export declare type GoslingSpec = (RootSpecWithSingleView & ResponsiveSpecOfSingleView) | (RootSpecWithMultipleViews & ResponsiveSpecOfMultipleViews);
export declare type ResponsiveSize = boolean | {
    width?: boolean;
    height?: boolean;
};
export declare type RootSpecWithSingleView = SingleView & {
    title?: string;
    subtitle?: string;
    description?: string;
    /** Determine whether to make the size of `GoslingComponent` bound to its parent element. __Default__: `false` */
    responsiveSize?: ResponsiveSize;
};
export interface RootSpecWithMultipleViews extends MultipleViews {
    title?: string;
    subtitle?: string;
    description?: string;
    /** Determine whether to make the size of `GoslingComponent` bound to its parent element. __Default__: `false` */
    responsiveSize?: ResponsiveSize;
}
export declare type View = SingleView | (MultipleViews & ResponsiveSpecOfMultipleViews);
export declare type SingleView = (OverlaidTracks | StackedTracks | FlatTracks) & ResponsiveSpecOfSingleView;
export declare type SelectivityCondition = {
    operation: LogicalOperation;
    /**
     * Does the condition applied to the visualization itself or its container? __Default__: `'self'`
     */
    target?: 'self' | 'container';
    measure: 'width' | 'height' | 'aspectRatio';
    /** Threshold in the unit of pixels. */
    threshold: number;
};
export declare type ResponsiveSpecOfSingleView = {
    responsiveSpec?: {
        spec: Partial<OverlaidTracks | StackedTracks>;
        selectivity: SelectivityCondition[];
    }[];
};
export interface FlatTracks extends CommonViewDef {
    tracks: Track[];
}
export declare type PartialTrack = Partial<Track>;
export interface StackedTracks extends CommonViewDef, Partial<SingleTrack> {
    alignment?: 'stack';
    tracks: (PartialTrack | OverlaidTracks)[];
}
export interface OverlaidTracks extends CommonViewDef, Partial<SingleTrack> {
    alignment: 'overlay';
    tracks: PartialTrack[];
}
export interface MultipleViews extends CommonViewDef {
    /**
     * Specify how multiple views are arranged.
     */
    arrangement?: 'parallel' | 'serial' | 'horizontal' | 'vertical';
    /** An array of view specifications */
    views: Array<SingleView | MultipleViews>;
    /** Internal: Used for responsive spec */
    _assignedWidth?: number;
    _assignedHeight?: number;
}
export declare type ResponsiveSpecOfMultipleViews = {
    responsiveSpec?: {
        spec: Partial<MultipleViews>;
        selectivity: SelectivityCondition[];
    }[];
};
export declare type Layout = 'linear' | 'circular';
export declare type Orientation = 'horizontal' | 'vertical';
/** Custom chromosome sizes, e.g., [["foo", 1000], ["bar", 300], ["baz", 240]] */
export declare type ChromSizes = [string, number][];
export declare type Assembly = 'hg38' | 'hg19' | 'hg18' | 'hg17' | 'hg16' | 'mm10' | 'mm9' | 'unknown' | ChromSizes;
export declare type ZoomLimits = [number | null, number | null];
export interface CommonViewDef {
    /** Specify the layout type of all tracks. */
    layout?: Layout;
    /** Specify the orientation. */
    orientation?: Orientation;
    /**
     * The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks.
     * The effect of this property depends on where on the spec you specify the `spacing`.
     *
     * In a linear layout, this value is used in pixels,
     * while in a circular layout, this value is used relative to the height of the tracks or views.
     */
    spacing?: number;
    /** Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning),
     * __Default:__ `false`.
     */
    static?: boolean;
    zoomLimits?: ZoomLimits;
    /** Specify the x offset of views in the unit of pixels */
    xOffset?: number;
    /** Specify the y offset of views in the unit of pixels */
    yOffset?: number;
    /**
     * A string that specifies the genome builds to use.
     * Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.
     *
     * __Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.
     */
    assembly?: Assembly;
    /** Specify the visible region of genomic x-axis */
    xDomain?: DomainInterval | DomainChrInterval | DomainChr;
    /** Specify the visible region of genomic y-axis */
    yDomain?: DomainInterval | DomainChrInterval | DomainChr;
    /** Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views) */
    linkingId?: string;
    /** not supported  */
    xAxis?: AxisPosition;
    /**
     * Proportion of the radius of the center white space.
     *
     * __Default:__ `0.3`
     * @Range [0, 1]
     */
    centerRadius?: number;
    /**
     * Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views.
     * Will be overwritten by the style of children elements (e.g., view, track).
     */
    style?: Style;
    /** Internal: Used for responsive spec */
    _assignedWidth?: number;
    _assignedHeight?: number;
}
export declare type Track = SingleTrack | OverlaidTrack | DataTrack | TemplateTrack;
export interface CommonTrackDef extends CommonViewDef {
    id?: string;
    /** If defined, will show the textual label on the left-top corner of a track. */
    title?: string;
    subtitle?: string;
    /** Specify the track width in pixels. */
    width?: number;
    /** Specify the track height in pixels. */
    height?: number;
    overlayOnPreviousTrack?: boolean;
    /**
     * Specify the outer radius of tracks when `{"layout": "circular"}`.
     */
    outerRadius?: number;
    /**
     * Specify the inner radius of tracks when (`{"layout": "circular"}`).
     */
    innerRadius?: number;
    /**
     * Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).
     */
    startAngle?: number;
    /**
     * Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).
     */
    endAngle?: number;
    /** internal */
    _renderingId?: string;
    /** internal */
    _invalidTrack?: boolean;
    /** internal */
    prerelease?: {};
}
/**
 * Partial specification of `BasicSingleTrack` to use default visual encoding predefined by data type.
 */
export interface DataTrack extends CommonTrackDef {
    data: DataDeep;
}
export declare type Mark = 'point' | 'line' | 'area' | 'bar' | 'rect' | 'text' | 'withinLink' | 'betweenLink' | 'rule' | 'triangleLeft' | 'triangleRight' | 'triangleBottom' | 'brush' | 'header';
interface CommonEventData {
    /** Source visualization ID, i.e., `track.id` */
    id: string;
    /** Values in a JSON array that represent data after data transformation */
    data: Datum[];
}
export interface GenomicPosition {
    chromosome: string;
    position: number;
}
interface PointMouseEventData extends CommonEventData {
    /** A genomic coordinate, e.g., `chr1:100,000`. */
    genomicPosition: GenomicPosition;
}
interface RangeMouseEventData extends CommonEventData {
    /** Start and end genomic coordinates. Null if a range is deselected. */
    genomicRange: [GenomicPosition, GenomicPosition] | null;
}
/**
 * The visual parameters that determine the shape of a linear track.
 * Origin is the left top corner.
 */
interface LinearTrackShape {
    x: number;
    y: number;
    width: number;
    height: number;
}
/** The visual parameters that determine the shape of a circular track */
interface CircularTrackShape {
    cx: number;
    cy: number;
    innerRadius: number;
    outerRadius: number;
    /** The first angle in the range of [0, 360]. The origin is 12 o'clock. Anticlockwise. */
    startAngle: number;
    /** The second angle in the range of [0, 360]. The origin is 12 o'clock. Anticlockwise. */
    endAngle: number;
}
/** The information for a track mouse event */
export declare type TrackMouseEventData = {
    /** ID of a source track, i.e., `track.id` */
    id: string;
    /** Expanded track specification processed by the Gosling compiler, e.g., default properties filled in. */
    spec: SingleTrack | OverlaidTrack;
    /** The shape of the source track */
    shape: LinearTrackShape | CircularTrackShape;
};
export declare type _EventMap = {
    mouseOver: PointMouseEventData;
    click: PointMouseEventData;
    rangeSelect: RangeMouseEventData;
    rawData: CommonEventData;
    trackMouseOver: TrackMouseEventData;
    trackClick: TrackMouseEventData;
};
/** Options for determining mouse events in detail, e.g., turning on specific events only */
export declare type MouseEventsDeep = {
    /** Whether to enable mouseover events. */
    mouseOver?: boolean;
    /** Whether to enable click events. */
    click?: boolean;
    /** Whether to send range selection events. */
    rangeSelect?: boolean;
    /** Group marks using keys in a data field. This affects how a set of marks are highlighted/selected by interaction. __Default__: `undefined` */
    groupMarksByField?: string;
    /** Determine whether all marks underneath the mouse point should be affected by mouse over. __Default__: `false` */
    enableMouseOverOnMultipleMarks?: boolean;
};
export declare type SingleTrack = SingleTrackBase & Encoding;
interface SingleTrackBase extends CommonTrackDef {
    data: DataDeep;
    dataTransform?: DataTransform[];
    tooltip?: Tooltip[];
    experimental?: {
        mouseEvents?: boolean | MouseEventsDeep;
        /**
         * Render visual marks with less smooth curves to increase rendering performance.
         * Only supported for `elliptical` `linkStyle` `withinLink` currently.
         * @default false
         */
        performanceMode?: boolean;
    };
    mark: Mark;
    displacement?: Displacement;
    visibility?: VisibilityCondition[];
    flipY?: boolean;
    baselineY?: number;
    stretch?: boolean;
    overrideTemplate?: boolean;
}
export interface Encoding {
    x?: X | ChannelValue;
    y?: Y | ChannelValue;
    xe?: X | ChannelValue;
    ye?: Y | ChannelValue;
    x1?: X | ChannelValue;
    y1?: Y | ChannelValue;
    x1e?: X | ChannelValue;
    y1e?: Y | ChannelValue;
    row?: Row | ChannelValue;
    color?: Color | ChannelValue;
    size?: Size | ChannelValue;
    text?: Text | ChannelValue;
    stroke?: Stroke | ChannelValue;
    strokeWidth?: StrokeWidth | ChannelValue;
    opacity?: Opacity | ChannelValue;
}
export interface Tooltip {
    /** Specifiy a data field whose value will show in the tooltip. */
    field: string;
    /** Type of the data field. */
    type: FieldType;
    /** Name of the data field for showing in the tooltip. Will use the field name if not specified. */
    alt?: string;
    /** format of the data value. */
    format?: string;
}
export interface Displacement {
    type: DisplacementType;
    padding?: number;
}
export declare type DisplacementType = 'pile' | 'spread';
/**
 * Superposing multiple tracks.
 */
export declare type OverlaidTrack = Partial<SingleTrack> & {
    overlay: Partial<Omit<SingleTrack, 'height' | 'width' | 'layout' | 'title' | 'subtitle'>>[];
};
/**
 * The styles defined here will be applied to the target marks of mouse events, such as a point mark after the user clicks on it.
 */
export interface EventStyle {
    /** color of the marks when mouse events are triggered */
    color?: string;
    /** stroke color of the marks when mouse events are triggered */
    stroke?: string;
    /** stroke width of the marks when mouse events are triggered */
    strokeWidth?: number;
    strokeOpacity?: number;
    /** opacity of the marks when mouse events are triggered */
    opacity?: number;
    /** Show event effects behind or in front of marks. */
    arrange?: 'behind' | 'front';
}
export interface Style {
    background?: string;
    backgroundOpacity?: number;
    outline?: string;
    outlineWidth?: number;
    /**
     * Whether to enable smooth paths when drawing curves.
     *
     * __Default__: `false`
     */
    enableSmoothPath?: boolean;
    /**
     * Specify the pattern of dashes and gaps for `rule` marks.
     */
    dashed?: [number, number];
    /**
     * Specify the pattern of dashes and gaps for `rule` marks.
     */
    linePattern?: {
        type: 'triangleLeft' | 'triangleRight';
        size: number;
    };
    /**
     * Specify the curve of `rule` marks.
     */
    curve?: 'top' | 'bottom' | 'left' | 'right';
    /**
     * Specify the alignment of marks.
     * This property is currently only supported for `triangle` marks.
     */
    align?: 'left' | 'right';
    /**
     * Offset the position of marks in x direction.
     * This property is currently only supported for `text` marks
     */
    dx?: number;
    /**
     * Offset the position of marks in y direction.
     * This property is currently only supported for `text` marks.
     */
    dy?: number;
    /**
     * The style of `withinLink` and `betweenLink` marks. __Default__: `'circular'`
     * `'elliptical'` will be used as a default option.
     */
    linkStyle?: 'elliptical' | 'circular' | 'straight';
    /**
     * The minimum height of `withinLink` and `betweenLink` marks. Unit is a percentagle. __Default__: `0.5`
     * @Range [0, 1]
     */
    linkMinHeight?: number;
    /**
     * Specify whether to show legend in a single horizontal line?
     */
    inlineLegend?: boolean;
    /**
     * If defined, show legend title on the top or left
     */
    legendTitle?: string;
    /**
     * Specify the font size of `text` marks.
     * Can also be specified using the `size` channel option of `text` marks.
     */
    textFontSize?: number;
    /**
     * Specify the stroke of `text` marks.
     * Can also be specified using the `stroke` channel option of `text` marks.
     */
    textStroke?: string;
    /**
     * Specify the stroke width of `text` marks.
     * Can also be specified using the `strokeWidth` channel option of `text` marks.
     */
    textStrokeWidth?: number;
    /** Specify the font weight of `text` marks. */
    textFontWeight?: 'bold' | 'normal';
    /** Specify the alignment of `text` marks to a given point.
     */
    textAnchor?: 'start' | 'middle' | 'end';
    /** Specify the connetion type of `betweenLink` marks.
     *
     * __Default__: `"corner"`
     */
    linkConnectionType?: 'straight' | 'curve' | 'corner';
    /**
     * Determine to show only one side of the diagonal in a HiGlass matrix. __Default__: `"full"`
     */
    matrixExtent?: 'full' | 'upper-right' | 'lower-left';
    /**
     * Customize visual effects of `mouseOver` events on marks.
     */
    mouseOver?: EventStyle;
    /**
     * Customize visual effects of `rangeSelect` events on marks .
     */
    select?: EventStyle;
    /**
     * Customize the style of the brush mark in the `rangeSelect` mouse event.
     */
    brush?: Omit<EventStyle, 'arrange'>;
}
export declare type VisibilityCondition = SizeVisibilityCondition | ZoomLevelVisibilityCondition;
interface CommonVisibilityCondition {
    /**
     * A string that specifies the logical operation to conduct between `threshold` and the `measure` of `target`.
     * Support
     *
     * - greater than : "greater-than", "gt", "GT"
     *
     * - less than : "less-than", "lt", "LT"
     *
     * - greater than or equal to : "greater-than-or-equal-to", "gtet", "GTET"
     *
     * - less than or equal to : "less-than-or-equal-to", "ltet", "LTET"
     */
    operation: LogicalOperation;
    /**
     * Specify the buffer size (in pixel) of width or height when calculating the visibility.
     *
     * __Default__: `0`
     */
    conditionPadding?: number;
    /**
     * Specify the buffer size (in pixel) of width or height for smooth transition.
     *
     * __Default__: `0`
     */
    transitionPadding?: number;
}
export interface SizeVisibilityCondition extends CommonVisibilityCondition {
    /**
     * Target specifies the object that you want to compare with the threshold.
     */
    target: 'track' | 'mark';
    /**
     * Specify which aspect of the `target` will be compared to the `threshold`.
     */
    measure: 'width' | 'height';
    /**
     * Specify the threshold as one of:
     *
     * - A number representing a fixed threshold in the unit of pixels;
     *
     * - `"|xe-x|"`, using the distance between `xe` and `x` as threshold
     */
    threshold: number | '|xe-x|';
}
export interface ZoomLevelVisibilityCondition extends CommonVisibilityCondition {
    /**
     * Target specifies the object that you want to compare with the threshold.
     */
    target: 'track' | 'mark';
    /**
     * Specify which aspect of the `target` will be compared to the `threshold`.
     */
    measure: 'zoomLevel';
    /**
     * Set a threshold in the unit of base pairs (bp)
     */
    threshold: number;
}
export declare type LogicalOperation = 'less-than' | 'lt' | 'LT' | 'greater-than' | 'gt' | 'GT' | 'less-than-or-equal-to' | 'ltet' | 'LTET' | 'greater-than-or-equal-to' | 'gtet' | 'GTET';
export declare const ChannelTypes: {
    readonly x: "x";
    readonly y: "y";
    readonly xe: "xe";
    readonly ye: "ye";
    readonly x1: "x1";
    readonly y1: "y1";
    readonly x1e: "x1e";
    readonly y1e: "y1e";
    readonly color: "color";
    readonly row: "row";
    readonly opacity: "opacity";
    readonly stroke: "stroke";
    readonly strokeWidth: "strokeWidth";
    readonly size: "size";
    readonly text: "text";
};
export declare type ChannelType = keyof typeof ChannelTypes | string;
export declare type Channel = ChannelDeep | ChannelValue;
export interface AxisCommon {
    /** Name of the data field. */
    field?: string;
    /** Specify the data type. */
    type?: 'quantitative' | 'nominal' | 'genomic';
    /** Values of the data */
    domain?: ValueExtent | GenomicDomain;
    /** Values of the visual channel. */
    range?: ValueExtent;
    /** Specify where should the axis be put  */
    axis?: AxisPosition;
    /** Whether to display legend. __Default__: `false` */
    legend?: boolean;
    /** Users need to assign a unique linkingId for [linking views](/docs/user-interaction#linking-views) and [Brushing and Linking](/docs/user-interaction#brushing-and-linking) */
    linkingId?: string;
    /** Specify how to aggregate data. __Default__: `undefined` */
    aggregate?: Aggregate;
    /** Whether to display grid. __Default__: `false` */
    grid?: boolean;
}
export interface X extends AxisCommon {
    type?: 'genomic';
    domain?: GenomicDomain;
}
export interface Y extends AxisCommon {
    /** Custom baseline of the y-axis. __Default__: `0` */
    baseline?: string | number;
    /** Specify whether to use zero baseline. __Default__: `true`  */
    zeroBaseline?: boolean;
    /** Whether to flip the y-axis. This is done by inverting the `range` property. __Default__: `false` */
    flip?: boolean;
}
export interface ChannelDeepCommon {
    /** Name of the data field */
    field?: string;
    /** Specify the data type */
    type?: 'quantitative' | 'nominal' | 'genomic';
    /** Values of the data */
    domain?: ValueExtent;
    /** Ranges of visual channel values */
    range?: ValueExtent | Range;
}
export interface Row extends ChannelDeepCommon {
    type?: 'nominal';
    domain?: ValueExtent;
    /** Determine the start and end position of rendering area of this track along vertical axis. __Default__: `[0, height]` */
    range?: ValueExtent;
    /** Whether to display legend. __Default__: `false` */
    legend?: boolean;
    /** Determines the size of inner white spaces on the top and bottom of individiual rows. __Default__: `0` */
    padding?: number;
    /** Whether to display grid. __Default__: `false` */
    grid?: boolean;
    /** Clip row when the actual y value exceeds the max value of the y scale. Used only for bar marks at the moment. __Default__: `true` */
    clip?: boolean;
}
export interface Color extends ChannelDeepCommon {
    type?: 'quantitative' | 'nominal';
    domain?: ValueExtent;
    /** Determine the colors that should be bound to data value. Default properties are determined considering the field type. */
    range?: Range;
    /** Title of the legend. __Default__: `undefined` */
    title?: string;
    /** Whether to display legend. __Default__: `false` */
    legend?: boolean;
    scale?: 'linear' | 'log';
    /** Whether to use offset of the domain proportionally. This is bound to brushes on the color legend. __Default__: `[0, 1]` */
    scaleOffset?: [number, number];
}
export interface Stroke extends ChannelDeepCommon {
    type?: 'quantitative' | 'nominal';
    domain?: ValueExtent;
    range?: Range;
    /** Title of the legend. __Default__: `undefined` */
    title?: string;
    /** Whether to display legend. __Default__: `false` */
    legend?: boolean;
    /** Whether to use offset of the domain proportionally. This is bound to brushes on the color legend. __Default__: `[0, 1]` */
    scaleOffset?: [number, number];
}
export interface StrokeWidth extends ChannelDeepCommon {
    type?: 'quantitative' | 'nominal';
    domain?: ValueExtent;
    range?: ValueExtent;
}
export interface Size extends ChannelDeepCommon {
    type?: 'quantitative' | 'nominal';
    domain?: ValueExtent;
    range?: ValueExtent;
    /** not supported: Whether to display legend. __Default__: `false` */
    legend?: boolean;
}
export interface Opacity extends ChannelDeepCommon {
    type?: 'quantitative' | 'nominal';
    domain?: ValueExtent;
    range?: ValueExtent;
}
export interface Text extends Omit<ChannelDeepCommon, 'baseline'> {
    type?: 'quantitative' | 'nominal';
    domain?: string[];
    range?: string[];
}
export declare type ChannelDeep = X | Y | Row | Color | Size | Stroke | StrokeWidth | Opacity | Text;
export interface ChannelValue {
    /** Assign a constant value for a visual channel. */
    value: number | string;
}
export declare type AxisPosition = 'none' | 'top' | 'bottom' | 'left' | 'right';
export declare type FieldType = 'genomic' | 'nominal' | 'quantitative';
export declare type ValueExtent = string[] | number[];
export declare type GenomicDomain = DomainInterval | DomainChrInterval | DomainChr;
export declare type Domain = ValueExtent | GenomicDomain;
export declare type Range = ValueExtent | PredefinedColors;
export declare type PredefinedColors = 'viridis' | 'grey' | 'spectral' | 'warm' | 'cividis' | 'bupu' | 'rdbu' | 'hot' | 'pink';
export interface DomainChr {
    chromosome: string;
}
export interface DomainChrInterval {
    /** If specified, only showing a certain interval in a chromosome. */
    chromosome: string;
    interval: [number, number];
}
export interface DomainInterval {
    /** Show a certain interval within entire chromosome */
    interval: [number, number];
}
export declare type Aggregate = 'max' | 'min' | 'mean' | 'bin' | 'count';
export declare type BinAggregate = 'mean' | 'sum';
export declare type DataDeep = JsonData | CsvData | BigWigData | MultivecData | BeddbData | VectorData | MatrixData | BamData | VcfData;
/** Values in the form of JSON. */
export interface Datum {
    [k: string]: number | string;
}
/**
 * The JSON data format allows users to include data directly in the Gosling's JSON specification.
 */
export interface JsonData {
    /**
     * Define data type.
     */
    type: 'json';
    /** Values in the form of JSON. */
    values: Datum[];
    /** Specify the name of chromosome data fields. */
    chromosomeField?: string;
    /** Specify the name of genomic data fields. */
    genomicFields?: string[];
    /** Specify the number of rows loaded from the URL.
     *
     * __Default:__ `1000`
     */
    sampleLength?: number;
    /** experimental */
    genomicFieldsToConvert?: {
        chromosomeField: string;
        genomicFields: string[];
    }[];
}
/**
 * Any small enough tabular data files, such as tsv, csv, BED, BEDPE, and GFF, can be loaded using "csv" data specification.
 */
export interface CsvData {
    type: 'csv';
    /**
     * Specify the URL address of the data file.
     */
    url: string;
    /**
     * Specify file separator, __Default:__ ','
     */
    separator?: string;
    /**
     * Specify the name of chromosome data fields.
     */
    chromosomeField?: string;
    /**
     * Specify the name of genomic data fields.
     */
    genomicFields?: string[];
    /**
     * Specify the number of rows loaded from the URL.
     *
     * __Default:__ `1000`
     */
    sampleLength?: number;
    /**
     * Specify the names of data fields if a CSV file does not contain a header.
     */
    headerNames?: string[];
    /**
     * experimental
     */
    chromosomePrefix?: string;
    /**
     * experimental
     */
    longToWideId?: string;
    /**
     * experimental
     */
    genomicFieldsToConvert?: {
        chromosomeField: string;
        genomicFields: string[];
    }[];
}
/**
 * Two-dimensional quantitative values,
 * one axis for genomic coordinate and the other for different samples, can be converted into HiGlass' `"multivec"` data.
 * For example, multiple BigWig files can be converted into a single multivec file.
 * You can also convert sequence data (FASTA) into this format where rows will be different nucleotide bases (e.g., A, T, G, C)
 * and quantitative values represent the frequency. Find out more about this format at [HiGlass Docs](https://docs.higlass.io/data_preparation.html#multivec-files).
 */
export interface MultivecData {
    type: 'multivec';
    /**
     * Specify the URL address of the data file.
     */
    url: string;
    /**
     * Assign a field name of the middle position of genomic intervals. __Default__: `"position"`
     */
    column?: string;
    /**
     * Assign a field name of samples. __Default__: `"category"`
     */
    row?: string;
    /**
     * Assign a field name of quantitative values. __Default__: `"value"`
     */
    value?: string;
    /**
     *  assign names of individual samples.
     */
    categories?: string[];
    /**
     * Assign a field name of the start position of genomic intervals. __Default__: `"start"`
     */
    start?: string;
    /**
     * Assign a field name of the end position of genomic intervals. __Default__: `"end"`
     */
    end?: string;
    /**
     * Binning the genomic interval in tiles (unit size: 256).
     */
    binSize?: number;
    /** Determine aggregation function to apply within bins. __Default__: `"mean"` */
    aggregation?: BinAggregate;
}
export interface BigWigData {
    type: 'bigwig';
    /**
     * Specify the URL address of the data file.
     */
    url: string;
    /**
     * Assign a field name of the middle position of genomic intervals. __Default__: `"position"`
     */
    column?: string;
    /**
     * Assign a field name of quantitative values. __Default__: `"value"`
     */
    value?: string;
    /**
     * Assign a field name of the start position of genomic intervals. __Default__: `"start"`
     */
    start?: string;
    /**
     * Assign a field name of the end position of genomic intervals. __Default__: `"end"`
     */
    end?: string;
    /**
     * Binning the genomic interval in tiles (unit size: 256).
     */
    binSize?: number;
    /** Determine aggregation function to apply within bins. __Default__: `"mean"` */
    aggregation?: BinAggregate;
}
/**
 * One-dimensional quantitative values along genomic position (e.g., bigwig) can be converted into HiGlass' `"vector"` format data.
 * Find out more about this format at [HiGlass Docs](https://docs.higlass.io/data_preparation.html#bigwig-files).
 */
export interface VectorData {
    type: 'vector';
    /**
     * Specify the URL address of the data file.
     */
    url: string;
    /** Assign a field name of the middle position of genomic intervals. __Default__: `"position"` */
    column?: string;
    /** Assign a field name of quantitative values. __Default__: `"value"` */
    value?: string;
    /** Assign a field name of the start position of genomic intervals. __Default__: `"start"` */
    start?: string;
    /** Assign a field name of the end position of genomic intervals. __Default__: `"end"` */
    end?: string;
    /** Binning the genomic interval in tiles (unit size: 256). */
    binSize?: number;
    /** Determine aggregation function to apply within bins. __Default__: `"mean"` */
    aggregation?: BinAggregate;
}
/**
 * Regular BED or similar files can be pre-aggregated for the scalable data exploration.
 * Find our more about this format at [HiGlass Docs](https://docs.higlass.io/data_preparation.html#bed-files).
 */
export interface BeddbData {
    type: 'beddb';
    /** Specify the URL address of the data file. */
    url: string;
    /** Specify the name of genomic data fields. */
    genomicFields: {
        index: number;
        name: string;
    }[];
    /** Specify the column indexes, field names, and field types. */
    valueFields?: {
        index: number;
        name: string;
        type: 'nominal' | 'quantitative';
    }[];
    /** experimental */
    exonIntervalFields?: [{
        index: number;
        name: string;
    }, {
        index: number;
        name: string;
    }];
}
/**
 * Binary Alignment Map (BAM) is the comprehensive raw data of genome sequencing;
 * it consists of the lossless, compressed binary representation of the Sequence Alignment Map-files.
 */
export interface BamData {
    type: 'bam';
    /** URL link to the BAM data file */
    url: string;
    /** URL link to the index file of the BAM file */
    indexUrl: string;
    /** Load mates that are located in the same chromosome. __Default__: `false` */
    loadMates?: boolean;
    /** Determine whether to extract exon-to-exon junctions. __Default__: `false` */
    extractJunction?: boolean;
    /** Determine the threshold of coverage when extracting exon-to-exon junctions. __Default__: `1` */
    junctionMinCoverage?: number;
    /** Determines the threshold of insert sizes for determining the structural variants. __Default__: `5000` */
    maxInsertSize?: number;
}
/**
 * The Variant Call Format (VCF).
 */
export interface VcfData {
    type: 'vcf';
    /** URL link to the VCF file */
    url: string;
    /** URL link to the tabix index file */
    indexUrl: string;
    /** The maximum number of rows to be loaded from the URL. __Default:__ `1000` */
    sampleLength?: number;
}
export interface MatrixData {
    type: 'matrix';
    /** URL link to the matrix data file */
    url: string;
    /** The name of the first genomic field. __Default__: `x` */
    column?: string;
    /** The name of the first genomic field. __Default__: `y` */
    row?: string;
    /** The name of the value field. __Default__: `value` */
    value?: string;
    /** Determine the number of nearby cells to aggregate. __Default__: `1` */
    binSize?: number;
}
export declare type DataTransform = FilterTransform | StrConcatTransform | StrReplaceTransform | LogTransform | DisplaceTransform | ExonSplitTransform | GenomicLengthTransform | SvTypeTransform | CoverageTransform | JsonParseTransform;
export declare type FilterTransform = OneOfFilter | RangeFilter | IncludeFilter;
interface CommonFilterTransform {
    type: 'filter';
    /** A filter is applied based on the values of the specified data field */
    field: string;
    /**
     * when `{"not": true}`, apply a NOT logical operation to the filter.
     *
     * __Default:__ `false` */
    not?: boolean;
}
export interface RangeFilter extends CommonFilterTransform {
    /** Check whether the value is in a number range. */
    inRange: number[];
}
export interface IncludeFilter extends CommonFilterTransform {
    /** Check whether the value includes a substring. */
    include: string;
}
export interface OneOfFilter extends CommonFilterTransform {
    /** Check whether the value is an element in the provided list. */
    oneOf: (string | number | null)[];
}
export interface ComparisonFilter extends CommonFilterTransform {
    /**
     * The second field to compare the value with.
     */
    field2: string;
    /**
     * A logical operation to apply between two fields.
     */
    operation: LogicalOperation;
    not: undefined;
}
export declare type LogBase = number | 'e';
export interface LogTransform {
    type: 'log';
    field: string;
    /** If not specified, 10 is used. */
    base?: LogBase;
    /** If specified, store transformed values in a new field. */
    newField?: string;
}
export interface StrConcatTransform {
    type: 'concat';
    fields: string[];
    newField: string;
    separator: string;
}
export interface StrReplaceTransform {
    type: 'replace';
    field: string;
    newField: string;
    replace: {
        from: string;
        to: string;
    }[];
}
export interface DisplaceTransform {
    type: 'displace';
    boundingBox: {
        /** The name of a quantitative field that represents the start position. */
        startField: string;
        /** The name of a quantitative field that represents the end position. */
        endField: string;
        /** The padding around visual lements. Either px or bp */
        padding?: number;
        /** Whether to consider `padding` as the bp length. */
        isPaddingBP?: boolean;
        /** The name of a nominal field to group rows by in prior to piling-up. */
        groupField?: string;
    };
    /** A string that specifies the type of displacement.  */
    method: DisplacementType;
    newField: string;
    /** Specify maximum rows to be generated (default has no limit). */
    maxRows?: number;
}
export interface ExonSplitTransform {
    type: 'exonSplit';
    separator: string;
    flag: {
        field: string;
        value: number | string;
    };
    fields: {
        field: string;
        type: FieldType;
        newField: string;
        chrField: string;
    }[];
}
/**
 * Calculate genomic length using two genomic fields
 */
export interface GenomicLengthTransform {
    type: 'genomicLength';
    startField: string;
    endField: string;
    newField: string;
}
/**
 * Based on the BEDPE, infer SV types.
 * SV types are specified as one of the following strings: DUP, TRA, DEL, t2tINV, h2hINV.
 */
declare type BpFields = {
    chrField: string;
    posField: string;
    strandField: string;
};
export interface SvTypeTransform {
    type: 'svType';
    firstBp: BpFields;
    secondBp: BpFields;
    newField: string;
}
/**
 * Aggregate rows and calculate coverage
 */
export interface CoverageTransform {
    type: 'coverage';
    startField: string;
    endField: string;
    newField?: string;
    /** The name of a nominal field to group rows by in prior to piling-up */
    groupField?: string;
}
/**
 * Parse JSON Object Array and append vertically
 */
export interface JsonParseTransform {
    type: 'subjson';
    /** The field that contains the JSON object array. */
    field: string;
    /** Base genomic position when parsing relative position. */
    baseGenomicField: string;
    /** Relative genomic position to parse. */
    genomicField: string;
    /** Length of genomic interval. */
    genomicLengthField: string;
}
/**
 * Template specification that will be internally converted into `SingleTrack` for rendering.
 */
export interface TemplateTrack extends CommonTrackDef {
    template: string;
    data: DataDeep;
    encoding?: {
        [k: string]: Channel;
    };
}
/**
 * Definition of Track Templates.
 */
export interface TemplateTrackDef {
    name: string;
    channels: CustomChannelDef[];
    mapping: TemplateTrackMappingDef[];
}
/**
 * Definition of custom channels used in a track template.
 */
export interface CustomChannelDef {
    name: string;
    type: FieldType | 'value';
    required?: boolean;
}
export declare type DataTransformWithBase = Partial<DataTransform> & {
    base?: string;
};
/**
 * This is based on `SingleTrack` but the differences are only the type of channels
 * which additionally have `base` properties to override properties from a template spec
 * and remove of certain properties (e.g., `data`)
 */
export declare type TemplateTrackMappingDef = Omit<CommonTrackDef, 'data' | 'height' | 'width' | 'layout' | 'title' | 'subtitle'> & {
    dataTransform?: DataTransformWithBase[];
    tooltip?: Tooltip[];
    mark: Mark;
    x?: ChannelWithBase;
    y?: ChannelWithBase;
    xe?: ChannelWithBase;
    ye?: ChannelWithBase;
    x1?: ChannelWithBase;
    y1?: ChannelWithBase;
    x1e?: ChannelWithBase;
    y1e?: ChannelWithBase;
    row?: ChannelWithBase;
    color?: ChannelWithBase;
    size?: ChannelWithBase;
    text?: ChannelWithBase;
    stroke?: ChannelWithBase;
    strokeWidth?: ChannelWithBase;
    opacity?: ChannelWithBase;
    displacement?: Displacement;
    visibility?: VisibilityCondition[];
    flipY?: boolean;
    stretch?: boolean;
    overrideTemplate?: boolean;
};
export declare type ChannelWithBase = Channel & {
    base?: string;
};
export {};
//# sourceMappingURL=gosling.schema.d.ts.map