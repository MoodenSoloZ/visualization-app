import * as PIXI from "pixi.js";
import { color } from "d3-color";
import { group, max as max$1, min as min$1, sum, bisector } from "d3-array";
import { Bezier } from "bezier-js";
import { scaleLinear, scaleSequential, scaleOrdinal, scaleBand } from "d3-scale";
import { isUndefined, isArray as isArray$1, sampleSize, isEqual, uniqBy } from "lodash-es";
import { interpolateViridis, interpolateGreys, interpolateWarm, interpolateSpectral, interpolateCividis, interpolateBuPu, interpolateRdBu, interpolateYlOrBr, interpolateRdPu } from "d3-scale-chromatic";
import higlassRegister from "higlass-register";
import { TextTrack } from "higlass-text";
import RBush from "rbush";
import { arc } from "d3-shape";
import * as gt from "gosling-theme";
import { getTheme as getTheme$1 } from "gosling-theme";
import PubSub$1 from "pubsub-js";
import { spawn } from "threads";
import require$$0, { Buffer as Buffer$2 } from "buffer";
import { unzlibSync } from "fflate";
import require$$9 from "quick-lru";
import require$$7, { RemoteFile as RemoteFile$1 } from "generic-filehandle";
import { dsvFormat } from "d3-dsv";
import { createNanoEvents } from "nanoevents";
import React, { forwardRef, useState, useEffect, useMemo, useRef, useImperativeHandle, useCallback } from "react";
import ReactDOM from "react-dom";
import { HiGlassComponent } from "higlass";
const $ref$2 = "#/definitions/GoslingSpec";
const $schema$4 = "http://json-schema.org/draft-07/schema#";
const definitions$3 = {
  Aggregate: {
    "enum": [
      "max",
      "min",
      "mean",
      "bin",
      "count"
    ],
    type: "string"
  },
  Assembly: {
    anyOf: [
      {
        "const": "hg38",
        type: "string"
      },
      {
        "const": "hg19",
        type: "string"
      },
      {
        "const": "hg18",
        type: "string"
      },
      {
        "const": "hg17",
        type: "string"
      },
      {
        "const": "hg16",
        type: "string"
      },
      {
        "const": "mm10",
        type: "string"
      },
      {
        "const": "mm9",
        type: "string"
      },
      {
        "const": "unknown",
        type: "string"
      },
      {
        $ref: "#/definitions/ChromSizes"
      }
    ]
  },
  AxisPosition: {
    "enum": [
      "none",
      "top",
      "bottom",
      "left",
      "right"
    ],
    type: "string"
  },
  BamData: {
    additionalProperties: false,
    description: "Binary Alignment Map (BAM) is the comprehensive raw data of genome sequencing; it consists of the lossless, compressed binary representation of the Sequence Alignment Map-files.",
    properties: {
      extractJunction: {
        description: "Determine whether to extract exon-to-exon junctions. __Default__: `false`",
        type: "boolean"
      },
      indexUrl: {
        description: "URL link to the index file of the BAM file",
        type: "string"
      },
      junctionMinCoverage: {
        description: "Determine the threshold of coverage when extracting exon-to-exon junctions. __Default__: `1`",
        type: "number"
      },
      loadMates: {
        description: "Load mates that are located in the same chromosome. __Default__: `false`",
        type: "boolean"
      },
      maxInsertSize: {
        description: "Determines the threshold of insert sizes for determining the structural variants. __Default__: `5000`",
        type: "number"
      },
      type: {
        "const": "bam",
        type: "string"
      },
      url: {
        description: "URL link to the BAM data file",
        type: "string"
      }
    },
    required: [
      "type",
      "url",
      "indexUrl"
    ],
    type: "object"
  },
  BeddbData: {
    additionalProperties: false,
    description: "Regular BED or similar files can be pre-aggregated for the scalable data exploration. Find our more about this format at [HiGlass Docs](https://docs.higlass.io/data_preparation.html#bed-files).",
    properties: {
      exonIntervalFields: {
        description: "experimental",
        items: [
          {
            additionalProperties: false,
            properties: {
              index: {
                type: "number"
              },
              name: {
                type: "string"
              }
            },
            required: [
              "index",
              "name"
            ],
            type: "object"
          },
          {
            additionalProperties: false,
            properties: {
              index: {
                type: "number"
              },
              name: {
                type: "string"
              }
            },
            required: [
              "index",
              "name"
            ],
            type: "object"
          }
        ],
        maxItems: 2,
        minItems: 2,
        type: "array"
      },
      genomicFields: {
        description: "Specify the name of genomic data fields.",
        items: {
          additionalProperties: false,
          properties: {
            index: {
              type: "number"
            },
            name: {
              type: "string"
            }
          },
          required: [
            "index",
            "name"
          ],
          type: "object"
        },
        type: "array"
      },
      type: {
        "const": "beddb",
        type: "string"
      },
      url: {
        description: "Specify the URL address of the data file.",
        type: "string"
      },
      valueFields: {
        description: "Specify the column indexes, field names, and field types.",
        items: {
          additionalProperties: false,
          properties: {
            index: {
              type: "number"
            },
            name: {
              type: "string"
            },
            type: {
              "enum": [
                "nominal",
                "quantitative"
              ],
              type: "string"
            }
          },
          required: [
            "index",
            "name",
            "type"
          ],
          type: "object"
        },
        type: "array"
      }
    },
    required: [
      "type",
      "url",
      "genomicFields"
    ],
    type: "object"
  },
  BigWigData: {
    additionalProperties: false,
    properties: {
      aggregation: {
        $ref: "#/definitions/BinAggregate",
        description: 'Determine aggregation function to apply within bins. __Default__: `"mean"`'
      },
      binSize: {
        description: "Binning the genomic interval in tiles (unit size: 256).",
        type: "number"
      },
      column: {
        description: 'Assign a field name of the middle position of genomic intervals. __Default__: `"position"`',
        type: "string"
      },
      end: {
        description: 'Assign a field name of the end position of genomic intervals. __Default__: `"end"`',
        type: "string"
      },
      start: {
        description: 'Assign a field name of the start position of genomic intervals. __Default__: `"start"`',
        type: "string"
      },
      type: {
        "const": "bigwig",
        type: "string"
      },
      url: {
        description: "Specify the URL address of the data file.",
        type: "string"
      },
      value: {
        description: 'Assign a field name of quantitative values. __Default__: `"value"`',
        type: "string"
      }
    },
    required: [
      "type",
      "url"
    ],
    type: "object"
  },
  BinAggregate: {
    "enum": [
      "mean",
      "sum"
    ],
    type: "string"
  },
  Channel: {
    anyOf: [
      {
        $ref: "#/definitions/ChannelDeep"
      },
      {
        $ref: "#/definitions/ChannelValue"
      }
    ]
  },
  ChannelDeep: {
    anyOf: [
      {
        $ref: "#/definitions/X"
      },
      {
        $ref: "#/definitions/Y"
      },
      {
        $ref: "#/definitions/Row"
      },
      {
        $ref: "#/definitions/Color"
      },
      {
        $ref: "#/definitions/Size"
      },
      {
        $ref: "#/definitions/Stroke"
      },
      {
        $ref: "#/definitions/StrokeWidth"
      },
      {
        $ref: "#/definitions/Opacity"
      },
      {
        $ref: "#/definitions/Text"
      }
    ]
  },
  ChannelValue: {
    additionalProperties: false,
    properties: {
      value: {
        description: "Assign a constant value for a visual channel.",
        type: [
          "number",
          "string"
        ]
      }
    },
    required: [
      "value"
    ],
    type: "object"
  },
  ChromSizes: {
    description: 'Custom chromosome sizes, e.g., [["foo", 1000], ["bar", 300], ["baz", 240]]',
    items: {
      items: [
        {
          type: "string"
        },
        {
          type: "number"
        }
      ],
      maxItems: 2,
      minItems: 2,
      type: "array"
    },
    type: "array"
  },
  Color: {
    additionalProperties: false,
    properties: {
      domain: {
        $ref: "#/definitions/ValueExtent",
        description: "Values of the data"
      },
      field: {
        description: "Name of the data field",
        type: "string"
      },
      legend: {
        description: "Whether to display legend. __Default__: `false`",
        type: "boolean"
      },
      range: {
        $ref: "#/definitions/Range",
        description: "Determine the colors that should be bound to data value. Default properties are determined considering the field type."
      },
      scale: {
        "enum": [
          "linear",
          "log"
        ],
        type: "string"
      },
      scaleOffset: {
        description: "Whether to use offset of the domain proportionally. This is bound to brushes on the color legend. __Default__: `[0, 1]`",
        items: {
          type: "number"
        },
        maxItems: 2,
        minItems: 2,
        type: "array"
      },
      title: {
        description: "Title of the legend. __Default__: `undefined`",
        type: "string"
      },
      type: {
        description: "Specify the data type",
        "enum": [
          "quantitative",
          "nominal"
        ],
        type: "string"
      }
    },
    type: "object"
  },
  CoverageTransform: {
    additionalProperties: false,
    description: "Aggregate rows and calculate coverage",
    properties: {
      endField: {
        type: "string"
      },
      groupField: {
        description: "The name of a nominal field to group rows by in prior to piling-up",
        type: "string"
      },
      newField: {
        type: "string"
      },
      startField: {
        type: "string"
      },
      type: {
        "const": "coverage",
        type: "string"
      }
    },
    required: [
      "type",
      "startField",
      "endField"
    ],
    type: "object"
  },
  CsvData: {
    additionalProperties: false,
    description: 'Any small enough tabular data files, such as tsv, csv, BED, BEDPE, and GFF, can be loaded using "csv" data specification.',
    properties: {
      chromosomeField: {
        description: "Specify the name of chromosome data fields.",
        type: "string"
      },
      chromosomePrefix: {
        description: "experimental",
        type: "string"
      },
      genomicFields: {
        description: "Specify the name of genomic data fields.",
        items: {
          type: "string"
        },
        type: "array"
      },
      genomicFieldsToConvert: {
        description: "experimental",
        items: {
          additionalProperties: false,
          properties: {
            chromosomeField: {
              type: "string"
            },
            genomicFields: {
              items: {
                type: "string"
              },
              type: "array"
            }
          },
          required: [
            "chromosomeField",
            "genomicFields"
          ],
          type: "object"
        },
        type: "array"
      },
      headerNames: {
        description: "Specify the names of data fields if a CSV file does not contain a header.",
        items: {
          type: "string"
        },
        type: "array"
      },
      longToWideId: {
        description: "experimental",
        type: "string"
      },
      sampleLength: {
        description: "Specify the number of rows loaded from the URL.\n\n__Default:__ `1000`",
        type: "number"
      },
      separator: {
        description: "Specify file separator, __Default:__ ','",
        type: "string"
      },
      type: {
        "const": "csv",
        type: "string"
      },
      url: {
        description: "Specify the URL address of the data file.",
        type: "string"
      }
    },
    required: [
      "type",
      "url"
    ],
    type: "object"
  },
  DataDeep: {
    anyOf: [
      {
        $ref: "#/definitions/JsonData"
      },
      {
        $ref: "#/definitions/CsvData"
      },
      {
        $ref: "#/definitions/BigWigData"
      },
      {
        $ref: "#/definitions/MultivecData"
      },
      {
        $ref: "#/definitions/BeddbData"
      },
      {
        $ref: "#/definitions/VectorData"
      },
      {
        $ref: "#/definitions/MatrixData"
      },
      {
        $ref: "#/definitions/BamData"
      },
      {
        $ref: "#/definitions/VcfData"
      }
    ]
  },
  DataTrack: {
    additionalProperties: false,
    description: "Partial specification of `BasicSingleTrack` to use default visual encoding predefined by data type.",
    properties: {
      _assignedHeight: {
        type: "number"
      },
      _assignedWidth: {
        description: "Internal: Used for responsive spec",
        type: "number"
      },
      _invalidTrack: {
        description: "internal",
        type: "boolean"
      },
      _renderingId: {
        description: "internal",
        type: "string"
      },
      assembly: {
        $ref: "#/definitions/Assembly",
        description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
      },
      centerRadius: {
        description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
        type: "number"
      },
      data: {
        $ref: "#/definitions/DataDeep"
      },
      endAngle: {
        description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      height: {
        description: "Specify the track height in pixels.",
        type: "number"
      },
      id: {
        type: "string"
      },
      innerRadius: {
        description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
        type: "number"
      },
      layout: {
        $ref: "#/definitions/Layout",
        description: "Specify the layout type of all tracks."
      },
      linkingId: {
        description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
        type: "string"
      },
      orientation: {
        $ref: "#/definitions/Orientation",
        description: "Specify the orientation."
      },
      outerRadius: {
        description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
        type: "number"
      },
      overlayOnPreviousTrack: {
        type: "boolean"
      },
      prerelease: {
        additionalProperties: false,
        description: "internal",
        type: "object"
      },
      spacing: {
        description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
        type: "number"
      },
      startAngle: {
        description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      "static": {
        description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
        type: "boolean"
      },
      style: {
        $ref: "#/definitions/Style",
        description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
      },
      subtitle: {
        type: "string"
      },
      title: {
        description: "If defined, will show the textual label on the left-top corner of a track.",
        type: "string"
      },
      width: {
        description: "Specify the track width in pixels.",
        type: "number"
      },
      xAxis: {
        $ref: "#/definitions/AxisPosition",
        description: "not supported"
      },
      xDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic x-axis"
      },
      xOffset: {
        description: "Specify the x offset of views in the unit of pixels",
        type: "number"
      },
      yDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic y-axis"
      },
      yOffset: {
        description: "Specify the y offset of views in the unit of pixels",
        type: "number"
      },
      zoomLimits: {
        $ref: "#/definitions/ZoomLimits"
      }
    },
    required: [
      "data"
    ],
    type: "object"
  },
  DataTransform: {
    anyOf: [
      {
        $ref: "#/definitions/FilterTransform"
      },
      {
        $ref: "#/definitions/StrConcatTransform"
      },
      {
        $ref: "#/definitions/StrReplaceTransform"
      },
      {
        $ref: "#/definitions/LogTransform"
      },
      {
        $ref: "#/definitions/DisplaceTransform"
      },
      {
        $ref: "#/definitions/ExonSplitTransform"
      },
      {
        $ref: "#/definitions/GenomicLengthTransform"
      },
      {
        $ref: "#/definitions/SvTypeTransform"
      },
      {
        $ref: "#/definitions/CoverageTransform"
      },
      {
        $ref: "#/definitions/JsonParseTransform"
      }
    ]
  },
  Datum: {
    additionalProperties: {
      type: [
        "number",
        "string"
      ]
    },
    description: "Values in the form of JSON.",
    type: "object"
  },
  DisplaceTransform: {
    additionalProperties: false,
    properties: {
      boundingBox: {
        additionalProperties: false,
        properties: {
          endField: {
            description: "The name of a quantitative field that represents the end position.",
            type: "string"
          },
          groupField: {
            description: "The name of a nominal field to group rows by in prior to piling-up.",
            type: "string"
          },
          isPaddingBP: {
            description: "Whether to consider `padding` as the bp length.",
            type: "boolean"
          },
          padding: {
            description: "The padding around visual lements. Either px or bp",
            type: "number"
          },
          startField: {
            description: "The name of a quantitative field that represents the start position.",
            type: "string"
          }
        },
        required: [
          "startField",
          "endField"
        ],
        type: "object"
      },
      maxRows: {
        description: "Specify maximum rows to be generated (default has no limit).",
        type: "number"
      },
      method: {
        $ref: "#/definitions/DisplacementType",
        description: "A string that specifies the type of displacement."
      },
      newField: {
        type: "string"
      },
      type: {
        "const": "displace",
        type: "string"
      }
    },
    required: [
      "type",
      "boundingBox",
      "method",
      "newField"
    ],
    type: "object"
  },
  Displacement: {
    additionalProperties: false,
    properties: {
      padding: {
        type: "number"
      },
      type: {
        $ref: "#/definitions/DisplacementType"
      }
    },
    required: [
      "type"
    ],
    type: "object"
  },
  DisplacementType: {
    "enum": [
      "pile",
      "spread"
    ],
    type: "string"
  },
  DomainChr: {
    additionalProperties: false,
    properties: {
      chromosome: {
        type: "string"
      }
    },
    required: [
      "chromosome"
    ],
    type: "object"
  },
  DomainChrInterval: {
    additionalProperties: false,
    properties: {
      chromosome: {
        description: "If specified, only showing a certain interval in a chromosome.",
        type: "string"
      },
      interval: {
        items: {
          type: "number"
        },
        maxItems: 2,
        minItems: 2,
        type: "array"
      }
    },
    required: [
      "chromosome",
      "interval"
    ],
    type: "object"
  },
  DomainInterval: {
    additionalProperties: false,
    properties: {
      interval: {
        description: "Show a certain interval within entire chromosome",
        items: {
          type: "number"
        },
        maxItems: 2,
        minItems: 2,
        type: "array"
      }
    },
    required: [
      "interval"
    ],
    type: "object"
  },
  EventStyle: {
    additionalProperties: false,
    description: "The styles defined here will be applied to the target marks of mouse events, such as a point mark after the user clicks on it.",
    properties: {
      arrange: {
        description: "Show event effects behind or in front of marks.",
        "enum": [
          "behind",
          "front"
        ],
        type: "string"
      },
      color: {
        description: "color of the marks when mouse events are triggered",
        type: "string"
      },
      opacity: {
        description: "opacity of the marks when mouse events are triggered",
        type: "number"
      },
      stroke: {
        description: "stroke color of the marks when mouse events are triggered",
        type: "string"
      },
      strokeOpacity: {
        type: "number"
      },
      strokeWidth: {
        description: "stroke width of the marks when mouse events are triggered",
        type: "number"
      }
    },
    type: "object"
  },
  ExonSplitTransform: {
    additionalProperties: false,
    properties: {
      fields: {
        items: {
          additionalProperties: false,
          properties: {
            chrField: {
              type: "string"
            },
            field: {
              type: "string"
            },
            newField: {
              type: "string"
            },
            type: {
              $ref: "#/definitions/FieldType"
            }
          },
          required: [
            "field",
            "type",
            "newField",
            "chrField"
          ],
          type: "object"
        },
        type: "array"
      },
      flag: {
        additionalProperties: false,
        properties: {
          field: {
            type: "string"
          },
          value: {
            type: [
              "number",
              "string"
            ]
          }
        },
        required: [
          "field",
          "value"
        ],
        type: "object"
      },
      separator: {
        type: "string"
      },
      type: {
        "const": "exonSplit",
        type: "string"
      }
    },
    required: [
      "type",
      "separator",
      "flag",
      "fields"
    ],
    type: "object"
  },
  FieldType: {
    "enum": [
      "genomic",
      "nominal",
      "quantitative"
    ],
    type: "string"
  },
  FilterTransform: {
    anyOf: [
      {
        $ref: "#/definitions/OneOfFilter"
      },
      {
        $ref: "#/definitions/RangeFilter"
      },
      {
        $ref: "#/definitions/IncludeFilter"
      }
    ]
  },
  GenomicDomain: {
    anyOf: [
      {
        $ref: "#/definitions/DomainInterval"
      },
      {
        $ref: "#/definitions/DomainChrInterval"
      },
      {
        $ref: "#/definitions/DomainChr"
      }
    ]
  },
  GenomicLengthTransform: {
    additionalProperties: false,
    description: "Calculate genomic length using two genomic fields",
    properties: {
      endField: {
        type: "string"
      },
      newField: {
        type: "string"
      },
      startField: {
        type: "string"
      },
      type: {
        "const": "genomicLength",
        type: "string"
      }
    },
    required: [
      "type",
      "startField",
      "endField",
      "newField"
    ],
    type: "object"
  },
  GoslingSpec: {
    anyOf: [
      {
        additionalProperties: false,
        properties: {
          _assignedHeight: {
            type: "number"
          },
          _assignedWidth: {
            description: "Internal: Used for responsive spec",
            type: "number"
          },
          _invalidTrack: {
            description: "internal",
            type: "boolean"
          },
          _renderingId: {
            description: "internal",
            type: "string"
          },
          alignment: {
            "const": "overlay",
            type: "string"
          },
          assembly: {
            $ref: "#/definitions/Assembly",
            description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
          },
          baselineY: {
            type: "number"
          },
          centerRadius: {
            description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
            type: "number"
          },
          color: {
            anyOf: [
              {
                $ref: "#/definitions/Color"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          data: {
            $ref: "#/definitions/DataDeep"
          },
          dataTransform: {
            items: {
              $ref: "#/definitions/DataTransform"
            },
            type: "array"
          },
          description: {
            type: "string"
          },
          displacement: {
            $ref: "#/definitions/Displacement"
          },
          endAngle: {
            description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
            type: "number"
          },
          experimental: {
            additionalProperties: false,
            properties: {
              mouseEvents: {
                anyOf: [
                  {
                    type: "boolean"
                  },
                  {
                    $ref: "#/definitions/MouseEventsDeep"
                  }
                ]
              },
              performanceMode: {
                "default": false,
                description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                type: "boolean"
              }
            },
            type: "object"
          },
          flipY: {
            type: "boolean"
          },
          height: {
            description: "Specify the track height in pixels.",
            type: "number"
          },
          id: {
            type: "string"
          },
          innerRadius: {
            description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
            type: "number"
          },
          layout: {
            $ref: "#/definitions/Layout",
            description: "Specify the layout type of all tracks."
          },
          linkingId: {
            description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
            type: "string"
          },
          mark: {
            $ref: "#/definitions/Mark"
          },
          opacity: {
            anyOf: [
              {
                $ref: "#/definitions/Opacity"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          orientation: {
            $ref: "#/definitions/Orientation",
            description: "Specify the orientation."
          },
          outerRadius: {
            description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
            type: "number"
          },
          overlayOnPreviousTrack: {
            type: "boolean"
          },
          overrideTemplate: {
            type: "boolean"
          },
          prerelease: {
            additionalProperties: false,
            description: "internal",
            type: "object"
          },
          responsiveSize: {
            $ref: "#/definitions/ResponsiveSize",
            description: "Determine whether to make the size of `GoslingComponent` bound to its parent element. __Default__: `false`"
          },
          responsiveSpec: {
            items: {
              additionalProperties: false,
              properties: {
                selectivity: {
                  items: {
                    $ref: "#/definitions/SelectivityCondition"
                  },
                  type: "array"
                },
                spec: {
                  additionalProperties: false,
                  properties: {
                    _assignedHeight: {
                      type: "number"
                    },
                    _assignedWidth: {
                      description: "Internal: Used for responsive spec",
                      type: "number"
                    },
                    _invalidTrack: {
                      description: "internal",
                      type: "boolean"
                    },
                    _renderingId: {
                      description: "internal",
                      type: "string"
                    },
                    alignment: {
                      "enum": [
                        "overlay",
                        "stack"
                      ],
                      type: "string"
                    },
                    assembly: {
                      $ref: "#/definitions/Assembly",
                      description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
                    },
                    baselineY: {
                      type: "number"
                    },
                    centerRadius: {
                      description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
                      type: "number"
                    },
                    color: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Color"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    data: {
                      $ref: "#/definitions/DataDeep"
                    },
                    dataTransform: {
                      items: {
                        $ref: "#/definitions/DataTransform"
                      },
                      type: "array"
                    },
                    displacement: {
                      $ref: "#/definitions/Displacement"
                    },
                    endAngle: {
                      description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    experimental: {
                      additionalProperties: false,
                      properties: {
                        mouseEvents: {
                          anyOf: [
                            {
                              type: "boolean"
                            },
                            {
                              $ref: "#/definitions/MouseEventsDeep"
                            }
                          ]
                        },
                        performanceMode: {
                          "default": false,
                          description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                          type: "boolean"
                        }
                      },
                      type: "object"
                    },
                    flipY: {
                      type: "boolean"
                    },
                    height: {
                      description: "Specify the track height in pixels.",
                      type: "number"
                    },
                    id: {
                      type: "string"
                    },
                    innerRadius: {
                      description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    layout: {
                      $ref: "#/definitions/Layout",
                      description: "Specify the layout type of all tracks."
                    },
                    linkingId: {
                      description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
                      type: "string"
                    },
                    mark: {
                      $ref: "#/definitions/Mark"
                    },
                    opacity: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Opacity"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    orientation: {
                      $ref: "#/definitions/Orientation",
                      description: "Specify the orientation."
                    },
                    outerRadius: {
                      description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
                      type: "number"
                    },
                    overlayOnPreviousTrack: {
                      type: "boolean"
                    },
                    overrideTemplate: {
                      type: "boolean"
                    },
                    prerelease: {
                      additionalProperties: false,
                      description: "internal",
                      type: "object"
                    },
                    row: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Row"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    size: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Size"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    spacing: {
                      description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
                      type: "number"
                    },
                    startAngle: {
                      description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    "static": {
                      description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
                      type: "boolean"
                    },
                    stretch: {
                      type: "boolean"
                    },
                    stroke: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Stroke"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    strokeWidth: {
                      anyOf: [
                        {
                          $ref: "#/definitions/StrokeWidth"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    style: {
                      $ref: "#/definitions/Style",
                      description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
                    },
                    subtitle: {
                      type: "string"
                    },
                    text: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Text"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    title: {
                      description: "If defined, will show the textual label on the left-top corner of a track.",
                      type: "string"
                    },
                    tooltip: {
                      items: {
                        $ref: "#/definitions/Tooltip"
                      },
                      type: "array"
                    },
                    tracks: {
                      anyOf: [
                        {
                          items: {
                            $ref: "#/definitions/PartialTrack"
                          },
                          type: "array"
                        },
                        {
                          items: {
                            anyOf: [
                              {
                                $ref: "#/definitions/PartialTrack"
                              },
                              {
                                $ref: "#/definitions/OverlaidTracks"
                              }
                            ]
                          },
                          type: "array"
                        }
                      ]
                    },
                    visibility: {
                      items: {
                        $ref: "#/definitions/VisibilityCondition"
                      },
                      type: "array"
                    },
                    width: {
                      description: "Specify the track width in pixels.",
                      type: "number"
                    },
                    x: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    xAxis: {
                      $ref: "#/definitions/AxisPosition",
                      description: "not supported"
                    },
                    xDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic x-axis"
                    },
                    xOffset: {
                      description: "Specify the x offset of views in the unit of pixels",
                      type: "number"
                    },
                    xe: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    yDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic y-axis"
                    },
                    yOffset: {
                      description: "Specify the y offset of views in the unit of pixels",
                      type: "number"
                    },
                    ye: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    zoomLimits: {
                      $ref: "#/definitions/ZoomLimits"
                    }
                  },
                  type: "object"
                }
              },
              required: [
                "spec",
                "selectivity"
              ],
              type: "object"
            },
            type: "array"
          },
          row: {
            anyOf: [
              {
                $ref: "#/definitions/Row"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          size: {
            anyOf: [
              {
                $ref: "#/definitions/Size"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          spacing: {
            description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
            type: "number"
          },
          startAngle: {
            description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
            type: "number"
          },
          "static": {
            description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
            type: "boolean"
          },
          stretch: {
            type: "boolean"
          },
          stroke: {
            anyOf: [
              {
                $ref: "#/definitions/Stroke"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          strokeWidth: {
            anyOf: [
              {
                $ref: "#/definitions/StrokeWidth"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          style: {
            $ref: "#/definitions/Style",
            description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
          },
          subtitle: {
            type: "string"
          },
          text: {
            anyOf: [
              {
                $ref: "#/definitions/Text"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          title: {
            description: "If defined, will show the textual label on the left-top corner of a track.",
            type: "string"
          },
          tooltip: {
            items: {
              $ref: "#/definitions/Tooltip"
            },
            type: "array"
          },
          tracks: {
            items: {
              $ref: "#/definitions/PartialTrack"
            },
            type: "array"
          },
          visibility: {
            items: {
              $ref: "#/definitions/VisibilityCondition"
            },
            type: "array"
          },
          width: {
            description: "Specify the track width in pixels.",
            type: "number"
          },
          x: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          x1: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          x1e: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          xAxis: {
            $ref: "#/definitions/AxisPosition",
            description: "not supported"
          },
          xDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic x-axis"
          },
          xOffset: {
            description: "Specify the x offset of views in the unit of pixels",
            type: "number"
          },
          xe: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y1: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y1e: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          yDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic y-axis"
          },
          yOffset: {
            description: "Specify the y offset of views in the unit of pixels",
            type: "number"
          },
          ye: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          zoomLimits: {
            $ref: "#/definitions/ZoomLimits"
          }
        },
        required: [
          "alignment",
          "tracks"
        ],
        type: "object"
      },
      {
        additionalProperties: false,
        properties: {
          _assignedHeight: {
            type: "number"
          },
          _assignedWidth: {
            description: "Internal: Used for responsive spec",
            type: "number"
          },
          _invalidTrack: {
            description: "internal",
            type: "boolean"
          },
          _renderingId: {
            description: "internal",
            type: "string"
          },
          alignment: {
            "const": "stack",
            type: "string"
          },
          assembly: {
            $ref: "#/definitions/Assembly",
            description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
          },
          baselineY: {
            type: "number"
          },
          centerRadius: {
            description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
            type: "number"
          },
          color: {
            anyOf: [
              {
                $ref: "#/definitions/Color"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          data: {
            $ref: "#/definitions/DataDeep"
          },
          dataTransform: {
            items: {
              $ref: "#/definitions/DataTransform"
            },
            type: "array"
          },
          description: {
            type: "string"
          },
          displacement: {
            $ref: "#/definitions/Displacement"
          },
          endAngle: {
            description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
            type: "number"
          },
          experimental: {
            additionalProperties: false,
            properties: {
              mouseEvents: {
                anyOf: [
                  {
                    type: "boolean"
                  },
                  {
                    $ref: "#/definitions/MouseEventsDeep"
                  }
                ]
              },
              performanceMode: {
                "default": false,
                description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                type: "boolean"
              }
            },
            type: "object"
          },
          flipY: {
            type: "boolean"
          },
          height: {
            description: "Specify the track height in pixels.",
            type: "number"
          },
          id: {
            type: "string"
          },
          innerRadius: {
            description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
            type: "number"
          },
          layout: {
            $ref: "#/definitions/Layout",
            description: "Specify the layout type of all tracks."
          },
          linkingId: {
            description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
            type: "string"
          },
          mark: {
            $ref: "#/definitions/Mark"
          },
          opacity: {
            anyOf: [
              {
                $ref: "#/definitions/Opacity"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          orientation: {
            $ref: "#/definitions/Orientation",
            description: "Specify the orientation."
          },
          outerRadius: {
            description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
            type: "number"
          },
          overlayOnPreviousTrack: {
            type: "boolean"
          },
          overrideTemplate: {
            type: "boolean"
          },
          prerelease: {
            additionalProperties: false,
            description: "internal",
            type: "object"
          },
          responsiveSize: {
            $ref: "#/definitions/ResponsiveSize",
            description: "Determine whether to make the size of `GoslingComponent` bound to its parent element. __Default__: `false`"
          },
          responsiveSpec: {
            items: {
              additionalProperties: false,
              properties: {
                selectivity: {
                  items: {
                    $ref: "#/definitions/SelectivityCondition"
                  },
                  type: "array"
                },
                spec: {
                  additionalProperties: false,
                  properties: {
                    _assignedHeight: {
                      type: "number"
                    },
                    _assignedWidth: {
                      description: "Internal: Used for responsive spec",
                      type: "number"
                    },
                    _invalidTrack: {
                      description: "internal",
                      type: "boolean"
                    },
                    _renderingId: {
                      description: "internal",
                      type: "string"
                    },
                    alignment: {
                      "enum": [
                        "overlay",
                        "stack"
                      ],
                      type: "string"
                    },
                    assembly: {
                      $ref: "#/definitions/Assembly",
                      description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
                    },
                    baselineY: {
                      type: "number"
                    },
                    centerRadius: {
                      description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
                      type: "number"
                    },
                    color: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Color"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    data: {
                      $ref: "#/definitions/DataDeep"
                    },
                    dataTransform: {
                      items: {
                        $ref: "#/definitions/DataTransform"
                      },
                      type: "array"
                    },
                    displacement: {
                      $ref: "#/definitions/Displacement"
                    },
                    endAngle: {
                      description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    experimental: {
                      additionalProperties: false,
                      properties: {
                        mouseEvents: {
                          anyOf: [
                            {
                              type: "boolean"
                            },
                            {
                              $ref: "#/definitions/MouseEventsDeep"
                            }
                          ]
                        },
                        performanceMode: {
                          "default": false,
                          description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                          type: "boolean"
                        }
                      },
                      type: "object"
                    },
                    flipY: {
                      type: "boolean"
                    },
                    height: {
                      description: "Specify the track height in pixels.",
                      type: "number"
                    },
                    id: {
                      type: "string"
                    },
                    innerRadius: {
                      description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    layout: {
                      $ref: "#/definitions/Layout",
                      description: "Specify the layout type of all tracks."
                    },
                    linkingId: {
                      description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
                      type: "string"
                    },
                    mark: {
                      $ref: "#/definitions/Mark"
                    },
                    opacity: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Opacity"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    orientation: {
                      $ref: "#/definitions/Orientation",
                      description: "Specify the orientation."
                    },
                    outerRadius: {
                      description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
                      type: "number"
                    },
                    overlayOnPreviousTrack: {
                      type: "boolean"
                    },
                    overrideTemplate: {
                      type: "boolean"
                    },
                    prerelease: {
                      additionalProperties: false,
                      description: "internal",
                      type: "object"
                    },
                    row: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Row"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    size: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Size"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    spacing: {
                      description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
                      type: "number"
                    },
                    startAngle: {
                      description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    "static": {
                      description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
                      type: "boolean"
                    },
                    stretch: {
                      type: "boolean"
                    },
                    stroke: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Stroke"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    strokeWidth: {
                      anyOf: [
                        {
                          $ref: "#/definitions/StrokeWidth"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    style: {
                      $ref: "#/definitions/Style",
                      description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
                    },
                    subtitle: {
                      type: "string"
                    },
                    text: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Text"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    title: {
                      description: "If defined, will show the textual label on the left-top corner of a track.",
                      type: "string"
                    },
                    tooltip: {
                      items: {
                        $ref: "#/definitions/Tooltip"
                      },
                      type: "array"
                    },
                    tracks: {
                      anyOf: [
                        {
                          items: {
                            $ref: "#/definitions/PartialTrack"
                          },
                          type: "array"
                        },
                        {
                          items: {
                            anyOf: [
                              {
                                $ref: "#/definitions/PartialTrack"
                              },
                              {
                                $ref: "#/definitions/OverlaidTracks"
                              }
                            ]
                          },
                          type: "array"
                        }
                      ]
                    },
                    visibility: {
                      items: {
                        $ref: "#/definitions/VisibilityCondition"
                      },
                      type: "array"
                    },
                    width: {
                      description: "Specify the track width in pixels.",
                      type: "number"
                    },
                    x: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    xAxis: {
                      $ref: "#/definitions/AxisPosition",
                      description: "not supported"
                    },
                    xDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic x-axis"
                    },
                    xOffset: {
                      description: "Specify the x offset of views in the unit of pixels",
                      type: "number"
                    },
                    xe: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    yDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic y-axis"
                    },
                    yOffset: {
                      description: "Specify the y offset of views in the unit of pixels",
                      type: "number"
                    },
                    ye: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    zoomLimits: {
                      $ref: "#/definitions/ZoomLimits"
                    }
                  },
                  type: "object"
                }
              },
              required: [
                "spec",
                "selectivity"
              ],
              type: "object"
            },
            type: "array"
          },
          row: {
            anyOf: [
              {
                $ref: "#/definitions/Row"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          size: {
            anyOf: [
              {
                $ref: "#/definitions/Size"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          spacing: {
            description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
            type: "number"
          },
          startAngle: {
            description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
            type: "number"
          },
          "static": {
            description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
            type: "boolean"
          },
          stretch: {
            type: "boolean"
          },
          stroke: {
            anyOf: [
              {
                $ref: "#/definitions/Stroke"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          strokeWidth: {
            anyOf: [
              {
                $ref: "#/definitions/StrokeWidth"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          style: {
            $ref: "#/definitions/Style",
            description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
          },
          subtitle: {
            type: "string"
          },
          text: {
            anyOf: [
              {
                $ref: "#/definitions/Text"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          title: {
            description: "If defined, will show the textual label on the left-top corner of a track.",
            type: "string"
          },
          tooltip: {
            items: {
              $ref: "#/definitions/Tooltip"
            },
            type: "array"
          },
          tracks: {
            items: {
              anyOf: [
                {
                  $ref: "#/definitions/PartialTrack"
                },
                {
                  $ref: "#/definitions/OverlaidTracks"
                }
              ]
            },
            type: "array"
          },
          visibility: {
            items: {
              $ref: "#/definitions/VisibilityCondition"
            },
            type: "array"
          },
          width: {
            description: "Specify the track width in pixels.",
            type: "number"
          },
          x: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          x1: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          x1e: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          xAxis: {
            $ref: "#/definitions/AxisPosition",
            description: "not supported"
          },
          xDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic x-axis"
          },
          xOffset: {
            description: "Specify the x offset of views in the unit of pixels",
            type: "number"
          },
          xe: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y1: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y1e: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          yDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic y-axis"
          },
          yOffset: {
            description: "Specify the y offset of views in the unit of pixels",
            type: "number"
          },
          ye: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          zoomLimits: {
            $ref: "#/definitions/ZoomLimits"
          }
        },
        required: [
          "tracks"
        ],
        type: "object"
      },
      {
        additionalProperties: false,
        properties: {
          _assignedHeight: {
            type: "number"
          },
          _assignedWidth: {
            description: "Internal: Used for responsive spec",
            type: "number"
          },
          assembly: {
            $ref: "#/definitions/Assembly",
            description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
          },
          centerRadius: {
            description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
            type: "number"
          },
          description: {
            type: "string"
          },
          layout: {
            $ref: "#/definitions/Layout",
            description: "Specify the layout type of all tracks."
          },
          linkingId: {
            description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
            type: "string"
          },
          orientation: {
            $ref: "#/definitions/Orientation",
            description: "Specify the orientation."
          },
          responsiveSize: {
            $ref: "#/definitions/ResponsiveSize",
            description: "Determine whether to make the size of `GoslingComponent` bound to its parent element. __Default__: `false`"
          },
          responsiveSpec: {
            items: {
              additionalProperties: false,
              properties: {
                selectivity: {
                  items: {
                    $ref: "#/definitions/SelectivityCondition"
                  },
                  type: "array"
                },
                spec: {
                  additionalProperties: false,
                  properties: {
                    _assignedHeight: {
                      type: "number"
                    },
                    _assignedWidth: {
                      description: "Internal: Used for responsive spec",
                      type: "number"
                    },
                    _invalidTrack: {
                      description: "internal",
                      type: "boolean"
                    },
                    _renderingId: {
                      description: "internal",
                      type: "string"
                    },
                    alignment: {
                      "enum": [
                        "overlay",
                        "stack"
                      ],
                      type: "string"
                    },
                    assembly: {
                      $ref: "#/definitions/Assembly",
                      description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
                    },
                    baselineY: {
                      type: "number"
                    },
                    centerRadius: {
                      description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
                      type: "number"
                    },
                    color: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Color"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    data: {
                      $ref: "#/definitions/DataDeep"
                    },
                    dataTransform: {
                      items: {
                        $ref: "#/definitions/DataTransform"
                      },
                      type: "array"
                    },
                    displacement: {
                      $ref: "#/definitions/Displacement"
                    },
                    endAngle: {
                      description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    experimental: {
                      additionalProperties: false,
                      properties: {
                        mouseEvents: {
                          anyOf: [
                            {
                              type: "boolean"
                            },
                            {
                              $ref: "#/definitions/MouseEventsDeep"
                            }
                          ]
                        },
                        performanceMode: {
                          "default": false,
                          description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                          type: "boolean"
                        }
                      },
                      type: "object"
                    },
                    flipY: {
                      type: "boolean"
                    },
                    height: {
                      description: "Specify the track height in pixels.",
                      type: "number"
                    },
                    id: {
                      type: "string"
                    },
                    innerRadius: {
                      description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    layout: {
                      $ref: "#/definitions/Layout",
                      description: "Specify the layout type of all tracks."
                    },
                    linkingId: {
                      description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
                      type: "string"
                    },
                    mark: {
                      $ref: "#/definitions/Mark"
                    },
                    opacity: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Opacity"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    orientation: {
                      $ref: "#/definitions/Orientation",
                      description: "Specify the orientation."
                    },
                    outerRadius: {
                      description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
                      type: "number"
                    },
                    overlayOnPreviousTrack: {
                      type: "boolean"
                    },
                    overrideTemplate: {
                      type: "boolean"
                    },
                    prerelease: {
                      additionalProperties: false,
                      description: "internal",
                      type: "object"
                    },
                    row: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Row"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    size: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Size"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    spacing: {
                      description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
                      type: "number"
                    },
                    startAngle: {
                      description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    "static": {
                      description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
                      type: "boolean"
                    },
                    stretch: {
                      type: "boolean"
                    },
                    stroke: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Stroke"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    strokeWidth: {
                      anyOf: [
                        {
                          $ref: "#/definitions/StrokeWidth"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    style: {
                      $ref: "#/definitions/Style",
                      description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
                    },
                    subtitle: {
                      type: "string"
                    },
                    text: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Text"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    title: {
                      description: "If defined, will show the textual label on the left-top corner of a track.",
                      type: "string"
                    },
                    tooltip: {
                      items: {
                        $ref: "#/definitions/Tooltip"
                      },
                      type: "array"
                    },
                    tracks: {
                      anyOf: [
                        {
                          items: {
                            $ref: "#/definitions/PartialTrack"
                          },
                          type: "array"
                        },
                        {
                          items: {
                            anyOf: [
                              {
                                $ref: "#/definitions/PartialTrack"
                              },
                              {
                                $ref: "#/definitions/OverlaidTracks"
                              }
                            ]
                          },
                          type: "array"
                        }
                      ]
                    },
                    visibility: {
                      items: {
                        $ref: "#/definitions/VisibilityCondition"
                      },
                      type: "array"
                    },
                    width: {
                      description: "Specify the track width in pixels.",
                      type: "number"
                    },
                    x: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    xAxis: {
                      $ref: "#/definitions/AxisPosition",
                      description: "not supported"
                    },
                    xDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic x-axis"
                    },
                    xOffset: {
                      description: "Specify the x offset of views in the unit of pixels",
                      type: "number"
                    },
                    xe: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    yDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic y-axis"
                    },
                    yOffset: {
                      description: "Specify the y offset of views in the unit of pixels",
                      type: "number"
                    },
                    ye: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    zoomLimits: {
                      $ref: "#/definitions/ZoomLimits"
                    }
                  },
                  type: "object"
                }
              },
              required: [
                "spec",
                "selectivity"
              ],
              type: "object"
            },
            type: "array"
          },
          spacing: {
            description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
            type: "number"
          },
          "static": {
            description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
            type: "boolean"
          },
          style: {
            $ref: "#/definitions/Style",
            description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
          },
          subtitle: {
            type: "string"
          },
          title: {
            type: "string"
          },
          tracks: {
            items: {
              $ref: "#/definitions/Track"
            },
            type: "array"
          },
          xAxis: {
            $ref: "#/definitions/AxisPosition",
            description: "not supported"
          },
          xDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic x-axis"
          },
          xOffset: {
            description: "Specify the x offset of views in the unit of pixels",
            type: "number"
          },
          yDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic y-axis"
          },
          yOffset: {
            description: "Specify the y offset of views in the unit of pixels",
            type: "number"
          },
          zoomLimits: {
            $ref: "#/definitions/ZoomLimits"
          }
        },
        required: [
          "tracks"
        ],
        type: "object"
      },
      {
        additionalProperties: false,
        properties: {
          _assignedHeight: {
            type: "number"
          },
          _assignedWidth: {
            description: "Internal: Used for responsive spec",
            type: "number"
          },
          arrangement: {
            description: "Specify how multiple views are arranged.",
            "enum": [
              "parallel",
              "serial",
              "horizontal",
              "vertical"
            ],
            type: "string"
          },
          assembly: {
            $ref: "#/definitions/Assembly",
            description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
          },
          centerRadius: {
            description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
            type: "number"
          },
          description: {
            type: "string"
          },
          layout: {
            $ref: "#/definitions/Layout",
            description: "Specify the layout type of all tracks."
          },
          linkingId: {
            description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
            type: "string"
          },
          orientation: {
            $ref: "#/definitions/Orientation",
            description: "Specify the orientation."
          },
          responsiveSize: {
            $ref: "#/definitions/ResponsiveSize",
            description: "Determine whether to make the size of `GoslingComponent` bound to its parent element. __Default__: `false`"
          },
          responsiveSpec: {
            items: {
              additionalProperties: false,
              properties: {
                selectivity: {
                  items: {
                    $ref: "#/definitions/SelectivityCondition"
                  },
                  type: "array"
                },
                spec: {
                  additionalProperties: false,
                  properties: {
                    _assignedHeight: {
                      type: "number"
                    },
                    _assignedWidth: {
                      description: "Internal: Used for responsive spec",
                      type: "number"
                    },
                    arrangement: {
                      description: "Specify how multiple views are arranged.",
                      "enum": [
                        "parallel",
                        "serial",
                        "horizontal",
                        "vertical"
                      ],
                      type: "string"
                    },
                    assembly: {
                      $ref: "#/definitions/Assembly",
                      description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
                    },
                    centerRadius: {
                      description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
                      type: "number"
                    },
                    layout: {
                      $ref: "#/definitions/Layout",
                      description: "Specify the layout type of all tracks."
                    },
                    linkingId: {
                      description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
                      type: "string"
                    },
                    orientation: {
                      $ref: "#/definitions/Orientation",
                      description: "Specify the orientation."
                    },
                    spacing: {
                      description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
                      type: "number"
                    },
                    "static": {
                      description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
                      type: "boolean"
                    },
                    style: {
                      $ref: "#/definitions/Style",
                      description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
                    },
                    views: {
                      description: "An array of view specifications",
                      items: {
                        anyOf: [
                          {
                            $ref: "#/definitions/SingleView"
                          },
                          {
                            $ref: "#/definitions/MultipleViews"
                          }
                        ]
                      },
                      type: "array"
                    },
                    xAxis: {
                      $ref: "#/definitions/AxisPosition",
                      description: "not supported"
                    },
                    xDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic x-axis"
                    },
                    xOffset: {
                      description: "Specify the x offset of views in the unit of pixels",
                      type: "number"
                    },
                    yDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic y-axis"
                    },
                    yOffset: {
                      description: "Specify the y offset of views in the unit of pixels",
                      type: "number"
                    },
                    zoomLimits: {
                      $ref: "#/definitions/ZoomLimits"
                    }
                  },
                  type: "object"
                }
              },
              required: [
                "spec",
                "selectivity"
              ],
              type: "object"
            },
            type: "array"
          },
          spacing: {
            description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
            type: "number"
          },
          "static": {
            description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
            type: "boolean"
          },
          style: {
            $ref: "#/definitions/Style",
            description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
          },
          subtitle: {
            type: "string"
          },
          title: {
            type: "string"
          },
          views: {
            description: "An array of view specifications",
            items: {
              anyOf: [
                {
                  $ref: "#/definitions/SingleView"
                },
                {
                  $ref: "#/definitions/MultipleViews"
                }
              ]
            },
            type: "array"
          },
          xAxis: {
            $ref: "#/definitions/AxisPosition",
            description: "not supported"
          },
          xDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic x-axis"
          },
          xOffset: {
            description: "Specify the x offset of views in the unit of pixels",
            type: "number"
          },
          yDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic y-axis"
          },
          yOffset: {
            description: "Specify the y offset of views in the unit of pixels",
            type: "number"
          },
          zoomLimits: {
            $ref: "#/definitions/ZoomLimits"
          }
        },
        required: [
          "views"
        ],
        type: "object"
      }
    ]
  },
  IncludeFilter: {
    additionalProperties: false,
    properties: {
      field: {
        description: "A filter is applied based on the values of the specified data field",
        type: "string"
      },
      include: {
        description: "Check whether the value includes a substring.",
        type: "string"
      },
      not: {
        description: 'when `{"not": true}`, apply a NOT logical operation to the filter.\n\n__Default:__ `false`',
        type: "boolean"
      },
      type: {
        "const": "filter",
        type: "string"
      }
    },
    required: [
      "field",
      "include",
      "type"
    ],
    type: "object"
  },
  JsonData: {
    additionalProperties: false,
    description: "The JSON data format allows users to include data directly in the Gosling's JSON specification.",
    properties: {
      chromosomeField: {
        description: "Specify the name of chromosome data fields.",
        type: "string"
      },
      genomicFields: {
        description: "Specify the name of genomic data fields.",
        items: {
          type: "string"
        },
        type: "array"
      },
      genomicFieldsToConvert: {
        description: "experimental",
        items: {
          additionalProperties: false,
          properties: {
            chromosomeField: {
              type: "string"
            },
            genomicFields: {
              items: {
                type: "string"
              },
              type: "array"
            }
          },
          required: [
            "chromosomeField",
            "genomicFields"
          ],
          type: "object"
        },
        type: "array"
      },
      sampleLength: {
        description: "Specify the number of rows loaded from the URL.\n\n__Default:__ `1000`",
        type: "number"
      },
      type: {
        "const": "json",
        description: "Define data type.",
        type: "string"
      },
      values: {
        description: "Values in the form of JSON.",
        items: {
          $ref: "#/definitions/Datum"
        },
        type: "array"
      }
    },
    required: [
      "type",
      "values"
    ],
    type: "object"
  },
  JsonParseTransform: {
    additionalProperties: false,
    description: "Parse JSON Object Array and append vertically",
    properties: {
      baseGenomicField: {
        description: "Base genomic position when parsing relative position.",
        type: "string"
      },
      field: {
        description: "The field that contains the JSON object array.",
        type: "string"
      },
      genomicField: {
        description: "Relative genomic position to parse.",
        type: "string"
      },
      genomicLengthField: {
        description: "Length of genomic interval.",
        type: "string"
      },
      type: {
        "const": "subjson",
        type: "string"
      }
    },
    required: [
      "type",
      "field",
      "baseGenomicField",
      "genomicField",
      "genomicLengthField"
    ],
    type: "object"
  },
  Layout: {
    "enum": [
      "linear",
      "circular"
    ],
    type: "string"
  },
  LogBase: {
    anyOf: [
      {
        type: "number"
      },
      {
        "const": "e",
        type: "string"
      }
    ]
  },
  LogTransform: {
    additionalProperties: false,
    properties: {
      base: {
        $ref: "#/definitions/LogBase",
        description: "If not specified, 10 is used."
      },
      field: {
        type: "string"
      },
      newField: {
        description: "If specified, store transformed values in a new field.",
        type: "string"
      },
      type: {
        "const": "log",
        type: "string"
      }
    },
    required: [
      "type",
      "field"
    ],
    type: "object"
  },
  LogicalOperation: {
    "enum": [
      "less-than",
      "lt",
      "LT",
      "greater-than",
      "gt",
      "GT",
      "less-than-or-equal-to",
      "ltet",
      "LTET",
      "greater-than-or-equal-to",
      "gtet",
      "GTET"
    ],
    type: "string"
  },
  Mark: {
    "enum": [
      "point",
      "line",
      "area",
      "bar",
      "rect",
      "text",
      "withinLink",
      "betweenLink",
      "rule",
      "triangleLeft",
      "triangleRight",
      "triangleBottom",
      "brush",
      "header"
    ],
    type: "string"
  },
  MatrixData: {
    additionalProperties: false,
    properties: {
      binSize: {
        description: "Determine the number of nearby cells to aggregate. __Default__: `1`",
        type: "number"
      },
      column: {
        description: "The name of the first genomic field. __Default__: `x`",
        type: "string"
      },
      row: {
        description: "The name of the first genomic field. __Default__: `y`",
        type: "string"
      },
      type: {
        "const": "matrix",
        type: "string"
      },
      url: {
        description: "URL link to the matrix data file",
        type: "string"
      },
      value: {
        description: "The name of the value field. __Default__: `value`",
        type: "string"
      }
    },
    required: [
      "type",
      "url"
    ],
    type: "object"
  },
  MouseEventsDeep: {
    additionalProperties: false,
    description: "Options for determining mouse events in detail, e.g., turning on specific events only",
    properties: {
      click: {
        description: "Whether to enable click events.",
        type: "boolean"
      },
      enableMouseOverOnMultipleMarks: {
        description: "Determine whether all marks underneath the mouse point should be affected by mouse over. __Default__: `false`",
        type: "boolean"
      },
      groupMarksByField: {
        description: "Group marks using keys in a data field. This affects how a set of marks are highlighted/selected by interaction. __Default__: `undefined`",
        type: "string"
      },
      mouseOver: {
        description: "Whether to enable mouseover events.",
        type: "boolean"
      },
      rangeSelect: {
        description: "Whether to send range selection events.",
        type: "boolean"
      }
    },
    type: "object"
  },
  MultipleViews: {
    additionalProperties: false,
    properties: {
      _assignedHeight: {
        type: "number"
      },
      _assignedWidth: {
        description: "Internal: Used for responsive spec",
        type: "number"
      },
      arrangement: {
        description: "Specify how multiple views are arranged.",
        "enum": [
          "parallel",
          "serial",
          "horizontal",
          "vertical"
        ],
        type: "string"
      },
      assembly: {
        $ref: "#/definitions/Assembly",
        description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
      },
      centerRadius: {
        description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
        type: "number"
      },
      layout: {
        $ref: "#/definitions/Layout",
        description: "Specify the layout type of all tracks."
      },
      linkingId: {
        description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
        type: "string"
      },
      orientation: {
        $ref: "#/definitions/Orientation",
        description: "Specify the orientation."
      },
      spacing: {
        description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
        type: "number"
      },
      "static": {
        description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
        type: "boolean"
      },
      style: {
        $ref: "#/definitions/Style",
        description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
      },
      views: {
        description: "An array of view specifications",
        items: {
          anyOf: [
            {
              $ref: "#/definitions/SingleView"
            },
            {
              $ref: "#/definitions/MultipleViews"
            }
          ]
        },
        type: "array"
      },
      xAxis: {
        $ref: "#/definitions/AxisPosition",
        description: "not supported"
      },
      xDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic x-axis"
      },
      xOffset: {
        description: "Specify the x offset of views in the unit of pixels",
        type: "number"
      },
      yDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic y-axis"
      },
      yOffset: {
        description: "Specify the y offset of views in the unit of pixels",
        type: "number"
      },
      zoomLimits: {
        $ref: "#/definitions/ZoomLimits"
      }
    },
    required: [
      "views"
    ],
    type: "object"
  },
  MultivecData: {
    additionalProperties: false,
    description: 'Two-dimensional quantitative values, one axis for genomic coordinate and the other for different samples, can be converted into HiGlass\' `"multivec"` data. For example, multiple BigWig files can be converted into a single multivec file. You can also convert sequence data (FASTA) into this format where rows will be different nucleotide bases (e.g., A, T, G, C) and quantitative values represent the frequency. Find out more about this format at [HiGlass Docs](https://docs.higlass.io/data_preparation.html#multivec-files).',
    properties: {
      aggregation: {
        $ref: "#/definitions/BinAggregate",
        description: 'Determine aggregation function to apply within bins. __Default__: `"mean"`'
      },
      binSize: {
        description: "Binning the genomic interval in tiles (unit size: 256).",
        type: "number"
      },
      categories: {
        description: "assign names of individual samples.",
        items: {
          type: "string"
        },
        type: "array"
      },
      column: {
        description: 'Assign a field name of the middle position of genomic intervals. __Default__: `"position"`',
        type: "string"
      },
      end: {
        description: 'Assign a field name of the end position of genomic intervals. __Default__: `"end"`',
        type: "string"
      },
      row: {
        description: 'Assign a field name of samples. __Default__: `"category"`',
        type: "string"
      },
      start: {
        description: 'Assign a field name of the start position of genomic intervals. __Default__: `"start"`',
        type: "string"
      },
      type: {
        "const": "multivec",
        type: "string"
      },
      url: {
        description: "Specify the URL address of the data file.",
        type: "string"
      },
      value: {
        description: 'Assign a field name of quantitative values. __Default__: `"value"`',
        type: "string"
      }
    },
    required: [
      "type",
      "url"
    ],
    type: "object"
  },
  OneOfFilter: {
    additionalProperties: false,
    properties: {
      field: {
        description: "A filter is applied based on the values of the specified data field",
        type: "string"
      },
      not: {
        description: 'when `{"not": true}`, apply a NOT logical operation to the filter.\n\n__Default:__ `false`',
        type: "boolean"
      },
      oneOf: {
        description: "Check whether the value is an element in the provided list.",
        items: {
          type: [
            "string",
            "number",
            "null"
          ]
        },
        type: "array"
      },
      type: {
        "const": "filter",
        type: "string"
      }
    },
    required: [
      "field",
      "oneOf",
      "type"
    ],
    type: "object"
  },
  Opacity: {
    additionalProperties: false,
    properties: {
      domain: {
        $ref: "#/definitions/ValueExtent",
        description: "Values of the data"
      },
      field: {
        description: "Name of the data field",
        type: "string"
      },
      range: {
        $ref: "#/definitions/ValueExtent",
        description: "Ranges of visual channel values"
      },
      type: {
        description: "Specify the data type",
        "enum": [
          "quantitative",
          "nominal"
        ],
        type: "string"
      }
    },
    type: "object"
  },
  Orientation: {
    "enum": [
      "horizontal",
      "vertical"
    ],
    type: "string"
  },
  OverlaidTrack: {
    additionalProperties: false,
    description: "Superposing multiple tracks.",
    properties: {
      _assignedHeight: {
        type: "number"
      },
      _assignedWidth: {
        description: "Internal: Used for responsive spec",
        type: "number"
      },
      _invalidTrack: {
        description: "internal",
        type: "boolean"
      },
      _renderingId: {
        description: "internal",
        type: "string"
      },
      assembly: {
        $ref: "#/definitions/Assembly",
        description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
      },
      baselineY: {
        type: "number"
      },
      centerRadius: {
        description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
        type: "number"
      },
      color: {
        anyOf: [
          {
            $ref: "#/definitions/Color"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      data: {
        $ref: "#/definitions/DataDeep"
      },
      dataTransform: {
        items: {
          $ref: "#/definitions/DataTransform"
        },
        type: "array"
      },
      displacement: {
        $ref: "#/definitions/Displacement"
      },
      endAngle: {
        description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      experimental: {
        additionalProperties: false,
        properties: {
          mouseEvents: {
            anyOf: [
              {
                type: "boolean"
              },
              {
                $ref: "#/definitions/MouseEventsDeep"
              }
            ]
          },
          performanceMode: {
            "default": false,
            description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
            type: "boolean"
          }
        },
        type: "object"
      },
      flipY: {
        type: "boolean"
      },
      height: {
        description: "Specify the track height in pixels.",
        type: "number"
      },
      id: {
        type: "string"
      },
      innerRadius: {
        description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
        type: "number"
      },
      layout: {
        $ref: "#/definitions/Layout",
        description: "Specify the layout type of all tracks."
      },
      linkingId: {
        description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
        type: "string"
      },
      mark: {
        $ref: "#/definitions/Mark"
      },
      opacity: {
        anyOf: [
          {
            $ref: "#/definitions/Opacity"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      orientation: {
        $ref: "#/definitions/Orientation",
        description: "Specify the orientation."
      },
      outerRadius: {
        description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
        type: "number"
      },
      overlay: {
        items: {
          additionalProperties: false,
          properties: {
            _assignedHeight: {
              type: "number"
            },
            _assignedWidth: {
              description: "Internal: Used for responsive spec",
              type: "number"
            },
            _invalidTrack: {
              description: "internal",
              type: "boolean"
            },
            _renderingId: {
              description: "internal",
              type: "string"
            },
            assembly: {
              $ref: "#/definitions/Assembly",
              description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
            },
            baselineY: {
              type: "number"
            },
            centerRadius: {
              description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
              type: "number"
            },
            color: {
              anyOf: [
                {
                  $ref: "#/definitions/Color"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            data: {
              $ref: "#/definitions/DataDeep"
            },
            dataTransform: {
              items: {
                $ref: "#/definitions/DataTransform"
              },
              type: "array"
            },
            displacement: {
              $ref: "#/definitions/Displacement"
            },
            endAngle: {
              description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
              type: "number"
            },
            experimental: {
              additionalProperties: false,
              properties: {
                mouseEvents: {
                  anyOf: [
                    {
                      type: "boolean"
                    },
                    {
                      $ref: "#/definitions/MouseEventsDeep"
                    }
                  ]
                },
                performanceMode: {
                  "default": false,
                  description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                  type: "boolean"
                }
              },
              type: "object"
            },
            flipY: {
              type: "boolean"
            },
            id: {
              type: "string"
            },
            innerRadius: {
              description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
              type: "number"
            },
            linkingId: {
              description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
              type: "string"
            },
            mark: {
              $ref: "#/definitions/Mark"
            },
            opacity: {
              anyOf: [
                {
                  $ref: "#/definitions/Opacity"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            orientation: {
              $ref: "#/definitions/Orientation",
              description: "Specify the orientation."
            },
            outerRadius: {
              description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
              type: "number"
            },
            overlayOnPreviousTrack: {
              type: "boolean"
            },
            overrideTemplate: {
              type: "boolean"
            },
            prerelease: {
              additionalProperties: false,
              description: "internal",
              type: "object"
            },
            row: {
              anyOf: [
                {
                  $ref: "#/definitions/Row"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            size: {
              anyOf: [
                {
                  $ref: "#/definitions/Size"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            spacing: {
              description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
              type: "number"
            },
            startAngle: {
              description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
              type: "number"
            },
            "static": {
              description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
              type: "boolean"
            },
            stretch: {
              type: "boolean"
            },
            stroke: {
              anyOf: [
                {
                  $ref: "#/definitions/Stroke"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            strokeWidth: {
              anyOf: [
                {
                  $ref: "#/definitions/StrokeWidth"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            style: {
              $ref: "#/definitions/Style",
              description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
            },
            text: {
              anyOf: [
                {
                  $ref: "#/definitions/Text"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            tooltip: {
              items: {
                $ref: "#/definitions/Tooltip"
              },
              type: "array"
            },
            visibility: {
              items: {
                $ref: "#/definitions/VisibilityCondition"
              },
              type: "array"
            },
            x: {
              anyOf: [
                {
                  $ref: "#/definitions/X"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            x1: {
              anyOf: [
                {
                  $ref: "#/definitions/X"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            x1e: {
              anyOf: [
                {
                  $ref: "#/definitions/X"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            xAxis: {
              $ref: "#/definitions/AxisPosition",
              description: "not supported"
            },
            xDomain: {
              anyOf: [
                {
                  $ref: "#/definitions/DomainInterval"
                },
                {
                  $ref: "#/definitions/DomainChrInterval"
                },
                {
                  $ref: "#/definitions/DomainChr"
                }
              ],
              description: "Specify the visible region of genomic x-axis"
            },
            xOffset: {
              description: "Specify the x offset of views in the unit of pixels",
              type: "number"
            },
            xe: {
              anyOf: [
                {
                  $ref: "#/definitions/X"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            y: {
              anyOf: [
                {
                  $ref: "#/definitions/Y"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            y1: {
              anyOf: [
                {
                  $ref: "#/definitions/Y"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            y1e: {
              anyOf: [
                {
                  $ref: "#/definitions/Y"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            yDomain: {
              anyOf: [
                {
                  $ref: "#/definitions/DomainInterval"
                },
                {
                  $ref: "#/definitions/DomainChrInterval"
                },
                {
                  $ref: "#/definitions/DomainChr"
                }
              ],
              description: "Specify the visible region of genomic y-axis"
            },
            yOffset: {
              description: "Specify the y offset of views in the unit of pixels",
              type: "number"
            },
            ye: {
              anyOf: [
                {
                  $ref: "#/definitions/Y"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            zoomLimits: {
              $ref: "#/definitions/ZoomLimits"
            }
          },
          type: "object"
        },
        type: "array"
      },
      overlayOnPreviousTrack: {
        type: "boolean"
      },
      overrideTemplate: {
        type: "boolean"
      },
      prerelease: {
        additionalProperties: false,
        description: "internal",
        type: "object"
      },
      row: {
        anyOf: [
          {
            $ref: "#/definitions/Row"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      size: {
        anyOf: [
          {
            $ref: "#/definitions/Size"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      spacing: {
        description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
        type: "number"
      },
      startAngle: {
        description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      "static": {
        description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
        type: "boolean"
      },
      stretch: {
        type: "boolean"
      },
      stroke: {
        anyOf: [
          {
            $ref: "#/definitions/Stroke"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      strokeWidth: {
        anyOf: [
          {
            $ref: "#/definitions/StrokeWidth"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      style: {
        $ref: "#/definitions/Style",
        description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
      },
      subtitle: {
        type: "string"
      },
      text: {
        anyOf: [
          {
            $ref: "#/definitions/Text"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      title: {
        description: "If defined, will show the textual label on the left-top corner of a track.",
        type: "string"
      },
      tooltip: {
        items: {
          $ref: "#/definitions/Tooltip"
        },
        type: "array"
      },
      visibility: {
        items: {
          $ref: "#/definitions/VisibilityCondition"
        },
        type: "array"
      },
      width: {
        description: "Specify the track width in pixels.",
        type: "number"
      },
      x: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      x1: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      x1e: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      xAxis: {
        $ref: "#/definitions/AxisPosition",
        description: "not supported"
      },
      xDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic x-axis"
      },
      xOffset: {
        description: "Specify the x offset of views in the unit of pixels",
        type: "number"
      },
      xe: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y1: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y1e: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      yDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic y-axis"
      },
      yOffset: {
        description: "Specify the y offset of views in the unit of pixels",
        type: "number"
      },
      ye: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      zoomLimits: {
        $ref: "#/definitions/ZoomLimits"
      }
    },
    required: [
      "overlay"
    ],
    type: "object"
  },
  OverlaidTracks: {
    additionalProperties: false,
    properties: {
      _assignedHeight: {
        type: "number"
      },
      _assignedWidth: {
        description: "Internal: Used for responsive spec",
        type: "number"
      },
      _invalidTrack: {
        description: "internal",
        type: "boolean"
      },
      _renderingId: {
        description: "internal",
        type: "string"
      },
      alignment: {
        "const": "overlay",
        type: "string"
      },
      assembly: {
        $ref: "#/definitions/Assembly",
        description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
      },
      baselineY: {
        type: "number"
      },
      centerRadius: {
        description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
        type: "number"
      },
      color: {
        anyOf: [
          {
            $ref: "#/definitions/Color"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      data: {
        $ref: "#/definitions/DataDeep"
      },
      dataTransform: {
        items: {
          $ref: "#/definitions/DataTransform"
        },
        type: "array"
      },
      displacement: {
        $ref: "#/definitions/Displacement"
      },
      endAngle: {
        description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      experimental: {
        additionalProperties: false,
        properties: {
          mouseEvents: {
            anyOf: [
              {
                type: "boolean"
              },
              {
                $ref: "#/definitions/MouseEventsDeep"
              }
            ]
          },
          performanceMode: {
            "default": false,
            description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
            type: "boolean"
          }
        },
        type: "object"
      },
      flipY: {
        type: "boolean"
      },
      height: {
        description: "Specify the track height in pixels.",
        type: "number"
      },
      id: {
        type: "string"
      },
      innerRadius: {
        description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
        type: "number"
      },
      layout: {
        $ref: "#/definitions/Layout",
        description: "Specify the layout type of all tracks."
      },
      linkingId: {
        description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
        type: "string"
      },
      mark: {
        $ref: "#/definitions/Mark"
      },
      opacity: {
        anyOf: [
          {
            $ref: "#/definitions/Opacity"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      orientation: {
        $ref: "#/definitions/Orientation",
        description: "Specify the orientation."
      },
      outerRadius: {
        description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
        type: "number"
      },
      overlayOnPreviousTrack: {
        type: "boolean"
      },
      overrideTemplate: {
        type: "boolean"
      },
      prerelease: {
        additionalProperties: false,
        description: "internal",
        type: "object"
      },
      row: {
        anyOf: [
          {
            $ref: "#/definitions/Row"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      size: {
        anyOf: [
          {
            $ref: "#/definitions/Size"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      spacing: {
        description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
        type: "number"
      },
      startAngle: {
        description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      "static": {
        description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
        type: "boolean"
      },
      stretch: {
        type: "boolean"
      },
      stroke: {
        anyOf: [
          {
            $ref: "#/definitions/Stroke"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      strokeWidth: {
        anyOf: [
          {
            $ref: "#/definitions/StrokeWidth"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      style: {
        $ref: "#/definitions/Style",
        description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
      },
      subtitle: {
        type: "string"
      },
      text: {
        anyOf: [
          {
            $ref: "#/definitions/Text"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      title: {
        description: "If defined, will show the textual label on the left-top corner of a track.",
        type: "string"
      },
      tooltip: {
        items: {
          $ref: "#/definitions/Tooltip"
        },
        type: "array"
      },
      tracks: {
        items: {
          $ref: "#/definitions/PartialTrack"
        },
        type: "array"
      },
      visibility: {
        items: {
          $ref: "#/definitions/VisibilityCondition"
        },
        type: "array"
      },
      width: {
        description: "Specify the track width in pixels.",
        type: "number"
      },
      x: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      x1: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      x1e: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      xAxis: {
        $ref: "#/definitions/AxisPosition",
        description: "not supported"
      },
      xDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic x-axis"
      },
      xOffset: {
        description: "Specify the x offset of views in the unit of pixels",
        type: "number"
      },
      xe: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y1: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y1e: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      yDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic y-axis"
      },
      yOffset: {
        description: "Specify the y offset of views in the unit of pixels",
        type: "number"
      },
      ye: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      zoomLimits: {
        $ref: "#/definitions/ZoomLimits"
      }
    },
    required: [
      "alignment",
      "tracks"
    ],
    type: "object"
  },
  PartialTrack: {
    additionalProperties: false,
    properties: {
      _assignedHeight: {
        type: "number"
      },
      _assignedWidth: {
        description: "Internal: Used for responsive spec",
        type: "number"
      },
      _invalidTrack: {
        description: "internal",
        type: "boolean"
      },
      _renderingId: {
        description: "internal",
        type: "string"
      },
      assembly: {
        $ref: "#/definitions/Assembly",
        description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
      },
      baselineY: {
        type: "number"
      },
      centerRadius: {
        description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
        type: "number"
      },
      color: {
        anyOf: [
          {
            $ref: "#/definitions/Color"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      data: {
        $ref: "#/definitions/DataDeep"
      },
      dataTransform: {
        items: {
          $ref: "#/definitions/DataTransform"
        },
        type: "array"
      },
      displacement: {
        $ref: "#/definitions/Displacement"
      },
      encoding: {
        additionalProperties: {
          $ref: "#/definitions/Channel"
        },
        type: "object"
      },
      endAngle: {
        description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      experimental: {
        additionalProperties: false,
        properties: {
          mouseEvents: {
            anyOf: [
              {
                type: "boolean"
              },
              {
                $ref: "#/definitions/MouseEventsDeep"
              }
            ]
          },
          performanceMode: {
            "default": false,
            description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
            type: "boolean"
          }
        },
        type: "object"
      },
      flipY: {
        type: "boolean"
      },
      height: {
        description: "Specify the track height in pixels.",
        type: "number"
      },
      id: {
        type: "string"
      },
      innerRadius: {
        description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
        type: "number"
      },
      layout: {
        $ref: "#/definitions/Layout",
        description: "Specify the layout type of all tracks."
      },
      linkingId: {
        description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
        type: "string"
      },
      mark: {
        $ref: "#/definitions/Mark"
      },
      opacity: {
        anyOf: [
          {
            $ref: "#/definitions/Opacity"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      orientation: {
        $ref: "#/definitions/Orientation",
        description: "Specify the orientation."
      },
      outerRadius: {
        description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
        type: "number"
      },
      overlay: {
        items: {
          additionalProperties: false,
          properties: {
            _assignedHeight: {
              type: "number"
            },
            _assignedWidth: {
              description: "Internal: Used for responsive spec",
              type: "number"
            },
            _invalidTrack: {
              description: "internal",
              type: "boolean"
            },
            _renderingId: {
              description: "internal",
              type: "string"
            },
            assembly: {
              $ref: "#/definitions/Assembly",
              description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
            },
            baselineY: {
              type: "number"
            },
            centerRadius: {
              description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
              type: "number"
            },
            color: {
              anyOf: [
                {
                  $ref: "#/definitions/Color"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            data: {
              $ref: "#/definitions/DataDeep"
            },
            dataTransform: {
              items: {
                $ref: "#/definitions/DataTransform"
              },
              type: "array"
            },
            displacement: {
              $ref: "#/definitions/Displacement"
            },
            endAngle: {
              description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
              type: "number"
            },
            experimental: {
              additionalProperties: false,
              properties: {
                mouseEvents: {
                  anyOf: [
                    {
                      type: "boolean"
                    },
                    {
                      $ref: "#/definitions/MouseEventsDeep"
                    }
                  ]
                },
                performanceMode: {
                  "default": false,
                  description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                  type: "boolean"
                }
              },
              type: "object"
            },
            flipY: {
              type: "boolean"
            },
            id: {
              type: "string"
            },
            innerRadius: {
              description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
              type: "number"
            },
            linkingId: {
              description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
              type: "string"
            },
            mark: {
              $ref: "#/definitions/Mark"
            },
            opacity: {
              anyOf: [
                {
                  $ref: "#/definitions/Opacity"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            orientation: {
              $ref: "#/definitions/Orientation",
              description: "Specify the orientation."
            },
            outerRadius: {
              description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
              type: "number"
            },
            overlayOnPreviousTrack: {
              type: "boolean"
            },
            overrideTemplate: {
              type: "boolean"
            },
            prerelease: {
              additionalProperties: false,
              description: "internal",
              type: "object"
            },
            row: {
              anyOf: [
                {
                  $ref: "#/definitions/Row"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            size: {
              anyOf: [
                {
                  $ref: "#/definitions/Size"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            spacing: {
              description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
              type: "number"
            },
            startAngle: {
              description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
              type: "number"
            },
            "static": {
              description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
              type: "boolean"
            },
            stretch: {
              type: "boolean"
            },
            stroke: {
              anyOf: [
                {
                  $ref: "#/definitions/Stroke"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            strokeWidth: {
              anyOf: [
                {
                  $ref: "#/definitions/StrokeWidth"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            style: {
              $ref: "#/definitions/Style",
              description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
            },
            text: {
              anyOf: [
                {
                  $ref: "#/definitions/Text"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            tooltip: {
              items: {
                $ref: "#/definitions/Tooltip"
              },
              type: "array"
            },
            visibility: {
              items: {
                $ref: "#/definitions/VisibilityCondition"
              },
              type: "array"
            },
            x: {
              anyOf: [
                {
                  $ref: "#/definitions/X"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            x1: {
              anyOf: [
                {
                  $ref: "#/definitions/X"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            x1e: {
              anyOf: [
                {
                  $ref: "#/definitions/X"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            xAxis: {
              $ref: "#/definitions/AxisPosition",
              description: "not supported"
            },
            xDomain: {
              anyOf: [
                {
                  $ref: "#/definitions/DomainInterval"
                },
                {
                  $ref: "#/definitions/DomainChrInterval"
                },
                {
                  $ref: "#/definitions/DomainChr"
                }
              ],
              description: "Specify the visible region of genomic x-axis"
            },
            xOffset: {
              description: "Specify the x offset of views in the unit of pixels",
              type: "number"
            },
            xe: {
              anyOf: [
                {
                  $ref: "#/definitions/X"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            y: {
              anyOf: [
                {
                  $ref: "#/definitions/Y"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            y1: {
              anyOf: [
                {
                  $ref: "#/definitions/Y"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            y1e: {
              anyOf: [
                {
                  $ref: "#/definitions/Y"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            yDomain: {
              anyOf: [
                {
                  $ref: "#/definitions/DomainInterval"
                },
                {
                  $ref: "#/definitions/DomainChrInterval"
                },
                {
                  $ref: "#/definitions/DomainChr"
                }
              ],
              description: "Specify the visible region of genomic y-axis"
            },
            yOffset: {
              description: "Specify the y offset of views in the unit of pixels",
              type: "number"
            },
            ye: {
              anyOf: [
                {
                  $ref: "#/definitions/Y"
                },
                {
                  $ref: "#/definitions/ChannelValue"
                }
              ]
            },
            zoomLimits: {
              $ref: "#/definitions/ZoomLimits"
            }
          },
          type: "object"
        },
        type: "array"
      },
      overlayOnPreviousTrack: {
        type: "boolean"
      },
      overrideTemplate: {
        type: "boolean"
      },
      prerelease: {
        additionalProperties: false,
        description: "internal",
        type: "object"
      },
      row: {
        anyOf: [
          {
            $ref: "#/definitions/Row"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      size: {
        anyOf: [
          {
            $ref: "#/definitions/Size"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      spacing: {
        description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
        type: "number"
      },
      startAngle: {
        description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      "static": {
        description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
        type: "boolean"
      },
      stretch: {
        type: "boolean"
      },
      stroke: {
        anyOf: [
          {
            $ref: "#/definitions/Stroke"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      strokeWidth: {
        anyOf: [
          {
            $ref: "#/definitions/StrokeWidth"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      style: {
        $ref: "#/definitions/Style",
        description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
      },
      subtitle: {
        type: "string"
      },
      template: {
        type: "string"
      },
      text: {
        anyOf: [
          {
            $ref: "#/definitions/Text"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      title: {
        description: "If defined, will show the textual label on the left-top corner of a track.",
        type: "string"
      },
      tooltip: {
        items: {
          $ref: "#/definitions/Tooltip"
        },
        type: "array"
      },
      visibility: {
        items: {
          $ref: "#/definitions/VisibilityCondition"
        },
        type: "array"
      },
      width: {
        description: "Specify the track width in pixels.",
        type: "number"
      },
      x: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      x1: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      x1e: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      xAxis: {
        $ref: "#/definitions/AxisPosition",
        description: "not supported"
      },
      xDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic x-axis"
      },
      xOffset: {
        description: "Specify the x offset of views in the unit of pixels",
        type: "number"
      },
      xe: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y1: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y1e: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      yDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic y-axis"
      },
      yOffset: {
        description: "Specify the y offset of views in the unit of pixels",
        type: "number"
      },
      ye: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      zoomLimits: {
        $ref: "#/definitions/ZoomLimits"
      }
    },
    type: "object"
  },
  PredefinedColors: {
    "enum": [
      "viridis",
      "grey",
      "spectral",
      "warm",
      "cividis",
      "bupu",
      "rdbu",
      "hot",
      "pink"
    ],
    type: "string"
  },
  Range: {
    anyOf: [
      {
        $ref: "#/definitions/ValueExtent"
      },
      {
        $ref: "#/definitions/PredefinedColors"
      }
    ]
  },
  RangeFilter: {
    additionalProperties: false,
    properties: {
      field: {
        description: "A filter is applied based on the values of the specified data field",
        type: "string"
      },
      inRange: {
        description: "Check whether the value is in a number range.",
        items: {
          type: "number"
        },
        type: "array"
      },
      not: {
        description: 'when `{"not": true}`, apply a NOT logical operation to the filter.\n\n__Default:__ `false`',
        type: "boolean"
      },
      type: {
        "const": "filter",
        type: "string"
      }
    },
    required: [
      "field",
      "inRange",
      "type"
    ],
    type: "object"
  },
  ResponsiveSize: {
    anyOf: [
      {
        type: "boolean"
      },
      {
        additionalProperties: false,
        properties: {
          height: {
            type: "boolean"
          },
          width: {
            type: "boolean"
          }
        },
        type: "object"
      }
    ]
  },
  Row: {
    additionalProperties: false,
    properties: {
      clip: {
        description: "Clip row when the actual y value exceeds the max value of the y scale. Used only for bar marks at the moment. __Default__: `true`",
        type: "boolean"
      },
      domain: {
        $ref: "#/definitions/ValueExtent",
        description: "Values of the data"
      },
      field: {
        description: "Name of the data field",
        type: "string"
      },
      grid: {
        description: "Whether to display grid. __Default__: `false`",
        type: "boolean"
      },
      legend: {
        description: "Whether to display legend. __Default__: `false`",
        type: "boolean"
      },
      padding: {
        description: "Determines the size of inner white spaces on the top and bottom of individiual rows. __Default__: `0`",
        type: "number"
      },
      range: {
        $ref: "#/definitions/ValueExtent",
        description: "Determine the start and end position of rendering area of this track along vertical axis. __Default__: `[0, height]`"
      },
      type: {
        "const": "nominal",
        description: "Specify the data type",
        type: "string"
      }
    },
    type: "object"
  },
  SelectivityCondition: {
    additionalProperties: false,
    properties: {
      measure: {
        "enum": [
          "width",
          "height",
          "aspectRatio"
        ],
        type: "string"
      },
      operation: {
        $ref: "#/definitions/LogicalOperation"
      },
      target: {
        description: "Does the condition applied to the visualization itself or its container? __Default__: `'self'`",
        "enum": [
          "self",
          "container"
        ],
        type: "string"
      },
      threshold: {
        description: "Threshold in the unit of pixels.",
        type: "number"
      }
    },
    required: [
      "operation",
      "measure",
      "threshold"
    ],
    type: "object"
  },
  SingleTrack: {
    additionalProperties: false,
    properties: {
      _assignedHeight: {
        type: "number"
      },
      _assignedWidth: {
        description: "Internal: Used for responsive spec",
        type: "number"
      },
      _invalidTrack: {
        description: "internal",
        type: "boolean"
      },
      _renderingId: {
        description: "internal",
        type: "string"
      },
      assembly: {
        $ref: "#/definitions/Assembly",
        description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
      },
      baselineY: {
        type: "number"
      },
      centerRadius: {
        description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
        type: "number"
      },
      color: {
        anyOf: [
          {
            $ref: "#/definitions/Color"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      data: {
        $ref: "#/definitions/DataDeep"
      },
      dataTransform: {
        items: {
          $ref: "#/definitions/DataTransform"
        },
        type: "array"
      },
      displacement: {
        $ref: "#/definitions/Displacement"
      },
      endAngle: {
        description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      experimental: {
        additionalProperties: false,
        properties: {
          mouseEvents: {
            anyOf: [
              {
                type: "boolean"
              },
              {
                $ref: "#/definitions/MouseEventsDeep"
              }
            ]
          },
          performanceMode: {
            "default": false,
            description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
            type: "boolean"
          }
        },
        type: "object"
      },
      flipY: {
        type: "boolean"
      },
      height: {
        description: "Specify the track height in pixels.",
        type: "number"
      },
      id: {
        type: "string"
      },
      innerRadius: {
        description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
        type: "number"
      },
      layout: {
        $ref: "#/definitions/Layout",
        description: "Specify the layout type of all tracks."
      },
      linkingId: {
        description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
        type: "string"
      },
      mark: {
        $ref: "#/definitions/Mark"
      },
      opacity: {
        anyOf: [
          {
            $ref: "#/definitions/Opacity"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      orientation: {
        $ref: "#/definitions/Orientation",
        description: "Specify the orientation."
      },
      outerRadius: {
        description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
        type: "number"
      },
      overlayOnPreviousTrack: {
        type: "boolean"
      },
      overrideTemplate: {
        type: "boolean"
      },
      prerelease: {
        additionalProperties: false,
        description: "internal",
        type: "object"
      },
      row: {
        anyOf: [
          {
            $ref: "#/definitions/Row"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      size: {
        anyOf: [
          {
            $ref: "#/definitions/Size"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      spacing: {
        description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
        type: "number"
      },
      startAngle: {
        description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      "static": {
        description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
        type: "boolean"
      },
      stretch: {
        type: "boolean"
      },
      stroke: {
        anyOf: [
          {
            $ref: "#/definitions/Stroke"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      strokeWidth: {
        anyOf: [
          {
            $ref: "#/definitions/StrokeWidth"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      style: {
        $ref: "#/definitions/Style",
        description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
      },
      subtitle: {
        type: "string"
      },
      text: {
        anyOf: [
          {
            $ref: "#/definitions/Text"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      title: {
        description: "If defined, will show the textual label on the left-top corner of a track.",
        type: "string"
      },
      tooltip: {
        items: {
          $ref: "#/definitions/Tooltip"
        },
        type: "array"
      },
      visibility: {
        items: {
          $ref: "#/definitions/VisibilityCondition"
        },
        type: "array"
      },
      width: {
        description: "Specify the track width in pixels.",
        type: "number"
      },
      x: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      x1: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      x1e: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      xAxis: {
        $ref: "#/definitions/AxisPosition",
        description: "not supported"
      },
      xDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic x-axis"
      },
      xOffset: {
        description: "Specify the x offset of views in the unit of pixels",
        type: "number"
      },
      xe: {
        anyOf: [
          {
            $ref: "#/definitions/X"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y1: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      y1e: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      yDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic y-axis"
      },
      yOffset: {
        description: "Specify the y offset of views in the unit of pixels",
        type: "number"
      },
      ye: {
        anyOf: [
          {
            $ref: "#/definitions/Y"
          },
          {
            $ref: "#/definitions/ChannelValue"
          }
        ]
      },
      zoomLimits: {
        $ref: "#/definitions/ZoomLimits"
      }
    },
    required: [
      "data",
      "mark"
    ],
    type: "object"
  },
  SingleView: {
    anyOf: [
      {
        additionalProperties: false,
        properties: {
          _assignedHeight: {
            type: "number"
          },
          _assignedWidth: {
            description: "Internal: Used for responsive spec",
            type: "number"
          },
          _invalidTrack: {
            description: "internal",
            type: "boolean"
          },
          _renderingId: {
            description: "internal",
            type: "string"
          },
          alignment: {
            "const": "overlay",
            type: "string"
          },
          assembly: {
            $ref: "#/definitions/Assembly",
            description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
          },
          baselineY: {
            type: "number"
          },
          centerRadius: {
            description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
            type: "number"
          },
          color: {
            anyOf: [
              {
                $ref: "#/definitions/Color"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          data: {
            $ref: "#/definitions/DataDeep"
          },
          dataTransform: {
            items: {
              $ref: "#/definitions/DataTransform"
            },
            type: "array"
          },
          displacement: {
            $ref: "#/definitions/Displacement"
          },
          endAngle: {
            description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
            type: "number"
          },
          experimental: {
            additionalProperties: false,
            properties: {
              mouseEvents: {
                anyOf: [
                  {
                    type: "boolean"
                  },
                  {
                    $ref: "#/definitions/MouseEventsDeep"
                  }
                ]
              },
              performanceMode: {
                "default": false,
                description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                type: "boolean"
              }
            },
            type: "object"
          },
          flipY: {
            type: "boolean"
          },
          height: {
            description: "Specify the track height in pixels.",
            type: "number"
          },
          id: {
            type: "string"
          },
          innerRadius: {
            description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
            type: "number"
          },
          layout: {
            $ref: "#/definitions/Layout",
            description: "Specify the layout type of all tracks."
          },
          linkingId: {
            description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
            type: "string"
          },
          mark: {
            $ref: "#/definitions/Mark"
          },
          opacity: {
            anyOf: [
              {
                $ref: "#/definitions/Opacity"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          orientation: {
            $ref: "#/definitions/Orientation",
            description: "Specify the orientation."
          },
          outerRadius: {
            description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
            type: "number"
          },
          overlayOnPreviousTrack: {
            type: "boolean"
          },
          overrideTemplate: {
            type: "boolean"
          },
          prerelease: {
            additionalProperties: false,
            description: "internal",
            type: "object"
          },
          responsiveSpec: {
            items: {
              additionalProperties: false,
              properties: {
                selectivity: {
                  items: {
                    $ref: "#/definitions/SelectivityCondition"
                  },
                  type: "array"
                },
                spec: {
                  additionalProperties: false,
                  properties: {
                    _assignedHeight: {
                      type: "number"
                    },
                    _assignedWidth: {
                      description: "Internal: Used for responsive spec",
                      type: "number"
                    },
                    _invalidTrack: {
                      description: "internal",
                      type: "boolean"
                    },
                    _renderingId: {
                      description: "internal",
                      type: "string"
                    },
                    alignment: {
                      "enum": [
                        "overlay",
                        "stack"
                      ],
                      type: "string"
                    },
                    assembly: {
                      $ref: "#/definitions/Assembly",
                      description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
                    },
                    baselineY: {
                      type: "number"
                    },
                    centerRadius: {
                      description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
                      type: "number"
                    },
                    color: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Color"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    data: {
                      $ref: "#/definitions/DataDeep"
                    },
                    dataTransform: {
                      items: {
                        $ref: "#/definitions/DataTransform"
                      },
                      type: "array"
                    },
                    displacement: {
                      $ref: "#/definitions/Displacement"
                    },
                    endAngle: {
                      description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    experimental: {
                      additionalProperties: false,
                      properties: {
                        mouseEvents: {
                          anyOf: [
                            {
                              type: "boolean"
                            },
                            {
                              $ref: "#/definitions/MouseEventsDeep"
                            }
                          ]
                        },
                        performanceMode: {
                          "default": false,
                          description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                          type: "boolean"
                        }
                      },
                      type: "object"
                    },
                    flipY: {
                      type: "boolean"
                    },
                    height: {
                      description: "Specify the track height in pixels.",
                      type: "number"
                    },
                    id: {
                      type: "string"
                    },
                    innerRadius: {
                      description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    layout: {
                      $ref: "#/definitions/Layout",
                      description: "Specify the layout type of all tracks."
                    },
                    linkingId: {
                      description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
                      type: "string"
                    },
                    mark: {
                      $ref: "#/definitions/Mark"
                    },
                    opacity: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Opacity"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    orientation: {
                      $ref: "#/definitions/Orientation",
                      description: "Specify the orientation."
                    },
                    outerRadius: {
                      description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
                      type: "number"
                    },
                    overlayOnPreviousTrack: {
                      type: "boolean"
                    },
                    overrideTemplate: {
                      type: "boolean"
                    },
                    prerelease: {
                      additionalProperties: false,
                      description: "internal",
                      type: "object"
                    },
                    row: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Row"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    size: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Size"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    spacing: {
                      description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
                      type: "number"
                    },
                    startAngle: {
                      description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    "static": {
                      description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
                      type: "boolean"
                    },
                    stretch: {
                      type: "boolean"
                    },
                    stroke: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Stroke"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    strokeWidth: {
                      anyOf: [
                        {
                          $ref: "#/definitions/StrokeWidth"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    style: {
                      $ref: "#/definitions/Style",
                      description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
                    },
                    subtitle: {
                      type: "string"
                    },
                    text: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Text"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    title: {
                      description: "If defined, will show the textual label on the left-top corner of a track.",
                      type: "string"
                    },
                    tooltip: {
                      items: {
                        $ref: "#/definitions/Tooltip"
                      },
                      type: "array"
                    },
                    tracks: {
                      anyOf: [
                        {
                          items: {
                            $ref: "#/definitions/PartialTrack"
                          },
                          type: "array"
                        },
                        {
                          items: {
                            anyOf: [
                              {
                                $ref: "#/definitions/PartialTrack"
                              },
                              {
                                $ref: "#/definitions/OverlaidTracks"
                              }
                            ]
                          },
                          type: "array"
                        }
                      ]
                    },
                    visibility: {
                      items: {
                        $ref: "#/definitions/VisibilityCondition"
                      },
                      type: "array"
                    },
                    width: {
                      description: "Specify the track width in pixels.",
                      type: "number"
                    },
                    x: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    xAxis: {
                      $ref: "#/definitions/AxisPosition",
                      description: "not supported"
                    },
                    xDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic x-axis"
                    },
                    xOffset: {
                      description: "Specify the x offset of views in the unit of pixels",
                      type: "number"
                    },
                    xe: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    yDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic y-axis"
                    },
                    yOffset: {
                      description: "Specify the y offset of views in the unit of pixels",
                      type: "number"
                    },
                    ye: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    zoomLimits: {
                      $ref: "#/definitions/ZoomLimits"
                    }
                  },
                  type: "object"
                }
              },
              required: [
                "spec",
                "selectivity"
              ],
              type: "object"
            },
            type: "array"
          },
          row: {
            anyOf: [
              {
                $ref: "#/definitions/Row"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          size: {
            anyOf: [
              {
                $ref: "#/definitions/Size"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          spacing: {
            description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
            type: "number"
          },
          startAngle: {
            description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
            type: "number"
          },
          "static": {
            description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
            type: "boolean"
          },
          stretch: {
            type: "boolean"
          },
          stroke: {
            anyOf: [
              {
                $ref: "#/definitions/Stroke"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          strokeWidth: {
            anyOf: [
              {
                $ref: "#/definitions/StrokeWidth"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          style: {
            $ref: "#/definitions/Style",
            description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
          },
          subtitle: {
            type: "string"
          },
          text: {
            anyOf: [
              {
                $ref: "#/definitions/Text"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          title: {
            description: "If defined, will show the textual label on the left-top corner of a track.",
            type: "string"
          },
          tooltip: {
            items: {
              $ref: "#/definitions/Tooltip"
            },
            type: "array"
          },
          tracks: {
            items: {
              $ref: "#/definitions/PartialTrack"
            },
            type: "array"
          },
          visibility: {
            items: {
              $ref: "#/definitions/VisibilityCondition"
            },
            type: "array"
          },
          width: {
            description: "Specify the track width in pixels.",
            type: "number"
          },
          x: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          x1: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          x1e: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          xAxis: {
            $ref: "#/definitions/AxisPosition",
            description: "not supported"
          },
          xDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic x-axis"
          },
          xOffset: {
            description: "Specify the x offset of views in the unit of pixels",
            type: "number"
          },
          xe: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y1: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y1e: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          yDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic y-axis"
          },
          yOffset: {
            description: "Specify the y offset of views in the unit of pixels",
            type: "number"
          },
          ye: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          zoomLimits: {
            $ref: "#/definitions/ZoomLimits"
          }
        },
        required: [
          "alignment",
          "tracks"
        ],
        type: "object"
      },
      {
        additionalProperties: false,
        properties: {
          _assignedHeight: {
            type: "number"
          },
          _assignedWidth: {
            description: "Internal: Used for responsive spec",
            type: "number"
          },
          _invalidTrack: {
            description: "internal",
            type: "boolean"
          },
          _renderingId: {
            description: "internal",
            type: "string"
          },
          alignment: {
            "const": "stack",
            type: "string"
          },
          assembly: {
            $ref: "#/definitions/Assembly",
            description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
          },
          baselineY: {
            type: "number"
          },
          centerRadius: {
            description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
            type: "number"
          },
          color: {
            anyOf: [
              {
                $ref: "#/definitions/Color"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          data: {
            $ref: "#/definitions/DataDeep"
          },
          dataTransform: {
            items: {
              $ref: "#/definitions/DataTransform"
            },
            type: "array"
          },
          displacement: {
            $ref: "#/definitions/Displacement"
          },
          endAngle: {
            description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
            type: "number"
          },
          experimental: {
            additionalProperties: false,
            properties: {
              mouseEvents: {
                anyOf: [
                  {
                    type: "boolean"
                  },
                  {
                    $ref: "#/definitions/MouseEventsDeep"
                  }
                ]
              },
              performanceMode: {
                "default": false,
                description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                type: "boolean"
              }
            },
            type: "object"
          },
          flipY: {
            type: "boolean"
          },
          height: {
            description: "Specify the track height in pixels.",
            type: "number"
          },
          id: {
            type: "string"
          },
          innerRadius: {
            description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
            type: "number"
          },
          layout: {
            $ref: "#/definitions/Layout",
            description: "Specify the layout type of all tracks."
          },
          linkingId: {
            description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
            type: "string"
          },
          mark: {
            $ref: "#/definitions/Mark"
          },
          opacity: {
            anyOf: [
              {
                $ref: "#/definitions/Opacity"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          orientation: {
            $ref: "#/definitions/Orientation",
            description: "Specify the orientation."
          },
          outerRadius: {
            description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
            type: "number"
          },
          overlayOnPreviousTrack: {
            type: "boolean"
          },
          overrideTemplate: {
            type: "boolean"
          },
          prerelease: {
            additionalProperties: false,
            description: "internal",
            type: "object"
          },
          responsiveSpec: {
            items: {
              additionalProperties: false,
              properties: {
                selectivity: {
                  items: {
                    $ref: "#/definitions/SelectivityCondition"
                  },
                  type: "array"
                },
                spec: {
                  additionalProperties: false,
                  properties: {
                    _assignedHeight: {
                      type: "number"
                    },
                    _assignedWidth: {
                      description: "Internal: Used for responsive spec",
                      type: "number"
                    },
                    _invalidTrack: {
                      description: "internal",
                      type: "boolean"
                    },
                    _renderingId: {
                      description: "internal",
                      type: "string"
                    },
                    alignment: {
                      "enum": [
                        "overlay",
                        "stack"
                      ],
                      type: "string"
                    },
                    assembly: {
                      $ref: "#/definitions/Assembly",
                      description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
                    },
                    baselineY: {
                      type: "number"
                    },
                    centerRadius: {
                      description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
                      type: "number"
                    },
                    color: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Color"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    data: {
                      $ref: "#/definitions/DataDeep"
                    },
                    dataTransform: {
                      items: {
                        $ref: "#/definitions/DataTransform"
                      },
                      type: "array"
                    },
                    displacement: {
                      $ref: "#/definitions/Displacement"
                    },
                    endAngle: {
                      description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    experimental: {
                      additionalProperties: false,
                      properties: {
                        mouseEvents: {
                          anyOf: [
                            {
                              type: "boolean"
                            },
                            {
                              $ref: "#/definitions/MouseEventsDeep"
                            }
                          ]
                        },
                        performanceMode: {
                          "default": false,
                          description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                          type: "boolean"
                        }
                      },
                      type: "object"
                    },
                    flipY: {
                      type: "boolean"
                    },
                    height: {
                      description: "Specify the track height in pixels.",
                      type: "number"
                    },
                    id: {
                      type: "string"
                    },
                    innerRadius: {
                      description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    layout: {
                      $ref: "#/definitions/Layout",
                      description: "Specify the layout type of all tracks."
                    },
                    linkingId: {
                      description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
                      type: "string"
                    },
                    mark: {
                      $ref: "#/definitions/Mark"
                    },
                    opacity: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Opacity"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    orientation: {
                      $ref: "#/definitions/Orientation",
                      description: "Specify the orientation."
                    },
                    outerRadius: {
                      description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
                      type: "number"
                    },
                    overlayOnPreviousTrack: {
                      type: "boolean"
                    },
                    overrideTemplate: {
                      type: "boolean"
                    },
                    prerelease: {
                      additionalProperties: false,
                      description: "internal",
                      type: "object"
                    },
                    row: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Row"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    size: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Size"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    spacing: {
                      description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
                      type: "number"
                    },
                    startAngle: {
                      description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    "static": {
                      description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
                      type: "boolean"
                    },
                    stretch: {
                      type: "boolean"
                    },
                    stroke: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Stroke"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    strokeWidth: {
                      anyOf: [
                        {
                          $ref: "#/definitions/StrokeWidth"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    style: {
                      $ref: "#/definitions/Style",
                      description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
                    },
                    subtitle: {
                      type: "string"
                    },
                    text: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Text"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    title: {
                      description: "If defined, will show the textual label on the left-top corner of a track.",
                      type: "string"
                    },
                    tooltip: {
                      items: {
                        $ref: "#/definitions/Tooltip"
                      },
                      type: "array"
                    },
                    tracks: {
                      anyOf: [
                        {
                          items: {
                            $ref: "#/definitions/PartialTrack"
                          },
                          type: "array"
                        },
                        {
                          items: {
                            anyOf: [
                              {
                                $ref: "#/definitions/PartialTrack"
                              },
                              {
                                $ref: "#/definitions/OverlaidTracks"
                              }
                            ]
                          },
                          type: "array"
                        }
                      ]
                    },
                    visibility: {
                      items: {
                        $ref: "#/definitions/VisibilityCondition"
                      },
                      type: "array"
                    },
                    width: {
                      description: "Specify the track width in pixels.",
                      type: "number"
                    },
                    x: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    xAxis: {
                      $ref: "#/definitions/AxisPosition",
                      description: "not supported"
                    },
                    xDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic x-axis"
                    },
                    xOffset: {
                      description: "Specify the x offset of views in the unit of pixels",
                      type: "number"
                    },
                    xe: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    yDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic y-axis"
                    },
                    yOffset: {
                      description: "Specify the y offset of views in the unit of pixels",
                      type: "number"
                    },
                    ye: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    zoomLimits: {
                      $ref: "#/definitions/ZoomLimits"
                    }
                  },
                  type: "object"
                }
              },
              required: [
                "spec",
                "selectivity"
              ],
              type: "object"
            },
            type: "array"
          },
          row: {
            anyOf: [
              {
                $ref: "#/definitions/Row"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          size: {
            anyOf: [
              {
                $ref: "#/definitions/Size"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          spacing: {
            description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
            type: "number"
          },
          startAngle: {
            description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
            type: "number"
          },
          "static": {
            description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
            type: "boolean"
          },
          stretch: {
            type: "boolean"
          },
          stroke: {
            anyOf: [
              {
                $ref: "#/definitions/Stroke"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          strokeWidth: {
            anyOf: [
              {
                $ref: "#/definitions/StrokeWidth"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          style: {
            $ref: "#/definitions/Style",
            description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
          },
          subtitle: {
            type: "string"
          },
          text: {
            anyOf: [
              {
                $ref: "#/definitions/Text"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          title: {
            description: "If defined, will show the textual label on the left-top corner of a track.",
            type: "string"
          },
          tooltip: {
            items: {
              $ref: "#/definitions/Tooltip"
            },
            type: "array"
          },
          tracks: {
            items: {
              anyOf: [
                {
                  $ref: "#/definitions/PartialTrack"
                },
                {
                  $ref: "#/definitions/OverlaidTracks"
                }
              ]
            },
            type: "array"
          },
          visibility: {
            items: {
              $ref: "#/definitions/VisibilityCondition"
            },
            type: "array"
          },
          width: {
            description: "Specify the track width in pixels.",
            type: "number"
          },
          x: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          x1: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          x1e: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          xAxis: {
            $ref: "#/definitions/AxisPosition",
            description: "not supported"
          },
          xDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic x-axis"
          },
          xOffset: {
            description: "Specify the x offset of views in the unit of pixels",
            type: "number"
          },
          xe: {
            anyOf: [
              {
                $ref: "#/definitions/X"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y1: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          y1e: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          yDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic y-axis"
          },
          yOffset: {
            description: "Specify the y offset of views in the unit of pixels",
            type: "number"
          },
          ye: {
            anyOf: [
              {
                $ref: "#/definitions/Y"
              },
              {
                $ref: "#/definitions/ChannelValue"
              }
            ]
          },
          zoomLimits: {
            $ref: "#/definitions/ZoomLimits"
          }
        },
        required: [
          "tracks"
        ],
        type: "object"
      },
      {
        additionalProperties: false,
        properties: {
          _assignedHeight: {
            type: "number"
          },
          _assignedWidth: {
            description: "Internal: Used for responsive spec",
            type: "number"
          },
          assembly: {
            $ref: "#/definitions/Assembly",
            description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
          },
          centerRadius: {
            description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
            type: "number"
          },
          layout: {
            $ref: "#/definitions/Layout",
            description: "Specify the layout type of all tracks."
          },
          linkingId: {
            description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
            type: "string"
          },
          orientation: {
            $ref: "#/definitions/Orientation",
            description: "Specify the orientation."
          },
          responsiveSpec: {
            items: {
              additionalProperties: false,
              properties: {
                selectivity: {
                  items: {
                    $ref: "#/definitions/SelectivityCondition"
                  },
                  type: "array"
                },
                spec: {
                  additionalProperties: false,
                  properties: {
                    _assignedHeight: {
                      type: "number"
                    },
                    _assignedWidth: {
                      description: "Internal: Used for responsive spec",
                      type: "number"
                    },
                    _invalidTrack: {
                      description: "internal",
                      type: "boolean"
                    },
                    _renderingId: {
                      description: "internal",
                      type: "string"
                    },
                    alignment: {
                      "enum": [
                        "overlay",
                        "stack"
                      ],
                      type: "string"
                    },
                    assembly: {
                      $ref: "#/definitions/Assembly",
                      description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
                    },
                    baselineY: {
                      type: "number"
                    },
                    centerRadius: {
                      description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
                      type: "number"
                    },
                    color: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Color"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    data: {
                      $ref: "#/definitions/DataDeep"
                    },
                    dataTransform: {
                      items: {
                        $ref: "#/definitions/DataTransform"
                      },
                      type: "array"
                    },
                    displacement: {
                      $ref: "#/definitions/Displacement"
                    },
                    endAngle: {
                      description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    experimental: {
                      additionalProperties: false,
                      properties: {
                        mouseEvents: {
                          anyOf: [
                            {
                              type: "boolean"
                            },
                            {
                              $ref: "#/definitions/MouseEventsDeep"
                            }
                          ]
                        },
                        performanceMode: {
                          "default": false,
                          description: "Render visual marks with less smooth curves to increase rendering performance. Only supported for `elliptical` `linkStyle` `withinLink` currently.",
                          type: "boolean"
                        }
                      },
                      type: "object"
                    },
                    flipY: {
                      type: "boolean"
                    },
                    height: {
                      description: "Specify the track height in pixels.",
                      type: "number"
                    },
                    id: {
                      type: "string"
                    },
                    innerRadius: {
                      description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    layout: {
                      $ref: "#/definitions/Layout",
                      description: "Specify the layout type of all tracks."
                    },
                    linkingId: {
                      description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
                      type: "string"
                    },
                    mark: {
                      $ref: "#/definitions/Mark"
                    },
                    opacity: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Opacity"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    orientation: {
                      $ref: "#/definitions/Orientation",
                      description: "Specify the orientation."
                    },
                    outerRadius: {
                      description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
                      type: "number"
                    },
                    overlayOnPreviousTrack: {
                      type: "boolean"
                    },
                    overrideTemplate: {
                      type: "boolean"
                    },
                    prerelease: {
                      additionalProperties: false,
                      description: "internal",
                      type: "object"
                    },
                    row: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Row"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    size: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Size"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    spacing: {
                      description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
                      type: "number"
                    },
                    startAngle: {
                      description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
                      type: "number"
                    },
                    "static": {
                      description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
                      type: "boolean"
                    },
                    stretch: {
                      type: "boolean"
                    },
                    stroke: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Stroke"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    strokeWidth: {
                      anyOf: [
                        {
                          $ref: "#/definitions/StrokeWidth"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    style: {
                      $ref: "#/definitions/Style",
                      description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
                    },
                    subtitle: {
                      type: "string"
                    },
                    text: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Text"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    title: {
                      description: "If defined, will show the textual label on the left-top corner of a track.",
                      type: "string"
                    },
                    tooltip: {
                      items: {
                        $ref: "#/definitions/Tooltip"
                      },
                      type: "array"
                    },
                    tracks: {
                      anyOf: [
                        {
                          items: {
                            $ref: "#/definitions/PartialTrack"
                          },
                          type: "array"
                        },
                        {
                          items: {
                            anyOf: [
                              {
                                $ref: "#/definitions/PartialTrack"
                              },
                              {
                                $ref: "#/definitions/OverlaidTracks"
                              }
                            ]
                          },
                          type: "array"
                        }
                      ]
                    },
                    visibility: {
                      items: {
                        $ref: "#/definitions/VisibilityCondition"
                      },
                      type: "array"
                    },
                    width: {
                      description: "Specify the track width in pixels.",
                      type: "number"
                    },
                    x: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    x1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    xAxis: {
                      $ref: "#/definitions/AxisPosition",
                      description: "not supported"
                    },
                    xDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic x-axis"
                    },
                    xOffset: {
                      description: "Specify the x offset of views in the unit of pixels",
                      type: "number"
                    },
                    xe: {
                      anyOf: [
                        {
                          $ref: "#/definitions/X"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    y1e: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    yDomain: {
                      anyOf: [
                        {
                          $ref: "#/definitions/DomainInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChrInterval"
                        },
                        {
                          $ref: "#/definitions/DomainChr"
                        }
                      ],
                      description: "Specify the visible region of genomic y-axis"
                    },
                    yOffset: {
                      description: "Specify the y offset of views in the unit of pixels",
                      type: "number"
                    },
                    ye: {
                      anyOf: [
                        {
                          $ref: "#/definitions/Y"
                        },
                        {
                          $ref: "#/definitions/ChannelValue"
                        }
                      ]
                    },
                    zoomLimits: {
                      $ref: "#/definitions/ZoomLimits"
                    }
                  },
                  type: "object"
                }
              },
              required: [
                "spec",
                "selectivity"
              ],
              type: "object"
            },
            type: "array"
          },
          spacing: {
            description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
            type: "number"
          },
          "static": {
            description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
            type: "boolean"
          },
          style: {
            $ref: "#/definitions/Style",
            description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
          },
          tracks: {
            items: {
              $ref: "#/definitions/Track"
            },
            type: "array"
          },
          xAxis: {
            $ref: "#/definitions/AxisPosition",
            description: "not supported"
          },
          xDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic x-axis"
          },
          xOffset: {
            description: "Specify the x offset of views in the unit of pixels",
            type: "number"
          },
          yDomain: {
            anyOf: [
              {
                $ref: "#/definitions/DomainInterval"
              },
              {
                $ref: "#/definitions/DomainChrInterval"
              },
              {
                $ref: "#/definitions/DomainChr"
              }
            ],
            description: "Specify the visible region of genomic y-axis"
          },
          yOffset: {
            description: "Specify the y offset of views in the unit of pixels",
            type: "number"
          },
          zoomLimits: {
            $ref: "#/definitions/ZoomLimits"
          }
        },
        required: [
          "tracks"
        ],
        type: "object"
      }
    ]
  },
  Size: {
    additionalProperties: false,
    properties: {
      domain: {
        $ref: "#/definitions/ValueExtent",
        description: "Values of the data"
      },
      field: {
        description: "Name of the data field",
        type: "string"
      },
      legend: {
        description: "not supported: Whether to display legend. __Default__: `false`",
        type: "boolean"
      },
      range: {
        $ref: "#/definitions/ValueExtent",
        description: "Ranges of visual channel values"
      },
      type: {
        description: "Specify the data type",
        "enum": [
          "quantitative",
          "nominal"
        ],
        type: "string"
      }
    },
    type: "object"
  },
  SizeVisibilityCondition: {
    additionalProperties: false,
    properties: {
      conditionPadding: {
        description: "Specify the buffer size (in pixel) of width or height when calculating the visibility.\n\n__Default__: `0`",
        type: "number"
      },
      measure: {
        description: "Specify which aspect of the `target` will be compared to the `threshold`.",
        "enum": [
          "width",
          "height"
        ],
        type: "string"
      },
      operation: {
        $ref: "#/definitions/LogicalOperation",
        description: 'A string that specifies the logical operation to conduct between `threshold` and the `measure` of `target`. Support\n\n- greater than : "greater-than", "gt", "GT"\n\n- less than : "less-than", "lt", "LT"\n\n- greater than or equal to : "greater-than-or-equal-to", "gtet", "GTET"\n\n- less than or equal to : "less-than-or-equal-to", "ltet", "LTET"'
      },
      target: {
        description: "Target specifies the object that you want to compare with the threshold.",
        "enum": [
          "track",
          "mark"
        ],
        type: "string"
      },
      threshold: {
        anyOf: [
          {
            type: "number"
          },
          {
            "const": "|xe-x|",
            type: "string"
          }
        ],
        description: 'Specify the threshold as one of:\n\n- A number representing a fixed threshold in the unit of pixels;\n\n- `"|xe-x|"`, using the distance between `xe` and `x` as threshold'
      },
      transitionPadding: {
        description: "Specify the buffer size (in pixel) of width or height for smooth transition.\n\n__Default__: `0`",
        type: "number"
      }
    },
    required: [
      "measure",
      "operation",
      "target",
      "threshold"
    ],
    type: "object"
  },
  StrConcatTransform: {
    additionalProperties: false,
    properties: {
      fields: {
        items: {
          type: "string"
        },
        type: "array"
      },
      newField: {
        type: "string"
      },
      separator: {
        type: "string"
      },
      type: {
        "const": "concat",
        type: "string"
      }
    },
    required: [
      "type",
      "fields",
      "newField",
      "separator"
    ],
    type: "object"
  },
  StrReplaceTransform: {
    additionalProperties: false,
    properties: {
      field: {
        type: "string"
      },
      newField: {
        type: "string"
      },
      replace: {
        items: {
          additionalProperties: false,
          properties: {
            from: {
              type: "string"
            },
            to: {
              type: "string"
            }
          },
          required: [
            "from",
            "to"
          ],
          type: "object"
        },
        type: "array"
      },
      type: {
        "const": "replace",
        type: "string"
      }
    },
    required: [
      "type",
      "field",
      "newField",
      "replace"
    ],
    type: "object"
  },
  Stroke: {
    additionalProperties: false,
    properties: {
      domain: {
        $ref: "#/definitions/ValueExtent",
        description: "Values of the data"
      },
      field: {
        description: "Name of the data field",
        type: "string"
      },
      legend: {
        description: "Whether to display legend. __Default__: `false`",
        type: "boolean"
      },
      range: {
        $ref: "#/definitions/Range",
        description: "Ranges of visual channel values"
      },
      scaleOffset: {
        description: "Whether to use offset of the domain proportionally. This is bound to brushes on the color legend. __Default__: `[0, 1]`",
        items: {
          type: "number"
        },
        maxItems: 2,
        minItems: 2,
        type: "array"
      },
      title: {
        description: "Title of the legend. __Default__: `undefined`",
        type: "string"
      },
      type: {
        description: "Specify the data type",
        "enum": [
          "quantitative",
          "nominal"
        ],
        type: "string"
      }
    },
    type: "object"
  },
  StrokeWidth: {
    additionalProperties: false,
    properties: {
      domain: {
        $ref: "#/definitions/ValueExtent",
        description: "Values of the data"
      },
      field: {
        description: "Name of the data field",
        type: "string"
      },
      range: {
        $ref: "#/definitions/ValueExtent",
        description: "Ranges of visual channel values"
      },
      type: {
        description: "Specify the data type",
        "enum": [
          "quantitative",
          "nominal"
        ],
        type: "string"
      }
    },
    type: "object"
  },
  Style: {
    additionalProperties: false,
    properties: {
      align: {
        description: "Specify the alignment of marks. This property is currently only supported for `triangle` marks.",
        "enum": [
          "left",
          "right"
        ],
        type: "string"
      },
      background: {
        type: "string"
      },
      backgroundOpacity: {
        type: "number"
      },
      brush: {
        additionalProperties: false,
        description: "Customize the style of the brush mark in the `rangeSelect` mouse event.",
        properties: {
          color: {
            description: "color of the marks when mouse events are triggered",
            type: "string"
          },
          opacity: {
            description: "opacity of the marks when mouse events are triggered",
            type: "number"
          },
          stroke: {
            description: "stroke color of the marks when mouse events are triggered",
            type: "string"
          },
          strokeOpacity: {
            type: "number"
          },
          strokeWidth: {
            description: "stroke width of the marks when mouse events are triggered",
            type: "number"
          }
        },
        type: "object"
      },
      curve: {
        description: "Specify the curve of `rule` marks.",
        "enum": [
          "top",
          "bottom",
          "left",
          "right"
        ],
        type: "string"
      },
      dashed: {
        description: "Specify the pattern of dashes and gaps for `rule` marks.",
        items: {
          type: "number"
        },
        maxItems: 2,
        minItems: 2,
        type: "array"
      },
      dx: {
        description: "Offset the position of marks in x direction. This property is currently only supported for `text` marks",
        type: "number"
      },
      dy: {
        description: "Offset the position of marks in y direction. This property is currently only supported for `text` marks.",
        type: "number"
      },
      enableSmoothPath: {
        description: "Whether to enable smooth paths when drawing curves.\n\n__Default__: `false`",
        type: "boolean"
      },
      inlineLegend: {
        description: "Specify whether to show legend in a single horizontal line?",
        type: "boolean"
      },
      legendTitle: {
        description: "If defined, show legend title on the top or left",
        type: "string"
      },
      linePattern: {
        additionalProperties: false,
        description: "Specify the pattern of dashes and gaps for `rule` marks.",
        properties: {
          size: {
            type: "number"
          },
          type: {
            "enum": [
              "triangleLeft",
              "triangleRight"
            ],
            type: "string"
          }
        },
        required: [
          "type",
          "size"
        ],
        type: "object"
      },
      linkConnectionType: {
        description: 'Specify the connetion type of `betweenLink` marks.\n\n__Default__: `"corner"`',
        "enum": [
          "straight",
          "curve",
          "corner"
        ],
        type: "string"
      },
      linkMinHeight: {
        description: "The minimum height of `withinLink` and `betweenLink` marks. Unit is a percentagle. __Default__: `0.5`",
        type: "number"
      },
      linkStyle: {
        description: "The style of `withinLink` and `betweenLink` marks. __Default__: `'circular'` `'elliptical'` will be used as a default option.",
        "enum": [
          "elliptical",
          "circular",
          "straight"
        ],
        type: "string"
      },
      matrixExtent: {
        description: 'Determine to show only one side of the diagonal in a HiGlass matrix. __Default__: `"full"`',
        "enum": [
          "full",
          "upper-right",
          "lower-left"
        ],
        type: "string"
      },
      mouseOver: {
        $ref: "#/definitions/EventStyle",
        description: "Customize visual effects of `mouseOver` events on marks."
      },
      outline: {
        type: "string"
      },
      outlineWidth: {
        type: "number"
      },
      select: {
        $ref: "#/definitions/EventStyle",
        description: "Customize visual effects of `rangeSelect` events on marks ."
      },
      textAnchor: {
        description: "Specify the alignment of `text` marks to a given point.",
        "enum": [
          "start",
          "middle",
          "end"
        ],
        type: "string"
      },
      textFontSize: {
        description: "Specify the font size of `text` marks. Can also be specified using the `size` channel option of `text` marks.",
        type: "number"
      },
      textFontWeight: {
        description: "Specify the font weight of `text` marks.",
        "enum": [
          "bold",
          "normal"
        ],
        type: "string"
      },
      textStroke: {
        description: "Specify the stroke of `text` marks. Can also be specified using the `stroke` channel option of `text` marks.",
        type: "string"
      },
      textStrokeWidth: {
        description: "Specify the stroke width of `text` marks. Can also be specified using the `strokeWidth` channel option of `text` marks.",
        type: "number"
      }
    },
    type: "object"
  },
  SvTypeTransform: {
    additionalProperties: false,
    properties: {
      firstBp: {
        additionalProperties: false,
        description: "Based on the BEDPE, infer SV types. SV types are specified as one of the following strings: DUP, TRA, DEL, t2tINV, h2hINV.",
        properties: {
          chrField: {
            type: "string"
          },
          posField: {
            type: "string"
          },
          strandField: {
            type: "string"
          }
        },
        required: [
          "chrField",
          "posField",
          "strandField"
        ],
        type: "object"
      },
      newField: {
        type: "string"
      },
      secondBp: {
        additionalProperties: false,
        description: "Based on the BEDPE, infer SV types. SV types are specified as one of the following strings: DUP, TRA, DEL, t2tINV, h2hINV.",
        properties: {
          chrField: {
            type: "string"
          },
          posField: {
            type: "string"
          },
          strandField: {
            type: "string"
          }
        },
        required: [
          "chrField",
          "posField",
          "strandField"
        ],
        type: "object"
      },
      type: {
        "const": "svType",
        type: "string"
      }
    },
    required: [
      "type",
      "firstBp",
      "secondBp",
      "newField"
    ],
    type: "object"
  },
  TemplateTrack: {
    additionalProperties: false,
    description: "Template specification that will be internally converted into `SingleTrack` for rendering.",
    properties: {
      _assignedHeight: {
        type: "number"
      },
      _assignedWidth: {
        description: "Internal: Used for responsive spec",
        type: "number"
      },
      _invalidTrack: {
        description: "internal",
        type: "boolean"
      },
      _renderingId: {
        description: "internal",
        type: "string"
      },
      assembly: {
        $ref: "#/definitions/Assembly",
        description: 'A string that specifies the genome builds to use. Currently support `"hg38"`, `"hg19"`, `"hg18"`, `"hg17"`, `"hg16"`, `"mm10"`, `"mm9"`, and `"unknown"`.\n\n__Note:__: with `"unknown"` assembly, genomic axes do not show chrN: in labels.'
      },
      centerRadius: {
        description: "Proportion of the radius of the center white space.\n\n__Default:__ `0.3`",
        type: "number"
      },
      data: {
        $ref: "#/definitions/DataDeep"
      },
      encoding: {
        additionalProperties: {
          $ref: "#/definitions/Channel"
        },
        type: "object"
      },
      endAngle: {
        description: 'Specify the end angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      height: {
        description: "Specify the track height in pixels.",
        type: "number"
      },
      id: {
        type: "string"
      },
      innerRadius: {
        description: 'Specify the inner radius of tracks when (`{"layout": "circular"}`).',
        type: "number"
      },
      layout: {
        $ref: "#/definitions/Layout",
        description: "Specify the layout type of all tracks."
      },
      linkingId: {
        description: "Specify an ID for [linking multiple views](http://gosling-lang.org/docs/user-interaction#linking-views)",
        type: "string"
      },
      orientation: {
        $ref: "#/definitions/Orientation",
        description: "Specify the orientation."
      },
      outerRadius: {
        description: 'Specify the outer radius of tracks when `{"layout": "circular"}`.',
        type: "number"
      },
      overlayOnPreviousTrack: {
        type: "boolean"
      },
      prerelease: {
        additionalProperties: false,
        description: "internal",
        type: "object"
      },
      spacing: {
        description: "The size of the gap (1) between tracks, (2) between views, and (3) of the origin of circular tracks. The effect of this property depends on where on the spec you specify the `spacing`.\n\nIn a linear layout, this value is used in pixels, while in a circular layout, this value is used relative to the height of the tracks or views.",
        type: "number"
      },
      startAngle: {
        description: 'Specify the start angle (in the range of [0, 360]) of circular tracks (`{"layout": "circular"}`).',
        type: "number"
      },
      "static": {
        description: "Whether to disable [Zooming and Panning](http://gosling-lang.org/docs/user-interaction#zooming-and-panning), __Default:__ `false`.",
        type: "boolean"
      },
      style: {
        $ref: "#/definitions/Style",
        description: "Define the [style](http://gosling-lang.org/docs/visual-channel#style-related-properties) of multive views. Will be overwritten by the style of children elements (e.g., view, track)."
      },
      subtitle: {
        type: "string"
      },
      template: {
        type: "string"
      },
      title: {
        description: "If defined, will show the textual label on the left-top corner of a track.",
        type: "string"
      },
      width: {
        description: "Specify the track width in pixels.",
        type: "number"
      },
      xAxis: {
        $ref: "#/definitions/AxisPosition",
        description: "not supported"
      },
      xDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic x-axis"
      },
      xOffset: {
        description: "Specify the x offset of views in the unit of pixels",
        type: "number"
      },
      yDomain: {
        anyOf: [
          {
            $ref: "#/definitions/DomainInterval"
          },
          {
            $ref: "#/definitions/DomainChrInterval"
          },
          {
            $ref: "#/definitions/DomainChr"
          }
        ],
        description: "Specify the visible region of genomic y-axis"
      },
      yOffset: {
        description: "Specify the y offset of views in the unit of pixels",
        type: "number"
      },
      zoomLimits: {
        $ref: "#/definitions/ZoomLimits"
      }
    },
    required: [
      "template",
      "data"
    ],
    type: "object"
  },
  Text: {
    additionalProperties: false,
    properties: {
      domain: {
        description: "Values of the data",
        items: {
          type: "string"
        },
        type: "array"
      },
      field: {
        description: "Name of the data field",
        type: "string"
      },
      range: {
        description: "Ranges of visual channel values",
        items: {
          type: "string"
        },
        type: "array"
      },
      type: {
        description: "Specify the data type",
        "enum": [
          "quantitative",
          "nominal"
        ],
        type: "string"
      }
    },
    type: "object"
  },
  Tooltip: {
    additionalProperties: false,
    properties: {
      alt: {
        description: "Name of the data field for showing in the tooltip. Will use the field name if not specified.",
        type: "string"
      },
      field: {
        description: "Specifiy a data field whose value will show in the tooltip.",
        type: "string"
      },
      format: {
        description: "format of the data value.",
        type: "string"
      },
      type: {
        $ref: "#/definitions/FieldType",
        description: "Type of the data field."
      }
    },
    required: [
      "field",
      "type"
    ],
    type: "object"
  },
  Track: {
    anyOf: [
      {
        $ref: "#/definitions/SingleTrack"
      },
      {
        $ref: "#/definitions/OverlaidTrack"
      },
      {
        $ref: "#/definitions/DataTrack"
      },
      {
        $ref: "#/definitions/TemplateTrack"
      }
    ]
  },
  ValueExtent: {
    anyOf: [
      {
        items: {
          type: "string"
        },
        type: "array"
      },
      {
        items: {
          type: "number"
        },
        type: "array"
      }
    ]
  },
  VcfData: {
    additionalProperties: false,
    description: "The Variant Call Format (VCF).",
    properties: {
      indexUrl: {
        description: "URL link to the tabix index file",
        type: "string"
      },
      sampleLength: {
        description: "The maximum number of rows to be loaded from the URL. __Default:__ `1000`",
        type: "number"
      },
      type: {
        "const": "vcf",
        type: "string"
      },
      url: {
        description: "URL link to the VCF file",
        type: "string"
      }
    },
    required: [
      "type",
      "url",
      "indexUrl"
    ],
    type: "object"
  },
  VectorData: {
    additionalProperties: false,
    description: 'One-dimensional quantitative values along genomic position (e.g., bigwig) can be converted into HiGlass\' `"vector"` format data. Find out more about this format at [HiGlass Docs](https://docs.higlass.io/data_preparation.html#bigwig-files).',
    properties: {
      aggregation: {
        $ref: "#/definitions/BinAggregate",
        description: 'Determine aggregation function to apply within bins. __Default__: `"mean"`'
      },
      binSize: {
        description: "Binning the genomic interval in tiles (unit size: 256).",
        type: "number"
      },
      column: {
        description: 'Assign a field name of the middle position of genomic intervals. __Default__: `"position"`',
        type: "string"
      },
      end: {
        description: 'Assign a field name of the end position of genomic intervals. __Default__: `"end"`',
        type: "string"
      },
      start: {
        description: 'Assign a field name of the start position of genomic intervals. __Default__: `"start"`',
        type: "string"
      },
      type: {
        "const": "vector",
        type: "string"
      },
      url: {
        description: "Specify the URL address of the data file.",
        type: "string"
      },
      value: {
        description: 'Assign a field name of quantitative values. __Default__: `"value"`',
        type: "string"
      }
    },
    required: [
      "type",
      "url"
    ],
    type: "object"
  },
  VisibilityCondition: {
    anyOf: [
      {
        $ref: "#/definitions/SizeVisibilityCondition"
      },
      {
        $ref: "#/definitions/ZoomLevelVisibilityCondition"
      }
    ]
  },
  X: {
    additionalProperties: false,
    properties: {
      aggregate: {
        $ref: "#/definitions/Aggregate",
        description: "Specify how to aggregate data. __Default__: `undefined`"
      },
      axis: {
        $ref: "#/definitions/AxisPosition",
        description: "Specify where should the axis be put"
      },
      domain: {
        $ref: "#/definitions/GenomicDomain",
        description: "Values of the data"
      },
      field: {
        description: "Name of the data field.",
        type: "string"
      },
      grid: {
        description: "Whether to display grid. __Default__: `false`",
        type: "boolean"
      },
      legend: {
        description: "Whether to display legend. __Default__: `false`",
        type: "boolean"
      },
      linkingId: {
        description: "Users need to assign a unique linkingId for [linking views](/docs/user-interaction#linking-views) and [Brushing and Linking](/docs/user-interaction#brushing-and-linking)",
        type: "string"
      },
      range: {
        $ref: "#/definitions/ValueExtent",
        description: "Values of the visual channel."
      },
      type: {
        "const": "genomic",
        description: "Specify the data type.",
        type: "string"
      }
    },
    type: "object"
  },
  Y: {
    additionalProperties: false,
    properties: {
      aggregate: {
        $ref: "#/definitions/Aggregate",
        description: "Specify how to aggregate data. __Default__: `undefined`"
      },
      axis: {
        $ref: "#/definitions/AxisPosition",
        description: "Specify where should the axis be put"
      },
      baseline: {
        description: "Custom baseline of the y-axis. __Default__: `0`",
        type: [
          "string",
          "number"
        ]
      },
      domain: {
        anyOf: [
          {
            $ref: "#/definitions/ValueExtent"
          },
          {
            $ref: "#/definitions/GenomicDomain"
          }
        ],
        description: "Values of the data"
      },
      field: {
        description: "Name of the data field.",
        type: "string"
      },
      flip: {
        description: "Whether to flip the y-axis. This is done by inverting the `range` property. __Default__: `false`",
        type: "boolean"
      },
      grid: {
        description: "Whether to display grid. __Default__: `false`",
        type: "boolean"
      },
      legend: {
        description: "Whether to display legend. __Default__: `false`",
        type: "boolean"
      },
      linkingId: {
        description: "Users need to assign a unique linkingId for [linking views](/docs/user-interaction#linking-views) and [Brushing and Linking](/docs/user-interaction#brushing-and-linking)",
        type: "string"
      },
      range: {
        $ref: "#/definitions/ValueExtent",
        description: "Values of the visual channel."
      },
      type: {
        description: "Specify the data type.",
        "enum": [
          "quantitative",
          "nominal",
          "genomic"
        ],
        type: "string"
      },
      zeroBaseline: {
        description: "Specify whether to use zero baseline. __Default__: `true`",
        type: "boolean"
      }
    },
    type: "object"
  },
  ZoomLevelVisibilityCondition: {
    additionalProperties: false,
    properties: {
      conditionPadding: {
        description: "Specify the buffer size (in pixel) of width or height when calculating the visibility.\n\n__Default__: `0`",
        type: "number"
      },
      measure: {
        "const": "zoomLevel",
        description: "Specify which aspect of the `target` will be compared to the `threshold`.",
        type: "string"
      },
      operation: {
        $ref: "#/definitions/LogicalOperation",
        description: 'A string that specifies the logical operation to conduct between `threshold` and the `measure` of `target`. Support\n\n- greater than : "greater-than", "gt", "GT"\n\n- less than : "less-than", "lt", "LT"\n\n- greater than or equal to : "greater-than-or-equal-to", "gtet", "GTET"\n\n- less than or equal to : "less-than-or-equal-to", "ltet", "LTET"'
      },
      target: {
        description: "Target specifies the object that you want to compare with the threshold.",
        "enum": [
          "track",
          "mark"
        ],
        type: "string"
      },
      threshold: {
        description: "Set a threshold in the unit of base pairs (bp)",
        type: "number"
      },
      transitionPadding: {
        description: "Specify the buffer size (in pixel) of width or height for smooth transition.\n\n__Default__: `0`",
        type: "number"
      }
    },
    required: [
      "measure",
      "operation",
      "target",
      "threshold"
    ],
    type: "object"
  },
  ZoomLimits: {
    items: {
      type: [
        "number",
        "null"
      ]
    },
    maxItems: 2,
    minItems: 2,
    type: "array"
  }
};
var GoslingSchema = {
  $ref: $ref$2,
  $schema: $schema$4,
  definitions: definitions$3
};
const $ref$1 = "#/definitions/Theme";
const $schema$3 = "http://json-schema.org/draft-07/schema#";
const definitions$2 = {
  AxisStyle: {
    additionalProperties: false,
    properties: {
      baselineColor: {
        type: "string"
      },
      gridColor: {
        type: "string"
      },
      gridStrokeDash: {
        items: {
          type: "number"
        },
        maxItems: 2,
        minItems: 2,
        type: "array"
      },
      gridStrokeType: {
        "enum": [
          "solid",
          "dashed"
        ],
        type: "string"
      },
      gridStrokeWidth: {
        type: "number"
      },
      labelColor: {
        type: "string"
      },
      labelFontFamily: {
        type: "string"
      },
      labelFontSize: {
        type: "number"
      },
      labelFontWeight: {
        "enum": [
          "bold",
          "normal",
          "light"
        ],
        type: "string"
      },
      tickColor: {
        type: "string"
      }
    },
    type: "object"
  },
  LegendStyle: {
    additionalProperties: false,
    properties: {
      background: {
        type: "string"
      },
      backgroundOpacity: {
        type: "number"
      },
      backgroundStroke: {
        type: "string"
      },
      labelColor: {
        type: "string"
      },
      labelFontFamily: {
        type: "string"
      },
      labelFontSize: {
        type: "number"
      },
      labelFontWeight: {
        "enum": [
          "bold",
          "normal",
          "light"
        ],
        type: "string"
      },
      position: {
        "enum": [
          "top",
          "right"
        ],
        type: "string"
      },
      tickColor: {
        type: "string"
      }
    },
    type: "object"
  },
  MarkStyle: {
    additionalProperties: false,
    properties: {
      color: {
        type: "string"
      },
      nominalColorRange: {
        items: {
          type: "string"
        },
        type: "array"
      },
      opacity: {
        type: "number"
      },
      quantitativeSizeRange: {
        items: {
          type: "number"
        },
        maxItems: 2,
        minItems: 2,
        type: "array"
      },
      size: {
        type: "number"
      },
      stroke: {
        type: "string"
      },
      strokeWidth: {
        type: "number"
      }
    },
    type: "object"
  },
  RootStyle: {
    additionalProperties: false,
    properties: {
      background: {
        type: "string"
      },
      mousePositionColor: {
        type: "string"
      },
      showMousePosition: {
        type: "boolean"
      },
      subtitleAlign: {
        "enum": [
          "left",
          "middle",
          "right"
        ],
        type: "string"
      },
      subtitleBackgroundColor: {
        type: "string"
      },
      subtitleColor: {
        type: "string"
      },
      subtitleFontFamily: {
        type: "string"
      },
      subtitleFontSize: {
        type: "number"
      },
      subtitleFontWeight: {
        "enum": [
          "bold",
          "normal",
          "light"
        ],
        type: "string"
      },
      titleAlign: {
        "enum": [
          "left",
          "middle",
          "right"
        ],
        type: "string"
      },
      titleBackgroundColor: {
        type: "string"
      },
      titleColor: {
        type: "string"
      },
      titleFontFamily: {
        type: "string"
      },
      titleFontSize: {
        type: "number"
      },
      titleFontWeight: {
        "enum": [
          "bold",
          "normal",
          "light"
        ],
        type: "string"
      }
    },
    type: "object"
  },
  Theme: {
    anyOf: [
      {
        $ref: "#/definitions/ThemeType"
      },
      {
        $ref: "#/definitions/ThemeDeep"
      }
    ]
  },
  ThemeDeep: {
    additionalProperties: false,
    properties: {
      area: {
        $ref: "#/definitions/MarkStyle"
      },
      axis: {
        $ref: "#/definitions/AxisStyle"
      },
      bar: {
        $ref: "#/definitions/MarkStyle"
      },
      base: {
        $ref: "#/definitions/ThemeType"
      },
      brush: {
        $ref: "#/definitions/MarkStyle"
      },
      legend: {
        $ref: "#/definitions/LegendStyle"
      },
      line: {
        $ref: "#/definitions/MarkStyle"
      },
      link: {
        $ref: "#/definitions/MarkStyle"
      },
      markCommon: {
        $ref: "#/definitions/MarkStyle"
      },
      point: {
        $ref: "#/definitions/MarkStyle"
      },
      rect: {
        $ref: "#/definitions/MarkStyle"
      },
      root: {
        $ref: "#/definitions/RootStyle"
      },
      rule: {
        $ref: "#/definitions/MarkStyle"
      },
      text: {
        additionalProperties: false,
        properties: {
          color: {
            type: "string"
          },
          nominalColorRange: {
            items: {
              type: "string"
            },
            type: "array"
          },
          opacity: {
            type: "number"
          },
          quantitativeSizeRange: {
            items: {
              type: "number"
            },
            maxItems: 2,
            minItems: 2,
            type: "array"
          },
          size: {
            type: "number"
          },
          stroke: {
            type: "string"
          },
          strokeWidth: {
            type: "number"
          },
          textAnchor: {
            "enum": [
              "start",
              "middle",
              "end"
            ],
            type: "string"
          },
          textFontWeight: {
            "enum": [
              "bold",
              "normal"
            ],
            type: "string"
          }
        },
        type: "object"
      },
      track: {
        $ref: "#/definitions/TrackStyle"
      },
      triangle: {
        $ref: "#/definitions/MarkStyle"
      }
    },
    required: [
      "base"
    ],
    type: "object"
  },
  ThemeType: {
    "enum": [
      "light",
      "dark",
      "warm",
      "ggplot",
      "igv",
      "ensembl",
      "jbrowse",
      "ucsc",
      "washu",
      "excel",
      "google"
    ],
    type: "string"
  },
  TrackStyle: {
    additionalProperties: false,
    properties: {
      alternatingBackground: {
        type: "string"
      },
      background: {
        type: "string"
      },
      outline: {
        type: "string"
      },
      outlineWidth: {
        type: "number"
      },
      titleAlign: {
        "enum": [
          "left",
          "middle",
          "right"
        ],
        type: "string"
      },
      titleBackground: {
        type: "string"
      },
      titleColor: {
        type: "string"
      },
      titleFontSize: {
        type: "number"
      }
    },
    type: "object"
  }
};
var theme_schema = {
  $ref: $ref$1,
  $schema: $schema$3,
  definitions: definitions$2
};
const name = "gosling.js";
const version = "0.9.25";
const DEWFAULT_TITLE_PADDING_ON_TOP_AND_BOTTOM = 6;
const DEFAULT_TRACK_HEIGHT_LINEAR = 130;
const DEFAULT_TRACK_WIDTH_LINEAR = 600;
const DEFAULT_TRACK_SIZE_2D = 600;
const DEFAULT_VIEW_SPACING = 10;
const DEFAULT_INNER_RADIUS_PROP = 0.3;
const DEFAULT_CIRCULAR_VIEW_PADDING = 0;
const DEFAULT_BACKUP_COLOR = "gray";
const colorToHex = (colorStr) => {
  let c = color(colorStr);
  if (!c) {
    c = color(DEFAULT_BACKUP_COLOR);
  }
  const hex = PIXI.utils.rgb2hex([c.rgb().r / 255, c.rgb().g / 255, c.rgb().b / 255]);
  return hex;
};
const RADIAN_GAP = 0;
function valueToRadian(v, max2, sa, ea, g) {
  const safeVal = Math.max(Math.min(max2, v), 0);
  const gap = g != null ? g : RADIAN_GAP;
  const radExtent = (ea - sa) / 360 * Math.PI * 2 - gap * 2;
  const radStart = sa / 360 * Math.PI * 2;
  return -(radStart + safeVal / max2 * radExtent) - Math.PI / 2 - gap;
}
function cartesianToPolar(x, max2, r, cx, cy, sa, ea) {
  return {
    x: cx + r * Math.cos(valueToRadian(x, max2, sa, ea)),
    y: cy + r * Math.sin(valueToRadian(x, max2, sa, ea))
  };
}
function positionToRadian(x, y, cx, cy) {
  if (cx <= x) {
    return Math.atan((y - cy) / (x - cx));
  } else {
    return Math.atan((y - cy) / (x - cx)) - Math.PI;
  }
}
function pointsToDegree(x, y, cx, cy) {
  return (Math.atan2(-(y - cy), x - cx) / Math.PI * 180 + 270) % 360;
}
function drawPoint(trackInfo, g, model) {
  var _a, _b, _c, _d, _e;
  const spec = model.spec();
  if (!spec.width || !spec.height) {
    console.warn("Size of a track is not properly determined, so visual mark cannot be rendered");
    return;
  }
  const data2 = model.data();
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const zoomLevel = model.getChannelScale("x").invert(trackWidth) - model.getChannelScale("x").invert(0);
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const tcx = trackWidth / 2;
  const tcy = trackHeight / 2;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  rowCategories.forEach((rowCategory) => {
    const rowPosition = model.encodedValue("row", rowCategory);
    data2.filter((d) => !getValueUsingChannel(d, spec.row) || getValueUsingChannel(d, spec.row) === rowCategory).forEach((d) => {
      const cx = model.encodedPIXIProperty("x-center", d);
      const cy = model.encodedPIXIProperty("y-center", d);
      const color2 = model.encodedPIXIProperty("color", d);
      const radius = model.encodedPIXIProperty("p-size", d);
      const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
      const stroke = model.encodedPIXIProperty("stroke", d);
      const opacity = model.encodedPIXIProperty("opacity", d);
      const alphaTransition = model.markVisibility(d, { width: radius, zoomLevel });
      const actualOpacity = Math.min(alphaTransition, opacity);
      if (radius <= 0.1 || actualOpacity === 0 || cx + radius < 0 || cx - radius > trackWidth) {
        return;
      }
      g.lineStyle(strokeWidth, colorToHex(stroke), actualOpacity, 1);
      if (circular) {
        const r = trackOuterRadius - (rowPosition + rowHeight - cy) / trackHeight * trackRingSize;
        const pos = cartesianToPolar(cx, trackWidth, r, tcx, tcy, startAngle, endAngle);
        g.beginFill(colorToHex(color2), actualOpacity);
        g.drawCircle(pos.x, pos.y, radius);
        model.getMouseEventModel().addPointBasedEvent(d, [pos.x, pos.y, radius]);
      } else {
        g.beginFill(colorToHex(color2), actualOpacity);
        g.drawCircle(cx, rowPosition + rowHeight - cy, radius);
        model.getMouseEventModel().addPointBasedEvent(d, [cx, rowPosition + rowHeight - cy, radius]);
      }
    });
  });
}
function pointProperty(model, propertyKey, datum) {
  const xe = model.visualPropertyByChannel("xe", datum);
  const x = model.visualPropertyByChannel("x", datum);
  const size = model.visualPropertyByChannel("size", datum);
  switch (propertyKey) {
    case "x-center":
      return xe ? (xe + x) / 2 : x;
    case "y-center": {
      const ye = model.visualPropertyByChannel("ye", datum);
      const y = model.visualPropertyByChannel("y", datum);
      return ye ? (ye + y) / 2 : y;
    }
    case "p-size":
      return xe && model.spec().stretch ? (xe - x) / 2 : size;
    default:
      return void 0;
  }
}
function drawLine(g, model, trackWidth, trackHeight) {
  var _a, _b, _c, _d, _e, _f;
  const spec = model.spec();
  if (!spec.width || !spec.height) {
    console.warn("Size of a track is not properly determined, so visual mark cannot be rendered");
    return;
  }
  const data2 = model.data();
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const trackCenterX = trackWidth / 2;
  const trackCenterY = trackHeight / 2;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  const colorCategories = (_f = model.getChannelDomainArray("color")) != null ? _f : ["___SINGLE_COLOR___"];
  rowCategories.forEach((rowCategory) => {
    const rowPosition = model.encodedValue("row", rowCategory);
    colorCategories.forEach((colorCategory) => {
      data2.filter((d) => (!getValueUsingChannel(d, spec.row) || getValueUsingChannel(d, spec.row) === rowCategory) && (!getValueUsingChannel(d, spec.color) || getValueUsingChannel(d, spec.color) === colorCategory)).sort((d1, d2) => getValueUsingChannel(d1, spec.x) - getValueUsingChannel(d2, spec.x)).forEach((d, i) => {
        const cx = model.encodedPIXIProperty("x", d);
        const y = model.encodedPIXIProperty("y", d);
        const size = model.encodedPIXIProperty("size", d);
        const color2 = model.encodedPIXIProperty("color", d);
        const opacity = model.encodedPIXIProperty("opacity", d);
        g.lineStyle(size, colorToHex(color2), opacity, 0.5);
        if (circular) {
          const r = trackOuterRadius - (rowPosition + rowHeight - y) / trackHeight * trackRingSize;
          const pos = cartesianToPolar(cx, trackWidth, r, trackCenterX, trackCenterY, startAngle, endAngle);
          if (i === 0) {
            g.moveTo(pos.x, pos.y);
          } else {
            g.lineTo(pos.x, pos.y);
          }
          model.getMouseEventModel().addPointBasedEvent(d, [pos.x, pos.y, 1]);
        } else {
          if (i === 0) {
            g.moveTo(cx, rowPosition + rowHeight - y);
          } else {
            g.lineTo(cx, rowPosition + rowHeight - y);
          }
          model.getMouseEventModel().addPointBasedEvent(d, [cx, rowPosition + rowHeight - y, 1]);
        }
      });
    });
  });
}
function drawBar(trackInfo, tile, model) {
  var _a, _b, _c, _d, _e, _f, _g;
  const spec = model.spec();
  if (!spec.width || !spec.height) {
    console.warn("Size of a track is not properly determined, so visual mark cannot be rendered");
    return;
  }
  const data2 = model.data();
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const tileSize = trackInfo.tilesetInfo.tile_size;
  const { tileX, tileWidth } = trackInfo.getTilePosAndDimensions(tile.tileData.zoomLevel, tile.tileData.tilePos, tileSize);
  const zoomLevel = model.getChannelScale("x").invert(trackWidth) - model.getChannelScale("x").invert(0);
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const cx = trackWidth / 2;
  const cy = trackHeight / 2;
  const xScale = model.getChannelScale("x");
  const tileUnitWidth = xScale(tileX + tileWidth / tileSize) - xScale(tileX);
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  const clipRow = !IsChannelDeep(spec.row) || IsChannelDeep(spec.row) && typeof spec.row.clip === "undefined" || spec.row.clip;
  const baselineValue = IsChannelDeep(spec.y) ? (_f = spec.y) == null ? void 0 : _f.baseline : void 0;
  const staticBaseY = (_g = model.encodedValue("y", baselineValue)) != null ? _g : 0;
  const g = tile.graphics;
  if (IsStackedMark(spec)) {
    const genomicChannel = model.getGenomicChannel();
    if (!genomicChannel || !genomicChannel.field) {
      console.warn("Genomic field is not provided in the specification");
      return;
    }
    const pivotedData = group(data2, (d) => d[genomicChannel.field]);
    const xKeys = [...pivotedData.keys()];
    xKeys.forEach((k) => {
      var _a2;
      let prevYEnd = 0;
      (_a2 = pivotedData.get(k)) == null ? void 0 : _a2.forEach((d) => {
        const color2 = model.encodedPIXIProperty("color", d);
        const stroke = model.encodedPIXIProperty("stroke", d);
        const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
        const opacity = model.encodedPIXIProperty("opacity", d);
        const y = model.encodedPIXIProperty("y", d);
        const barWidth = model.encodedPIXIProperty("width", d, { tileUnitWidth });
        const xs = model.encodedPIXIProperty("x-start", d, { markWidth: barWidth });
        const xe = xs + barWidth;
        const alphaTransition = model.markVisibility(d, { width: barWidth, zoomLevel });
        const actualOpacity = Math.min(alphaTransition, opacity);
        if (actualOpacity === 0 || barWidth <= 0 || y <= 0) {
          return;
        }
        g.lineStyle(strokeWidth, colorToHex(stroke), actualOpacity, 0);
        let polygonForMouseEvents = [];
        if (circular) {
          const farR = trackOuterRadius - (rowHeight - prevYEnd) / trackHeight * trackRingSize;
          const nearR = trackOuterRadius - (rowHeight - y - prevYEnd) / trackHeight * trackRingSize;
          const sPos = cartesianToPolar(xs, trackWidth, nearR, cx, cy, startAngle, endAngle);
          const startRad = valueToRadian(xs, trackWidth, startAngle, endAngle);
          const endRad = valueToRadian(xs + barWidth, trackWidth, startAngle, endAngle);
          g.beginFill(colorToHex(color2), color2 === "none" ? 0 : actualOpacity);
          g.moveTo(sPos.x, sPos.y);
          g.arc(cx, cy, nearR, startRad, endRad, true);
          g.arc(cx, cy, farR, endRad, startRad, false);
          polygonForMouseEvents = Array.from(g.currentPath.points);
          g.closePath();
        } else {
          g.beginFill(colorToHex(color2), color2 === "none" ? 0 : actualOpacity);
          g.drawRect(xs, rowHeight - y - prevYEnd, barWidth, y);
          const ys = rowHeight - y - prevYEnd;
          const ye = ys + y;
          polygonForMouseEvents = [xs, ys, xs, ye, xe, ye, xe, ys];
        }
        model.getMouseEventModel().addPolygonBasedEvent(d, polygonForMouseEvents);
        prevYEnd += y;
      });
    });
  } else {
    rowCategories.forEach((rowCategory) => {
      const rowPosition = model.encodedValue("row", rowCategory);
      data2.filter((d) => {
        const rowValue = getValueUsingChannel(d, spec.row);
        return !rowValue || rowValue === rowCategory;
      }).forEach((d) => {
        const color2 = model.encodedPIXIProperty("color", d);
        const stroke = model.encodedPIXIProperty("stroke", d);
        const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
        const opacity = model.encodedPIXIProperty("opacity");
        let y = model.encodedPIXIProperty("y", d);
        let ye = model.encodedPIXIProperty("ye", d);
        if (typeof ye !== "undefined" && y > ye) {
          [y, ye] = [ye, y];
        }
        const barWidth = model.encodedPIXIProperty("width", d, { tileUnitWidth });
        const xs = model.encodedPIXIProperty("x-start", d, { markWidth: barWidth });
        const xe = xs + barWidth;
        let ys;
        if (typeof ye === "undefined") {
          ys = rowPosition + rowHeight - staticBaseY - y;
          ye = rowPosition + rowHeight - staticBaseY;
          if (IsChannelDeep(spec.y) && spec.y.flip || spec.flipY) {
            ye = ys;
            ys = rowPosition;
          }
        } else {
          ys = rowPosition + rowHeight - ye;
          ye = rowPosition + rowHeight - y;
        }
        if (clipRow) {
          ys = Math.max(rowPosition, ys);
          ys = Math.min(ys, rowPosition + rowHeight);
          ye = Math.max(rowPosition, ye);
          ye = Math.min(ye, rowPosition + rowHeight);
        }
        const alphaTransition = model.markVisibility(d, { width: barWidth, zoomLevel });
        const actualOpacity = Math.min(alphaTransition, opacity);
        if (actualOpacity === 0 || barWidth === 0 || ye - ys === 0) {
          return;
        }
        g.lineStyle(strokeWidth, colorToHex(stroke), actualOpacity, 0);
        let polygonForMouseEvents = [];
        if (circular) {
          const farR = trackOuterRadius - ys / trackHeight * trackRingSize;
          const nearR = trackOuterRadius - ye / trackHeight * trackRingSize;
          const sPos = cartesianToPolar(xs, trackWidth, nearR, cx, cy, startAngle, endAngle);
          const startRad = valueToRadian(xs, trackWidth, startAngle, endAngle);
          const endRad = valueToRadian(xs + barWidth, trackWidth, startAngle, endAngle);
          g.beginFill(colorToHex(color2), color2 === "none" ? 0 : actualOpacity);
          g.moveTo(sPos.x, sPos.y);
          g.arc(cx, cy, nearR, startRad, endRad, true);
          g.arc(cx, cy, farR, endRad, startRad, false);
          polygonForMouseEvents = Array.from(g.currentPath.points);
          g.closePath();
        } else {
          g.beginFill(colorToHex(color2), color2 === "none" ? 0 : actualOpacity);
          g.drawRect(xs, ys, barWidth, ye - ys);
          polygonForMouseEvents = [xs, ys, xs, ye, xe, ye, xe, ys];
        }
        model.getMouseEventModel().addPolygonBasedEvent(d, polygonForMouseEvents);
      });
    });
  }
}
function barProperty(gm, propertyKey, datum, additionalInfo) {
  const x = gm.visualPropertyByChannel("x", datum);
  const xe = gm.visualPropertyByChannel("xe", datum);
  const size = gm.visualPropertyByChannel("size", datum);
  switch (propertyKey) {
    case "width":
      return size != null ? size : xe ? xe - x : additionalInfo == null ? void 0 : additionalInfo.tileUnitWidth;
    case "x-start":
      if (!(additionalInfo == null ? void 0 : additionalInfo.markWidth)) {
        return void 0;
      }
      return xe ? (x + xe - (additionalInfo == null ? void 0 : additionalInfo.markWidth)) / 2 : x - (additionalInfo == null ? void 0 : additionalInfo.markWidth) / 2;
    default:
      return void 0;
  }
}
function drawArea(HGC, trackInfo, tile, model) {
  var _a, _b, _c, _d, _e, _f;
  const spec = model.spec();
  const data2 = model.data();
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const tileSize = trackInfo.tilesetInfo.tile_size;
  const { tileX } = trackInfo.getTilePosAndDimensions(tile.tileData.zoomLevel, tile.tileData.tilePos, tileSize);
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const trackCenterX = trackWidth / 2;
  const trackCenterY = trackHeight / 2;
  const xScale = trackInfo._xScale;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  const colorCategories = (_f = model.getChannelDomainArray("color")) != null ? _f : ["___SINGLE_COLOR___"];
  const constantOpacity = model.encodedPIXIProperty("opacity");
  const constantStrokeWidth = model.encodedPIXIProperty("strokeWidth");
  const constantStroke = model.encodedPIXIProperty("stroke");
  const graphics = tile.graphics;
  if (IsStackedMark(spec)) {
    const genomicChannel = model.getGenomicChannel();
    if (!genomicChannel || !genomicChannel.field) {
      console.warn("Genomic field is not provided in the specification");
      return;
    }
    const pivotedData = group(data2, (d) => d[genomicChannel.field]);
    const genomicPosCategories = [...pivotedData.keys()];
    graphics.lineStyle(constantStrokeWidth, colorToHex(constantStroke), constantOpacity, 1);
    const prevYEndByGPos = {};
    colorCategories.forEach((colorCategory) => {
      const areaPointsTop = [];
      const areaPointsBottom = [];
      genomicPosCategories.forEach((genomicPosCategory, i, array) => {
        var _a2, _b2;
        (_b2 = (_a2 = pivotedData.get(genomicPosCategory)) == null ? void 0 : _a2.filter((d) => getValueUsingChannel(d, spec.color) === colorCategory)) == null ? void 0 : _b2.forEach((d) => {
          const xValue = +genomicPosCategory;
          const cx = xScale(xValue);
          const cy = max$1([model.encodedPIXIProperty("y", d), 0]);
          if (typeof prevYEndByGPos[genomicPosCategory] === "undefined") {
            prevYEndByGPos[genomicPosCategory] = 0;
          }
          const ys = rowHeight - cy - prevYEndByGPos[genomicPosCategory];
          const ye = rowHeight - prevYEndByGPos[genomicPosCategory];
          if (circular) {
            if (i === 0) {
              const r = trackOuterRadius - rowHeight / trackHeight * trackRingSize;
              const pos = cartesianToPolar(cx, trackWidth, r, trackCenterX, trackCenterY, startAngle, endAngle);
              areaPointsTop.push([pos.x, pos.y]);
              areaPointsBottom.push([pos.x, pos.y]);
            }
            const rTop = trackOuterRadius - ys / trackHeight * trackRingSize;
            const posTop = cartesianToPolar(cx, trackWidth, rTop, trackCenterX, trackCenterY, startAngle, endAngle);
            areaPointsTop.push([posTop.x, posTop.y]);
            const rBot = trackOuterRadius - ye / trackHeight * trackRingSize;
            const posBot = cartesianToPolar(cx, trackWidth, rBot, trackCenterX, trackCenterY, startAngle, endAngle);
            areaPointsBottom.push([posBot.x, posBot.y]);
            if (i === array.length - 1) {
              const r = trackOuterRadius - rowHeight / trackHeight * trackRingSize;
              const pos = cartesianToPolar(cx, trackWidth, r, trackCenterX, trackCenterY, startAngle, endAngle);
              areaPointsTop.push([pos.x, pos.y]);
              areaPointsBottom.push([pos.x, pos.y]);
            }
            model.getMouseEventModel().addPointBasedEvent(d, [posBot.x, posBot.y, 1]);
          } else {
            if (i === 0) {
              areaPointsTop.push([cx, rowHeight]);
              areaPointsBottom.push([cx, rowHeight]);
            }
            areaPointsTop.push([cx, ys]);
            areaPointsBottom.push([cx, ye]);
            if (i === array.length - 1) {
              areaPointsTop.push([cx, rowHeight]);
              areaPointsBottom.push([cx, rowHeight]);
            }
            model.getMouseEventModel().addPointBasedEvent(d, [cx, ys, 1]);
          }
          prevYEndByGPos[genomicPosCategory] += cy;
        });
      });
      const color2 = model.encodedValue("color", colorCategory);
      graphics.beginFill(colorToHex(color2), constantOpacity);
      graphics.drawPolygon([
        ...areaPointsTop.reduce((a, b) => a.concat(b)),
        ...areaPointsBottom.reverse().reduce((a, b) => a.concat(b))
      ]);
      graphics.endFill();
    });
  } else {
    rowCategories.forEach((rowCategory) => {
      const rowPosition = model.encodedValue("row", rowCategory);
      graphics.lineStyle(constantStrokeWidth, colorToHex(constantStroke), constantOpacity, 0);
      colorCategories.forEach((colorCategory) => {
        const baselinePoints = [];
        const areaPoints = [];
        const baselineR = trackOuterRadius - (rowPosition + rowHeight) / trackHeight * trackRingSize;
        data2.filter((d) => (typeof getValueUsingChannel(d, spec.row) === "undefined" || getValueUsingChannel(d, spec.row) === rowCategory) && (typeof getValueUsingChannel(d, spec.color) === "undefined" || getValueUsingChannel(d, spec.color) === colorCategory)).sort((a, b) => model.encodedPIXIProperty("x", a) - model.encodedPIXIProperty("x", b)).forEach((d, i, array) => {
          const cy = min$1([max$1([model.encodedPIXIProperty("y", d), 0]), rowHeight]);
          const cx = model.encodedPIXIProperty("x", d);
          if (circular) {
            const baselinePos = cartesianToPolar(cx, trackWidth, baselineR, trackCenterX, trackCenterY, startAngle, endAngle);
            baselinePoints.push([baselinePos.x, baselinePos.y]);
            if (i === 0) {
              areaPoints.push(baselinePos.x, baselinePos.y);
            }
            const r = trackOuterRadius - (rowPosition + rowHeight - cy) / trackHeight * trackRingSize;
            const pos = cartesianToPolar(cx, trackWidth, r, trackCenterX, trackCenterY, startAngle, endAngle);
            areaPoints.push(pos.x, pos.y);
            if (i === array.length - 1) {
              const startR = trackOuterRadius - (rowPosition + rowHeight) / trackHeight * trackRingSize;
              const curPos = cartesianToPolar(cx, trackWidth, startR, trackCenterX, trackCenterY, startAngle, endAngle);
              areaPoints.push(curPos.x, curPos.y);
            }
            model.getMouseEventModel().addPointBasedEvent(d, [pos.x, pos.y, 1]);
          } else {
            if (i === 0) {
              areaPoints.push(cx, rowPosition + rowHeight);
            }
            areaPoints.push(cx, rowPosition + rowHeight - cy);
            if (i === array.length - 1) {
              const startX = xScale(tileX);
              areaPoints.push(cx, rowPosition + rowHeight);
              areaPoints.push(startX, rowPosition + rowHeight);
            }
            model.getMouseEventModel().addPointBasedEvent(d, [cx, rowPosition + rowHeight - cy, 1]);
          }
        });
        if (circular && baselinePoints.length !== 0) {
          areaPoints.push(...baselinePoints.reverse().reduce((a, b) => a.concat(b)));
        }
        const color2 = model.encodedValue("color", colorCategory);
        graphics.beginFill(colorToHex(color2), constantOpacity);
        graphics.drawPolygon(areaPoints);
        graphics.endFill();
      });
    });
  }
}
function drawRect(HGC, track, tile, model) {
  var _a, _b, _c, _d, _e, _f;
  const spec = model.spec();
  const data2 = model.data();
  const [trackWidth, trackHeight] = track.dimensions;
  const tileSize = track.tilesetInfo.tile_size;
  const { tileX, tileWidth } = track.getTilePosAndDimensions(tile.tileData.zoomLevel, tile.tileData.tilePos, tileSize);
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const cx = trackWidth / 2;
  const cy = trackHeight / 2;
  const xScale = track._xScale;
  const tileUnitWidth = xScale(tileX + tileWidth / tileSize) - xScale(tileX);
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  const RPAD = IsChannelDeep(spec.row) && spec.row.padding ? spec.row.padding : 0;
  const yCategories = (_f = model.getChannelDomainArray("y")) != null ? _f : ["___SINGLE_Y_POSITION___"];
  const cellHeight = rowHeight / yCategories.length - RPAD * 2;
  const g = tile.graphics;
  data2.forEach((d) => {
    var _a2;
    const rowPosition = model.encodedPIXIProperty("row", d) + RPAD;
    const x = model.encodedPIXIProperty("x", d);
    const color2 = model.encodedPIXIProperty("color", d);
    const stroke = model.encodedPIXIProperty("stroke", d);
    const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
    const opacity = model.encodedPIXIProperty("opacity", d);
    const rectWidth = model.encodedPIXIProperty("width", d, { markWidth: tileUnitWidth });
    const rectHeight = model.encodedPIXIProperty("height", d, { markHeight: cellHeight });
    const y = model.encodedPIXIProperty("y", d);
    const alphaTransition = model.markVisibility(d, {
      width: rectWidth,
      zoomLevel: track._xScale.invert(trackWidth) - track._xScale.invert(0)
    });
    const actualOpacity = Math.min(alphaTransition, opacity);
    if (actualOpacity === 0 || rectHeight === 0 || rectWidth <= 1e-4) {
      return;
    }
    const [xs, xe, ys, ye] = [
      x,
      x + rectWidth,
      rowPosition + rowHeight - y - rectHeight / 2,
      rowPosition + rowHeight - y + rectHeight / 2
    ];
    const absoluteHeight = (_a2 = model.visualPropertyByChannel("size", d)) != null ? _a2 : void 0;
    g.lineStyle(strokeWidth, colorToHex(stroke), actualOpacity, 0.5);
    let polygonForMouseEvent = [];
    if (circular) {
      if (xe < 0 || trackWidth < xs) {
        return;
      }
      let farR = trackOuterRadius - ys / trackHeight * trackRingSize;
      let nearR = trackOuterRadius - ye / trackHeight * trackRingSize;
      if (absoluteHeight) {
        const midR = trackOuterRadius - (rowPosition + y) / trackHeight * trackRingSize;
        farR = midR - absoluteHeight / 2;
        nearR = midR + absoluteHeight / 2;
      }
      const sPos = cartesianToPolar(xs, trackWidth, nearR, cx, cy, startAngle, endAngle);
      const startRad = valueToRadian(xs, trackWidth, startAngle, endAngle);
      const endRad = valueToRadian(xe, trackWidth, startAngle, endAngle);
      g.beginFill(colorToHex(color2 === "none" ? "white" : color2), color2 === "none" ? 0 : actualOpacity);
      g.moveTo(sPos.x, sPos.y);
      g.arc(cx, cy, nearR, startRad, endRad, true);
      g.arc(cx, cy, farR, endRad, startRad, false);
      polygonForMouseEvent = Array.from(g.currentPath.points);
      g.closePath();
    } else {
      g.beginFill(colorToHex(color2 === "none" ? "white" : color2), color2 === "none" ? 0 : actualOpacity);
      g.drawRect(xs, ys, xe - xs, ye - ys);
      polygonForMouseEvent = [xs, ys, xs, ye, xe, ye, xe, ys];
    }
    model.getMouseEventModel().addPolygonBasedEvent(d, polygonForMouseEvent);
  });
}
function rectProperty(gm, propertyKey, datum, additionalInfo) {
  var _a;
  switch (propertyKey) {
    case "width":
      const width = gm.visualPropertyByChannel("xe", datum) ? gm.visualPropertyByChannel("xe", datum) - gm.visualPropertyByChannel("x", datum) : additionalInfo == null ? void 0 : additionalInfo.markWidth;
      return width === 0 ? 0.1 : width;
    case "height":
      return (_a = gm.visualPropertyByChannel("size", datum)) != null ? _a : additionalInfo == null ? void 0 : additionalInfo.markHeight;
    default:
      return void 0;
  }
}
function drawTriangle(g, model, trackWidth, trackHeight) {
  var _a, _b, _c, _d, _e, _f, _g;
  const spec = model.spec();
  if (!spec.width || !spec.height) {
    console.warn("Size of a track is not properly determined, so visual mark cannot be rendered");
    return;
  }
  const data2 = model.data();
  const zoomLevel = model.getChannelScale("x").invert(trackWidth) - model.getChannelScale("x").invert(0);
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const cx = trackWidth / 2;
  const cy = trackHeight / 2;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  const yCategories = (_f = model.getChannelDomainArray("y")) != null ? _f : ["___SINGLE_Y___"];
  const triHeight = (_g = model.encodedValue("size")) != null ? _g : circular ? trackRingSize / rowCategories.length / yCategories.length : rowHeight / yCategories.length;
  rowCategories.forEach((rowCategory) => {
    const rowPosition = model.encodedValue("row", rowCategory);
    data2.filter((d) => !getValueUsingChannel(d, spec.row) || getValueUsingChannel(d, spec.row) === rowCategory).forEach((d) => {
      var _a2, _b2, _c2;
      const x = model.encodedPIXIProperty("x", d);
      const xe = model.encodedPIXIProperty("xe", d);
      const markWidth = (_a2 = model.encodedPIXIProperty("size", d)) != null ? _a2 : xe === void 0 ? triHeight : xe - x;
      const y = model.encodedPIXIProperty("y", d);
      const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
      const stroke = model.encodedPIXIProperty("stroke", d);
      const color2 = model.encodedPIXIProperty("color", d);
      const opacity = model.encodedPIXIProperty("opacity", d);
      let polygon = [];
      if (circular) {
        let x0 = x ? x : xe - markWidth;
        let x1 = xe ? xe : x + markWidth;
        let xm = (x0 + x1) / 2;
        const rm = trackOuterRadius - (rowPosition + rowHeight - y) / trackHeight * trackRingSize;
        const r0 = rm - triHeight / 2;
        const r1 = rm + triHeight / 2;
        if (((_b2 = spec.style) == null ? void 0 : _b2.align) === "right" && !xe) {
          x0 -= markWidth;
          x1 -= markWidth;
          xm -= markWidth;
        }
        if (spec.mark === "triangleLeft") {
          const p0 = cartesianToPolar(x1, trackWidth, r0, cx, cy, startAngle, endAngle);
          const p1 = cartesianToPolar(x0, trackWidth, rm, cx, cy, startAngle, endAngle);
          const p2 = cartesianToPolar(x1, trackWidth, r1, cx, cy, startAngle, endAngle);
          const p3 = cartesianToPolar(x1, trackWidth, r0, cx, cy, startAngle, endAngle);
          polygon = [p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y];
        } else if (spec.mark === "triangleRight") {
          const p0 = cartesianToPolar(x0, trackWidth, r0, cx, cy, startAngle, endAngle);
          const p1 = cartesianToPolar(x1, trackWidth, rm, cx, cy, startAngle, endAngle);
          const p2 = cartesianToPolar(x0, trackWidth, r1, cx, cy, startAngle, endAngle);
          const p3 = cartesianToPolar(x0, trackWidth, r0, cx, cy, startAngle, endAngle);
          polygon = [p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y];
        } else if (spec.mark === "triangleBottom") {
          x0 = xm - markWidth / 2;
          x1 = xm + markWidth / 2;
          const p0 = cartesianToPolar(x0, trackWidth, r1, cx, cy, startAngle, endAngle);
          const p1 = cartesianToPolar(x1, trackWidth, r1, cx, cy, startAngle, endAngle);
          const p2 = cartesianToPolar(xm, trackWidth, r0, cx, cy, startAngle, endAngle);
          const p3 = cartesianToPolar(x0, trackWidth, r1, cx, cy, startAngle, endAngle);
          polygon = [p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y];
        }
        const alphaTransition = model.markVisibility(d, { width: x1 - x0, zoomLevel });
        const actualOpacity = Math.min(alphaTransition, opacity);
        g.lineStyle(strokeWidth, colorToHex(stroke), x1 - x0 > 2 ? actualOpacity : 0, 0);
        g.beginFill(colorToHex(color2), actualOpacity);
        g.drawPolygon(polygon);
        g.endFill();
      } else {
        let x0 = x ? x : xe - markWidth;
        let x1 = xe ? xe : x + markWidth;
        let xm = x0 + (x1 - x0) / 2;
        const ym = rowPosition + rowHeight - y;
        const y0 = rowPosition + rowHeight - y - triHeight / 2;
        const y1 = rowPosition + rowHeight - y + triHeight / 2;
        if (((_c2 = spec.style) == null ? void 0 : _c2.align) === "right" && !xe) {
          x0 -= markWidth;
          x1 -= markWidth;
          xm -= markWidth;
        }
        polygon = {
          triangleLeft: [x1, y0, x0, ym, x1, y1, x1, y0],
          triangleRight: [x0, y0, x1, ym, x0, y1, x0, y0],
          triangleBottom: [x0, y0, x1, y0, xm, y1, x0, y0]
        }[spec.mark];
        const alphaTransition = model.markVisibility(d, { width: x1 - x0, zoomLevel });
        const actualOpacity = Math.min(alphaTransition, opacity);
        g.lineStyle(strokeWidth, colorToHex(stroke), x1 - x0 > 2 ? actualOpacity : 0, 0.5);
        g.beginFill(colorToHex(color2), actualOpacity);
        g.drawPolygon(polygon);
        g.endFill();
      }
      model.getMouseEventModel().addPolygonBasedEvent(d, polygon);
    });
  });
}
const TEXT_STYLE_GLOBAL = {
  fontSize: "12px",
  fontFamily: "sans-serif",
  fontWeight: "normal",
  fill: "black",
  background: "white",
  lineJoin: "round",
  stroke: "#ffffff",
  strokeThickness: 0
};
function drawText(HGC, trackInfo, tile, model) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  const spec = model.spec();
  const data2 = model.data();
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const tcx = trackWidth / 2;
  const tcy = trackHeight / 2;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  const dx = (_g = (_f = spec.style) == null ? void 0 : _f.dx) != null ? _g : 0;
  const dy = (_i = (_h = spec.style) == null ? void 0 : _h.dy) != null ? _i : 0;
  const textAnchor = !((_j = spec.style) == null ? void 0 : _j.textAnchor) ? "middle" : spec.style.textAnchor;
  if (IsStackedMark(spec)) {
    if (circular) {
      return;
    }
    const rowGraphics = tile.graphics;
    const genomicChannel = model.getGenomicChannel();
    if (!genomicChannel || !genomicChannel.field) {
      console.warn("Genomic field is not provided in the specification");
      return;
    }
    const pivotedData = group(data2, (d) => d[genomicChannel.field]);
    const xKeys = [...pivotedData.keys()];
    xKeys.forEach((k) => {
      var _a2;
      let prevYEnd = 0;
      (_a2 = pivotedData.get(k)) == null ? void 0 : _a2.forEach((d) => {
        var _a3, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
        const text = model.encodedPIXIProperty("text", d);
        const color2 = model.encodedPIXIProperty("color", d);
        const x = model.encodedPIXIProperty("x", d) + dx;
        const xe = model.encodedPIXIProperty("xe", d) + dx;
        const cx = model.encodedPIXIProperty("x-center", d) + dx;
        const y = model.encodedPIXIProperty("y", d) + dy;
        const size = model.encodedPIXIProperty("size", d);
        const stroke = model.encodedPIXIProperty("stroke", d);
        const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
        const opacity = model.encodedPIXIProperty("opacity", d);
        if (cx < 0 || cx > trackWidth) {
          return;
        }
        if (trackInfo.textsBeingUsed > 1e3) {
          return;
        }
        const localTextStyle = {
          ...TEXT_STYLE_GLOBAL,
          fontSize: size != null ? size : ((_a3 = spec.style) == null ? void 0 : _a3.textFontSize) ? `${(_b2 = spec.style) == null ? void 0 : _b2.textFontSize}px` : TEXT_STYLE_GLOBAL.fontSize,
          stroke: (_d2 = stroke != null ? stroke : (_c2 = spec.style) == null ? void 0 : _c2.textStroke) != null ? _d2 : TEXT_STYLE_GLOBAL.stroke,
          strokeThickness: (_f2 = strokeWidth != null ? strokeWidth : (_e2 = spec.style) == null ? void 0 : _e2.textStrokeWidth) != null ? _f2 : TEXT_STYLE_GLOBAL.strokeThickness,
          fontWeight: (_h2 = (_g2 = spec.style) == null ? void 0 : _g2.textFontWeight) != null ? _h2 : TEXT_STYLE_GLOBAL.fontWeight
        };
        const textStyleObj = new HGC.libraries.PIXI.TextStyle(localTextStyle);
        let textGraphic;
        if (trackInfo.textGraphics.length > trackInfo.textsBeingUsed) {
          textGraphic = trackInfo.textGraphics[trackInfo.textsBeingUsed];
          textGraphic.style.fill = color2;
          textGraphic.visible = true;
          textGraphic.text = text;
          textGraphic.alpha = 1;
        } else {
          textGraphic = new HGC.libraries.PIXI.Text(text, {
            ...localTextStyle,
            fill: color2
          });
          trackInfo.textGraphics.push(textGraphic);
        }
        const metric = HGC.libraries.PIXI.TextMetrics.measureText(text, textStyleObj);
        trackInfo.textsBeingUsed++;
        const alphaTransition = model.markVisibility(d, {
          ...metric,
          zoomLevel: trackInfo._xScale.invert(trackWidth) - trackInfo._xScale.invert(0)
        });
        const actualOpacity = Math.min(alphaTransition, opacity);
        if (!text || actualOpacity === 0) {
          trackInfo.textsBeingUsed--;
          textGraphic.visible = false;
          return;
        }
        textGraphic.alpha = actualOpacity;
        textGraphic.resolution = 8;
        textGraphic.updateText();
        textGraphic.texture.baseTexture.scaleMode = HGC.libraries.PIXI.SCALE_MODES.LINEAR;
        const sprite = new HGC.libraries.PIXI.Sprite(textGraphic.texture);
        sprite.x = x;
        sprite.y = rowHeight - y - prevYEnd;
        sprite.width = xe - x;
        sprite.height = y;
        rowGraphics.addChild(sprite);
        prevYEnd += y;
      });
    });
  } else {
    rowCategories.forEach((rowCategory) => {
      const rowGraphics = tile.graphics;
      const rowPosition = model.encodedValue("row", rowCategory);
      data2.filter((d) => !getValueUsingChannel(d, spec.row) || getValueUsingChannel(d, spec.row) === rowCategory).forEach((d) => {
        var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
        const text = model.encodedPIXIProperty("text", d);
        const color2 = model.encodedPIXIProperty("color", d);
        const cx = model.encodedPIXIProperty("x-center", d) + dx;
        const y = model.encodedPIXIProperty("y", d) + dy;
        const size = model.encodedPIXIProperty("size", d);
        const stroke = model.encodedPIXIProperty("stroke", d);
        const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
        const opacity = model.encodedPIXIProperty("opacity", d);
        if (cx < 0 || cx > trackWidth) {
          return;
        }
        if (trackInfo.textsBeingUsed > 1e3) {
          return;
        }
        const localTextStyle = {
          ...TEXT_STYLE_GLOBAL,
          fontSize: size != null ? size : ((_a2 = spec.style) == null ? void 0 : _a2.textFontSize) ? `${(_b2 = spec.style) == null ? void 0 : _b2.textFontSize}px` : TEXT_STYLE_GLOBAL.fontSize,
          stroke: (_d2 = stroke != null ? stroke : (_c2 = spec.style) == null ? void 0 : _c2.textStroke) != null ? _d2 : TEXT_STYLE_GLOBAL.stroke,
          strokeThickness: (_f2 = strokeWidth != null ? strokeWidth : (_e2 = spec.style) == null ? void 0 : _e2.textStrokeWidth) != null ? _f2 : TEXT_STYLE_GLOBAL.strokeThickness,
          fontWeight: (_h2 = (_g2 = spec.style) == null ? void 0 : _g2.textFontWeight) != null ? _h2 : TEXT_STYLE_GLOBAL.fontWeight
        };
        const textStyleObj = new HGC.libraries.PIXI.TextStyle(localTextStyle);
        let textGraphic;
        if (trackInfo.textGraphics.length > trackInfo.textsBeingUsed) {
          textGraphic = trackInfo.textGraphics[trackInfo.textsBeingUsed];
          textGraphic.style.fill = color2;
          textGraphic.visible = true;
          textGraphic.text = text;
          textGraphic.alpha = 1;
        } else {
          textGraphic = new HGC.libraries.PIXI.Text(text, {
            ...localTextStyle,
            fill: color2
          });
          trackInfo.textGraphics.push(textGraphic);
        }
        const metric = HGC.libraries.PIXI.TextMetrics.measureText(text, textStyleObj);
        trackInfo.textsBeingUsed++;
        const alphaTransition = model.markVisibility(d, {
          ...metric,
          zoomLevel: trackInfo._xScale.invert(trackWidth) - trackInfo._xScale.invert(0)
        });
        const actualOpacity = Math.min(alphaTransition, opacity);
        if (!text || actualOpacity === 0) {
          trackInfo.textsBeingUsed--;
          textGraphic.visible = false;
          return;
        }
        textGraphic.alpha = actualOpacity;
        textGraphic.anchor.y = 0.5;
        textGraphic.anchor.x = textAnchor === "middle" ? 0.5 : textAnchor === "start" ? 0 : 1;
        let polygonForMouseEvents = [];
        if (circular) {
          const r = trackOuterRadius - (rowPosition + rowHeight - y) / trackHeight * trackRingSize;
          const centerPos = cartesianToPolar(cx, trackWidth, r, tcx, tcy, startAngle, endAngle);
          textGraphic.x = centerPos.x;
          textGraphic.y = centerPos.y;
          textGraphic.resolution = 4;
          const tw = metric.width / (2 * r * Math.PI) * trackWidth;
          let [minX, maxX] = [cx - tw / 2, cx + tw / 2];
          if (minX < 0) {
            const gap = -minX;
            minX = 0;
            maxX += gap;
          } else if (maxX > trackWidth) {
            const gap = maxX - trackWidth;
            maxX = trackWidth;
            minX -= gap;
          }
          const ropePoints = [];
          const eventPointsFar = [];
          const eventPointsNear = [];
          for (let i = maxX; i >= minX; i -= tw / 10) {
            const p = cartesianToPolar(i, trackWidth, r, tcx, tcy, startAngle, endAngle);
            ropePoints.push(new HGC.libraries.PIXI.Point(p.x, p.y));
            const pFar = cartesianToPolar(i, trackWidth, r + metric.height / 2, tcx, tcy, startAngle, endAngle);
            const pNear = cartesianToPolar(i, trackWidth, r - metric.height / 2, tcx, tcy, startAngle, endAngle);
            eventPointsFar.push(pFar.x, pFar.y);
            if (i === maxX) {
              eventPointsNear.push(pFar.y, pFar.x);
            }
            eventPointsNear.push(pNear.y, pNear.x);
          }
          textGraphic.updateText();
          const rope = new HGC.libraries.PIXI.SimpleRope(textGraphic.texture, ropePoints);
          rope.alpha = actualOpacity;
          rowGraphics.addChild(rope);
          eventPointsNear.reverse();
          polygonForMouseEvents = eventPointsFar.concat(eventPointsNear);
        } else {
          textGraphic.position.x = cx;
          textGraphic.position.y = rowPosition + rowHeight - y;
          rowGraphics.addChild(textGraphic);
          const { height: h, width: w } = metric;
          const ys = textGraphic.position.y - h / 2;
          const ye = ys + h;
          let xs = 0;
          let xe = 0;
          if (textAnchor === "start") {
            xs = cx;
            xe = cx + w;
          } else if (textAnchor === "middle") {
            xs = cx - w / 2;
            xe = cx + w / 2;
          } else {
            xs = cx - w;
            xe = cx;
          }
          polygonForMouseEvents = [xs, ys, xs, ye, xe, ye, xe, ys];
        }
        model.getMouseEventModel().addPolygonBasedEvent(d, polygonForMouseEvents);
      });
    });
  }
}
function drawRule(HGC, trackInfo, tile, model) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const spec = model.spec();
  const data2 = model.data();
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const cx = trackWidth / 2;
  const cy = trackHeight / 2;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  const dashed = (_f = spec.style) == null ? void 0 : _f.dashed;
  const linePattern = (_g = spec.style) == null ? void 0 : _g.linePattern;
  const curved = (_h = spec.style) == null ? void 0 : _h.curve;
  const g = tile.graphics;
  rowCategories.forEach((rowCategory) => {
    const rowPosition = model.encodedValue("row", rowCategory);
    data2.filter((d) => !getValueUsingChannel(d, spec.row) || getValueUsingChannel(d, spec.row) === rowCategory).forEach((d) => {
      const x = model.encodedPIXIProperty("x", d);
      const xe = model.encodedPIXIProperty("xe", d);
      const y = model.encodedPIXIProperty("y", d);
      const color2 = model.encodedPIXIProperty("color", d);
      const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
      const opacity = model.encodedPIXIProperty("opacity", d);
      const alphaTransition = model.markVisibility(d, {
        width: xe - x,
        zoomLevel: trackInfo._xScale.invert(trackWidth) - trackInfo._xScale.invert(0)
      });
      const actualOpacity = Math.min(alphaTransition, opacity);
      g.lineStyle(strokeWidth, colorToHex(color2), actualOpacity, 0.5);
      if (!xe && (!spec.y || !("field" in spec.y))) {
        if (circular) {
          return;
        } else {
          if (dashed) {
            const [dashSize, gapSize] = dashed;
            let curPos = 0;
            do {
              g.moveTo(x, curPos);
              g.lineTo(x, curPos + dashSize);
              curPos += dashSize + gapSize;
            } while (curPos < trackHeight);
          } else {
            g.moveTo(x, 0);
            g.lineTo(x, trackHeight);
          }
        }
      } else if (!xe && y) {
        if (circular) {
          g.lineStyle(strokeWidth, colorToHex(color2), 0, 0.5);
          const midR = trackOuterRadius - (rowPosition + y) / trackHeight * trackRingSize;
          const farR = midR + strokeWidth / 2;
          const nearR = midR - strokeWidth / 2;
          const sPos = cartesianToPolar(0, trackWidth, nearR, cx, cy, startAngle, endAngle);
          const startRad = valueToRadian(0, trackWidth, startAngle, endAngle);
          const endRad = valueToRadian(trackWidth, trackWidth, startAngle, endAngle);
          g.beginFill(colorToHex(color2), actualOpacity);
          g.moveTo(sPos.x, sPos.y);
          g.arc(cx, cy, nearR, startRad, endRad, true);
          g.arc(cx, cy, farR, endRad, startRad, false);
          g.closePath();
        } else {
          if (dashed) {
            const [dashSize, gapSize] = dashed;
            let curPos = 0;
            do {
              g.moveTo(curPos, rowPosition + rowHeight - y);
              g.lineTo(curPos + dashSize, rowPosition + rowHeight - y);
              curPos += dashSize + gapSize;
            } while (curPos < trackWidth);
          } else {
            g.moveTo(0, rowPosition + rowHeight - y);
            g.lineTo(trackWidth, rowPosition + rowHeight - y);
          }
        }
      } else {
        if (circular) {
          if (strokeWidth === 0) {
            return;
          }
          g.lineStyle(strokeWidth, colorToHex(color2), 0, 0.5);
          const midR = trackOuterRadius - (rowPosition + y) / trackHeight * trackRingSize;
          const farR = midR + strokeWidth / 2;
          const nearR = midR - strokeWidth / 2;
          const sPos = cartesianToPolar(x, trackWidth, nearR, cx, cy, startAngle, endAngle);
          const startRad = valueToRadian(x, trackWidth, startAngle, endAngle);
          const endRad = valueToRadian(xe, trackWidth, startAngle, endAngle);
          g.beginFill(colorToHex(color2), actualOpacity);
          g.moveTo(sPos.x, sPos.y);
          g.arc(cx, cy, nearR, startRad, endRad, true);
          g.arc(cx, cy, farR, endRad, startRad, false);
          g.closePath();
        } else if (dashed) {
          const [dashSize, gapSize] = dashed;
          let curPos = x;
          do {
            g.moveTo(curPos, rowPosition + rowHeight - y);
            g.lineTo(curPos + dashSize, rowPosition + rowHeight - y);
            curPos += dashSize + gapSize;
          } while (curPos < xe);
        } else {
          if (curved === void 0) {
            g.moveTo(x, rowPosition + rowHeight - y);
            g.lineTo(xe, rowPosition + rowHeight - y);
          } else if (curved === "top") {
            const CURVE_HEIGHT = 2;
            const xm = x + (xe - x) / 2;
            g.moveTo(x, rowPosition + rowHeight - y + CURVE_HEIGHT / 2);
            g.lineTo(xm, rowPosition + rowHeight - y - CURVE_HEIGHT / 2);
            g.moveTo(xm, rowPosition + rowHeight - y - CURVE_HEIGHT / 2);
            g.lineTo(xe, rowPosition + rowHeight - y + CURVE_HEIGHT / 2);
          }
        }
        if (linePattern && curved === void 0 && !circular) {
          const { type: pType, size: pSize } = linePattern;
          let curPos = Math.max(x, 0);
          g.lineStyle(0);
          const PATTERN_GAP_SIZE = pSize * 2;
          let count2 = 0;
          while (curPos < Math.min(xe, trackWidth) && count2 < 100) {
            const x0 = curPos;
            const x1 = curPos + pSize;
            const ym = rowPosition + rowHeight - y;
            const y0 = ym - pSize / 2;
            const y1 = ym + pSize / 2;
            g.beginFill(colorToHex(color2), actualOpacity);
            g.drawPolygon(pType === "triangleLeft" ? [x1, y0, x0, ym, x1, y1, x1, y0] : [x0, y0, x1, ym, x0, y1, x0, y0]);
            g.endFill();
            curPos += pSize + PATTERN_GAP_SIZE;
            count2++;
          }
        }
      }
    });
  });
}
function drawWithinLink(g, trackInfo, model) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const spec = model.spec();
  if (!spec.width || !spec.height) {
    console.warn("Size of a track is not properly determined, so visual mark cannot be rendered");
    return;
  }
  const data2 = model.data();
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const tcx = trackWidth / 2;
  const tcy = trackHeight / 2;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  const MIN_HEIGHT = (_g = (_f = spec.style) == null ? void 0 : _f.linkMinHeight) != null ? _g : 0.5;
  const NUM_STEPS = ((_h = spec.experimental) == null ? void 0 : _h.performanceMode) ? 200 : 1e3;
  rowCategories.forEach((rowCategory) => {
    const rowPosition = model.encodedValue("row", rowCategory);
    data2.filter((d) => !getValueUsingChannel(d, spec.row) || getValueUsingChannel(d, spec.row) === rowCategory).forEach((d) => {
      var _a2, _b2, _c2, _d2, _e2;
      let x = model.encodedPIXIProperty("x", d);
      let xe = model.encodedPIXIProperty("xe", d);
      let x1 = model.encodedPIXIProperty("x1", d);
      let x1e = model.encodedPIXIProperty("x1e", d);
      const y = model.encodedPIXIProperty("y", d);
      const stroke = model.encodedPIXIProperty("stroke", d);
      const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
      const color2 = model.encodedPIXIProperty("color", d);
      const opacity = model.encodedPIXIProperty("opacity", d);
      if (typeof xe !== "undefined") {
        [x, xe] = [x, xe].sort((a, b) => a - b);
      }
      if (typeof x1 !== "undefined" && typeof x1e !== "undefined") {
        [x1, x1e] = [x1, x1e].sort((a, b) => a - b);
      }
      const isRibbon = typeof xe !== "undefined" && typeof x1 !== "undefined" && typeof x1e !== "undefined" && Math.abs(x - xe) > 0.1 && Math.abs(x1 - x1e) > 0.1;
      if (!isRibbon && xe === void 0 && !Is2DTrack(spec)) {
        if (x1 === void 0 && x1e === void 0) {
          return;
        }
        xe = x1 !== void 0 ? x1 : x1e;
      }
      if (!isRibbon && Math.abs(x - xe) <= 0.1 && Math.abs(x1 - x1e) <= 0.1) {
        x = (x + xe) / 2;
        xe = (x1 + x1e) / 2;
      }
      g.lineStyle(strokeWidth, colorToHex(stroke), opacity, 0.5);
      const flipY = IsChannelDeep(spec.y) && spec.y.flip || spec.flipY;
      const baseY = (_a2 = spec.baselineY) != null ? _a2 : rowPosition + (flipY ? 0 : rowHeight);
      let pathForMouseEvent = [];
      if (isRibbon) {
        g.beginFill(color2 === "none" ? colorToHex("white") : colorToHex(color2), color2 === "none" ? 0 : opacity);
        let [_x1, _x2, _x3, _x4] = [x, xe, x1, x1e];
        [_x1, _x2, _x3, _x4] = [_x1, _x2, _x3, _x4].sort((a, b) => a - b);
        if (_x1 > trackWidth || _x4 < 0 || Math.abs(_x4 - _x1) < 0.5) {
          return;
        }
        if (circular) {
          if (_x1 < 0 || _x4 > trackWidth) {
            return;
          }
          const r = trackOuterRadius - rowPosition / trackHeight * trackRingSize;
          const posX = cartesianToPolar(_x1, trackWidth, r, tcx, tcy, startAngle, endAngle);
          const posXE = cartesianToPolar(_x2, trackWidth, r, tcx, tcy, startAngle, endAngle);
          const posX1 = cartesianToPolar(_x3, trackWidth, r, tcx, tcy, startAngle, endAngle);
          const posX1E = cartesianToPolar(_x4, trackWidth, r, tcx, tcy, startAngle, endAngle);
          g.moveTo(posX.x, posX.y);
          g.bezierCurveTo(tcx, tcy, tcx, tcy, posX1E.x, posX1E.y);
          g.arc(tcx, tcy, trackOuterRadius, positionToRadian(posX1E.x, posX1E.y, tcx, tcy), positionToRadian(posX1.x, posX1.y, tcx, tcy), false);
          g.bezierCurveTo(tcx, tcy, tcx, tcy, posXE.x, posXE.y);
          g.arc(tcx, tcy, trackOuterRadius, positionToRadian(posXE.x, posXE.y, tcx, tcy), positionToRadian(posX.x, posX.y, tcx, tcy), false);
          pathForMouseEvent = Array.from(g.currentPath.points);
          g.endFill();
        } else {
          g.moveTo(_x1, baseY);
          if (!((_b2 = spec.style) == null ? void 0 : _b2.linkStyle) || ((_c2 = spec.style) == null ? void 0 : _c2.linkStyle) === "circular") {
            g.arc((_x1 + _x4) / 2, baseY, (_x4 - _x1) / 2, -Math.PI, Math.PI, false);
            g.arc((_x2 + _x3) / 2, baseY, (_x3 - _x2) / 2, Math.PI, -Math.PI, true);
            pathForMouseEvent = Array.from(g.currentPath.points);
            g.closePath();
          } else {
            g.lineTo(_x3, rowPosition + rowHeight);
            g.bezierCurveTo(_x3 + (_x2 - _x3) / 3, rowPosition + rowHeight - (_x2 - _x3) / 2, _x3 + (_x2 - _x3) / 3 * 2, rowPosition + rowHeight - (_x2 - _x3) / 2, _x2, rowPosition + rowHeight);
            g.lineTo(_x4, rowPosition + rowHeight);
            g.bezierCurveTo(_x1 + (_x4 - _x1) / 3 * 2, rowPosition + rowHeight - (_x4 - _x1) / 2, _x1 + (_x4 - _x1) / 3, rowPosition + rowHeight - (_x4 - _x1) / 2, _x1, rowPosition + rowHeight);
            pathForMouseEvent = Array.from(g.currentPath.points);
            g.endFill();
          }
        }
        model.getMouseEventModel().addPolygonBasedEvent(d, pathForMouseEvent);
      } else {
        const midX = (x + xe) / 2;
        g.beginFill(colorToHex("white"), 0);
        if (circular) {
          if (x < 0 || xe > trackWidth) {
            return;
          }
          if (((_d2 = spec.style) == null ? void 0 : _d2.linkStyle) === "straight") {
            const r = trackOuterRadius - rowPosition / trackHeight * trackRingSize;
            const posS = cartesianToPolar(x, trackWidth, r, tcx, tcy, startAngle, endAngle);
            const posE = cartesianToPolar(xe, trackWidth, r, tcx, tcy, startAngle, endAngle);
            const x12 = posS.x;
            const y1 = posS.y;
            const x4 = posE.x;
            const y4 = posE.y;
            g.moveTo(x12, y1);
            g.lineTo(x4, y4);
            const length = 100;
            const eventPoints = Array.from({ length }, (d2, i) => {
              return {
                x: (x4 - x12) / (length - 1) * i + x12,
                y: (y4 - y1) / (length - 1) * i + y1
              };
            });
            pathForMouseEvent = eventPoints.flatMap((d2) => [d2.x, d2.y]);
          } else {
            const r = trackOuterRadius - rowPosition / trackHeight * trackRingSize;
            const posS = cartesianToPolar(x, trackWidth, r, tcx, tcy, startAngle, endAngle);
            const posE = cartesianToPolar(xe, trackWidth, r, tcx, tcy, startAngle, endAngle);
            const x12 = posS.x;
            const y1 = posS.y;
            const x2 = posS.x;
            const y2 = posS.y;
            const x3 = trackWidth / 2;
            const y3 = trackHeight / 2;
            const x4 = posE.x;
            const y4 = posE.y;
            g.moveTo(x12, y1);
            const bezier = new Bezier(x12, y1, x2, y2, x3, y3, x4, y4);
            const points = bezier.getLUT(14);
            points.forEach((d2) => g.lineTo(d2.x, d2.y));
            const morePoints = bezier.getLUT(1e3);
            pathForMouseEvent = morePoints.flatMap((d2) => [d2.x, d2.y]);
          }
        } else {
          if (((_e2 = spec.style) == null ? void 0 : _e2.linkStyle) === "elliptical") {
            if (!(0 <= x && x <= trackWidth) && !(0 <= xe && xe <= trackWidth)) {
              return;
            }
            const morePoints = [];
            const constantY = IsChannelDeep(spec.y);
            for (let step = 0; step <= NUM_STEPS; step++) {
              const theta = Math.PI * (step / NUM_STEPS);
              const mx = (xe - x) / 2 * Math.cos(theta) + (x + xe) / 2;
              const my = baseY - y * Math.sin(theta) * (constantY ? 1 : Math.min(xe - x + trackWidth * MIN_HEIGHT, trackWidth) / trackWidth) * (flipY ? -1 : 1);
              if (step % 20 === 0 || step === NUM_STEPS) {
                if (step === 0) {
                  g.moveTo(mx, my);
                } else {
                  g.lineTo(mx, my);
                }
              }
              morePoints.push({ x: mx, y: my });
            }
            pathForMouseEvent = morePoints.flatMap((d2) => [d2.x, d2.y]);
          } else {
            if (xe < 0 || x > trackWidth) {
              return;
            }
            g.arc(midX, baseY, (xe - x) / 2, -Math.PI, Math.PI);
            pathForMouseEvent = Array.from(g.currentPath.points);
            g.closePath();
          }
        }
        model.getMouseEventModel().addLineBasedEvent(d, pathForMouseEvent);
      }
    });
  });
}
function drawGrid(trackInfo, tm, theme) {
  drawYGridQuantitative(trackInfo, tm, theme);
  drawRowGrid(trackInfo, tm, theme);
}
function drawRowGrid(trackInfo, tm, theme) {
  var _a, _b, _c, _d;
  const spec = tm.spec();
  if (!IsChannelDeep(spec.row) || spec.row.grid !== true) {
    return;
  }
  const [trackX, trackY] = trackInfo.position;
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const circular = tm.spec().layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const cx = trackWidth / 2;
  const cy = trackHeight / 2;
  const rowCategories = tm.getChannelDomainArray("row");
  if (!rowCategories) {
    return;
  }
  const rowHeight = trackHeight / rowCategories.length;
  if (circular && trackRingSize <= 20 || !circular && rowHeight <= 20) {
    return;
  }
  const graphics = trackInfo.pBackground;
  const strokeWidth = theme.axis.gridStrokeWidth;
  rowCategories.forEach((rowCategory) => {
    const rowPosition = tm.encodedValue("row", rowCategory);
    if (!circular) {
      graphics.lineStyle(strokeWidth, colorToHex(theme.axis.gridColor), 1, 0.5);
      const y = trackY + rowPosition + rowHeight / 2;
      graphics.moveTo(trackX, y);
      graphics.lineTo(trackX + trackWidth, y);
    } else {
      const y = rowPosition + rowHeight / 2;
      const midR = trackOuterRadius - y / trackHeight * trackRingSize;
      const farR = midR + strokeWidth / 2;
      const nearR = midR - strokeWidth / 2;
      const sPos = cartesianToPolar(0, trackWidth, nearR, cx, cy, startAngle, endAngle);
      const startRad = valueToRadian(0, trackWidth, startAngle, endAngle);
      const endRad = valueToRadian(trackWidth, trackWidth, startAngle, endAngle);
      graphics.lineStyle(strokeWidth, colorToHex("black"), 0, 0.5);
      graphics.beginFill(colorToHex(theme.axis.gridColor), 1);
      graphics.moveTo(trackX + sPos.x, trackY + sPos.y);
      graphics.arc(trackX + cx, trackY + cy, nearR, startRad, endRad, true);
      graphics.arc(trackX + cx, trackY + cy, farR, endRad, startRad, false);
      graphics.closePath();
    }
  });
}
function drawYGridQuantitative(trackInfo, tm, theme) {
  var _a, _b, _c, _d, _e;
  const spec = tm.spec();
  if (!IsChannelDeep(spec.y) || spec.y.grid !== true) {
    return;
  }
  const [trackX, trackY] = trackInfo.position;
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const startX = trackX;
  const endX = trackX + trackWidth;
  const circular = tm.spec().layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const cx = trackWidth / 2;
  const cy = trackHeight / 2;
  const rowCategories = (_e = tm.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  const scale = tm.getChannelScale("y");
  const domain = tm.getChannelDomainArray("y");
  if (!scale || !domain) {
    return;
  }
  if (circular && rowHeight / trackHeight * trackRingSize <= 20 || !circular && rowHeight <= 20) {
    return;
  }
  const graphics = trackInfo.pBackground;
  const strokeWidth = theme.axis.gridStrokeWidth;
  rowCategories.forEach((rowCategory) => {
    const rowPosition = tm.encodedValue("row", rowCategory);
    const assignedHeight = circular ? rowHeight / trackHeight * trackRingSize : rowHeight;
    const tickCount = Math.max(Math.ceil(assignedHeight / 40), 1);
    let ticks = scale.ticks(tickCount).filter((v) => domain[0] <= v && v <= domain[1]);
    if (ticks.length === 1) {
      ticks = scale.ticks(tickCount + 1).filter((v) => domain[0] <= v && v <= domain[1]);
    }
    if (!circular) {
      graphics.lineStyle(strokeWidth, colorToHex(theme.axis.gridColor), 1, 0.5);
      ticks.forEach((value) => {
        var _a2;
        const y = trackY + rowPosition + rowHeight - scale(value);
        if (theme.axis.gridStrokeType === "solid") {
          graphics.moveTo(startX, y);
          graphics.lineTo(endX, y);
        } else if (theme.axis.gridStrokeType === "dashed") {
          const [line, gap] = (_a2 = theme.axis.gridStrokeDash) != null ? _a2 : [1, 1];
          for (let i = startX; i < endX; i += line + gap) {
            graphics.moveTo(i, y);
            graphics.lineTo(i + line, y);
          }
        }
      });
    } else {
      ticks.forEach((value) => {
        const y = scale(value);
        const midR = trackOuterRadius - (rowPosition + rowHeight - y) / trackHeight * trackRingSize;
        const farR = midR + strokeWidth / 2;
        const nearR = midR - strokeWidth / 2;
        const sPos = cartesianToPolar(0, trackWidth, nearR, cx, cy, startAngle, endAngle);
        const startRad = valueToRadian(0, trackWidth, startAngle, endAngle);
        const endRad = valueToRadian(trackWidth, trackWidth, startAngle, endAngle);
        graphics.lineStyle(strokeWidth, colorToHex("black"), 0, 0.5);
        graphics.beginFill(colorToHex(theme.axis.gridColor), 1);
        graphics.moveTo(trackX + sPos.x, trackY + sPos.y);
        graphics.arc(trackX + cx, trackY + cy, nearR, startRad, endRad, true);
        graphics.arc(trackX + cx, trackY + cy, farR, endRad, startRad, false);
        graphics.closePath();
      });
    }
  });
}
const DEFAULT_TEXT_STYLE = {
  color: "black",
  size: 10,
  fontFamily: "Arial",
  fontWeight: "normal",
  stroke: "#ffffff",
  strokeThickness: 0
};
function getTextStyle(style = {}) {
  const merged = { ...DEFAULT_TEXT_STYLE, ...style };
  const pixiTextStyle = {
    fontSize: `${merged.size}px`,
    fontFamily: merged.fontFamily,
    fontWeight: merged.fontWeight === "light" ? "lighter" : merged.fontWeight,
    fill: merged.color,
    lineJoin: "round",
    stroke: merged.stroke,
    strokeThickness: merged.strokeThickness
  };
  return pixiTextStyle;
}
function drawCircularTitle(HGC, trackInfo, tile, model, theme) {
  var _a, _b, _c;
  const spec = model.spec();
  const { title: title2 } = spec;
  if (spec.layout !== "circular") {
    return;
  }
  if (!title2) {
    return;
  }
  const [tw, th] = trackInfo.dimensions;
  const trackOuterRadius = (_a = spec.outerRadius) != null ? _a : 300;
  const startAngle = (_b = spec.startAngle) != null ? _b : 0;
  const endAngle = (_c = spec.endAngle) != null ? _c : 360;
  const cx = tw / 2;
  const cy = th / 2;
  const g = tile.graphics;
  const titleR = trackOuterRadius - 1;
  const padding = 1;
  const pos = cartesianToPolar(padding, tw, titleR, cx, cy, startAngle, endAngle);
  const styleConfig = getTextStyle({
    color: theme.track.titleColor,
    size: 12,
    fontFamily: theme.axis.labelFontFamily,
    fontWeight: theme.axis.labelFontWeight
  });
  const textGraphic = new HGC.libraries.PIXI.Text(title2, styleConfig);
  textGraphic.anchor.x = 1;
  textGraphic.anchor.y = 0.5;
  textGraphic.position.x = pos.x;
  textGraphic.position.y = pos.y;
  textGraphic.resolution = 4;
  const txtStyle = new HGC.libraries.PIXI.TextStyle(styleConfig);
  const metric = HGC.libraries.PIXI.TextMetrics.measureText(textGraphic.text, txtStyle);
  const txtWidth = metric.width / (2 * titleR * Math.PI) * tw * 360 / (endAngle - startAngle);
  const scaledStartX = padding;
  const scaledEndX = padding + txtWidth;
  const ropePoints = [];
  for (let i = scaledEndX; i >= scaledStartX; i -= txtWidth / 10) {
    const p = cartesianToPolar(i, tw, titleR - metric.height / 2, cx, cy, startAngle, endAngle);
    ropePoints.push(new HGC.libraries.PIXI.Point(p.x, p.y));
  }
  const startRad = valueToRadian(scaledStartX, tw, startAngle, endAngle);
  const endRad = valueToRadian(scaledEndX + padding, tw, startAngle, endAngle);
  g.lineStyle(1, colorToHex("red"), 0, 0.5);
  g.beginFill(colorToHex(theme.track.titleBackground), 0.5);
  g.moveTo(pos.x, pos.y);
  g.arc(cx, cy, titleR - metric.height, startRad, endRad, true);
  g.arc(cx, cy, titleR, endRad, startRad, false);
  g.closePath();
  textGraphic.updateText();
  const rope = new HGC.libraries.PIXI.SimpleRope(textGraphic.texture, ropePoints);
  g.addChild(rope);
}
function drawChartOutlines(HGC, trackInfo, tm, theme) {
  var _a, _b, _c, _d;
  const g = trackInfo.pBorder;
  const [l, t] = trackInfo.position;
  const [w, h] = trackInfo.dimensions;
  g.lineStyle((_b = (_a = tm.spec().style) == null ? void 0 : _a.outlineWidth) != null ? _b : 1, colorToHex((_d = (_c = tm.spec().style) == null ? void 0 : _c.outline) != null ? _d : theme.track.outline), 1, 0.5);
  g.beginFill(colorToHex("white"), 0);
  g.drawRect(l, t, w, h);
  const x = tm.spec().x;
  g.lineStyle(1, colorToHex(theme.axis.baselineColor), 1, 0.5);
  if (IsChannelDeep(x) && x.axis === "top") {
    g.moveTo(l, t);
    g.lineTo(l + w, t);
  } else if (IsChannelDeep(x) && x.axis === "bottom") {
    g.moveTo(l, t + h);
    g.lineTo(l + w, t + h);
  }
}
function drawColorLegend(HGC, trackInfo, _tile, model, theme) {
  if (!trackInfo.gLegend) {
    return;
  }
  trackInfo.gLegend.selectAll(".brush").remove();
  const spec = model.spec();
  const offset = { offsetRight: 0 };
  if (IsChannelDeep(spec.color) && spec.color.legend) {
    switch (spec.color.type) {
      case "nominal":
        drawColorLegendCategories(HGC, trackInfo, _tile, model, theme);
        break;
      case "quantitative":
        drawColorLegendQuantitative(HGC, trackInfo, _tile, model, theme, "color", offset);
        break;
    }
  }
  if (IsChannelDeep(spec.stroke) && spec.stroke.legend) {
    switch (spec.stroke.type) {
      case "quantitative":
        drawColorLegendQuantitative(HGC, trackInfo, _tile, model, theme, "stroke", offset);
        break;
    }
  }
}
function drawColorLegendQuantitative(HGC, trackInfo, _tile, model, theme, channelKey, offset) {
  const spec = model.spec();
  const channel = spec[channelKey];
  if (!IsChannelDeep(channel) || channel.type !== "quantitative" || !channel.legend) {
    return;
  }
  const [trackX, trackY] = trackInfo.position;
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const legendWidth = 80;
  const legendHeight = trackHeight - 2 > 110 ? 110 : Math.max(trackHeight - 2, 40 - 2);
  const colorBarDim = {
    top: 10,
    left: 55,
    width: 20,
    height: legendHeight - 20
  };
  const legendX = trackX + trackWidth - legendWidth - 1 - offset.offsetRight;
  const legendY = trackY + 1;
  const colorScale = model.getChannelScale(channelKey);
  const colorDomain = model.getChannelDomainArray(channelKey);
  if (!colorScale || !colorDomain) {
    return;
  }
  const graphics = trackInfo.pBorder;
  graphics.beginFill(colorToHex(theme.legend.background), theme.legend.backgroundOpacity);
  graphics.lineStyle(1, colorToHex(theme.legend.backgroundStroke), theme.legend.backgroundOpacity, 0);
  graphics.drawRect(legendX, legendY, legendWidth, legendHeight);
  if (channel.title) {
    const titleStr = channel.title;
    const labelTextStyle2 = getTextStyle({
      color: theme.legend.labelColor,
      size: theme.legend.labelFontSize,
      fontWeight: theme.legend.labelFontWeight,
      fontFamily: theme.legend.labelFontFamily
    });
    const textGraphic = new HGC.libraries.PIXI.Text(titleStr, {
      ...labelTextStyle2,
      fontWeight: "bold"
    });
    textGraphic.anchor.x = 0;
    textGraphic.anchor.y = 0;
    textGraphic.position.x = legendX + 10;
    textGraphic.position.y = legendY + 10;
    const textStyleObj = new HGC.libraries.PIXI.TextStyle({ ...labelTextStyle2, fontWeight: "bold" });
    const textMetrics = HGC.libraries.PIXI.TextMetrics.measureText(titleStr, textStyleObj);
    graphics.addChild(textGraphic);
    colorBarDim.top += textMetrics.height + 4;
    colorBarDim.height -= textMetrics.height + 4;
  }
  const [startValue, endValue] = colorDomain;
  const extent = endValue - startValue;
  const scaleOffset = IsChannelDeep(channel) && channel.scaleOffset ? channel.scaleOffset : [0, 1];
  [...Array(colorBarDim.height).keys()].forEach((y) => {
    let value;
    const scaleOffsetSorted = Array.from(scaleOffset).sort();
    if (y / colorBarDim.height >= scaleOffsetSorted[1]) {
      value = endValue;
    } else if (y / colorBarDim.height <= scaleOffsetSorted[0]) {
      value = startValue;
    } else {
      const s1 = scaleLinear().domain([colorBarDim.height * scaleOffsetSorted[0], colorBarDim.height * scaleOffsetSorted[1]]).range([0, colorBarDim.height]);
      const s2 = scaleLinear().domain([0, colorBarDim.height]).range([startValue, endValue]);
      value = s2(s1(y));
    }
    graphics.beginFill(colorToHex(colorScale(value)), 1);
    graphics.lineStyle(1, colorToHex(theme.legend.backgroundStroke), 0, 0.5);
    graphics.drawRect(legendX + colorBarDim.left, legendY + colorBarDim.top + colorBarDim.height - y, colorBarDim.width, 1);
  });
  const BRUSH_HEIGHT = 4;
  trackInfo.colorBrushes = trackInfo.gLegend.append("g").attr("class", channelKey).selectAll(`.brush`).data(scaleOffset.map((d, i) => {
    return { y: d, id: i };
  })).enter().append("rect").attr("class", `brush`).attr("pointer-events", "all").attr("cursor", "ns-resize").attr("transform", (d) => `translate(${legendX + colorBarDim.left}, ${legendY + colorBarDim.top - BRUSH_HEIGHT / 2 + colorBarDim.height - colorBarDim.height * d.y})`).attr("width", `${colorBarDim.width}px`).attr("height", `${BRUSH_HEIGHT}px`).attr("fill", "lightgrey").attr("stroke", "black").attr("stroke-width", "0.5px").call(HGC.libraries.d3Drag.drag().on("start", () => {
    trackInfo.startEvent = HGC.libraries.d3Selection.event.sourceEvent;
  }).on("drag", (d) => {
    if (channel && channel.scaleOffset) {
      const endEvent = HGC.libraries.d3Selection.event.sourceEvent;
      const diffY = trackInfo.startEvent.clientY - endEvent.clientY;
      const newScaleOffset = [channel.scaleOffset[0], channel.scaleOffset[1]];
      if (d.id === 0) {
        newScaleOffset[0] += diffY / colorBarDim.height;
      } else {
        newScaleOffset[1] += diffY / colorBarDim.height;
      }
      newScaleOffset[0] = Math.min(1, Math.max(0, newScaleOffset[0]));
      newScaleOffset[1] = Math.min(1, Math.max(0, newScaleOffset[1]));
      trackInfo.updateScaleOffsetFromOriginalSpec(spec._renderingId, newScaleOffset, channelKey);
      trackInfo.shareScaleOffsetAcrossTracksAndTiles(newScaleOffset, channelKey);
      trackInfo.draw();
      trackInfo.startEvent = HGC.libraries.d3Selection.event.sourceEvent;
    }
  }));
  const tickCount = Math.max(Math.ceil(colorBarDim.height / 30), 2);
  let ticks = colorScale.ticks(tickCount).filter((v) => colorDomain[0] <= v && v <= colorDomain[1]);
  if (ticks.length === 1) {
    ticks = colorScale.ticks(tickCount + 1).filter((v) => colorDomain[0] <= v && v <= colorDomain[1]);
  }
  const TICK_STROKE_SIZE = 1;
  graphics.lineStyle(TICK_STROKE_SIZE, colorToHex(theme.legend.tickColor), 1, 0.5);
  const labelTextStyle = getTextStyle({
    color: theme.legend.labelColor,
    size: theme.legend.labelFontSize,
    fontWeight: theme.legend.labelFontWeight,
    fontFamily: theme.legend.labelFontFamily
  });
  const tickEnd = legendX + colorBarDim.left;
  ticks.forEach((value) => {
    let y = legendY + colorBarDim.top + colorBarDim.height - (value - startValue) / extent * colorBarDim.height;
    if (y === legendY + colorBarDim.top) {
      y += TICK_STROKE_SIZE / 2;
    } else if (y === legendY + colorBarDim.top + colorBarDim.height) {
      y -= TICK_STROKE_SIZE / 2;
    }
    graphics.moveTo(tickEnd - 3, y);
    graphics.lineTo(tickEnd, y);
    const textGraphic = new HGC.libraries.PIXI.Text(value, labelTextStyle);
    textGraphic.anchor.x = 1;
    textGraphic.anchor.y = 0.5;
    textGraphic.position.x = tickEnd - 6;
    textGraphic.position.y = y;
    graphics.addChild(textGraphic);
  });
  offset.offsetRight = trackWidth - legendX;
}
function drawColorLegendCategories(HGC, trackInfo, _tile, tm, theme) {
  var _a, _b, _c, _d, _e;
  const spec = tm.spec();
  if (!IsChannelDeep(spec.color) || spec.color.type !== "nominal" || !spec.color.legend) {
    return;
  }
  const colorCategories = (_a = tm.getChannelDomainArray("color")) != null ? _a : ["___SINGLE_COLOR___"];
  if (colorCategories.length === 0) {
    return;
  }
  const graphics = trackInfo.pBorder;
  const paddingX = 10;
  const paddingY = 4;
  let cumY = paddingY;
  let maxWidth = 0;
  const recipe = [];
  const labelTextStyle = getTextStyle({
    color: theme.legend.labelColor,
    size: theme.legend.labelFontSize,
    fontWeight: theme.legend.labelFontWeight,
    fontFamily: theme.legend.labelFontFamily
  });
  if ((_b = spec.style) == null ? void 0 : _b.inlineLegend) {
    colorCategories.map((d) => d).reverse().forEach((category) => {
      if (maxWidth > trackInfo.dimensions[0]) {
        return;
      }
      const color2 = tm.encodedValue("color", category);
      const textGraphic = new HGC.libraries.PIXI.Text(category, labelTextStyle);
      textGraphic.anchor.x = 1;
      textGraphic.anchor.y = 0;
      textGraphic.position.x = trackInfo.position[0] + trackInfo.dimensions[0] - maxWidth - paddingX;
      textGraphic.position.y = trackInfo.position[1] + paddingY;
      graphics.addChild(textGraphic);
      const textStyleObj = new HGC.libraries.PIXI.TextStyle(labelTextStyle);
      const textMetrics = HGC.libraries.PIXI.TextMetrics.measureText(category, textStyleObj);
      if (cumY < textMetrics.height + paddingY * 3) {
        cumY = textMetrics.height + paddingY * 3;
      }
      recipe.push({
        x: trackInfo.position[0] + trackInfo.dimensions[0] - textMetrics.width - maxWidth - paddingX * 2,
        y: trackInfo.position[1] + paddingY + textMetrics.height / 2,
        color: color2
      });
      maxWidth += textMetrics.width + paddingX * 3;
    });
  } else {
    if ((_c = spec.style) == null ? void 0 : _c.legendTitle) {
      const textGraphic = new HGC.libraries.PIXI.Text((_d = spec.style) == null ? void 0 : _d.legendTitle, {
        ...labelTextStyle,
        fontWeight: "bold"
      });
      textGraphic.anchor.x = 1;
      textGraphic.anchor.y = 0;
      textGraphic.position.x = trackInfo.position[0] + trackInfo.dimensions[0] - paddingX;
      textGraphic.position.y = trackInfo.position[1] + cumY;
      const textStyleObj = new HGC.libraries.PIXI.TextStyle({ ...labelTextStyle, fontWeight: "bold" });
      const textMetrics = HGC.libraries.PIXI.TextMetrics.measureText((_e = spec.style) == null ? void 0 : _e.legendTitle, textStyleObj);
      graphics.addChild(textGraphic);
      cumY += textMetrics.height + paddingY * 2;
    }
    colorCategories.forEach((category) => {
      if (cumY > trackInfo.dimensions[1]) {
        return;
      }
      const color2 = tm.encodedValue("color", category);
      const textGraphic = new HGC.libraries.PIXI.Text(category, labelTextStyle);
      textGraphic.anchor.x = 1;
      textGraphic.anchor.y = 0;
      textGraphic.position.x = trackInfo.position[0] + trackInfo.dimensions[0] - paddingX;
      textGraphic.position.y = trackInfo.position[1] + cumY;
      graphics.addChild(textGraphic);
      const textStyleObj = new HGC.libraries.PIXI.TextStyle(labelTextStyle);
      const textMetrics = HGC.libraries.PIXI.TextMetrics.measureText(category, textStyleObj);
      if (maxWidth < textMetrics.width + paddingX * 3) {
        maxWidth = textMetrics.width + paddingX * 3;
      }
      recipe.push({
        x: trackInfo.position[0] + trackInfo.dimensions[0] - textMetrics.width - paddingX * 2,
        y: trackInfo.position[1] + cumY + textMetrics.height / 2,
        color: color2
      });
      cumY += textMetrics.height + paddingY * 2;
    });
  }
  graphics.beginFill(colorToHex(theme.legend.background), theme.legend.backgroundOpacity);
  graphics.lineStyle(1, colorToHex(theme.legend.backgroundStroke), theme.legend.backgroundOpacity, 0);
  graphics.drawRect(trackInfo.position[0] + trackInfo.dimensions[0] - maxWidth - 1, trackInfo.position[1] + 1, maxWidth, cumY - paddingY);
  recipe.forEach((r) => {
    graphics.lineStyle(1, colorToHex("black"), 0, 0);
    graphics.beginFill(colorToHex(r.color), 1);
    graphics.drawCircle(r.x, r.y, 4);
  });
}
function drawRowLegend(HGC, trackInfo, _tile, tm, theme) {
  var _a;
  const spec = tm.spec();
  if (!IsChannelDeep(spec.row) || spec.row.type !== "nominal" || !spec.row.legend) {
    return;
  }
  const rowCategories = (_a = tm.getChannelDomainArray("row")) != null ? _a : ["___SINGLE_ROW___"];
  if (rowCategories.length === 0) {
    return;
  }
  const graphics = trackInfo.pBorder;
  const paddingX = 4;
  const paddingY = 2;
  const labelTextStyle = getTextStyle({
    color: theme.legend.labelColor,
    size: theme.legend.labelFontSize,
    fontWeight: theme.legend.labelFontWeight,
    fontFamily: theme.legend.labelFontFamily
  });
  rowCategories.forEach((category) => {
    const rowPosition = tm.encodedValue("row", category);
    const textGraphic = new HGC.libraries.PIXI.Text(category, labelTextStyle);
    textGraphic.anchor.x = 0;
    textGraphic.anchor.y = 0;
    textGraphic.position.x = trackInfo.position[0] + paddingX;
    textGraphic.position.y = trackInfo.position[1] + rowPosition + paddingY;
    graphics.addChild(textGraphic);
    const textStyleObj = new HGC.libraries.PIXI.TextStyle(labelTextStyle);
    const textMetrics = HGC.libraries.PIXI.TextMetrics.measureText(category, textStyleObj);
    graphics.beginFill(colorToHex(theme.legend.background), theme.legend.backgroundOpacity);
    graphics.lineStyle(1, colorToHex(theme.legend.backgroundStroke), 0, 0);
    graphics.drawRect(trackInfo.position[0] + 1, trackInfo.position[1] + rowPosition + 1, textMetrics.width + paddingX * 2, textMetrics.height + paddingY * 2);
  });
}
const EXTENT_TICK_SIZE = 8;
const TICK_SIZE = 6;
function drawLinearYAxis(HGC, trackInfo, _tile, model, theme) {
  var _a;
  const spec = model.spec();
  const CIRCULAR = spec.layout === "circular";
  const yDomain = model.getChannelDomainArray("y");
  const yRange = model.getChannelRangeArray("y");
  if (CIRCULAR) {
    return;
  }
  if (!model.isShowYAxis() || !yDomain || !yRange) {
    return;
  }
  const [tw, th] = trackInfo.dimensions;
  const [tx, ty] = trackInfo.position;
  const rowCategories = (_a = model.getChannelDomainArray("row")) != null ? _a : ["___SINGLE_ROW___"];
  const rowHeight = th / rowCategories.length;
  if (rowHeight <= 20) {
    return;
  }
  const yChannel = model.spec().y;
  const isLeft = IsChannelDeep(yChannel) && "axis" in yChannel && yChannel.axis === "right" ? false : true;
  const yScale = scaleLinear().domain(yDomain).range(yRange);
  const graphics = trackInfo.pBorder;
  rowCategories.forEach((category) => {
    const rowPosition = model.encodedValue("row", category);
    const dx = isLeft ? tx : tx + tw;
    const dy = ty + rowPosition;
    graphics.lineStyle(1, colorToHex(theme.axis.baselineColor), 1, 0.5);
    graphics.moveTo(dx, dy);
    graphics.lineTo(dx, dy + rowHeight);
    const tickCount = Math.max(Math.ceil(rowHeight / 40), 1);
    let ticks = yScale.ticks(tickCount).filter((v) => yDomain[0] <= v && v <= yDomain[1]);
    if (ticks.length === 1) {
      ticks = yScale.ticks(tickCount + 1).filter((v) => yDomain[0] <= v && v <= yDomain[1]);
    }
    graphics.lineStyle(1, colorToHex(theme.axis.tickColor), 1, 0.5);
    let tickEnd = isLeft ? dx + TICK_SIZE : dx - TICK_SIZE;
    ticks.forEach((t) => {
      const y = yScale(t);
      graphics.moveTo(dx, dy + rowHeight - y);
      graphics.lineTo(tickEnd, dy + rowHeight - y);
    });
    tickEnd = isLeft ? dx + EXTENT_TICK_SIZE : dx - EXTENT_TICK_SIZE;
    graphics.moveTo(dx, dy);
    graphics.lineTo(tickEnd, dy);
    graphics.moveTo(dx, dy + rowHeight);
    graphics.lineTo(tickEnd, dy + rowHeight);
    const styleConfig = getTextStyle({
      color: theme.axis.labelColor,
      size: theme.axis.labelFontSize,
      fontFamily: theme.axis.labelFontFamily,
      fontWeight: theme.axis.labelFontWeight
    });
    ticks.forEach((t) => {
      const y = yScale(t);
      tickEnd = isLeft ? dx + TICK_SIZE * 2 : dx - TICK_SIZE * 2;
      const textGraphic = new HGC.libraries.PIXI.Text(t, styleConfig);
      textGraphic.anchor.x = isLeft ? 0 : 1;
      textGraphic.anchor.y = y === 0 ? 0.9 : 0.5;
      textGraphic.position.x = tickEnd;
      textGraphic.position.y = dy + rowHeight - y;
      graphics.addChild(textGraphic);
    });
  });
}
function drawCircularYAxis(HGC, trackInfo, tile, model, theme) {
  var _a, _b, _c, _d, _e;
  const spec = model.spec();
  const CIRCULAR = spec.layout === "circular";
  const yDomain = model.getChannelDomainArray("y");
  const yRange = model.getChannelRangeArray("y");
  if (!CIRCULAR) {
    return;
  }
  if (!model.isShowYAxis() || !yDomain || !yRange) {
    return;
  }
  const [tw, th] = trackInfo.dimensions;
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const cx = tw / 2;
  const cy = th / 2;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = th / rowCategories.length;
  if (rowHeight / th * trackRingSize <= 20) {
    return;
  }
  const yChannel = model.spec().y;
  const isLeft = IsChannelDeep(yChannel) && "axis" in yChannel && yChannel.axis === "right" ? false : true;
  const yScale = scaleLinear().domain(yDomain).range(yRange);
  const graphics = tile.graphics;
  rowCategories.forEach((category) => {
    const rowPosition = model.encodedValue("row", category);
    const innerR = trackOuterRadius - (rowPosition + rowHeight) / th * trackRingSize;
    const outerR = trackOuterRadius - rowPosition / th * trackRingSize;
    const innerPos = cartesianToPolar(isLeft ? 0 : tw, tw, innerR, cx, cy, startAngle, endAngle);
    const outerPos = cartesianToPolar(isLeft ? 0 : tw, tw, outerR, cx, cy, startAngle, endAngle);
    graphics.lineStyle(1, colorToHex(theme.axis.baselineColor), 1, 0.5);
    graphics.moveTo(innerPos.x, innerPos.y);
    graphics.lineTo(outerPos.x, outerPos.y);
    const SCALED_TICK_SIZE = (r) => TICK_SIZE * tw / 2 / Math.PI / r;
    const SCALED_EXTENT_TICK_SIZE = (r) => EXTENT_TICK_SIZE * tw / 2 / Math.PI / r;
    const axisHeight = rowHeight / th * trackRingSize;
    const tickCount = Math.max(Math.ceil(axisHeight / 40), 1);
    let ticks = yScale.ticks(tickCount).filter((v) => yDomain[0] <= v && v <= yDomain[1]);
    if (ticks.length === 1) {
      ticks = yScale.ticks(tickCount + 1).filter((v) => yDomain[0] <= v && v <= yDomain[1]);
    }
    graphics.lineStyle(1, colorToHex(theme.axis.tickColor), 1, 0.5);
    ticks.forEach((t) => {
      const y = yScale(t);
      const currentR = trackOuterRadius - (rowPosition + rowHeight - y) / th * trackRingSize;
      const scaledStartX = isLeft ? 0 : tw - SCALED_TICK_SIZE(currentR);
      const scaledEndX = isLeft ? SCALED_TICK_SIZE(currentR) : tw;
      const pos = cartesianToPolar(scaledStartX, tw, currentR, cx, cy, startAngle, endAngle);
      const startRad = valueToRadian(scaledStartX, tw, startAngle, endAngle);
      const endRad = valueToRadian(scaledEndX, tw, startAngle, endAngle);
      graphics.moveTo(pos.x, pos.y);
      graphics.arc(cx, cy, currentR, startRad, endRad, true);
      graphics.arc(cx, cy, currentR, endRad, startRad, false);
      graphics.closePath();
    });
    {
      const scaledStartX = isLeft ? 0 : tw - SCALED_EXTENT_TICK_SIZE(trackInnerRadius);
      const scaledEndX = isLeft ? SCALED_EXTENT_TICK_SIZE(trackInnerRadius) : tw;
      const startRad = valueToRadian(scaledStartX, tw, startAngle, endAngle);
      const endRad = valueToRadian(scaledEndX, tw, startAngle, endAngle);
      graphics.moveTo(innerPos.x, innerPos.y);
      graphics.arc(cx, cy, trackInnerRadius, startRad, endRad, true);
      graphics.arc(cx, cy, trackInnerRadius, endRad, startRad, false);
      graphics.closePath();
    }
    {
      const scaledStartX = isLeft ? 0 : tw - SCALED_EXTENT_TICK_SIZE(trackOuterRadius);
      const scaledEndX = isLeft ? SCALED_EXTENT_TICK_SIZE(trackOuterRadius) : tw;
      const startRad = valueToRadian(scaledStartX, tw, startAngle, endAngle);
      const endRad = valueToRadian(scaledEndX, tw, startAngle, endAngle);
      graphics.moveTo(outerPos.x, outerPos.y);
      graphics.arc(cx, cy, trackOuterRadius, startRad, endRad, true);
      graphics.arc(cx, cy, trackOuterRadius, endRad, startRad, false);
      graphics.closePath();
    }
    ticks.forEach((t) => {
      const y = yScale(t);
      const currentR = trackOuterRadius - (rowPosition + rowHeight - y) / th * trackRingSize;
      const pos = cartesianToPolar(SCALED_TICK_SIZE(currentR) * 2, tw, currentR, cx, cy, startAngle, endAngle);
      const styleConfig = getTextStyle({
        color: theme.axis.labelColor,
        size: theme.axis.labelFontSize,
        fontFamily: theme.axis.labelFontFamily,
        fontWeight: theme.axis.labelFontWeight
      });
      const textGraphic = new HGC.libraries.PIXI.Text(t, styleConfig);
      textGraphic.anchor.x = isLeft ? 1 : 0;
      textGraphic.anchor.y = 0.5;
      textGraphic.position.x = pos.x;
      textGraphic.position.y = pos.y;
      textGraphic.resolution = 4;
      const txtStyle = new HGC.libraries.PIXI.TextStyle(styleConfig);
      const metric = HGC.libraries.PIXI.TextMetrics.measureText(textGraphic.text, txtStyle);
      const txtWidth = metric.width / (2 * currentR * Math.PI) * tw * 360 / (endAngle - startAngle);
      const scaledStartX = isLeft ? SCALED_TICK_SIZE(currentR) * 2 : tw - SCALED_TICK_SIZE(currentR) * 2 - txtWidth;
      const scaledEndX = isLeft ? SCALED_TICK_SIZE(currentR) * 2 + txtWidth : tw - SCALED_TICK_SIZE(currentR) * 2;
      const ropePoints = [];
      for (let i = scaledEndX; i >= scaledStartX; i -= txtWidth / 10) {
        const p = cartesianToPolar(i, tw, currentR, cx, cy, startAngle, endAngle);
        ropePoints.push(new HGC.libraries.PIXI.Point(p.x, p.y));
      }
      textGraphic.updateText();
      const rope = new HGC.libraries.PIXI.SimpleRope(textGraphic.texture, ropePoints);
      graphics.addChild(rope);
    });
  });
}
function drawCircularOutlines(HGC, trackInfo, tile, tm, theme) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
  const spec = tm.spec();
  const [l, t] = trackInfo.position;
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const cx = l + trackWidth / 2;
  const cy = t + trackHeight / 2;
  const posStartInner = cartesianToPolar(0, trackWidth, trackInnerRadius, cx, cy, startAngle, endAngle);
  const startRad = valueToRadian(0, trackWidth, startAngle, endAngle);
  const endRad = valueToRadian(trackWidth, trackWidth, startAngle, endAngle);
  const g = trackInfo.pBackground;
  if (!(spec.layout === "circular" && spec.mark === "withinLink")) {
    g.lineStyle(((_e = spec.style) == null ? void 0 : _e.outlineWidth) ? ((_f = spec.style) == null ? void 0 : _f.outlineWidth) / 2.5 : 0, colorToHex((_h = (_g = spec.style) == null ? void 0 : _g.outline) != null ? _h : "#DBDBDB"), 1, 1);
    g.beginFill(colorToHex((_j = (_i = tm.spec().style) == null ? void 0 : _i.background) != null ? _j : theme.track.background), (_l = (_k = tm.spec().style) == null ? void 0 : _k.backgroundOpacity) != null ? _l : !theme.track.background || theme.track.background === "transparent" ? 0 : 1);
    g.moveTo(posStartInner.x, posStartInner.y);
    g.arc(cx, cy, trackInnerRadius, startRad, endRad, true);
    g.arc(cx, cy, trackOuterRadius, endRad, startRad, false);
    g.closePath();
  }
  if (IsChannelDeep(spec.x) && spec.x.axis === "top") {
    g.lineStyle(0.5, colorToHex("black"), 0, 0.5);
    g.beginFill(colorToHex("white"), 0);
    g.moveTo(posStartInner.x, posStartInner.y);
    g.arc(cx, cy, trackOuterRadius - 0.5, startRad, endRad, true);
    g.arc(cx, cy, trackOuterRadius, endRad, startRad, false);
    g.closePath();
  }
  g.lineStyle(0.5, colorToHex("black"), 0, 0.5);
  g.beginFill(colorToHex("white"), 0);
  g.moveTo(cx, cy);
  g.arc(cx, cy, trackOuterRadius + 3, startRad, endRad, false);
  g.closePath();
  g.lineStyle(1, colorToHex("#DBDBDB"), 0, 0);
  g.beginFill(colorToHex("white"), 0);
  g.drawCircle(cx, cy, trackInnerRadius - 1);
}
function drawBackground(HGC, trackInfo, tile, tm, theme) {
  var _a, _b, _c, _d, _e, _f;
  const [l, t] = trackInfo.position;
  const [w, h] = trackInfo.dimensions;
  const g = trackInfo.pBackground;
  if (((_a = tm.spec().style) == null ? void 0 : _a.background) || theme.track.background && theme.track.background !== "transparent") {
    g.clear();
    const bg = (_c = (_b = tm.spec().style) == null ? void 0 : _b.background) != null ? _c : theme.track.background;
    const alpha = isUndefined((_d = tm.spec().style) == null ? void 0 : _d.backgroundOpacity) ? 1 : (_e = tm.spec().style) == null ? void 0 : _e.backgroundOpacity;
    g.lineStyle(1, colorToHex("white"), 0, 0);
    g.beginFill(colorToHex(bg), alpha);
    g.drawRect(l, t, w, h);
  }
  if (theme.track.alternatingBackground && theme.track.alternatingBackground !== "transparent") {
    const spec = tm.spec();
    if (!IsChannelDeep(spec.row) || spec.row.type !== "nominal") {
      return;
    }
    const rowCategories = (_f = tm.getChannelDomainArray("row")) != null ? _f : ["___SINGLE_ROW___"];
    if (rowCategories.length === 0) {
      return;
    }
    rowCategories.forEach((category, i) => {
      var _a2, _b2, _c2, _d2;
      if (i % 2 === 0) {
        return;
      }
      const rowPosition = tm.encodedValue("row", category);
      const bg = (_b2 = (_a2 = tm.spec().style) == null ? void 0 : _a2.background) != null ? _b2 : theme.track.alternatingBackground;
      const alpha = isUndefined((_c2 = tm.spec().style) == null ? void 0 : _c2.backgroundOpacity) ? 1 : (_d2 = tm.spec().style) == null ? void 0 : _d2.backgroundOpacity;
      g.lineStyle(1, colorToHex("white"), 0, 0);
      g.beginFill(colorToHex(bg), alpha);
      g.drawRect(trackInfo.position[0], trackInfo.position[1] + rowPosition, w, h / rowCategories.length);
    });
  }
}
function drawBetweenLink(g, trackInfo, model) {
  var _a, _b, _c, _d, _e;
  const spec = model.spec();
  if (!spec.width || !spec.height) {
    console.warn("Size of a track is not properly determined, so visual mark cannot be rendered");
    return;
  }
  const data2 = model.data();
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  const circular = spec.layout === "circular";
  const trackInnerRadius = (_a = spec.innerRadius) != null ? _a : 220;
  const trackOuterRadius = (_b = spec.outerRadius) != null ? _b : 300;
  const startAngle = (_c = spec.startAngle) != null ? _c : 0;
  const endAngle = (_d = spec.endAngle) != null ? _d : 360;
  const trackRingSize = trackOuterRadius - trackInnerRadius;
  const tcx = trackWidth / 2;
  const tcy = trackHeight / 2;
  const rowCategories = (_e = model.getChannelDomainArray("row")) != null ? _e : ["___SINGLE_ROW___"];
  const rowHeight = trackHeight / rowCategories.length;
  rowCategories.forEach((rowCategory) => {
    const rowPosition = model.encodedValue("row", rowCategory);
    data2.filter((d) => !getValueUsingChannel(d, spec.row) || getValueUsingChannel(d, spec.row) === rowCategory).forEach((d) => {
      var _a2, _b2;
      let x = model.encodedPIXIProperty("x", d);
      let xe = model.encodedPIXIProperty("xe", d);
      let x1 = model.encodedPIXIProperty("x1", d);
      let x1e = model.encodedPIXIProperty("x1e", d);
      const y = model.encodedPIXIProperty("y", d);
      const stroke = model.encodedPIXIProperty("stroke", d);
      const strokeWidth = model.encodedPIXIProperty("strokeWidth", d);
      const color2 = model.encodedPIXIProperty("color", d);
      const opacity = model.encodedPIXIProperty("opacity", d);
      if (typeof xe !== "undefined") {
        [x, xe] = [x, xe].sort((a, b) => a - b);
      }
      if (typeof x1 !== "undefined" && typeof x1e !== "undefined") {
        [x1, x1e] = [x1, x1e].sort((a, b) => a - b);
      }
      const isRibon = typeof xe !== "undefined" && typeof x1 !== "undefined" && typeof x1e !== "undefined" && Math.abs(x - xe) > 0.1 && Math.abs(x1 - x1e) > 0.1;
      if (!isRibon && xe === void 0 && !Is2DTrack(spec)) {
        if (x1 === void 0 && x1e === void 0) {
          return;
        }
        xe = x1 !== void 0 ? x1 : x1e;
      }
      if (!isRibon && Math.abs(x - xe) <= 0.1 && Math.abs(x1 - x1e) <= 0.1) {
        x = (x + xe) / 2;
        xe = (x1 + x1e) / 2;
      }
      g.lineStyle(strokeWidth, colorToHex(stroke), opacity, 0.5);
      if (isRibon) {
        g.beginFill(color2 === "none" ? colorToHex("white") : colorToHex(color2), color2 === "none" ? 0 : opacity);
        let [_x1, _x2, _x3, _x4] = [x, xe, x1, x1e];
        [_x1, _x2] = [_x1, _x2].sort((a, b) => a - b);
        [_x3, _x4] = [_x3, _x4].sort((a, b) => a - b);
        if (_x1 > trackWidth || _x4 < 0 || Math.abs(_x4 - _x1) < 0.5) {
          return;
        }
        if (circular) {
          if (_x1 < 0 || _x4 > trackWidth) {
            return;
          }
          const r = trackOuterRadius - rowPosition / trackHeight * trackRingSize;
          const posX = cartesianToPolar(_x1, trackWidth, r, tcx, tcy, startAngle, endAngle);
          const posXE = cartesianToPolar(_x2, trackWidth, r, tcx, tcy, startAngle, endAngle);
          const posX1 = cartesianToPolar(_x3, trackWidth, r, tcx, tcy, startAngle, endAngle);
          const posX1E = cartesianToPolar(_x4, trackWidth, r, tcx, tcy, startAngle, endAngle);
          g.moveTo(posX.x, posX.y);
          g.bezierCurveTo(tcx, tcy, tcx, tcy, posX1E.x, posX1E.y);
          g.arc(tcx, tcy, trackOuterRadius, positionToRadian(posX1E.x, posX1E.y, tcx, tcy), positionToRadian(posX1.x, posX1.y, tcx, tcy), false);
          g.bezierCurveTo(tcx, tcy, tcx, tcy, posXE.x, posXE.y);
          g.arc(tcx, tcy, trackOuterRadius, positionToRadian(posXE.x, posXE.y, tcx, tcy), positionToRadian(posX.x, posX.y, tcx, tcy), false);
          g.endFill();
        } else {
          g.moveTo(_x1, rowPosition);
          g.lineTo(_x2, rowPosition);
          g.lineTo(_x4, rowPosition + rowHeight);
          g.lineTo(_x3, rowPosition + rowHeight);
          g.lineTo(_x1, rowPosition);
          g.closePath();
        }
      } else {
        if (Is2DTrack(spec)) {
          if (((_a2 = spec.style) == null ? void 0 : _a2.linkConnectionType) === "curve") {
            g.moveTo(x, 0);
            g.bezierCurveTo(x / 5 * 4, (rowPosition + rowHeight - y) / 2, x / 2, (rowPosition + rowHeight - y) / 5 * 4, 0, rowPosition + rowHeight - y);
          } else if (((_b2 = spec.style) == null ? void 0 : _b2.linkConnectionType) === "straight") {
            g.moveTo(x, 0);
            g.lineTo(0, rowPosition + rowHeight - y);
          } else {
            g.moveTo(x, 0);
            g.lineTo(x, rowPosition + rowHeight - y);
            g.lineTo(0, rowPosition + rowHeight - y);
          }
          return;
        }
        if (circular) {
          let prevX, prevY;
          for (let t = 0; t <= 1; t += 0.02) {
            const logodds = (t2) => Math.log(t2 / (1 - t2));
            const movingRadius = (t2) => trackOuterRadius - 1 / (1 + Math.exp(logodds(t2))) * trackRingSize + 3;
            const getRadian = (t2, s, e) => ((e - s) * t2 + s) / trackWidth;
            const _x = tcx + movingRadius(t) * Math.cos(-getRadian(t, x, xe) * 2 * Math.PI - Math.PI / 2);
            const _y = tcy + movingRadius(t) * Math.sin(-getRadian(t, x, xe) * 2 * Math.PI - Math.PI / 2);
            if (prevX && prevY) {
              g.lineStyle(strokeWidth, colorToHex(stroke), opacity, 0.5);
              g.moveTo(prevX, prevY);
              g.lineTo(_x, _y);
            }
            prevX = _x;
            prevY = _y;
          }
          return;
        }
        g.moveTo(xe, rowPosition + rowHeight);
        g.lineTo(x, rowPosition);
      }
    });
  });
}
const SUPPORTED_CHANNELS = [
  "x",
  "xe",
  "x1",
  "x1e",
  "y",
  "ye",
  "y1",
  "y1e",
  "color",
  "size",
  "row",
  "stroke",
  "strokeWidth",
  "opacity",
  "text"
];
function drawMark(HGC, trackInfo, tile, model) {
  if (!HGC || !trackInfo || !tile) {
    return;
  }
  if (model.spec().mark === "brush") {
    return;
  }
  ["x", "x1", "x1e", "xe"].forEach((d) => {
    model.setChannelScale(d, trackInfo._xScale);
  });
  if (Is2DTrack(model.spec()) || IsVerticalRule(model.spec())) {
    const yScale = trackInfo._yScale.copy();
    yScale.range([yScale.range()[1], yScale.range()[0]]);
    ["y", "y1", "y1e", "ye"].forEach((d) => {
      model.setChannelScale(d, yScale);
    });
  }
  const [trackWidth, trackHeight] = trackInfo.dimensions;
  switch (model.spec().mark) {
    case "point":
      drawPoint(trackInfo, tile.graphics, model);
      break;
    case "bar":
      drawBar(trackInfo, tile, model);
      break;
    case "line":
      drawLine(tile.graphics, model, trackWidth, trackHeight);
      break;
    case "area":
      drawArea(HGC, trackInfo, tile, model);
      break;
    case "rect":
      drawRect(HGC, trackInfo, tile, model);
      break;
    case "triangleLeft":
    case "triangleRight":
    case "triangleBottom":
      drawTriangle(tile.graphics, model, trackWidth, trackHeight);
      break;
    case "text":
      drawText(HGC, trackInfo, tile, model);
      break;
    case "rule":
      drawRule(HGC, trackInfo, tile, model);
      break;
    case "betweenLink":
      drawBetweenLink(tile.graphics, trackInfo, model);
      break;
    case "withinLink":
      drawWithinLink(tile.graphics, trackInfo, model);
      break;
    default:
      console.warn("Unsupported mark type");
      break;
  }
}
function drawPreEmbellishment(HGC, trackInfo, tile, model, theme) {
  if (!HGC || !trackInfo || !tile) {
    return;
  }
  if (model.spec().mark === "brush") {
    return;
  }
  trackInfo.pBackground.clear();
  trackInfo.pBackground.removeChildren();
  trackInfo.pBorder.clear();
  trackInfo.pBorder.removeChildren();
  const CIRCULAR = model.spec().layout === "circular";
  ["x", "x1", "x1e", "xe"].forEach((d) => {
    model.setChannelScale(d, trackInfo._xScale);
  });
  if (CIRCULAR) {
    drawCircularOutlines(HGC, trackInfo, tile, model, theme);
  } else {
    drawBackground(HGC, trackInfo, tile, model, theme);
    drawChartOutlines(HGC, trackInfo, model, theme);
  }
  drawGrid(trackInfo, model, theme);
}
function drawPostEmbellishment(HGC, trackInfo, tile, model, theme) {
  if (!HGC || !trackInfo || !tile) {
    return;
  }
  if (model.spec().mark === "brush") {
    return;
  }
  const CIRCULAR = model.spec().layout === "circular";
  ["x", "x1", "x1e", "xe"].forEach((d) => {
    model.setChannelScale(d, trackInfo._xScale);
  });
  if (CIRCULAR) {
    drawCircularYAxis(HGC, trackInfo, tile, model, theme);
    drawCircularTitle(HGC, trackInfo, tile, model, theme);
  } else {
    drawLinearYAxis(HGC, trackInfo, tile, model, theme);
    drawRowLegend(HGC, trackInfo, tile, model, theme);
  }
  drawColorLegend(HGC, trackInfo, tile, model, theme);
}
function resolveSuperposedTracks(track) {
  if (IsDataTrack(track)) {
    return [];
  }
  if (!IsOverlaidTrack(track)) {
    return [track];
  }
  if (track.overlay.length === 0) {
    return [{ ...track, superpose: void 0 }];
  }
  const base = JSON.parse(JSON.stringify(track));
  delete base.overlay;
  const resolved = [];
  track.overlay.forEach((subSpec, i) => {
    const spec = Object.assign(JSON.parse(JSON.stringify(base)), subSpec);
    if (spec.title && i !== 0) {
      delete spec.title;
    }
    resolved.push(spec);
  });
  let xAxisPosition = void 0;
  resolved.forEach((d) => {
    if (IsChannelDeep(d.x) && d.x.axis && !xAxisPosition) {
      xAxisPosition = d.x.axis;
    }
  });
  const corrected = resolved.map((d) => {
    return {
      ...d,
      x: { ...d.x, axis: xAxisPosition }
    };
  });
  return corrected;
}
function spreadTracksByData(tracks) {
  return [].concat(...tracks.map((t) => {
    if (IsDataTrack(t) || !IsOverlaidTrack(t) || t.overlay.length <= 1) {
      return [t];
    }
    if (t.overlay.filter((s) => s.data).length === 0) {
      return [t];
    }
    if (isIdenticalDataSpec([t.data, ...t.overlay.map((s) => s.data)])) {
      return [t];
    }
    const base = JSON.parse(JSON.stringify(t));
    delete base.overlay;
    const spread = [];
    const original = JSON.parse(JSON.stringify(base));
    original.overlay = [];
    t.overlay.forEach((subSpec) => {
      if (!original.data) {
        original.data = subSpec.data;
      }
      if (!subSpec.data || isIdenticalDataSpec([original.data, subSpec.data])) {
        original.overlay.push(subSpec);
        return;
      }
      const spec = Object.assign(JSON.parse(JSON.stringify(base)), subSpec);
      spread.push(spec);
    });
    const output = original.overlay.length > 0 ? [original, ...spread] : spread;
    return output.map((track, i, arr) => {
      const overlayOnPreviousTrack = i !== 0;
      const y = IsSingleTrack(track) && IsChannelDeep(track.y) && !track.y.axis && overlayOnPreviousTrack ? { ...track.y, axis: i === 1 ? "right" : "none" } : IsSingleTrack(track) ? track.y : void 0;
      if (track.title && i !== arr.length - 1 && arr.length !== 1) {
        delete track.title;
      }
      return { ...track, overlayOnPreviousTrack, y };
    });
  }));
}
function isIdenticalDataSpec(specs) {
  if (specs.length === 0) {
    return false;
  }
  const definedSpecs = specs.filter((d) => d);
  if (definedSpecs.length !== specs.length) {
    return false;
  }
  const keys = Object.keys(definedSpecs[0]).sort();
  let isIdentical = true;
  keys.forEach((k) => {
    const uniqueProperties = Array.from(new Set(definedSpecs.map((d) => JSON.stringify(d[k]))));
    if (uniqueProperties.length !== 1) {
      isIdentical = false;
      return;
    }
  });
  return isIdentical;
}
const PREDEFINED_COLOR_STR_MAP = {
  viridis: interpolateViridis,
  grey: interpolateGreys,
  warm: interpolateWarm,
  spectral: interpolateSpectral,
  cividis: interpolateCividis,
  bupu: interpolateBuPu,
  rdbu: interpolateRdBu,
  hot: interpolateYlOrBr,
  pink: interpolateRdPu
};
function isObject$1(x) {
  return typeof x === "object" && x !== null;
}
function isTabularDataFetcher(dataFetcher) {
  return isObject$1(dataFetcher) && "getTabularData" in dataFetcher;
}
function hasDataTransform(spec, type2) {
  var _a;
  return ((_a = spec.dataTransform) != null ? _a : []).some((d) => d.type === type2);
}
function getHiGlassColorRange(colorStr = "viridis", step = 100) {
  var _a;
  const interpolate = (_a = PREDEFINED_COLOR_STR_MAP[colorStr]) != null ? _a : PREDEFINED_COLOR_STR_MAP["viridis"];
  return [...Array(step)].map((_, i) => interpolate(1 / step * i));
}
function IsFlatTracks(_) {
  return !("alignment" in _) && !_.tracks.find((d) => d.alignment === "overlay" || "tracks" in d);
}
function IsOverlaidTracks(_) {
  return "alignment" in _ && _.alignment === "overlay";
}
function IsStackedTracks(_) {
  return !IsFlatTracks(_) && !IsOverlaidTracks(_);
}
function IsDataTrack(_) {
  return !IsOverlaidTrack(_) && "data" in _ && !("mark" in _);
}
function IsDataTemplate(_) {
  return !!("data" in _ && "overrideTemplate" in _ && _.overrideTemplate);
}
function IsDataDeep(data2) {
  return typeof data2 === "object";
}
function IsDomainChr(domain) {
  return "chromosome" in domain && !("interval" in domain);
}
function IsDomainInterval(domain) {
  return !("chromosome" in domain) && "interval" in domain;
}
function IsDomainChrInterval(domain) {
  return "chromosome" in domain && "interval" in domain;
}
function IsSingleTrack(track) {
  return !("overlay" in track);
}
function IsOverlaidTrack(track) {
  return "overlay" in track;
}
function IsTemplateTrack(track) {
  return "template" in track;
}
function IsVerticalRule(track) {
  return IsSingleTrack(track) && !IsChannelDeep(track.x) && IsChannelDeep(track.y) && track.y.type === "genomic";
}
function Is2DTrack(track) {
  const t = IsSingleTrack(track) ? track : resolveSuperposedTracks(track)[0];
  return IsChannelDeep(t.x) && t.x.type === "genomic" && IsChannelDeep(t.y) && t.y.type === "genomic";
}
function IsHiGlassMatrix(track) {
  return Is2DTrack(track) && track.data.type === "matrix" && (track.mark === "bar" || track.mark === "rect") && track.xe && track.ye;
}
function IsChannelValue(channel) {
  return channel !== null && typeof channel === "object" && "value" in channel;
}
function IsDataDeepTileset(_) {
  return _ !== void 0 && (_.type === "vector" || _.type === "beddb" || _.type === "multivec" || _.type === "bigwig" || _.type === "matrix" || _.type === "bam" || _.type === "vcf");
}
function IsChannelDeep(channel) {
  return typeof channel === "object" && !("value" in channel);
}
function IsOneOfFilter(_) {
  return "oneOf" in _;
}
function IsRangeFilter(_) {
  return "inRange" in _;
}
function IsIncludeFilter(_) {
  return "include" in _;
}
function IsDomainArray(domain) {
  return isArray$1(domain);
}
function IsRangeArray(range2) {
  return isArray$1(range2);
}
function IsStackedMark(track) {
  return (track.mark === "bar" || track.mark === "area" || track.mark === "text") && IsChannelDeep(track.color) && track.color.type === "nominal" && (!track.row || IsChannelValue(track.row)) && IsChannelDeep(track.y) && track.y.type === "quantitative" && !IsChannelDeep(track.ye);
}
function IsStackedChannel(track, channelKey) {
  const channel = track[channelKey];
  return IsStackedMark(track) && (channelKey === "x" || channelKey === "y") && IsChannelDeep(channel) && channel.type === "quantitative";
}
function getValueUsingChannel(datum, channel) {
  if (IsChannelDeep(channel) && channel.field) {
    return datum[channel == null ? void 0 : channel.field];
  }
  return void 0;
}
function getChannelKeysByAggregateFnc(spec) {
  const keys = [];
  SUPPORTED_CHANNELS.forEach((k) => {
    const c = spec[k];
    if (IsChannelDeep(c) && "aggregate" in c) {
      keys.push(k);
    }
  });
  return keys;
}
function getChannelKeysByType(spec, t) {
  const keys = [];
  SUPPORTED_CHANNELS.forEach((k) => {
    const c = spec[k];
    if (IsChannelDeep(c) && c.type === t) {
      keys.push(k);
    }
  });
  return keys;
}
function IsXAxis(_) {
  if ((IsSingleTrack(_) || IsOverlaidTrack(_)) && IsChannelDeep(_.x) && _.x.axis && _.x.axis !== "none") {
    return true;
  } else if (IsOverlaidTrack(_)) {
    let isFound = false;
    _.overlay.forEach((t) => {
      if (isFound)
        return;
      if (IsChannelDeep(t.x) && t.x.axis && t.x.axis !== "none") {
        isFound = true;
      }
    });
    return isFound;
  }
  return false;
}
function IsYAxis(_) {
  if ((IsSingleTrack(_) || IsOverlaidTrack(_)) && IsChannelDeep(_.y) && _.y.axis && _.y.axis !== "none") {
    return true;
  } else if (IsOverlaidTrack(_)) {
    let isFound = false;
    _.overlay.forEach((t) => {
      if (isFound)
        return;
      if (IsChannelDeep(t.y) && t.y.axis && t.y.axis !== "none") {
        isFound = true;
      }
    });
    return isFound;
  }
  return false;
}
function IsMouseEventsDeep(_) {
  return typeof _ === "object";
}
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate$2(uuid) {
  return typeof uuid === "string" && REGEX.test(uuid);
}
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).substr(1));
}
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate$2(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var _nodeId;
var _clockseq;
var _lastMSecs = 0;
var _lastNSecs = 0;
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || stringify(b);
}
function parse(uuid) {
  if (!validate$2(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v;
  var arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL$2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name2, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return stringify(bytes);
  }
  try {
    generateUUID.name = name2;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL$2;
  return generateUUID;
}
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 255;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x, y) {
  var lsw = (x & 65535) + (y & 65535);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
v35("v3", 48, md5);
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify(rnds);
}
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  var K = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);
  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);
    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }
    M[_i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);
    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }
    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
v35("v5", 80, sha1);
function getStyleOverridden(parent, child) {
  const base = parent ? JSON.parse(JSON.stringify(parent)) : {};
  return child ? Object.assign(base, child) : base;
}
function traverseTracks(spec, callback) {
  if ("tracks" in spec) {
    spec.tracks.forEach((t, i, ts) => {
      callback(t, i, ts);
      traverseTracks(t, callback);
    });
  } else if ("views" in spec) {
    spec.views.forEach((view) => traverseTracks(view, callback));
  }
}
function traverseTracksAndViews(spec, callback) {
  if ("tracks" in spec) {
    spec.tracks.forEach((t) => {
      callback(t);
      traverseTracksAndViews(t, callback);
    });
  } else if ("views" in spec) {
    spec.views.forEach((v) => {
      callback(v);
      traverseTracksAndViews(v, callback);
    });
  }
}
function traverseViewArrangements(spec, callback) {
  if ("tracks" in spec)
    ;
  else {
    callback(spec);
    spec.views.forEach((v) => {
      traverseViewArrangements(v, callback);
    });
  }
}
function convertToFlatTracks(spec) {
  if (IsFlatTracks(spec)) {
    const base = JSON.parse(JSON.stringify(spec));
    delete base.tracks;
    return spec.tracks.filter((track) => !track._invalidTrack).map((track) => Object.assign(JSON.parse(JSON.stringify(base)), track));
  }
  const newTracks = [];
  if (IsStackedTracks(spec)) {
    spec.tracks.filter((track) => !track._invalidTrack).map((track) => {
      if ("alignment" in track) {
        newTracks.push({
          ...track,
          overlay: [...track.tracks],
          tracks: void 0,
          alignment: void 0
        });
      } else {
        const base = JSON.parse(JSON.stringify(spec));
        delete base.tracks;
        const newSpec = Object.assign(JSON.parse(JSON.stringify(base)), track);
        newTracks.push(newSpec);
      }
    });
  } else {
    newTracks.push({
      ...spec,
      overlay: [...spec.tracks.filter((track) => !track._invalidTrack)],
      tracks: void 0,
      alignment: void 0
    });
  }
  return JSON.parse(JSON.stringify(newTracks));
}
function traverseToFixSpecDownstream(spec, parentDef) {
  if (parentDef) {
    if (spec.assembly === void 0)
      spec.assembly = parentDef.assembly;
    if (spec.layout === void 0)
      spec.layout = parentDef.layout;
    if (spec.orientation === void 0)
      spec.orientation = parentDef.orientation;
    if (spec.static === void 0)
      spec.static = parentDef.static !== void 0 ? parentDef.static : false;
    if (spec.zoomLimits === void 0)
      spec.zoomLimits = parentDef.zoomLimits;
    if (spec.xDomain === void 0)
      spec.xDomain = parentDef.xDomain;
    if (spec.yDomain === void 0)
      spec.yDomain = parentDef.yDomain;
    if (spec.linkingId === void 0)
      spec.linkingId = parentDef.linkingId;
    if (spec.centerRadius === void 0)
      spec.centerRadius = parentDef.centerRadius;
    if (spec.spacing === void 0 && !("tracks" in spec))
      spec.spacing = parentDef.spacing;
    if (spec.xOffset === void 0)
      spec.xOffset = parentDef.xOffset;
    if (spec.yOffset === void 0)
      spec.yOffset = parentDef.yOffset;
    if ("views" in spec && "arrangement" in parentDef && spec.arrangement === void 0)
      spec.arrangement = parentDef.arrangement;
    spec.style = getStyleOverridden(parentDef.style, spec.style);
  } else {
    if (spec.assembly === void 0)
      spec.assembly = "hg38";
    if (spec.layout === void 0)
      spec.layout = "linear";
    if (spec.orientation === void 0)
      spec.orientation = "horizontal";
    if (spec.static === void 0)
      spec.static = false;
    if (spec.zoomLimits === void 0)
      spec.zoomLimits = [1, null];
    if (spec.centerRadius === void 0)
      spec.centerRadius = DEFAULT_INNER_RADIUS_PROP;
    if (spec.spacing === void 0)
      spec.spacing = DEFAULT_VIEW_SPACING;
    if ("views" in spec && spec.arrangement === void 0)
      spec.arrangement = "vertical";
    if (spec.xOffset === void 0)
      spec.xOffset = 0;
    if (spec.yOffset === void 0)
      spec.yOffset = 0;
  }
  if ("tracks" in spec) {
    let tracks = convertToFlatTracks(spec);
    tracks = spreadTracksByData(tracks);
    const linkID = v4();
    tracks.forEach((track, i, array) => {
      var _a, _b, _c;
      if (!track.width) {
        track.width = Is2DTrack(track) ? DEFAULT_TRACK_SIZE_2D : DEFAULT_TRACK_WIDTH_LINEAR;
      }
      if (!track.height) {
        track.height = Is2DTrack(track) ? DEFAULT_TRACK_SIZE_2D : DEFAULT_TRACK_HEIGHT_LINEAR;
      }
      if ("displacement" in track) {
        if (((_a = track.displacement) == null ? void 0 : _a.type) === "pile" && track.row === void 0 && IsChannelDeep(track.x) && track.x.field && IsChannelDeep(track.xe) && track.xe.field) {
          const newField = v4();
          const startField = track.x.field;
          const endField = track.xe.field;
          const padding = track.displacement.padding;
          const displaceTransform = {
            type: "displace",
            newField,
            boundingBox: { startField, endField, padding },
            method: "pile"
          };
          if (!track.dataTransform) {
            track.dataTransform = [];
          }
          track.dataTransform = [...track.dataTransform, displaceTransform];
          track.row = { field: newField, type: "nominal" };
        } else if (((_b = track.displacement) == null ? void 0 : _b.type) === "spread")
          ;
      }
      if (track.layout)
        track.layout = void 0;
      if (track.zoomLimits)
        track.zoomLimits = void 0;
      if (!track.assembly)
        track.assembly = spec.assembly;
      if (!track.layout)
        track.layout = spec.layout;
      if (!track.orientation)
        track.orientation = spec.orientation;
      if (track.static === void 0)
        track.static = spec.static !== void 0 ? spec.static : false;
      if (!track.zoomLimits)
        track.zoomLimits = spec.zoomLimits;
      track.style = getStyleOverridden(spec.style, track.style);
      if (IsOverlaidTrack(track)) {
        track.overlay.forEach((o) => {
          o.style = getStyleOverridden(track.style, o.style);
        });
      }
      if ((track.layout === "circular" || Is2DTrack(track)) && track.orientation === "vertical") {
        track.orientation = "horizontal";
      }
      if (Is2DTrack(track)) {
        track.layout = "linear";
        if ((IsSingleTrack(track) || IsOverlaidTrack(track)) && IsChannelDeep(track.y) && !track.y.domain) {
          track.y.domain = spec.yDomain;
        } else if (IsOverlaidTrack(track)) {
          track.overlay.forEach((o) => {
            if (IsChannelDeep(o.y) && !o.y.domain) {
              o.y.domain = spec.yDomain;
            }
          });
        }
      }
      if ((IsSingleTrack(track) || IsOverlaidTrack(track)) && IsChannelDeep(track.x) && !track.x.domain) {
        track.x.domain = spec.xDomain;
      } else if (IsOverlaidTrack(track)) {
        track.overlay.forEach((o) => {
          if (IsChannelDeep(o.x) && !o.x.domain) {
            o.x.domain = spec.xDomain;
          }
        });
      }
      if ((IsSingleTrack(track) || IsOverlaidTrack(track)) && IsChannelDeep(track.x) && !track.x.linkingId) {
        track.x.linkingId = (_c = spec.linkingId) != null ? _c : linkID;
      } else if (IsOverlaidTrack(track)) {
        let isAdded = false;
        track.overlay.forEach((o) => {
          var _a2;
          if (isAdded)
            return;
          if (IsChannelDeep(o.x) && !o.x.linkingId) {
            o.x.linkingId = (_a2 = spec.linkingId) != null ? _a2 : linkID;
            isAdded = true;
          }
        });
      }
      if (i === 0) {
        track.overlayOnPreviousTrack = false;
      }
      if (i === 0 || i !== 0 && tracks.slice(0, i).filter((d) => !d.overlayOnPreviousTrack).length === 1 && track.overlayOnPreviousTrack === true) {
        if ((IsSingleTrack(track) || IsOverlaidTrack(track)) && IsChannelDeep(track.x) && !track.x.axis) {
          if (track.orientation === "vertical") {
            track.x.axis = "left";
          } else {
            track.x.axis = "top";
          }
        } else if (IsOverlaidTrack(track)) {
          track.overlay.forEach((o) => {
            if (IsChannelDeep(o.x) && !o.x.axis) {
              if (track.orientation === "vertical") {
                o.x.axis = "left";
              } else {
                o.x.axis = "top";
              }
            }
          });
        }
      }
      if ((IsSingleTrack(track) || IsOverlaidTrack(track)) && IsChannelDeep(track.x) && track.x.axis && track.x.axis !== "none") {
        if (track.orientation === "vertical") {
          if (track.x.axis === "top") {
            track.x.axis = "left";
          } else if (track.x.axis === "bottom") {
            track.x.axis = "right";
          }
        } else {
          if (track.x.axis === "left") {
            track.x.axis = "top";
          } else if (track.x.axis === "right") {
            track.x.axis = "bottom";
          }
        }
      } else if (IsOverlaidTrack(track)) {
        track.overlay.forEach((o) => {
          if (IsChannelDeep(o.x) && o.x.axis && o.x.axis !== "none") {
            if (track.orientation === "vertical") {
              if (o.x.axis === "top") {
                o.x.axis = "left";
              } else if (o.x.axis === "bottom") {
                o.x.axis = "right";
              }
            } else {
              if (o.x.axis === "left") {
                o.x.axis = "top";
              } else if (o.x.axis === "right") {
                o.x.axis = "bottom";
              }
            }
          }
        });
      }
      if (i !== 0 && (i === array.length - 1 && array.slice(0, i + 1).filter((d) => d.overlayOnPreviousTrack).length < i || i !== array.length - 1 && array.slice(i + 1).filter((d) => d.overlayOnPreviousTrack).length === array.length - i - 1 && array.slice(0, i + 1).filter((d) => d.overlayOnPreviousTrack).length < i)) {
        if (IsSingleTrack(track) && track.mark === "withinLink" && track.flipY === void 0) {
          track.flipY = true;
        } else if (IsOverlaidTrack(track)) {
          if (track.mark === "withinLink" && track.flipY === void 0) {
            track.flipY = true;
          }
          track.overlay.forEach((o) => {
            if (o.mark === "withinLink" && o.flipY === void 0) {
              o.flipY = true;
            }
          });
        }
      }
      if (track.overlayOnPreviousTrack && array[i - 1]) {
        track.width = array[i - 1].width;
        track.height = array[i - 1].height;
        track.layout = array[i - 1].layout;
        track.assembly = array[i - 1].assembly;
      }
    });
    spec.tracks = tracks;
  } else {
    spec.views.forEach((v) => {
      traverseToFixSpecDownstream(v, spec);
    });
  }
}
function getVectorTemplate(column, value) {
  return {
    data: {
      type: "vector",
      url: "",
      column,
      value
    },
    mark: "bar",
    x: { field: column, type: "genomic", axis: "top" },
    y: { field: value, type: "quantitative" },
    width: 400,
    height: 100
  };
}
function getMultivecTemplate(row, column, value, categories) {
  return categories && categories.length < 10 ? {
    data: {
      type: "multivec",
      url: "",
      row,
      column,
      value,
      categories
    },
    mark: "bar",
    x: { field: column, type: "genomic", axis: "top" },
    y: { field: value, type: "quantitative" },
    row: { field: row, type: "nominal", legend: true },
    color: { field: row, type: "nominal" },
    width: 400,
    height: 100
  } : {
    data: {
      type: "multivec",
      url: "",
      row,
      column,
      value,
      categories
    },
    mark: "rect",
    x: { field: column, type: "genomic", axis: "top" },
    row: { field: row, type: "nominal", legend: true },
    color: { field: value, type: "quantitative" },
    width: 400,
    height: 100
  };
}
function overrideDataTemplates(spec) {
  traverseTracks(spec, (t, i, ts) => {
    var _a, _b, _c, _d, _e;
    if (!t.data || !IsDataDeepTileset(t.data)) {
      return;
    }
    if ("alignment" in t) {
      return;
    }
    if (!IsDataTemplate(t)) {
      return;
    }
    switch (t.data.type) {
      case "vector":
      case "bigwig":
        ts[i] = Object.assign(getVectorTemplate((_a = t.data.column) != null ? _a : "position", (_b = t.data.value) != null ? _b : "value"), t);
        break;
      case "multivec":
        ts[i] = Object.assign(getMultivecTemplate((_c = t.data.row) != null ? _c : "category", (_d = t.data.column) != null ? _d : "position", (_e = t.data.value) != null ? _e : "value", t.data.categories), t);
        break;
    }
  });
}
const GoslingTemplates = [
  {
    name: "gene",
    channels: [
      { name: "startPosition", type: "genomic", required: true },
      { name: "endPosition", type: "genomic", required: true },
      { name: "strandColor", type: "nominal", required: true },
      { name: "strandRow", type: "nominal", required: true },
      { name: "opacity", type: "value", required: false },
      { name: "geneHeight", type: "value", required: false },
      { name: "geneLabel", type: "nominal", required: true },
      { name: "geneLabelColor", type: "nominal", required: true },
      { name: "geneLabelFontSize", type: "value", required: false },
      { name: "geneLabelStroke", type: "value", required: false },
      { name: "geneLabelStrokeThickness", type: "value", required: false },
      { name: "geneLabelOpacity", type: "value", required: false },
      { name: "type", type: "nominal", required: true }
    ],
    mapping: [
      {
        dataTransform: [
          { type: "filter", base: "type", oneOf: ["gene"] },
          { type: "filter", base: "strandColor", oneOf: ["-"] }
        ],
        mark: "triangleLeft",
        x: { base: "startPosition", type: "genomic" },
        size: { base: "geneHeight", value: 12 },
        row: { base: "strandRow", type: "nominal", domain: ["+", "-"] },
        color: { base: "strandColor", type: "nominal", domain: ["+", "-"], range: ["blue", "red"] },
        opacity: { base: "opacity", value: 0.4 },
        style: { align: "right" }
      },
      {
        dataTransform: [
          { type: "filter", base: "type", oneOf: ["gene"] },
          { type: "filter", base: "strandColor", oneOf: ["+"] }
        ],
        mark: "triangleRight",
        x: { base: "endPosition", type: "genomic" },
        size: { base: "geneHeight", value: 12 },
        row: { base: "strandRow", type: "nominal", domain: ["+", "-"] },
        color: { base: "strandColor", type: "nominal", domain: ["+", "-"], range: ["blue", "red"] },
        opacity: { base: "opacity", value: 0.4 },
        style: { align: "left" }
      },
      {
        dataTransform: [{ type: "filter", base: "type", oneOf: ["exon"] }],
        mark: "rect",
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        size: { base: "geneHeight", value: 12 },
        row: { base: "strandRow", type: "nominal", domain: ["+", "-"] },
        color: { base: "strandColor", type: "nominal", domain: ["+", "-"], range: ["blue", "red"] },
        opacity: { base: "opacity", value: 0.4 }
      },
      {
        dataTransform: [
          { type: "filter", base: "type", oneOf: ["gene"] },
          { type: "filter", base: "strandColor", oneOf: ["+"] }
        ],
        mark: "rect",
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        row: { base: "strandRow", type: "nominal", domain: ["+", "-"] },
        color: { base: "strandColor", type: "nominal", domain: ["+", "-"], range: ["blue", "red"] },
        opacity: { base: "opacity", value: 0.4 },
        size: { value: 3 }
      },
      {
        dataTransform: [
          { type: "filter", base: "type", oneOf: ["gene"] },
          { type: "filter", base: "strandColor", oneOf: ["-"] }
        ],
        mark: "rect",
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        row: { base: "strandRow", type: "nominal", domain: ["+", "-"] },
        color: { base: "strandColor", type: "nominal", domain: ["+", "-"], range: ["blue", "red"] },
        opacity: { base: "opacity", value: 0.4 },
        size: { value: 3 }
      },
      {
        dataTransform: [{ type: "filter", base: "type", oneOf: ["gene"] }],
        mark: "text",
        text: { base: "geneLabel", type: "nominal" },
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        row: { base: "strandRow", type: "nominal", domain: ["+", "-"] },
        color: { base: "geneLabelColor", type: "nominal", domain: ["+", "-"], range: ["blue", "red"] },
        opacity: { base: "opacity", value: 1 },
        size: { base: "geneLabelFontSize", value: 18 },
        stroke: { base: "geneLabelStroke", value: "white" },
        strokeWidth: { base: "geneLabelStrokeThickness", value: 2 },
        visibility: [
          {
            operation: "less-than",
            measure: "width",
            threshold: "|xe-x|",
            transitionPadding: 10,
            target: "mark"
          }
        ]
      }
    ]
  },
  {
    name: "ideogram",
    channels: [
      { name: "startPosition", type: "genomic", required: true },
      { name: "endPosition", type: "genomic", required: true },
      { name: "chrHeight", type: "value", required: false },
      { name: "name", type: "nominal", required: true },
      { name: "stainBackgroundColor", type: "nominal", required: true },
      { name: "stainLabelColor", type: "nominal", required: true },
      { name: "stainStroke", type: "value", required: false },
      { name: "stainStrokeWidth", type: "value", required: false }
    ],
    mapping: [
      {
        mark: "rect",
        dataTransform: [{ type: "filter", base: "stainBackgroundColor", oneOf: ["acen"], not: true }],
        color: {
          base: "stainBackgroundColor",
          type: "nominal",
          domain: ["gneg", "gpos25", "gpos50", "gpos75", "gpos100", "gvar", "acen"],
          range: ["white", "lightgray", "gray", "gray", "black", "#7B9CC8", "#DC4542"]
        },
        size: { base: "chrHeight", value: 18 },
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        stroke: { base: "stainStroke", value: "gray" },
        strokeWidth: { base: "stainStrokeWidth", value: 0.3 }
      },
      {
        mark: "triangleRight",
        dataTransform: [
          { type: "filter", base: "stainBackgroundColor", oneOf: ["acen"] },
          { type: "filter", base: "name", include: "q" }
        ],
        color: {
          base: "stainBackgroundColor",
          type: "nominal",
          domain: ["gneg", "gpos25", "gpos50", "gpos75", "gpos100", "gvar", "acen"],
          range: ["white", "lightgray", "gray", "gray", "black", "#7B9CC8", "#DC4542"]
        },
        size: { base: "chrHeight", value: 18 },
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        stroke: { base: "stainStroke", value: "gray" },
        strokeWidth: { base: "stainStrokeWidth", value: 0.3 }
      },
      {
        mark: "triangleLeft",
        dataTransform: [
          { type: "filter", base: "stainBackgroundColor", oneOf: ["acen"] },
          { type: "filter", base: "name", include: "p" }
        ],
        color: {
          base: "stainBackgroundColor",
          type: "nominal",
          domain: ["gneg", "gpos25", "gpos50", "gpos75", "gpos100", "gvar", "acen"],
          range: ["white", "lightgray", "gray", "gray", "black", "#7B9CC8", "#DC4542"]
        },
        size: { base: "chrHeight", value: 18 },
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        stroke: { base: "stainStroke", value: "gray" },
        strokeWidth: { base: "stainStrokeWidth", value: 0.3 }
      },
      {
        mark: "text",
        dataTransform: [{ type: "filter", base: "stainLabelColor", oneOf: ["acen"], not: true }],
        color: {
          base: "stainLabelColor",
          type: "nominal",
          domain: ["gneg", "gpos25", "gpos50", "gpos75", "gpos100", "gvar"],
          range: ["black", "black", "black", "black", "white", "black"]
        },
        text: { base: "name", type: "nominal" },
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        visibility: [
          {
            operation: "less-than",
            measure: "width",
            threshold: "|xe-x|",
            transitionPadding: 10,
            target: "mark"
          }
        ]
      }
    ]
  },
  {
    name: "sequence",
    channels: [
      { name: "startPosition", type: "genomic", required: true },
      { name: "endPosition", type: "genomic", required: true },
      { name: "barLength", type: "quantitative", required: true },
      { name: "baseBackground", type: "nominal", required: true },
      { name: "baseLabelColor", type: "nominal", required: true },
      { name: "baseLabelFontSize", type: "value", required: false }
    ],
    mapping: [
      {
        mark: "bar",
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        y: { base: "barLength", type: "quantitative", axis: "none" },
        color: { base: "baseBackground", type: "nominal", domain: ["A", "T", "G", "C"] }
      },
      {
        dataTransform: [{ type: "filter", base: "barLength", oneOf: [0], not: true }],
        mark: "text",
        x: { base: "startPosition", type: "genomic" },
        xe: { base: "endPosition", type: "genomic" },
        color: { base: "baseLabelColor", type: "nominal", domain: ["A", "T", "G", "C"], range: ["white"] },
        text: { base: "baseBackground", type: "nominal" },
        size: { base: "baseLabelFontSize", value: 18 },
        visibility: [
          {
            operation: "less-than",
            measure: "width",
            threshold: "|xe-x|",
            transitionPadding: 30,
            target: "mark"
          },
          {
            operation: "LT",
            measure: "zoomLevel",
            threshold: 10,
            target: "track"
          }
        ]
      }
    ]
  }
];
function replaceTrackTemplates(spec, templates) {
  traverseTracks(spec, (t, i, ts) => {
    var _a, _b;
    if (!IsTemplateTrack(t)) {
      return;
    }
    const { template: name2 } = t;
    const templateDef = templates.find((d) => d.name === name2);
    if (!templateDef) {
      t._invalidTrack = true;
      console.warn(`There is no track template named '${name2}'`);
      return;
    }
    let isValid = true;
    templateDef.channels.forEach((d) => {
      if (d.required && (!t.encoding || !(d.name in t.encoding))) {
        isValid = false;
        console.warn(`A template spec ('${name2}') does not contain a required channel, ${d.name}`);
      }
    });
    if (!isValid) {
      t._invalidTrack = true;
      return;
    }
    const viewBase = JSON.parse(JSON.stringify(t));
    if ("encoding" in viewBase) {
      delete viewBase.encoding;
    }
    const convertedView = {
      ...viewBase,
      alignment: "overlay",
      tracks: [],
      width: (_a = t.width) != null ? _a : 100,
      height: (_b = t.height) != null ? _b : 100
    };
    templateDef.mapping.forEach((singleTrackMappingDef) => {
      const convertedTrack = {
        data: t.data,
        mark: singleTrackMappingDef.mark
      };
      const { dataTransform } = singleTrackMappingDef;
      if (dataTransform) {
        dataTransform.map((dataTramsformMap) => {
          const baseChannelName = dataTramsformMap.base;
          if (baseChannelName && t.encoding && baseChannelName in t.encoding && "field" in t.encoding[baseChannelName]) {
            delete dataTramsformMap.base;
            dataTramsformMap.field = t.encoding[baseChannelName].field;
          }
        });
      }
      const encodingSpec = t.encoding;
      if (!encodingSpec) {
        Object.keys(singleTrackMappingDef).filter((k) => k !== "mark").forEach((channelKey) => {
          const channelMap = JSON.parse(JSON.stringify(singleTrackMappingDef[channelKey]));
          if ("base" in channelMap) {
            delete channelMap.base;
          }
          convertedTrack[channelKey] = channelMap;
        });
      } else {
        Object.keys(singleTrackMappingDef).filter((k) => k !== "mark").forEach((channelKey) => {
          const channelMap = JSON.parse(JSON.stringify(singleTrackMappingDef[channelKey]));
          if ("base" in channelMap) {
            const baseChannelName = channelMap.base;
            if (baseChannelName in encodingSpec) {
              const base = JSON.parse(JSON.stringify(encodingSpec[baseChannelName]));
              delete channelMap.base;
              const newChannelSpec = Object.assign(channelMap, JSON.parse(JSON.stringify(base)));
              convertedTrack[channelKey] = newChannelSpec;
            } else {
              delete channelMap.base;
              convertedTrack[channelKey] = channelMap;
            }
          } else {
            convertedTrack[channelKey] = channelMap;
          }
        });
      }
      convertedView.tracks.push(convertedTrack);
    });
    ts[i] = convertedView;
  });
}
function formatDecimal(x) {
  return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
}
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}
function exponent(x) {
  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
}
function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
    while (i > 0 && g > 0) {
      if (length + g + 1 > width)
        g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}
function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function formatTrim(s) {
  out:
    for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}
var prefixExponent;
function formatPrefixAuto(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d)
    return x + "";
  var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0];
}
function formatRounded(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d)
    return x + "";
  var coefficient = d[0], exponent2 = d[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}
var formatTypes = {
  "%": function(x, p) {
    return (x * 100).toFixed(p);
  },
  "b": function(x) {
    return Math.round(x).toString(2);
  },
  "c": function(x) {
    return x + "";
  },
  "d": formatDecimal,
  "e": function(x, p) {
    return x.toExponential(p);
  },
  "f": function(x, p) {
    return x.toFixed(p);
  },
  "g": function(x, p) {
    return x.toPrecision(p);
  },
  "o": function(x) {
    return Math.round(x).toString(8);
  },
  "p": function(x, p) {
    return formatRounded(x * 100, p);
  },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function(x) {
    return Math.round(x).toString(16).toUpperCase();
  },
  "x": function(x) {
    return Math.round(x).toString(16);
  }
};
function identity$1(x) {
  return x;
}
var map$1 = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function formatLocale(locale2) {
  var group2 = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity$1 : formatGroup(map$1.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity$1 : formatNumerals(map$1.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "-" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;
    if (type2 === "n")
      comma = true, type2 = "g";
    else if (!formatTypes[type2])
      precision === void 0 && (precision = 12), trim = true, type2 = "g";
    if (zero || fill === "0" && align === "=")
      zero = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
    var formatType = formatTypes[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
      if (type2 === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim)
          value = formatTrim(value);
        if (valueNegative && +value === 0 && sign !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero)
        value = group2(value, Infinity);
      var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero)
        value = group2(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f2 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value2) {
      return f2(k * value2) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}
var locale;
var format$1;
var formatPrefix;
defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""],
  minus: "-"
});
function defaultLocale(definition) {
  locale = formatLocale(definition);
  format$1 = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}
function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}
const CHROM_SIZE_HG38 = {
  chr1: 248956422,
  chr2: 242193529,
  chr3: 198295559,
  chr4: 190214555,
  chr5: 181538259,
  chr6: 170805979,
  chr7: 159345973,
  chr8: 145138636,
  chr9: 138394717,
  chr10: 133797422,
  chr11: 135086622,
  chr12: 133275309,
  chr13: 114364328,
  chr14: 107043718,
  chr15: 101991189,
  chr16: 90338345,
  chr17: 83257441,
  chr18: 80373285,
  chr19: 58617616,
  chr20: 64444167,
  chr21: 46709983,
  chr22: 50818468,
  chrX: 156040895,
  chrY: 57227415
};
const CHROM_SIZE_HG19 = {
  chr1: 249250621,
  chr2: 243199373,
  chr3: 198022430,
  chr4: 191154276,
  chr5: 180915260,
  chr6: 171115067,
  chr7: 159138663,
  chr8: 146364022,
  chr9: 141213431,
  chr10: 135534747,
  chr11: 135006516,
  chr12: 133851895,
  chr13: 115169878,
  chr14: 107349540,
  chr15: 102531392,
  chr16: 90354753,
  chr17: 81195210,
  chr18: 78077248,
  chr19: 59128983,
  chr20: 63025520,
  chr21: 48129895,
  chr22: 51304566,
  chrX: 155270560,
  chrY: 59373566,
  chrM: 16571
};
const CHROM_SIZE_HG18 = {
  chr1: 247249719,
  chr2: 242951149,
  chr3: 199501827,
  chr4: 191273063,
  chr5: 180857866,
  chr6: 170899992,
  chr7: 158821424,
  chr8: 146274826,
  chr9: 140273252,
  chr10: 135374737,
  chr11: 134452384,
  chr12: 132349534,
  chr13: 114142980,
  chr14: 106368585,
  chr15: 100338915,
  chr16: 88827254,
  chr17: 78774742,
  chr18: 76117153,
  chr19: 63811651,
  chr20: 62435964,
  chr21: 46944323,
  chr22: 49691432,
  chrX: 154913754,
  chrY: 57772954,
  chrM: 16571
};
const CHROM_SIZE_HG17 = {
  chr1: 245522847,
  chr2: 243018229,
  chr3: 199505740,
  chr4: 191411218,
  chr5: 180857866,
  chr6: 170975699,
  chr7: 158628139,
  chr8: 146274826,
  chr9: 138429268,
  chr10: 135413628,
  chr11: 134452384,
  chr12: 132449811,
  chr13: 114142980,
  chr14: 106368585,
  chr15: 100338915,
  chr16: 88827254,
  chr17: 78774742,
  chr18: 76117153,
  chr19: 63811651,
  chr20: 62435964,
  chr21: 46944323,
  chr22: 49554710,
  chrX: 154824264,
  chrY: 57701691,
  chrM: 16571
};
const CHROM_SIZE_HG16 = {
  chr1: 246127941,
  chr2: 243615958,
  chr3: 199344050,
  chr4: 191731959,
  chr5: 181034922,
  chr6: 170914576,
  chr7: 158545518,
  chr8: 146308819,
  chr9: 136372045,
  chr10: 135037215,
  chr11: 134482954,
  chr12: 132078379,
  chr13: 113042980,
  chr14: 105311216,
  chr15: 100256656,
  chr16: 90041932,
  chr17: 81860266,
  chr18: 76115139,
  chr19: 63811651,
  chr20: 63741868,
  chr21: 46976097,
  chr22: 49396972,
  chrX: 153692391,
  chrY: 50286555,
  chrM: 16571
};
const CHROM_SIZE_MM10 = {
  chr1: 195471971,
  chr2: 182113224,
  chr3: 160039680,
  chr4: 156508116,
  chr5: 151834684,
  chr6: 149736546,
  chr7: 145441459,
  chr8: 129401213,
  chr9: 124595110,
  chr10: 130694993,
  chr11: 122082543,
  chr12: 120129022,
  chr13: 120421639,
  chr14: 124902244,
  chr15: 104043685,
  chr16: 98207768,
  chr17: 94987271,
  chr18: 90702639,
  chr19: 61431566,
  chrX: 171031299,
  chrY: 91744698,
  chrM: 16299
};
const CHROM_SIZE_MM9 = {
  chr1: 197195432,
  chr2: 181748087,
  chr3: 159599783,
  chr4: 155630120,
  chr5: 152537259,
  chr6: 149517037,
  chr7: 152524553,
  chr8: 131738871,
  chr9: 124076172,
  chr10: 129993255,
  chr11: 121843856,
  chr12: 121257530,
  chr13: 120284312,
  chr14: 125194864,
  chr15: 103494974,
  chr16: 98319150,
  chr17: 95272651,
  chr18: 90772031,
  chr19: 61342430,
  chrX: 166650296,
  chrY: 15902555,
  chrM: 16299
};
function getRelativeGenomicPosition(absPos, assembly) {
  var _a;
  const [chromosome, absInterval] = (_a = Object.entries(computeChromSizes(assembly).interval).find((d) => {
    const [start, end] = d[1];
    return start <= absPos && absPos < end;
  })) != null ? _a : [null, null];
  if (!chromosome || !absInterval) {
    return { chromosome: "unknown", position: absPos };
  }
  return { chromosome, position: absPos - absInterval[0] };
}
function createChromSizesUrl(chromSizes) {
  const text = chromSizes.map((d) => d.join("	")).join("\n");
  const tsv = new Blob([text], { type: "text/tsv" });
  return URL.createObjectURL(tsv);
}
function computeChromSizes(assembly) {
  if (assembly && typeof assembly === "string" && assembly in CRHOM_SIZES) {
    return CRHOM_SIZES[assembly];
  } else if (Array.isArray(assembly) && assembly.length !== 0) {
    const size = Object.fromEntries(assembly);
    return {
      size,
      interval: getChromInterval(size),
      total: getChromTotalSize(size),
      path: createChromSizesUrl(assembly)
    };
  } else {
    return CRHOM_SIZES.hg38;
  }
}
const basePath = (assembly) => `https://s3.amazonaws.com/gosling-lang.org/data/${assembly}.chrom.sizes`;
const CRHOM_SIZES = Object.freeze({
  hg38: {
    size: CHROM_SIZE_HG38,
    interval: getChromInterval(CHROM_SIZE_HG38),
    total: getChromTotalSize(CHROM_SIZE_HG38),
    path: basePath("hg38")
  },
  hg19: {
    size: CHROM_SIZE_HG19,
    interval: getChromInterval(CHROM_SIZE_HG19),
    total: getChromTotalSize(CHROM_SIZE_HG19),
    path: basePath("hg19")
  },
  hg18: {
    size: CHROM_SIZE_HG18,
    interval: getChromInterval(CHROM_SIZE_HG18),
    total: getChromTotalSize(CHROM_SIZE_HG18),
    path: basePath("hg18")
  },
  hg17: {
    size: CHROM_SIZE_HG17,
    interval: getChromInterval(CHROM_SIZE_HG17),
    total: getChromTotalSize(CHROM_SIZE_HG17),
    path: basePath("hg17")
  },
  hg16: {
    size: CHROM_SIZE_HG16,
    interval: getChromInterval(CHROM_SIZE_HG16),
    total: getChromTotalSize(CHROM_SIZE_HG16),
    path: basePath("hg16")
  },
  mm10: {
    size: CHROM_SIZE_MM10,
    interval: getChromInterval(CHROM_SIZE_MM10),
    total: getChromTotalSize(CHROM_SIZE_MM10),
    path: basePath("mm10")
  },
  mm9: {
    size: CHROM_SIZE_MM9,
    interval: getChromInterval(CHROM_SIZE_MM9),
    total: getChromTotalSize(CHROM_SIZE_MM9),
    path: basePath("mm9")
  },
  unknown: {
    size: { chr: Number.MAX_VALUE },
    interval: { chr: [0, Number.MAX_VALUE] },
    total: Number.MAX_VALUE,
    path: basePath("hg38")
  }
});
function getAutoCompleteId(assembly) {
  switch (assembly) {
    case "hg19":
      return "OHJakQICQD6gTD7skx4EWA";
    case "mm10":
      return "QDutvmyiSrec5nX4pA5WGQ";
    case "mm9":
      return "GUm5aBiLRCyz2PsBea7Yzg";
    case "hg38":
    default:
      return "P0PLbQMwTYGy-5uPIQid7A";
  }
}
function getChromInterval(chromSize) {
  const interval2 = {};
  Object.keys(chromSize).reduce((sum2, k) => {
    interval2[k] = [sum2, sum2 + chromSize[k]];
    return sum2 + chromSize[k];
  }, 0);
  return interval2;
}
function getChromTotalSize(chromSize) {
  return Object.values(chromSize).reduce((sum2, current) => sum2 + current, 0);
}
function parseGenomicPosition(position) {
  const [chromosome, intervalString] = position.split(":");
  if (intervalString) {
    const [start, end] = intervalString.split("-").map((s) => +s.replace(/,/g, ""));
    if (!Number.isNaN(start) && !Number.isNaN(end)) {
      return { chromosome, start, end };
    }
  }
  return { chromosome };
}
class GenomicPositionHelper {
  constructor(chromosome, start, end) {
    this.chromosome = chromosome;
    this.start = start;
    this.end = end;
  }
  static fromString(str) {
    const result = parseGenomicPosition(str);
    return new GenomicPositionHelper(result.chromosome, result.start, result.end);
  }
  toAbsoluteCoordinates(assembly, padding = 0) {
    const info = computeChromSizes(assembly);
    const size = info.size[this.chromosome];
    const interval2 = info.interval[this.chromosome];
    if (size === void 0 || interval2 === void 0) {
      throw new Error(`Chromosome name ${this.chromosome} is not valid`);
    }
    let { start, end } = this;
    if (start === void 0 || end === void 0) {
      [start, end] = [1, size];
    }
    const offset = interval2[0];
    return [start + offset - padding, end + offset + padding];
  }
}
function createPluginTrack(config2, factory2) {
  var _a;
  function Track(...args) {
    if (!new.target) {
      throw new Error('Uncaught TypeError: Class constructor cannot be invoked without "new"');
    }
    return factory2(...args);
  }
  Track.config = {
    ...config2,
    availableOptions: Object.keys((_a = config2.defaultOptions) != null ? _a : {})
  };
  return Track;
}
const TICK_WIDTH = 200;
const TICK_HEIGHT = 6;
const TICK_TEXT_SEPARATION = 2;
const TICK_COLOR = 7829367;
const icon$1 = '<svg version="1.0" xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 5640 5420" preserveAspectRatio="xMidYMid meet"> <g id="layer101" fill="#000000" stroke="none"> <path d="M0 2710 l0 -2710 2820 0 2820 0 0 2710 0 2710 -2820 0 -2820 0 0 -2710z"/> </g> <g id="layer102" fill="#750075" stroke="none"> <path d="M200 4480 l0 -740 630 0 630 0 0 740 0 740 -630 0 -630 0 0 -740z"/> <path d="M1660 4420 l0 -800 570 0 570 0 0 800 0 800 -570 0 -570 0 0 -800z"/> <path d="M3000 3450 l0 -1770 570 0 570 0 0 1770 0 1770 -570 0 -570 0 0 -1770z"/> <path d="M4340 2710 l0 -2510 560 0 560 0 0 2510 0 2510 -560 0 -560 0 0 -2510z"/> <path d="M200 1870 l0 -1670 630 0 630 0 0 1670 0 1670 -630 0 -630 0 0 -1670z"/> <path d="M1660 1810 l0 -1610 570 0 570 0 0 1610 0 1610 -570 0 -570 0 0 -1610z"/> <path d="M3000 840 l0 -640 570 0 570 0 0 640 0 640 -570 0 -570 0 0 -640z"/> </g> <g id="layer103" fill="#ffff04" stroke="none"> <path d="M200 4480 l0 -740 630 0 630 0 0 740 0 740 -630 0 -630 0 0 -740z"/> <path d="M1660 4420 l0 -800 570 0 570 0 0 800 0 800 -570 0 -570 0 0 -800z"/> <path d="M3000 3450 l0 -1770 570 0 570 0 0 1770 0 1770 -570 0 -570 0 0 -1770z"/> </g> </svg>';
const config$2 = {
  type: "axis-track",
  datatype: ["multivec", "epilogos"],
  local: false,
  orientation: "1d-horizontal",
  thumbnail: new DOMParser().parseFromString(icon$1, "text/xml").documentElement,
  defaultOptions: {
    innerRadius: 340,
    outerRadius: 310,
    startAngle: 0,
    endAngle: 360,
    width: 700,
    height: 700,
    layout: "linear",
    labelPosition: "none",
    labelColor: "black",
    labelTextOpacity: 0.4,
    trackBorderWidth: 0,
    trackBorderColor: "black",
    tickPositions: "even",
    fontSize: 12,
    fontFamily: "sans-serif",
    fontWeight: "normal",
    color: "#808080",
    stroke: "#ffffff",
    backgroundColor: "transparent",
    showMousePosition: false,
    tickColor: TICK_COLOR
  }
};
const factory$1 = (HGC, context2, options) => {
  const { absToChr, colorToHex: colorToHex2, pixiTextToSvg, svgLine, showMousePosition } = HGC.utils;
  function createTickText(text, style) {
    return Object.assign(new HGC.libraries.PIXI.Text(text, style), { hashValue: Math.random() });
  }
  class AxisTrackClass extends HGC.tracks.PixiTrack {
    constructor() {
      super(context2, options);
      const { dataConfig, animate, chromInfoPath, isShowGlobalMousePosition } = context2;
      this.searchField = null;
      this.dataConfig = dataConfig;
      this.allTexts = [];
      this.pTicksCircular = new HGC.libraries.PIXI.Graphics();
      this.pTicks = new HGC.libraries.PIXI.Graphics();
      this.pMain.addChild(this.pTicks);
      this.pMain.addChild(this.pTicksCircular);
      this.gTicks = {};
      this.tickTexts = {};
      this.options = options;
      this.isShowGlobalMousePosition = isShowGlobalMousePosition;
      this.pixiTextConfig = getTextStyle({
        size: +this.options.fontSize,
        fontFamily: this.options.fontFamily,
        fontWeight: this.options.fontWeight,
        color: this.options.color,
        stroke: this.options.stroke,
        strokeThickness: 2
      });
      this.stroke = colorToHex2(this.pixiTextConfig.stroke);
      this.tickWidth = TICK_WIDTH;
      this.tickHeight = TICK_HEIGHT;
      this.tickTextSeparation = TICK_TEXT_SEPARATION;
      this.tickColor = colorToHex2(this.options.tickColor);
      this.animate = animate;
      this.pubSubs = [];
      if (this.options.showMousePosition && !this.hideMousePosition) {
        this.hideMousePosition = showMousePosition(this, this.is2d, this.isShowGlobalMousePosition());
      }
      let chromSizesPath = chromInfoPath;
      if (!chromSizesPath) {
        chromSizesPath = `${dataConfig.server}/chrom-sizes/?id=${dataConfig.tilesetUid}`;
      }
      const assembly = this.options.assembly;
      const chrPositions = {};
      const chromLengths = { ...computeChromSizes(assembly).size };
      const cumPositions = [];
      Object.keys(computeChromSizes(assembly).size).forEach((k) => {
        chrPositions[k] = { chr: k, pos: computeChromSizes(assembly).size[k] };
      });
      Object.keys(computeChromSizes(assembly).interval).forEach((k) => {
        cumPositions.push({ chr: k, pos: computeChromSizes(assembly).interval[k][0] });
      });
      this.chromInfo = { chrPositions, chromLengths, cumPositions };
      this.rerender(this.options, true);
      this.draw();
      this.animate();
    }
    initBoundsTicks() {
      if (this.pTicks) {
        this.pMain.removeChild(this.pTicks);
        this.pTicks = null;
      }
      if (!this.gBoundTicks) {
        this.gBoundTicks = new HGC.libraries.PIXI.Graphics();
        this.leftBoundTick = createTickText("", this.pixiTextConfig);
        this.rightBoundTick = createTickText("", this.pixiTextConfig);
        this.gBoundTicks.addChild(this.leftBoundTick);
        this.gBoundTicks.addChild(this.rightBoundTick);
        this.pMain.addChild(this.gBoundTicks);
      }
      this.texts = [];
    }
    initChromLabels() {
      if (!this.chromInfo)
        return;
      if (this.gBoundTicks) {
        this.pMain.removeChild(this.gBoundTicks);
        this.gBoundTicks = void 0;
      }
      if (!this.pTicks) {
        this.pTicks = new HGC.libraries.PIXI.Graphics();
        this.pMain.addChild(this.pTicks);
      }
      this.texts = [];
      this.pTicks.removeChildren();
      this.chromInfo.cumPositions.forEach((info) => {
        var _a, _b, _c;
        const chromName = info.chr;
        this.gTicks[chromName] = new HGC.libraries.PIXI.Graphics();
        if (!this.tickTexts[chromName])
          this.tickTexts[chromName] = [];
        const text = createTickText(chromName, this.pixiTextConfig);
        (_a = this.pTicks) == null ? void 0 : _a.addChild(text);
        (_b = this.pTicks) == null ? void 0 : _b.addChild(this.gTicks[chromName]);
        (_c = this.texts) == null ? void 0 : _c.push(text);
      });
    }
    rerender(options2, force) {
      const strOptions = JSON.stringify(options2);
      if (!force && strOptions === this.prevOptions)
        return;
      this.prevOptions = strOptions;
      this.options = options2;
      this.pixiTextConfig.fontSize = +this.options.fontSize ? `${+this.options.fontSize}px` : this.pixiTextConfig.fontSize;
      this.pixiTextConfig.fill = this.options.color || this.pixiTextConfig.fill;
      this.pixiTextConfig.stroke = this.options.stroke || this.pixiTextConfig.stroke;
      this.stroke = colorToHex2(this.pixiTextConfig.stroke);
      this.tickColor = this.options.tickColor ? colorToHex2(this.options.tickColor) : TICK_COLOR;
      if (this.options.tickPositions === "ends" && this.options.layout !== "circular") {
        this.initBoundsTicks();
      } else {
        this.initChromLabels();
      }
      super.rerender(options2, force);
      if (this.options.showMousePosition && !this.hideMousePosition) {
        this.hideMousePosition = showMousePosition(this, this.is2d, this.isShowGlobalMousePosition());
      }
      if (!this.options.showMousePosition && this.hideMousePosition) {
        this.hideMousePosition();
        this.hideMousePosition = void 0;
      }
    }
    formatTick(pos) {
      if (isNaN(pos)) {
        return "null";
      }
      const domain = this._xScale.domain();
      const viewWidth = domain[1] - domain[0];
      const p = precisionPrefix(pos, viewWidth);
      const fPlain = format$1(",");
      const fPrecision = formatPrefix(`,.${p}`, viewWidth);
      let f2 = fPlain;
      if (this.options.tickFormat === "si") {
        f2 = fPrecision;
      } else if (this.options.tickFormat === "plain") {
        f2 = fPlain;
      } else if (this.options.tickPositions === "ends") {
        f2 = fPrecision;
      }
      return f2(pos);
    }
    drawBoundsTicks(x1, x2) {
      if (!this.gBoundTicks || !this.leftBoundTick || !this.rightBoundTick)
        return;
      const graphics = this.gBoundTicks;
      graphics.clear();
      graphics.lineStyle(1, 0);
      const lineYStart = this.options.reverseOrientation ? 0 : this.dimensions[1];
      const lineYEnd = this.options.reverseOrientation ? this.tickHeight : this.dimensions[1] - this.tickHeight;
      graphics.moveTo(1, lineYStart);
      graphics.lineTo(1, lineYEnd);
      graphics.moveTo(this.dimensions[0] - 1, lineYStart);
      graphics.lineTo(this.dimensions[0] - 1, lineYEnd);
      this.leftBoundTick.x = 0;
      this.leftBoundTick.y = this.options.reverseOrientation ? lineYEnd + this.tickTextSeparation : lineYEnd - this.tickTextSeparation;
      this.leftBoundTick.text = this.options.assembly === "unknown" ? `${this.formatTick(x1[1])}` : `${x1[0]}: ${this.formatTick(x1[1])}`;
      this.leftBoundTick.anchor.y = this.options.reverseOrientation ? 0 : 1;
      this.rightBoundTick.x = this.dimensions[0];
      this.rightBoundTick.text = this.options.assembly === "unknown" ? `${this.formatTick(x2[1])}` : `${x2[0]}: ${this.formatTick(x2[1])}`;
      this.rightBoundTick.y = this.options.reverseOrientation ? lineYEnd + this.tickTextSeparation : lineYEnd - this.tickTextSeparation;
      this.rightBoundTick.anchor.y = this.options.reverseOrientation ? 0 : 1;
      this.rightBoundTick.anchor.x = 1;
      if (this.flipText) {
        this.leftBoundTick.scale.x = -1;
        this.leftBoundTick.anchor.x = 1;
        this.rightBoundTick.scale.x = -1;
        this.rightBoundTick.anchor.x = 0;
      }
      this.leftBoundTick.tickLine = [1, this.dimensions[1], 1, this.dimensions[1] - this.tickHeight];
      this.rightBoundTick.tickLine = [
        this.dimensions[0] - 1,
        this.dimensions[1],
        this.dimensions[0] - 1,
        this.dimensions[1] - this.tickHeight
      ];
      this.tickTexts = {};
      this.tickTexts.all = [this.leftBoundTick, this.rightBoundTick];
    }
    drawTicks(cumPos) {
      const graphics = this.gTicks[cumPos.chr];
      graphics.visible = true;
      graphics.clear();
      const chromLen = +this.chromInfo.chromLengths[cumPos.chr];
      const vpLeft = Math.max(this._xScale(cumPos.pos), 0);
      const vpRight = Math.min(this._xScale(cumPos.pos + chromLen), this.dimensions[0]);
      const numTicks = (vpRight - vpLeft) / this.tickWidth;
      const xScale = scaleLinear().domain([
        Math.max(1, this._xScale.invert(0) - cumPos.pos),
        Math.min(chromLen, this._xScale.invert(this.dimensions[0]) - cumPos.pos)
      ]).range([vpLeft, vpRight]);
      const ticks = xScale.ticks(numTicks).filter((tick) => Number.isInteger(tick));
      const tickTexts = this.tickTexts[cumPos.chr];
      const tickHeight = this.tickHeight;
      const xPadding = 0;
      let yPadding = tickHeight + this.tickTextSeparation;
      if (this.options.reverseOrientation) {
        yPadding = this.dimensions[1] - yPadding;
      }
      while (tickTexts.length < ticks.length) {
        const newText = createTickText("", this.pixiTextConfig);
        tickTexts.push(newText);
        this.gTicks[cumPos.chr].addChild(newText);
      }
      while (tickTexts.length > ticks.length) {
        const text = tickTexts.pop();
        this.gTicks[cumPos.chr].removeChild(text);
      }
      let i = 0;
      while (i < ticks.length) {
        tickTexts[i].visible = true;
        tickTexts[i].anchor.x = 0.5;
        tickTexts[i].anchor.y = this.options.layout === "circular" ? 0 : this.options.reverseOrientation ? 0 : 1;
        if (this.flipText)
          tickTexts[i].scale.x = -1;
        const chrText = this.options.assembly === "unknown" ? "" : `${cumPos.chr}: `;
        tickTexts[i].text = ticks[i] === 0 ? `${chrText}1` : `${chrText}${this.formatTick(ticks[i])}`;
        const x = this._xScale(cumPos.pos + ticks[i]);
        if (this.options.layout === "circular") {
          const rope = this.addCurvedText(tickTexts[i], x + xPadding);
          rope && this.pTicksCircular.addChild(rope);
        } else {
          tickTexts[i].x = x + xPadding;
          tickTexts[i].y = this.dimensions[1] - yPadding;
          tickTexts[i].tickLine = [x - 1, this.dimensions[1], x - 1, this.dimensions[1] - tickHeight - 1];
          const lineYStart = this.options.reverseOrientation ? 0 : this.dimensions[1];
          const lineYEnd = this.options.reverseOrientation ? tickHeight : this.dimensions[1] - tickHeight;
          graphics.lineStyle(1, this.tickColor);
          graphics.moveTo(x, lineYStart);
          graphics.lineTo(x, lineYEnd);
        }
        i += 1;
      }
      if (this.options.layout === "circular")
        i = 0;
      while (i < tickTexts.length) {
        tickTexts[i].visible = false;
        i += 1;
      }
      return ticks.length;
    }
    addCurvedText(textObj, cx) {
      const [width, height] = this.dimensions;
      const { startAngle, endAngle } = this.options;
      const factor = Math.min(width, height) / Math.min(this.options.width, this.options.height);
      const innerRadius = this.options.innerRadius * factor;
      const outerRadius = this.options.outerRadius * factor;
      const r = (outerRadius + innerRadius) / 2;
      const centerPos = cartesianToPolar(cx, width, r, width / 2, height / 2, startAngle, endAngle);
      textObj.x = centerPos.x;
      textObj.y = centerPos.y;
      textObj.resolution = 4;
      const txtStyle = new HGC.libraries.PIXI.TextStyle(this.pixiTextConfig);
      const metric = HGC.libraries.PIXI.TextMetrics.measureText(textObj.text, txtStyle);
      const tw = metric.width / (2 * r * Math.PI) * width * 360 / (endAngle - startAngle);
      let [minX, maxX] = [cx - tw / 2, cx + tw / 2];
      if (minX < 0) {
        const gap = -minX;
        minX = 0;
        maxX += gap;
      } else if (maxX > width) {
        const gap = maxX - width;
        maxX = width;
        minX -= gap;
      }
      const ropePoints = [];
      const baseR = innerRadius + metric.height / 2 + 3;
      for (let i = maxX; i >= minX; i -= tw / 10) {
        const p = cartesianToPolar(i, width, baseR, width / 2, height / 2, startAngle, endAngle);
        ropePoints.push(new HGC.libraries.PIXI.Point(p.x, p.y));
      }
      if (ropePoints.length === 0) {
        return void 0;
      }
      textObj.updateText();
      const rope = new HGC.libraries.PIXI.SimpleRope(textObj.texture, ropePoints);
      return rope;
    }
    draw() {
      this.allTexts = [];
      if (!this.texts)
        return;
      const x1 = absToChr(this._xScale.domain()[0], this.chromInfo);
      const x2 = absToChr(this._xScale.domain()[1], this.chromInfo);
      if (!x1 || !x2) {
        console.warn("Empty chromInfo:", this.dataConfig, this.chromInfo);
        return;
      }
      if (this.options.tickPositions === "ends" && this.options.layout !== "circular") {
        if (!this.gBoundTicks)
          return;
        this.gBoundTicks.visible = true;
        this.drawBoundsTicks(x1, x2);
        return;
      }
      if (!this.pTicks) {
        return;
      }
      const circular = this.options.layout === "circular";
      for (let i = 0; i < this.texts.length; i++) {
        this.texts[i].visible = false;
        this.gTicks[this.chromInfo.cumPositions[i].chr].visible = false;
      }
      let yPadding = this.tickHeight + this.tickTextSeparation;
      if (this.options.reverseOrientation) {
        yPadding = this.dimensions[1] - yPadding;
      }
      Object.keys(this.chromInfo.chrPositions).forEach((chrom) => {
        if (this.tickTexts[chrom]) {
          this.tickTexts[chrom].forEach((tick) => {
            tick.visible = false;
          });
        }
      });
      this.pTicksCircular.removeChildren();
      for (let i = x1[3]; i <= x2[3]; i++) {
        const xCumPos = this.chromInfo.cumPositions[i];
        const midX = xCumPos.pos + this.chromInfo.chromLengths[xCumPos.chr] / 2;
        const viewportMidX = this._xScale(midX);
        const chrText = this.texts[i];
        chrText.anchor.x = 0.5;
        chrText.anchor.y = circular ? 0.5 : this.options.reverseOrientation ? 0 : 1;
        let rope;
        if (circular) {
          rope = this.addCurvedText(chrText, viewportMidX);
          if (rope) {
            this.pTicksCircular.addChild(rope);
          }
        } else {
          chrText.x = viewportMidX;
          chrText.y = this.dimensions[1] - yPadding;
        }
        chrText.updateTransform();
        if (this.flipText)
          chrText.scale.x = -1;
        const numTicksDrawn = this.drawTicks(xCumPos);
        if (!circular) {
          chrText.visible = numTicksDrawn <= 0;
        } else {
          if (numTicksDrawn > 0) {
            rope && this.pTicksCircular.removeChild(rope);
          }
        }
        this.allTexts.push({
          importance: chrText.hashValue,
          text: chrText,
          rope
        });
      }
      this.hideOverlaps(this.allTexts);
    }
    hideOverlaps(allTexts) {
      const tree = new RBush();
      allTexts.sort((a, b) => b.importance - a.importance).forEach(({ text, rope }) => {
        text.updateTransform();
        const b = text.getBounds();
        const m = 5;
        const boxWithMargin = {
          minX: b.x - m,
          minY: b.y - m,
          maxX: b.x + b.width + m * 2,
          maxY: b.y + b.height + m * 2
        };
        if (!tree.collides(boxWithMargin)) {
          tree.insert(boxWithMargin);
        } else {
          text.visible = false;
          if (this.options.layout === "circular" && rope) {
            this.pTicksCircular.removeChild(rope);
          }
        }
      });
    }
    setPosition(newPosition) {
      super.setPosition(newPosition);
      [this.pMain.position.x, this.pMain.position.y] = this.position;
    }
    zoomed(newXScale, newYScale) {
      const domainValues = [...newXScale.domain(), ...newYScale.domain()];
      if (domainValues.filter((d) => isNaN(d)).length !== 0) {
        return;
      }
      this.xScale(newXScale);
      this.yScale(newYScale);
      this.draw();
    }
    exportSVG() {
      let track = null;
      let base = null;
      if (super.exportSVG) {
        [base, track] = super.exportSVG();
      } else {
        base = document.createElement("g");
        track = base;
      }
      base.setAttribute("class", "chromosome-labels");
      const output = document.createElement("g");
      track.appendChild(output);
      output.setAttribute("transform", `translate(${this.position[0]},${this.position[1]})`);
      this.allTexts.filter((text) => text.text.visible).forEach((text) => {
        const g = pixiTextToSvg(text.text);
        output.appendChild(g);
      });
      Object.values(this.tickTexts).forEach((texts) => {
        texts.filter((x) => x.visible).forEach((text) => {
          if (!text.tickLine)
            return;
          let g = pixiTextToSvg(text);
          output.appendChild(g);
          g = svgLine(text.x, this.options.reverseOrientation ? 0 : this.dimensions[1], text.x, this.options.reverseOrientation ? this.tickHeight : this.dimensions[1] - this.tickHeight, 1, this.tickColor);
          const line = document.createElement("line");
          line.setAttribute("x1", String(text.tickLine[0]));
          line.setAttribute("y1", String(text.tickLine[1]));
          line.setAttribute("x2", String(text.tickLine[2]));
          line.setAttribute("y2", String(text.tickLine[3]));
          line.setAttribute("style", "stroke: grey");
          output.appendChild(g);
          output.appendChild(line);
        });
      });
      return [base, track];
    }
  }
  return new AxisTrackClass();
};
var AxisTrack = createPluginTrack(config$2, factory$1);
function BrushTrack(HGC, ...args) {
  if (!new.target) {
    throw new Error('Uncaught TypeError: Class constructor cannot be invoked without "new"');
  }
  class BrushTrackClass extends HGC.tracks.SVGTrack {
    constructor(params) {
      var _a, _b;
      super(...params);
      const [context2, options] = params;
      const { registerViewportChanged, removeViewportChanged, setDomainsCallback } = context2;
      this.uid = v1();
      this.options = options;
      this.hasFromView = !context2.projectionXDomain;
      this.removeViewportChanged = removeViewportChanged;
      this.setDomainsCallback = setDomainsCallback;
      this.viewportXDomain = this.hasFromView ? null : context2.projectionXDomain;
      this.viewportYDomain = this.hasFromView ? null : [0, 0];
      this.prevExtent = [0, 0];
      this.RR = 0.02;
      const extent = [0, Math.PI * 1.7];
      this.circularBrushData = this.getBrushData(extent);
      this.brush = arc().innerRadius((_a = this.options.innerRadius) != null ? _a : 100).outerRadius((_b = this.options.outerRadius) != null ? _b : 200);
      this.gBrush = this.gMain.append("g").attr("id", `brush-${this.uid}`).selectAll(".brush").data(this.circularBrushData).enter().append("path").attr("class", "brush").attr("d", this.brush).attr("fill", this.options.projectionFillColor).attr("stroke", this.options.projectionStrokeColor).attr("fill-opacity", (d) => d.type === "brush" ? this.options.projectionFillOpacity : 0).attr("stroke-opacity", (d) => d.type === "brush" ? this.options.projectionStrokeOpacity : 0).attr("stroke-width", this.options.strokeWidth).style("pointer-events", "all").style("cursor", (d) => d.cursor).call(this.dragged());
      registerViewportChanged(this.uid, this.viewportChanged.bind(this));
      this.draw();
    }
    getBrushData(extent) {
      return [
        {
          type: "brush",
          startAngle: extent[0],
          endAngle: extent[1],
          cursor: "grab"
        },
        {
          type: "start",
          startAngle: extent[0],
          endAngle: extent[0] + this.RR,
          cursor: "move"
        },
        {
          type: "end",
          startAngle: extent[1] - this.RR,
          endAngle: extent[1],
          cursor: "move"
        }
      ];
    }
    cropExtent(extent) {
      let [s, e] = extent;
      let round = 0;
      while (s > Math.PI * 2 || e > Math.PI * 2 || s < 0 || e < 0) {
        if (round++ > 10) {
          break;
        }
        if (s > Math.PI * 2 || e > Math.PI * 2) {
          s -= Math.PI * 2;
          e -= Math.PI * 2;
        } else if (s < 0 || e < 0) {
          s += Math.PI * 2;
          e += Math.PI * 2;
        }
      }
      return [s, e].sort((a, b) => a - b);
    }
    updateBrush(extent) {
      let [s, e] = extent;
      if (s <= RADIAN_GAP && e <= RADIAN_GAP || s >= Math.PI * 2 - RADIAN_GAP && e >= Math.PI * 2 - RADIAN_GAP) {
        this.gBrush.attr("visibility", "hidden");
        return;
      }
      if (s < RADIAN_GAP) {
        s = RADIAN_GAP;
      }
      if (s > Math.PI * 2 - RADIAN_GAP) {
        s = Math.PI * 2 - RADIAN_GAP;
      }
      if (e < RADIAN_GAP) {
        e = RADIAN_GAP;
      }
      if (e > Math.PI * 2 - RADIAN_GAP) {
        e = Math.PI * 2 - RADIAN_GAP;
      }
      this.circularBrushData = this.getBrushData(extent);
      this.gBrush.data(this.circularBrushData).attr("d", this.brush).attr("visibility", "visible");
    }
    dragged() {
      const start = () => {
        this.startEvent = HGC.libraries.d3Selection.event.sourceEvent;
        this.prevExtent = [this.circularBrushData[0].startAngle, this.circularBrushData[0].endAngle];
      };
      const drag = (d) => {
        const [x, y] = this.position;
        const [w, h] = this.dimensions;
        const endEvent = HGC.libraries.d3Selection.event.sourceEvent;
        const startX = this.startEvent.layerX - x;
        const startY = this.startEvent.layerY - y;
        const endX = endEvent.layerX - x;
        const endY = endEvent.layerY - y;
        const radDiff = Math.atan2(startX - w / 2, startY - h / 2) - Math.atan2(endX - w / 2, endY - h / 2);
        let [s, e] = this.prevExtent;
        if (d.type === "brush") {
          s = s + radDiff;
          e = e + radDiff;
          if (s < RADIAN_GAP || Math.PI * 2 - RADIAN_GAP < e) {
            const sto = RADIAN_GAP - s;
            const eto = e - (Math.PI * 2 - RADIAN_GAP);
            if (sto > eto) {
              e += sto;
              s += sto;
            } else {
              s -= eto;
              e -= eto;
            }
          }
        } else if (d.type === "start") {
          s = s + radDiff;
        } else if (d.type === "end") {
          e = e + radDiff;
        }
        [s, e] = this.cropExtent([s, e]);
        if (!this._xScale || !this._yScale) {
          return;
        }
        const scale = (this.options.endAngle - this.options.startAngle) / 360;
        const offsetedS = s - this.options.startAngle / 360 * Math.PI * 2;
        const offsetedE = e - this.options.startAngle / 360 * Math.PI * 2;
        const xDomain = [
          this._xScale.invert(w - w * offsetedE / (Math.PI * 2 * scale)),
          this._xScale.invert(w - w * offsetedS / (Math.PI * 2 * scale))
        ];
        const yDomain = this.viewportYDomain;
        if (!this.hasFromView) {
          this.viewportXDomain = xDomain;
        }
        this.setDomainsCallback(xDomain, yDomain);
        this.updateBrush([s, e]);
      };
      return HGC.libraries.d3Drag.drag().on("start", start).on("drag", drag);
    }
    draw() {
      if (!this._xScale || !this.yScale) {
        return;
      }
      if (!this.viewportXDomain || !this.viewportYDomain) {
        return;
      }
      const x0 = this._xScale(this.viewportXDomain[0]);
      const x1 = this._xScale(this.viewportXDomain[1]);
      const [w] = this.dimensions;
      let e = valueToRadian(x0, w, this.options.startAngle, this.options.endAngle) + Math.PI / 2;
      let s = valueToRadian(x1, w, this.options.startAngle, this.options.endAngle) + Math.PI / 2;
      [s, e] = this.cropExtent([s, e]);
      this.updateBrush([s, e]);
    }
    viewportChanged(viewportXScale, viewportYScale) {
      const viewportXDomain = viewportXScale.domain();
      const viewportYDomain = viewportYScale.domain();
      this.viewportXDomain = viewportXDomain;
      this.viewportYDomain = viewportYDomain;
      this.draw();
    }
    remove() {
      this.removeViewportChanged(this.uid);
      super.remove();
    }
    rerender() {
    }
    zoomed(newXScale, newYScale) {
      this.xScale(newXScale);
      this.yScale(newYScale);
      this.draw();
    }
    setPosition(newPosition) {
      super.setPosition(newPosition);
      this.draw();
    }
    setDimensions(newDimensions) {
      super.setDimensions(newDimensions);
      this.gBrush.attr("transform", `translate(${newDimensions[0] / 2},${newDimensions[1] / 2})`);
      this.draw();
    }
  }
  return new BrushTrackClass(args);
}
const icon = '<svg version="1.0" xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 5640 5420" preserveAspectRatio="xMidYMid meet"> <g id="layer101" fill="#000000" stroke="none"> <path d="M0 2710 l0 -2710 2820 0 2820 0 0 2710 0 2710 -2820 0 -2820 0 0 -2710z"/> </g> <g id="layer102" fill="#750075" stroke="none"> <path d="M200 4480 l0 -740 630 0 630 0 0 740 0 740 -630 0 -630 0 0 -740z"/> <path d="M1660 4420 l0 -800 570 0 570 0 0 800 0 800 -570 0 -570 0 0 -800z"/> <path d="M3000 3450 l0 -1770 570 0 570 0 0 1770 0 1770 -570 0 -570 0 0 -1770z"/> <path d="M4340 2710 l0 -2510 560 0 560 0 0 2510 0 2510 -560 0 -560 0 0 -2510z"/> <path d="M200 1870 l0 -1670 630 0 630 0 0 1670 0 1670 -630 0 -630 0 0 -1670z"/> <path d="M1660 1810 l0 -1610 570 0 570 0 0 1610 0 1610 -570 0 -570 0 0 -1610z"/> <path d="M3000 840 l0 -640 570 0 570 0 0 640 0 640 -570 0 -570 0 0 -640z"/> </g> <g id="layer103" fill="#ffff04" stroke="none"> <path d="M200 4480 l0 -740 630 0 630 0 0 740 0 740 -630 0 -630 0 0 -740z"/> <path d="M1660 4420 l0 -800 570 0 570 0 0 800 0 800 -570 0 -570 0 0 -800z"/> <path d="M3000 3450 l0 -1770 570 0 570 0 0 1770 0 1770 -570 0 -570 0 0 -1770z"/> </g> </svg>';
BrushTrack.config = {
  type: "brush-track",
  datatype: ["projection"],
  local: false,
  projection: true,
  orientation: "2d",
  thumbnail: new DOMParser().parseFromString(icon, "text/xml").documentElement,
  availableOptions: [
    "innerRadius",
    "outerRadius",
    "startAngle",
    "endAngle",
    "axisPositionHorizontal",
    "projectionFillColor",
    "projectionStrokeColor",
    "projectionFillOpacity",
    "projectionStrokeOpacity",
    "strokeWidth"
  ],
  defaultOptions: {
    innerRadius: 100,
    outerRadius: 200,
    startAngle: 0,
    endAngle: 360,
    axisPositionHorizontal: "left",
    projectionFillColor: "#777",
    projectionStrokeColor: "#777",
    projectionFillOpacity: 0.3,
    projectionStrokeOpacity: 0.7,
    strokeWidth: 1
  }
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var a = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var uri_all = { exports: {} };
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function(module, exports) {
  (function(global2, factory2) {
    factory2(exports);
  })(commonjsGlobal, function(exports2) {
    function merge2() {
      for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
        sets[_key] = arguments[_key];
      }
      if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
          sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join("");
      } else {
        return sets[0];
      }
    }
    function subexp(str) {
      return "(?:" + str + ")";
    }
    function typeOf(o) {
      return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
    }
    function toUpperCase(str) {
      return str.toUpperCase();
    }
    function toArray2(obj) {
      return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
    }
    function assign(target, source) {
      var obj = target;
      if (source) {
        for (var key in source) {
          obj[key] = source[key];
        }
      }
      return obj;
    }
    function buildExps(isIRI) {
      var ALPHA$$ = "[A-Za-z]", DIGIT$$ = "[0-9]", HEXDIG$$2 = merge2(DIGIT$$, "[A-Fa-f]"), PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge2(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge2(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$);
      subexp(ALPHA$$ + merge2(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*");
      subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*");
      var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+");
      subexp("[vV]" + HEXDIG$$2 + "+\\." + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+");
      subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$)) + "*");
      var PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]"));
      subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+");
      subexp(subexp(PCHAR$ + "|" + merge2("[\\/\\?]", IPRIVATE$$)) + "*");
      return {
        NOT_SCHEME: new RegExp(merge2("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge2("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge2("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge2("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge2("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge2("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge2("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(merge2("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
        OTHER_CHARS: new RegExp(merge2("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
      };
    }
    var URI_PROTOCOL = buildExps(false);
    var IRI_PROTOCOL = buildExps(true);
    var slicedToArray = function() {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"])
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    var toConsumableArray2 = function(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
          arr2[i] = arr[i];
        return arr2;
      } else {
        return Array.from(arr);
      }
    };
    var maxInt = 2147483647;
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter = "-";
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7E]/;
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    var errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    function error$1(type2) {
      throw new RangeError(errors[type2]);
    }
    function map2(array, fn) {
      var result = [];
      var length = array.length;
      while (length--) {
        result[length] = fn(array[length]);
      }
      return result;
    }
    function mapDomain(string, fn) {
      var parts = string.split("@");
      var result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string = parts[1];
      }
      string = string.replace(regexSeparators, ".");
      var labels = string.split(".");
      var encoded = map2(labels, fn).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      var output = [];
      var counter = 0;
      var length = string.length;
      while (counter < length) {
        var value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          var extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    var ucs2encode = function ucs2encode2(array) {
      return String.fromCodePoint.apply(String, toConsumableArray2(array));
    };
    var basicToDigit = function basicToDigit2(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    };
    var digitToBasic = function digitToBasic2(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    var adapt = function adapt2(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var decode = function decode2(input) {
      var output = [];
      var inputLength = input.length;
      var i = 0;
      var n = initialN;
      var bias = initialBias;
      var basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (var j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error$1("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        var oldi = i;
        for (var w = 1, k = base; ; k += base) {
          if (index >= inputLength) {
            error$1("invalid-input");
          }
          var digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base || digit > floor((maxInt - i) / w)) {
            error$1("overflow");
          }
          i += digit * w;
          var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t) {
            break;
          }
          var baseMinusT = base - t;
          if (w > floor(maxInt / baseMinusT)) {
            error$1("overflow");
          }
          w *= baseMinusT;
        }
        var out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error$1("overflow");
        }
        n += floor(i / out);
        i %= out;
        output.splice(i++, 0, n);
      }
      return String.fromCodePoint.apply(String, output);
    };
    var encode = function encode2(input) {
      var output = [];
      input = ucs2decode(input);
      var inputLength = input.length;
      var n = initialN;
      var delta = 0;
      var bias = initialBias;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _currentValue2 = _step.value;
          if (_currentValue2 < 128) {
            output.push(stringFromCharCode(_currentValue2));
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      var basicLength = output.length;
      var handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        var m = maxInt;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = void 0;
        try {
          for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var currentValue = _step2.value;
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
        var handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error$1("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = void 0;
        try {
          for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _currentValue = _step3.value;
            if (_currentValue < n && ++delta > maxInt) {
              error$1("overflow");
            }
            if (_currentValue == n) {
              var q = delta;
              for (var k = base; ; k += base) {
                var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) {
                  break;
                }
                var qMinusT = q - t;
                var baseMinusT = base - t;
                output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    };
    var toUnicode = function toUnicode2(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    var toASCII = function toASCII2(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    var punycode = {
      "version": "2.1.0",
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode,
      "encode": encode,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    var SCHEMES = {};
    function pctEncChar(chr) {
      var c = chr.charCodeAt(0);
      var e = void 0;
      if (c < 16)
        e = "%0" + c.toString(16).toUpperCase();
      else if (c < 128)
        e = "%" + c.toString(16).toUpperCase();
      else if (c < 2048)
        e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      else
        e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      return e;
    }
    function pctDecChars(str) {
      var newStr = "";
      var i = 0;
      var il = str.length;
      while (i < il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
          newStr += String.fromCharCode(c);
          i += 3;
        } else if (c >= 194 && c < 224) {
          if (il - i >= 6) {
            var c2 = parseInt(str.substr(i + 4, 2), 16);
            newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
          } else {
            newStr += str.substr(i, 6);
          }
          i += 6;
        } else if (c >= 224) {
          if (il - i >= 9) {
            var _c = parseInt(str.substr(i + 4, 2), 16);
            var c3 = parseInt(str.substr(i + 7, 2), 16);
            newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
          } else {
            newStr += str.substr(i, 9);
          }
          i += 9;
        } else {
          newStr += str.substr(i, 3);
          i += 3;
        }
      }
      return newStr;
    }
    function _normalizeComponentEncoding(components, protocol) {
      function decodeUnreserved2(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
      }
      if (components.scheme)
        components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
      if (components.userinfo !== void 0)
        components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.host !== void 0)
        components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.path !== void 0)
        components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.query !== void 0)
        components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.fragment !== void 0)
        components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      return components;
    }
    function _stripLeadingZeros(str) {
      return str.replace(/^0*(.*)/, "$1") || "0";
    }
    function _normalizeIPv4(host, protocol) {
      var matches = host.match(protocol.IPV4ADDRESS) || [];
      var _matches = slicedToArray(matches, 2), address = _matches[1];
      if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
      } else {
        return host;
      }
    }
    function _normalizeIPv6(host, protocol) {
      var matches = host.match(protocol.IPV6ADDRESS) || [];
      var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
      if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last2 = _address$toLowerCase$2[0], first2 = _address$toLowerCase$2[1];
        var firstFields = first2 ? first2.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last2.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
          fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
        }
        if (isLastFieldIPv4Address) {
          fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function(acc, field, index) {
          if (!field || field === "0") {
            var lastLongest = acc[acc.length - 1];
            if (lastLongest && lastLongest.index + lastLongest.length === index) {
              lastLongest.length++;
            } else {
              acc.push({ index, length: 1 });
            }
          }
          return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function(a, b) {
          return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
          var newFirst = fields.slice(0, longestZeroFields.index);
          var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
          newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
          newHost = fields.join(":");
        }
        if (zone) {
          newHost += "%" + zone;
        }
        return newHost;
      } else {
        return host;
      }
    }
    var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
    var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
    function parse2(uriString) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var components = {};
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      if (options.reference === "suffix")
        uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
      var matches = uriString.match(URI_PARSE);
      if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
          components.scheme = matches[1];
          components.userinfo = matches[3];
          components.host = matches[4];
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = matches[7];
          components.fragment = matches[8];
          if (isNaN(components.port)) {
            components.port = matches[5];
          }
        } else {
          components.scheme = matches[1] || void 0;
          components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
          components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
          components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
          if (isNaN(components.port)) {
            components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
          }
        }
        if (components.host) {
          components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
          components.reference = "same-document";
        } else if (components.scheme === void 0) {
          components.reference = "relative";
        } else if (components.fragment === void 0) {
          components.reference = "absolute";
        } else {
          components.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
          components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
            try {
              components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
            }
          }
          _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
          _normalizeComponentEncoding(components, protocol);
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(components, options);
        }
      } else {
        components.error = components.error || "URI can not be parsed.";
      }
      return components;
    }
    function _recomposeAuthority(components, options) {
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
          return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    var RDS1 = /^\.\.?\//;
    var RDS2 = /^\/\.(\/|$)/;
    var RDS3 = /^\/\.\.(\/|$)/;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
    function removeDotSegments(input) {
      var output = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          var im = input.match(RDS5);
          if (im) {
            var s = im[0];
            input = input.slice(s.length);
            output.push(s);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output.join("");
    }
    function serialize(components) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize)
        schemeHandler.serialize(components, options);
      if (components.host) {
        if (protocol.IPV6ADDRESS.test(components.host))
          ;
        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
          try {
            components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
          } catch (e) {
            components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
          }
        }
      }
      _normalizeComponentEncoding(components, protocol);
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
      }
      var authority = _recomposeAuthority(components, options);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        var s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0) {
          s = s.replace(/^\/\//, "/%2F");
        }
        uriTokens.push(s);
      }
      if (components.query !== void 0) {
        uriTokens.push("?");
        uriTokens.push(components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
      }
      return uriTokens.join("");
    }
    function resolveComponents(base2, relative) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var skipNormalization = arguments[3];
      var target = {};
      if (!skipNormalization) {
        base2 = parse2(serialize(base2, options), options);
        relative = parse2(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base2.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base2.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                target.path = "/" + relative.path;
              } else if (!base2.path) {
                target.path = relative.path;
              } else {
                target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base2.userinfo;
          target.host = base2.host;
          target.port = base2.port;
        }
        target.scheme = base2.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function resolve2(baseURI, relativeURI, options) {
      var schemelessOptions = assign({ scheme: "null" }, options);
      return serialize(resolveComponents(parse2(baseURI, schemelessOptions), parse2(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
    }
    function normalize(uri2, options) {
      if (typeof uri2 === "string") {
        uri2 = serialize(parse2(uri2, options), options);
      } else if (typeOf(uri2) === "object") {
        uri2 = parse2(serialize(uri2, options), options);
      }
      return uri2;
    }
    function equal3(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = serialize(parse2(uriA, options), options);
      } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
      }
      if (typeof uriB === "string") {
        uriB = serialize(parse2(uriB, options), options);
      } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
      }
      return uriA === uriB;
    }
    function escapeComponent(str, options) {
      return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
    }
    function unescapeComponent(str, options) {
      return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
    }
    var handler = {
      scheme: "http",
      domainHost: true,
      parse: function parse3(components, options) {
        if (!components.host) {
          components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
      },
      serialize: function serialize2(components, options) {
        var secure = String(components.scheme).toLowerCase() === "https";
        if (components.port === (secure ? 443 : 80) || components.port === "") {
          components.port = void 0;
        }
        if (!components.path) {
          components.path = "/";
        }
        return components;
      }
    };
    var handler$1 = {
      scheme: "https",
      domainHost: handler.domainHost,
      parse: handler.parse,
      serialize: handler.serialize
    };
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    var handler$2 = {
      scheme: "ws",
      domainHost: true,
      parse: function parse3(components, options) {
        var wsComponents = components;
        wsComponents.secure = isSecure(wsComponents);
        wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
        wsComponents.path = void 0;
        wsComponents.query = void 0;
        return wsComponents;
      },
      serialize: function serialize2(wsComponents, options) {
        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
          wsComponents.port = void 0;
        }
        if (typeof wsComponents.secure === "boolean") {
          wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
          wsComponents.secure = void 0;
        }
        if (wsComponents.resourceName) {
          var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
          wsComponents.path = path && path !== "/" ? path : void 0;
          wsComponents.query = query;
          wsComponents.resourceName = void 0;
        }
        wsComponents.fragment = void 0;
        return wsComponents;
      }
    };
    var handler$3 = {
      scheme: "wss",
      domainHost: handler$2.domainHost,
      parse: handler$2.parse,
      serialize: handler$2.serialize
    };
    var O = {};
    var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]";
    var HEXDIG$$ = "[0-9A-Fa-f]";
    var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
    var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
    var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
    var VCHAR$$ = merge2(QTEXT$$, '[\\"\\\\]');
    var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
    var UNRESERVED = new RegExp(UNRESERVED$$, "g");
    var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
    var NOT_LOCAL_PART = new RegExp(merge2("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
    var NOT_HFNAME = new RegExp(merge2("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
    var NOT_HFVALUE = NOT_HFNAME;
    function decodeUnreserved(str) {
      var decStr = pctDecChars(str);
      return !decStr.match(UNRESERVED) ? str : decStr;
    }
    var handler$4 = {
      scheme: "mailto",
      parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = void 0;
        if (mailtoComponents.query) {
          var unknownHeaders = false;
          var headers = {};
          var hfields = mailtoComponents.query.split("&");
          for (var x = 0, xl = hfields.length; x < xl; ++x) {
            var hfield = hfields[x].split("=");
            switch (hfield[0]) {
              case "to":
                var toAddrs = hfield[1].split(",");
                for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                  to.push(toAddrs[_x]);
                }
                break;
              case "subject":
                mailtoComponents.subject = unescapeComponent(hfield[1], options);
                break;
              case "body":
                mailtoComponents.body = unescapeComponent(hfield[1], options);
                break;
              default:
                unknownHeaders = true;
                headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                break;
            }
          }
          if (unknownHeaders)
            mailtoComponents.headers = headers;
        }
        mailtoComponents.query = void 0;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
          var addr = to[_x2].split("@");
          addr[0] = unescapeComponent(addr[0]);
          if (!options.unicodeSupport) {
            try {
              addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
            } catch (e) {
              mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
            }
          } else {
            addr[1] = unescapeComponent(addr[1], options).toLowerCase();
          }
          to[_x2] = addr.join("@");
        }
        return mailtoComponents;
      },
      serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray2(mailtoComponents.to);
        if (to) {
          for (var x = 0, xl = to.length; x < xl; ++x) {
            var toAddr = String(to[x]);
            var atIdx = toAddr.lastIndexOf("@");
            var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
            var domain = toAddr.slice(atIdx + 1);
            try {
              domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
            } catch (e) {
              components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
            to[x] = localPart + "@" + domain;
          }
          components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject)
          headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body)
          headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name2 in headers) {
          if (headers[name2] !== O[name2]) {
            fields.push(name2.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name2].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
          }
        }
        if (fields.length) {
          components.query = fields.join("&");
        }
        return components;
      }
    };
    var URN_PARSE = /^([^\:]+)\:(.*)/;
    var handler$5 = {
      scheme: "urn",
      parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = matches[1].toLowerCase();
          var nss = matches[2];
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          urnComponents.nid = nid;
          urnComponents.nss = nss;
          urnComponents.path = void 0;
          if (schemeHandler) {
            urnComponents = schemeHandler.parse(urnComponents, options);
          }
        } else {
          urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
      },
      serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
          urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
      }
    };
    var UUID2 = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
    var handler$6 = {
      scheme: "urn:uuid",
      parse: function parse3(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = void 0;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID2))) {
          uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
      },
      serialize: function serialize2(uuidComponents, options) {
        var urnComponents = uuidComponents;
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
      }
    };
    SCHEMES[handler.scheme] = handler;
    SCHEMES[handler$1.scheme] = handler$1;
    SCHEMES[handler$2.scheme] = handler$2;
    SCHEMES[handler$3.scheme] = handler$3;
    SCHEMES[handler$4.scheme] = handler$4;
    SCHEMES[handler$5.scheme] = handler$5;
    SCHEMES[handler$6.scheme] = handler$6;
    exports2.SCHEMES = SCHEMES;
    exports2.pctEncChar = pctEncChar;
    exports2.pctDecChars = pctDecChars;
    exports2.parse = parse2;
    exports2.removeDotSegments = removeDotSegments;
    exports2.serialize = serialize;
    exports2.resolveComponents = resolveComponents;
    exports2.resolve = resolve2;
    exports2.normalize = normalize;
    exports2.equal = equal3;
    exports2.escapeComponent = escapeComponent;
    exports2.unescapeComponent = unescapeComponent;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
})(uri_all, uri_all.exports);
var fastDeepEqual = function equal(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    if (a.constructor !== b.constructor)
      return false;
    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!equal(a[i], b[i]))
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
        return false;
    for (i = length; i-- !== 0; ) {
      var key = keys[i];
      if (!equal(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
};
var ucs2length$1 = function ucs2length(str) {
  var length = 0, len = str.length, pos = 0, value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 55296 && value <= 56319 && pos < len) {
      value = str.charCodeAt(pos);
      if ((value & 64512) == 56320)
        pos++;
    }
  }
  return length;
};
var util$6 = {
  copy,
  checkDataType,
  checkDataTypes,
  coerceToTypes,
  toHash: toHash$1,
  getProperty,
  escapeQuotes,
  equal: fastDeepEqual,
  ucs2length: ucs2length$1,
  varOccurences,
  varReplace,
  schemaHasRules,
  schemaHasRulesExcept,
  schemaUnknownRules,
  toQuotedString,
  getPathExpr,
  getPath,
  getData,
  unescapeFragment,
  unescapeJsonPointer,
  escapeFragment,
  escapeJsonPointer
};
function copy(o, to) {
  to = to || {};
  for (var key in o)
    to[key] = o[key];
  return to;
}
function checkDataType(dataType, data2, strictNumbers, negate2) {
  var EQUAL = negate2 ? " !== " : " === ", AND = negate2 ? " || " : " && ", OK = negate2 ? "!" : "", NOT = negate2 ? "" : "!";
  switch (dataType) {
    case "null":
      return data2 + EQUAL + "null";
    case "array":
      return OK + "Array.isArray(" + data2 + ")";
    case "object":
      return "(" + OK + data2 + AND + "typeof " + data2 + EQUAL + '"object"' + AND + NOT + "Array.isArray(" + data2 + "))";
    case "integer":
      return "(typeof " + data2 + EQUAL + '"number"' + AND + NOT + "(" + data2 + " % 1)" + AND + data2 + EQUAL + data2 + (strictNumbers ? AND + OK + "isFinite(" + data2 + ")" : "") + ")";
    case "number":
      return "(typeof " + data2 + EQUAL + '"' + dataType + '"' + (strictNumbers ? AND + OK + "isFinite(" + data2 + ")" : "") + ")";
    default:
      return "typeof " + data2 + EQUAL + '"' + dataType + '"';
  }
}
function checkDataTypes(dataTypes, data2, strictNumbers) {
  switch (dataTypes.length) {
    case 1:
      return checkDataType(dataTypes[0], data2, strictNumbers, true);
    default:
      var code = "";
      var types = toHash$1(dataTypes);
      if (types.array && types.object) {
        code = types.null ? "(" : "(!" + data2 + " || ";
        code += "typeof " + data2 + ' !== "object")';
        delete types.null;
        delete types.array;
        delete types.object;
      }
      if (types.number)
        delete types.integer;
      for (var t in types)
        code += (code ? " && " : "") + checkDataType(t, data2, strictNumbers, true);
      return code;
  }
}
var COERCE_TO_TYPES = toHash$1(["string", "number", "integer", "boolean", "null"]);
function coerceToTypes(optionCoerceTypes, dataTypes) {
  if (Array.isArray(dataTypes)) {
    var types = [];
    for (var i = 0; i < dataTypes.length; i++) {
      var t = dataTypes[i];
      if (COERCE_TO_TYPES[t])
        types[types.length] = t;
      else if (optionCoerceTypes === "array" && t === "array")
        types[types.length] = t;
    }
    if (types.length)
      return types;
  } else if (COERCE_TO_TYPES[dataTypes]) {
    return [dataTypes];
  } else if (optionCoerceTypes === "array" && dataTypes === "array") {
    return ["array"];
  }
}
function toHash$1(arr) {
  var hash = {};
  for (var i = 0; i < arr.length; i++)
    hash[arr[i]] = true;
  return hash;
}
var IDENTIFIER$1 = /^[a-z$_][a-z$_0-9]*$/i;
var SINGLE_QUOTE = /'|\\/g;
function getProperty(key) {
  return typeof key == "number" ? "[" + key + "]" : IDENTIFIER$1.test(key) ? "." + key : "['" + escapeQuotes(key) + "']";
}
function escapeQuotes(str) {
  return str.replace(SINGLE_QUOTE, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
}
function varOccurences(str, dataVar) {
  dataVar += "[^0-9]";
  var matches = str.match(new RegExp(dataVar, "g"));
  return matches ? matches.length : 0;
}
function varReplace(str, dataVar, expr) {
  dataVar += "([^0-9])";
  expr = expr.replace(/\$/g, "$$$$");
  return str.replace(new RegExp(dataVar, "g"), expr + "$1");
}
function schemaHasRules(schema, rules3) {
  if (typeof schema == "boolean")
    return !schema;
  for (var key in schema)
    if (rules3[key])
      return true;
}
function schemaHasRulesExcept(schema, rules3, exceptKeyword) {
  if (typeof schema == "boolean")
    return !schema && exceptKeyword != "not";
  for (var key in schema)
    if (key != exceptKeyword && rules3[key])
      return true;
}
function schemaUnknownRules(schema, rules3) {
  if (typeof schema == "boolean")
    return;
  for (var key in schema)
    if (!rules3[key])
      return key;
}
function toQuotedString(str) {
  return "'" + escapeQuotes(str) + "'";
}
function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
  var path = jsonPointers ? "'/' + " + expr + (isNumber ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : isNumber ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'";
  return joinPaths(currentPath, path);
}
function getPath(currentPath, prop, jsonPointers) {
  var path = jsonPointers ? toQuotedString("/" + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
  return joinPaths(currentPath, path);
}
var JSON_POINTER$1 = /^\/(?:[^~]|~0|~1)*$/;
var RELATIVE_JSON_POINTER$1 = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, lvl, paths) {
  var up, jsonPointer, data2, matches;
  if ($data === "")
    return "rootData";
  if ($data[0] == "/") {
    if (!JSON_POINTER$1.test($data))
      throw new Error("Invalid JSON-pointer: " + $data);
    jsonPointer = $data;
    data2 = "rootData";
  } else {
    matches = $data.match(RELATIVE_JSON_POINTER$1);
    if (!matches)
      throw new Error("Invalid JSON-pointer: " + $data);
    up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer == "#") {
      if (up >= lvl)
        throw new Error("Cannot access property/index " + up + " levels up, current level is " + lvl);
      return paths[lvl - up];
    }
    if (up > lvl)
      throw new Error("Cannot access data " + up + " levels up, current level is " + lvl);
    data2 = "data" + (lvl - up || "");
    if (!jsonPointer)
      return data2;
  }
  var expr = data2;
  var segments = jsonPointer.split("/");
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (segment) {
      data2 += getProperty(unescapeJsonPointer(segment));
      expr += " && " + data2;
    }
  }
  return expr;
}
function joinPaths(a, b) {
  if (a == '""')
    return b;
  return (a + " + " + b).replace(/([^\\])' \+ '/g, "$1");
}
function unescapeFragment(str) {
  return unescapeJsonPointer(decodeURIComponent(str));
}
function escapeFragment(str) {
  return encodeURIComponent(escapeJsonPointer(str));
}
function escapeJsonPointer(str) {
  return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
function unescapeJsonPointer(str) {
  return str.replace(/~1/g, "/").replace(/~0/g, "~");
}
var util$5 = util$6;
var schema_obj = SchemaObject$2;
function SchemaObject$2(obj) {
  util$5.copy(obj, this);
}
var jsonSchemaTraverse = { exports: {} };
var traverse$1 = jsonSchemaTraverse.exports = function(schema, opts, cb) {
  if (typeof opts == "function") {
    cb = opts;
    opts = {};
  }
  cb = opts.cb || cb;
  var pre = typeof cb == "function" ? cb : cb.pre || function() {
  };
  var post = cb.post || function() {
  };
  _traverse(opts, pre, post, schema, "", schema);
};
traverse$1.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true
};
traverse$1.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};
traverse$1.propsKeywords = {
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};
traverse$1.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};
function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == "object" && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse$1.arrayKeywords) {
          for (var i = 0; i < sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse$1.propsKeywords) {
        if (sch && typeof sch == "object") {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse$1.keywords || opts.allKeys && !(key in traverse$1.skipKeywords)) {
        _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}
function escapeJsonPtr(str) {
  return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
var URI$1 = uri_all.exports, equal$1 = fastDeepEqual, util$4 = util$6, SchemaObject$1 = schema_obj, traverse = jsonSchemaTraverse.exports;
var resolve_1 = resolve$3;
resolve$3.normalizeId = normalizeId;
resolve$3.fullPath = getFullPath;
resolve$3.url = resolveUrl;
resolve$3.ids = resolveIds;
resolve$3.inlineRef = inlineRef;
resolve$3.schema = resolveSchema;
function resolve$3(compile2, root, ref2) {
  var refVal = this._refs[ref2];
  if (typeof refVal == "string") {
    if (this._refs[refVal])
      refVal = this._refs[refVal];
    else
      return resolve$3.call(this, compile2, root, refVal);
  }
  refVal = refVal || this._schemas[ref2];
  if (refVal instanceof SchemaObject$1) {
    return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
  }
  var res = resolveSchema.call(this, root, ref2);
  var schema, v, baseId;
  if (res) {
    schema = res.schema;
    root = res.root;
    baseId = res.baseId;
  }
  if (schema instanceof SchemaObject$1) {
    v = schema.validate || compile2.call(this, schema.schema, root, void 0, baseId);
  } else if (schema !== void 0) {
    v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile2.call(this, schema, root, void 0, baseId);
  }
  return v;
}
function resolveSchema(root, ref2) {
  var p = URI$1.parse(ref2), refPath = _getFullPath(p), baseId = getFullPath(this._getId(root.schema));
  if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
    var id = normalizeId(refPath);
    var refVal = this._refs[id];
    if (typeof refVal == "string") {
      return resolveRecursive.call(this, root, refVal, p);
    } else if (refVal instanceof SchemaObject$1) {
      if (!refVal.validate)
        this._compile(refVal);
      root = refVal;
    } else {
      refVal = this._schemas[id];
      if (refVal instanceof SchemaObject$1) {
        if (!refVal.validate)
          this._compile(refVal);
        if (id == normalizeId(ref2))
          return { schema: refVal, root, baseId };
        root = refVal;
      } else {
        return;
      }
    }
    if (!root.schema)
      return;
    baseId = getFullPath(this._getId(root.schema));
  }
  return getJsonPointer.call(this, p, baseId, root.schema, root);
}
function resolveRecursive(root, ref2, parsedRef) {
  var res = resolveSchema.call(this, root, ref2);
  if (res) {
    var schema = res.schema;
    var baseId = res.baseId;
    root = res.root;
    var id = this._getId(schema);
    if (id)
      baseId = resolveUrl(baseId, id);
    return getJsonPointer.call(this, parsedRef, baseId, schema, root);
  }
}
var PREVENT_SCOPE_CHANGE = util$4.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
function getJsonPointer(parsedRef, baseId, schema, root) {
  parsedRef.fragment = parsedRef.fragment || "";
  if (parsedRef.fragment.slice(0, 1) != "/")
    return;
  var parts = parsedRef.fragment.split("/");
  for (var i = 1; i < parts.length; i++) {
    var part = parts[i];
    if (part) {
      part = util$4.unescapeFragment(part);
      schema = schema[part];
      if (schema === void 0)
        break;
      var id;
      if (!PREVENT_SCOPE_CHANGE[part]) {
        id = this._getId(schema);
        if (id)
          baseId = resolveUrl(baseId, id);
        if (schema.$ref) {
          var $ref2 = resolveUrl(baseId, schema.$ref);
          var res = resolveSchema.call(this, root, $ref2);
          if (res) {
            schema = res.schema;
            root = res.root;
            baseId = res.baseId;
          }
        }
      }
    }
  }
  if (schema !== void 0 && schema !== root.schema)
    return { schema, root, baseId };
}
var SIMPLE_INLINED = util$4.toHash([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum"
]);
function inlineRef(schema, limit) {
  if (limit === false)
    return false;
  if (limit === void 0 || limit === true)
    return checkNoRef(schema);
  else if (limit)
    return countKeys(schema) <= limit;
}
function checkNoRef(schema) {
  var item;
  if (Array.isArray(schema)) {
    for (var i = 0; i < schema.length; i++) {
      item = schema[i];
      if (typeof item == "object" && !checkNoRef(item))
        return false;
    }
  } else {
    for (var key in schema) {
      if (key == "$ref")
        return false;
      item = schema[key];
      if (typeof item == "object" && !checkNoRef(item))
        return false;
    }
  }
  return true;
}
function countKeys(schema) {
  var count2 = 0, item;
  if (Array.isArray(schema)) {
    for (var i = 0; i < schema.length; i++) {
      item = schema[i];
      if (typeof item == "object")
        count2 += countKeys(item);
      if (count2 == Infinity)
        return Infinity;
    }
  } else {
    for (var key in schema) {
      if (key == "$ref")
        return Infinity;
      if (SIMPLE_INLINED[key]) {
        count2++;
      } else {
        item = schema[key];
        if (typeof item == "object")
          count2 += countKeys(item) + 1;
        if (count2 == Infinity)
          return Infinity;
      }
    }
  }
  return count2;
}
function getFullPath(id, normalize) {
  if (normalize !== false)
    id = normalizeId(id);
  var p = URI$1.parse(id);
  return _getFullPath(p);
}
function _getFullPath(p) {
  return URI$1.serialize(p).split("#")[0] + "#";
}
var TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
  return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
}
function resolveUrl(baseId, id) {
  id = normalizeId(id);
  return URI$1.resolve(baseId, id);
}
function resolveIds(schema) {
  var schemaId = normalizeId(this._getId(schema));
  var baseIds = { "": schemaId };
  var fullPaths = { "": getFullPath(schemaId, false) };
  var localRefs = {};
  var self2 = this;
  traverse(schema, { allKeys: true }, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (jsonPtr === "")
      return;
    var id = self2._getId(sch);
    var baseId = baseIds[parentJsonPtr];
    var fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
    if (keyIndex !== void 0)
      fullPath += "/" + (typeof keyIndex == "number" ? keyIndex : util$4.escapeFragment(keyIndex));
    if (typeof id == "string") {
      id = baseId = normalizeId(baseId ? URI$1.resolve(baseId, id) : id);
      var refVal = self2._refs[id];
      if (typeof refVal == "string")
        refVal = self2._refs[refVal];
      if (refVal && refVal.schema) {
        if (!equal$1(sch, refVal.schema))
          throw new Error('id "' + id + '" resolves to more than one schema');
      } else if (id != normalizeId(fullPath)) {
        if (id[0] == "#") {
          if (localRefs[id] && !equal$1(sch, localRefs[id]))
            throw new Error('id "' + id + '" resolves to more than one schema');
          localRefs[id] = sch;
        } else {
          self2._refs[id] = fullPath;
        }
      }
    }
    baseIds[jsonPtr] = baseId;
    fullPaths[jsonPtr] = fullPath;
  });
  return localRefs;
}
var resolve$2 = resolve_1;
var error_classes = {
  Validation: errorSubclass(ValidationError$1),
  MissingRef: errorSubclass(MissingRefError$1)
};
function ValidationError$1(errors) {
  this.message = "validation failed";
  this.errors = errors;
  this.ajv = this.validation = true;
}
MissingRefError$1.message = function(baseId, ref2) {
  return "can't resolve reference " + ref2 + " from id " + baseId;
};
function MissingRefError$1(baseId, ref2, message) {
  this.message = message || MissingRefError$1.message(baseId, ref2);
  this.missingRef = resolve$2.url(baseId, ref2);
  this.missingSchema = resolve$2.normalizeId(resolve$2.fullPath(this.missingRef));
}
function errorSubclass(Subclass) {
  Subclass.prototype = Object.create(Error.prototype);
  Subclass.prototype.constructor = Subclass;
  return Subclass;
}
var fastJsonStableStringify = function(data2, opts) {
  if (!opts)
    opts = {};
  if (typeof opts === "function")
    opts = { cmp: opts };
  var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
  var cmp = opts.cmp && function(f2) {
    return function(node) {
      return function(a, b) {
        var aobj = { key: a, value: node[a] };
        var bobj = { key: b, value: node[b] };
        return f2(aobj, bobj);
      };
    };
  }(opts.cmp);
  var seen = [];
  return function stringify2(node) {
    if (node && node.toJSON && typeof node.toJSON === "function") {
      node = node.toJSON();
    }
    if (node === void 0)
      return;
    if (typeof node == "number")
      return isFinite(node) ? "" + node : "null";
    if (typeof node !== "object")
      return JSON.stringify(node);
    var i, out;
    if (Array.isArray(node)) {
      out = "[";
      for (i = 0; i < node.length; i++) {
        if (i)
          out += ",";
        out += stringify2(node[i]) || "null";
      }
      return out + "]";
    }
    if (node === null)
      return "null";
    if (seen.indexOf(node) !== -1) {
      if (cycles)
        return JSON.stringify("__cycle__");
      throw new TypeError("Converting circular structure to JSON");
    }
    var seenIndex = seen.push(node) - 1;
    var keys = Object.keys(node).sort(cmp && cmp(node));
    out = "";
    for (i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = stringify2(node[key]);
      if (!value)
        continue;
      if (out)
        out += ",";
      out += JSON.stringify(key) + ":" + value;
    }
    seen.splice(seenIndex, 1);
    return "{" + out + "}";
  }(data2);
};
var validate$1 = function generate_validate(it, $keyword, $ruleType) {
  var out = "";
  var $async = it.schema.$async === true, $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, "$ref"), $id2 = it.self._getId(it.schema);
  if (it.opts.strictKeywords) {
    var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
    if ($unknownKwd) {
      var $keywordsMsg = "unknown keyword: " + $unknownKwd;
      if (it.opts.strictKeywords === "log")
        it.logger.warn($keywordsMsg);
      else
        throw new Error($keywordsMsg);
    }
  }
  if (it.isTop) {
    out += " var validate = ";
    if ($async) {
      it.async = true;
      out += "async ";
    }
    out += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
    if ($id2 && (it.opts.sourceCode || it.opts.processCode)) {
      out += " " + ("/*# sourceURL=" + $id2 + " */") + " ";
    }
  }
  if (typeof it.schema == "boolean" || !($refKeywords || it.schema.$ref)) {
    var $keyword = "false schema";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    if (it.schema === false) {
      if (it.isTop) {
        $breakOnError = true;
      } else {
        out += " var " + $valid + " = false; ";
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "false schema") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: 'boolean schema is false' ";
        }
        if (it.opts.verbose) {
          out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
    } else {
      if (it.isTop) {
        if ($async) {
          out += " return data; ";
        } else {
          out += " validate.errors = null; return true; ";
        }
      } else {
        out += " var " + $valid + " = true; ";
      }
    }
    if (it.isTop) {
      out += " }; return validate; ";
    }
    return out;
  }
  if (it.isTop) {
    var $top = it.isTop, $lvl = it.level = 0, $dataLvl = it.dataLevel = 0, $data = "data";
    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
    it.baseId = it.baseId || it.rootId;
    delete it.isTop;
    it.dataPathArr = [""];
    if (it.schema.default !== void 0 && it.opts.useDefaults && it.opts.strictDefaults) {
      var $defaultMsg = "default is ignored in the schema root";
      if (it.opts.strictDefaults === "log")
        it.logger.warn($defaultMsg);
      else
        throw new Error($defaultMsg);
    }
    out += " var vErrors = null; ";
    out += " var errors = 0;     ";
    out += " if (rootData === undefined) rootData = data; ";
  } else {
    var $lvl = it.level, $dataLvl = it.dataLevel, $data = "data" + ($dataLvl || "");
    if ($id2)
      it.baseId = it.resolve.url(it.baseId, $id2);
    if ($async && !it.async)
      throw new Error("async schema in sync schema");
    out += " var errs_" + $lvl + " = errors;";
  }
  var $valid = "valid" + $lvl, $breakOnError = !it.opts.allErrors, $closingBraces1 = "", $closingBraces2 = "";
  var $errorKeyword;
  var $typeSchema = it.schema.type, $typeIsArray = Array.isArray($typeSchema);
  if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
    if ($typeIsArray) {
      if ($typeSchema.indexOf("null") == -1)
        $typeSchema = $typeSchema.concat("null");
    } else if ($typeSchema != "null") {
      $typeSchema = [$typeSchema, "null"];
      $typeIsArray = true;
    }
  }
  if ($typeIsArray && $typeSchema.length == 1) {
    $typeSchema = $typeSchema[0];
    $typeIsArray = false;
  }
  if (it.schema.$ref && $refKeywords) {
    if (it.opts.extendRefs == "fail") {
      throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
    } else if (it.opts.extendRefs !== true) {
      $refKeywords = false;
      it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
    }
  }
  if (it.schema.$comment && it.opts.$comment) {
    out += " " + it.RULES.all.$comment.code(it, "$comment");
  }
  if ($typeSchema) {
    if (it.opts.coerceTypes) {
      var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
    }
    var $rulesGroup = it.RULES.types[$typeSchema];
    if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
      var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
      var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type", $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
      out += " if (" + it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true) + ") { ";
      if ($coerceToTypes) {
        var $dataType = "dataType" + $lvl, $coerced = "coerced" + $lvl;
        out += " var " + $dataType + " = typeof " + $data + "; var " + $coerced + " = undefined; ";
        if (it.opts.coerceTypes == "array") {
          out += " if (" + $dataType + " == 'object' && Array.isArray(" + $data + ") && " + $data + ".length == 1) { " + $data + " = " + $data + "[0]; " + $dataType + " = typeof " + $data + "; if (" + it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers) + ") " + $coerced + " = " + $data + "; } ";
        }
        out += " if (" + $coerced + " !== undefined) ; ";
        var arr1 = $coerceToTypes;
        if (arr1) {
          var $type, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $type = arr1[$i += 1];
            if ($type == "string") {
              out += " else if (" + $dataType + " == 'number' || " + $dataType + " == 'boolean') " + $coerced + " = '' + " + $data + "; else if (" + $data + " === null) " + $coerced + " = ''; ";
            } else if ($type == "number" || $type == "integer") {
              out += " else if (" + $dataType + " == 'boolean' || " + $data + " === null || (" + $dataType + " == 'string' && " + $data + " && " + $data + " == +" + $data + " ";
              if ($type == "integer") {
                out += " && !(" + $data + " % 1)";
              }
              out += ")) " + $coerced + " = +" + $data + "; ";
            } else if ($type == "boolean") {
              out += " else if (" + $data + " === 'false' || " + $data + " === 0 || " + $data + " === null) " + $coerced + " = false; else if (" + $data + " === 'true' || " + $data + " === 1) " + $coerced + " = true; ";
            } else if ($type == "null") {
              out += " else if (" + $data + " === '' || " + $data + " === 0 || " + $data + " === false) " + $coerced + " = null; ";
            } else if (it.opts.coerceTypes == "array" && $type == "array") {
              out += " else if (" + $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " + $data + " == null) " + $coerced + " = [" + $data + "]; ";
            }
          }
        }
        out += " else {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
          if ($typeIsArray) {
            out += "" + $typeSchema.join(",");
          } else {
            out += "" + $typeSchema;
          }
          out += "' } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should be ";
            if ($typeIsArray) {
              out += "" + $typeSchema.join(",");
            } else {
              out += "" + $typeSchema;
            }
            out += "' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } if (" + $coerced + " !== undefined) {  ";
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " " + $data + " = " + $coerced + "; ";
        if (!$dataLvl) {
          out += "if (" + $parentData + " !== undefined)";
        }
        out += " " + $parentData + "[" + $parentDataProperty + "] = " + $coerced + "; } ";
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
          if ($typeIsArray) {
            out += "" + $typeSchema.join(",");
          } else {
            out += "" + $typeSchema;
          }
          out += "' } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should be ";
            if ($typeIsArray) {
              out += "" + $typeSchema.join(",");
            } else {
              out += "" + $typeSchema;
            }
            out += "' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
      }
      out += " } ";
    }
  }
  if (it.schema.$ref && !$refKeywords) {
    out += " " + it.RULES.all.$ref.code(it, "$ref") + " ";
    if ($breakOnError) {
      out += " } if (errors === ";
      if ($top) {
        out += "0";
      } else {
        out += "errs_" + $lvl;
      }
      out += ") { ";
      $closingBraces2 += "}";
    }
  } else {
    var arr2 = it.RULES;
    if (arr2) {
      var $rulesGroup, i2 = -1, l2 = arr2.length - 1;
      while (i2 < l2) {
        $rulesGroup = arr2[i2 += 1];
        if ($shouldUseGroup($rulesGroup)) {
          if ($rulesGroup.type) {
            out += " if (" + it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers) + ") { ";
          }
          if (it.opts.useDefaults) {
            if ($rulesGroup.type == "object" && it.schema.properties) {
              var $schema2 = it.schema.properties, $schemaKeys = Object.keys($schema2);
              var arr3 = $schemaKeys;
              if (arr3) {
                var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                while (i3 < l3) {
                  $propertyKey = arr3[i3 += 1];
                  var $sch = $schema2[$propertyKey];
                  if ($sch.default !== void 0) {
                    var $passData = $data + it.util.getProperty($propertyKey);
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = "default is ignored for: " + $passData;
                        if (it.opts.strictDefaults === "log")
                          it.logger.warn($defaultMsg);
                        else
                          throw new Error($defaultMsg);
                      }
                    } else {
                      out += " if (" + $passData + " === undefined ";
                      if (it.opts.useDefaults == "empty") {
                        out += " || " + $passData + " === null || " + $passData + " === '' ";
                      }
                      out += " ) " + $passData + " = ";
                      if (it.opts.useDefaults == "shared") {
                        out += " " + it.useDefault($sch.default) + " ";
                      } else {
                        out += " " + JSON.stringify($sch.default) + " ";
                      }
                      out += "; ";
                    }
                  }
                }
              }
            } else if ($rulesGroup.type == "array" && Array.isArray(it.schema.items)) {
              var arr4 = it.schema.items;
              if (arr4) {
                var $sch, $i = -1, l4 = arr4.length - 1;
                while ($i < l4) {
                  $sch = arr4[$i += 1];
                  if ($sch.default !== void 0) {
                    var $passData = $data + "[" + $i + "]";
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = "default is ignored for: " + $passData;
                        if (it.opts.strictDefaults === "log")
                          it.logger.warn($defaultMsg);
                        else
                          throw new Error($defaultMsg);
                      }
                    } else {
                      out += " if (" + $passData + " === undefined ";
                      if (it.opts.useDefaults == "empty") {
                        out += " || " + $passData + " === null || " + $passData + " === '' ";
                      }
                      out += " ) " + $passData + " = ";
                      if (it.opts.useDefaults == "shared") {
                        out += " " + it.useDefault($sch.default) + " ";
                      } else {
                        out += " " + JSON.stringify($sch.default) + " ";
                      }
                      out += "; ";
                    }
                  }
                }
              }
            }
          }
          var arr5 = $rulesGroup.rules;
          if (arr5) {
            var $rule, i5 = -1, l5 = arr5.length - 1;
            while (i5 < l5) {
              $rule = arr5[i5 += 1];
              if ($shouldUseRule($rule)) {
                var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                if ($code) {
                  out += " " + $code + " ";
                  if ($breakOnError) {
                    $closingBraces1 += "}";
                  }
                }
              }
            }
          }
          if ($breakOnError) {
            out += " " + $closingBraces1 + " ";
            $closingBraces1 = "";
          }
          if ($rulesGroup.type) {
            out += " } ";
            if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
              out += " else { ";
              var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: 'should be ";
                  if ($typeIsArray) {
                    out += "" + $typeSchema.join(",");
                  } else {
                    out += "" + $typeSchema;
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              out += " } ";
            }
          }
          if ($breakOnError) {
            out += " if (errors === ";
            if ($top) {
              out += "0";
            } else {
              out += "errs_" + $lvl;
            }
            out += ") { ";
            $closingBraces2 += "}";
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += " " + $closingBraces2 + " ";
  }
  if ($top) {
    if ($async) {
      out += " if (errors === 0) return data;           ";
      out += " else throw new ValidationError(vErrors); ";
    } else {
      out += " validate.errors = vErrors; ";
      out += " return errors === 0;       ";
    }
    out += " }; return validate;";
  } else {
    out += " var " + $valid + " = errors === errs_" + $lvl + ";";
  }
  function $shouldUseGroup($rulesGroup2) {
    var rules3 = $rulesGroup2.rules;
    for (var i = 0; i < rules3.length; i++)
      if ($shouldUseRule(rules3[i]))
        return true;
  }
  function $shouldUseRule($rule2) {
    return it.schema[$rule2.keyword] !== void 0 || $rule2.implements && $ruleImplementsSomeKeyword($rule2);
  }
  function $ruleImplementsSomeKeyword($rule2) {
    var impl = $rule2.implements;
    for (var i = 0; i < impl.length; i++)
      if (it.schema[impl[i]] !== void 0)
        return true;
  }
  return out;
};
var resolve$1 = resolve_1, util$3 = util$6, errorClasses$1 = error_classes, stableStringify$1 = fastJsonStableStringify;
var validateGenerator = validate$1;
var ucs2length2 = util$3.ucs2length;
var equal2 = fastDeepEqual;
var ValidationError = errorClasses$1.Validation;
var compile_1 = compile$2;
function compile$2(schema, root, localRefs, baseId) {
  var self2 = this, opts = this._opts, refVal = [void 0], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];
  root = root || { schema, refVal, refs };
  var c = checkCompiling.call(this, schema, root, baseId);
  var compilation = this._compilations[c.index];
  if (c.compiling)
    return compilation.callValidate = callValidate;
  var formats2 = this._formats;
  var RULES = this.RULES;
  try {
    var v = localCompile(schema, root, localRefs, baseId);
    compilation.validate = v;
    var cv = compilation.callValidate;
    if (cv) {
      cv.schema = v.schema;
      cv.errors = null;
      cv.refs = v.refs;
      cv.refVal = v.refVal;
      cv.root = v.root;
      cv.$async = v.$async;
      if (opts.sourceCode)
        cv.source = v.source;
    }
    return v;
  } finally {
    endCompiling.call(this, schema, root, baseId);
  }
  function callValidate() {
    var validate2 = compilation.validate;
    var result = validate2.apply(this, arguments);
    callValidate.errors = validate2.errors;
    return result;
  }
  function localCompile(_schema, _root, localRefs2, baseId2) {
    var isRoot = !_root || _root && _root.schema == _schema;
    if (_root.schema != root.schema)
      return compile$2.call(self2, _schema, _root, localRefs2, baseId2);
    var $async = _schema.$async === true;
    var sourceCode = validateGenerator({
      isTop: true,
      schema: _schema,
      isRoot,
      baseId: baseId2,
      root: _root,
      schemaPath: "",
      errSchemaPath: "#",
      errorPath: '""',
      MissingRefError: errorClasses$1.MissingRef,
      RULES,
      validate: validateGenerator,
      util: util$3,
      resolve: resolve$1,
      resolveRef,
      usePattern,
      useDefault,
      useCustomRule,
      opts,
      formats: formats2,
      logger: self2.logger,
      self: self2
    });
    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode$1) + sourceCode;
    if (opts.processCode)
      sourceCode = opts.processCode(sourceCode, _schema);
    var validate2;
    try {
      var makeValidate = new Function("self", "RULES", "formats", "root", "refVal", "defaults", "customRules", "equal", "ucs2length", "ValidationError", sourceCode);
      validate2 = makeValidate(self2, RULES, formats2, root, refVal, defaults, customRules, equal2, ucs2length2, ValidationError);
      refVal[0] = validate2;
    } catch (e) {
      self2.logger.error("Error compiling schema, function code:", sourceCode);
      throw e;
    }
    validate2.schema = _schema;
    validate2.errors = null;
    validate2.refs = refs;
    validate2.refVal = refVal;
    validate2.root = isRoot ? validate2 : _root;
    if ($async)
      validate2.$async = true;
    if (opts.sourceCode === true) {
      validate2.source = {
        code: sourceCode,
        patterns,
        defaults
      };
    }
    return validate2;
  }
  function resolveRef(baseId2, ref2, isRoot) {
    ref2 = resolve$1.url(baseId2, ref2);
    var refIndex = refs[ref2];
    var _refVal, refCode;
    if (refIndex !== void 0) {
      _refVal = refVal[refIndex];
      refCode = "refVal[" + refIndex + "]";
      return resolvedRef(_refVal, refCode);
    }
    if (!isRoot && root.refs) {
      var rootRefId = root.refs[ref2];
      if (rootRefId !== void 0) {
        _refVal = root.refVal[rootRefId];
        refCode = addLocalRef(ref2, _refVal);
        return resolvedRef(_refVal, refCode);
      }
    }
    refCode = addLocalRef(ref2);
    var v2 = resolve$1.call(self2, localCompile, root, ref2);
    if (v2 === void 0) {
      var localSchema = localRefs && localRefs[ref2];
      if (localSchema) {
        v2 = resolve$1.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile$2.call(self2, localSchema, root, localRefs, baseId2);
      }
    }
    if (v2 === void 0) {
      removeLocalRef(ref2);
    } else {
      replaceLocalRef(ref2, v2);
      return resolvedRef(v2, refCode);
    }
  }
  function addLocalRef(ref2, v2) {
    var refId = refVal.length;
    refVal[refId] = v2;
    refs[ref2] = refId;
    return "refVal" + refId;
  }
  function removeLocalRef(ref2) {
    delete refs[ref2];
  }
  function replaceLocalRef(ref2, v2) {
    var refId = refs[ref2];
    refVal[refId] = v2;
  }
  function resolvedRef(refVal2, code) {
    return typeof refVal2 == "object" || typeof refVal2 == "boolean" ? { code, schema: refVal2, inline: true } : { code, $async: refVal2 && !!refVal2.$async };
  }
  function usePattern(regexStr) {
    var index = patternsHash[regexStr];
    if (index === void 0) {
      index = patternsHash[regexStr] = patterns.length;
      patterns[index] = regexStr;
    }
    return "pattern" + index;
  }
  function useDefault(value) {
    switch (typeof value) {
      case "boolean":
      case "number":
        return "" + value;
      case "string":
        return util$3.toQuotedString(value);
      case "object":
        if (value === null)
          return "null";
        var valueStr = stableStringify$1(value);
        var index = defaultsHash[valueStr];
        if (index === void 0) {
          index = defaultsHash[valueStr] = defaults.length;
          defaults[index] = value;
        }
        return "default" + index;
    }
  }
  function useCustomRule(rule, schema2, parentSchema, it) {
    if (self2._opts.validateSchema !== false) {
      var deps = rule.definition.dependencies;
      if (deps && !deps.every(function(keyword2) {
        return Object.prototype.hasOwnProperty.call(parentSchema, keyword2);
      }))
        throw new Error("parent schema must have all required keywords: " + deps.join(","));
      var validateSchema2 = rule.definition.validateSchema;
      if (validateSchema2) {
        var valid = validateSchema2(schema2);
        if (!valid) {
          var message = "keyword schema is invalid: " + self2.errorsText(validateSchema2.errors);
          if (self2._opts.validateSchema == "log")
            self2.logger.error(message);
          else
            throw new Error(message);
        }
      }
    }
    var compile2 = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;
    var validate2;
    if (compile2) {
      validate2 = compile2.call(self2, schema2, parentSchema, it);
    } else if (macro) {
      validate2 = macro.call(self2, schema2, parentSchema, it);
      if (opts.validateSchema !== false)
        self2.validateSchema(validate2, true);
    } else if (inline) {
      validate2 = inline.call(self2, it, rule.keyword, schema2, parentSchema);
    } else {
      validate2 = rule.definition.validate;
      if (!validate2)
        return;
    }
    if (validate2 === void 0)
      throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
    var index = customRules.length;
    customRules[index] = validate2;
    return {
      code: "customRule" + index,
      validate: validate2
    };
  }
}
function checkCompiling(schema, root, baseId) {
  var index = compIndex.call(this, schema, root, baseId);
  if (index >= 0)
    return { index, compiling: true };
  index = this._compilations.length;
  this._compilations[index] = {
    schema,
    root,
    baseId
  };
  return { index, compiling: false };
}
function endCompiling(schema, root, baseId) {
  var i = compIndex.call(this, schema, root, baseId);
  if (i >= 0)
    this._compilations.splice(i, 1);
}
function compIndex(schema, root, baseId) {
  for (var i = 0; i < this._compilations.length; i++) {
    var c = this._compilations[i];
    if (c.schema == schema && c.root == root && c.baseId == baseId)
      return i;
  }
  return -1;
}
function patternCode(i, patterns) {
  return "var pattern" + i + " = new RegExp(" + util$3.toQuotedString(patterns[i]) + ");";
}
function defaultCode(i) {
  return "var default" + i + " = defaults[" + i + "];";
}
function refValCode(i, refVal) {
  return refVal[i] === void 0 ? "" : "var refVal" + i + " = refVal[" + i + "];";
}
function customRuleCode$1(i) {
  return "var customRule" + i + " = customRules[" + i + "];";
}
function vars(arr, statement) {
  if (!arr.length)
    return "";
  var code = "";
  for (var i = 0; i < arr.length; i++)
    code += statement(i, arr);
  return code;
}
var cache = { exports: {} };
var Cache$1 = cache.exports = function Cache() {
  this._cache = {};
};
Cache$1.prototype.put = function Cache_put(key, value) {
  this._cache[key] = value;
};
Cache$1.prototype.get = function Cache_get(key) {
  return this._cache[key];
};
Cache$1.prototype.del = function Cache_del(key) {
  delete this._cache[key];
};
Cache$1.prototype.clear = function Cache_clear() {
  this._cache = {};
};
var util$2 = util$6;
var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
var URL$1 = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
var formats_1 = formats$1;
function formats$1(mode) {
  mode = mode == "full" ? "full" : "fast";
  return util$2.copy(formats$1[mode]);
}
formats$1.fast = {
  date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
  time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
  "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
  uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
  "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
  "uri-template": URITEMPLATE,
  url: URL$1,
  email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
  hostname: HOSTNAME,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex,
  uuid: UUID,
  "json-pointer": JSON_POINTER,
  "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
  "relative-json-pointer": RELATIVE_JSON_POINTER
};
formats$1.full = {
  date,
  time,
  "date-time": date_time,
  uri,
  "uri-reference": URIREF,
  "uri-template": URITEMPLATE,
  url: URL$1,
  email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: HOSTNAME,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex,
  uuid: UUID,
  "json-pointer": JSON_POINTER,
  "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
  "relative-json-pointer": RELATIVE_JSON_POINTER
};
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function date(str) {
  var matches = str.match(DATE);
  if (!matches)
    return false;
  var year = +matches[1];
  var month = +matches[2];
  var day = +matches[3];
  return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
}
function time(str, full) {
  var matches = str.match(TIME);
  if (!matches)
    return false;
  var hour = matches[1];
  var minute = matches[2];
  var second = matches[3];
  var timeZone = matches[5];
  return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
}
var DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
  var dateTime = str.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
}
var NOT_URI_FRAGMENT = /\/|:/;
function uri(str) {
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}
var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str))
    return false;
  try {
    new RegExp(str);
    return true;
  } catch (e) {
    return false;
  }
}
var ref = function generate_ref(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $async, $refCode;
  if ($schema2 == "#" || $schema2 == "#/") {
    if (it.isRoot) {
      $async = it.async;
      $refCode = "validate";
    } else {
      $async = it.root.schema.$async === true;
      $refCode = "root.refVal[0]";
    }
  } else {
    var $refVal = it.resolveRef(it.baseId, $schema2, it.isRoot);
    if ($refVal === void 0) {
      var $message = it.MissingRefError.message(it.baseId, $schema2);
      if (it.opts.missingRefs == "fail") {
        it.logger.error($message);
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '$ref' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { ref: '" + it.util.escapeQuotes($schema2) + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: 'can\\'t resolve reference " + it.util.escapeQuotes($schema2) + "' ";
          }
          if (it.opts.verbose) {
            out += " , schema: " + it.util.toQuotedString($schema2) + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        if ($breakOnError) {
          out += " if (false) { ";
        }
      } else if (it.opts.missingRefs == "ignore") {
        it.logger.warn($message);
        if ($breakOnError) {
          out += " if (true) { ";
        }
      } else {
        throw new it.MissingRefError(it.baseId, $schema2, $message);
      }
    } else if ($refVal.inline) {
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = "valid" + $it.level;
      $it.schema = $refVal.schema;
      $it.schemaPath = "";
      $it.errSchemaPath = $schema2;
      var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
      out += " " + $code + " ";
      if ($breakOnError) {
        out += " if (" + $nextValid + ") { ";
      }
    } else {
      $async = $refVal.$async === true || it.async && $refVal.$async !== false;
      $refCode = $refVal.code;
    }
  }
  if ($refCode) {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.opts.passContext) {
      out += " " + $refCode + ".call(this, ";
    } else {
      out += " " + $refCode + "( ";
    }
    out += " " + $data + ", (dataPath || '')";
    if (it.errorPath != '""') {
      out += " + " + it.errorPath;
    }
    var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
    out += " , " + $parentData + " , " + $parentDataProperty + ", rootData)  ";
    var __callValidate = out;
    out = $$outStack.pop();
    if ($async) {
      if (!it.async)
        throw new Error("async schema referenced by sync schema");
      if ($breakOnError) {
        out += " var " + $valid + "; ";
      }
      out += " try { await " + __callValidate + "; ";
      if ($breakOnError) {
        out += " " + $valid + " = true; ";
      }
      out += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ";
      if ($breakOnError) {
        out += " " + $valid + " = false; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " if (" + $valid + ") { ";
      }
    } else {
      out += " if (!" + __callValidate + ") { if (vErrors === null) vErrors = " + $refCode + ".errors; else vErrors = vErrors.concat(" + $refCode + ".errors); errors = vErrors.length; } ";
      if ($breakOnError) {
        out += " else { ";
      }
    }
  }
  return out;
};
var allOf = function generate_allOf(it, $keyword, $ruleType) {
  var out = " ";
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $it = it.util.copy(it);
  var $closingBraces = "";
  $it.level++;
  var $nextValid = "valid" + $it.level;
  var $currentBaseId = $it.baseId, $allSchemasEmpty = true;
  var arr1 = $schema2;
  if (arr1) {
    var $sch, $i = -1, l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
        $allSchemasEmpty = false;
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + "[" + $i + "]";
        $it.errSchemaPath = $errSchemaPath + "/" + $i;
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
    }
  }
  if ($breakOnError) {
    if ($allSchemasEmpty) {
      out += " if (true) { ";
    } else {
      out += " " + $closingBraces.slice(0, -1) + " ";
    }
  }
  return out;
};
var anyOf = function generate_anyOf(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = "";
  $it.level++;
  var $nextValid = "valid" + $it.level;
  var $noEmptySchema = $schema2.every(function($sch2) {
    return it.opts.strictKeywords ? typeof $sch2 == "object" && Object.keys($sch2).length > 0 || $sch2 === false : it.util.schemaHasRules($sch2, it.RULES.all);
  });
  if ($noEmptySchema) {
    var $currentBaseId = $it.baseId;
    out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema2;
    if (arr1) {
      var $sch, $i = -1, l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + "[" + $i + "]";
        $it.errSchemaPath = $errSchemaPath + "/" + $i;
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        out += " " + $valid + " = " + $valid + " || " + $nextValid + "; if (!" + $valid + ") { ";
        $closingBraces += "}";
      }
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += " " + $closingBraces + " if (!" + $valid + ") {   var err =   ";
    if (it.createErrors !== false) {
      out += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
      if (it.opts.messages !== false) {
        out += " , message: 'should match some schema in anyOf' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError(vErrors); ";
      } else {
        out += " validate.errors = vErrors; return false; ";
      }
    }
    out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
    if (it.opts.allErrors) {
      out += " } ";
    }
  } else {
    if ($breakOnError) {
      out += " if (true) { ";
    }
  }
  return out;
};
var comment = function generate_comment(it, $keyword, $ruleType) {
  var out = " ";
  var $schema2 = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  !it.opts.allErrors;
  var $comment = it.util.toQuotedString($schema2);
  if (it.opts.$comment === true) {
    out += " console.log(" + $comment + ");";
  } else if (typeof it.opts.$comment == "function") {
    out += " self._opts.$comment(" + $comment + ", " + it.util.toQuotedString($errSchemaPath) + ", validate.root.schema);";
  }
  return out;
};
var _const = function generate_const(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $isData = it.opts.$data && $schema2 && $schema2.$data;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
  }
  if (!$isData) {
    out += " var schema" + $lvl + " = validate.schema" + $schemaPath + ";";
  }
  out += "var " + $valid + " = equal(" + $data + ", schema" + $lvl + "); if (!" + $valid + ") {   ";
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: 'const' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValue: schema" + $lvl + " } ";
    if (it.opts.messages !== false) {
      out += " , message: 'should be equal to constant' ";
    }
    if (it.opts.verbose) {
      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += " }";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var contains = function generate_contains(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = "";
  $it.level++;
  var $nextValid = "valid" + $it.level;
  var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId, $nonEmptySchema = it.opts.strictKeywords ? typeof $schema2 == "object" && Object.keys($schema2).length > 0 || $schema2 === false : it.util.schemaHasRules($schema2, it.RULES.all);
  out += "var " + $errs + " = errors;var " + $valid + ";";
  if ($nonEmptySchema) {
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.schema = $schema2;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += " var " + $nextValid + " = false; for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + "[" + $idx + "]";
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
    } else {
      out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
    }
    out += " if (" + $nextValid + ") break; }  ";
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += " " + $closingBraces + " if (!" + $nextValid + ") {";
  } else {
    out += " if (" + $data + ".length == 0) {";
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: 'contains' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
    if (it.opts.messages !== false) {
      out += " , message: 'should contain a valid item' ";
    }
    if (it.opts.verbose) {
      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += " } else { ";
  if ($nonEmptySchema) {
    out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
  }
  if (it.opts.allErrors) {
    out += " } ";
  }
  return out;
};
var dependencies = function generate_dependencies(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = "";
  $it.level++;
  var $nextValid = "valid" + $it.level;
  var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it.opts.ownProperties;
  for ($property in $schema2) {
    if ($property == "__proto__")
      continue;
    var $sch = $schema2[$property];
    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
    $deps[$property] = $sch;
  }
  out += "var " + $errs + " = errors;";
  var $currentErrorPath = it.errorPath;
  out += "var missing" + $lvl + ";";
  for (var $property in $propertyDeps) {
    $deps = $propertyDeps[$property];
    if ($deps.length) {
      out += " if ( " + $data + it.util.getProperty($property) + " !== undefined ";
      if ($ownProperties) {
        out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
      }
      if ($breakOnError) {
        out += " && ( ";
        var arr1 = $deps;
        if (arr1) {
          var $propertyKey, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $propertyKey = arr1[$i += 1];
            if ($i) {
              out += " || ";
            }
            var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
            out += " ( ( " + $useData + " === undefined ";
            if ($ownProperties) {
              out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
            }
            out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
          }
        }
        out += ")) {  ";
        var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should have ";
            if ($deps.length == 1) {
              out += "property " + it.util.escapeQuotes($deps[0]);
            } else {
              out += "properties " + it.util.escapeQuotes($deps.join(", "));
            }
            out += " when property " + it.util.escapeQuotes($property) + " is present' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
      } else {
        out += " ) { ";
        var arr2 = $deps;
        if (arr2) {
          var $propertyKey, i2 = -1, l2 = arr2.length - 1;
          while (i2 < l2) {
            $propertyKey = arr2[i2 += 1];
            var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += " if ( " + $useData + " === undefined ";
            if ($ownProperties) {
              out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
            }
            out += ") {  var err =   ";
            if (it.createErrors !== false) {
              out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should have ";
                if ($deps.length == 1) {
                  out += "property " + it.util.escapeQuotes($deps[0]);
                } else {
                  out += "properties " + it.util.escapeQuotes($deps.join(", "));
                }
                out += " when property " + it.util.escapeQuotes($property) + " is present' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
          }
        }
      }
      out += " }   ";
      if ($breakOnError) {
        $closingBraces += "}";
        out += " else { ";
      }
    }
  }
  it.errorPath = $currentErrorPath;
  var $currentBaseId = $it.baseId;
  for (var $property in $schemaDeps) {
    var $sch = $schemaDeps[$property];
    if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
      out += " " + $nextValid + " = true; if ( " + $data + it.util.getProperty($property) + " !== undefined ";
      if ($ownProperties) {
        out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
      }
      out += ") { ";
      $it.schema = $sch;
      $it.schemaPath = $schemaPath + it.util.getProperty($property);
      $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($property);
      out += "  " + it.validate($it) + " ";
      $it.baseId = $currentBaseId;
      out += " }  ";
      if ($breakOnError) {
        out += " if (" + $nextValid + ") { ";
        $closingBraces += "}";
      }
    }
  }
  if ($breakOnError) {
    out += "   " + $closingBraces + " if (" + $errs + " == errors) {";
  }
  return out;
};
var _enum = function generate_enum(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $isData = it.opts.$data && $schema2 && $schema2.$data;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
  }
  var $i = "i" + $lvl, $vSchema = "schema" + $lvl;
  if (!$isData) {
    out += " var " + $vSchema + " = validate.schema" + $schemaPath + ";";
  }
  out += "var " + $valid + ";";
  if ($isData) {
    out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
  }
  out += "" + $valid + " = false;for (var " + $i + "=0; " + $i + "<" + $vSchema + ".length; " + $i + "++) if (equal(" + $data + ", " + $vSchema + "[" + $i + "])) { " + $valid + " = true; break; }";
  if ($isData) {
    out += "  }  ";
  }
  out += " if (!" + $valid + ") {   ";
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: 'enum' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValues: schema" + $lvl + " } ";
    if (it.opts.messages !== false) {
      out += " , message: 'should be equal to one of the allowed values' ";
    }
    if (it.opts.verbose) {
      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += " }";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var format = function generate_format(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  if (it.opts.format === false) {
    if ($breakOnError) {
      out += " if (true) { ";
    }
    return out;
  }
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  var $unknownFormats = it.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
  if ($isData) {
    var $format = "format" + $lvl, $isObject = "isObject" + $lvl, $formatType = "formatType" + $lvl;
    out += " var " + $format + " = formats[" + $schemaValue + "]; var " + $isObject + " = typeof " + $format + " == 'object' && !(" + $format + " instanceof RegExp) && " + $format + ".validate; var " + $formatType + " = " + $isObject + " && " + $format + ".type || 'string'; if (" + $isObject + ") { ";
    if (it.async) {
      out += " var async" + $lvl + " = " + $format + ".async; ";
    }
    out += " " + $format + " = " + $format + ".validate; } if (  ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
    }
    out += " (";
    if ($unknownFormats != "ignore") {
      out += " (" + $schemaValue + " && !" + $format + " ";
      if ($allowUnknown) {
        out += " && self._opts.unknownFormats.indexOf(" + $schemaValue + ") == -1 ";
      }
      out += ") || ";
    }
    out += " (" + $format + " && " + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ";
    if (it.async) {
      out += " (async" + $lvl + " ? await " + $format + "(" + $data + ") : " + $format + "(" + $data + ")) ";
    } else {
      out += " " + $format + "(" + $data + ") ";
    }
    out += " : " + $format + ".test(" + $data + "))))) {";
  } else {
    var $format = it.formats[$schema2];
    if (!$format) {
      if ($unknownFormats == "ignore") {
        it.logger.warn('unknown format "' + $schema2 + '" ignored in schema at path "' + it.errSchemaPath + '"');
        if ($breakOnError) {
          out += " if (true) { ";
        }
        return out;
      } else if ($allowUnknown && $unknownFormats.indexOf($schema2) >= 0) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
        return out;
      } else {
        throw new Error('unknown format "' + $schema2 + '" is used in schema at path "' + it.errSchemaPath + '"');
      }
    }
    var $isObject = typeof $format == "object" && !($format instanceof RegExp) && $format.validate;
    var $formatType = $isObject && $format.type || "string";
    if ($isObject) {
      var $async = $format.async === true;
      $format = $format.validate;
    }
    if ($formatType != $ruleType) {
      if ($breakOnError) {
        out += " if (true) { ";
      }
      return out;
    }
    if ($async) {
      if (!it.async)
        throw new Error("async format in sync schema");
      var $formatRef = "formats" + it.util.getProperty($schema2) + ".validate";
      out += " if (!(await " + $formatRef + "(" + $data + "))) { ";
    } else {
      out += " if (! ";
      var $formatRef = "formats" + it.util.getProperty($schema2);
      if ($isObject)
        $formatRef += ".validate";
      if (typeof $format == "function") {
        out += " " + $formatRef + "(" + $data + ") ";
      } else {
        out += " " + $formatRef + ".test(" + $data + ") ";
      }
      out += ") { ";
    }
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: 'format' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { format:  ";
    if ($isData) {
      out += "" + $schemaValue;
    } else {
      out += "" + it.util.toQuotedString($schema2);
    }
    out += "  } ";
    if (it.opts.messages !== false) {
      out += ` , message: 'should match format "`;
      if ($isData) {
        out += "' + " + $schemaValue + " + '";
      } else {
        out += "" + it.util.escapeQuotes($schema2);
      }
      out += `"' `;
    }
    if (it.opts.verbose) {
      out += " , schema:  ";
      if ($isData) {
        out += "validate.schema" + $schemaPath;
      } else {
        out += "" + it.util.toQuotedString($schema2);
      }
      out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += " } ";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var _if = function generate_if(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = "valid" + $it.level;
  var $thenSch = it.schema["then"], $elseSch = it.schema["else"], $thenPresent = $thenSch !== void 0 && (it.opts.strictKeywords ? typeof $thenSch == "object" && Object.keys($thenSch).length > 0 || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)), $elsePresent = $elseSch !== void 0 && (it.opts.strictKeywords ? typeof $elseSch == "object" && Object.keys($elseSch).length > 0 || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)), $currentBaseId = $it.baseId;
  if ($thenPresent || $elsePresent) {
    var $ifClause;
    $it.createErrors = false;
    $it.schema = $schema2;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += " var " + $errs + " = errors; var " + $valid + " = true;  ";
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    out += "  " + it.validate($it) + " ";
    $it.baseId = $currentBaseId;
    $it.createErrors = true;
    out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }  ";
    it.compositeRule = $it.compositeRule = $wasComposite;
    if ($thenPresent) {
      out += " if (" + $nextValid + ") {  ";
      $it.schema = it.schema["then"];
      $it.schemaPath = it.schemaPath + ".then";
      $it.errSchemaPath = it.errSchemaPath + "/then";
      out += "  " + it.validate($it) + " ";
      $it.baseId = $currentBaseId;
      out += " " + $valid + " = " + $nextValid + "; ";
      if ($thenPresent && $elsePresent) {
        $ifClause = "ifClause" + $lvl;
        out += " var " + $ifClause + " = 'then'; ";
      } else {
        $ifClause = "'then'";
      }
      out += " } ";
      if ($elsePresent) {
        out += " else { ";
      }
    } else {
      out += " if (!" + $nextValid + ") { ";
    }
    if ($elsePresent) {
      $it.schema = it.schema["else"];
      $it.schemaPath = it.schemaPath + ".else";
      $it.errSchemaPath = it.errSchemaPath + "/else";
      out += "  " + it.validate($it) + " ";
      $it.baseId = $currentBaseId;
      out += " " + $valid + " = " + $nextValid + "; ";
      if ($thenPresent && $elsePresent) {
        $ifClause = "ifClause" + $lvl;
        out += " var " + $ifClause + " = 'else'; ";
      } else {
        $ifClause = "'else'";
      }
      out += " } ";
    }
    out += " if (!" + $valid + ") {   var err =   ";
    if (it.createErrors !== false) {
      out += " { keyword: 'if' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { failingKeyword: " + $ifClause + " } ";
      if (it.opts.messages !== false) {
        out += ` , message: 'should match "' + ` + $ifClause + ` + '" schema' `;
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError(vErrors); ";
      } else {
        out += " validate.errors = vErrors; return false; ";
      }
    }
    out += " }   ";
    if ($breakOnError) {
      out += " else { ";
    }
  } else {
    if ($breakOnError) {
      out += " if (true) { ";
    }
  }
  return out;
};
var items = function generate_items(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = "";
  $it.level++;
  var $nextValid = "valid" + $it.level;
  var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId;
  out += "var " + $errs + " = errors;var " + $valid + ";";
  if (Array.isArray($schema2)) {
    var $additionalItems = it.schema.additionalItems;
    if ($additionalItems === false) {
      out += " " + $valid + " = " + $data + ".length <= " + $schema2.length + "; ";
      var $currErrSchemaPath = $errSchemaPath;
      $errSchemaPath = it.errSchemaPath + "/additionalItems";
      out += "  if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schema2.length + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT have more than " + $schema2.length + " items' ";
        }
        if (it.opts.verbose) {
          out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      $errSchemaPath = $currErrSchemaPath;
      if ($breakOnError) {
        $closingBraces += "}";
        out += " else { ";
      }
    }
    var arr1 = $schema2;
    if (arr1) {
      var $sch, $i = -1, l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          out += " " + $nextValid + " = true; if (" + $data + ".length > " + $i + ") { ";
          var $passData = $data + "[" + $i + "]";
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + "[" + $i + "]";
          $it.errSchemaPath = $errSchemaPath + "/" + $i;
          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
          $it.dataPathArr[$dataNxt] = $i;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          out += " }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
    }
    if (typeof $additionalItems == "object" && (it.opts.strictKeywords ? typeof $additionalItems == "object" && Object.keys($additionalItems).length > 0 || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
      $it.schema = $additionalItems;
      $it.schemaPath = it.schemaPath + ".additionalItems";
      $it.errSchemaPath = it.errSchemaPath + "/additionalItems";
      out += " " + $nextValid + " = true; if (" + $data + ".length > " + $schema2.length + ") {  for (var " + $idx + " = " + $schema2.length + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + "[" + $idx + "]";
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
      } else {
        out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
      }
      if ($breakOnError) {
        out += " if (!" + $nextValid + ") break; ";
      }
      out += " } }  ";
      if ($breakOnError) {
        out += " if (" + $nextValid + ") { ";
        $closingBraces += "}";
      }
    }
  } else if (it.opts.strictKeywords ? typeof $schema2 == "object" && Object.keys($schema2).length > 0 || $schema2 === false : it.util.schemaHasRules($schema2, it.RULES.all)) {
    $it.schema = $schema2;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += "  for (var " + $idx + " = " + 0 + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + "[" + $idx + "]";
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
    } else {
      out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
    }
    if ($breakOnError) {
      out += " if (!" + $nextValid + ") break; ";
    }
    out += " }";
  }
  if ($breakOnError) {
    out += " " + $closingBraces + " if (" + $errs + " == errors) {";
  }
  return out;
};
var _limit = function generate__limit(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = "data" + ($dataLvl || "");
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  var $isMax = $keyword == "maximum", $exclusiveKeyword = $isMax ? "exclusiveMaximum" : "exclusiveMinimum", $schemaExcl = it.schema[$exclusiveKeyword], $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $notOp = $isMax ? ">" : "<", $errorKeyword = void 0;
  if (!($isData || typeof $schema2 == "number" || $schema2 === void 0)) {
    throw new Error($keyword + " must be number");
  }
  if (!($isDataExcl || $schemaExcl === void 0 || typeof $schemaExcl == "number" || typeof $schemaExcl == "boolean")) {
    throw new Error($exclusiveKeyword + " must be number or boolean");
  }
  if ($isDataExcl) {
    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr), $exclusive = "exclusive" + $lvl, $exclType = "exclType" + $lvl, $exclIsNumber = "exclIsNumber" + $lvl, $opExpr = "op" + $lvl, $opStr = "' + " + $opExpr + " + '";
    out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ";
    $schemaValueExcl = "schemaExcl" + $lvl;
    out += " var " + $exclusive + "; var " + $exclType + " = typeof " + $schemaValueExcl + "; if (" + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
    var $errorKeyword = $exclusiveKeyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
      if (it.opts.messages !== false) {
        out += " , message: '" + $exclusiveKeyword + " should be boolean' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } else if ( ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    }
    out += " " + $exclType + " == 'number' ? ( (" + $exclusive + " = " + $schemaValue + " === undefined || " + $schemaValueExcl + " " + $op + "= " + $schemaValue + ") ? " + $data + " " + $notOp + "= " + $schemaValueExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) : ( (" + $exclusive + " = " + $schemaValueExcl + " === true) ? " + $data + " " + $notOp + "= " + $schemaValue + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "='; ";
    if ($schema2 === void 0) {
      $errorKeyword = $exclusiveKeyword;
      $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
      $schemaValue = $schemaValueExcl;
      $isData = $isDataExcl;
    }
  } else {
    var $exclIsNumber = typeof $schemaExcl == "number", $opStr = $op;
    if ($exclIsNumber && $isData) {
      var $opExpr = "'" + $opStr + "'";
      out += " if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " ( " + $schemaValue + " === undefined || " + $schemaExcl + " " + $op + "= " + $schemaValue + " ? " + $data + " " + $notOp + "= " + $schemaExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { ";
    } else {
      if ($exclIsNumber && $schema2 === void 0) {
        $exclusive = true;
        $errorKeyword = $exclusiveKeyword;
        $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
        $schemaValue = $schemaExcl;
        $notOp += "=";
      } else {
        if ($exclIsNumber)
          $schemaValue = Math[$isMax ? "min" : "max"]($schemaExcl, $schema2);
        if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
          $exclusive = true;
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
          $notOp += "=";
        } else {
          $exclusive = false;
          $opStr += "=";
        }
      }
      var $opExpr = "'" + $opStr + "'";
      out += " if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " " + $data + " " + $notOp + " " + $schemaValue + " || " + $data + " !== " + $data + ") { ";
    }
  }
  $errorKeyword = $errorKeyword || $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: '" + ($errorKeyword || "_limit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit: " + $schemaValue + ", exclusive: " + $exclusive + " } ";
    if (it.opts.messages !== false) {
      out += " , message: 'should be " + $opStr + " ";
      if ($isData) {
        out += "' + " + $schemaValue;
      } else {
        out += "" + $schemaValue + "'";
      }
    }
    if (it.opts.verbose) {
      out += " , schema:  ";
      if ($isData) {
        out += "validate.schema" + $schemaPath;
      } else {
        out += "" + $schema2;
      }
      out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += " } ";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var _limitItems = function generate__limitItems(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = "data" + ($dataLvl || "");
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  if (!($isData || typeof $schema2 == "number")) {
    throw new Error($keyword + " must be number");
  }
  var $op = $keyword == "maxItems" ? ">" : "<";
  out += "if ( ";
  if ($isData) {
    out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
  }
  out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: '" + ($errorKeyword || "_limitItems") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
    if (it.opts.messages !== false) {
      out += " , message: 'should NOT have ";
      if ($keyword == "maxItems") {
        out += "more";
      } else {
        out += "fewer";
      }
      out += " than ";
      if ($isData) {
        out += "' + " + $schemaValue + " + '";
      } else {
        out += "" + $schema2;
      }
      out += " items' ";
    }
    if (it.opts.verbose) {
      out += " , schema:  ";
      if ($isData) {
        out += "validate.schema" + $schemaPath;
      } else {
        out += "" + $schema2;
      }
      out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += "} ";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var _limitLength = function generate__limitLength(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = "data" + ($dataLvl || "");
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  if (!($isData || typeof $schema2 == "number")) {
    throw new Error($keyword + " must be number");
  }
  var $op = $keyword == "maxLength" ? ">" : "<";
  out += "if ( ";
  if ($isData) {
    out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
  }
  if (it.opts.unicode === false) {
    out += " " + $data + ".length ";
  } else {
    out += " ucs2length(" + $data + ") ";
  }
  out += " " + $op + " " + $schemaValue + ") { ";
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: '" + ($errorKeyword || "_limitLength") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
    if (it.opts.messages !== false) {
      out += " , message: 'should NOT be ";
      if ($keyword == "maxLength") {
        out += "longer";
      } else {
        out += "shorter";
      }
      out += " than ";
      if ($isData) {
        out += "' + " + $schemaValue + " + '";
      } else {
        out += "" + $schema2;
      }
      out += " characters' ";
    }
    if (it.opts.verbose) {
      out += " , schema:  ";
      if ($isData) {
        out += "validate.schema" + $schemaPath;
      } else {
        out += "" + $schema2;
      }
      out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += "} ";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var _limitProperties = function generate__limitProperties(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = "data" + ($dataLvl || "");
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  if (!($isData || typeof $schema2 == "number")) {
    throw new Error($keyword + " must be number");
  }
  var $op = $keyword == "maxProperties" ? ">" : "<";
  out += "if ( ";
  if ($isData) {
    out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
  }
  out += " Object.keys(" + $data + ").length " + $op + " " + $schemaValue + ") { ";
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: '" + ($errorKeyword || "_limitProperties") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
    if (it.opts.messages !== false) {
      out += " , message: 'should NOT have ";
      if ($keyword == "maxProperties") {
        out += "more";
      } else {
        out += "fewer";
      }
      out += " than ";
      if ($isData) {
        out += "' + " + $schemaValue + " + '";
      } else {
        out += "" + $schema2;
      }
      out += " properties' ";
    }
    if (it.opts.verbose) {
      out += " , schema:  ";
      if ($isData) {
        out += "validate.schema" + $schemaPath;
      } else {
        out += "" + $schema2;
      }
      out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += "} ";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var multipleOf = function generate_multipleOf(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  if (!($isData || typeof $schema2 == "number")) {
    throw new Error($keyword + " must be number");
  }
  out += "var division" + $lvl + ";if (";
  if ($isData) {
    out += " " + $schemaValue + " !== undefined && ( typeof " + $schemaValue + " != 'number' || ";
  }
  out += " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ";
  if (it.opts.multipleOfPrecision) {
    out += " Math.abs(Math.round(division" + $lvl + ") - division" + $lvl + ") > 1e-" + it.opts.multipleOfPrecision + " ";
  } else {
    out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ";
  }
  out += " ) ";
  if ($isData) {
    out += "  )  ";
  }
  out += " ) {   ";
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { multipleOf: " + $schemaValue + " } ";
    if (it.opts.messages !== false) {
      out += " , message: 'should be multiple of ";
      if ($isData) {
        out += "' + " + $schemaValue;
      } else {
        out += "" + $schemaValue + "'";
      }
    }
    if (it.opts.verbose) {
      out += " , schema:  ";
      if ($isData) {
        out += "validate.schema" + $schemaPath;
      } else {
        out += "" + $schema2;
      }
      out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += "} ";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var not$1 = function generate_not(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = "valid" + $it.level;
  if (it.opts.strictKeywords ? typeof $schema2 == "object" && Object.keys($schema2).length > 0 || $schema2 === false : it.util.schemaHasRules($schema2, it.RULES.all)) {
    $it.schema = $schema2;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += " var " + $errs + " = errors;  ";
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.createErrors = false;
    var $allErrorsOption;
    if ($it.opts.allErrors) {
      $allErrorsOption = $it.opts.allErrors;
      $it.opts.allErrors = false;
    }
    out += " " + it.validate($it) + " ";
    $it.createErrors = true;
    if ($allErrorsOption)
      $it.opts.allErrors = $allErrorsOption;
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += " if (" + $nextValid + ") {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
      if (it.opts.messages !== false) {
        out += " , message: 'should NOT be valid' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
    if (it.opts.allErrors) {
      out += " } ";
    }
  } else {
    out += "  var err =   ";
    if (it.createErrors !== false) {
      out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
      if (it.opts.messages !== false) {
        out += " , message: 'should NOT be valid' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    if ($breakOnError) {
      out += " if (false) { ";
    }
  }
  return out;
};
var oneOf = function generate_oneOf(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = "";
  $it.level++;
  var $nextValid = "valid" + $it.level;
  var $currentBaseId = $it.baseId, $prevValid = "prevValid" + $lvl, $passingSchemas = "passingSchemas" + $lvl;
  out += "var " + $errs + " = errors , " + $prevValid + " = false , " + $valid + " = false , " + $passingSchemas + " = null; ";
  var $wasComposite = it.compositeRule;
  it.compositeRule = $it.compositeRule = true;
  var arr1 = $schema2;
  if (arr1) {
    var $sch, $i = -1, l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + "[" + $i + "]";
        $it.errSchemaPath = $errSchemaPath + "/" + $i;
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
      } else {
        out += " var " + $nextValid + " = true; ";
      }
      if ($i) {
        out += " if (" + $nextValid + " && " + $prevValid + ") { " + $valid + " = false; " + $passingSchemas + " = [" + $passingSchemas + ", " + $i + "]; } else { ";
        $closingBraces += "}";
      }
      out += " if (" + $nextValid + ") { " + $valid + " = " + $prevValid + " = true; " + $passingSchemas + " = " + $i + "; }";
    }
  }
  it.compositeRule = $it.compositeRule = $wasComposite;
  out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   ";
  if (it.createErrors !== false) {
    out += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { passingSchemas: " + $passingSchemas + " } ";
    if (it.opts.messages !== false) {
      out += " , message: 'should match exactly one schema in oneOf' ";
    }
    if (it.opts.verbose) {
      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError(vErrors); ";
    } else {
      out += " validate.errors = vErrors; return false; ";
    }
  }
  out += "} else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }";
  if (it.opts.allErrors) {
    out += " } ";
  }
  return out;
};
var pattern = function generate_pattern(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  var $regexp = $isData ? "(new RegExp(" + $schemaValue + "))" : it.usePattern($schema2);
  out += "if ( ";
  if ($isData) {
    out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
  }
  out += " !" + $regexp + ".test(" + $data + ") ) {   ";
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = "";
  if (it.createErrors !== false) {
    out += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { pattern:  ";
    if ($isData) {
      out += "" + $schemaValue;
    } else {
      out += "" + it.util.toQuotedString($schema2);
    }
    out += "  } ";
    if (it.opts.messages !== false) {
      out += ` , message: 'should match pattern "`;
      if ($isData) {
        out += "' + " + $schemaValue + " + '";
      } else {
        out += "" + it.util.escapeQuotes($schema2);
      }
      out += `"' `;
    }
    if (it.opts.verbose) {
      out += " , schema:  ";
      if ($isData) {
        out += "validate.schema" + $schemaPath;
      } else {
        out += "" + it.util.toQuotedString($schema2);
      }
      out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
    }
    out += " } ";
  } else {
    out += " {} ";
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    if (it.async) {
      out += " throw new ValidationError([" + __err + "]); ";
    } else {
      out += " validate.errors = [" + __err + "]; return false; ";
    }
  } else {
    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
  }
  out += "} ";
  if ($breakOnError) {
    out += " else { ";
  }
  return out;
};
var properties$2 = function generate_properties(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = "";
  $it.level++;
  var $nextValid = "valid" + $it.level;
  var $key = "key" + $lvl, $idx = "idx" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl;
  var $schemaKeys = Object.keys($schema2 || {}).filter(notProto), $pProperties = it.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties).filter(notProto), $aProperties = it.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == "object" && Object.keys($aProperties).length, $removeAdditional = it.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
  var $required = it.schema.required;
  if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {
    var $requiredHash = it.util.toHash($required);
  }
  function notProto(p) {
    return p !== "__proto__";
  }
  out += "var " + $errs + " = errors;var " + $nextValid + " = true;";
  if ($ownProperties) {
    out += " var " + $dataProperties + " = undefined;";
  }
  if ($checkAdditional) {
    if ($ownProperties) {
      out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
    } else {
      out += " for (var " + $key + " in " + $data + ") { ";
    }
    if ($someProperties) {
      out += " var isAdditional" + $lvl + " = !(false ";
      if ($schemaKeys.length) {
        if ($schemaKeys.length > 8) {
          out += " || validate.schema" + $schemaPath + ".hasOwnProperty(" + $key + ") ";
        } else {
          var arr1 = $schemaKeys;
          if (arr1) {
            var $propertyKey, i1 = -1, l1 = arr1.length - 1;
            while (i1 < l1) {
              $propertyKey = arr1[i1 += 1];
              out += " || " + $key + " == " + it.util.toQuotedString($propertyKey) + " ";
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr2 = $pPropertyKeys;
        if (arr2) {
          var $pProperty, $i = -1, l2 = arr2.length - 1;
          while ($i < l2) {
            $pProperty = arr2[$i += 1];
            out += " || " + it.usePattern($pProperty) + ".test(" + $key + ") ";
          }
        }
      }
      out += " ); if (isAdditional" + $lvl + ") { ";
    }
    if ($removeAdditional == "all") {
      out += " delete " + $data + "[" + $key + "]; ";
    } else {
      var $currentErrorPath = it.errorPath;
      var $additionalProperty = "' + " + $key + " + '";
      if (it.opts._errorDataPathProperty) {
        it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
      }
      if ($noAdditional) {
        if ($removeAdditional) {
          out += " delete " + $data + "[" + $key + "]; ";
        } else {
          out += " " + $nextValid + " = false; ";
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + "/additionalProperties";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { additionalProperty: '" + $additionalProperty + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: '";
              if (it.opts._errorDataPathProperty) {
                out += "is an invalid additional property";
              } else {
                out += "should NOT have additional properties";
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            out += " break; ";
          }
        }
      } else if ($additionalIsSchema) {
        if ($removeAdditional == "failing") {
          out += " var " + $errs + " = errors;  ";
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + ".additionalProperties";
          $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + "[" + $key + "]";
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          out += " if (!" + $nextValid + ") { errors = " + $errs + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + $data + "[" + $key + "]; }  ";
          it.compositeRule = $it.compositeRule = $wasComposite;
        } else {
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + ".additionalProperties";
          $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + "[" + $key + "]";
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          if ($breakOnError) {
            out += " if (!" + $nextValid + ") break; ";
          }
        }
      }
      it.errorPath = $currentErrorPath;
    }
    if ($someProperties) {
      out += " } ";
    }
    out += " }  ";
    if ($breakOnError) {
      out += " if (" + $nextValid + ") { ";
      $closingBraces += "}";
    }
  }
  var $useDefaults = it.opts.useDefaults && !it.compositeRule;
  if ($schemaKeys.length) {
    var arr3 = $schemaKeys;
    if (arr3) {
      var $propertyKey, i3 = -1, l3 = arr3.length - 1;
      while (i3 < l3) {
        $propertyKey = arr3[i3 += 1];
        var $sch = $schema2[$propertyKey];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          var $prop = it.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== void 0;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + $prop;
          $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($propertyKey);
          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            $code = it.util.varReplace($code, $nextData, $passData);
            var $useData = $passData;
          } else {
            var $useData = $nextData;
            out += " var " + $nextData + " = " + $passData + "; ";
          }
          if ($hasDefault) {
            out += " " + $code + " ";
          } else {
            if ($requiredHash && $requiredHash[$propertyKey]) {
              out += " if ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") { " + $nextValid + " = false; ";
              var $currentErrorPath = it.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it.util.escapeQuotes($propertyKey);
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }
              $errSchemaPath = it.errSchemaPath + "/required";
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              $errSchemaPath = $currErrSchemaPath;
              it.errorPath = $currentErrorPath;
              out += " } else { ";
            } else {
              if ($breakOnError) {
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") { " + $nextValid + " = true; } else { ";
              } else {
                out += " if (" + $useData + " !== undefined ";
                if ($ownProperties) {
                  out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += " ) { ";
              }
            }
            out += " " + $code + " } ";
          }
        }
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
    }
  }
  if ($pPropertyKeys.length) {
    var arr4 = $pPropertyKeys;
    if (arr4) {
      var $pProperty, i4 = -1, l4 = arr4.length - 1;
      while (i4 < l4) {
        $pProperty = arr4[i4 += 1];
        var $sch = $pProperties[$pProperty];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          $it.schema = $sch;
          $it.schemaPath = it.schemaPath + ".patternProperties" + it.util.getProperty($pProperty);
          $it.errSchemaPath = it.errSchemaPath + "/patternProperties/" + it.util.escapeFragment($pProperty);
          if ($ownProperties) {
            out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
          } else {
            out += " for (var " + $key + " in " + $data + ") { ";
          }
          out += " if (" + it.usePattern($pProperty) + ".test(" + $key + ")) { ";
          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + "[" + $key + "]";
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          if ($breakOnError) {
            out += " if (!" + $nextValid + ") break; ";
          }
          out += " } ";
          if ($breakOnError) {
            out += " else " + $nextValid + " = true; ";
          }
          out += " }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += " " + $closingBraces + " if (" + $errs + " == errors) {";
  }
  return out;
};
var propertyNames = function generate_propertyNames(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $errs = "errs__" + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = "";
  $it.level++;
  var $nextValid = "valid" + $it.level;
  out += "var " + $errs + " = errors;";
  if (it.opts.strictKeywords ? typeof $schema2 == "object" && Object.keys($schema2).length > 0 || $schema2 === false : it.util.schemaHasRules($schema2, it.RULES.all)) {
    $it.schema = $schema2;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    var $key = "key" + $lvl, $idx = "idx" + $lvl, $i = "i" + $lvl, $invalidName = "' + " + $key + " + '", $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
    if ($ownProperties) {
      out += " var " + $dataProperties + " = undefined; ";
    }
    if ($ownProperties) {
      out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
    } else {
      out += " for (var " + $key + " in " + $data + ") { ";
    }
    out += " var startErrs" + $lvl + " = errors; ";
    var $passData = $key;
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
    } else {
      out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += " if (!" + $nextValid + ") { for (var " + $i + "=startErrs" + $lvl + "; " + $i + "<errors; " + $i + "++) { vErrors[" + $i + "].propertyName = " + $key + "; }   var err =   ";
    if (it.createErrors !== false) {
      out += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { propertyName: '" + $invalidName + "' } ";
      if (it.opts.messages !== false) {
        out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError(vErrors); ";
      } else {
        out += " validate.errors = vErrors; return false; ";
      }
    }
    if ($breakOnError) {
      out += " break; ";
    }
    out += " } }";
  }
  if ($breakOnError) {
    out += " " + $closingBraces + " if (" + $errs + " == errors) {";
  }
  return out;
};
var required$1 = function generate_required(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $isData = it.opts.$data && $schema2 && $schema2.$data;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
  }
  var $vSchema = "schema" + $lvl;
  if (!$isData) {
    if ($schema2.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
      var $required = [];
      var arr1 = $schema2;
      if (arr1) {
        var $property, i1 = -1, l1 = arr1.length - 1;
        while (i1 < l1) {
          $property = arr1[i1 += 1];
          var $propertySch = it.schema.properties[$property];
          if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == "object" && Object.keys($propertySch).length > 0 || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
            $required[$required.length] = $property;
          }
        }
      }
    } else {
      var $required = $schema2;
    }
  }
  if ($isData || $required.length) {
    var $currentErrorPath = it.errorPath, $loopRequired = $isData || $required.length >= it.opts.loopRequired, $ownProperties = it.opts.ownProperties;
    if ($breakOnError) {
      out += " var missing" + $lvl + "; ";
      if ($loopRequired) {
        if (!$isData) {
          out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
        }
        var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        out += " var " + $valid + " = true; ";
        if ($isData) {
          out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
        }
        out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { " + $valid + " = " + $data + "[" + $vSchema + "[" + $i + "]] !== undefined ";
        if ($ownProperties) {
          out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
        }
        out += "; if (!" + $valid + ") break; } ";
        if ($isData) {
          out += "  }  ";
        }
        out += "  if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: '";
            if (it.opts._errorDataPathProperty) {
              out += "is a required property";
            } else {
              out += "should have required property \\'" + $missingProperty + "\\'";
            }
            out += "' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else { ";
      } else {
        out += " if ( ";
        var arr2 = $required;
        if (arr2) {
          var $propertyKey, $i = -1, l2 = arr2.length - 1;
          while ($i < l2) {
            $propertyKey = arr2[$i += 1];
            if ($i) {
              out += " || ";
            }
            var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
            out += " ( ( " + $useData + " === undefined ";
            if ($ownProperties) {
              out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
            }
            out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
          }
        }
        out += ") {  ";
        var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: '";
            if (it.opts._errorDataPathProperty) {
              out += "is a required property";
            } else {
              out += "should have required property \\'" + $missingProperty + "\\'";
            }
            out += "' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else { ";
      }
    } else {
      if ($loopRequired) {
        if (!$isData) {
          out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
        }
        var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        if ($isData) {
          out += " if (" + $vSchema + " && !Array.isArray(" + $vSchema + ")) {  var err =   ";
          if (it.createErrors !== false) {
            out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: '";
              if (it.opts._errorDataPathProperty) {
                out += "is a required property";
              } else {
                out += "should have required property \\'" + $missingProperty + "\\'";
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + $vSchema + " !== undefined) { ";
        }
        out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { if (" + $data + "[" + $vSchema + "[" + $i + "]] === undefined ";
        if ($ownProperties) {
          out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
        }
        out += ") {  var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: '";
            if (it.opts._errorDataPathProperty) {
              out += "is a required property";
            } else {
              out += "should have required property \\'" + $missingProperty + "\\'";
            }
            out += "' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ";
        if ($isData) {
          out += "  }  ";
        }
      } else {
        var arr3 = $required;
        if (arr3) {
          var $propertyKey, i3 = -1, l3 = arr3.length - 1;
          while (i3 < l3) {
            $propertyKey = arr3[i3 += 1];
            var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += " if ( " + $useData + " === undefined ";
            if ($ownProperties) {
              out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
            }
            out += ") {  var err =   ";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
          }
        }
      }
    }
    it.errorPath = $currentErrorPath;
  } else if ($breakOnError) {
    out += " if (true) {";
  }
  return out;
};
var uniqueItems = function generate_uniqueItems(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  if (($schema2 || $isData) && it.opts.uniqueItems !== false) {
    if ($isData) {
      out += " var " + $valid + "; if (" + $schemaValue + " === false || " + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'boolean') " + $valid + " = false; else { ";
    }
    out += " var i = " + $data + ".length , " + $valid + " = true , j; if (i > 1) { ";
    var $itemType = it.schema.items && it.schema.items.type, $typeIsArray = Array.isArray($itemType);
    if (!$itemType || $itemType == "object" || $itemType == "array" || $typeIsArray && ($itemType.indexOf("object") >= 0 || $itemType.indexOf("array") >= 0)) {
      out += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + $data + "[i], " + $data + "[j])) { " + $valid + " = false; break outer; } } } ";
    } else {
      out += " var itemIndices = {}, item; for (;i--;) { var item = " + $data + "[i]; ";
      var $method = "checkDataType" + ($typeIsArray ? "s" : "");
      out += " if (" + it.util[$method]($itemType, "item", it.opts.strictNumbers, true) + ") continue; ";
      if ($typeIsArray) {
        out += ` if (typeof item == 'string') item = '"' + item; `;
      }
      out += " if (typeof itemIndices[item] == 'number') { " + $valid + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
    }
    out += " } ";
    if ($isData) {
      out += "  }  ";
    }
    out += " if (!" + $valid + ") {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { i: i, j: j } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema2;
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } ";
    if ($breakOnError) {
      out += " else { ";
    }
  } else {
    if ($breakOnError) {
      out += " if (true) { ";
    }
  }
  return out;
};
var dotjs = {
  "$ref": ref,
  allOf,
  anyOf,
  "$comment": comment,
  const: _const,
  contains,
  dependencies,
  "enum": _enum,
  format,
  "if": _if,
  items,
  maximum: _limit,
  minimum: _limit,
  maxItems: _limitItems,
  minItems: _limitItems,
  maxLength: _limitLength,
  minLength: _limitLength,
  maxProperties: _limitProperties,
  minProperties: _limitProperties,
  multipleOf,
  not: not$1,
  oneOf,
  pattern,
  properties: properties$2,
  propertyNames,
  required: required$1,
  uniqueItems,
  validate: validate$1
};
var ruleModules = dotjs, toHash = util$6.toHash;
var rules$1 = function rules() {
  var RULES = [
    {
      type: "number",
      rules: [
        { "maximum": ["exclusiveMaximum"] },
        { "minimum": ["exclusiveMinimum"] },
        "multipleOf",
        "format"
      ]
    },
    {
      type: "string",
      rules: ["maxLength", "minLength", "pattern", "format"]
    },
    {
      type: "array",
      rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
    },
    {
      type: "object",
      rules: [
        "maxProperties",
        "minProperties",
        "required",
        "dependencies",
        "propertyNames",
        { "properties": ["additionalProperties", "patternProperties"] }
      ]
    },
    { rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"] }
  ];
  var ALL = ["type", "$comment"];
  var KEYWORDS2 = [
    "$schema",
    "$id",
    "id",
    "$data",
    "$async",
    "title",
    "description",
    "default",
    "definitions",
    "examples",
    "readOnly",
    "writeOnly",
    "contentMediaType",
    "contentEncoding",
    "additionalItems",
    "then",
    "else"
  ];
  var TYPES = ["number", "integer", "string", "array", "object", "boolean", "null"];
  RULES.all = toHash(ALL);
  RULES.types = toHash(TYPES);
  RULES.forEach(function(group2) {
    group2.rules = group2.rules.map(function(keyword2) {
      var implKeywords;
      if (typeof keyword2 == "object") {
        var key = Object.keys(keyword2)[0];
        implKeywords = keyword2[key];
        keyword2 = key;
        implKeywords.forEach(function(k) {
          ALL.push(k);
          RULES.all[k] = true;
        });
      }
      ALL.push(keyword2);
      var rule = RULES.all[keyword2] = {
        keyword: keyword2,
        code: ruleModules[keyword2],
        implements: implKeywords
      };
      return rule;
    });
    RULES.all.$comment = {
      keyword: "$comment",
      code: ruleModules.$comment
    };
    if (group2.type)
      RULES.types[group2.type] = group2;
  });
  RULES.keywords = toHash(ALL.concat(KEYWORDS2));
  RULES.custom = {};
  return RULES;
};
var KEYWORDS = [
  "multipleOf",
  "maximum",
  "exclusiveMaximum",
  "minimum",
  "exclusiveMinimum",
  "maxLength",
  "minLength",
  "pattern",
  "additionalItems",
  "maxItems",
  "minItems",
  "uniqueItems",
  "maxProperties",
  "minProperties",
  "required",
  "additionalProperties",
  "enum",
  "format",
  "const"
];
var data = function(metaSchema2, keywordsJsonPointers) {
  for (var i = 0; i < keywordsJsonPointers.length; i++) {
    metaSchema2 = JSON.parse(JSON.stringify(metaSchema2));
    var segments = keywordsJsonPointers[i].split("/");
    var keywords = metaSchema2;
    var j;
    for (j = 1; j < segments.length; j++)
      keywords = keywords[segments[j]];
    for (j = 0; j < KEYWORDS.length; j++) {
      var key = KEYWORDS[j];
      var schema = keywords[key];
      if (schema) {
        keywords[key] = {
          anyOf: [
            schema,
            { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
          ]
        };
      }
    }
  }
  return metaSchema2;
};
var MissingRefError = error_classes.MissingRef;
var async$1 = compileAsync;
function compileAsync(schema, meta, callback) {
  var self2 = this;
  if (typeof this._opts.loadSchema != "function")
    throw new Error("options.loadSchema should be a function");
  if (typeof meta == "function") {
    callback = meta;
    meta = void 0;
  }
  var p = loadMetaSchemaOf(schema).then(function() {
    var schemaObj = self2._addSchema(schema, void 0, meta);
    return schemaObj.validate || _compileAsync(schemaObj);
  });
  if (callback) {
    p.then(function(v) {
      callback(null, v);
    }, callback);
  }
  return p;
  function loadMetaSchemaOf(sch) {
    var $schema2 = sch.$schema;
    return $schema2 && !self2.getSchema($schema2) ? compileAsync.call(self2, { $ref: $schema2 }, true) : Promise.resolve();
  }
  function _compileAsync(schemaObj) {
    try {
      return self2._compile(schemaObj);
    } catch (e) {
      if (e instanceof MissingRefError)
        return loadMissingSchema(e);
      throw e;
    }
    function loadMissingSchema(e) {
      var ref2 = e.missingSchema;
      if (added(ref2))
        throw new Error("Schema " + ref2 + " is loaded but " + e.missingRef + " cannot be resolved");
      var schemaPromise = self2._loadingSchemas[ref2];
      if (!schemaPromise) {
        schemaPromise = self2._loadingSchemas[ref2] = self2._opts.loadSchema(ref2);
        schemaPromise.then(removePromise, removePromise);
      }
      return schemaPromise.then(function(sch) {
        if (!added(ref2)) {
          return loadMetaSchemaOf(sch).then(function() {
            if (!added(ref2))
              self2.addSchema(sch, ref2, void 0, meta);
          });
        }
      }).then(function() {
        return _compileAsync(schemaObj);
      });
      function removePromise() {
        delete self2._loadingSchemas[ref2];
      }
      function added(ref3) {
        return self2._refs[ref3] || self2._schemas[ref3];
      }
    }
  }
}
var custom = function generate_custom(it, $keyword, $ruleType) {
  var out = " ";
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema2 = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = "data" + ($dataLvl || "");
  var $valid = "valid" + $lvl;
  var $errs = "errs__" + $lvl;
  var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
  if ($isData) {
    out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    $schemaValue = "schema" + $lvl;
  } else {
    $schemaValue = $schema2;
  }
  var $rule = this, $definition = "definition" + $lvl, $rDef = $rule.definition, $closingBraces = "";
  var $compile, $inline, $macro, $ruleValidate, $validateCode;
  if ($isData && $rDef.$data) {
    $validateCode = "keywordValidate" + $lvl;
    var $validateSchema = $rDef.validateSchema;
    out += " var " + $definition + " = RULES.custom['" + $keyword + "'].definition; var " + $validateCode + " = " + $definition + ".validate;";
  } else {
    $ruleValidate = it.useCustomRule($rule, $schema2, it.schema, it);
    if (!$ruleValidate)
      return;
    $schemaValue = "validate.schema" + $schemaPath;
    $validateCode = $ruleValidate.code;
    $compile = $rDef.compile;
    $inline = $rDef.inline;
    $macro = $rDef.macro;
  }
  var $ruleErrs = $validateCode + ".errors", $i = "i" + $lvl, $ruleErr = "ruleErr" + $lvl, $asyncKeyword = $rDef.async;
  if ($asyncKeyword && !it.async)
    throw new Error("async keyword in sync schema");
  if (!($inline || $macro)) {
    out += "" + $ruleErrs + " = null;";
  }
  out += "var " + $errs + " = errors;var " + $valid + ";";
  if ($isData && $rDef.$data) {
    $closingBraces += "}";
    out += " if (" + $schemaValue + " === undefined) { " + $valid + " = true; } else { ";
    if ($validateSchema) {
      $closingBraces += "}";
      out += " " + $valid + " = " + $definition + ".validateSchema(" + $schemaValue + "); if (" + $valid + ") { ";
    }
  }
  if ($inline) {
    if ($rDef.statements) {
      out += " " + $ruleValidate.validate + " ";
    } else {
      out += " " + $valid + " = " + $ruleValidate.validate + "; ";
    }
  } else if ($macro) {
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    $it.schema = $ruleValidate.validate;
    $it.schemaPath = "";
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += " " + $code;
  } else {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    out += "  " + $validateCode + ".call( ";
    if (it.opts.passContext) {
      out += "this";
    } else {
      out += "self";
    }
    if ($compile || $rDef.schema === false) {
      out += " , " + $data + " ";
    } else {
      out += " , " + $schemaValue + " , " + $data + " , validate.schema" + it.schemaPath + " ";
    }
    out += " , (dataPath || '')";
    if (it.errorPath != '""') {
      out += " + " + it.errorPath;
    }
    var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
    out += " , " + $parentData + " , " + $parentDataProperty + " , rootData )  ";
    var def_callRuleValidate = out;
    out = $$outStack.pop();
    if ($rDef.errors === false) {
      out += " " + $valid + " = ";
      if ($asyncKeyword) {
        out += "await ";
      }
      out += "" + def_callRuleValidate + "; ";
    } else {
      if ($asyncKeyword) {
        $ruleErrs = "customErrors" + $lvl;
        out += " var " + $ruleErrs + " = null; try { " + $valid + " = await " + def_callRuleValidate + "; } catch (e) { " + $valid + " = false; if (e instanceof ValidationError) " + $ruleErrs + " = e.errors; else throw e; } ";
      } else {
        out += " " + $ruleErrs + " = null; " + $valid + " = " + def_callRuleValidate + "; ";
      }
    }
  }
  if ($rDef.modifying) {
    out += " if (" + $parentData + ") " + $data + " = " + $parentData + "[" + $parentDataProperty + "];";
  }
  out += "" + $closingBraces;
  if ($rDef.valid) {
    if ($breakOnError) {
      out += " if (true) { ";
    }
  } else {
    out += " if ( ";
    if ($rDef.valid === void 0) {
      out += " !";
      if ($macro) {
        out += "" + $nextValid;
      } else {
        out += "" + $valid;
      }
    } else {
      out += " " + !$rDef.valid + " ";
    }
    out += ") { ";
    $errorKeyword = $rule.keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
      if (it.opts.messages !== false) {
        out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    var def_customError = out;
    out = $$outStack.pop();
    if ($inline) {
      if ($rDef.errors) {
        if ($rDef.errors != "full") {
          out += "  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
          if (it.opts.verbose) {
            out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
          }
          out += " } ";
        }
      } else {
        if ($rDef.errors === false) {
          out += " " + def_customError + " ";
        } else {
          out += " if (" + $errs + " == errors) { " + def_customError + " } else {  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
          if (it.opts.verbose) {
            out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
          }
          out += " } } ";
        }
      }
    } else if ($macro) {
      out += "   var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
    } else {
      if ($rDef.errors === false) {
        out += " " + def_customError + " ";
      } else {
        out += " if (Array.isArray(" + $ruleErrs + ")) { if (vErrors === null) vErrors = " + $ruleErrs + "; else vErrors = vErrors.concat(" + $ruleErrs + "); errors = vErrors.length;  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + ";  " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
        if (it.opts.verbose) {
          out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
        }
        out += " } } else { " + def_customError + " } ";
      }
    }
    out += " } ";
    if ($breakOnError) {
      out += " else { ";
    }
  }
  return out;
};
const $schema$2 = "http://json-schema.org/draft-07/schema#";
const $id$1 = "http://json-schema.org/draft-07/schema#";
const title = "Core schema meta-schema";
const definitions$1 = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        "default": 0
      }
    ]
  },
  simpleTypes: {
    "enum": [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: true,
    "default": []
  }
};
const type$1 = [
  "object",
  "boolean"
];
const properties$1 = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  "default": true,
  readOnly: {
    type: "boolean",
    "default": false
  },
  examples: {
    type: "array",
    items: true
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    "default": true
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    "default": false
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    "default": {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  "const": true,
  "enum": {
    type: "array",
    items: true,
    minItems: 1,
    uniqueItems: true
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: true
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  "if": {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  "else": {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
};
var require$$13$1 = {
  $schema: $schema$2,
  $id: $id$1,
  title,
  definitions: definitions$1,
  type: type$1,
  properties: properties$1,
  "default": true
};
var metaSchema = require$$13$1;
var definition_schema = {
  $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
  definitions: {
    simpleTypes: metaSchema.definitions.simpleTypes
  },
  type: "object",
  dependencies: {
    schema: ["validate"],
    $data: ["validate"],
    statements: ["inline"],
    valid: { not: { required: ["macro"] } }
  },
  properties: {
    type: metaSchema.properties.type,
    schema: { type: "boolean" },
    statements: { type: "boolean" },
    dependencies: {
      type: "array",
      items: { type: "string" }
    },
    metaSchema: { type: "object" },
    modifying: { type: "boolean" },
    valid: { type: "boolean" },
    $data: { type: "boolean" },
    async: { type: "boolean" },
    errors: {
      anyOf: [
        { type: "boolean" },
        { const: "full" }
      ]
    }
  }
};
var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
var customRuleCode = custom;
var definitionSchema = definition_schema;
var keyword = {
  add: addKeyword,
  get: getKeyword,
  remove: removeKeyword,
  validate: validateKeyword
};
function addKeyword(keyword2, definition) {
  var RULES = this.RULES;
  if (RULES.keywords[keyword2])
    throw new Error("Keyword " + keyword2 + " is already defined");
  if (!IDENTIFIER.test(keyword2))
    throw new Error("Keyword " + keyword2 + " is not a valid identifier");
  if (definition) {
    this.validateKeyword(definition, true);
    var dataType = definition.type;
    if (Array.isArray(dataType)) {
      for (var i = 0; i < dataType.length; i++)
        _addRule(keyword2, dataType[i], definition);
    } else {
      _addRule(keyword2, dataType, definition);
    }
    var metaSchema2 = definition.metaSchema;
    if (metaSchema2) {
      if (definition.$data && this._opts.$data) {
        metaSchema2 = {
          anyOf: [
            metaSchema2,
            { "$ref": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
          ]
        };
      }
      definition.validateSchema = this.compile(metaSchema2, true);
    }
  }
  RULES.keywords[keyword2] = RULES.all[keyword2] = true;
  function _addRule(keyword3, dataType2, definition2) {
    var ruleGroup;
    for (var i2 = 0; i2 < RULES.length; i2++) {
      var rg = RULES[i2];
      if (rg.type == dataType2) {
        ruleGroup = rg;
        break;
      }
    }
    if (!ruleGroup) {
      ruleGroup = { type: dataType2, rules: [] };
      RULES.push(ruleGroup);
    }
    var rule = {
      keyword: keyword3,
      definition: definition2,
      custom: true,
      code: customRuleCode,
      implements: definition2.implements
    };
    ruleGroup.rules.push(rule);
    RULES.custom[keyword3] = rule;
  }
  return this;
}
function getKeyword(keyword2) {
  var rule = this.RULES.custom[keyword2];
  return rule ? rule.definition : this.RULES.keywords[keyword2] || false;
}
function removeKeyword(keyword2) {
  var RULES = this.RULES;
  delete RULES.keywords[keyword2];
  delete RULES.all[keyword2];
  delete RULES.custom[keyword2];
  for (var i = 0; i < RULES.length; i++) {
    var rules3 = RULES[i].rules;
    for (var j = 0; j < rules3.length; j++) {
      if (rules3[j].keyword == keyword2) {
        rules3.splice(j, 1);
        break;
      }
    }
  }
  return this;
}
function validateKeyword(definition, throwError2) {
  validateKeyword.errors = null;
  var v = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);
  if (v(definition))
    return true;
  validateKeyword.errors = v.errors;
  if (throwError2)
    throw new Error("custom keyword definition is invalid: " + this.errorsText(v.errors));
  else
    return false;
}
const $schema$1 = "http://json-schema.org/draft-07/schema#";
const $id = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description = "Meta-schema for $data reference (JSON Schema extension proposal)";
const type = "object";
const required = [
  "$data"
];
const properties = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
};
const additionalProperties = false;
var require$$12$1 = {
  $schema: $schema$1,
  $id,
  description,
  type,
  required,
  properties,
  additionalProperties
};
var compileSchema = compile_1, resolve = resolve_1, Cache2 = cache.exports, SchemaObject = schema_obj, stableStringify = fastJsonStableStringify, formats = formats_1, rules2 = rules$1, $dataMetaSchema = data, util$1 = util$6;
var ajv = Ajv;
Ajv.prototype.validate = validate;
Ajv.prototype.compile = compile$1;
Ajv.prototype.addSchema = addSchema;
Ajv.prototype.addMetaSchema = addMetaSchema;
Ajv.prototype.validateSchema = validateSchema;
Ajv.prototype.getSchema = getSchema;
Ajv.prototype.removeSchema = removeSchema;
Ajv.prototype.addFormat = addFormat;
Ajv.prototype.errorsText = errorsText;
Ajv.prototype._addSchema = _addSchema;
Ajv.prototype._compile = _compile;
Ajv.prototype.compileAsync = async$1;
var customKeyword = keyword;
Ajv.prototype.addKeyword = customKeyword.add;
Ajv.prototype.getKeyword = customKeyword.get;
Ajv.prototype.removeKeyword = customKeyword.remove;
Ajv.prototype.validateKeyword = customKeyword.validate;
var errorClasses = error_classes;
Ajv.ValidationError = errorClasses.Validation;
Ajv.MissingRefError = errorClasses.MissingRef;
Ajv.$dataMetaSchema = $dataMetaSchema;
var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"];
var META_SUPPORT_DATA = ["/properties"];
function Ajv(opts) {
  if (!(this instanceof Ajv))
    return new Ajv(opts);
  opts = this._opts = util$1.copy(opts) || {};
  setLogger(this);
  this._schemas = {};
  this._refs = {};
  this._fragments = {};
  this._formats = formats(opts.format);
  this._cache = opts.cache || new Cache2();
  this._loadingSchemas = {};
  this._compilations = [];
  this.RULES = rules2();
  this._getId = chooseGetId(opts);
  opts.loopRequired = opts.loopRequired || Infinity;
  if (opts.errorDataPath == "property")
    opts._errorDataPathProperty = true;
  if (opts.serialize === void 0)
    opts.serialize = stableStringify;
  this._metaOpts = getMetaSchemaOptions(this);
  if (opts.formats)
    addInitialFormats(this);
  if (opts.keywords)
    addInitialKeywords(this);
  addDefaultMetaSchema(this);
  if (typeof opts.meta == "object")
    this.addMetaSchema(opts.meta);
  if (opts.nullable)
    this.addKeyword("nullable", { metaSchema: { type: "boolean" } });
  addInitialSchemas(this);
}
function validate(schemaKeyRef, data2) {
  var v;
  if (typeof schemaKeyRef == "string") {
    v = this.getSchema(schemaKeyRef);
    if (!v)
      throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
  } else {
    var schemaObj = this._addSchema(schemaKeyRef);
    v = schemaObj.validate || this._compile(schemaObj);
  }
  var valid = v(data2);
  if (v.$async !== true)
    this.errors = v.errors;
  return valid;
}
function compile$1(schema, _meta) {
  var schemaObj = this._addSchema(schema, void 0, _meta);
  return schemaObj.validate || this._compile(schemaObj);
}
function addSchema(schema, key, _skipValidation, _meta) {
  if (Array.isArray(schema)) {
    for (var i = 0; i < schema.length; i++)
      this.addSchema(schema[i], void 0, _skipValidation, _meta);
    return this;
  }
  var id = this._getId(schema);
  if (id !== void 0 && typeof id != "string")
    throw new Error("schema id must be string");
  key = resolve.normalizeId(key || id);
  checkUnique(this, key);
  this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
  return this;
}
function addMetaSchema(schema, key, skipValidation) {
  this.addSchema(schema, key, skipValidation, true);
  return this;
}
function validateSchema(schema, throwOrLogError) {
  var $schema2 = schema.$schema;
  if ($schema2 !== void 0 && typeof $schema2 != "string")
    throw new Error("$schema must be a string");
  $schema2 = $schema2 || this._opts.defaultMeta || defaultMeta(this);
  if (!$schema2) {
    this.logger.warn("meta-schema not available");
    this.errors = null;
    return true;
  }
  var valid = this.validate($schema2, schema);
  if (!valid && throwOrLogError) {
    var message = "schema is invalid: " + this.errorsText();
    if (this._opts.validateSchema == "log")
      this.logger.error(message);
    else
      throw new Error(message);
  }
  return valid;
}
function defaultMeta(self2) {
  var meta = self2._opts.meta;
  self2._opts.defaultMeta = typeof meta == "object" ? self2._getId(meta) || meta : self2.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0;
  return self2._opts.defaultMeta;
}
function getSchema(keyRef) {
  var schemaObj = _getSchemaObj(this, keyRef);
  switch (typeof schemaObj) {
    case "object":
      return schemaObj.validate || this._compile(schemaObj);
    case "string":
      return this.getSchema(schemaObj);
    case "undefined":
      return _getSchemaFragment(this, keyRef);
  }
}
function _getSchemaFragment(self2, ref2) {
  var res = resolve.schema.call(self2, { schema: {} }, ref2);
  if (res) {
    var schema = res.schema, root = res.root, baseId = res.baseId;
    var v = compileSchema.call(self2, schema, root, void 0, baseId);
    self2._fragments[ref2] = new SchemaObject({
      ref: ref2,
      fragment: true,
      schema,
      root,
      baseId,
      validate: v
    });
    return v;
  }
}
function _getSchemaObj(self2, keyRef) {
  keyRef = resolve.normalizeId(keyRef);
  return self2._schemas[keyRef] || self2._refs[keyRef] || self2._fragments[keyRef];
}
function removeSchema(schemaKeyRef) {
  if (schemaKeyRef instanceof RegExp) {
    _removeAllSchemas(this, this._schemas, schemaKeyRef);
    _removeAllSchemas(this, this._refs, schemaKeyRef);
    return this;
  }
  switch (typeof schemaKeyRef) {
    case "undefined":
      _removeAllSchemas(this, this._schemas);
      _removeAllSchemas(this, this._refs);
      this._cache.clear();
      return this;
    case "string":
      var schemaObj = _getSchemaObj(this, schemaKeyRef);
      if (schemaObj)
        this._cache.del(schemaObj.cacheKey);
      delete this._schemas[schemaKeyRef];
      delete this._refs[schemaKeyRef];
      return this;
    case "object":
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
      this._cache.del(cacheKey);
      var id = this._getId(schemaKeyRef);
      if (id) {
        id = resolve.normalizeId(id);
        delete this._schemas[id];
        delete this._refs[id];
      }
  }
  return this;
}
function _removeAllSchemas(self2, schemas, regex2) {
  for (var keyRef in schemas) {
    var schemaObj = schemas[keyRef];
    if (!schemaObj.meta && (!regex2 || regex2.test(keyRef))) {
      self2._cache.del(schemaObj.cacheKey);
      delete schemas[keyRef];
    }
  }
}
function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
  if (typeof schema != "object" && typeof schema != "boolean")
    throw new Error("schema should be object or boolean");
  var serialize = this._opts.serialize;
  var cacheKey = serialize ? serialize(schema) : schema;
  var cached = this._cache.get(cacheKey);
  if (cached)
    return cached;
  shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
  var id = resolve.normalizeId(this._getId(schema));
  if (id && shouldAddSchema)
    checkUnique(this, id);
  var willValidate = this._opts.validateSchema !== false && !skipValidation;
  var recursiveMeta;
  if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
    this.validateSchema(schema, true);
  var localRefs = resolve.ids.call(this, schema);
  var schemaObj = new SchemaObject({
    id,
    schema,
    localRefs,
    cacheKey,
    meta
  });
  if (id[0] != "#" && shouldAddSchema)
    this._refs[id] = schemaObj;
  this._cache.put(cacheKey, schemaObj);
  if (willValidate && recursiveMeta)
    this.validateSchema(schema, true);
  return schemaObj;
}
function _compile(schemaObj, root) {
  if (schemaObj.compiling) {
    schemaObj.validate = callValidate;
    callValidate.schema = schemaObj.schema;
    callValidate.errors = null;
    callValidate.root = root ? root : callValidate;
    if (schemaObj.schema.$async === true)
      callValidate.$async = true;
    return callValidate;
  }
  schemaObj.compiling = true;
  var currentOpts;
  if (schemaObj.meta) {
    currentOpts = this._opts;
    this._opts = this._metaOpts;
  }
  var v;
  try {
    v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
  } catch (e) {
    delete schemaObj.validate;
    throw e;
  } finally {
    schemaObj.compiling = false;
    if (schemaObj.meta)
      this._opts = currentOpts;
  }
  schemaObj.validate = v;
  schemaObj.refs = v.refs;
  schemaObj.refVal = v.refVal;
  schemaObj.root = v.root;
  return v;
  function callValidate() {
    var _validate = schemaObj.validate;
    var result = _validate.apply(this, arguments);
    callValidate.errors = _validate.errors;
    return result;
  }
}
function chooseGetId(opts) {
  switch (opts.schemaId) {
    case "auto":
      return _get$IdOrId;
    case "id":
      return _getId;
    default:
      return _get$Id;
  }
}
function _getId(schema) {
  if (schema.$id)
    this.logger.warn("schema $id ignored", schema.$id);
  return schema.id;
}
function _get$Id(schema) {
  if (schema.id)
    this.logger.warn("schema id ignored", schema.id);
  return schema.$id;
}
function _get$IdOrId(schema) {
  if (schema.$id && schema.id && schema.$id != schema.id)
    throw new Error("schema $id is different from id");
  return schema.$id || schema.id;
}
function errorsText(errors, options) {
  errors = errors || this.errors;
  if (!errors)
    return "No errors";
  options = options || {};
  var separator = options.separator === void 0 ? ", " : options.separator;
  var dataVar = options.dataVar === void 0 ? "data" : options.dataVar;
  var text = "";
  for (var i = 0; i < errors.length; i++) {
    var e = errors[i];
    if (e)
      text += dataVar + e.dataPath + " " + e.message + separator;
  }
  return text.slice(0, -separator.length);
}
function addFormat(name2, format2) {
  if (typeof format2 == "string")
    format2 = new RegExp(format2);
  this._formats[name2] = format2;
  return this;
}
function addDefaultMetaSchema(self2) {
  var $dataSchema;
  if (self2._opts.$data) {
    $dataSchema = require$$12$1;
    self2.addMetaSchema($dataSchema, $dataSchema.$id, true);
  }
  if (self2._opts.meta === false)
    return;
  var metaSchema2 = require$$13$1;
  if (self2._opts.$data)
    metaSchema2 = $dataMetaSchema(metaSchema2, META_SUPPORT_DATA);
  self2.addMetaSchema(metaSchema2, META_SCHEMA_ID, true);
  self2._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
}
function addInitialSchemas(self2) {
  var optsSchemas = self2._opts.schemas;
  if (!optsSchemas)
    return;
  if (Array.isArray(optsSchemas))
    self2.addSchema(optsSchemas);
  else
    for (var key in optsSchemas)
      self2.addSchema(optsSchemas[key], key);
}
function addInitialFormats(self2) {
  for (var name2 in self2._opts.formats) {
    var format2 = self2._opts.formats[name2];
    self2.addFormat(name2, format2);
  }
}
function addInitialKeywords(self2) {
  for (var name2 in self2._opts.keywords) {
    var keyword2 = self2._opts.keywords[name2];
    self2.addKeyword(name2, keyword2);
  }
}
function checkUnique(self2, id) {
  if (self2._schemas[id] || self2._refs[id])
    throw new Error('schema with key or id "' + id + '" already exists');
}
function getMetaSchemaOptions(self2) {
  var metaOpts = util$1.copy(self2._opts);
  for (var i = 0; i < META_IGNORE_OPTIONS.length; i++)
    delete metaOpts[META_IGNORE_OPTIONS[i]];
  return metaOpts;
}
function setLogger(self2) {
  var logger = self2._opts.logger;
  if (logger === false) {
    self2.logger = { log: noop$1, warn: noop$1, error: noop$1 };
  } else {
    if (logger === void 0)
      logger = console;
    if (!(typeof logger == "object" && logger.log && logger.warn && logger.error))
      throw new Error("logger must implement log, warn and error methods");
    self2.logger = logger;
  }
}
function noop$1() {
}
function validateGoslingSpec(spec) {
  return validateSpec(GoslingSchema, spec);
}
function validateSpec(schema, spec, silence = false) {
  const validate2 = new ajv({ extendRefs: true }).compile(schema);
  const valid = validate2(spec);
  let message = "";
  let details = "";
  if (validate2.errors) {
    details = JSON.stringify(validate2.errors, null, 2);
    if (!silence) {
      console.warn(details);
    }
    message = "\u26A0\uFE0F Some properties are incorrectly used.";
  }
  return { state: valid ? "success" : "warn", message, details };
}
function validateTrack(track) {
  let valid = true;
  const errorMessages = [];
  const resolvedTrack = resolveSuperposedTracks(track);
  resolvedTrack.forEach((spec) => {
    if (!getGenomicChannelFromTrack(spec) && spec.mark !== "brush" && spec.mark !== "rule") {
      errorMessages.push("genomic type is not encoded to either a x- or y- axis");
      valid = false;
    }
    const color2 = spec.color;
    if (spec.mark === "line" && IsChannelDeep(color2) && color2.type === "quantitative") {
      errorMessages.push("`line` mark cannot be used with `quantitative` value");
      valid = false;
    }
  });
  return { valid, errorMessages };
}
function getGenomicChannelFromTrack(track) {
  let genomicChannel = void 0;
  ["x", "y", "xe", "ye", "x1", "y1", "x1e", "y1e"].reverse().forEach((channelType) => {
    const channel = track[channelType];
    if (IsChannelDeep(channel) && channel.type === "genomic") {
      genomicChannel = channel;
    }
  });
  return genomicChannel;
}
function getGenomicChannelKeyFromTrack(track) {
  let genomicChannelKey = void 0;
  ["x", "xe", "y", "ye", "x1", "y1", "x1e", "y1e"].reverse().forEach((channelKey) => {
    const channel = track[channelKey];
    if (IsChannelDeep(channel) && channel.type === "genomic") {
      genomicChannelKey = channelKey;
    }
  });
  return genomicChannelKey;
}
const $ref = "#/definitions/HiGlassSpec";
const $schema = "http://json-schema.org/draft-07/schema#";
const definitions = {
  Assembly: {
    anyOf: [
      {
        "const": "hg38",
        type: "string"
      },
      {
        "const": "hg19",
        type: "string"
      },
      {
        "const": "hg18",
        type: "string"
      },
      {
        "const": "hg17",
        type: "string"
      },
      {
        "const": "hg16",
        type: "string"
      },
      {
        "const": "mm10",
        type: "string"
      },
      {
        "const": "mm9",
        type: "string"
      },
      {
        "const": "unknown",
        type: "string"
      },
      {
        $ref: "#/definitions/ChromSizes"
      }
    ]
  },
  ChromSizes: {
    description: 'Custom chromosome sizes, e.g., [["foo", 1000], ["bar", 300], ["baz", 240]]',
    items: {
      items: [
        {
          type: "string"
        },
        {
          type: "number"
        }
      ],
      maxItems: 2,
      minItems: 2,
      type: "array"
    },
    type: "array"
  },
  CombinedTrack: {
    additionalProperties: false,
    properties: {
      contents: {
        items: {
          $ref: "#/definitions/Track"
        },
        type: "array"
      },
      height: {
        type: "number"
      },
      options: {},
      position: {
        type: "string"
      },
      type: {
        "const": "combined",
        type: "string"
      },
      uid: {
        type: "string"
      },
      width: {
        type: "number"
      }
    },
    required: [
      "type",
      "contents"
    ],
    type: "object"
  },
  Data: {
    additionalProperties: false,
    properties: {
      assembly: {
        $ref: "#/definitions/Assembly"
      },
      children: {
        items: {},
        type: "array"
      },
      filter: {
        items: {
          $ref: "#/definitions/FilterTransform"
        },
        type: "array"
      },
      tiles: {},
      tilesetInfo: {},
      type: {
        type: "string"
      },
      url: {
        type: "string"
      }
    },
    type: "object"
  },
  EnumTrack: {
    additionalProperties: false,
    properties: {
      chromInfoPath: {
        type: "string"
      },
      data: {
        $ref: "#/definitions/Data"
      },
      fromViewUid: {
        type: [
          "null",
          "string"
        ]
      },
      height: {
        type: "number"
      },
      options: {},
      server: {
        type: "string"
      },
      tilesetUid: {
        type: "string"
      },
      type: {
        $ref: "#/definitions/EnumTrackType"
      },
      uid: {
        type: "string"
      },
      width: {
        type: "number"
      },
      x: {
        type: "number"
      },
      y: {
        type: "number"
      }
    },
    required: [
      "type"
    ],
    type: "object"
  },
  EnumTrackType: {
    "enum": [
      "heatmap",
      "2d-annotations",
      "2d-chromosome-annotations",
      "2d-chromosome-grid",
      "2d-chromosome-labels",
      "2d-rectangle-domains",
      "2d-tiles",
      "arrowhead-domains",
      "bedlike",
      "cross-rule",
      "dummy",
      "horizontal-1d-annotations",
      "horizontal-1d-heatmap",
      "horizontal-1d-tiles",
      "horizontal-1d-value-interval",
      "horizontal-2d-rectangle-domains",
      "horizontal-bar",
      "horizontal-chromosome-grid",
      "horizontal-chromosome-labels",
      "horizontal-divergent-bar",
      "horizontal-gene-annotations",
      "horizontal-heatmap",
      "horizontal-line",
      "horizontal-multivec",
      "horizontal-point",
      "horizontal-rule",
      "horizontal-vector-heatmap",
      "image-tiles",
      "left-axis",
      "left-stacked-interval",
      "mapbox-tiles",
      "osm-2d-tile-ids",
      "osm-tiles",
      "raster-tiles",
      "simple-svg",
      "square-markers",
      "top-axis",
      "top-stacked-interval",
      "vertical-1d-annotations",
      "vertical-1d-heatmap",
      "vertical-1d-tiles",
      "vertical-1d-value-interval",
      "vertical-2d-rectangle-domains",
      "vertical-bar",
      "vertical-bedlike",
      "vertical-chromosome-grid",
      "vertical-chromosome-labels",
      "vertical-gene-annotations",
      "vertical-heatmap",
      "vertical-line",
      "vertical-multivec",
      "vertical-point",
      "vertical-rule",
      "vertical-vector-heatmap",
      "viewport-projection-center",
      "viewport-projection-horizontal",
      "viewport-projection-vertical",
      "gosling-track",
      "gosling-2d-track",
      "axis-track",
      "text"
    ],
    type: "string"
  },
  FilterTransform: {
    anyOf: [
      {
        $ref: "#/definitions/OneOfFilter"
      },
      {
        $ref: "#/definitions/RangeFilter"
      },
      {
        $ref: "#/definitions/IncludeFilter"
      }
    ]
  },
  GenericLocks: {
    additionalProperties: false,
    properties: {
      locksByViewUid: {
        $ref: "#/definitions/LocksByViewUid"
      },
      locksDict: {}
    },
    required: [
      "locksByViewUid",
      "locksDict"
    ],
    type: "object"
  },
  GenomePositionSearchBox: {
    additionalProperties: false,
    properties: {
      autocompleteId: {
        type: "string"
      },
      autocompleteServer: {
        type: "string"
      },
      chromInfoId: {
        type: "string"
      },
      chromInfoServer: {
        type: "string"
      },
      visible: {
        type: "boolean"
      }
    },
    required: [
      "chromInfoId",
      "chromInfoServer"
    ],
    type: "object"
  },
  HeatmapTrack: {
    additionalProperties: false,
    properties: {
      data: {
        $ref: "#/definitions/Data"
      },
      height: {
        type: "number"
      },
      options: {},
      position: {
        type: "string"
      },
      server: {
        type: "string"
      },
      tilesetUid: {
        type: "string"
      },
      type: {
        "const": "heatmap",
        type: "string"
      },
      uid: {
        type: "string"
      },
      width: {
        type: "number"
      }
    },
    required: [
      "type"
    ],
    type: "object"
  },
  HiGlassSpec: {
    additionalProperties: false,
    properties: {
      chromInfoPath: {
        type: "string"
      },
      compactLayout: {
        type: "boolean"
      },
      editable: {
        type: "boolean"
      },
      exportViewUrl: {
        type: "string"
      },
      locationLocks: {
        $ref: "#/definitions/GenericLocks"
      },
      trackSourceServers: {
        items: {
          type: "string"
        },
        type: "array"
      },
      tracksEditable: {
        type: "boolean"
      },
      valueScaleLocks: {
        $ref: "#/definitions/ValueScaleLocks"
      },
      viewEditable: {
        type: "boolean"
      },
      views: {
        items: {
          $ref: "#/definitions/View"
        },
        type: "array"
      },
      zoomFixed: {
        type: "boolean"
      },
      zoomLocks: {
        $ref: "#/definitions/GenericLocks"
      }
    },
    required: [
      "views",
      "zoomLocks",
      "locationLocks"
    ],
    type: "object"
  },
  IncludeFilter: {
    additionalProperties: false,
    properties: {
      field: {
        description: "A filter is applied based on the values of the specified data field",
        type: "string"
      },
      include: {
        description: "Check whether the value includes a substring.",
        type: "string"
      },
      not: {
        description: 'when `{"not": true}`, apply a NOT logical operation to the filter.\n\n__Default:__ `false`',
        type: "boolean"
      },
      type: {
        "const": "filter",
        type: "string"
      }
    },
    required: [
      "field",
      "include",
      "type"
    ],
    type: "object"
  },
  IndependentViewportProjectionTrack: {
    additionalProperties: false,
    properties: {
      fromViewUid: {
        type: "null"
      },
      options: {},
      projectionXDomain: {
        items: {
          type: "number"
        },
        type: "array"
      },
      projectionYDomain: {
        items: {
          type: "number"
        },
        type: "array"
      },
      transforms: {
        items: {},
        type: "array"
      },
      type: {
        "enum": [
          "viewport-projection-horizontal",
          "viewport-projection-vertical",
          "viewport-projection-center"
        ],
        type: "string"
      },
      uid: {
        type: "string"
      },
      width: {
        type: "number"
      },
      x: {
        type: "number"
      },
      y: {
        type: "number"
      }
    },
    required: [
      "type"
    ],
    type: "object"
  },
  Layout: {
    additionalProperties: false,
    properties: {
      h: {
        type: "number"
      },
      w: {
        type: "number"
      },
      x: {
        type: "number"
      },
      y: {
        type: "number"
      }
    },
    required: [
      "h",
      "w",
      "x",
      "y"
    ],
    type: "object"
  },
  LocksByViewUid: {
    additionalProperties: {
      type: "string"
    },
    type: "object"
  },
  OneOfFilter: {
    additionalProperties: false,
    properties: {
      field: {
        description: "A filter is applied based on the values of the specified data field",
        type: "string"
      },
      not: {
        description: 'when `{"not": true}`, apply a NOT logical operation to the filter.\n\n__Default:__ `false`',
        type: "boolean"
      },
      oneOf: {
        description: "Check whether the value is an element in the provided list.",
        items: {
          type: [
            "string",
            "number",
            "null"
          ]
        },
        type: "array"
      },
      type: {
        "const": "filter",
        type: "string"
      }
    },
    required: [
      "field",
      "oneOf",
      "type"
    ],
    type: "object"
  },
  Overlay: {
    additionalProperties: false,
    properties: {
      chromInfoPath: {
        type: "string"
      },
      includes: {
        items: {},
        type: "array"
      },
      options: {
        $ref: "#/definitions/OverlayOptions"
      },
      type: {
        type: "string"
      },
      uid: {
        type: "string"
      }
    },
    type: "object"
  },
  OverlayOptions: {
    additionalProperties: false,
    properties: {
      extent: {
        items: {},
        type: "array"
      },
      fill: {
        type: "string"
      },
      fillOpacity: {
        type: "number"
      },
      minWidth: {
        type: "number"
      },
      outline: {
        type: "string"
      },
      outlineOpacity: {
        type: "number"
      },
      outlinePos: {
        anyOf: [
          {
            items: {},
            type: "array"
          },
          {
            type: "string"
          }
        ]
      },
      outlineWidth: {
        type: "number"
      },
      stroke: {
        type: "string"
      },
      strokeOpacity: {
        type: "number"
      },
      strokePos: {
        anyOf: [
          {
            items: {},
            type: "array"
          },
          {
            type: "string"
          }
        ]
      },
      strokeWidth: {
        type: "number"
      }
    },
    type: "object"
  },
  RangeFilter: {
    additionalProperties: false,
    properties: {
      field: {
        description: "A filter is applied based on the values of the specified data field",
        type: "string"
      },
      inRange: {
        description: "Check whether the value is in a number range.",
        items: {
          type: "number"
        },
        type: "array"
      },
      not: {
        description: 'when `{"not": true}`, apply a NOT logical operation to the filter.\n\n__Default:__ `false`',
        type: "boolean"
      },
      type: {
        "const": "filter",
        type: "string"
      }
    },
    required: [
      "field",
      "inRange",
      "type"
    ],
    type: "object"
  },
  Track: {
    anyOf: [
      {
        $ref: "#/definitions/HeatmapTrack"
      },
      {
        $ref: "#/definitions/CombinedTrack"
      },
      {
        $ref: "#/definitions/IndependentViewportProjectionTrack"
      },
      {
        $ref: "#/definitions/EnumTrack"
      }
    ]
  },
  Tracks: {
    additionalProperties: false,
    properties: {
      bottom: {
        items: {
          $ref: "#/definitions/Track"
        },
        type: "array"
      },
      center: {
        items: {
          $ref: "#/definitions/Track"
        },
        type: "array"
      },
      gallery: {
        items: {
          $ref: "#/definitions/Track"
        },
        type: "array"
      },
      left: {
        items: {
          $ref: "#/definitions/Track"
        },
        type: "array"
      },
      right: {
        items: {
          $ref: "#/definitions/Track"
        },
        type: "array"
      },
      top: {
        items: {
          $ref: "#/definitions/Track"
        },
        type: "array"
      },
      whole: {
        items: {
          $ref: "#/definitions/Track"
        },
        type: "array"
      }
    },
    required: [
      "top",
      "left",
      "center",
      "right",
      "bottom",
      "gallery",
      "whole"
    ],
    type: "object"
  },
  ValueScaleLocks: {
    additionalProperties: false,
    properties: {
      locksByViewUid: {
        $ref: "#/definitions/LocksByViewUid"
      },
      locksDict: {}
    },
    required: [
      "locksByViewUid"
    ],
    type: "object"
  },
  View: {
    additionalProperties: false,
    properties: {
      autocompleteSource: {
        type: "string"
      },
      chromInfoPath: {
        type: "string"
      },
      genomePositionSearchBox: {
        $ref: "#/definitions/GenomePositionSearchBox"
      },
      genomePositionSearchBoxVisible: {
        type: "boolean"
      },
      initialXDomain: {
        items: {
          type: "number"
        },
        type: "array"
      },
      initialYDomain: {
        items: {
          type: "number"
        },
        type: "array"
      },
      layout: {
        $ref: "#/definitions/Layout"
      },
      overlays: {
        items: {
          $ref: "#/definitions/Overlay"
        },
        type: "array"
      },
      selectionView: {
        type: "boolean"
      },
      tracks: {
        $ref: "#/definitions/Tracks"
      },
      uid: {
        type: "string"
      },
      zoomFixed: {
        type: "boolean"
      },
      zoomLimits: {
        items: {
          type: [
            "number",
            "null"
          ]
        },
        maxItems: 2,
        minItems: 2,
        type: "array"
      }
    },
    required: [
      "tracks",
      "layout"
    ],
    type: "object"
  }
};
var HiGlassSchema = {
  $ref,
  $schema,
  definitions
};
function getNumericDomain(domain, assembly) {
  const chromInterval = computeChromSizes(assembly).interval;
  if ("chromosome" in domain) {
    const isThereChr = Object.keys(chromInterval).find((chr) => chr === domain.chromosome);
    if (!isThereChr) {
      return;
    }
  }
  if (IsDomainChr(domain)) {
    return [chromInterval[domain.chromosome][0] + 1, chromInterval[domain.chromosome][1]];
  } else if (IsDomainInterval(domain)) {
    return domain.interval;
  } else if (IsDomainChrInterval(domain)) {
    const chrStart = chromInterval[domain.chromosome][0];
    const [start, end] = domain.interval;
    return [chrStart + start, chrStart + end];
  }
}
function shareScaleAcrossTracks(trackModels, force) {
  const globalDomain = {};
  const channelKeys = SUPPORTED_CHANNELS;
  trackModels.forEach((model) => {
    channelKeys.forEach((channelKey) => {
      const channel = model.spec()[channelKey];
      if (!IsChannelDeep(channel) || channel.domain === void 0) {
        return;
      }
      const { domain, type: type2 } = channel;
      if (type2 === "quantitative") {
        const numericDomain = Array.from(domain);
        if (!globalDomain[channelKey]) {
          globalDomain[channelKey] = numericDomain;
        } else {
          if (globalDomain[channelKey][0] > numericDomain[0]) {
            globalDomain[channelKey][0] = numericDomain[0];
          }
          if (globalDomain[channelKey][1] < numericDomain[1]) {
            globalDomain[channelKey][1] = numericDomain[1];
          }
        }
      } else if (type2 === "nominal") {
        const nominalDomain = Array.from(domain);
        if (!globalDomain[channelKey]) {
          globalDomain[channelKey] = nominalDomain;
        } else {
          globalDomain[channelKey] = Array.from(/* @__PURE__ */ new Set([...globalDomain[channelKey], ...nominalDomain]));
        }
      }
    });
  });
  trackModels.forEach((model) => {
    channelKeys.forEach((channelKey) => {
      const channel = model.spec()[channelKey];
      if (IsChannelDeep(channel) && channel.type === "genomic")
        return;
      model.setChannelDomain(channelKey, globalDomain[channelKey], force);
      model.generateScales();
    });
    model.updateChannelValue();
  });
}
const example = {
  compactLayout: false,
  trackSourceServers: ["https://server.gosling-lang.org/api/v1/"],
  views: [
    {
      genomePositionSearchBoxVisible: false,
      genomePositionSearchBox: {
        autocompleteServer: "https://higlass.io/api/v1",
        autocompleteId: "P0PLbQMwTYGy-5uPIQid7A",
        chromInfoServer: "https://higlass.io/api/v1",
        chromInfoId: "hg38"
      },
      layout: { x: 0, y: 0, w: 6.4, h: 600 },
      tracks: {
        top: [],
        left: [
          {
            type: "combined",
            width: 130,
            height: 600,
            contents: [
              {
                type: "gosling-track",
                server: "https://server.gosling-lang.org/api/v1/",
                tilesetUid: "cistrome-multivec",
                width: 130,
                height: 600,
                options: {
                  showMousePosition: true,
                  mousePositionColor: "#000000",
                  fontSize: 24,
                  labelPosition: "none",
                  labelShowResolution: false,
                  labelColor: "black",
                  labelBackgroundColor: "white",
                  labelTextOpacity: 1,
                  labelLeftMargin: 1,
                  labelTopMargin: 1,
                  labelRightMargin: 0,
                  labelBottomMargin: 0,
                  backgroundColor: "transparent",
                  spec: {
                    spacing: 10,
                    orientation: "vertical",
                    assembly: "hg38",
                    layout: "linear",
                    static: false,
                    xDomain: { interval: [0, 1e9] },
                    centerRadius: 0.3,
                    xOffset: 0,
                    yOffset: 0,
                    style: { outlineWidth: 0.5 },
                    data: {
                      url: "https://server.gosling-lang.org/api/v1/tileset_info/?d=cistrome-multivec",
                      type: "multivec",
                      row: "sample",
                      column: "position",
                      value: "peak",
                      categories: ["sample 1", "sample 2", "sample 3", "sample 4"],
                      binSize: 4
                    },
                    mark: "rect",
                    x: {
                      field: "start",
                      type: "genomic",
                      axis: "left",
                      domain: { interval: [0, 1e9] },
                      linkingId: "7f94b74e-25ec-4e67-8c75-3dc0f1b0d6bd"
                    },
                    xe: { field: "end", type: "genomic" },
                    row: {
                      field: "sample",
                      type: "nominal",
                      legend: true
                    },
                    color: {
                      field: "peak",
                      type: "quantitative",
                      legend: true
                    },
                    tooltip: [
                      {
                        field: "start",
                        type: "genomic",
                        alt: "Start Position"
                      },
                      {
                        field: "end",
                        type: "genomic",
                        alt: "End Position"
                      },
                      {
                        field: "peak",
                        type: "quantitative",
                        alt: "Value",
                        format: ".2"
                      },
                      { field: "sample", type: "nominal", alt: "Sample" }
                    ],
                    width: 160,
                    height: 600,
                    overlayOnPreviousTrack: false
                  },
                  theme: {
                    base: "light",
                    root: {
                      background: "white",
                      titleColor: "black",
                      titleBackgroundColor: "transparent",
                      titleFontSize: 18,
                      titleFontFamily: "Arial",
                      titleAlign: "left",
                      titleFontWeight: "bold",
                      subtitleColor: "gray",
                      subtitleBackgroundColor: "transparent",
                      subtitleFontSize: 16,
                      subtitleFontFamily: "Arial",
                      subtitleFontWeight: "normal",
                      subtitleAlign: "left",
                      mousePositionColor: "#000000"
                    },
                    track: {
                      background: "transparent",
                      alternatingBackground: "transparent",
                      titleColor: "black",
                      titleBackground: "white",
                      titleFontSize: 24,
                      titleAlign: "left",
                      outline: "black",
                      outlineWidth: 1
                    },
                    legend: {
                      position: "top",
                      background: "white",
                      backgroundOpacity: 0.7,
                      labelColor: "black",
                      labelFontSize: 12,
                      labelFontWeight: "normal",
                      labelFontFamily: "Arial",
                      backgroundStroke: "#DBDBDB",
                      tickColor: "black"
                    },
                    axis: {
                      tickColor: "black",
                      labelColor: "black",
                      labelFontSize: 12,
                      labelFontWeight: "normal",
                      labelFontFamily: "Arial",
                      baselineColor: "black",
                      gridColor: "#E3E3E3",
                      gridStrokeWidth: 1,
                      gridStrokeType: "solid",
                      gridStrokeDash: [4, 4]
                    },
                    markCommon: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    point: {
                      color: "#E79F00",
                      size: 3,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    rect: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    triangle: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    area: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    line: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    bar: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    rule: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 1,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    link: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 1,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    text: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6],
                      textAnchor: "middle",
                      textFontWeight: "normal"
                    },
                    brush: {
                      color: "gray",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 1,
                      opacity: 0.3,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    }
                  }
                }
              }
            ]
          },
          {
            uid: "15483511-f6fb-11eb-914b-976b6ecda162",
            type: "axis-track",
            chromInfoPath: "https://s3.amazonaws.com/gosling-lang.org/data/hg38.chrom.sizes",
            options: {
              layout: "linear",
              outerRadius: null,
              width: 160,
              height: 600,
              theme: {
                base: "light",
                root: {
                  background: "white",
                  titleColor: "black",
                  titleBackgroundColor: "transparent",
                  titleFontSize: 18,
                  titleFontFamily: "Arial",
                  titleAlign: "left",
                  titleFontWeight: "bold",
                  subtitleColor: "gray",
                  subtitleBackgroundColor: "transparent",
                  subtitleFontSize: 16,
                  subtitleFontFamily: "Arial",
                  subtitleFontWeight: "normal",
                  subtitleAlign: "left",
                  mousePositionColor: "#000000"
                },
                track: {
                  background: "transparent",
                  alternatingBackground: "transparent",
                  titleColor: "black",
                  titleBackground: "white",
                  titleFontSize: 24,
                  titleAlign: "left",
                  outline: "black",
                  outlineWidth: 1
                },
                legend: {
                  position: "top",
                  background: "white",
                  backgroundOpacity: 0.7,
                  labelColor: "black",
                  labelFontSize: 12,
                  labelFontWeight: "normal",
                  labelFontFamily: "Arial",
                  backgroundStroke: "#DBDBDB",
                  tickColor: "black"
                },
                axis: {
                  tickColor: "black",
                  labelColor: "black",
                  labelFontSize: 12,
                  labelFontWeight: "normal",
                  labelFontFamily: "Arial",
                  baselineColor: "black",
                  gridColor: "#E3E3E3",
                  gridStrokeWidth: 1,
                  gridStrokeType: "solid",
                  gridStrokeDash: [4, 4]
                },
                markCommon: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 0,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                point: {
                  color: "#E79F00",
                  size: 3,
                  stroke: "black",
                  strokeWidth: 0,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                rect: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 0,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                triangle: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 0,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                area: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 0,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                line: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 0,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                bar: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 0,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                rule: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 1,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                link: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 1,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                },
                text: {
                  color: "#E79F00",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 0,
                  opacity: 1,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6],
                  textAnchor: "middle",
                  textFontWeight: "normal"
                },
                brush: {
                  color: "gray",
                  size: 1,
                  stroke: "black",
                  strokeWidth: 1,
                  opacity: 0.3,
                  nominalColorRange: [
                    "#E79F00",
                    "#029F73",
                    "#0072B2",
                    "#CB7AA7",
                    "#D45E00",
                    "#57B4E9",
                    "#EFE441"
                  ],
                  quantitativeSizeRange: [2, 6]
                }
              },
              assembly: "hg38",
              stroke: "transparent",
              color: "black",
              fontSize: 12,
              fontFamily: "Arial",
              fontWeight: "normal",
              tickColor: "black",
              tickFormat: "plain",
              tickPositions: "even",
              reverseOrientation: false
            },
            width: 30
          }
        ],
        center: [],
        right: [],
        bottom: [],
        gallery: [],
        whole: []
      },
      initialXDomain: [0, 1e9],
      initialYDomain: [0, 1e9],
      zoomFixed: false,
      zoomLimits: [1, null],
      uid: "15483510-f6fb-11eb-914b-976b6ecda162",
      chromInfoPath: "https://s3.amazonaws.com/gosling-lang.org/data/hg38.chrom.sizes"
    },
    {
      genomePositionSearchBoxVisible: false,
      genomePositionSearchBox: {
        autocompleteServer: "https://higlass.io/api/v1",
        autocompleteId: "P0PLbQMwTYGy-5uPIQid7A",
        chromInfoServer: "https://higlass.io/api/v1",
        chromInfoId: "hg38"
      },
      layout: { x: 6.8, y: 0, w: 5.2, h: 600 },
      tracks: {
        top: [],
        left: [
          {
            type: "combined",
            width: 130,
            height: 600,
            contents: [
              {
                type: "gosling-track",
                server: "https://server.gosling-lang.org/api/v1/",
                tilesetUid: "cistrome-multivec",
                width: 130,
                height: 600,
                options: {
                  showMousePosition: true,
                  mousePositionColor: "#000000",
                  fontSize: 24,
                  labelPosition: "none",
                  labelShowResolution: false,
                  labelColor: "black",
                  labelBackgroundColor: "white",
                  labelTextOpacity: 1,
                  labelLeftMargin: 1,
                  labelTopMargin: 1,
                  labelRightMargin: 0,
                  labelBottomMargin: 0,
                  backgroundColor: "transparent",
                  spec: {
                    spacing: 10,
                    orientation: "vertical",
                    assembly: "hg38",
                    layout: "linear",
                    static: false,
                    xDomain: { interval: [0, 1e9] },
                    centerRadius: 0.3,
                    xOffset: 0,
                    yOffset: 0,
                    style: { outlineWidth: 0.5 },
                    data: {
                      url: "https://server.gosling-lang.org/api/v1/tileset_info/?d=cistrome-multivec",
                      type: "multivec",
                      row: "sample",
                      column: "position",
                      value: "peak",
                      categories: ["sample 1", "sample 2", "sample 3", "sample 4"],
                      binSize: 4
                    },
                    mark: "rect",
                    x: {
                      field: "start",
                      type: "genomic",
                      domain: { interval: [0, 1e9] },
                      linkingId: "7f94b74e-25ec-4e67-8c75-3dc0f1b0d6bd"
                    },
                    xe: { field: "end", type: "genomic" },
                    row: {
                      field: "sample",
                      type: "nominal",
                      legend: true
                    },
                    color: {
                      field: "peak",
                      type: "quantitative",
                      legend: true
                    },
                    tooltip: [
                      {
                        field: "start",
                        type: "genomic",
                        alt: "Start Position"
                      },
                      {
                        field: "end",
                        type: "genomic",
                        alt: "End Position"
                      },
                      {
                        field: "peak",
                        type: "quantitative",
                        alt: "Value",
                        format: ".2"
                      },
                      { field: "sample", type: "nominal", alt: "Sample" }
                    ],
                    width: 130,
                    height: 600
                  },
                  theme: {
                    base: "light",
                    root: {
                      background: "white",
                      titleColor: "black",
                      titleBackgroundColor: "transparent",
                      titleFontSize: 18,
                      titleFontFamily: "Arial",
                      titleAlign: "left",
                      titleFontWeight: "bold",
                      subtitleColor: "gray",
                      subtitleBackgroundColor: "transparent",
                      subtitleFontSize: 16,
                      subtitleFontFamily: "Arial",
                      subtitleFontWeight: "normal",
                      subtitleAlign: "left",
                      mousePositionColor: "#000000"
                    },
                    track: {
                      background: "transparent",
                      alternatingBackground: "transparent",
                      titleColor: "black",
                      titleBackground: "white",
                      titleFontSize: 24,
                      titleAlign: "left",
                      outline: "black",
                      outlineWidth: 1
                    },
                    legend: {
                      position: "top",
                      background: "white",
                      backgroundOpacity: 0.7,
                      labelColor: "black",
                      labelFontSize: 12,
                      labelFontWeight: "normal",
                      labelFontFamily: "Arial",
                      backgroundStroke: "#DBDBDB",
                      tickColor: "black"
                    },
                    axis: {
                      tickColor: "black",
                      labelColor: "black",
                      labelFontSize: 12,
                      labelFontWeight: "normal",
                      labelFontFamily: "Arial",
                      baselineColor: "black",
                      gridColor: "#E3E3E3",
                      gridStrokeWidth: 1,
                      gridStrokeType: "solid",
                      gridStrokeDash: [4, 4]
                    },
                    markCommon: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    point: {
                      color: "#E79F00",
                      size: 3,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    rect: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    triangle: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    area: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    line: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    bar: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    rule: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 1,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    link: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 1,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    },
                    text: {
                      color: "#E79F00",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 0,
                      opacity: 1,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6],
                      textAnchor: "middle",
                      textFontWeight: "normal"
                    },
                    brush: {
                      color: "gray",
                      size: 1,
                      stroke: "black",
                      strokeWidth: 1,
                      opacity: 0.3,
                      nominalColorRange: [
                        "#E79F00",
                        "#029F73",
                        "#0072B2",
                        "#CB7AA7",
                        "#D45E00",
                        "#57B4E9",
                        "#EFE441"
                      ],
                      quantitativeSizeRange: [2, 6]
                    }
                  }
                }
              }
            ]
          }
        ],
        center: [],
        right: [],
        bottom: [],
        gallery: [],
        whole: []
      },
      initialXDomain: [0, 1e9],
      initialYDomain: [0, 1e9],
      zoomFixed: false,
      zoomLimits: [1, null],
      uid: "154b1b40-f6fb-11eb-914b-976b6ecda162"
    }
  ],
  zoomLocks: { locksByViewUid: {}, locksDict: {} },
  locationLocks: { locksByViewUid: {}, locksDict: {} },
  editable: false,
  chromInfoPath: "https://s3.amazonaws.com/gosling-lang.org/data/hg38.chrom.sizes"
};
function insertItemToArray(array, index, item) {
  return [...array.slice(0, index), item, ...array.slice(index)];
}
function flatArrayToPairArray(array) {
  const output = [];
  for (let i = 0; i < array.length; i += 2) {
    output.push([array[i], array[i + 1]]);
  }
  return output;
}
const HIGLASS_AXIS_SIZE = 30;
const getViewTemplate = (assembly) => {
  return {
    genomePositionSearchBoxVisible: false,
    genomePositionSearchBox: {
      autocompleteServer: "https://higlass.io/api/v1",
      autocompleteId: getAutoCompleteId(assembly),
      chromInfoServer: "https://higlass.io/api/v1",
      chromInfoId: assembly != null ? assembly : "hg38"
    },
    layout: { w: 12, h: 12, x: 0, y: 0 },
    tracks: {
      top: [],
      left: [],
      center: [],
      right: [],
      bottom: [],
      gallery: [],
      whole: []
    },
    initialXDomain: [0, computeChromSizes(assembly).total],
    initialYDomain: [0, computeChromSizes(assembly).total],
    zoomFixed: false
  };
};
class HiGlassModel {
  constructor() {
    this.assembly = "hg38";
    this.hg = {
      compactLayout: false,
      trackSourceServers: [],
      views: [],
      zoomLocks: {
        locksByViewUid: {},
        locksDict: {}
      },
      locationLocks: {
        locksByViewUid: {},
        locksDict: {}
      }
    };
    this.setEditable(false);
  }
  spec() {
    return this.hg;
  }
  setViewOrientation(orientation) {
    this.orientation = orientation;
    return this;
  }
  addDefaultView(uid, assembly) {
    this.hg.views.push(JSON.parse(JSON.stringify({ ...getViewTemplate(assembly), uid })));
    return this;
  }
  setAssembly(assembly) {
    this.assembly = assembly;
    this.setChromInfoPath(computeChromSizes(this.assembly).path);
    return this;
  }
  getAssembly() {
    return this.assembly;
  }
  setTextTrack(width, height, text, textColor = "black", fontSize = 14, fontWeight = "normal", align = "left", backgroundColor = "transparent", fontFamily = "Arial") {
    var _a;
    if (this.getLastView()) {
      (_a = this.getLastView().tracks.top) == null ? void 0 : _a.push({
        type: "text",
        width,
        height,
        options: {
          backgroundColor,
          textColor,
          fontSize,
          fontWeight,
          fontFamily,
          offsetY: 0,
          align,
          text
        }
      });
    }
    return this;
  }
  addBrush(layout, viewId, theme, fromViewUid, style) {
    var _a, _b, _c, _d, _e, _f;
    if (!fromViewUid)
      return;
    (_f = this.getView(viewId)) == null ? void 0 : _f.tracks.whole.push({
      type: layout === "circular" ? "brush-track" : "viewport-projection-horizontal",
      uid: v4(),
      fromViewUid,
      options: {
        projectionFillColor: (_a = style == null ? void 0 : style.color) != null ? _a : theme.brush.color,
        projectionStrokeColor: (_b = style == null ? void 0 : style.stroke) != null ? _b : theme.brush.stroke,
        projectionFillOpacity: (_c = style == null ? void 0 : style.opacity) != null ? _c : theme.brush.opacity,
        projectionStrokeOpacity: (_d = style == null ? void 0 : style.opacity) != null ? _d : theme.brush.opacity,
        strokeWidth: (_e = style == null ? void 0 : style.strokeWidth) != null ? _e : theme.brush.strokeWidth,
        startAngle: style == null ? void 0 : style.startAngle,
        endAngle: style == null ? void 0 : style.endAngle,
        innerRadius: style == null ? void 0 : style.innerRadius,
        outerRadius: style == null ? void 0 : style.outerRadius
      }
    });
    return this;
  }
  getLastView() {
    return this.hg.views[this.hg.views.length - 1];
  }
  getMainTrackPosition() {
    return this.orientation === "vertical" ? "left" : "center";
  }
  getLastVisView() {
    const vs = this.hg.views.filter((v) => {
      var _a, _b;
      return ((_b = (_a = v.tracks[this.getMainTrackPosition()]) == null ? void 0 : _a[0]) == null ? void 0 : _b.type) === "combined";
    });
    return vs[vs.length - 1];
  }
  getView(viewId) {
    return this.hg.views.find((d) => d.uid === viewId);
  }
  validateSpec(silence = false) {
    return validateSpec(HiGlassSchema, this.spec(), silence).state === "success";
  }
  setDomain(xDomain, yDomain) {
    if (xDomain) {
      this.getLastView().initialXDomain = getNumericDomain(xDomain, this.getAssembly());
    }
    if (yDomain) {
      this.getLastView().initialYDomain = getNumericDomain(yDomain, this.getAssembly());
    }
    return this;
  }
  adjustDomain(orientation = "horizontal", width, height) {
    if (orientation !== "vertical") {
      return this;
    }
    const domain = this.getLastView().initialXDomain;
    if (!domain) {
      return this;
    }
    const [start, end] = domain;
    const size = end - start;
    const center = (start + end) / 2;
    this.getLastView().initialXDomain = [
      center - size / width / 2 / height * width,
      center + size / width / 2 / height * width
    ];
    return this;
  }
  setZoomFixed(zoomFixed) {
    this.getLastView().zoomFixed = zoomFixed;
    return this;
  }
  setZoomLimits(zoomLimits) {
    this.getLastView().zoomLimits = zoomLimits;
    return this;
  }
  setLayout(layout) {
    this.getLastView().layout = layout;
    return this;
  }
  setEditable(editable) {
    this.hg.editable = editable;
    return this;
  }
  setChromInfoPath(chromInfoPath) {
    if (this.getLastView()) {
      this.getLastView().chromInfoPath = chromInfoPath;
    }
    this.hg.chromInfoPath = chromInfoPath;
    return this;
  }
  addTrackSourceServers(trackSourceServers) {
    var _a, _b;
    if (trackSourceServers && ((_a = this.hg.trackSourceServers) == null ? void 0 : _a.indexOf(trackSourceServers)) === -1)
      (_b = this.hg.trackSourceServers) == null ? void 0 : _b.push(trackSourceServers);
    return this;
  }
  setMainTrack(track) {
    var _a;
    if (!this.getLastView())
      return this;
    this.getLastView().tracks[this.getMainTrackPosition()] = [
      {
        type: "combined",
        uid: `${(_a = track.uid) != null ? _a : v4()}-${this.getMainTrackPosition()}-combined`,
        width: track.width - 1,
        height: track.height,
        contents: [track]
      }
    ];
    return this;
  }
  addTrackToCombined(track) {
    var _a;
    if (!this.getLastVisView())
      return this;
    (_a = this.getLastVisView().tracks[this.getMainTrackPosition()][0]) == null ? void 0 : _a.contents.push(track);
    return this;
  }
  setAxisTrack(position, type2 = "regular", options) {
    if (!this.hg.views)
      return this;
    const widthOrHeight = position === "left" || position === "right" ? "width" : "height";
    const axisTrackTemplate = {
      type: "axis-track",
      chromInfoPath: this.hg.chromInfoPath,
      options: {
        ...options,
        assembly: this.getAssembly(),
        stroke: "transparent",
        color: options.theme.axis.labelColor,
        fontSize: options.theme.axis.labelFontSize,
        fontFamily: options.theme.axis.labelFontFamily,
        fontWeight: options.theme.axis.labelFontWeight,
        tickColor: options.theme.axis.tickColor,
        tickFormat: type2 === "narrower" ? "si" : "plain",
        tickPositions: type2 === "regular" ? "even" : "ends",
        reverseOrientation: position === "bottom" || position === "right" ? true : false
      }
    };
    if (options.layout === "circular") {
      this.addTrackToCombined({
        ...axisTrackTemplate,
        options: { ...axisTrackTemplate.options, layout: "circular" }
      });
    } else {
      const axisTrack = { ...axisTrackTemplate, [widthOrHeight]: HIGLASS_AXIS_SIZE };
      if (position === "left") {
        if (this.getLastView().tracks.left.filter((d) => d.type === "axis-track").length !== 0) {
          return this;
        }
        this.getLastView().tracks.left = insertItemToArray(this.getLastView().tracks.left, 0, axisTrack);
      } else if (position === "right") {
        if (this.getLastView().tracks.right.filter((d) => d.type === "axis-track").length !== 0) {
          return this;
        }
        this.getLastView().tracks.right.push(axisTrack);
      } else {
        if (this.getLastView().tracks[position].filter((d) => d.type === "axis-track").length !== 0) {
          return this;
        }
        this.getLastView().tracks[position].push(axisTrack);
      }
    }
    return this;
  }
  setExampleHiglassViewConfig() {
    this.hg = example;
  }
}
function logicalComparison(value, op, ref2, transitionPadding) {
  const padding = transitionPadding && transitionPadding !== 0 ? transitionPadding : void 0;
  let alpha = 0;
  switch (op) {
    case "less-than":
    case "LT":
    case "lt":
      alpha = ref2 > value ? padding ? (ref2 - value) / padding : 1 : 0;
      break;
    case "less-than-or-equal-to":
    case "LTET":
    case "ltet":
      alpha = ref2 >= value ? padding ? (ref2 - value) / padding : 1 : 0;
      break;
    case "greater-than":
    case "GT":
    case "gt":
      alpha = ref2 < value ? padding ? (value - ref2) / padding : 1 : 0;
      break;
    case "greater-than-or-equal-to":
    case "GTET":
    case "gtet":
      alpha = ref2 <= value ? padding ? (value - ref2) / padding : 1 : 0;
      break;
  }
  return Math.max(Math.min(1, alpha), 0);
}
function filterData(filter2, data2) {
  const { field, not: not3 } = filter2;
  let output = Array.from(data2);
  if (IsOneOfFilter(filter2)) {
    const { oneOf: oneOf2 } = filter2;
    output = output.filter((d) => {
      return not3 ? oneOf2.indexOf(d[field]) === -1 : oneOf2.indexOf(d[field]) !== -1;
    });
  } else if (IsRangeFilter(filter2)) {
    const { inRange } = filter2;
    output = output.filter((d) => {
      return not3 ? !(inRange[0] <= d[field] && d[field] <= inRange[1]) : inRange[0] <= d[field] && d[field] <= inRange[1];
    });
  } else if (IsIncludeFilter(filter2)) {
    const { include } = filter2;
    output = output.filter((d) => {
      return not3 ? `${d[field]}`.includes(include) : !`${d[field]}`.includes(include);
    });
  }
  return output;
}
function concatString(concat2, data2) {
  const { fields, separator, newField } = concat2;
  let output = Array.from(data2);
  output = output.map((d) => {
    const strs = fields.map((f2) => d[f2]);
    d[newField] = strs.join(separator);
    return d;
  });
  return output;
}
function replaceString(_, data2) {
  const { field, replace, newField } = _;
  let output = Array.from(data2);
  output = output.map((d) => {
    d[newField] = d[field];
    replace.forEach((r) => {
      const { from: from2, to } = r;
      d[newField] = d[newField].toString().replaceAll(from2, to);
    });
    return d;
  });
  return output;
}
function calculateData(log, data2) {
  const { field, base, newField } = log;
  let output = Array.from(data2);
  output = output.map((d) => {
    if (+d[field]) {
      if (base === "e") {
        d[newField != null ? newField : field] = Math.log(+d[field]);
      } else {
        d[newField != null ? newField : field] = Math.log(+d[field]) / Math.log(base != null ? base : 10);
      }
    }
    return d;
  });
  return output;
}
function calculateGenomicLength(_, data2) {
  const { startField, endField, newField } = _;
  const output = Array.from(data2);
  output.forEach((d) => {
    const s = d[startField];
    const e = d[endField];
    if (!s || !e) {
      return;
    }
    d[newField] = Math.abs(+e - +s);
  });
  return output;
}
function inferSvType(_, data2) {
  const { firstBp, secondBp, newField } = _;
  const output = Array.from(data2);
  const [DUP, TRA, DEL, t2tINV, h2hINV] = ["DUP", "TRA", "DEL", "t2tINV", "h2hINV"];
  output.forEach((d) => {
    const chr1 = d[firstBp.chrField];
    const chr2 = d[secondBp.chrField];
    if (chr1 !== chr2) {
      d[newField] = TRA;
      return;
    }
    let pos1 = d[firstBp.posField];
    let pos2 = d[secondBp.posField];
    let strand1 = d[firstBp.strandField];
    let strand2 = d[secondBp.strandField];
    if (pos1 > pos2) {
      const _pos = pos1;
      const _strand = strand1;
      pos1 = pos2;
      strand1 = strand2;
      pos2 = _pos;
      strand2 = _strand;
    }
    switch (`${strand1}${strand2}`) {
      case "+-":
        d[newField] = DEL;
        break;
      case "--":
        d[newField] = t2tINV;
        break;
      case "++":
        d[newField] = h2hINV;
        break;
      case "-+":
        d[newField] = DUP;
        break;
      default:
        d[newField] = "unknown";
    }
  });
  return output;
}
function aggregateCoverage(_, data2, scale) {
  const { startField, endField, newField, groupField } = _;
  const coverage = {};
  const binSize = 1;
  data2.forEach((d) => {
    const curStart = scale(d[startField]);
    const curEnd = scale(d[endField]);
    const group2 = groupField ? d[groupField] : "__NO_GROUP__";
    const adjustedStart = Math.floor(curStart);
    for (let i = adjustedStart; i < curEnd; i += binSize) {
      if (!coverage[group2]) {
        coverage[group2] = {};
      }
      if (!coverage[group2][i]) {
        coverage[group2][i] = 0;
      }
      coverage[group2][i]++;
    }
  });
  const output = Object.entries(coverage).flatMap((group2) => {
    const [groupName, coverageRecords] = group2;
    return Object.entries(coverageRecords).map((entry) => {
      const [key, value] = entry;
      return {
        [startField]: scale.invert(+key),
        [endField]: scale.invert(+key + binSize),
        [newField != null ? newField : "coverage"]: value,
        [groupField != null ? groupField : "group"]: groupName
      };
    });
  });
  return output;
}
function displace(t, data2, scale) {
  const { boundingBox, method, newField } = t;
  const { startField, endField, groupField } = boundingBox;
  let padding = 0;
  if (boundingBox.padding && scale && !boundingBox.isPaddingBP) {
    padding = Math.abs(scale.invert(boundingBox.padding) - scale.invert(0));
  } else if (boundingBox.padding && boundingBox.isPaddingBP) {
    padding = boundingBox.padding;
  }
  const base = Array.from(data2);
  if (base && base.length > 0) {
    if (!Object.keys(base[0]).find((d) => d === startField) || !Object.keys(base[0]).find((d) => d === endField)) {
      return base;
    }
  }
  if (method === "pile") {
    {
      const { maxRows } = t;
      const occupiedSpaceInRows = {};
      const sorted = base.sort((a, b) => a[startField] - b[startField]);
      sorted.forEach((d) => {
        const start = d[startField] - padding;
        const end = d[endField] + padding;
        const group2 = groupField ? d[groupField] : "__NO_GROUP__";
        if (!occupiedSpaceInRows[group2]) {
          occupiedSpaceInRows[group2] = [];
        }
        let rowIndex = occupiedSpaceInRows[group2].findIndex((d2) => {
          if (end < d2.start) {
            d2.start = start;
            return true;
          } else if (d2.end < start) {
            d2.end = end;
            return true;
          }
          return false;
        });
        if (rowIndex === -1) {
          occupiedSpaceInRows[group2].push({ start, end });
          rowIndex = occupiedSpaceInRows[group2].length - 1;
        }
        d[newField] = `${maxRows && maxRows <= rowIndex ? maxRows - 1 : rowIndex}`;
      });
    }
  } else if (method === "spread") {
    const boundingBoxes = [];
    base.sort((a, b) => a[startField] - b[startField]).forEach((d) => {
      let start = d[startField] - padding;
      let end = d[endField] + padding;
      let overlapped = boundingBoxes.filter((box) => box.start === start && end === box.end || box.start < start && start < box.end || box.start < end && end < box.end || start < box.start && box.end < end);
      if (overlapped.length > 0) {
        let trial = 0;
        do {
          overlapped = boundingBoxes.filter((box) => box.start === start && end === box.end || box.start < start && start < box.end || box.start < end && end < box.end || start < box.start && box.end < end);
          if (overlapped.length > 0) {
            if (trial % 2 === 0) {
              start += padding * trial;
              end += padding * trial;
            } else {
              start -= padding * trial;
              end -= padding * trial;
            }
          }
          trial++;
        } while (overlapped.length > 0 && trial < 1e3);
      }
      d[`${newField}Start`] = `${start + padding}`;
      d[`${newField}Etart`] = `${end - padding}`;
      boundingBoxes.push({ start, end });
    });
  }
  return base;
}
function splitExon(split, data2, assembly = "hg38") {
  const { separator, fields, flag } = split;
  let output = Array.from(data2);
  output = output.map((d) => {
    const newRows = [];
    fields.forEach((f2) => {
      const { field, type: type2, newField, chrField } = f2;
      const splitted = d[field].toString().split(separator);
      splitted.forEach((s, i) => {
        let newValue = s;
        if (type2 === "genomic") {
          newValue = computeChromSizes(assembly).interval[d[chrField]][0] + +s;
        }
        if (!newRows[i]) {
          newRows[i] = Object.assign(JSON.parse(JSON.stringify(d)), {
            [newField]: newValue,
            [flag.field]: flag.value
          });
        } else {
          newRows[i][newField] = newValue;
        }
      });
    });
    return [d, ...newRows];
  }).reduce((a, b) => a.concat(b), []);
  return output;
}
function parseSubJSON(_, data2) {
  const { field, genomicField, baseGenomicField, genomicLengthField } = _;
  let output = Array.from(data2);
  output = output.map((d) => {
    let newRows = JSON.parse(d[field]);
    newRows = newRows.map((row) => {
      var _a, _b;
      if (row[genomicField] && d[baseGenomicField]) {
        row[`${genomicField}_start`] = +row[genomicField] + +d[baseGenomicField];
        row[`${genomicField}_end`] = +row[genomicField] + +d[baseGenomicField] + +row[genomicLengthField];
      }
      return Object.assign(JSON.parse(JSON.stringify(d)), {
        ...row,
        [`${genomicField}_start`]: row[`${genomicField}_start`],
        [`${genomicField}_end`]: row[`${genomicField}_end`],
        type: (_b = (_a = row.type) != null ? _a : row.variant) != null ? _b : null,
        isParsedRow: "yes"
      });
    });
    return [d, ...newRows];
  }).reduce((a, b) => a.concat(b), []);
  return output;
}
function aggregateData(spec, data2) {
  if (getChannelKeysByAggregateFnc(spec).length === 0) {
    return data2;
  }
  const nChannelKeys = getChannelKeysByType(spec, "nominal");
  if (nChannelKeys.length !== 1) {
    console.warn("Currently, we only support aggregating datasets with single nominal field.");
    return data2;
  }
  const nFieldSpec = spec[nChannelKeys[0]];
  if (!IsChannelDeep(nFieldSpec)) {
    return data2;
  }
  const nField = nFieldSpec.field;
  if (!nField) {
    return data2;
  }
  const qChannelKeys = [...getChannelKeysByType(spec, "quantitative"), ...getChannelKeysByType(spec, "genomic")];
  const aggregated = [];
  const uniqueCategories = Array.from(new Set(data2.map((d) => d[nField])));
  let failed = false;
  uniqueCategories.forEach((c) => {
    const datum = {};
    datum[nField] = c;
    qChannelKeys.forEach((q) => {
      const qFieldSpec = spec[q];
      if (!IsChannelDeep(qFieldSpec)) {
        failed = true;
        return;
      }
      const { field: qField } = qFieldSpec;
      if (!qField || !("aggregate" in qFieldSpec)) {
        failed = true;
        return;
      }
      datum[qField] = qFieldSpec.aggregate === "max" ? Math.max(...data2.filter((d) => d[nField] === c).map((d) => +d[qField])) : Math.min(...data2.filter((d) => d[nField] === c).map((d) => +d[qField]));
    });
    aggregated.push(datum);
  });
  return !failed ? aggregated : data2;
}
const CHANNEL_DEFAULTS = {
  NOMINAL_COLOR: ["#E79F00", "#029F73", "#0072B2", "#CB7AA7", "#D45E00", "#57B4E9", "#EFE441"],
  NOMINAL_COLOR_EXTENDED: [
    "#d60000",
    "#018700",
    "#b500ff",
    "#05acc6",
    "#97ff00",
    "#ffa52f",
    "#ff8ec8",
    "#79525e",
    "#00fdcf",
    "#afa5ff",
    "#93ac83",
    "#9a6900",
    "#366962",
    "#d3008c",
    "#fdf490",
    "#c86e66",
    "#9ee2ff",
    "#00c846",
    "#a877ac",
    "#b8ba01",
    "#f4bfb1",
    "#ff28fd",
    "#f2cdff",
    "#009e7c",
    "#ff6200",
    "#56642a",
    "#953f1f",
    "#90318e",
    "#ff3464",
    "#a0e491",
    "#8c9ab1",
    "#829026",
    "#ae083f",
    "#77c6ba",
    "#bc9157",
    "#e48eff",
    "#72b8ff",
    "#c6a5c1",
    "#ff9070",
    "#d3c37c",
    "#bceddb",
    "#6b8567",
    "#916e56",
    "#f9ff00",
    "#bac1df",
    "#ac567c",
    "#ffcd03",
    "#ff49b1",
    "#c15603",
    "#5d8c90",
    "#c144bc",
    "#00753f",
    "#ba6efd",
    "#00d493",
    "#00ff75",
    "#49a150",
    "#cc9790",
    "#00ebed",
    "#db7e01",
    "#f77589",
    "#b89500",
    "#c84248",
    "#00cff9",
    "#755726",
    "#85d401",
    "#ebffd4",
    "#a77b87",
    "#db72c8",
    "#cae256",
    "#8abf5d",
    "#a1216b",
    "#855b89",
    "#89bacf",
    "#ffbad6",
    "#b6cfaa",
    "#97414d",
    "#67aa00",
    "#fde1b1",
    "#ff3628",
    "#80793d",
    "#d6e8ff",
    "#a795c6",
    "#7ea59a",
    "#d182a3",
    "#54823b",
    "#e6a872",
    "#9cffff",
    "#da5480",
    "#05b3aa",
    "#ffaaf6",
    "#d1afef",
    "#da015d",
    "#ac1a13",
    "#60b385",
    "#d442fd",
    "#acaa59",
    "#fb9ca7",
    "#b3723b",
    "#f26952",
    "#aed1d4",
    "#9affc3",
    "#dbb333",
    "#eb01c3",
    "#9900c4",
    "#cfff9e",
    "#a55949",
    "#3b6d01",
    "#008579",
    "#959167",
    "#89dbb3",
    "#6d7400",
    "#aa5dca",
    "#07ef00",
    "#804f3d",
    "#d88052",
    "#ffc862",
    "#b8009e",
    "#99acdd",
    "#904f00",
    "#8c4470",
    "#4f6e52",
    "#ff8734",
    "#c68ecd",
    "#d4e29e",
    "#b1826d",
    "#9cfb75",
    "#56dd77",
    "#f90087",
    "#a1cdff",
    "#13cad1",
    "#118e54",
    "#d154a5",
    "#00dfc3",
    "#a3832f",
    "#77975b",
    "#baaa80",
    "#70a3af",
    "#d6fbff",
    "#e8013a",
    "#d84621",
    "#ff82ed",
    "#b63862",
    "#b6cd72",
    "#97626b",
    "#897490",
    "#00a316",
    "#00f4a1",
    "#bf90f2",
    "#89e4d8",
    "#a34d95",
    "#6e5d00",
    "#8cc68e",
    "#95aa2a",
    "#c672dd",
    "#b33b01",
    "#d69a36",
    "#dfacb6",
    "#009aa0",
    "#599000",
    "#97bca8",
    "#ac8ca8",
    "#dad4ff",
    "#547c72",
    "#00ba69",
    "#ffc38e",
    "#b800d4",
    "#dfcf5b",
    "#629a7b",
    "#bfedbc",
    "#c1bdfd",
    "#80d3dd",
    "#e2857e",
    "#f9eb4d",
    "#bf6d82",
    "#caff4f",
    "#ef72aa",
    "#ed67ff",
    "#9946ae",
    "#6d6942",
    "#e25660",
    "#dd662d",
    "#9cdb5d",
    "#e29ccf",
    "#b87500",
    "#c6002d",
    "#dfbcda",
    "#59b5df",
    "#ff59da",
    "#38c1a1",
    "#9e698c",
    "#acaac8",
    "#95622f",
    "#b55662",
    "#2b7e60",
    "#b1e400",
    "#eda590",
    "#95fde2",
    "#ff548e",
    "#bd6ea1",
    "#aa3b36",
    "#d8cf00",
    "#aa80cd",
    "#a08052",
    "#e100e8",
    "#c35b3d",
    "#b53a85",
    "#8c7700",
    "#dbbc95",
    "#529e93",
    "#afbc82",
    "#91b5b6",
    "#a75423",
    "#ffd4ef",
    "#79ae6b",
    "#5db54b",
    "#80fb9a",
    "#48ffef",
    "#979548",
    "#9387a7",
    "#31d400",
    "#6ee956",
    "#b6d4eb",
    "#705470",
    "#f2db8a",
    "#aad4c1",
    "#7ecdf2",
    "#89ba00",
    "#64b6ba",
    "#ffb500",
    "#c38285",
    "#caaa5e",
    "#647748",
    "#59e2ff",
    "#df4dcd",
    "#e9ff79",
    "#bc66b8",
    "#c395a5",
    "#64c674",
    "#d19570",
    "#70cf4f",
    "#aa6e66",
    "#9c60a5",
    "#00b800",
    "#e299b3",
    "#bc006b",
    "#b3e8ef",
    "#cdbfe4",
    "#77a342",
    "#856277",
    "#568e5b",
    "#9eafc4",
    "#e82fa0",
    "#247c2a",
    "#826723",
    "#bfbc4d",
    "#ddd3a5"
  ],
  QUANTITATIVE_COLOR: "viridis",
  SIZE: 3,
  SIZE_RANGE: [2, 6]
};
function getTheme(theme = "light") {
  if (typeof theme === "string") {
    if (gt.isThereTheme(theme)) {
      return gt.getTheme(theme);
    } else if (theme === "dark" || theme === "light") {
      return THEMES[theme];
    } else {
      return THEMES["light"];
    }
  } else {
    let baseSpec = JSON.parse(JSON.stringify(THEMES["light"]));
    if (gt.isThereTheme(theme.base)) {
      baseSpec = gt.getTheme(theme.base);
    } else if (theme.base === "light" || theme.base === "dark") {
      baseSpec = JSON.parse(JSON.stringify(THEMES[theme.base]));
    }
    Object.keys(baseSpec).forEach((k) => {
      if (theme[k] && k !== "base") {
        baseSpec[k] = Object.assign(JSON.parse(JSON.stringify(baseSpec[k])), JSON.parse(JSON.stringify(theme[k])));
      }
    });
    return baseSpec;
  }
}
const LightThemeMarkCommonStyle = {
  color: CHANNEL_DEFAULTS.NOMINAL_COLOR[0],
  size: 1,
  stroke: "black",
  strokeWidth: 0,
  opacity: 1,
  nominalColorRange: CHANNEL_DEFAULTS.NOMINAL_COLOR,
  quantitativeSizeRange: [2, 6]
};
const DarkThemeMarkCommonStyle = { ...LightThemeMarkCommonStyle, stroke: "white" };
const THEMES = {
  light: {
    base: "light",
    root: {
      background: "white",
      titleColor: "black",
      titleBackgroundColor: "transparent",
      titleFontSize: 18,
      titleFontFamily: "Arial",
      titleAlign: "left",
      titleFontWeight: "bold",
      subtitleColor: "gray",
      subtitleBackgroundColor: "transparent",
      subtitleFontSize: 16,
      subtitleFontFamily: "Arial",
      subtitleFontWeight: "normal",
      subtitleAlign: "left",
      showMousePosition: true,
      mousePositionColor: "#000000"
    },
    track: {
      background: "transparent",
      alternatingBackground: "transparent",
      titleColor: "black",
      titleBackground: "white",
      titleFontSize: 24,
      titleAlign: "left",
      outline: "black",
      outlineWidth: 1
    },
    legend: {
      position: "top",
      background: "white",
      backgroundOpacity: 0.7,
      labelColor: "black",
      labelFontSize: 12,
      labelFontWeight: "normal",
      labelFontFamily: "Arial",
      backgroundStroke: "#DBDBDB",
      tickColor: "black"
    },
    axis: {
      tickColor: "black",
      labelColor: "black",
      labelFontSize: 12,
      labelFontWeight: "normal",
      labelFontFamily: "Arial",
      baselineColor: "black",
      gridColor: "#E3E3E3",
      gridStrokeWidth: 1,
      gridStrokeType: "solid",
      gridStrokeDash: [4, 4]
    },
    markCommon: {
      ...LightThemeMarkCommonStyle
    },
    point: {
      ...LightThemeMarkCommonStyle,
      size: 3
    },
    rect: {
      ...LightThemeMarkCommonStyle
    },
    triangle: {
      ...LightThemeMarkCommonStyle
    },
    area: {
      ...LightThemeMarkCommonStyle
    },
    line: {
      ...LightThemeMarkCommonStyle
    },
    bar: {
      ...LightThemeMarkCommonStyle
    },
    rule: {
      ...LightThemeMarkCommonStyle,
      strokeWidth: 1
    },
    link: {
      ...LightThemeMarkCommonStyle,
      strokeWidth: 1
    },
    text: {
      ...LightThemeMarkCommonStyle,
      textAnchor: "middle",
      textFontWeight: "normal"
    },
    brush: {
      ...LightThemeMarkCommonStyle,
      color: "gray",
      opacity: 0.3,
      stroke: "black",
      strokeWidth: 1
    }
  },
  dark: {
    base: "dark",
    root: {
      background: "black",
      titleColor: "white",
      titleBackgroundColor: "transparent",
      titleFontSize: 18,
      titleFontFamily: "Arial",
      titleAlign: "middle",
      titleFontWeight: "bold",
      subtitleColor: "lightgray",
      subtitleBackgroundColor: "transparent",
      subtitleFontSize: 16,
      subtitleFontFamily: "Arial",
      subtitleAlign: "middle",
      subtitleFontWeight: "normal",
      showMousePosition: true,
      mousePositionColor: "#FFFFFF"
    },
    track: {
      background: "transparent",
      alternatingBackground: "transparent",
      titleColor: "white",
      titleBackground: "black",
      titleFontSize: 18,
      titleAlign: "left",
      outline: "white",
      outlineWidth: 1
    },
    legend: {
      position: "right",
      background: "black",
      backgroundOpacity: 0.7,
      labelColor: "white",
      labelFontSize: 12,
      labelFontWeight: "normal",
      labelFontFamily: "Arial",
      backgroundStroke: "#DBDBDB",
      tickColor: "white"
    },
    axis: {
      tickColor: "white",
      labelColor: "white",
      labelFontSize: 10,
      labelFontWeight: "normal",
      labelFontFamily: "Arial",
      baselineColor: "white",
      gridColor: "gray",
      gridStrokeWidth: 1,
      gridStrokeType: "solid",
      gridStrokeDash: [4, 4]
    },
    markCommon: {
      ...DarkThemeMarkCommonStyle
    },
    point: {
      ...DarkThemeMarkCommonStyle,
      size: 3
    },
    rect: {
      ...DarkThemeMarkCommonStyle
    },
    triangle: {
      ...DarkThemeMarkCommonStyle
    },
    area: {
      ...DarkThemeMarkCommonStyle
    },
    line: {
      ...DarkThemeMarkCommonStyle
    },
    bar: {
      ...DarkThemeMarkCommonStyle
    },
    rule: {
      ...DarkThemeMarkCommonStyle,
      strokeWidth: 1
    },
    link: {
      ...DarkThemeMarkCommonStyle,
      strokeWidth: 1
    },
    text: {
      ...DarkThemeMarkCommonStyle,
      textAnchor: "middle",
      textFontWeight: "normal"
    },
    brush: {
      ...DarkThemeMarkCommonStyle,
      color: "lightgray",
      opacity: 0.3,
      stroke: "white",
      strokeWidth: 1
    }
  }
};
const isPointInsideDonutSlice = ([x, y], [cx, cy], [innerRadius, outerRadius], [startAngle, endAngle]) => {
  const dist2 = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
  if (dist2 < innerRadius || outerRadius < dist2) {
    return false;
  }
  const degree = pointsToDegree(x, y, cx, cy);
  if (degree < startAngle || endAngle < degree) {
    return false;
  }
  return true;
};
const isPointNearPoint = ([x1, y1], [x2, y2], radius = 5) => {
  return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2) < radius;
};
const isPointInsideRange = ([x1, x2], x) => {
  return x1 <= x && x <= x2;
};
const isCircleWithinRange = (range2, x, radius = 5) => {
  return isPointInsideRange(range2, x - radius) && isPointInsideRange(range2, x + radius);
};
const isAllPointsWithinRange = (range2, path) => {
  return path.filter((_, i) => i % 2 === 0).every((x) => isPointInsideRange(range2, x));
};
const isPointNearLine = ([x, y], path, dist2 = 5) => {
  let x1;
  let y1;
  let x2;
  let y2;
  let isWithin = false;
  for (let i = 0; i < path.length - 2; i += 2) {
    x1 = path[i];
    y1 = path[i + 1];
    x2 = path[i + 2];
    y2 = path[i + 3];
    const AB = [x2 - x1, y2 - y1];
    const BE = [x - x2, y - y2];
    const AE = [x - x1, y - y1];
    const AB_BE = AB[0] * BE[0] + AB[1] * BE[1];
    const AB_AE = AB[0] * AE[0] + AB[1] * AE[1];
    let actDist = 0;
    if (AB_BE > 0) {
      actDist = Math.sqrt((y - y2) ** 2 + (x - x2) ** 2);
    } else if (AB_AE < 0) {
      actDist = Math.sqrt((y - y1) ** 2 + (x - x1) ** 2);
    } else {
      actDist = Math.abs(AB[0] * AE[1] - AB[1] * AE[0]) / Math.sqrt(AB[0] ** 2 + AB[1] ** 2);
    }
    if (actDist < dist2) {
      isWithin = true;
    }
  }
  return isWithin;
};
const isPointInPolygon = ([x, y], polygon) => {
  let x1;
  let y1;
  let x2;
  let y2;
  let isWithin = false;
  for (let i = 0, j = polygon.length - 2; i < polygon.length; i += 2) {
    x1 = polygon[i];
    y1 = polygon[i + 1];
    x2 = polygon[j];
    y2 = polygon[j + 1];
    if (y1 > y !== y2 > y && x < (x2 - x1) * (y - y1) / (y2 - y1) + x1) {
      isWithin = !isWithin;
    }
    j = i;
  }
  return isWithin;
};
class MouseEventModel {
  constructor() {
    this.data = [];
  }
  size() {
    return this.data.length;
  }
  addPolygonBasedEvent(value, polygon) {
    this.data.push({ uid: v4(), type: "polygon", value, polygon });
  }
  addPointBasedEvent(value, pointAndRadius) {
    this.data.push({ uid: v4(), type: "point", value, polygon: pointAndRadius });
  }
  addLineBasedEvent(value, path) {
    this.data.push({ uid: v4(), type: "line", value, polygon: path });
  }
  clear() {
    this.data = [];
  }
  find(x, y, reverse = false) {
    const _ = Array.from(this.data);
    if (reverse)
      _.reverse();
    return _.find((d) => this.isMouseWithin(d, x, y));
  }
  findAll(x, y, reverse = false) {
    const _ = Array.from(this.data);
    if (reverse)
      _.reverse();
    return _.filter((d) => this.isMouseWithin(d, x, y));
  }
  getSiblings(source, idField) {
    const siblings = [];
    const sourceUids = Array.from(new Set(source.map((d) => d.uid)));
    source.forEach((s) => {
      const id = s.value[idField];
      if (id) {
        siblings.push(...this.data.filter((_) => _.value[idField] === id && sourceUids.indexOf(_.uid) === -1));
      }
    });
    return siblings;
  }
  isMouseWithin(data2, x, y) {
    switch (data2.type) {
      case "point":
        return isPointNearPoint([x, y], data2.polygon);
      case "line":
        return isPointNearLine([x, y], data2.polygon);
      case "polygon":
      default:
        return isPointInPolygon([x, y], data2.polygon);
    }
  }
  findAllWithinRange(x1, x2, reverse = false) {
    const _ = Array.from(this.data);
    if (reverse)
      _.reverse();
    return _.filter((d) => this.isWithinRange(d, x1, x2));
  }
  isWithinRange(data2, x1, x2) {
    switch (data2.type) {
      case "point":
        return isCircleWithinRange([x1, x2], data2.polygon[0], data2.polygon[2]);
      case "line":
      case "polygon":
      default:
        return isAllPointsWithinRange([x1, x2], data2.polygon);
    }
  }
}
class GoslingTrackModel {
  constructor(spec, data2, theme) {
    this.id = v1();
    this.theme = theme != null ? theme : getTheme();
    this.dataOriginal = JSON.parse(JSON.stringify(data2));
    this.dataAggregated = JSON.parse(JSON.stringify(data2));
    this.specOriginal = JSON.parse(JSON.stringify(spec));
    this.specComplete = JSON.parse(JSON.stringify(spec));
    this.channelScales = {};
    this.mouseEventModel = new MouseEventModel();
    const validity = this.validateSpec();
    if (!validity.valid) {
      console.warn("Gosling specification is not valid!", validity.errorMessages);
      return;
    }
    this.generateCompleteSpec(this.specComplete);
    this.flipRanges(this.specComplete);
    this.generateScales();
    this.dataAggregated = aggregateData(this.spec(), this.dataAggregated);
  }
  getId() {
    return this.id;
  }
  getRenderingId() {
    var _a;
    return (_a = this.spec()._renderingId) != null ? _a : this.getId();
  }
  originalSpec() {
    return this.specOriginal;
  }
  spec() {
    return this.specComplete;
  }
  data() {
    return this.dataAggregated;
  }
  getMouseEventModel() {
    return this.mouseEventModel;
  }
  generateCompleteSpec(spec) {
    if (!spec.width || !spec.height) {
      console.warn("Size of track is not determined yet.");
      return;
    }
    if (spec.orientation === "vertical") {
      const width = spec.width;
      spec.width = spec.height;
      spec.height = width;
    }
    const xOrY = this.getGenomicChannelKey();
    let isAxisShown = false;
    if (xOrY === "x") {
      isAxisShown = IsChannelDeep(spec.x) && spec.x.axis !== void 0 && spec.x.axis !== "none";
    }
    if (xOrY === "y") {
      isAxisShown = IsChannelDeep(spec.y) && spec.y.axis !== void 0 && spec.y.axis !== "none";
    }
    if (spec.layout !== "circular") {
      if (IsChannelDeep(spec.x) && spec.x.axis !== void 0 && spec.x.axis !== "none") {
        spec.height -= HIGLASS_AXIS_SIZE;
      }
    } else {
      if (xOrY === "x" && isAxisShown && IsChannelDeep(spec.x) && spec.x.axis === "top") {
        spec["outerRadius"] = spec["outerRadius"] - HIGLASS_AXIS_SIZE;
      } else if (xOrY === "x" && isAxisShown && IsChannelDeep(spec.x) && spec.x.axis === "bottom") {
        spec["innerRadius"] = spec["innerRadius"] + HIGLASS_AXIS_SIZE;
      }
    }
    SUPPORTED_CHANNELS.forEach((channelKey) => {
      const channel = spec[channelKey];
      if (IsChannelDeep(channel) && !("zeroBaseline" in channel) && channel.type === "quantitative") {
        channel.zeroBaseline = true;
      }
    });
    this.addScaleMaterials(spec);
  }
  flipRanges(spec) {
    if (IsChannelDeep(spec.y) && spec.y.flip && Array.isArray(spec.y.range)) {
      spec.y.range = spec.y.range.reverse();
    }
  }
  getGenomicChannelKey() {
    return getGenomicChannelKeyFromTrack(this.spec());
  }
  getGenomicChannel() {
    return getGenomicChannelFromTrack(this.spec());
  }
  setChannelDomain(channelKey, domain, force) {
    const channelRaw = this.originalSpec()[channelKey];
    if (!force && IsChannelDeep(channelRaw) && channelRaw.domain !== void 0) {
      return;
    }
    const channel = this.specComplete[channelKey];
    if (IsChannelDeep(channel)) {
      channel.domain = domain;
    }
  }
  setChannelRange(channelKey, range2) {
    const channel = this.specComplete[channelKey];
    if (IsChannelDeep(channel)) {
      channel.range = range2;
    }
  }
  updateChannelValue() {
    if (this.originalSpec().y === void 0) {
      const y = this.spec().y;
      const rowCategories = this.getChannelDomainArray("row");
      if (y && IsChannelValue(y) && rowCategories && this.spec().mark !== "withinLink") {
        y.value = this.spec().height / rowCategories.length / 2;
      }
    }
  }
  encodedValue(channelKey, value) {
    var _a;
    if (channelKey === "text" && value !== void 0) {
      return `${+value ? ~~value : value}`;
    }
    const channel = this.spec()[channelKey];
    const channelFieldType = IsChannelDeep(channel) ? channel.type : IsChannelValue(channel) ? "constant" : void 0;
    if (!channelFieldType) {
      return void 0;
    }
    if (channelFieldType === "constant") {
      return this.channelScales[channelKey]();
    }
    if (value === void 0) {
      return void 0;
    }
    if (value === null) {
      if (channelFieldType === "quantitative") {
        value = 0;
      } else if (channelFieldType === "nominal") {
        value = "null";
      }
    }
    if (typeof this.channelScales[channelKey] !== "function") {
      return void 0;
    }
    switch (channelKey) {
      case "x":
      case "y":
      case "x1":
      case "y1":
      case "xe":
      case "ye":
      case "x1e":
        if (channelFieldType === "quantitative" || channelFieldType === "genomic") {
          return this.channelScales[channelKey](value);
        }
        if (channelFieldType === "nominal") {
          return this.channelScales[channelKey](value);
        }
        break;
      case "stroke":
      case "color":
        if (channelFieldType === "quantitative") {
          const s = this.channelScales[channelKey].copy();
          const d = s.domain();
          const e = d[1] - d[0];
          const so = Array.from((_a = channel.scaleOffset) != null ? _a : [0, 1]);
          return s.domain([d[0] + e * so.sort()[0], d[0] + e * so.sort()[1]])(value);
        }
        if (channelFieldType === "nominal") {
          return this.channelScales[channelKey](value);
        }
        break;
      case "size":
        if (channelFieldType === "quantitative") {
          return this.channelScales[channelKey](value);
        }
        if (channelFieldType === "nominal") {
          return this.channelScales[channelKey](value);
        }
        break;
      case "row":
        if (channelFieldType === "nominal") {
          return this.channelScales[channelKey](value);
        }
        break;
      case "strokeWidth":
      case "opacity":
        if (channelFieldType === "quantitative") {
          return this.channelScales[channelKey](value);
        }
        break;
      default:
        console.warn(`${channelKey} is not supported for encoding values, so returning a undefined value`);
        return void 0;
    }
  }
  trackVisibility(currentStage) {
    const spec = this.spec();
    if (!spec.visibility || spec.visibility.length === 0 || spec.visibility.filter((d) => d.target === "track").length === 0) {
      return true;
    }
    let visibility = true;
    spec.visibility.filter((d) => d.target === "track").forEach((d) => {
      const { operation, measure, threshold } = d;
      let compareValue;
      if (measure === "zoomLevel") {
        compareValue = currentStage[measure];
      } else {
        compareValue = spec[measure];
      }
      if (compareValue !== void 0) {
        visibility = visibility && logicalComparison(compareValue, operation, threshold) === 1;
      }
    });
    return visibility;
  }
  markVisibility(datum, metrics) {
    const spec = this.spec();
    if (!spec.visibility || spec.visibility.length === 0 || spec.visibility.filter((d) => d.target === "mark").length === 0) {
      return 1;
    }
    let visibility = 1;
    spec.visibility.filter((d) => d.target === "mark").forEach((d) => {
      const { operation, threshold, conditionPadding, transitionPadding, measure } = d;
      const padding = conditionPadding != null ? conditionPadding : 0;
      const mark = spec.mark;
      let newVisibility = 1;
      if (mark === "text" && threshold === "|xe-x|" && measure === "width") {
        const xe = this.encodedPIXIProperty("xe", datum);
        const x = this.encodedPIXIProperty("x", datum);
        if (xe !== void 0 && (metrics == null ? void 0 : metrics.width)) {
          newVisibility = logicalComparison(metrics.width + padding, operation, Math.abs(xe - x), transitionPadding);
        }
      } else if (measure === "width" && typeof threshold === "number" && (metrics == null ? void 0 : metrics.width)) {
        newVisibility = logicalComparison(metrics.width + padding, operation, threshold, transitionPadding);
      } else if (measure === "zoomLevel" && typeof threshold === "number" && (metrics == null ? void 0 : metrics.zoomLevel)) {
        newVisibility = logicalComparison(metrics.zoomLevel, operation, threshold, transitionPadding);
      }
      if (visibility > newVisibility) {
        visibility = newVisibility;
      }
    });
    return visibility;
  }
  visualPropertyByChannel(channelKey, datum) {
    const value = datum !== void 0 ? getValueUsingChannel(datum, this.spec()[channelKey]) : void 0;
    return this.encodedValue(channelKey, value);
  }
  encodedPIXIProperty(propertyKey, datum, additionalInfo) {
    const mark = this.spec().mark;
    if ([
      "text",
      "color",
      "row",
      "stroke",
      "opacity",
      "strokeWidth",
      "x",
      "y",
      "xe",
      "x1",
      "x1e",
      "ye",
      "size"
    ].includes(propertyKey)) {
      return this.visualPropertyByChannel(propertyKey, datum);
    }
    switch (mark) {
      case "bar":
        return barProperty(this, propertyKey, datum, additionalInfo);
      case "point":
      case "text":
        return pointProperty(this, propertyKey, datum);
      case "rect":
        return rectProperty(this, propertyKey, datum, additionalInfo);
      default:
        return void 0;
    }
  }
  addScaleMaterials(spec) {
    const data2 = this.data();
    const genomicChannel = this.getGenomicChannel();
    if (!genomicChannel || !genomicChannel.field) {
      console.warn("Genomic field is not provided in the specification");
      return;
    }
    if (typeof spec.width === "undefined" || typeof spec.height === "undefined") {
      console.warn("Track size is not determined yet");
      return;
    }
    SUPPORTED_CHANNELS.forEach((channelKey) => {
      var _a, _b, _c, _d;
      const channel = spec[channelKey];
      if (IsStackedChannel(spec, channelKey) && IsChannelDeep(channel)) {
        const pivotedData = group(data2, (d) => d[genomicChannel.field]);
        const xKeys = [...pivotedData.keys()];
        if (!channel.domain) {
          const min2 = "zeroBaseline" in channel && channel.zeroBaseline ? 0 : min$1(xKeys.map((d) => sum(pivotedData.get(d).map((_d2) => channel.field ? _d2[channel.field] : void 0))));
          const max2 = max$1(xKeys.map((d) => sum(pivotedData.get(d).map((_d2) => channel.field ? _d2[channel.field] : void 0))));
          channel.domain = [min2, max2];
        }
        if (!channel.range) {
          const rowChannel = spec.row;
          const rowField = IsChannelDeep(rowChannel) ? rowChannel.field : void 0;
          const rowCategories = (_a = this.getChannelDomainArray("row")) != null ? _a : rowField ? Array.from(new Set(data2.map((d) => d[rowField]))) : [1];
          const rowHeight = spec.height / rowCategories.length;
          switch (channelKey) {
            case "x":
              channel.range = [0, spec.width];
              break;
            case "y":
              channel.range = [0, rowHeight];
              break;
          }
        }
      } else {
        const rowChannel = spec.row;
        const rowField = IsChannelDeep(rowChannel) ? rowChannel.field : void 0;
        const rowCategories = (_b = this.getChannelDomainArray("row")) != null ? _b : rowField ? Array.from(new Set(data2.map((d) => d[rowField]))) : [1];
        const rowHeight = spec.height / rowCategories.length;
        if (!channel) {
          let value;
          switch (channelKey) {
            case "x":
              value = spec.width / 2;
              break;
            case "y":
              if (spec.mark === "withinLink")
                value = rowHeight;
              else
                value = rowHeight / 2;
              break;
            case "size":
              if (spec.mark === "line")
                value = this.theme.line.size;
              else if (spec.mark === "bar")
                value = void 0;
              else if (spec.mark === "rect")
                value = void 0;
              else if (spec.mark === "triangleRight")
                value = void 0;
              else if (spec.mark === "triangleLeft")
                value = void 0;
              else if (spec.mark === "triangleBottom")
                value = void 0;
              else if (spec.stretch && spec.mark === "point" && IsChannelDeep(spec.x) && IsChannelDeep(spec.xe))
                value = void 0;
              else if (spec.mark === "text")
                value = 12;
              else
                value = this.theme.point.size;
              break;
            case "color":
              value = this.theme.markCommon.color;
              break;
            case "row":
              value = 0;
              break;
            case "stroke":
              if (spec.mark === "text")
                value = this.theme.text.stroke;
              else
                value = this.theme.markCommon.stroke;
              break;
            case "strokeWidth":
              if (spec.mark === "rule")
                value = this.theme.rule.strokeWidth;
              else if (spec.mark === "withinLink" || spec.mark === "betweenLink")
                value = this.theme.link.strokeWidth;
              else if (spec.mark === "text")
                value = this.theme.text.strokeWidth;
              else
                value = this.theme.markCommon.strokeWidth;
              break;
            case "opacity":
              value = this.theme.markCommon.opacity;
              break;
            case "text":
              value = "";
              break;
          }
          if (typeof value !== "undefined") {
            spec[channelKey] = { value };
          }
        } else if (IsChannelDeep(channel) && (channel.type === "quantitative" || channel.type === "genomic")) {
          if (channel.domain === void 0) {
            const min2 = "zeroBaseline" in channel && channel.zeroBaseline ? 0 : (_c = min$1(data2.map((d) => +d[channel.field]))) != null ? _c : 0;
            const max2 = (_d = max$1(data2.map((d) => +d[channel.field]))) != null ? _d : 0;
            channel.domain = [min2, max2];
          } else if (channel.type === "genomic" && !IsDomainArray(channel.domain)) {
            channel.domain = getNumericDomain(channel.domain);
          }
          if ((channelKey === "color" || channelKey === "stroke") && channel.type === "quantitative" && !channel.scaleOffset) {
            channel.scaleOffset = [0, 1];
          }
          if (!channel.range) {
            let range2;
            switch (channelKey) {
              case "x":
              case "xe":
              case "x1":
              case "x1e":
                range2 = [0, spec.width];
                break;
              case "y":
              case "ye":
                range2 = [0, rowHeight];
                break;
              case "color":
              case "stroke":
                range2 = CHANNEL_DEFAULTS.QUANTITATIVE_COLOR;
                break;
              case "size":
                range2 = this.theme.markCommon.quantitativeSizeRange;
                break;
              case "strokeWidth":
                range2 = [1, 3];
                break;
              case "opacity":
                range2 = [0, 1];
                break;
            }
            if (range2) {
              channel.range = range2;
            }
          }
        } else if (IsChannelDeep(channel) && channel.type === "nominal") {
          if (channel.domain === void 0) {
            channel.domain = Array.from(new Set(data2.map((d) => {
              var _a2;
              return (_a2 = d[channel.field]) != null ? _a2 : "null";
            })));
          }
          if (!channel.range) {
            let startSize = 2;
            let range2;
            switch (channelKey) {
              case "x":
              case "xe":
                range2 = [0, spec.width];
                break;
              case "y":
              case "ye":
                range2 = [rowHeight, 0];
                break;
              case "color":
              case "stroke":
                range2 = this.theme.markCommon.nominalColorRange;
                break;
              case "row":
                range2 = [0, spec.height];
                break;
              case "size":
                range2 = channel.domain.map(() => startSize++);
                break;
            }
            if (range2) {
              channel.range = range2;
            }
          }
        }
      }
    });
    [
      ["x", "xe"],
      ["y", "ye"]
    ].forEach((pair) => {
      const [k1, k2] = pair;
      const c1 = spec[k1], c2 = spec[k2];
      if (IsChannelDeep(c1) && IsChannelDeep(c2) && c1.type === c2.type && c1.domain && c2.domain && Array.isArray(c1.domain) && Array.isArray(c2.domain)) {
        if (c1.type === "genomic" || c1.type === "quantitative") {
          const min2 = min$1([c1.domain[0], c2.domain[0]]);
          const max2 = max$1([c1.domain[1], c2.domain[1]]);
          c1.domain = c2.domain = [min2, max2];
        } else if (c1.type === "nominal") {
          const range2 = Array.from(/* @__PURE__ */ new Set([...c1.domain, ...c2.domain]));
          c1.range = c2.range = range2;
        }
      }
    });
  }
  generateScales() {
    const spec = this.spec();
    SUPPORTED_CHANNELS.forEach((channelKey) => {
      const channel = spec[channelKey];
      if (IsChannelValue(channel)) {
        this.channelScales[channelKey] = () => channel.value;
      } else if (IsChannelDeep(channel)) {
        if (channelKey === "text") {
          return;
        }
        const domain = channel.domain;
        const range2 = channel.range;
        if (domain === void 0 || range2 === void 0) {
          return;
        }
        if (channel.type === "quantitative" || channel.type === "genomic") {
          switch (channelKey) {
            case "x":
            case "x1":
            case "xe":
            case "x1e":
            case "y":
            case "ye":
            case "size":
            case "opacity":
            case "strokeWidth":
              this.channelScales[channelKey] = scaleLinear().domain(domain).range(range2);
              break;
            case "color":
            case "stroke":
              let interpolate = interpolateViridis;
              if (Object.keys(PREDEFINED_COLOR_STR_MAP).includes(range2)) {
                interpolate = PREDEFINED_COLOR_STR_MAP[range2];
              }
              this.channelScales[channelKey] = scaleSequential(interpolate).domain(domain);
              break;
          }
        } else if (channel.type === "nominal") {
          switch (channelKey) {
            case "x":
            case "xe":
            case "y":
            case "ye":
            case "row":
              this.channelScales[channelKey] = scaleBand().domain(domain).range(range2);
              break;
            case "size":
              this.channelScales[channelKey] = scaleOrdinal().domain(domain).range(range2);
              break;
            case "color":
            case "stroke":
              this.channelScales[channelKey] = scaleOrdinal(range2).domain(domain);
              break;
          }
        }
      }
    });
  }
  getChannelScale(channelKey) {
    return this.channelScales[channelKey];
  }
  setChannelScale(channelKey, scale) {
    this.channelScales[channelKey] = scale;
  }
  addDataRows(_) {
    this.dataAggregated = [...this.dataAggregated, ..._];
  }
  isShowYAxis() {
    const spec = this.spec();
    const yDomain = this.getChannelDomainArray("y");
    const yRange = this.getChannelRangeArray("y");
    return IsChannelDeep(spec.y) && spec.y.axis !== "none" && spec.y.type === "quantitative" && !!yDomain && !!yRange;
  }
  getChannelDomainArray(channelKey) {
    const c = this.spec()[channelKey];
    return IsChannelDeep(c) && IsDomainArray(c.domain) ? c.domain : void 0;
  }
  getChannelRangeArray(channelKey) {
    const c = this.spec()[channelKey];
    return IsChannelDeep(c) && IsRangeArray(c.range) ? c.range : void 0;
  }
  validateSpec() {
    return validateTrack(this.originalSpec());
  }
}
const GOSLING_DATA_ROW_UID_FIELD = "gosling-data-row-uid";
function getTabularData(spec, data2) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
  const tabularData = [];
  if (!IsDataDeepTileset(spec.data)) {
    console.warn("No data is specified");
    return;
  }
  if (spec.data.type === "vector" || spec.data.type === "bigwig") {
    if (!("dense" in data2)) {
      return;
    }
    const bin = (_a = spec.data.binSize) != null ? _a : 1;
    const numericValues = data2.dense;
    const numOfGenomicPositions = data2.tileSize;
    const tileUnitSize = data2.tileWidth / data2.tileSize;
    const valueName = (_b = spec.data.value) != null ? _b : "value";
    const columnName = (_c = spec.data.column) != null ? _c : "position";
    const startName = (_d = spec.data.start) != null ? _d : "start";
    const endName = (_e = spec.data.end) != null ? _e : "end";
    const minValueName = `${valueName}_min`;
    const maxValueName = `${valueName}_max`;
    const agg = (_f = spec.data.aggregation) != null ? _f : "mean";
    let cumVal = 0;
    let minVal = Number.MAX_SAFE_INTEGER;
    let maxVal = Number.MIN_SAFE_INTEGER;
    let binStart = Number.MIN_SAFE_INTEGER;
    let binEnd = Number.MAX_SAFE_INTEGER;
    Array.from(Array(numOfGenomicPositions).keys()).forEach((g, j) => {
      if (bin === 1) {
        const value = numericValues[j] / (agg === "mean" ? tileUnitSize : 1);
        tabularData.push({
          [valueName]: value,
          [columnName]: data2.tileX + (j + 0.5) * tileUnitSize,
          [startName]: data2.tileX + j * tileUnitSize,
          [endName]: data2.tileX + (j + 1) * tileUnitSize,
          [minValueName]: value,
          [maxValueName]: value
        });
      } else {
        if (j % bin === 0) {
          cumVal = minVal = maxVal = numericValues[j];
          binStart = j;
          binEnd = j + bin;
        } else if (j % bin === bin - 1) {
          tabularData.push({
            [valueName]: cumVal / bin / (agg === "mean" ? tileUnitSize : 1),
            [columnName]: data2.tileX + (binStart + bin / 2) * tileUnitSize,
            [startName]: data2.tileX + binStart * tileUnitSize,
            [endName]: data2.tileX + binEnd * tileUnitSize,
            [minValueName]: minVal,
            [maxValueName]: maxVal
          });
        } else if (j === numOfGenomicPositions - 1) {
          const smallBin = numOfGenomicPositions % bin;
          const correctedBinEnd = binStart + smallBin;
          tabularData.push({
            [valueName]: cumVal / smallBin / (agg === "mean" ? tileUnitSize : 1),
            [columnName]: data2.tileX + (binStart + smallBin / 2) * tileUnitSize,
            [startName]: data2.tileX + binStart * tileUnitSize,
            [endName]: data2.tileX + correctedBinEnd * tileUnitSize,
            [minValueName]: minVal,
            [maxValueName]: maxVal
          });
        } else {
          cumVal += numericValues[j];
          if (minVal > numericValues[j])
            minVal = numericValues[j];
          if (maxVal < numericValues[j])
            maxVal = numericValues[j];
        }
      }
    });
  } else if (spec.data.type === "multivec") {
    if (!("dense" in data2) || data2.shape === void 0) {
      return;
    }
    const bin = (_g = spec.data.binSize) != null ? _g : 1;
    const numOfTotalCategories = data2.shape[0];
    const categories = (_h = spec.data.categories) != null ? _h : [...Array(numOfTotalCategories).keys()];
    const numericValues = data2.dense;
    const numOfGenomicPositions = data2.shape[1];
    const tileUnitSize = data2.tileWidth / data2.tileSize;
    const rowName = (_i = spec.data.row) != null ? _i : "category";
    const valueName = (_j = spec.data.value) != null ? _j : "value";
    const columnName = (_k = spec.data.column) != null ? _k : "position";
    const startName = (_l = spec.data.start) != null ? _l : "start";
    const endName = (_m = spec.data.end) != null ? _m : "end";
    const minValueName = `${valueName}_min`;
    const maxValueName = `${valueName}_max`;
    const agg = (_n = spec.data.aggregation) != null ? _n : "mean";
    categories.forEach((c, i) => {
      let cumVal = 0;
      let binStart = Number.MIN_SAFE_INTEGER;
      let binEnd = Number.MAX_SAFE_INTEGER;
      let minVal = Number.MAX_SAFE_INTEGER;
      let maxVal = Number.MIN_SAFE_INTEGER;
      Array.from(Array(numOfGenomicPositions).keys()).forEach((g, j) => {
        if (bin === 1) {
          const value = numericValues[numOfGenomicPositions * i + j] / (agg === "mean" ? tileUnitSize : 1);
          tabularData.push({
            [rowName]: c,
            [valueName]: value,
            [columnName]: data2.tileX + (j + 0.5) * tileUnitSize,
            [startName]: data2.tileX + j * tileUnitSize,
            [endName]: data2.tileX + (j + 1) * tileUnitSize,
            [minValueName]: value,
            [maxValueName]: value
          });
        } else {
          if (j % bin === 0) {
            cumVal = minVal = maxVal = numericValues[numOfGenomicPositions * i + j];
            binStart = j;
            binEnd = j + bin;
          } else if (j % bin === bin - 1) {
            tabularData.push({
              [rowName]: c,
              [valueName]: agg === "mean" ? cumVal / bin / tileUnitSize : cumVal,
              [columnName]: data2.tileX + (binStart + bin / 2) * tileUnitSize,
              [startName]: data2.tileX + binStart * tileUnitSize,
              [endName]: data2.tileX + binEnd * tileUnitSize,
              [minValueName]: minVal,
              [maxValueName]: maxVal
            });
          } else if (j === numOfGenomicPositions - 1) {
            const smallBin = numOfGenomicPositions % bin;
            const correctedBinEnd = binStart + smallBin;
            tabularData.push({
              [rowName]: c,
              [valueName]: agg === "mean" ? cumVal / smallBin / tileUnitSize : cumVal,
              [columnName]: data2.tileX + (binStart + smallBin / 2) * tileUnitSize,
              [startName]: data2.tileX + binStart * tileUnitSize,
              [endName]: data2.tileX + correctedBinEnd * tileUnitSize,
              [minValueName]: minVal,
              [maxValueName]: maxVal
            });
          } else {
            const value = numericValues[numOfGenomicPositions * i + j];
            cumVal += value;
            if (minVal > value)
              minVal = value;
            if (maxVal < value)
              maxVal = value;
          }
        }
      });
    });
  } else if (spec.data.type === "matrix") {
    if (!("dense" in data2) || typeof data2.tileY === "undefined" || typeof data2.tileHeight === "undefined") {
      return;
    }
    const numBins = Math.sqrt(data2.dense.length);
    const { tileX, tileY, tileWidth, tileHeight } = data2;
    const numericValues = data2.dense;
    const tileXUnitSize = tileWidth / numBins;
    const tileYUnitSize = tileHeight / numBins;
    const columnField = (_o = spec.data.column) != null ? _o : "x";
    const rowField = (_p = spec.data.row) != null ? _p : "y";
    const aggSize = 16;
    for (let i = 0; i < numericValues.length / aggSize; i++) {
      const aggLen = Math.sqrt(aggSize);
      const xIndex = i * aggLen % numBins;
      const yIndex = Math.floor(i * aggLen / numBins) * aggLen;
      let value = NaN;
      for (let c = 0; c < aggLen; c++) {
        for (let r = 0; r < aggLen; r++) {
          const curVal = numericValues[(yIndex + r) * numBins + (xIndex + c)];
          if (!isNaN(+curVal)) {
            if (isNaN(value)) {
              value = 0;
            }
            value += curVal;
          }
        }
      }
      if (isNaN(value)) {
        continue;
      }
      const xs = tileX + xIndex * tileXUnitSize;
      const xe = tileX + (xIndex + aggLen) * tileXUnitSize;
      const ys = tileY + yIndex * tileYUnitSize;
      const ye = tileY + (yIndex + aggLen) * tileYUnitSize;
      const x = (xs + xe) / 2;
      const y = (ys + ye) / 2;
      tabularData.push({
        value,
        [columnField]: x,
        [`${columnField}s`]: xs,
        [`${columnField}e`]: xe,
        [rowField]: y,
        [`${rowField}s`]: ys,
        [`${rowField}e`]: ye
      });
    }
  } else if (spec.data.type === "beddb") {
    if (!data2.sparse) {
      return;
    }
    const { genomicFields, exonIntervalFields, valueFields } = spec.data;
    data2.sparse.forEach((d, i) => {
      const { chrOffset, fields } = d;
      const datum = {};
      datum[GOSLING_DATA_ROW_UID_FIELD] = `${i}`;
      genomicFields.forEach((g) => {
        datum[g.name] = +fields[g.index] + chrOffset;
      });
      valueFields == null ? void 0 : valueFields.forEach((v) => {
        datum[v.name] = v.type === "quantitative" ? +fields[v.index] : fields[v.index];
      });
      tabularData.push({
        ...datum,
        type: "gene"
      });
      if (exonIntervalFields) {
        const [exonStartField, exonEndField] = exonIntervalFields;
        const exonStartStrs = fields[exonStartField.index].split(",");
        const exonEndStrs = fields[exonEndField.index].split(",");
        exonStartStrs.forEach((es, i2) => {
          const ee = exonEndStrs[i2];
          tabularData.push({
            ...datum,
            [exonStartField.name]: +es + chrOffset,
            [exonEndField.name]: +ee + chrOffset,
            type: "exon"
          });
          if (i2 + 1 < exonStartStrs.length) {
            const nextEs = exonStartStrs[i2 + 1];
            tabularData.push({
              ...datum,
              [exonStartField.name]: +ee + chrOffset,
              [exonEndField.name]: +nextEs + chrOffset,
              type: "intron"
            });
          }
        });
      }
    });
  }
  return tabularData;
}
function publish$1(name2, data2) {
  PubSub$1.publish(name2, data2);
}
function subscribe(name2, callback) {
  PubSub$1.subscribe(name2, callback);
}
function unsubscribe(name2) {
  PubSub$1.unsubscribe(name2);
}
const encodedJs$1 = "KCgpID0+IHsKICB2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlOwogIHZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7CiAgdmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllczsKICB2YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7CiAgdmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7CiAgdmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7CiAgdmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzOwogIHZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7CiAgdmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7CiAgdmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7CiAgdmFyIF9fcG93ID0gTWF0aC5wb3c7CiAgdmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlOwogIHZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7CiAgICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpCiAgICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSkKICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7CiAgICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scykKICAgICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7CiAgICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKQogICAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pOwogICAgICB9CiAgICByZXR1cm4gYTsKICB9OwogIHZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpOwogIHZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICB2YXIgX19lc20gPSAoZm4sIHJlcykgPT4gZnVuY3Rpb24gX19pbml0KCkgewogICAgcmV0dXJuIGZuICYmIChyZXMgPSAoMCwgZm5bT2JqZWN0LmtleXMoZm4pWzBdXSkoZm4gPSAwKSksIHJlczsKICB9OwogIHZhciBfX2NvbW1vbkpTID0gKGNiLCBtb2QpID0+IGZ1bmN0aW9uIF9fcmVxdWlyZSgpIHsKICAgIHJldHVybiBtb2QgfHwgKDAsIGNiW09iamVjdC5rZXlzKGNiKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzOwogIH07CiAgdmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUsIGRlc2MpID0+IHsKICAgIGlmIChtb2R1bGUgJiYgdHlwZW9mIG1vZHVsZSA9PT0gIm9iamVjdCIgfHwgdHlwZW9mIG1vZHVsZSA9PT0gImZ1bmN0aW9uIikgewogICAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlKSkKICAgICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09ICJkZWZhdWx0IikKICAgICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pOwogICAgfQogICAgcmV0dXJuIHRhcmdldDsKICB9OwogIHZhciBfX3RvTW9kdWxlID0gKG1vZHVsZSkgPT4gewogICAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZSAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZSkpIDoge30sICJkZWZhdWx0IiwgbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlICYmICJkZWZhdWx0IiBpbiBtb2R1bGUgPyB7IGdldDogKCkgPT4gbW9kdWxlLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZSwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZSk7CiAgfTsKICB2YXIgX19hc3luYyA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHsKICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7CiAgICAgIHZhciBmdWxmaWxsZWQgPSAodmFsdWUpID0+IHsKICAgICAgICB0cnkgewogICAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOwogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIHJlamVjdChlKTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIHZhciByZWplY3RlZCA9ICh2YWx1ZSkgPT4gewogICAgICAgIHRyeSB7CiAgICAgICAgICBzdGVwKGdlbmVyYXRvci50aHJvdyh2YWx1ZSkpOwogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIHJlamVjdChlKTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIHZhciBzdGVwID0gKHgpID0+IHguZG9uZSA/IHJlc29sdmUoeC52YWx1ZSkgOiBQcm9taXNlLnJlc29sdmUoeC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsKICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpKS5uZXh0KCkpOwogICAgfSk7CiAgfTsKCiAgLy8gbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcwogIHZhciByZXF1aXJlX2Jhc2U2NF9qcyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIGV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7CiAgICAgIGV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheTsKICAgICAgZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheTsKICAgICAgdmFyIGxvb2t1cCA9IFtdOwogICAgICB2YXIgcmV2TG9va3VwID0gW107CiAgICAgIHZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gInVuZGVmaW5lZCIgPyBVaW50OEFycmF5IDogQXJyYXk7CiAgICAgIHZhciBjb2RlID0gIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8iOwogICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7CiAgICAgICAgbG9va3VwW2ldID0gY29kZVtpXTsKICAgICAgICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGk7CiAgICAgIH0KICAgICAgdmFyIGk7CiAgICAgIHZhciBsZW47CiAgICAgIHJldkxvb2t1cFsiLSIuY2hhckNvZGVBdCgwKV0gPSA2MjsKICAgICAgcmV2TG9va3VwWyJfIi5jaGFyQ29kZUF0KDApXSA9IDYzOwogICAgICBmdW5jdGlvbiBnZXRMZW5zKGI2NCkgewogICAgICAgIHZhciBsZW4yID0gYjY0Lmxlbmd0aDsKICAgICAgICBpZiAobGVuMiAlIDQgPiAwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQiKTsKICAgICAgICB9CiAgICAgICAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoIj0iKTsKICAgICAgICBpZiAodmFsaWRMZW4gPT09IC0xKQogICAgICAgICAgdmFsaWRMZW4gPSBsZW4yOwogICAgICAgIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuMiA/IDAgOiA0IC0gdmFsaWRMZW4gJSA0OwogICAgICAgIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYnl0ZUxlbmd0aChiNjQpIHsKICAgICAgICB2YXIgbGVucyA9IGdldExlbnMoYjY0KTsKICAgICAgICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdOwogICAgICAgIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdOwogICAgICAgIHJldHVybiAodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQgLSBwbGFjZUhvbGRlcnNMZW47CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7CiAgICAgICAgcmV0dXJuICh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCAtIHBsYWNlSG9sZGVyc0xlbjsKICAgICAgfQogICAgICBmdW5jdGlvbiB0b0J5dGVBcnJheShiNjQpIHsKICAgICAgICB2YXIgdG1wOwogICAgICAgIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpOwogICAgICAgIHZhciB2YWxpZExlbiA9IGxlbnNbMF07CiAgICAgICAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV07CiAgICAgICAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSk7CiAgICAgICAgdmFyIGN1ckJ5dGUgPSAwOwogICAgICAgIHZhciBsZW4yID0gcGxhY2VIb2xkZXJzTGVuID4gMCA/IHZhbGlkTGVuIC0gNCA6IHZhbGlkTGVuOwogICAgICAgIHZhciBpMjsKICAgICAgICBmb3IgKGkyID0gMDsgaTIgPCBsZW4yOyBpMiArPSA0KSB7CiAgICAgICAgICB0bXAgPSByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIpXSA8PCAxOCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDEpXSA8PCAxMiB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDIpXSA8PCA2IHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMyldOwogICAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgPj4gMTYgJiAyNTU7CiAgICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCA+PiA4ICYgMjU1OwogICAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAyNTU7CiAgICAgICAgfQogICAgICAgIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHsKICAgICAgICAgIHRtcCA9IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMildIDw8IDIgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAxKV0gPj4gNDsKICAgICAgICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMjU1OwogICAgICAgIH0KICAgICAgICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7CiAgICAgICAgICB0bXAgPSByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIpXSA8PCAxMCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDEpXSA8PCA0IHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMildID4+IDI7CiAgICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCA+PiA4ICYgMjU1OwogICAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAyNTU7CiAgICAgICAgfQogICAgICAgIHJldHVybiBhcnI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0KG51bSkgewogICAgICAgIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgNjNdICsgbG9va3VwW251bSA+PiAxMiAmIDYzXSArIGxvb2t1cFtudW0gPj4gNiAmIDYzXSArIGxvb2t1cFtudW0gJiA2M107CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZW5jb2RlQ2h1bmsodWludDgsIHN0YXJ0LCBlbmQpIHsKICAgICAgICB2YXIgdG1wOwogICAgICAgIHZhciBvdXRwdXQgPSBbXTsKICAgICAgICBmb3IgKHZhciBpMiA9IHN0YXJ0OyBpMiA8IGVuZDsgaTIgKz0gMykgewogICAgICAgICAgdG1wID0gKHVpbnQ4W2kyXSA8PCAxNiAmIDE2NzExNjgwKSArICh1aW50OFtpMiArIDFdIDw8IDggJiA2NTI4MCkgKyAodWludDhbaTIgKyAyXSAmIDI1NSk7CiAgICAgICAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBvdXRwdXQuam9pbigiIik7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSh1aW50OCkgewogICAgICAgIHZhciB0bXA7CiAgICAgICAgdmFyIGxlbjIgPSB1aW50OC5sZW5ndGg7CiAgICAgICAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4yICUgMzsKICAgICAgICB2YXIgcGFydHMgPSBbXTsKICAgICAgICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MzsKICAgICAgICBmb3IgKHZhciBpMiA9IDAsIGxlbjIyID0gbGVuMiAtIGV4dHJhQnl0ZXM7IGkyIDwgbGVuMjI7IGkyICs9IG1heENodW5rTGVuZ3RoKSB7CiAgICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpMiwgaTIgKyBtYXhDaHVua0xlbmd0aCA+IGxlbjIyID8gbGVuMjIgOiBpMiArIG1heENodW5rTGVuZ3RoKSk7CiAgICAgICAgfQogICAgICAgIGlmIChleHRyYUJ5dGVzID09PSAxKSB7CiAgICAgICAgICB0bXAgPSB1aW50OFtsZW4yIC0gMV07CiAgICAgICAgICBwYXJ0cy5wdXNoKGxvb2t1cFt0bXAgPj4gMl0gKyBsb29rdXBbdG1wIDw8IDQgJiA2M10gKyAiPT0iKTsKICAgICAgICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHsKICAgICAgICAgIHRtcCA9ICh1aW50OFtsZW4yIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4yIC0gMV07CiAgICAgICAgICBwYXJ0cy5wdXNoKGxvb2t1cFt0bXAgPj4gMTBdICsgbG9va3VwW3RtcCA+PiA0ICYgNjNdICsgbG9va3VwW3RtcCA8PCAyICYgNjNdICsgIj0iKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oIiIpOwogICAgICB9CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfaWVlZTc1NCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykgewogICAgICAgIHZhciBlLCBtOwogICAgICAgIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxOwogICAgICAgIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxOwogICAgICAgIHZhciBlQmlhcyA9IGVNYXggPj4gMTsKICAgICAgICB2YXIgbkJpdHMgPSAtNzsKICAgICAgICB2YXIgaSA9IGlzTEUgPyBuQnl0ZXMgLSAxIDogMDsKICAgICAgICB2YXIgZCA9IGlzTEUgPyAtMSA6IDE7CiAgICAgICAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07CiAgICAgICAgaSArPSBkOwogICAgICAgIGUgPSBzICYgKDEgPDwgLW5CaXRzKSAtIDE7CiAgICAgICAgcyA+Pj0gLW5CaXRzOwogICAgICAgIG5CaXRzICs9IGVMZW47CiAgICAgICAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkgewogICAgICAgIH0KICAgICAgICBtID0gZSAmICgxIDw8IC1uQml0cykgLSAxOwogICAgICAgIGUgPj49IC1uQml0czsKICAgICAgICBuQml0cyArPSBtTGVuOwogICAgICAgIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHsKICAgICAgICB9CiAgICAgICAgaWYgKGUgPT09IDApIHsKICAgICAgICAgIGUgPSAxIC0gZUJpYXM7CiAgICAgICAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7CiAgICAgICAgICByZXR1cm4gbSA/IE5hTiA6IChzID8gLTEgOiAxKSAqIEluZmluaXR5OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pOwogICAgICAgICAgZSA9IGUgLSBlQmlhczsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7CiAgICAgIH07CiAgICAgIGV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykgewogICAgICAgIHZhciBlLCBtLCBjOwogICAgICAgIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxOwogICAgICAgIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxOwogICAgICAgIHZhciBlQmlhcyA9IGVNYXggPj4gMTsKICAgICAgICB2YXIgcnQgPSBtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMDsKICAgICAgICB2YXIgaSA9IGlzTEUgPyAwIDogbkJ5dGVzIC0gMTsKICAgICAgICB2YXIgZCA9IGlzTEUgPyAxIDogLTE7CiAgICAgICAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCA/IDEgOiAwOwogICAgICAgIHZhbHVlID0gTWF0aC5hYnModmFsdWUpOwogICAgICAgIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7CiAgICAgICAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7CiAgICAgICAgICBlID0gZU1heDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpOwogICAgICAgICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkgewogICAgICAgICAgICBlLS07CiAgICAgICAgICAgIGMgKj0gMjsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChlICsgZUJpYXMgPj0gMSkgewogICAgICAgICAgICB2YWx1ZSArPSBydCAvIGM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodmFsdWUgKiBjID49IDIpIHsKICAgICAgICAgICAgZSsrOwogICAgICAgICAgICBjIC89IDI7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHsKICAgICAgICAgICAgbSA9IDA7CiAgICAgICAgICAgIGUgPSBlTWF4OwogICAgICAgICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkgewogICAgICAgICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7CiAgICAgICAgICAgIGUgPSBlICsgZUJpYXM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7CiAgICAgICAgICAgIGUgPSAwOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMjU1LCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHsKICAgICAgICB9CiAgICAgICAgZSA9IGUgPDwgbUxlbiB8IG07CiAgICAgICAgZUxlbiArPSBtTGVuOwogICAgICAgIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDI1NSwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7CiAgICAgICAgfQogICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcwogIHZhciByZXF1aXJlX2J1ZmZlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBiYXNlNjQgPSByZXF1aXJlX2Jhc2U2NF9qcygpOwogICAgICB2YXIgaWVlZTc1NCA9IHJlcXVpcmVfaWVlZTc1NCgpOwogICAgICB2YXIgY3VzdG9tSW5zcGVjdFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICJmdW5jdGlvbiIgJiYgdHlwZW9mIFN5bWJvbFsiZm9yIl0gPT09ICJmdW5jdGlvbiIgPyBTeW1ib2xbImZvciJdKCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbSIpIDogbnVsbDsKICAgICAgZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXIzOwogICAgICBleHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyOwogICAgICBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTA7CiAgICAgIHZhciBLX01BWF9MRU5HVEggPSAyMTQ3NDgzNjQ3OwogICAgICBleHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEg7CiAgICAgIEJ1ZmZlcjMuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KCk7CiAgICAgIGlmICghQnVmZmVyMy5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAidW5kZWZpbmVkIiAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gImZ1bmN0aW9uIikgewogICAgICAgIGNvbnNvbGUuZXJyb3IoIlRoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSBgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LiIpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0KCkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSgxKTsKICAgICAgICAgIGNvbnN0IHByb3RvID0geyBmb286IGZ1bmN0aW9uKCkgewogICAgICAgICAgICByZXR1cm4gNDI7CiAgICAgICAgICB9IH07CiAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKTsKICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnIsIHByb3RvKTsKICAgICAgICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyOwogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgIH0KICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlcjMucHJvdG90eXBlLCAicGFyZW50IiwgewogICAgICAgIGVudW1lcmFibGU6IHRydWUsCiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICAgIGlmICghQnVmZmVyMy5pc0J1ZmZlcih0aGlzKSkKICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcjsKICAgICAgICB9CiAgICAgIH0pOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyMy5wcm90b3R5cGUsICJvZmZzZXQiLCB7CiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgICAgaWYgKCFCdWZmZXIzLmlzQnVmZmVyKHRoaXMpKQogICAgICAgICAgICByZXR1cm4gdm9pZCAwOwogICAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldDsKICAgICAgICB9CiAgICAgIH0pOwogICAgICBmdW5jdGlvbiBjcmVhdGVCdWZmZXIobGVuZ3RoKSB7CiAgICAgICAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSAiJyArIGxlbmd0aCArICciIGlzIGludmFsaWQgZm9yIG9wdGlvbiAic2l6ZSInKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTsKICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIzLnByb3RvdHlwZSk7CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfQogICAgICBmdW5jdGlvbiBCdWZmZXIzKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICJudW1iZXIiKSB7CiAgICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSAic3RyaW5nIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcicpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZyk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTsKICAgICAgfQogICAgICBCdWZmZXIzLnBvb2xTaXplID0gODE5MjsKICAgICAgZnVuY3Rpb24gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gInN0cmluZyIpIHsKICAgICAgICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KTsKICAgICAgICB9CiAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHsKICAgICAgICAgIHJldHVybiBmcm9tQXJyYXlWaWV3KHZhbHVlKTsKICAgICAgICB9CiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIlRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICIgKyB0eXBlb2YgdmFsdWUpOwogICAgICAgIH0KICAgICAgICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8IHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpIHsKICAgICAgICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICJ1bmRlZmluZWQiICYmIChpc0luc3RhbmNlKHZhbHVlLCBTaGFyZWRBcnJheUJ1ZmZlcikgfHwgdmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIFNoYXJlZEFycmF5QnVmZmVyKSkpIHsKICAgICAgICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICJudW1iZXIiKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgInZhbHVlIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpOwogICAgICAgIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHsKICAgICAgICAgIHJldHVybiBCdWZmZXIzLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgYiA9IGZyb21PYmplY3QodmFsdWUpOwogICAgICAgIGlmIChiKQogICAgICAgICAgcmV0dXJuIGI7CiAgICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICJ1bmRlZmluZWQiICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICByZXR1cm4gQnVmZmVyMy5mcm9tKHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oInN0cmluZyIpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpOwogICAgICAgIH0KICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAiICsgdHlwZW9mIHZhbHVlKTsKICAgICAgfQogICAgICBCdWZmZXIzLmZyb20gPSBmdW5jdGlvbih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7CiAgICAgIH07CiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIzLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpOwogICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyMywgVWludDhBcnJheSk7CiAgICAgIGZ1bmN0aW9uIGFzc2VydFNpemUoc2l6ZSkgewogICAgICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gIm51bWJlciIpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJzaXplIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJyk7CiAgICAgICAgfSBlbHNlIGlmIChzaXplIDwgMCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSAiJyArIHNpemUgKyAnIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gInNpemUiJyk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7CiAgICAgICAgYXNzZXJ0U2l6ZShzaXplKTsKICAgICAgICBpZiAoc2l6ZSA8PSAwKSB7CiAgICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpOwogICAgICAgIH0KICAgICAgICBpZiAoZmlsbCAhPT0gdm9pZCAwKSB7CiAgICAgICAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAic3RyaW5nIiA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKSA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpOwogICAgICB9CiAgICAgIEJ1ZmZlcjMuYWxsb2MgPSBmdW5jdGlvbihzaXplLCBmaWxsLCBlbmNvZGluZykgewogICAgICAgIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZyk7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGFsbG9jVW5zYWZlKHNpemUpIHsKICAgICAgICBhc3NlcnRTaXplKHNpemUpOwogICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApOwogICAgICB9CiAgICAgIEJ1ZmZlcjMuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbihzaXplKSB7CiAgICAgICAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpOwogICAgICB9OwogICAgICBCdWZmZXIzLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uKHNpemUpIHsKICAgICAgICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSk7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyaW5nLCBlbmNvZGluZykgewogICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICJzdHJpbmciIHx8IGVuY29kaW5nID09PSAiIikgewogICAgICAgICAgZW5jb2RpbmcgPSAidXRmOCI7CiAgICAgICAgfQogICAgICAgIGlmICghQnVmZmVyMy5pc0VuY29kaW5nKGVuY29kaW5nKSkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiVW5rbm93biBlbmNvZGluZzogIiArIGVuY29kaW5nKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDA7CiAgICAgICAgbGV0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpOwogICAgICAgIGNvbnN0IGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKTsKICAgICAgICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHsKICAgICAgICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gYnVmOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZyb21BcnJheUxpa2UoYXJyYXkpIHsKICAgICAgICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDA7CiAgICAgICAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aCk7CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTU7CiAgICAgICAgfQogICAgICAgIHJldHVybiBidWY7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZnJvbUFycmF5VmlldyhhcnJheVZpZXcpIHsKICAgICAgICBpZiAoaXNJbnN0YW5jZShhcnJheVZpZXcsIFVpbnQ4QXJyYXkpKSB7CiAgICAgICAgICBjb25zdCBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlWaWV3KTsKICAgICAgICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIoY29weS5idWZmZXIsIGNvcHkuYnl0ZU9mZnNldCwgY29weS5ieXRlTGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UoYXJyYXlWaWV3KTsKICAgICAgfQogICAgICBmdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkgewogICAgICAgIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJyJvZmZzZXQiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpOwogICAgICAgIH0KICAgICAgICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignImxlbmd0aCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyk7CiAgICAgICAgfQogICAgICAgIGxldCBidWY7CiAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPT09IHZvaWQgMCAmJiBsZW5ndGggPT09IHZvaWQgMCkgewogICAgICAgICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpOwogICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID09PSB2b2lkIDApIHsKICAgICAgICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlcjMucHJvdG90eXBlKTsKICAgICAgICByZXR1cm4gYnVmOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqKSB7CiAgICAgICAgaWYgKEJ1ZmZlcjMuaXNCdWZmZXIob2JqKSkgewogICAgICAgICAgY29uc3QgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDA7CiAgICAgICAgICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuKTsKICAgICAgICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBidWY7CiAgICAgICAgICB9CiAgICAgICAgICBvYmouY29weShidWYsIDAsIDAsIGxlbik7CiAgICAgICAgICByZXR1cm4gYnVmOwogICAgICAgIH0KICAgICAgICBpZiAob2JqLmxlbmd0aCAhPT0gdm9pZCAwKSB7CiAgICAgICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICJudW1iZXIiIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7CiAgICAgICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMCk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopOwogICAgICAgIH0KICAgICAgICBpZiAob2JqLnR5cGUgPT09ICJCdWZmZXIiICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7CiAgICAgICAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNoZWNrZWQobGVuZ3RoKSB7CiAgICAgICAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtIHNpemU6IDB4IiArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAiIGJ5dGVzIik7CiAgICAgICAgfQogICAgICAgIHJldHVybiBsZW5ndGggfCAwOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIFNsb3dCdWZmZXIobGVuZ3RoKSB7CiAgICAgICAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7CiAgICAgICAgICBsZW5ndGggPSAwOwogICAgICAgIH0KICAgICAgICByZXR1cm4gQnVmZmVyMy5hbGxvYygrbGVuZ3RoKTsKICAgICAgfQogICAgICBCdWZmZXIzLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIoYikgewogICAgICAgIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiYgYiAhPT0gQnVmZmVyMy5wcm90b3R5cGU7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjMuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikgewogICAgICAgIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKQogICAgICAgICAgYSA9IEJ1ZmZlcjMuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKTsKICAgICAgICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkKICAgICAgICAgIGIgPSBCdWZmZXIzLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aCk7CiAgICAgICAgaWYgKCFCdWZmZXIzLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIzLmlzQnVmZmVyKGIpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgImJ1ZjEiLCAiYnVmMiIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknKTsKICAgICAgICB9CiAgICAgICAgaWYgKGEgPT09IGIpCiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICBsZXQgeCA9IGEubGVuZ3RoOwogICAgICAgIGxldCB5ID0gYi5sZW5ndGg7CiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHsKICAgICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSB7CiAgICAgICAgICAgIHggPSBhW2ldOwogICAgICAgICAgICB5ID0gYltpXTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmICh4IDwgeSkKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICBpZiAoeSA8IHgpCiAgICAgICAgICByZXR1cm4gMTsKICAgICAgICByZXR1cm4gMDsKICAgICAgfTsKICAgICAgQnVmZmVyMy5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyhlbmNvZGluZykgewogICAgICAgIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7CiAgICAgICAgICBjYXNlICJoZXgiOgogICAgICAgICAgY2FzZSAidXRmOCI6CiAgICAgICAgICBjYXNlICJ1dGYtOCI6CiAgICAgICAgICBjYXNlICJhc2NpaSI6CiAgICAgICAgICBjYXNlICJsYXRpbjEiOgogICAgICAgICAgY2FzZSAiYmluYXJ5IjoKICAgICAgICAgIGNhc2UgImJhc2U2NCI6CiAgICAgICAgICBjYXNlICJ1Y3MyIjoKICAgICAgICAgIGNhc2UgInVjcy0yIjoKICAgICAgICAgIGNhc2UgInV0ZjE2bGUiOgogICAgICAgICAgY2FzZSAidXRmLTE2bGUiOgogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIEJ1ZmZlcjMuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KGxpc3QsIGxlbmd0aCkgewogICAgICAgIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignImxpc3QiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpOwogICAgICAgIH0KICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDApIHsKICAgICAgICAgIHJldHVybiBCdWZmZXIzLmFsbG9jKDApOwogICAgICAgIH0KICAgICAgICBsZXQgaTsKICAgICAgICBpZiAobGVuZ3RoID09PSB2b2lkIDApIHsKICAgICAgICAgIGxlbmd0aCA9IDA7CiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkgewogICAgICAgICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGg7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlcjMuYWxsb2NVbnNhZmUobGVuZ3RoKTsKICAgICAgICBsZXQgcG9zID0gMDsKICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkgewogICAgICAgICAgbGV0IGJ1ZiA9IGxpc3RbaV07CiAgICAgICAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7CiAgICAgICAgICAgIGlmIChwb3MgKyBidWYubGVuZ3RoID4gYnVmZmVyLmxlbmd0aCkgewogICAgICAgICAgICAgIGlmICghQnVmZmVyMy5pc0J1ZmZlcihidWYpKQogICAgICAgICAgICAgICAgYnVmID0gQnVmZmVyMy5mcm9tKGJ1Zik7CiAgICAgICAgICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKGJ1ZmZlciwgYnVmLCBwb3MpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKCFCdWZmZXIzLmlzQnVmZmVyKGJ1ZikpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignImxpc3QiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpOwogICAgICAgICAgfQogICAgICAgICAgcG9zICs9IGJ1Zi5sZW5ndGg7CiAgICAgICAgfQogICAgICAgIHJldHVybiBidWZmZXI7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgewogICAgICAgIGlmIChCdWZmZXIzLmlzQnVmZmVyKHN0cmluZykpIHsKICAgICAgICAgIHJldHVybiBzdHJpbmcubGVuZ3RoOwogICAgICAgIH0KICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkgewogICAgICAgICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIHN0cmluZyAhPT0gInN0cmluZyIpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSAic3RyaW5nIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZyk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGxlbiA9IHN0cmluZy5sZW5ndGg7CiAgICAgICAgY29uc3QgbXVzdE1hdGNoID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlOwogICAgICAgIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlOwogICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgc3dpdGNoIChlbmNvZGluZykgewogICAgICAgICAgICBjYXNlICJhc2NpaSI6CiAgICAgICAgICAgIGNhc2UgImxhdGluMSI6CiAgICAgICAgICAgIGNhc2UgImJpbmFyeSI6CiAgICAgICAgICAgICAgcmV0dXJuIGxlbjsKICAgICAgICAgICAgY2FzZSAidXRmOCI6CiAgICAgICAgICAgIGNhc2UgInV0Zi04IjoKICAgICAgICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGg7CiAgICAgICAgICAgIGNhc2UgInVjczIiOgogICAgICAgICAgICBjYXNlICJ1Y3MtMiI6CiAgICAgICAgICAgIGNhc2UgInV0ZjE2bGUiOgogICAgICAgICAgICBjYXNlICJ1dGYtMTZsZSI6CiAgICAgICAgICAgICAgcmV0dXJuIGxlbiAqIDI7CiAgICAgICAgICAgIGNhc2UgImhleCI6CiAgICAgICAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMTsKICAgICAgICAgICAgY2FzZSAiYmFzZTY0IjoKICAgICAgICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aDsKICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICBpZiAobG93ZXJlZENhc2UpIHsKICAgICAgICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBlbmNvZGluZyA9ICgiIiArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpOwogICAgICAgICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgQnVmZmVyMy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDsKICAgICAgZnVuY3Rpb24gc2xvd1RvU3RyaW5nKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7CiAgICAgICAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2U7CiAgICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDAgfHwgc3RhcnQgPCAwKSB7CiAgICAgICAgICBzdGFydCA9IDA7CiAgICAgICAgfQogICAgICAgIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7CiAgICAgICAgICByZXR1cm4gIiI7CiAgICAgICAgfQogICAgICAgIGlmIChlbmQgPT09IHZvaWQgMCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkgewogICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7CiAgICAgICAgfQogICAgICAgIGlmIChlbmQgPD0gMCkgewogICAgICAgICAgcmV0dXJuICIiOwogICAgICAgIH0KICAgICAgICBlbmQgPj4+PSAwOwogICAgICAgIHN0YXJ0ID4+Pj0gMDsKICAgICAgICBpZiAoZW5kIDw9IHN0YXJ0KSB7CiAgICAgICAgICByZXR1cm4gIiI7CiAgICAgICAgfQogICAgICAgIGlmICghZW5jb2RpbmcpCiAgICAgICAgICBlbmNvZGluZyA9ICJ1dGY4IjsKICAgICAgICB3aGlsZSAodHJ1ZSkgewogICAgICAgICAgc3dpdGNoIChlbmNvZGluZykgewogICAgICAgICAgICBjYXNlICJoZXgiOgogICAgICAgICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKTsKICAgICAgICAgICAgY2FzZSAidXRmOCI6CiAgICAgICAgICAgIGNhc2UgInV0Zi04IjoKICAgICAgICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpOwogICAgICAgICAgICBjYXNlICJhc2NpaSI6CiAgICAgICAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZCk7CiAgICAgICAgICAgIGNhc2UgImxhdGluMSI6CiAgICAgICAgICAgIGNhc2UgImJpbmFyeSI6CiAgICAgICAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpOwogICAgICAgICAgICBjYXNlICJiYXNlNjQiOgogICAgICAgICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKTsKICAgICAgICAgICAgY2FzZSAidWNzMiI6CiAgICAgICAgICAgIGNhc2UgInVjcy0yIjoKICAgICAgICAgICAgY2FzZSAidXRmMTZsZSI6CiAgICAgICAgICAgIGNhc2UgInV0Zi0xNmxlIjoKICAgICAgICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpOwogICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgIGlmIChsb3dlcmVkQ2FzZSkKICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIlVua25vd24gZW5jb2Rpbmc6ICIgKyBlbmNvZGluZyk7CiAgICAgICAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAiIikudG9Mb3dlckNhc2UoKTsKICAgICAgICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIEJ1ZmZlcjMucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWU7CiAgICAgIGZ1bmN0aW9uIHN3YXAoYiwgbiwgbSkgewogICAgICAgIGNvbnN0IGkgPSBiW25dOwogICAgICAgIGJbbl0gPSBiW21dOwogICAgICAgIGJbbV0gPSBpOwogICAgICB9CiAgICAgIEJ1ZmZlcjMucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNigpIHsKICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aDsKICAgICAgICBpZiAobGVuICUgMiAhPT0gMCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzIik7CiAgICAgICAgfQogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHsKICAgICAgICAgIHN3YXAodGhpcywgaSwgaSArIDEpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfTsKICAgICAgQnVmZmVyMy5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyKCkgewogICAgICAgIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoOwogICAgICAgIGlmIChsZW4gJSA0ICE9PSAwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMiKTsKICAgICAgICB9CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkgewogICAgICAgICAgc3dhcCh0aGlzLCBpLCBpICsgMyk7CiAgICAgICAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMik7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9OwogICAgICBCdWZmZXIzLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQoKSB7CiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGg7CiAgICAgICAgaWYgKGxlbiAlIDggIT09IDApIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cyIpOwogICAgICAgIH0KICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7CiAgICAgICAgICBzd2FwKHRoaXMsIGksIGkgKyA3KTsKICAgICAgICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KTsKICAgICAgICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KTsKICAgICAgICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7CiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGg7CiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkKICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkKICAgICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKTsKICAgICAgICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjMucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyMy5wcm90b3R5cGUudG9TdHJpbmc7CiAgICAgIEJ1ZmZlcjMucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhiKSB7CiAgICAgICAgaWYgKCFCdWZmZXIzLmlzQnVmZmVyKGIpKQogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciIpOwogICAgICAgIGlmICh0aGlzID09PSBiKQogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgcmV0dXJuIEJ1ZmZlcjMuY29tcGFyZSh0aGlzLCBiKSA9PT0gMDsKICAgICAgfTsKICAgICAgQnVmZmVyMy5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7CiAgICAgICAgbGV0IHN0ciA9ICIiOwogICAgICAgIGNvbnN0IG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVM7CiAgICAgICAgc3RyID0gdGhpcy50b1N0cmluZygiaGV4IiwgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgIiQxICIpLnRyaW0oKTsKICAgICAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpCiAgICAgICAgICBzdHIgKz0gIiAuLi4gIjsKICAgICAgICByZXR1cm4gIjxCdWZmZXIgIiArIHN0ciArICI+IjsKICAgICAgfTsKICAgICAgaWYgKGN1c3RvbUluc3BlY3RTeW1ib2wpIHsKICAgICAgICBCdWZmZXIzLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IEJ1ZmZlcjMucHJvdG90eXBlLmluc3BlY3Q7CiAgICAgIH0KICAgICAgQnVmZmVyMy5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHsKICAgICAgICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7CiAgICAgICAgICB0YXJnZXQgPSBCdWZmZXIzLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIGlmICghQnVmZmVyMy5pc0J1ZmZlcih0YXJnZXQpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgInRhcmdldCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHRhcmdldCk7CiAgICAgICAgfQogICAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBzdGFydCA9IDA7CiAgICAgICAgfQogICAgICAgIGlmIChlbmQgPT09IHZvaWQgMCkgewogICAgICAgICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDA7CiAgICAgICAgfQogICAgICAgIGlmICh0aGlzU3RhcnQgPT09IHZvaWQgMCkgewogICAgICAgICAgdGhpc1N0YXJ0ID0gMDsKICAgICAgICB9CiAgICAgICAgaWYgKHRoaXNFbmQgPT09IHZvaWQgMCkgewogICAgICAgICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJvdXQgb2YgcmFuZ2UgaW5kZXgiKTsKICAgICAgICB9CiAgICAgICAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkgewogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgfQogICAgICAgIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkgewogICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhcnQgPj0gZW5kKSB7CiAgICAgICAgICByZXR1cm4gMTsKICAgICAgICB9CiAgICAgICAgc3RhcnQgPj4+PSAwOwogICAgICAgIGVuZCA+Pj49IDA7CiAgICAgICAgdGhpc1N0YXJ0ID4+Pj0gMDsKICAgICAgICB0aGlzRW5kID4+Pj0gMDsKICAgICAgICBpZiAodGhpcyA9PT0gdGFyZ2V0KQogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgbGV0IHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0OwogICAgICAgIGxldCB5ID0gZW5kIC0gc3RhcnQ7CiAgICAgICAgY29uc3QgbGVuID0gTWF0aC5taW4oeCwgeSk7CiAgICAgICAgY29uc3QgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZCk7CiAgICAgICAgY29uc3QgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7CiAgICAgICAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHsKICAgICAgICAgICAgeCA9IHRoaXNDb3B5W2ldOwogICAgICAgICAgICB5ID0gdGFyZ2V0Q29weVtpXTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmICh4IDwgeSkKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICBpZiAoeSA8IHgpCiAgICAgICAgICByZXR1cm4gMTsKICAgICAgICByZXR1cm4gMDsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHsKICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXQ7CiAgICAgICAgICBieXRlT2Zmc2V0ID0gMDsKICAgICAgICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAyMTQ3NDgzNjQ3KSB7CiAgICAgICAgICBieXRlT2Zmc2V0ID0gMjE0NzQ4MzY0NzsKICAgICAgICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMjE0NzQ4MzY0OCkgewogICAgICAgICAgYnl0ZU9mZnNldCA9IC0yMTQ3NDgzNjQ4OwogICAgICAgIH0KICAgICAgICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQ7CiAgICAgICAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7CiAgICAgICAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IGJ1ZmZlci5sZW5ndGggLSAxOwogICAgICAgIH0KICAgICAgICBpZiAoYnl0ZU9mZnNldCA8IDApCiAgICAgICAgICBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXQ7CiAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkgewogICAgICAgICAgaWYgKGRpcikKICAgICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgICAgZWxzZQogICAgICAgICAgICBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDE7CiAgICAgICAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkgewogICAgICAgICAgaWYgKGRpcikKICAgICAgICAgICAgYnl0ZU9mZnNldCA9IDA7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICB2YWwgPSBCdWZmZXIzLmZyb20odmFsLCBlbmNvZGluZyk7CiAgICAgICAgfQogICAgICAgIGlmIChCdWZmZXIzLmlzQnVmZmVyKHZhbCkpIHsKICAgICAgICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpOwogICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gIm51bWJlciIpIHsKICAgICAgICAgIHZhbCA9IHZhbCAmIDI1NTsKICAgICAgICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICBpZiAoZGlyKSB7CiAgICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpOwogICAgICAgIH0KICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJ2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXIiKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBhcnJheUluZGV4T2YoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHsKICAgICAgICBsZXQgaW5kZXhTaXplID0gMTsKICAgICAgICBsZXQgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aDsKICAgICAgICBsZXQgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aDsKICAgICAgICBpZiAoZW5jb2RpbmcgIT09IHZvaWQgMCkgewogICAgICAgICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICJ1Y3MyIiB8fCBlbmNvZGluZyA9PT0gInVjcy0yIiB8fCBlbmNvZGluZyA9PT0gInV0ZjE2bGUiIHx8IGVuY29kaW5nID09PSAidXRmLTE2bGUiKSB7CiAgICAgICAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikgewogICAgICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpbmRleFNpemUgPSAyOwogICAgICAgICAgICBhcnJMZW5ndGggLz0gMjsKICAgICAgICAgICAgdmFsTGVuZ3RoIC89IDI7CiAgICAgICAgICAgIGJ5dGVPZmZzZXQgLz0gMjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcmVhZChidWYsIGkyKSB7CiAgICAgICAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7CiAgICAgICAgICAgIHJldHVybiBidWZbaTJdOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaTIgKiBpbmRleFNpemUpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBsZXQgaTsKICAgICAgICBpZiAoZGlyKSB7CiAgICAgICAgICBsZXQgZm91bmRJbmRleCA9IC0xOwogICAgICAgICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHsKICAgICAgICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpCiAgICAgICAgICAgICAgICBmb3VuZEluZGV4ID0gaTsKICAgICAgICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpCiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpCiAgICAgICAgICAgICAgICBpIC09IGkgLSBmb3VuZEluZGV4OwogICAgICAgICAgICAgIGZvdW5kSW5kZXggPSAtMTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkKICAgICAgICAgICAgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aDsKICAgICAgICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7CiAgICAgICAgICAgIGxldCBmb3VuZCA9IHRydWU7CiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHsKICAgICAgICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7CiAgICAgICAgICAgICAgICBmb3VuZCA9IGZhbHNlOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChmb3VuZCkKICAgICAgICAgICAgICByZXR1cm4gaTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9CiAgICAgIEJ1ZmZlcjMucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXModmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgewogICAgICAgIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xOwogICAgICB9OwogICAgICBCdWZmZXIzLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7CiAgICAgICAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpOwogICAgICB9OwogICAgICBCdWZmZXIzLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHsKICAgICAgICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpOwogICAgICB9OwogICAgICBmdW5jdGlvbiBoZXhXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwOwogICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXQ7CiAgICAgICAgaWYgKCFsZW5ndGgpIHsKICAgICAgICAgIGxlbmd0aCA9IHJlbWFpbmluZzsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aCk7CiAgICAgICAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7CiAgICAgICAgICAgIGxlbmd0aCA9IHJlbWFpbmluZzsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgY29uc3Qgc3RyTGVuID0gc3RyaW5nLmxlbmd0aDsKICAgICAgICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikgewogICAgICAgICAgbGVuZ3RoID0gc3RyTGVuIC8gMjsKICAgICAgICB9CiAgICAgICAgbGV0IGk7CiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7CiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpOwogICAgICAgICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpCiAgICAgICAgICAgIHJldHVybiBpOwogICAgICAgICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkOwogICAgICAgIH0KICAgICAgICByZXR1cm4gaTsKICAgICAgfQogICAgICBmdW5jdGlvbiB1dGY4V3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYmFzZTY0V3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB1Y3MyV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgIH0KICAgICAgQnVmZmVyMy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykgewogICAgICAgIGlmIChvZmZzZXQgPT09IHZvaWQgMCkgewogICAgICAgICAgZW5jb2RpbmcgPSAidXRmOCI7CiAgICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDsKICAgICAgICAgIG9mZnNldCA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChsZW5ndGggPT09IHZvaWQgMCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAic3RyaW5nIikgewogICAgICAgICAgZW5jb2RpbmcgPSBvZmZzZXQ7CiAgICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDsKICAgICAgICAgIG9mZnNldCA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7CiAgICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkgewogICAgICAgICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDA7CiAgICAgICAgICAgIGlmIChlbmNvZGluZyA9PT0gdm9pZCAwKQogICAgICAgICAgICAgIGVuY29kaW5nID0gInV0ZjgiOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7CiAgICAgICAgICAgIGxlbmd0aCA9IHZvaWQgMDsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCIpOwogICAgICAgIH0KICAgICAgICBjb25zdCByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDsKICAgICAgICBpZiAobGVuZ3RoID09PSB2b2lkIDAgfHwgbGVuZ3RoID4gcmVtYWluaW5nKQogICAgICAgICAgbGVuZ3RoID0gcmVtYWluaW5nOwogICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkF0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzIik7CiAgICAgICAgfQogICAgICAgIGlmICghZW5jb2RpbmcpCiAgICAgICAgICBlbmNvZGluZyA9ICJ1dGY4IjsKICAgICAgICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZTsKICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHsKICAgICAgICAgICAgY2FzZSAiaGV4IjoKICAgICAgICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgICAgIGNhc2UgInV0ZjgiOgogICAgICAgICAgICBjYXNlICJ1dGYtOCI6CiAgICAgICAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgICAgICAgY2FzZSAiYXNjaWkiOgogICAgICAgICAgICBjYXNlICJsYXRpbjEiOgogICAgICAgICAgICBjYXNlICJiaW5hcnkiOgogICAgICAgICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpOwogICAgICAgICAgICBjYXNlICJiYXNlNjQiOgogICAgICAgICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgICAgICAgY2FzZSAidWNzMiI6CiAgICAgICAgICAgIGNhc2UgInVjcy0yIjoKICAgICAgICAgICAgY2FzZSAidXRmMTZsZSI6CiAgICAgICAgICAgIGNhc2UgInV0Zi0xNmxlIjoKICAgICAgICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpOwogICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgIGlmIChsb3dlcmVkQ2FzZSkKICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIlVua25vd24gZW5jb2Rpbmc6ICIgKyBlbmNvZGluZyk7CiAgICAgICAgICAgICAgZW5jb2RpbmcgPSAoIiIgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTsKICAgICAgICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9OwogICAgICBCdWZmZXIzLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIHR5cGU6ICJCdWZmZXIiLAogICAgICAgICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApCiAgICAgICAgfTsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gYmFzZTY0U2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7CiAgICAgICAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkgewogICAgICAgICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zik7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiB1dGY4U2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7CiAgICAgICAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTsKICAgICAgICBjb25zdCByZXMgPSBbXTsKICAgICAgICBsZXQgaSA9IHN0YXJ0OwogICAgICAgIHdoaWxlIChpIDwgZW5kKSB7CiAgICAgICAgICBjb25zdCBmaXJzdEJ5dGUgPSBidWZbaV07CiAgICAgICAgICBsZXQgY29kZVBvaW50ID0gbnVsbDsKICAgICAgICAgIGxldCBieXRlc1BlclNlcXVlbmNlID0gZmlyc3RCeXRlID4gMjM5ID8gNCA6IGZpcnN0Qnl0ZSA+IDIyMyA/IDMgOiBmaXJzdEJ5dGUgPiAxOTEgPyAyIDogMTsKICAgICAgICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHsKICAgICAgICAgICAgbGV0IHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludDsKICAgICAgICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7CiAgICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDEyOCkgewogICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIDI6CiAgICAgICAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTsKICAgICAgICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDE5MikgPT09IDEyOCkgewogICAgICAgICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDMxKSA8PCA2IHwgc2Vjb25kQnl0ZSAmIDYzOwogICAgICAgICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDEyNykgewogICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgMzoKICAgICAgICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdOwogICAgICAgICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTsKICAgICAgICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDE5MikgPT09IDEyOCAmJiAodGhpcmRCeXRlICYgMTkyKSA9PT0gMTI4KSB7CiAgICAgICAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMTUpIDw8IDEyIHwgKHNlY29uZEJ5dGUgJiA2MykgPDwgNiB8IHRoaXJkQnl0ZSAmIDYzOwogICAgICAgICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDIwNDcgJiYgKHRlbXBDb2RlUG9pbnQgPCA1NTI5NiB8fCB0ZW1wQ29kZVBvaW50ID4gNTczNDMpKSB7CiAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSA0OgogICAgICAgICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07CiAgICAgICAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdOwogICAgICAgICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM107CiAgICAgICAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAxOTIpID09PSAxMjggJiYgKHRoaXJkQnl0ZSAmIDE5MikgPT09IDEyOCAmJiAoZm91cnRoQnl0ZSAmIDE5MikgPT09IDEyOCkgewogICAgICAgICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDE1KSA8PCAxOCB8IChzZWNvbmRCeXRlICYgNjMpIDw8IDEyIHwgKHRoaXJkQnl0ZSAmIDYzKSA8PCA2IHwgZm91cnRoQnl0ZSAmIDYzOwogICAgICAgICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDY1NTM1ICYmIHRlbXBDb2RlUG9pbnQgPCAxMTE0MTEyKSB7CiAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7CiAgICAgICAgICAgIGNvZGVQb2ludCA9IDY1NTMzOwogICAgICAgICAgICBieXRlc1BlclNlcXVlbmNlID0gMTsKICAgICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gNjU1MzUpIHsKICAgICAgICAgICAgY29kZVBvaW50IC09IDY1NTM2OwogICAgICAgICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMTAyMyB8IDU1Mjk2KTsKICAgICAgICAgICAgY29kZVBvaW50ID0gNTYzMjAgfCBjb2RlUG9pbnQgJiAxMDIzOwogICAgICAgICAgfQogICAgICAgICAgcmVzLnB1c2goY29kZVBvaW50KTsKICAgICAgICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpOwogICAgICB9CiAgICAgIHZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDQwOTY7CiAgICAgIGZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheShjb2RlUG9pbnRzKSB7CiAgICAgICAgY29uc3QgbGVuID0gY29kZVBvaW50cy5sZW5ndGg7CiAgICAgICAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkgewogICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKTsKICAgICAgICB9CiAgICAgICAgbGV0IHJlcyA9ICIiOwogICAgICAgIGxldCBpID0gMDsKICAgICAgICB3aGlsZSAoaSA8IGxlbikgewogICAgICAgICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJlczsKICAgICAgfQogICAgICBmdW5jdGlvbiBhc2NpaVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkgewogICAgICAgIGxldCByZXQgPSAiIjsKICAgICAgICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpOwogICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7CiAgICAgICAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAxMjcpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGxhdGluMVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkgewogICAgICAgIGxldCByZXQgPSAiIjsKICAgICAgICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpOwogICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7CiAgICAgICAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGhleFNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkgewogICAgICAgIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGg7CiAgICAgICAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApCiAgICAgICAgICBzdGFydCA9IDA7CiAgICAgICAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pCiAgICAgICAgICBlbmQgPSBsZW47CiAgICAgICAgbGV0IG91dCA9ICIiOwogICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7CiAgICAgICAgICBvdXQgKz0gaGV4U2xpY2VMb29rdXBUYWJsZVtidWZbaV1dOwogICAgICAgIH0KICAgICAgICByZXR1cm4gb3V0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHV0ZjE2bGVTbGljZShidWYsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBjb25zdCBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKTsKICAgICAgICBsZXQgcmVzID0gIiI7CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGggLSAxOyBpICs9IDIpIHsKICAgICAgICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJlczsKICAgICAgfQogICAgICBCdWZmZXIzLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHsKICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aDsKICAgICAgICBzdGFydCA9IH5+c3RhcnQ7CiAgICAgICAgZW5kID0gZW5kID09PSB2b2lkIDAgPyBsZW4gOiB+fmVuZDsKICAgICAgICBpZiAoc3RhcnQgPCAwKSB7CiAgICAgICAgICBzdGFydCArPSBsZW47CiAgICAgICAgICBpZiAoc3RhcnQgPCAwKQogICAgICAgICAgICBzdGFydCA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikgewogICAgICAgICAgc3RhcnQgPSBsZW47CiAgICAgICAgfQogICAgICAgIGlmIChlbmQgPCAwKSB7CiAgICAgICAgICBlbmQgKz0gbGVuOwogICAgICAgICAgaWYgKGVuZCA8IDApCiAgICAgICAgICAgIGVuZCA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHsKICAgICAgICAgIGVuZCA9IGxlbjsKICAgICAgICB9CiAgICAgICAgaWYgKGVuZCA8IHN0YXJ0KQogICAgICAgICAgZW5kID0gc3RhcnQ7CiAgICAgICAgY29uc3QgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKTsKICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIzLnByb3RvdHlwZSk7CiAgICAgICAgcmV0dXJuIG5ld0J1ZjsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gY2hlY2tPZmZzZXQob2Zmc2V0LCBleHQsIGxlbmd0aCkgewogICAgICAgIGlmIChvZmZzZXQgJSAxICE9PSAwIHx8IG9mZnNldCA8IDApCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigib2Zmc2V0IGlzIG5vdCB1aW50Iik7CiAgICAgICAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoIik7CiAgICAgIH0KICAgICAgQnVmZmVyMy5wcm90b3R5cGUucmVhZFVpbnRMRSA9IEJ1ZmZlcjMucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFKG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGJ5dGVMZW5ndGgyID0gYnl0ZUxlbmd0aDIgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIGxldCBpID0gMDsKICAgICAgICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aDIgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHZhbDsKICAgICAgfTsKICAgICAgQnVmZmVyMy5wcm90b3R5cGUucmVhZFVpbnRCRSA9IEJ1ZmZlcjMucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFKG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGJ5dGVMZW5ndGgyID0gYnl0ZUxlbmd0aDIgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkgewogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoMiwgdGhpcy5sZW5ndGgpOwogICAgICAgIH0KICAgICAgICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGgyXTsKICAgICAgICBsZXQgbXVsID0gMTsKICAgICAgICB3aGlsZSAoYnl0ZUxlbmd0aDIgPiAwICYmIChtdWwgKj0gMjU2KSkgewogICAgICAgICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoMl0gKiBtdWw7CiAgICAgICAgfQogICAgICAgIHJldHVybiB2YWw7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjMucHJvdG90eXBlLnJlYWRVaW50OCA9IEJ1ZmZlcjMucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gdGhpc1tvZmZzZXRdOwogICAgICB9OwogICAgICBCdWZmZXIzLnByb3RvdHlwZS5yZWFkVWludDE2TEUgPSBCdWZmZXIzLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgODsKICAgICAgfTsKICAgICAgQnVmZmVyMy5wcm90b3R5cGUucmVhZFVpbnQxNkJFID0gQnVmZmVyMy5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiB0aGlzW29mZnNldF0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgMV07CiAgICAgIH07CiAgICAgIEJ1ZmZlcjMucHJvdG90eXBlLnJlYWRVaW50MzJMRSA9IEJ1ZmZlcjMucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gKHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpICsgdGhpc1tvZmZzZXQgKyAzXSAqIDE2Nzc3MjE2OwogICAgICB9OwogICAgICBCdWZmZXIzLnByb3RvdHlwZS5yZWFkVWludDMyQkUgPSBCdWZmZXIzLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSAqIDE2Nzc3MjE2ICsgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYgfCB0aGlzW29mZnNldCArIDJdIDw8IDggfCB0aGlzW29mZnNldCArIDNdKTsKICAgICAgfTsKICAgICAgQnVmZmVyMy5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRMRShvZmZzZXQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAib2Zmc2V0Iik7CiAgICAgICAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF07CiAgICAgICAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN107CiAgICAgICAgaWYgKGZpcnN0ID09PSB2b2lkIDAgfHwgbGFzdCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOCk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGxvID0gZmlyc3QgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNDsKICAgICAgICBjb25zdCBoaSA9IHRoaXNbKytvZmZzZXRdICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgKyBsYXN0ICogMiAqKiAyNDsKICAgICAgICByZXR1cm4gQmlnSW50KGxvKSArIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpOwogICAgICB9KTsKICAgICAgQnVmZmVyMy5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRCRShvZmZzZXQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAib2Zmc2V0Iik7CiAgICAgICAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF07CiAgICAgICAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN107CiAgICAgICAgaWYgKGZpcnN0ID09PSB2b2lkIDAgfHwgbGFzdCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOCk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGhpID0gZmlyc3QgKiAyICoqIDI0ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyB0aGlzWysrb2Zmc2V0XTsKICAgICAgICBjb25zdCBsbyA9IHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICsgbGFzdDsKICAgICAgICByZXR1cm4gKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQobG8pOwogICAgICB9KTsKICAgICAgQnVmZmVyMy5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFKG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGJ5dGVMZW5ndGgyID0gYnl0ZUxlbmd0aDIgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIGxldCBpID0gMDsKICAgICAgICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aDIgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDsKICAgICAgICB9CiAgICAgICAgbXVsICo9IDEyODsKICAgICAgICBpZiAodmFsID49IG11bCkKICAgICAgICAgIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aDIpOwogICAgICAgIHJldHVybiB2YWw7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjMucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRShvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBieXRlTGVuZ3RoMiA9IGJ5dGVMZW5ndGgyID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgbGV0IGkgPSBieXRlTGVuZ3RoMjsKICAgICAgICBsZXQgbXVsID0gMTsKICAgICAgICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldOwogICAgICAgIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWw7CiAgICAgICAgfQogICAgICAgIG11bCAqPSAxMjg7CiAgICAgICAgaWYgKHZhbCA+PSBtdWwpCiAgICAgICAgICB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgyKTsKICAgICAgICByZXR1cm4gdmFsOwogICAgICB9OwogICAgICBCdWZmZXIzLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4KG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpOwogICAgICAgIGlmICghKHRoaXNbb2Zmc2V0XSAmIDEyOCkpCiAgICAgICAgICByZXR1cm4gdGhpc1tvZmZzZXRdOwogICAgICAgIHJldHVybiAoMjU1IC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMTsKICAgICAgfTsKICAgICAgQnVmZmVyMy5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICBjb25zdCB2YWwgPSB0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDg7CiAgICAgICAgcmV0dXJuIHZhbCAmIDMyNzY4ID8gdmFsIHwgNDI5NDkwMTc2MCA6IHZhbDsKICAgICAgfTsKICAgICAgQnVmZmVyMy5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgdGhpc1tvZmZzZXRdIDw8IDg7CiAgICAgICAgcmV0dXJuIHZhbCAmIDMyNzY4ID8gdmFsIHwgNDI5NDkwMTc2MCA6IHZhbDsKICAgICAgfTsKICAgICAgQnVmZmVyMy5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgdGhpc1tvZmZzZXQgKyAxXSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAyXSA8PCAxNiB8IHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQ7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjMucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSA8PCAyNCB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYgfCB0aGlzW29mZnNldCArIDJdIDw8IDggfCB0aGlzW29mZnNldCArIDNdOwogICAgICB9OwogICAgICBCdWZmZXIzLnByb3RvdHlwZS5yZWFkQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRMRShvZmZzZXQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAib2Zmc2V0Iik7CiAgICAgICAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF07CiAgICAgICAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN107CiAgICAgICAgaWYgKGZpcnN0ID09PSB2b2lkIDAgfHwgbGFzdCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOCk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgNF0gKyB0aGlzW29mZnNldCArIDVdICogMiAqKiA4ICsgdGhpc1tvZmZzZXQgKyA2XSAqIDIgKiogMTYgKyAobGFzdCA8PCAyNCk7CiAgICAgICAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChmaXJzdCArIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDI0KTsKICAgICAgfSk7CiAgICAgIEJ1ZmZlcjMucHJvdG90eXBlLnJlYWRCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NEJFKG9mZnNldCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICJvZmZzZXQiKTsKICAgICAgICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XTsKICAgICAgICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XTsKICAgICAgICBpZiAoZmlyc3QgPT09IHZvaWQgMCB8fCBsYXN0ID09PSB2b2lkIDApIHsKICAgICAgICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KTsKICAgICAgICB9CiAgICAgICAgY29uc3QgdmFsID0gKGZpcnN0IDw8IDI0KSArIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICsgdGhpc1srK29mZnNldF07CiAgICAgICAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludCh0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArIGxhc3QpOwogICAgICB9KTsKICAgICAgQnVmZmVyMy5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpOwogICAgICB9OwogICAgICBCdWZmZXIzLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpOwogICAgICB9OwogICAgICBCdWZmZXIzLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KTsKICAgICAgfTsKICAgICAgQnVmZmVyMy5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpOwogICAgICB9OwogICAgICBmdW5jdGlvbiBjaGVja0ludChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHsKICAgICAgICBpZiAoIUJ1ZmZlcjMuaXNCdWZmZXIoYnVmKSkKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJidWZmZXIiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTsKICAgICAgICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignInZhbHVlIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJyk7CiAgICAgICAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiSW5kZXggb3V0IG9mIHJhbmdlIik7CiAgICAgIH0KICAgICAgQnVmZmVyMy5wcm90b3R5cGUud3JpdGVVaW50TEUgPSBCdWZmZXIzLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBieXRlTGVuZ3RoMiA9IGJ5dGVMZW5ndGgyID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpIHsKICAgICAgICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgyKSAtIDE7CiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbWF4Qnl0ZXMsIDApOwogICAgICAgIH0KICAgICAgICBsZXQgbXVsID0gMTsKICAgICAgICBsZXQgaSA9IDA7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGgyICYmIChtdWwgKj0gMjU2KSkgewogICAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlIC8gbXVsICYgMjU1OwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjMucHJvdG90eXBlLndyaXRlVWludEJFID0gQnVmZmVyMy5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgYnl0ZUxlbmd0aDIgPSBieXRlTGVuZ3RoMiA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7CiAgICAgICAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoMikgLSAxOwogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIG1heEJ5dGVzLCAwKTsKICAgICAgICB9CiAgICAgICAgbGV0IGkgPSBieXRlTGVuZ3RoMiAtIDE7CiAgICAgICAgbGV0IG11bCA9IDE7CiAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMjU1OwogICAgICAgIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAvIG11bCAmIDI1NTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgyOwogICAgICB9OwogICAgICBCdWZmZXIzLnByb3RvdHlwZS53cml0ZVVpbnQ4ID0gQnVmZmVyMy5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDI1NSwgMCk7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDE7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjMucHJvdG90eXBlLndyaXRlVWludDE2TEUgPSBCdWZmZXIzLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgNjU1MzUsIDApOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gODsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMjsKICAgICAgfTsKICAgICAgQnVmZmVyMy5wcm90b3R5cGUud3JpdGVVaW50MTZCRSA9IEJ1ZmZlcjMucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCA2NTUzNSwgMCk7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgPj4+IDg7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlICYgMjU1OwogICAgICAgIHJldHVybiBvZmZzZXQgKyAyOwogICAgICB9OwogICAgICBCdWZmZXIzLnByb3RvdHlwZS53cml0ZVVpbnQzMkxFID0gQnVmZmVyMy5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDQyOTQ5NjcyOTUsIDApOwogICAgICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZSA+Pj4gMjQ7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiAxNjsKICAgICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDg7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDQ7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjMucHJvdG90eXBlLndyaXRlVWludDMyQkUgPSBCdWZmZXIzLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgNDI5NDk2NzI5NSwgMCk7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgPj4+IDI0OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gMTY7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiA4OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZSAmIDI1NTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgNDsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gd3J0QmlnVUludDY0TEUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkgewogICAgICAgIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNyk7CiAgICAgICAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDQyOTQ5NjcyOTUpKTsKICAgICAgICBidWZbb2Zmc2V0KytdID0gbG87CiAgICAgICAgbG8gPSBsbyA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBsbzsKICAgICAgICBsbyA9IGxvID4+IDg7CiAgICAgICAgYnVmW29mZnNldCsrXSA9IGxvOwogICAgICAgIGxvID0gbG8gPj4gODsKICAgICAgICBidWZbb2Zmc2V0KytdID0gbG87CiAgICAgICAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoNDI5NDk2NzI5NSkpOwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBoaTsKICAgICAgICBoaSA9IGhpID4+IDg7CiAgICAgICAgYnVmW29mZnNldCsrXSA9IGhpOwogICAgICAgIGhpID0gaGkgPj4gODsKICAgICAgICBidWZbb2Zmc2V0KytdID0gaGk7CiAgICAgICAgaGkgPSBoaSA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBoaTsKICAgICAgICByZXR1cm4gb2Zmc2V0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHdydEJpZ1VJbnQ2NEJFKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHsKICAgICAgICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpOwogICAgICAgIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCg0Mjk0OTY3Mjk1KSk7CiAgICAgICAgYnVmW29mZnNldCArIDddID0gbG87CiAgICAgICAgbG8gPSBsbyA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQgKyA2XSA9IGxvOwogICAgICAgIGxvID0gbG8gPj4gODsKICAgICAgICBidWZbb2Zmc2V0ICsgNV0gPSBsbzsKICAgICAgICBsbyA9IGxvID4+IDg7CiAgICAgICAgYnVmW29mZnNldCArIDRdID0gbG87CiAgICAgICAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoNDI5NDk2NzI5NSkpOwogICAgICAgIGJ1ZltvZmZzZXQgKyAzXSA9IGhpOwogICAgICAgIGhpID0gaGkgPj4gODsKICAgICAgICBidWZbb2Zmc2V0ICsgMl0gPSBoaTsKICAgICAgICBoaSA9IGhpID4+IDg7CiAgICAgICAgYnVmW29mZnNldCArIDFdID0gaGk7CiAgICAgICAgaGkgPSBoaSA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXRdID0gaGk7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDg7CiAgICAgIH0KICAgICAgQnVmZmVyMy5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NExFKHZhbHVlLCBvZmZzZXQgPSAwKSB7CiAgICAgICAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCIweGZmZmZmZmZmZmZmZmZmZmYiKSk7CiAgICAgIH0pOwogICAgICBCdWZmZXIzLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0QkUodmFsdWUsIG9mZnNldCA9IDApIHsKICAgICAgICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoIjB4ZmZmZmZmZmZmZmZmZmZmZiIpKTsKICAgICAgfSk7CiAgICAgIEJ1ZmZlcjMucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7CiAgICAgICAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoMiAtIDEpOwogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIGxpbWl0IC0gMSwgLWxpbWl0KTsKICAgICAgICB9CiAgICAgICAgbGV0IGkgPSAwOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIGxldCBzdWIgPSAwOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoMiAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7CiAgICAgICAgICAgIHN1YiA9IDE7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsID4+IDApIC0gc3ViICYgMjU1OwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjMucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7CiAgICAgICAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoMiAtIDEpOwogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIGxpbWl0IC0gMSwgLWxpbWl0KTsKICAgICAgICB9CiAgICAgICAgbGV0IGkgPSBieXRlTGVuZ3RoMiAtIDE7CiAgICAgICAgbGV0IG11bCA9IDE7CiAgICAgICAgbGV0IHN1YiA9IDA7CiAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMjU1OwogICAgICAgIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7CiAgICAgICAgICAgIHN1YiA9IDE7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsID4+IDApIC0gc3ViICYgMjU1OwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjMucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMTI3LCAtMTI4KTsKICAgICAgICBpZiAodmFsdWUgPCAwKQogICAgICAgICAgdmFsdWUgPSAyNTUgKyB2YWx1ZSArIDE7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDE7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjMucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMzI3NjcsIC0zMjc2OCk7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiA4OwogICAgICAgIHJldHVybiBvZmZzZXQgKyAyOwogICAgICB9OwogICAgICBCdWZmZXIzLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDMyNzY3LCAtMzI3NjgpOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlID4+PiA4OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMjsKICAgICAgfTsKICAgICAgQnVmZmVyMy5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAyMTQ3NDgzNjQ3LCAtMjE0NzQ4MzY0OCk7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiA4OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+Pj4gMTY7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlID4+PiAyNDsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgNDsKICAgICAgfTsKICAgICAgQnVmZmVyMy5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAyMTQ3NDgzNjQ3LCAtMjE0NzQ4MzY0OCk7CiAgICAgICAgaWYgKHZhbHVlIDwgMCkKICAgICAgICAgIHZhbHVlID0gNDI5NDk2NzI5NSArIHZhbHVlICsgMTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gMjQ7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiAxNjsKICAgICAgICB0aGlzW29mZnNldCArIDJdID0gdmFsdWUgPj4+IDg7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlICYgMjU1OwogICAgICAgIHJldHVybiBvZmZzZXQgKyA0OwogICAgICB9OwogICAgICBCdWZmZXIzLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NExFKHZhbHVlLCBvZmZzZXQgPSAwKSB7CiAgICAgICAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoIjB4ODAwMDAwMDAwMDAwMDAwMCIpLCBCaWdJbnQoIjB4N2ZmZmZmZmZmZmZmZmZmZiIpKTsKICAgICAgfSk7CiAgICAgIEJ1ZmZlcjMucHJvdG90eXBlLndyaXRlQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0QkUodmFsdWUsIG9mZnNldCA9IDApIHsKICAgICAgICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgiMHg4MDAwMDAwMDAwMDAwMDAwIiksIEJpZ0ludCgiMHg3ZmZmZmZmZmZmZmZmZmZmIikpOwogICAgICB9KTsKICAgICAgZnVuY3Rpb24gY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikgewogICAgICAgIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKQogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkluZGV4IG91dCBvZiByYW5nZSIpOwogICAgICAgIGlmIChvZmZzZXQgPCAwKQogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkluZGV4IG91dCBvZiByYW5nZSIpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpIHsKICAgICAgICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDM0MDI4MjM0NjYzODUyODg2ZTIyLCAtMzQwMjgyMzQ2NjM4NTI4ODZlMjIpOwogICAgICAgIH0KICAgICAgICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNCk7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDQ7CiAgICAgIH0KICAgICAgQnVmZmVyMy5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpOwogICAgICB9OwogICAgICBCdWZmZXIzLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpOwogICAgICB9OwogICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkgewogICAgICAgICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMTc5NzY5MzEzNDg2MjMxNTdlMjkyLCAtMTc5NzY5MzEzNDg2MjMxNTdlMjkyKTsKICAgICAgICB9CiAgICAgICAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpOwogICAgICAgIHJldHVybiBvZmZzZXQgKyA4OwogICAgICB9CiAgICAgIEJ1ZmZlcjMucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTsKICAgICAgfTsKICAgICAgQnVmZmVyMy5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTsKICAgICAgfTsKICAgICAgQnVmZmVyMy5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkgewogICAgICAgIGlmICghQnVmZmVyMy5pc0J1ZmZlcih0YXJnZXQpKQogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyIik7CiAgICAgICAgaWYgKCFzdGFydCkKICAgICAgICAgIHN0YXJ0ID0gMDsKICAgICAgICBpZiAoIWVuZCAmJiBlbmQgIT09IDApCiAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDsKICAgICAgICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkKICAgICAgICAgIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aDsKICAgICAgICBpZiAoIXRhcmdldFN0YXJ0KQogICAgICAgICAgdGFyZ2V0U3RhcnQgPSAwOwogICAgICAgIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KQogICAgICAgICAgZW5kID0gc3RhcnQ7CiAgICAgICAgaWYgKGVuZCA9PT0gc3RhcnQpCiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIGlmICh0YXJnZXRTdGFydCA8IDApIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJ0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzIik7CiAgICAgICAgfQogICAgICAgIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiSW5kZXggb3V0IG9mIHJhbmdlIik7CiAgICAgICAgaWYgKGVuZCA8IDApCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigic291cmNlRW5kIG91dCBvZiBib3VuZHMiKTsKICAgICAgICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpCiAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDsKICAgICAgICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHsKICAgICAgICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0OwogICAgICAgIH0KICAgICAgICBjb25zdCBsZW4gPSBlbmQgLSBzdGFydDsKICAgICAgICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbCh0YXJnZXQsIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksIHRhcmdldFN0YXJ0KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGxlbjsKICAgICAgfTsKICAgICAgQnVmZmVyMy5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykgewogICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAic3RyaW5nIikgewogICAgICAgICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgZW5jb2RpbmcgPSBzdGFydDsKICAgICAgICAgICAgc3RhcnQgPSAwOwogICAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgZW5jb2RpbmcgPSBlbmQ7CiAgICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGVuY29kaW5nICE9PSB2b2lkIDAgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAic3RyaW5nIikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nIik7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAic3RyaW5nIiAmJiAhQnVmZmVyMy5pc0VuY29kaW5nKGVuY29kaW5nKSkgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGVuY29kaW5nOiAiICsgZW5jb2RpbmcpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHsKICAgICAgICAgICAgY29uc3QgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApOwogICAgICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICJ1dGY4IiAmJiBjb2RlIDwgMTI4IHx8IGVuY29kaW5nID09PSAibGF0aW4xIikgewogICAgICAgICAgICAgIHZhbCA9IGNvZGU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICJudW1iZXIiKSB7CiAgICAgICAgICB2YWwgPSB2YWwgJiAyNTU7CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAiYm9vbGVhbiIpIHsKICAgICAgICAgIHZhbCA9IE51bWJlcih2YWwpOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJPdXQgb2YgcmFuZ2UgaW5kZXgiKTsKICAgICAgICB9CiAgICAgICAgaWYgKGVuZCA8PSBzdGFydCkgewogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfQogICAgICAgIHN0YXJ0ID0gc3RhcnQgPj4+IDA7CiAgICAgICAgZW5kID0gZW5kID09PSB2b2lkIDAgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMDsKICAgICAgICBpZiAoIXZhbCkKICAgICAgICAgIHZhbCA9IDA7CiAgICAgICAgbGV0IGk7CiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICJudW1iZXIiKSB7CiAgICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7CiAgICAgICAgICAgIHRoaXNbaV0gPSB2YWw7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGNvbnN0IGJ5dGVzID0gQnVmZmVyMy5pc0J1ZmZlcih2YWwpID8gdmFsIDogQnVmZmVyMy5mcm9tKHZhbCwgZW5jb2RpbmcpOwogICAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoOwogICAgICAgICAgaWYgKGxlbiA9PT0gMCkgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgIicgKyB2YWwgKyAnIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCAidmFsdWUiJyk7CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkgewogICAgICAgICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CiAgICAgIHZhciBlcnJvcnMgPSB7fTsKICAgICAgZnVuY3Rpb24gRShzeW0sIGdldE1lc3NhZ2UsIEJhc2UpIHsKICAgICAgICBlcnJvcnNbc3ltXSA9IGNsYXNzIE5vZGVFcnJvciBleHRlbmRzIEJhc2UgewogICAgICAgICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgICAgIHN1cGVyKCk7CiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAibWVzc2FnZSIsIHsKICAgICAgICAgICAgICB2YWx1ZTogZ2V0TWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLAogICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLAogICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgICAgICAgICB9KTsKICAgICAgICAgICAgdGhpcy5uYW1lID0gYCR7dGhpcy5uYW1lfSBbJHtzeW19XWA7CiAgICAgICAgICAgIHRoaXMuc3RhY2s7CiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm5hbWU7CiAgICAgICAgICB9CiAgICAgICAgICBnZXQgY29kZSgpIHsKICAgICAgICAgICAgcmV0dXJuIHN5bTsKICAgICAgICAgIH0KICAgICAgICAgIHNldCBjb2RlKHZhbHVlKSB7CiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAiY29kZSIsIHsKICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgICAgICAgICAgICB2YWx1ZSwKICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZQogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICAgIHRvU3RyaW5nKCkgewogICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBbJHtzeW19XTogJHt0aGlzLm1lc3NhZ2V9YDsKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICB9CiAgICAgIEUoIkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUyIsIGZ1bmN0aW9uKG5hbWUpIHsKICAgICAgICBpZiAobmFtZSkgewogICAgICAgICAgcmV0dXJuIGAke25hbWV9IGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kc2A7CiAgICAgICAgfQogICAgICAgIHJldHVybiAiQXR0ZW1wdCB0byBhY2Nlc3MgbWVtb3J5IG91dHNpZGUgYnVmZmVyIGJvdW5kcyI7CiAgICAgIH0sIFJhbmdlRXJyb3IpOwogICAgICBFKCJFUlJfSU5WQUxJRF9BUkdfVFlQRSIsIGZ1bmN0aW9uKG5hbWUsIGFjdHVhbCkgewogICAgICAgIHJldHVybiBgVGhlICIke25hbWV9IiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGFjdHVhbH1gOwogICAgICB9LCBUeXBlRXJyb3IpOwogICAgICBFKCJFUlJfT1VUX09GX1JBTkdFIiwgZnVuY3Rpb24oc3RyLCByYW5nZSwgaW5wdXQpIHsKICAgICAgICBsZXQgbXNnID0gYFRoZSB2YWx1ZSBvZiAiJHtzdHJ9IiBpcyBvdXQgb2YgcmFuZ2UuYDsKICAgICAgICBsZXQgcmVjZWl2ZWQgPSBpbnB1dDsKICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihpbnB1dCkgJiYgTWF0aC5hYnMoaW5wdXQpID4gMiAqKiAzMikgewogICAgICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IoU3RyaW5nKGlucHV0KSk7CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICJiaWdpbnQiKSB7CiAgICAgICAgICByZWNlaXZlZCA9IFN0cmluZyhpbnB1dCk7CiAgICAgICAgICBpZiAoaW5wdXQgPiBCaWdJbnQoMikgKiogQmlnSW50KDMyKSB8fCBpbnB1dCA8IC0oQmlnSW50KDIpICoqIEJpZ0ludCgzMikpKSB7CiAgICAgICAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKHJlY2VpdmVkKTsKICAgICAgICAgIH0KICAgICAgICAgIHJlY2VpdmVkICs9ICJuIjsKICAgICAgICB9CiAgICAgICAgbXNnICs9IGAgSXQgbXVzdCBiZSAke3JhbmdlfS4gUmVjZWl2ZWQgJHtyZWNlaXZlZH1gOwogICAgICAgIHJldHVybiBtc2c7CiAgICAgIH0sIFJhbmdlRXJyb3IpOwogICAgICBmdW5jdGlvbiBhZGROdW1lcmljYWxTZXBhcmF0b3IodmFsKSB7CiAgICAgICAgbGV0IHJlcyA9ICIiOwogICAgICAgIGxldCBpID0gdmFsLmxlbmd0aDsKICAgICAgICBjb25zdCBzdGFydCA9IHZhbFswXSA9PT0gIi0iID8gMSA6IDA7CiAgICAgICAgZm9yICg7IGkgPj0gc3RhcnQgKyA0OyBpIC09IDMpIHsKICAgICAgICAgIHJlcyA9IGBfJHt2YWwuc2xpY2UoaSAtIDMsIGkpfSR7cmVzfWA7CiAgICAgICAgfQogICAgICAgIHJldHVybiBgJHt2YWwuc2xpY2UoMCwgaSl9JHtyZXN9YDsKICAgICAgfQogICAgICBmdW5jdGlvbiBjaGVja0JvdW5kcyhidWYsIG9mZnNldCwgYnl0ZUxlbmd0aDIpIHsKICAgICAgICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICJvZmZzZXQiKTsKICAgICAgICBpZiAoYnVmW29mZnNldF0gPT09IHZvaWQgMCB8fCBidWZbb2Zmc2V0ICsgYnl0ZUxlbmd0aDJdID09PSB2b2lkIDApIHsKICAgICAgICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgYnVmLmxlbmd0aCAtIChieXRlTGVuZ3RoMiArIDEpKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoMikgewogICAgICAgIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgewogICAgICAgICAgY29uc3QgbiA9IHR5cGVvZiBtaW4gPT09ICJiaWdpbnQiID8gIm4iIDogIiI7CiAgICAgICAgICBsZXQgcmFuZ2U7CiAgICAgICAgICBpZiAoYnl0ZUxlbmd0aDIgPiAzKSB7CiAgICAgICAgICAgIGlmIChtaW4gPT09IDAgfHwgbWluID09PSBCaWdJbnQoMCkpIHsKICAgICAgICAgICAgICByYW5nZSA9IGA+PSAwJHtufSBhbmQgPCAyJHtufSAqKiAkeyhieXRlTGVuZ3RoMiArIDEpICogOH0ke259YDsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByYW5nZSA9IGA+PSAtKDIke259ICoqICR7KGJ5dGVMZW5ndGgyICsgMSkgKiA4IC0gMX0ke259KSBhbmQgPCAyICoqICR7KGJ5dGVMZW5ndGgyICsgMSkgKiA4IC0gMX0ke259YDsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmFuZ2UgPSBgPj0gJHttaW59JHtufSBhbmQgPD0gJHttYXh9JHtufWA7CiAgICAgICAgICB9CiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UoInZhbHVlIiwgcmFuZ2UsIHZhbHVlKTsKICAgICAgICB9CiAgICAgICAgY2hlY2tCb3VuZHMoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgyKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgbmFtZSkgewogICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICJudW1iZXIiKSB7CiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICJudW1iZXIiLCB2YWx1ZSk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJvdW5kc0Vycm9yKHZhbHVlLCBsZW5ndGgsIHR5cGUpIHsKICAgICAgICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKSB7CiAgICAgICAgICB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgdHlwZSk7CiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAib2Zmc2V0IiwgImFuIGludGVnZXIiLCB2YWx1ZSk7CiAgICAgICAgfQogICAgICAgIGlmIChsZW5ndGggPCAwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUygpOwogICAgICAgIH0KICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAib2Zmc2V0IiwgYD49ICR7dHlwZSA/IDEgOiAwfSBhbmQgPD0gJHtsZW5ndGh9YCwgdmFsdWUpOwogICAgICB9CiAgICAgIHZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2c7CiAgICAgIGZ1bmN0aW9uIGJhc2U2NGNsZWFuKHN0cikgewogICAgICAgIHN0ciA9IHN0ci5zcGxpdCgiPSIpWzBdOwogICAgICAgIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgIiIpOwogICAgICAgIGlmIChzdHIubGVuZ3RoIDwgMikKICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHsKICAgICAgICAgIHN0ciA9IHN0ciArICI9IjsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHN0cjsKICAgICAgfQogICAgICBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHJpbmcsIHVuaXRzKSB7CiAgICAgICAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eTsKICAgICAgICBsZXQgY29kZVBvaW50OwogICAgICAgIGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7CiAgICAgICAgbGV0IGxlYWRTdXJyb2dhdGUgPSBudWxsOwogICAgICAgIGNvbnN0IGJ5dGVzID0gW107CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgewogICAgICAgICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7CiAgICAgICAgICBpZiAoY29kZVBvaW50ID4gNTUyOTUgJiYgY29kZVBvaW50IDwgNTczNDQpIHsKICAgICAgICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7CiAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA+IDU2MzE5KSB7CiAgICAgICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpCiAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMjM5LCAxOTEsIDE4OSk7CiAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHsKICAgICAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkKICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgyMzksIDE5MSwgMTg5KTsKICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50OwogICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPCA1NjMyMCkgewogICAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkKICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMjM5LCAxOTEsIDE4OSk7CiAgICAgICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDsKICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDU1Mjk2IDw8IDEwIHwgY29kZVBvaW50IC0gNTYzMjApICsgNjU1MzY7CiAgICAgICAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHsKICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKQogICAgICAgICAgICAgIGJ5dGVzLnB1c2goMjM5LCAxOTEsIDE4OSk7CiAgICAgICAgICB9CiAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gbnVsbDsKICAgICAgICAgIGlmIChjb2RlUG9pbnQgPCAxMjgpIHsKICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApCiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KTsKICAgICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMjA0OCkgewogICAgICAgICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQgPj4gNiB8IDE5MiwgY29kZVBvaW50ICYgNjMgfCAxMjgpOwogICAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCA2NTUzNikgewogICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQgPj4gMTIgfCAyMjQsIGNvZGVQb2ludCA+PiA2ICYgNjMgfCAxMjgsIGNvZGVQb2ludCAmIDYzIHwgMTI4KTsKICAgICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMTExNDExMikgewogICAgICAgICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQgPj4gMTggfCAyNDAsIGNvZGVQb2ludCA+PiAxMiAmIDYzIHwgMTI4LCBjb2RlUG9pbnQgPj4gNiAmIDYzIHwgMTI4LCBjb2RlUG9pbnQgJiA2MyB8IDEyOCk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgY29kZSBwb2ludCIpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gYnl0ZXM7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYXNjaWlUb0J5dGVzKHN0cikgewogICAgICAgIGNvbnN0IGJ5dGVBcnJheSA9IFtdOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7CiAgICAgICAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDI1NSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBieXRlQXJyYXk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMoc3RyLCB1bml0cykgewogICAgICAgIGxldCBjLCBoaSwgbG87CiAgICAgICAgY29uc3QgYnl0ZUFycmF5ID0gW107CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHsKICAgICAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKQogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTsKICAgICAgICAgIGhpID0gYyA+PiA4OwogICAgICAgICAgbG8gPSBjICUgMjU2OwogICAgICAgICAgYnl0ZUFycmF5LnB1c2gobG8pOwogICAgICAgICAgYnl0ZUFycmF5LnB1c2goaGkpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gYnl0ZUFycmF5OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoc3RyKSB7CiAgICAgICAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBibGl0QnVmZmVyKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkgewogICAgICAgIGxldCBpOwogICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgewogICAgICAgICAgaWYgKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCB8fCBpID49IHNyYy5sZW5ndGgpCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldOwogICAgICAgIH0KICAgICAgICByZXR1cm4gaTsKICAgICAgfQogICAgICBmdW5jdGlvbiBpc0luc3RhbmNlKG9iaiwgdHlwZSkgewogICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8IG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZTsKICAgICAgfQogICAgICBmdW5jdGlvbiBudW1iZXJJc05hTihvYmopIHsKICAgICAgICByZXR1cm4gb2JqICE9PSBvYmo7CiAgICAgIH0KICAgICAgdmFyIGhleFNsaWNlTG9va3VwVGFibGUgPSBmdW5jdGlvbigpIHsKICAgICAgICBjb25zdCBhbHBoYWJldCA9ICIwMTIzNDU2Nzg5YWJjZGVmIjsKICAgICAgICBjb25zdCB0YWJsZSA9IG5ldyBBcnJheSgyNTYpOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkgewogICAgICAgICAgY29uc3QgaTE2ID0gaSAqIDE2OwogICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgKytqKSB7CiAgICAgICAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRhYmxlOwogICAgICB9KCk7CiAgICAgIGZ1bmN0aW9uIGRlZmluZUJpZ0ludE1ldGhvZChmbikgewogICAgICAgIHJldHVybiB0eXBlb2YgQmlnSW50ID09PSAidW5kZWZpbmVkIiA/IEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgOiBmbjsKICAgICAgfQogICAgICBmdW5jdGlvbiBCdWZmZXJCaWdJbnROb3REZWZpbmVkKCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiQmlnSW50IG5vdCBzdXBwb3J0ZWQiKTsKICAgICAgfQogICAgfQogIH0pOwoKICAvLyBzcmMvYWxpYXMvYnVmZmVyLXNoaW0uanMKICB2YXIgaW1wb3J0X2J1ZmZlcjsKICB2YXIgaW5pdF9idWZmZXJfc2hpbSA9IF9fZXNtKHsKICAgICJzcmMvYWxpYXMvYnVmZmVyLXNoaW0uanMiKCkgewogICAgICBpbXBvcnRfYnVmZmVyID0gX190b01vZHVsZShyZXF1aXJlX2J1ZmZlcigpKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2lzLW9ic2VydmFibGUvaW5kZXguanMKICB2YXIgcmVxdWlyZV9pc19vYnNlcnZhYmxlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2lzLW9ic2VydmFibGUvaW5kZXguanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSAodmFsdWUpID0+IHsKICAgICAgICBpZiAoIXZhbHVlKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgU3ltYm9sLm9ic2VydmFibGUgPT09ICJzeW1ib2wiICYmIHR5cGVvZiB2YWx1ZVtTeW1ib2wub2JzZXJ2YWJsZV0gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVbU3ltYm9sLm9ic2VydmFibGVdKCk7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgdmFsdWVbIkBAb2JzZXJ2YWJsZSJdID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlWyJAQG9ic2VydmFibGUiXSgpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvc2VyaWFsaXplcnMuanMKICB2YXIgcmVxdWlyZV9zZXJpYWxpemVycyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvc2VyaWFsaXplcnMuanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGV4cG9ydHMuRGVmYXVsdFNlcmlhbGl6ZXIgPSBleHBvcnRzLmV4dGVuZFNlcmlhbGl6ZXIgPSB2b2lkIDA7CiAgICAgIGZ1bmN0aW9uIGV4dGVuZFNlcmlhbGl6ZXIoZXh0ZW5kLCBpbXBsZW1lbnRhdGlvbikgewogICAgICAgIGNvbnN0IGZhbGxiYWNrRGVzZXJpYWxpemVyID0gZXh0ZW5kLmRlc2VyaWFsaXplLmJpbmQoZXh0ZW5kKTsKICAgICAgICBjb25zdCBmYWxsYmFja1NlcmlhbGl6ZXIgPSBleHRlbmQuc2VyaWFsaXplLmJpbmQoZXh0ZW5kKTsKICAgICAgICByZXR1cm4gewogICAgICAgICAgZGVzZXJpYWxpemUobWVzc2FnZSkgewogICAgICAgICAgICByZXR1cm4gaW1wbGVtZW50YXRpb24uZGVzZXJpYWxpemUobWVzc2FnZSwgZmFsbGJhY2tEZXNlcmlhbGl6ZXIpOwogICAgICAgICAgfSwKICAgICAgICAgIHNlcmlhbGl6ZShpbnB1dCkgewogICAgICAgICAgICByZXR1cm4gaW1wbGVtZW50YXRpb24uc2VyaWFsaXplKGlucHV0LCBmYWxsYmFja1NlcmlhbGl6ZXIpOwogICAgICAgICAgfQogICAgICAgIH07CiAgICAgIH0KICAgICAgZXhwb3J0cy5leHRlbmRTZXJpYWxpemVyID0gZXh0ZW5kU2VyaWFsaXplcjsKICAgICAgdmFyIERlZmF1bHRFcnJvclNlcmlhbGl6ZXIgPSB7CiAgICAgICAgZGVzZXJpYWxpemUobWVzc2FnZSkgewogICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oRXJyb3IobWVzc2FnZS5tZXNzYWdlKSwgewogICAgICAgICAgICBuYW1lOiBtZXNzYWdlLm5hbWUsCiAgICAgICAgICAgIHN0YWNrOiBtZXNzYWdlLnN0YWNrCiAgICAgICAgICB9KTsKICAgICAgICB9LAogICAgICAgIHNlcmlhbGl6ZShlcnJvcikgewogICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgX19lcnJvcl9tYXJrZXI6ICIkJGVycm9yIiwKICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSwKICAgICAgICAgICAgbmFtZTogZXJyb3IubmFtZSwKICAgICAgICAgICAgc3RhY2s6IGVycm9yLnN0YWNrCiAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgfTsKICAgICAgdmFyIGlzU2VyaWFsaXplZEVycm9yID0gKHRoaW5nKSA9PiB0aGluZyAmJiB0eXBlb2YgdGhpbmcgPT09ICJvYmplY3QiICYmICJfX2Vycm9yX21hcmtlciIgaW4gdGhpbmcgJiYgdGhpbmcuX19lcnJvcl9tYXJrZXIgPT09ICIkJGVycm9yIjsKICAgICAgZXhwb3J0cy5EZWZhdWx0U2VyaWFsaXplciA9IHsKICAgICAgICBkZXNlcmlhbGl6ZShtZXNzYWdlKSB7CiAgICAgICAgICBpZiAoaXNTZXJpYWxpemVkRXJyb3IobWVzc2FnZSkpIHsKICAgICAgICAgICAgcmV0dXJuIERlZmF1bHRFcnJvclNlcmlhbGl6ZXIuZGVzZXJpYWxpemUobWVzc2FnZSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4gbWVzc2FnZTsKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHNlcmlhbGl6ZShpbnB1dCkgewogICAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgRXJyb3IpIHsKICAgICAgICAgICAgcmV0dXJuIERlZmF1bHRFcnJvclNlcmlhbGl6ZXIuc2VyaWFsaXplKGlucHV0KTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJldHVybiBpbnB1dDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3QvY29tbW9uLmpzCiAgdmFyIHJlcXVpcmVfY29tbW9uID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC9jb21tb24uanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGV4cG9ydHMuc2VyaWFsaXplID0gZXhwb3J0cy5kZXNlcmlhbGl6ZSA9IGV4cG9ydHMucmVnaXN0ZXJTZXJpYWxpemVyID0gdm9pZCAwOwogICAgICB2YXIgc2VyaWFsaXplcnNfMSA9IHJlcXVpcmVfc2VyaWFsaXplcnMoKTsKICAgICAgdmFyIHJlZ2lzdGVyZWRTZXJpYWxpemVyID0gc2VyaWFsaXplcnNfMS5EZWZhdWx0U2VyaWFsaXplcjsKICAgICAgZnVuY3Rpb24gcmVnaXN0ZXJTZXJpYWxpemVyMihzZXJpYWxpemVyKSB7CiAgICAgICAgcmVnaXN0ZXJlZFNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyc18xLmV4dGVuZFNlcmlhbGl6ZXIocmVnaXN0ZXJlZFNlcmlhbGl6ZXIsIHNlcmlhbGl6ZXIpOwogICAgICB9CiAgICAgIGV4cG9ydHMucmVnaXN0ZXJTZXJpYWxpemVyID0gcmVnaXN0ZXJTZXJpYWxpemVyMjsKICAgICAgZnVuY3Rpb24gZGVzZXJpYWxpemUobWVzc2FnZSkgewogICAgICAgIHJldHVybiByZWdpc3RlcmVkU2VyaWFsaXplci5kZXNlcmlhbGl6ZShtZXNzYWdlKTsKICAgICAgfQogICAgICBleHBvcnRzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemU7CiAgICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZShpbnB1dCkgewogICAgICAgIHJldHVybiByZWdpc3RlcmVkU2VyaWFsaXplci5zZXJpYWxpemUoaW5wdXQpOwogICAgICB9CiAgICAgIGV4cG9ydHMuc2VyaWFsaXplID0gc2VyaWFsaXplOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3N5bWJvbHMuanMKICB2YXIgcmVxdWlyZV9zeW1ib2xzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC9zeW1ib2xzLmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICBleHBvcnRzLiR3b3JrZXIgPSBleHBvcnRzLiR0cmFuc2ZlcmFibGUgPSBleHBvcnRzLiR0ZXJtaW5hdGUgPSBleHBvcnRzLiRldmVudHMgPSBleHBvcnRzLiRlcnJvcnMgPSB2b2lkIDA7CiAgICAgIGV4cG9ydHMuJGVycm9ycyA9IFN5bWJvbCgidGhyZWFkLmVycm9ycyIpOwogICAgICBleHBvcnRzLiRldmVudHMgPSBTeW1ib2woInRocmVhZC5ldmVudHMiKTsKICAgICAgZXhwb3J0cy4kdGVybWluYXRlID0gU3ltYm9sKCJ0aHJlYWQudGVybWluYXRlIik7CiAgICAgIGV4cG9ydHMuJHRyYW5zZmVyYWJsZSA9IFN5bWJvbCgidGhyZWFkLnRyYW5zZmVyYWJsZSIpOwogICAgICBleHBvcnRzLiR3b3JrZXIgPSBTeW1ib2woInRocmVhZC53b3JrZXIiKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC90cmFuc2ZlcmFibGUuanMKICB2YXIgcmVxdWlyZV90cmFuc2ZlcmFibGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3RyYW5zZmVyYWJsZS5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZXhwb3J0cy5UcmFuc2ZlciA9IGV4cG9ydHMuaXNUcmFuc2ZlckRlc2NyaXB0b3IgPSB2b2lkIDA7CiAgICAgIHZhciBzeW1ib2xzXzEgPSByZXF1aXJlX3N5bWJvbHMoKTsKICAgICAgZnVuY3Rpb24gaXNUcmFuc2ZlcmFibGUodGhpbmcpIHsKICAgICAgICBpZiAoIXRoaW5nIHx8IHR5cGVvZiB0aGluZyAhPT0gIm9iamVjdCIpCiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaXNUcmFuc2ZlckRlc2NyaXB0b3IodGhpbmcpIHsKICAgICAgICByZXR1cm4gdGhpbmcgJiYgdHlwZW9mIHRoaW5nID09PSAib2JqZWN0IiAmJiB0aGluZ1tzeW1ib2xzXzEuJHRyYW5zZmVyYWJsZV07CiAgICAgIH0KICAgICAgZXhwb3J0cy5pc1RyYW5zZmVyRGVzY3JpcHRvciA9IGlzVHJhbnNmZXJEZXNjcmlwdG9yOwogICAgICBmdW5jdGlvbiBUcmFuc2ZlcjIocGF5bG9hZCwgdHJhbnNmZXJhYmxlcykgewogICAgICAgIGlmICghdHJhbnNmZXJhYmxlcykgewogICAgICAgICAgaWYgKCFpc1RyYW5zZmVyYWJsZShwYXlsb2FkKSkKICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTsKICAgICAgICAgIHRyYW5zZmVyYWJsZXMgPSBbcGF5bG9hZF07CiAgICAgICAgfQogICAgICAgIHJldHVybiB7CiAgICAgICAgICBbc3ltYm9sc18xLiR0cmFuc2ZlcmFibGVdOiB0cnVlLAogICAgICAgICAgc2VuZDogcGF5bG9hZCwKICAgICAgICAgIHRyYW5zZmVyYWJsZXMKICAgICAgICB9OwogICAgICB9CiAgICAgIGV4cG9ydHMuVHJhbnNmZXIgPSBUcmFuc2ZlcjI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3QvdHlwZXMvbWVzc2FnZXMuanMKICB2YXIgcmVxdWlyZV9tZXNzYWdlcyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3QvdHlwZXMvbWVzc2FnZXMuanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGV4cG9ydHMuV29ya2VyTWVzc2FnZVR5cGUgPSBleHBvcnRzLk1hc3Rlck1lc3NhZ2VUeXBlID0gdm9pZCAwOwogICAgICB2YXIgTWFzdGVyTWVzc2FnZVR5cGU7CiAgICAgIChmdW5jdGlvbihNYXN0ZXJNZXNzYWdlVHlwZTIpIHsKICAgICAgICBNYXN0ZXJNZXNzYWdlVHlwZTJbImNhbmNlbCJdID0gImNhbmNlbCI7CiAgICAgICAgTWFzdGVyTWVzc2FnZVR5cGUyWyJydW4iXSA9ICJydW4iOwogICAgICB9KShNYXN0ZXJNZXNzYWdlVHlwZSA9IGV4cG9ydHMuTWFzdGVyTWVzc2FnZVR5cGUgfHwgKGV4cG9ydHMuTWFzdGVyTWVzc2FnZVR5cGUgPSB7fSkpOwogICAgICB2YXIgV29ya2VyTWVzc2FnZVR5cGU7CiAgICAgIChmdW5jdGlvbihXb3JrZXJNZXNzYWdlVHlwZTIpIHsKICAgICAgICBXb3JrZXJNZXNzYWdlVHlwZTJbImVycm9yIl0gPSAiZXJyb3IiOwogICAgICAgIFdvcmtlck1lc3NhZ2VUeXBlMlsiaW5pdCJdID0gImluaXQiOwogICAgICAgIFdvcmtlck1lc3NhZ2VUeXBlMlsicmVzdWx0Il0gPSAicmVzdWx0IjsKICAgICAgICBXb3JrZXJNZXNzYWdlVHlwZTJbInJ1bm5pbmciXSA9ICJydW5uaW5nIjsKICAgICAgICBXb3JrZXJNZXNzYWdlVHlwZTJbInVuY2F1Z2h0RXJyb3IiXSA9ICJ1bmNhdWdodEVycm9yIjsKICAgICAgfSkoV29ya2VyTWVzc2FnZVR5cGUgPSBleHBvcnRzLldvcmtlck1lc3NhZ2VUeXBlIHx8IChleHBvcnRzLldvcmtlck1lc3NhZ2VUeXBlID0ge30pKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC93b3JrZXIvaW1wbGVtZW50YXRpb24uYnJvd3Nlci5qcwogIHZhciByZXF1aXJlX2ltcGxlbWVudGF0aW9uX2Jyb3dzZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3dvcmtlci9pbXBsZW1lbnRhdGlvbi5icm93c2VyLmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICB2YXIgaXNXb3JrZXJSdW50aW1lID0gZnVuY3Rpb24gaXNXb3JrZXJSdW50aW1lMigpIHsKICAgICAgICBjb25zdCBpc1dpbmRvd0NvbnRleHQgPSB0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgJiYgdHlwZW9mIFdpbmRvdyAhPT0gInVuZGVmaW5lZCIgJiYgc2VsZiBpbnN0YW5jZW9mIFdpbmRvdzsKICAgICAgICByZXR1cm4gdHlwZW9mIHNlbGYgIT09ICJ1bmRlZmluZWQiICYmIHNlbGYucG9zdE1lc3NhZ2UgJiYgIWlzV2luZG93Q29udGV4dCA/IHRydWUgOiBmYWxzZTsKICAgICAgfTsKICAgICAgdmFyIHBvc3RNZXNzYWdlVG9NYXN0ZXIgPSBmdW5jdGlvbiBwb3N0TWVzc2FnZVRvTWFzdGVyMihkYXRhLCB0cmFuc2Zlckxpc3QpIHsKICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKGRhdGEsIHRyYW5zZmVyTGlzdCk7CiAgICAgIH07CiAgICAgIHZhciBzdWJzY3JpYmVUb01hc3Rlck1lc3NhZ2VzID0gZnVuY3Rpb24gc3Vic2NyaWJlVG9NYXN0ZXJNZXNzYWdlczIob25NZXNzYWdlKSB7CiAgICAgICAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSAobWVzc2FnZUV2ZW50KSA9PiB7CiAgICAgICAgICBvbk1lc3NhZ2UobWVzc2FnZUV2ZW50LmRhdGEpOwogICAgICAgIH07CiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSAoKSA9PiB7CiAgICAgICAgICBzZWxmLnJlbW92ZUV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLCBtZXNzYWdlSGFuZGxlcik7CiAgICAgICAgfTsKICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLCBtZXNzYWdlSGFuZGxlcik7CiAgICAgICAgcmV0dXJuIHVuc3Vic2NyaWJlOwogICAgICB9OwogICAgICBleHBvcnRzLmRlZmF1bHQgPSB7CiAgICAgICAgaXNXb3JrZXJSdW50aW1lLAogICAgICAgIHBvc3RNZXNzYWdlVG9NYXN0ZXIsCiAgICAgICAgc3Vic2NyaWJlVG9NYXN0ZXJNZXNzYWdlcwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3dvcmtlci9pbmRleC5qcwogIHZhciByZXF1aXJlX3dvcmtlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvd29ya2VyL2luZGV4LmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgX19hd2FpdGVyID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fYXdhaXRlciB8fCBmdW5jdGlvbih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHsKICAgICAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgewogICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24ocmVzb2x2ZSkgewogICAgICAgICAgICByZXNvbHZlKHZhbHVlKTsKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkgewogICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOwogICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgcmVqZWN0KGUpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgewogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yWyJ0aHJvdyJdKHZhbHVlKSk7CiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICByZWplY3QoZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7CiAgICAgICAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOwogICAgICAgICAgfQogICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpOwogICAgICAgIH0pOwogICAgICB9OwogICAgICB2YXIgX19pbXBvcnREZWZhdWx0ID0gZXhwb3J0cyAmJiBleHBvcnRzLl9faW1wb3J0RGVmYXVsdCB8fCBmdW5jdGlvbihtb2QpIHsKICAgICAgICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDogeyAiZGVmYXVsdCI6IG1vZCB9OwogICAgICB9OwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICBleHBvcnRzLmV4cG9zZSA9IGV4cG9ydHMuaXNXb3JrZXJSdW50aW1lID0gZXhwb3J0cy5UcmFuc2ZlciA9IGV4cG9ydHMucmVnaXN0ZXJTZXJpYWxpemVyID0gdm9pZCAwOwogICAgICB2YXIgaXNfb2JzZXJ2YWJsZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmVfaXNfb2JzZXJ2YWJsZSgpKTsKICAgICAgdmFyIGNvbW1vbl8xID0gcmVxdWlyZV9jb21tb24oKTsKICAgICAgdmFyIHRyYW5zZmVyYWJsZV8xID0gcmVxdWlyZV90cmFuc2ZlcmFibGUoKTsKICAgICAgdmFyIG1lc3NhZ2VzXzEgPSByZXF1aXJlX21lc3NhZ2VzKCk7CiAgICAgIHZhciBpbXBsZW1lbnRhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmVfaW1wbGVtZW50YXRpb25fYnJvd3NlcigpKTsKICAgICAgdmFyIGNvbW1vbl8yID0gcmVxdWlyZV9jb21tb24oKTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJyZWdpc3RlclNlcmlhbGl6ZXIiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIGNvbW1vbl8yLnJlZ2lzdGVyU2VyaWFsaXplcjsKICAgICAgfSB9KTsKICAgICAgdmFyIHRyYW5zZmVyYWJsZV8yID0gcmVxdWlyZV90cmFuc2ZlcmFibGUoKTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJUcmFuc2ZlciIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdHJhbnNmZXJhYmxlXzIuVHJhbnNmZXI7CiAgICAgIH0gfSk7CiAgICAgIGV4cG9ydHMuaXNXb3JrZXJSdW50aW1lID0gaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LmlzV29ya2VyUnVudGltZTsKICAgICAgdmFyIGV4cG9zZUNhbGxlZCA9IGZhbHNlOwogICAgICB2YXIgYWN0aXZlU3Vic2NyaXB0aW9ucyA9IG5ldyBNYXAoKTsKICAgICAgdmFyIGlzTWFzdGVySm9iQ2FuY2VsTWVzc2FnZSA9ICh0aGluZykgPT4gdGhpbmcgJiYgdGhpbmcudHlwZSA9PT0gbWVzc2FnZXNfMS5NYXN0ZXJNZXNzYWdlVHlwZS5jYW5jZWw7CiAgICAgIHZhciBpc01hc3RlckpvYlJ1bk1lc3NhZ2UgPSAodGhpbmcpID0+IHRoaW5nICYmIHRoaW5nLnR5cGUgPT09IG1lc3NhZ2VzXzEuTWFzdGVyTWVzc2FnZVR5cGUucnVuOwogICAgICB2YXIgaXNPYnNlcnZhYmxlID0gKHRoaW5nKSA9PiBpc19vYnNlcnZhYmxlXzEuZGVmYXVsdCh0aGluZykgfHwgaXNaZW5PYnNlcnZhYmxlKHRoaW5nKTsKICAgICAgZnVuY3Rpb24gaXNaZW5PYnNlcnZhYmxlKHRoaW5nKSB7CiAgICAgICAgcmV0dXJuIHRoaW5nICYmIHR5cGVvZiB0aGluZyA9PT0gIm9iamVjdCIgJiYgdHlwZW9mIHRoaW5nLnN1YnNjcmliZSA9PT0gImZ1bmN0aW9uIjsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWNvbnN0cnVjdFRyYW5zZmVyKHRoaW5nKSB7CiAgICAgICAgcmV0dXJuIHRyYW5zZmVyYWJsZV8xLmlzVHJhbnNmZXJEZXNjcmlwdG9yKHRoaW5nKSA/IHsgcGF5bG9hZDogdGhpbmcuc2VuZCwgdHJhbnNmZXJhYmxlczogdGhpbmcudHJhbnNmZXJhYmxlcyB9IDogeyBwYXlsb2FkOiB0aGluZywgdHJhbnNmZXJhYmxlczogdm9pZCAwIH07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9zdEZ1bmN0aW9uSW5pdE1lc3NhZ2UoKSB7CiAgICAgICAgY29uc3QgaW5pdE1lc3NhZ2UgPSB7CiAgICAgICAgICB0eXBlOiBtZXNzYWdlc18xLldvcmtlck1lc3NhZ2VUeXBlLmluaXQsCiAgICAgICAgICBleHBvc2VkOiB7CiAgICAgICAgICAgIHR5cGU6ICJmdW5jdGlvbiIKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5wb3N0TWVzc2FnZVRvTWFzdGVyKGluaXRNZXNzYWdlKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwb3N0TW9kdWxlSW5pdE1lc3NhZ2UobWV0aG9kTmFtZXMpIHsKICAgICAgICBjb25zdCBpbml0TWVzc2FnZSA9IHsKICAgICAgICAgIHR5cGU6IG1lc3NhZ2VzXzEuV29ya2VyTWVzc2FnZVR5cGUuaW5pdCwKICAgICAgICAgIGV4cG9zZWQ6IHsKICAgICAgICAgICAgdHlwZTogIm1vZHVsZSIsCiAgICAgICAgICAgIG1ldGhvZHM6IG1ldGhvZE5hbWVzCiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQucG9zdE1lc3NhZ2VUb01hc3Rlcihpbml0TWVzc2FnZSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9zdEpvYkVycm9yTWVzc2FnZSh1aWQsIHJhd0Vycm9yKSB7CiAgICAgICAgY29uc3QgeyBwYXlsb2FkOiBlcnJvciwgdHJhbnNmZXJhYmxlcyB9ID0gZGVjb25zdHJ1Y3RUcmFuc2ZlcihyYXdFcnJvcik7CiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gewogICAgICAgICAgdHlwZTogbWVzc2FnZXNfMS5Xb3JrZXJNZXNzYWdlVHlwZS5lcnJvciwKICAgICAgICAgIHVpZCwKICAgICAgICAgIGVycm9yOiBjb21tb25fMS5zZXJpYWxpemUoZXJyb3IpCiAgICAgICAgfTsKICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQucG9zdE1lc3NhZ2VUb01hc3RlcihlcnJvck1lc3NhZ2UsIHRyYW5zZmVyYWJsZXMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBvc3RKb2JSZXN1bHRNZXNzYWdlKHVpZCwgY29tcGxldGVkLCByZXN1bHRWYWx1ZSkgewogICAgICAgIGNvbnN0IHsgcGF5bG9hZCwgdHJhbnNmZXJhYmxlcyB9ID0gZGVjb25zdHJ1Y3RUcmFuc2ZlcihyZXN1bHRWYWx1ZSk7CiAgICAgICAgY29uc3QgcmVzdWx0TWVzc2FnZSA9IHsKICAgICAgICAgIHR5cGU6IG1lc3NhZ2VzXzEuV29ya2VyTWVzc2FnZVR5cGUucmVzdWx0LAogICAgICAgICAgdWlkLAogICAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlZCA/IHRydWUgOiB2b2lkIDAsCiAgICAgICAgICBwYXlsb2FkCiAgICAgICAgfTsKICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQucG9zdE1lc3NhZ2VUb01hc3RlcihyZXN1bHRNZXNzYWdlLCB0cmFuc2ZlcmFibGVzKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwb3N0Sm9iU3RhcnRNZXNzYWdlKHVpZCwgcmVzdWx0VHlwZSkgewogICAgICAgIGNvbnN0IHN0YXJ0TWVzc2FnZSA9IHsKICAgICAgICAgIHR5cGU6IG1lc3NhZ2VzXzEuV29ya2VyTWVzc2FnZVR5cGUucnVubmluZywKICAgICAgICAgIHVpZCwKICAgICAgICAgIHJlc3VsdFR5cGUKICAgICAgICB9OwogICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5wb3N0TWVzc2FnZVRvTWFzdGVyKHN0YXJ0TWVzc2FnZSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9zdFVuY2F1Z2h0RXJyb3JNZXNzYWdlKGVycm9yKSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHsKICAgICAgICAgICAgdHlwZTogbWVzc2FnZXNfMS5Xb3JrZXJNZXNzYWdlVHlwZS51bmNhdWdodEVycm9yLAogICAgICAgICAgICBlcnJvcjogY29tbW9uXzEuc2VyaWFsaXplKGVycm9yKQogICAgICAgICAgfTsKICAgICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5wb3N0TWVzc2FnZVRvTWFzdGVyKGVycm9yTWVzc2FnZSk7CiAgICAgICAgfSBjYXRjaCAoc3ViRXJyb3IpIHsKICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIk5vdCByZXBvcnRpbmcgdW5jYXVnaHQgZXJyb3IgYmFjayB0byBtYXN0ZXIgdGhyZWFkIGFzIGl0IG9jY3VyZWQgd2hpbGUgcmVwb3J0aW5nIGFuIHVuY2F1Z2h0IGVycm9yIGFscmVhZHkuXG5MYXRlc3QgZXJyb3I6Iiwgc3ViRXJyb3IsICJcbk9yaWdpbmFsIGVycm9yOiIsIGVycm9yKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcnVuRnVuY3Rpb24oam9iVUlELCBmbiwgYXJncykgewogICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7CiAgICAgICAgICBsZXQgc3luY1Jlc3VsdDsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHN5bmNSZXN1bHQgPSBmbiguLi5hcmdzKTsKICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgICAgIHJldHVybiBwb3N0Sm9iRXJyb3JNZXNzYWdlKGpvYlVJRCwgZXJyb3IpOwogICAgICAgICAgfQogICAgICAgICAgY29uc3QgcmVzdWx0VHlwZSA9IGlzT2JzZXJ2YWJsZShzeW5jUmVzdWx0KSA/ICJvYnNlcnZhYmxlIiA6ICJwcm9taXNlIjsKICAgICAgICAgIHBvc3RKb2JTdGFydE1lc3NhZ2Uoam9iVUlELCByZXN1bHRUeXBlKTsKICAgICAgICAgIGlmIChpc09ic2VydmFibGUoc3luY1Jlc3VsdCkpIHsKICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gc3luY1Jlc3VsdC5zdWJzY3JpYmUoKHZhbHVlKSA9PiBwb3N0Sm9iUmVzdWx0TWVzc2FnZShqb2JVSUQsIGZhbHNlLCBjb21tb25fMS5zZXJpYWxpemUodmFsdWUpKSwgKGVycm9yKSA9PiB7CiAgICAgICAgICAgICAgcG9zdEpvYkVycm9yTWVzc2FnZShqb2JVSUQsIGNvbW1vbl8xLnNlcmlhbGl6ZShlcnJvcikpOwogICAgICAgICAgICAgIGFjdGl2ZVN1YnNjcmlwdGlvbnMuZGVsZXRlKGpvYlVJRCk7CiAgICAgICAgICAgIH0sICgpID0+IHsKICAgICAgICAgICAgICBwb3N0Sm9iUmVzdWx0TWVzc2FnZShqb2JVSUQsIHRydWUpOwogICAgICAgICAgICAgIGFjdGl2ZVN1YnNjcmlwdGlvbnMuZGVsZXRlKGpvYlVJRCk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICBhY3RpdmVTdWJzY3JpcHRpb25zLnNldChqb2JVSUQsIHN1YnNjcmlwdGlvbik7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHN5bmNSZXN1bHQ7CiAgICAgICAgICAgICAgcG9zdEpvYlJlc3VsdE1lc3NhZ2Uoam9iVUlELCB0cnVlLCBjb21tb25fMS5zZXJpYWxpemUocmVzdWx0KSk7CiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgICAgICAgcG9zdEpvYkVycm9yTWVzc2FnZShqb2JVSUQsIGNvbW1vbl8xLnNlcmlhbGl6ZShlcnJvcikpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZXhwb3NlMihleHBvc2VkKSB7CiAgICAgICAgaWYgKCFpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQuaXNXb3JrZXJSdW50aW1lKCkpIHsKICAgICAgICAgIHRocm93IEVycm9yKCJleHBvc2UoKSBjYWxsZWQgaW4gdGhlIG1hc3RlciB0aHJlYWQuIik7CiAgICAgICAgfQogICAgICAgIGlmIChleHBvc2VDYWxsZWQpIHsKICAgICAgICAgIHRocm93IEVycm9yKCJleHBvc2UoKSBjYWxsZWQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgaXMgbm90IHBvc3NpYmxlLiBQYXNzIGFuIG9iamVjdCB0byBleHBvc2UoKSBpZiB5b3Ugd2FudCB0byBleHBvc2UgbXVsdGlwbGUgZnVuY3Rpb25zLiIpOwogICAgICAgIH0KICAgICAgICBleHBvc2VDYWxsZWQgPSB0cnVlOwogICAgICAgIGlmICh0eXBlb2YgZXhwb3NlZCA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnN1YnNjcmliZVRvTWFzdGVyTWVzc2FnZXMoKG1lc3NhZ2VEYXRhKSA9PiB7CiAgICAgICAgICAgIGlmIChpc01hc3RlckpvYlJ1bk1lc3NhZ2UobWVzc2FnZURhdGEpICYmICFtZXNzYWdlRGF0YS5tZXRob2QpIHsKICAgICAgICAgICAgICBydW5GdW5jdGlvbihtZXNzYWdlRGF0YS51aWQsIGV4cG9zZWQsIG1lc3NhZ2VEYXRhLmFyZ3MubWFwKGNvbW1vbl8xLmRlc2VyaWFsaXplKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwogICAgICAgICAgcG9zdEZ1bmN0aW9uSW5pdE1lc3NhZ2UoKTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvc2VkID09PSAib2JqZWN0IiAmJiBleHBvc2VkKSB7CiAgICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQuc3Vic2NyaWJlVG9NYXN0ZXJNZXNzYWdlcygobWVzc2FnZURhdGEpID0+IHsKICAgICAgICAgICAgaWYgKGlzTWFzdGVySm9iUnVuTWVzc2FnZShtZXNzYWdlRGF0YSkgJiYgbWVzc2FnZURhdGEubWV0aG9kKSB7CiAgICAgICAgICAgICAgcnVuRnVuY3Rpb24obWVzc2FnZURhdGEudWlkLCBleHBvc2VkW21lc3NhZ2VEYXRhLm1ldGhvZF0sIG1lc3NhZ2VEYXRhLmFyZ3MubWFwKGNvbW1vbl8xLmRlc2VyaWFsaXplKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwogICAgICAgICAgY29uc3QgbWV0aG9kTmFtZXMgPSBPYmplY3Qua2V5cyhleHBvc2VkKS5maWx0ZXIoKGtleSkgPT4gdHlwZW9mIGV4cG9zZWRba2V5XSA9PT0gImZ1bmN0aW9uIik7CiAgICAgICAgICBwb3N0TW9kdWxlSW5pdE1lc3NhZ2UobWV0aG9kTmFtZXMpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aHJvdyBFcnJvcihgSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgdG8gZXhwb3NlKCkuIEV4cGVjdGVkIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0LCBnb3Q6ICR7ZXhwb3NlZH1gKTsKICAgICAgICB9CiAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnN1YnNjcmliZVRvTWFzdGVyTWVzc2FnZXMoKG1lc3NhZ2VEYXRhKSA9PiB7CiAgICAgICAgICBpZiAoaXNNYXN0ZXJKb2JDYW5jZWxNZXNzYWdlKG1lc3NhZ2VEYXRhKSkgewogICAgICAgICAgICBjb25zdCBqb2JVSUQgPSBtZXNzYWdlRGF0YS51aWQ7CiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGFjdGl2ZVN1YnNjcmlwdGlvbnMuZ2V0KGpvYlVJRCk7CiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHsKICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTsKICAgICAgICAgICAgICBhY3RpdmVTdWJzY3JpcHRpb25zLmRlbGV0ZShqb2JVSUQpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgZXhwb3J0cy5leHBvc2UgPSBleHBvc2UyOwogICAgICBpZiAodHlwZW9mIHNlbGYgIT09ICJ1bmRlZmluZWQiICYmIHR5cGVvZiBzZWxmLmFkZEV2ZW50TGlzdGVuZXIgPT09ICJmdW5jdGlvbiIgJiYgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LmlzV29ya2VyUnVudGltZSgpKSB7CiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCJlcnJvciIsIChldmVudCkgPT4gewogICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBwb3N0VW5jYXVnaHRFcnJvck1lc3NhZ2UoZXZlbnQuZXJyb3IgfHwgZXZlbnQpLCAyNTApOwogICAgICAgIH0pOwogICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcigidW5oYW5kbGVkcmVqZWN0aW9uIiwgKGV2ZW50KSA9PiB7CiAgICAgICAgICBjb25zdCBlcnJvciA9IGV2ZW50LnJlYXNvbjsKICAgICAgICAgIGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBwb3N0VW5jYXVnaHRFcnJvck1lc3NhZ2UoZXJyb3IpLCAyNTApOwogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICB9CiAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gInVuZGVmaW5lZCIgJiYgdHlwZW9mIHByb2Nlc3Mub24gPT09ICJmdW5jdGlvbiIgJiYgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LmlzV29ya2VyUnVudGltZSgpKSB7CiAgICAgICAgcHJvY2Vzcy5vbigidW5jYXVnaHRFeGNlcHRpb24iLCAoZXJyb3IpID0+IHsKICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcG9zdFVuY2F1Z2h0RXJyb3JNZXNzYWdlKGVycm9yKSwgMjUwKTsKICAgICAgICB9KTsKICAgICAgICBwcm9jZXNzLm9uKCJ1bmhhbmRsZWRSZWplY3Rpb24iLCAoZXJyb3IpID0+IHsKICAgICAgICAgIGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBwb3N0VW5jYXVnaHRFcnJvck1lc3NhZ2UoZXJyb3IpLCAyNTApOwogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICB9CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzCiAgdmFyIHJlcXVpcmVfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7CiAgICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsKICAgICAgICAgICJkZWZhdWx0Ijogb2JqCiAgICAgICAgfTsKICAgICAgfQogICAgICBtb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQ7CiAgICAgIG1vZHVsZS5leHBvcnRzWyJkZWZhdWx0Il0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2dsb2JhbC5qcwogIHZhciByZXF1aXJlX2dsb2JhbCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2dsb2JhbC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGNoZWNrID0gZnVuY3Rpb24oaXQpIHsKICAgICAgICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PSBNYXRoICYmIGl0OwogICAgICB9OwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09ICJvYmplY3QiICYmIGdsb2JhbFRoaXMpIHx8IGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gIm9iamVjdCIgJiYgd2luZG93KSB8fCBjaGVjayh0eXBlb2Ygc2VsZiA9PSAib2JqZWN0IiAmJiBzZWxmKSB8fCBjaGVjayh0eXBlb2YgZ2xvYmFsID09ICJvYmplY3QiICYmIGdsb2JhbCkgfHwgZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH0oKSB8fCBGdW5jdGlvbigicmV0dXJuIHRoaXMiKSgpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pcy1jYWxsYWJsZS5qcwogIHZhciByZXF1aXJlX2lzX2NhbGxhYmxlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvaXMtY2FsbGFibGUuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJndW1lbnQpIHsKICAgICAgICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09PSAiZnVuY3Rpb24iOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9mYWlscy5qcwogIHZhciByZXF1aXJlX2ZhaWxzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZmFpbHMuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYykgewogICAgICAgIHRyeSB7CiAgICAgICAgICByZXR1cm4gISFleGVjKCk7CiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0KICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanMKICB2YXIgcmVxdWlyZV9kZXNjcmlwdG9ycyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgZmFpbHMgPSByZXF1aXJlX2ZhaWxzKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIDEsIHsgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICAgIHJldHVybiA3OwogICAgICAgIH0gfSlbMV0gIT0gNzsKICAgICAgfSk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlLmpzCiAgdmFyIHJlcXVpcmVfb2JqZWN0X3Byb3BlcnR5X2lzX2VudW1lcmFibGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZS5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlOwogICAgICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsKICAgICAgdmFyIE5BU0hPUk5fQlVHID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICYmICEkcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh7IDE6IDIgfSwgMSk7CiAgICAgIGV4cG9ydHMuZiA9IE5BU0hPUk5fQlVHID8gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikgewogICAgICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMsIFYpOwogICAgICAgIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlOwogICAgICB9IDogJHByb3BlcnR5SXNFbnVtZXJhYmxlOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvci5qcwogIHZhciByZXF1aXJlX2NyZWF0ZV9wcm9wZXJ0eV9kZXNjcmlwdG9yID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSkgewogICAgICAgIHJldHVybiB7CiAgICAgICAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLAogICAgICAgICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLAogICAgICAgICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksCiAgICAgICAgICB2YWx1ZQogICAgICAgIH07CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzCiAgdmFyIHJlcXVpcmVfY2xhc3NvZl9yYXcgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9jbGFzc29mLXJhdy5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpIHsKICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pbmRleGVkLW9iamVjdC5qcwogIHZhciByZXF1aXJlX2luZGV4ZWRfb2JqZWN0ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBmYWlscyA9IHJlcXVpcmVfZmFpbHMoKTsKICAgICAgdmFyIGNsYXNzb2YgPSByZXF1aXJlX2NsYXNzb2ZfcmF3KCk7CiAgICAgIHZhciBzcGxpdCA9ICIiLnNwbGl0OwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhaWxzKGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiAhT2JqZWN0KCJ6IikucHJvcGVydHlJc0VudW1lcmFibGUoMCk7CiAgICAgIH0pID8gZnVuY3Rpb24oaXQpIHsKICAgICAgICByZXR1cm4gY2xhc3NvZihpdCkgPT0gIlN0cmluZyIgPyBzcGxpdC5jYWxsKGl0LCAiIikgOiBPYmplY3QoaXQpOwogICAgICB9IDogT2JqZWN0OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanMKICB2YXIgcmVxdWlyZV9yZXF1aXJlX29iamVjdF9jb2VyY2libGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpIHsKICAgICAgICBpZiAoaXQgPT0gdm9pZCAwKQogICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAiICsgaXQpOwogICAgICAgIHJldHVybiBpdDsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanMKICB2YXIgcmVxdWlyZV90b19pbmRleGVkX29iamVjdCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgSW5kZXhlZE9iamVjdCA9IHJlcXVpcmVfaW5kZXhlZF9vYmplY3QoKTsKICAgICAgdmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlX3JlcXVpcmVfb2JqZWN0X2NvZXJjaWJsZSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KSB7CiAgICAgICAgcmV0dXJuIEluZGV4ZWRPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShpdCkpOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pcy1vYmplY3QuanMKICB2YXIgcmVxdWlyZV9pc19vYmplY3QgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pcy1vYmplY3QuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBpc0NhbGxhYmxlID0gcmVxdWlyZV9pc19jYWxsYWJsZSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KSB7CiAgICAgICAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gIm9iamVjdCIgPyBpdCAhPT0gbnVsbCA6IGlzQ2FsbGFibGUoaXQpOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9wYXRoLmpzCiAgdmFyIHJlcXVpcmVfcGF0aCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3BhdGguanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0ge307CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qcwogIHZhciByZXF1aXJlX2dldF9idWlsdF9pbiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHBhdGggPSByZXF1aXJlX3BhdGgoKTsKICAgICAgdmFyIGdsb2JhbDIgPSByZXF1aXJlX2dsb2JhbCgpOwogICAgICB2YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmVfaXNfY2FsbGFibGUoKTsKICAgICAgdmFyIGFGdW5jdGlvbiA9IGZ1bmN0aW9uKHZhcmlhYmxlKSB7CiAgICAgICAgcmV0dXJuIGlzQ2FsbGFibGUodmFyaWFibGUpID8gdmFyaWFibGUgOiB2b2lkIDA7CiAgICAgIH07CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZXNwYWNlLCBtZXRob2QpIHsKICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBhRnVuY3Rpb24ocGF0aFtuYW1lc3BhY2VdKSB8fCBhRnVuY3Rpb24oZ2xvYmFsMltuYW1lc3BhY2VdKSA6IHBhdGhbbmFtZXNwYWNlXSAmJiBwYXRoW25hbWVzcGFjZV1bbWV0aG9kXSB8fCBnbG9iYWwyW25hbWVzcGFjZV0gJiYgZ2xvYmFsMltuYW1lc3BhY2VdW21ldGhvZF07CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50LmpzCiAgdmFyIHJlcXVpcmVfZW5naW5lX3VzZXJfYWdlbnQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9lbmdpbmUtdXNlci1hZ2VudC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlX2dldF9idWlsdF9pbigpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oIm5hdmlnYXRvciIsICJ1c2VyQWdlbnQiKSB8fCAiIjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24uanMKICB2YXIgcmVxdWlyZV9lbmdpbmVfdjhfdmVyc2lvbiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2VuZ2luZS12OC12ZXJzaW9uLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgZ2xvYmFsMiA9IHJlcXVpcmVfZ2xvYmFsKCk7CiAgICAgIHZhciB1c2VyQWdlbnQgPSByZXF1aXJlX2VuZ2luZV91c2VyX2FnZW50KCk7CiAgICAgIHZhciBwcm9jZXNzMiA9IGdsb2JhbDIucHJvY2VzczsKICAgICAgdmFyIERlbm8gPSBnbG9iYWwyLkRlbm87CiAgICAgIHZhciB2ZXJzaW9ucyA9IHByb2Nlc3MyICYmIHByb2Nlc3MyLnZlcnNpb25zIHx8IERlbm8gJiYgRGVuby52ZXJzaW9uOwogICAgICB2YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52ODsKICAgICAgdmFyIG1hdGNoOwogICAgICB2YXIgdmVyc2lvbjsKICAgICAgaWYgKHY4KSB7CiAgICAgICAgbWF0Y2ggPSB2OC5zcGxpdCgiLiIpOwogICAgICAgIHZlcnNpb24gPSBtYXRjaFswXSA8IDQgPyAxIDogbWF0Y2hbMF0gKyBtYXRjaFsxXTsKICAgICAgfSBlbHNlIGlmICh1c2VyQWdlbnQpIHsKICAgICAgICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvRWRnZVwvKFxkKykvKTsKICAgICAgICBpZiAoIW1hdGNoIHx8IG1hdGNoWzFdID49IDc0KSB7CiAgICAgICAgICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXC8oXGQrKS8pOwogICAgICAgICAgaWYgKG1hdGNoKQogICAgICAgICAgICB2ZXJzaW9uID0gbWF0Y2hbMV07CiAgICAgICAgfQogICAgICB9CiAgICAgIG1vZHVsZS5leHBvcnRzID0gdmVyc2lvbiAmJiArdmVyc2lvbjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbC5qcwogIHZhciByZXF1aXJlX25hdGl2ZV9zeW1ib2wgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9uYXRpdmUtc3ltYm9sLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgVjhfVkVSU0lPTiA9IHJlcXVpcmVfZW5naW5lX3Y4X3ZlcnNpb24oKTsKICAgICAgdmFyIGZhaWxzID0gcmVxdWlyZV9mYWlscygpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9ICEhT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJiAhZmFpbHMoZnVuY3Rpb24oKSB7CiAgICAgICAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpOwogICAgICAgIHJldHVybiAhU3RyaW5nKHN5bWJvbCkgfHwgIShPYmplY3Qoc3ltYm9sKSBpbnN0YW5jZW9mIFN5bWJvbCkgfHwgIVN5bWJvbC5zaGFtICYmIFY4X1ZFUlNJT04gJiYgVjhfVkVSU0lPTiA8IDQxOwogICAgICB9KTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQuanMKICB2YXIgcmVxdWlyZV91c2Vfc3ltYm9sX2FzX3VpZCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmVfbmF0aXZlX3N5bWJvbCgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IE5BVElWRV9TWU1CT0wgJiYgIVN5bWJvbC5zaGFtICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gInN5bWJvbCI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2lzLXN5bWJvbC5qcwogIHZhciByZXF1aXJlX2lzX3N5bWJvbCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2lzLXN5bWJvbC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlX2lzX2NhbGxhYmxlKCk7CiAgICAgIHZhciBnZXRCdWlsdEluID0gcmVxdWlyZV9nZXRfYnVpbHRfaW4oKTsKICAgICAgdmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gcmVxdWlyZV91c2Vfc3ltYm9sX2FzX3VpZCgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IFVTRV9TWU1CT0xfQVNfVUlEID8gZnVuY3Rpb24oaXQpIHsKICAgICAgICByZXR1cm4gdHlwZW9mIGl0ID09ICJzeW1ib2wiOwogICAgICB9IDogZnVuY3Rpb24oaXQpIHsKICAgICAgICB2YXIgJFN5bWJvbCA9IGdldEJ1aWx0SW4oIlN5bWJvbCIpOwogICAgICAgIHJldHVybiBpc0NhbGxhYmxlKCRTeW1ib2wpICYmIE9iamVjdChpdCkgaW5zdGFuY2VvZiAkU3ltYm9sOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy90cnktdG8tc3RyaW5nLmpzCiAgdmFyIHJlcXVpcmVfdHJ5X3RvX3N0cmluZyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3RyeS10by1zdHJpbmcuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJndW1lbnQpIHsKICAgICAgICB0cnkgewogICAgICAgICAgcmV0dXJuIFN0cmluZyhhcmd1bWVudCk7CiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgIHJldHVybiAiT2JqZWN0IjsKICAgICAgICB9CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2EtY2FsbGFibGUuanMKICB2YXIgcmVxdWlyZV9hX2NhbGxhYmxlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvYS1jYWxsYWJsZS5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlX2lzX2NhbGxhYmxlKCk7CiAgICAgIHZhciB0cnlUb1N0cmluZyA9IHJlcXVpcmVfdHJ5X3RvX3N0cmluZygpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFyZ3VtZW50KSB7CiAgICAgICAgaWYgKGlzQ2FsbGFibGUoYXJndW1lbnQpKQogICAgICAgICAgcmV0dXJuIGFyZ3VtZW50OwogICAgICAgIHRocm93IFR5cGVFcnJvcih0cnlUb1N0cmluZyhhcmd1bWVudCkgKyAiIGlzIG5vdCBhIGZ1bmN0aW9uIik7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2dldC1tZXRob2QuanMKICB2YXIgcmVxdWlyZV9nZXRfbWV0aG9kID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZ2V0LW1ldGhvZC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGFDYWxsYWJsZSA9IHJlcXVpcmVfYV9jYWxsYWJsZSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFYsIFApIHsKICAgICAgICB2YXIgZnVuYyA9IFZbUF07CiAgICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IHZvaWQgMCA6IGFDYWxsYWJsZShmdW5jKTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvb3JkaW5hcnktdG8tcHJpbWl0aXZlLmpzCiAgdmFyIHJlcXVpcmVfb3JkaW5hcnlfdG9fcHJpbWl0aXZlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvb3JkaW5hcnktdG8tcHJpbWl0aXZlLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmVfaXNfY2FsbGFibGUoKTsKICAgICAgdmFyIGlzT2JqZWN0ID0gcmVxdWlyZV9pc19vYmplY3QoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpbnB1dCwgcHJlZikgewogICAgICAgIHZhciBmbiwgdmFsOwogICAgICAgIGlmIChwcmVmID09PSAic3RyaW5nIiAmJiBpc0NhbGxhYmxlKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGlucHV0KSkpCiAgICAgICAgICByZXR1cm4gdmFsOwogICAgICAgIGlmIChpc0NhbGxhYmxlKGZuID0gaW5wdXQudmFsdWVPZikgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkKICAgICAgICAgIHJldHVybiB2YWw7CiAgICAgICAgaWYgKHByZWYgIT09ICJzdHJpbmciICYmIGlzQ2FsbGFibGUoZm4gPSBpbnB1dC50b1N0cmluZykgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkKICAgICAgICAgIHJldHVybiB2YWw7CiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWUiKTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvaXMtcHVyZS5qcwogIHZhciByZXF1aXJlX2lzX3B1cmUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pcy1wdXJlLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHRydWU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3NldC1nbG9iYWwuanMKICB2YXIgcmVxdWlyZV9zZXRfZ2xvYmFsID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvc2V0LWdsb2JhbC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGdsb2JhbDIgPSByZXF1aXJlX2dsb2JhbCgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHsKICAgICAgICB0cnkgewogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbDIsIGtleSwgeyB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsKICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgZ2xvYmFsMltrZXldID0gdmFsdWU7CiAgICAgICAgfQogICAgICAgIHJldHVybiB2YWx1ZTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlLmpzCiAgdmFyIHJlcXVpcmVfc2hhcmVkX3N0b3JlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgZ2xvYmFsMiA9IHJlcXVpcmVfZ2xvYmFsKCk7CiAgICAgIHZhciBzZXRHbG9iYWwgPSByZXF1aXJlX3NldF9nbG9iYWwoKTsKICAgICAgdmFyIFNIQVJFRCA9ICJfX2NvcmUtanNfc2hhcmVkX18iOwogICAgICB2YXIgc3RvcmUgPSBnbG9iYWwyW1NIQVJFRF0gfHwgc2V0R2xvYmFsKFNIQVJFRCwge30pOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHN0b3JlOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9zaGFyZWQuanMKICB2YXIgcmVxdWlyZV9zaGFyZWQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9zaGFyZWQuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBJU19QVVJFID0gcmVxdWlyZV9pc19wdXJlKCk7CiAgICAgIHZhciBzdG9yZSA9IHJlcXVpcmVfc2hhcmVkX3N0b3JlKCk7CiAgICAgIChtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHsKICAgICAgICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB2b2lkIDAgPyB2YWx1ZSA6IHt9KTsKICAgICAgfSkoInZlcnNpb25zIiwgW10pLnB1c2goewogICAgICAgIHZlcnNpb246ICIzLjE4LjAiLAogICAgICAgIG1vZGU6IElTX1BVUkUgPyAicHVyZSIgOiAiZ2xvYmFsIiwKICAgICAgICBjb3B5cmlnaHQ6ICJceEE5IDIwMjEgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSkiCiAgICAgIH0pOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy90by1vYmplY3QuanMKICB2YXIgcmVxdWlyZV90b19vYmplY3QgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy90by1vYmplY3QuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZV9yZXF1aXJlX29iamVjdF9jb2VyY2libGUoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcmd1bWVudCkgewogICAgICAgIHJldHVybiBPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudCkpOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9oYXMuanMKICB2YXIgcmVxdWlyZV9oYXMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9oYXMuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciB0b09iamVjdCA9IHJlcXVpcmVfdG9fb2JqZWN0KCk7CiAgICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5OwogICAgICBtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5oYXNPd24gfHwgZnVuY3Rpb24gaGFzT3duKGl0LCBrZXkpIHsKICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbCh0b09iamVjdChpdCksIGtleSk7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3VpZC5qcwogIHZhciByZXF1aXJlX3VpZCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3VpZC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGlkID0gMDsKICAgICAgdmFyIHBvc3RmaXggPSBNYXRoLnJhbmRvbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSkgewogICAgICAgIHJldHVybiAiU3ltYm9sKCIgKyBTdHJpbmcoa2V5ID09PSB2b2lkIDAgPyAiIiA6IGtleSkgKyAiKV8iICsgKCsraWQgKyBwb3N0Zml4KS50b1N0cmluZygzNik7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzCiAgdmFyIHJlcXVpcmVfd2VsbF9rbm93bl9zeW1ib2wgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGdsb2JhbDIgPSByZXF1aXJlX2dsb2JhbCgpOwogICAgICB2YXIgc2hhcmVkID0gcmVxdWlyZV9zaGFyZWQoKTsKICAgICAgdmFyIGhhcyA9IHJlcXVpcmVfaGFzKCk7CiAgICAgIHZhciB1aWQgPSByZXF1aXJlX3VpZCgpOwogICAgICB2YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmVfbmF0aXZlX3N5bWJvbCgpOwogICAgICB2YXIgVVNFX1NZTUJPTF9BU19VSUQgPSByZXF1aXJlX3VzZV9zeW1ib2xfYXNfdWlkKCk7CiAgICAgIHZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQoIndrcyIpOwogICAgICB2YXIgU3ltYm9sMiA9IGdsb2JhbDIuU3ltYm9sOwogICAgICB2YXIgY3JlYXRlV2VsbEtub3duU3ltYm9sID0gVVNFX1NZTUJPTF9BU19VSUQgPyBTeW1ib2wyIDogU3ltYm9sMiAmJiBTeW1ib2wyLndpdGhvdXRTZXR0ZXIgfHwgdWlkOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpIHsKICAgICAgICBpZiAoIWhhcyhXZWxsS25vd25TeW1ib2xzU3RvcmUsIG5hbWUpIHx8ICEoTkFUSVZFX1NZTUJPTCB8fCB0eXBlb2YgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID09ICJzdHJpbmciKSkgewogICAgICAgICAgaWYgKE5BVElWRV9TWU1CT0wgJiYgaGFzKFN5bWJvbDIsIG5hbWUpKSB7CiAgICAgICAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IFN5bWJvbDJbbmFtZV07CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBjcmVhdGVXZWxsS25vd25TeW1ib2woIlN5bWJvbC4iICsgbmFtZSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3RvLXByaW1pdGl2ZS5qcwogIHZhciByZXF1aXJlX3RvX3ByaW1pdGl2ZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3RvLXByaW1pdGl2ZS5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGlzT2JqZWN0ID0gcmVxdWlyZV9pc19vYmplY3QoKTsKICAgICAgdmFyIGlzU3ltYm9sID0gcmVxdWlyZV9pc19zeW1ib2woKTsKICAgICAgdmFyIGdldE1ldGhvZCA9IHJlcXVpcmVfZ2V0X21ldGhvZCgpOwogICAgICB2YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSA9IHJlcXVpcmVfb3JkaW5hcnlfdG9fcHJpbWl0aXZlKCk7CiAgICAgIHZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlX3dlbGxfa25vd25fc3ltYm9sKCk7CiAgICAgIHZhciBUT19QUklNSVRJVkUgPSB3ZWxsS25vd25TeW1ib2woInRvUHJpbWl0aXZlIik7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW5wdXQsIHByZWYpIHsKICAgICAgICBpZiAoIWlzT2JqZWN0KGlucHV0KSB8fCBpc1N5bWJvbChpbnB1dCkpCiAgICAgICAgICByZXR1cm4gaW5wdXQ7CiAgICAgICAgdmFyIGV4b3RpY1RvUHJpbSA9IGdldE1ldGhvZChpbnB1dCwgVE9fUFJJTUlUSVZFKTsKICAgICAgICB2YXIgcmVzdWx0OwogICAgICAgIGlmIChleG90aWNUb1ByaW0pIHsKICAgICAgICAgIGlmIChwcmVmID09PSB2b2lkIDApCiAgICAgICAgICAgIHByZWYgPSAiZGVmYXVsdCI7CiAgICAgICAgICByZXN1bHQgPSBleG90aWNUb1ByaW0uY2FsbChpbnB1dCwgcHJlZik7CiAgICAgICAgICBpZiAoIWlzT2JqZWN0KHJlc3VsdCkgfHwgaXNTeW1ib2wocmVzdWx0KSkKICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICAgIHRocm93IFR5cGVFcnJvcigiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlIik7CiAgICAgICAgfQogICAgICAgIGlmIChwcmVmID09PSB2b2lkIDApCiAgICAgICAgICBwcmVmID0gIm51bWJlciI7CiAgICAgICAgcmV0dXJuIG9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIHByZWYpOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXkuanMKICB2YXIgcmVxdWlyZV90b19wcm9wZXJ0eV9rZXkgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXkuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmVfdG9fcHJpbWl0aXZlKCk7CiAgICAgIHZhciBpc1N5bWJvbCA9IHJlcXVpcmVfaXNfc3ltYm9sKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJndW1lbnQpIHsKICAgICAgICB2YXIga2V5ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsICJzdHJpbmciKTsKICAgICAgICByZXR1cm4gaXNTeW1ib2woa2V5KSA/IGtleSA6IFN0cmluZyhrZXkpOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudC5qcwogIHZhciByZXF1aXJlX2RvY3VtZW50X2NyZWF0ZV9lbGVtZW50ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBnbG9iYWwyID0gcmVxdWlyZV9nbG9iYWwoKTsKICAgICAgdmFyIGlzT2JqZWN0ID0gcmVxdWlyZV9pc19vYmplY3QoKTsKICAgICAgdmFyIGRvY3VtZW50MiA9IGdsb2JhbDIuZG9jdW1lbnQ7CiAgICAgIHZhciBFWElTVFMgPSBpc09iamVjdChkb2N1bWVudDIpICYmIGlzT2JqZWN0KGRvY3VtZW50Mi5jcmVhdGVFbGVtZW50KTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCkgewogICAgICAgIHJldHVybiBFWElTVFMgPyBkb2N1bWVudDIuY3JlYXRlRWxlbWVudChpdCkgOiB7fTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUuanMKICB2YXIgcmVxdWlyZV9pZThfZG9tX2RlZmluZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlX2Rlc2NyaXB0b3JzKCk7CiAgICAgIHZhciBmYWlscyA9IHJlcXVpcmVfZmFpbHMoKTsKICAgICAgdmFyIGNyZWF0ZUVsZW1lbnQgPSByZXF1aXJlX2RvY3VtZW50X2NyZWF0ZV9lbGVtZW50KCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gIURFU0NSSVBUT1JTICYmICFmYWlscyhmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGNyZWF0ZUVsZW1lbnQoImRpdiIpLCAiYSIsIHsKICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHJldHVybiA3OwogICAgICAgICAgfQogICAgICAgIH0pLmEgIT0gNzsKICAgICAgfSk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMKICB2YXIgcmVxdWlyZV9vYmplY3RfZ2V0X293bl9wcm9wZXJ0eV9kZXNjcmlwdG9yID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBERVNDUklQVE9SUyA9IHJlcXVpcmVfZGVzY3JpcHRvcnMoKTsKICAgICAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gcmVxdWlyZV9vYmplY3RfcHJvcGVydHlfaXNfZW51bWVyYWJsZSgpOwogICAgICB2YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZV9jcmVhdGVfcHJvcGVydHlfZGVzY3JpcHRvcigpOwogICAgICB2YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZV90b19pbmRleGVkX29iamVjdCgpOwogICAgICB2YXIgdG9Qcm9wZXJ0eUtleSA9IHJlcXVpcmVfdG9fcHJvcGVydHlfa2V5KCk7CiAgICAgIHZhciBoYXMgPSByZXF1aXJlX2hhcygpOwogICAgICB2YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlX2llOF9kb21fZGVmaW5lKCk7CiAgICAgIHZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsKICAgICAgZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHsKICAgICAgICBPID0gdG9JbmRleGVkT2JqZWN0KE8pOwogICAgICAgIFAgPSB0b1Byb3BlcnR5S2V5KFApOwogICAgICAgIGlmIChJRThfRE9NX0RFRklORSkKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApOwogICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgIH0KICAgICAgICBpZiAoaGFzKE8sIFApKQogICAgICAgICAgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcighcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZi5jYWxsKE8sIFApLCBPW1BdKTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvaXMtZm9yY2VkLmpzCiAgdmFyIHJlcXVpcmVfaXNfZm9yY2VkID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvaXMtZm9yY2VkLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgZmFpbHMgPSByZXF1aXJlX2ZhaWxzKCk7CiAgICAgIHZhciBpc0NhbGxhYmxlID0gcmVxdWlyZV9pc19jYWxsYWJsZSgpOwogICAgICB2YXIgcmVwbGFjZW1lbnQgPSAvI3xcLnByb3RvdHlwZVwuLzsKICAgICAgdmFyIGlzRm9yY2VkID0gZnVuY3Rpb24oZmVhdHVyZSwgZGV0ZWN0aW9uKSB7CiAgICAgICAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldOwogICAgICAgIHJldHVybiB2YWx1ZSA9PSBQT0xZRklMTCA/IHRydWUgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZSA6IGlzQ2FsbGFibGUoZGV0ZWN0aW9uKSA/IGZhaWxzKGRldGVjdGlvbikgOiAhIWRldGVjdGlvbjsKICAgICAgfTsKICAgICAgdmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHN0cmluZykgewogICAgICAgIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlcGxhY2VtZW50LCAiLiIpLnRvTG93ZXJDYXNlKCk7CiAgICAgIH07CiAgICAgIHZhciBkYXRhID0gaXNGb3JjZWQuZGF0YSA9IHt9OwogICAgICB2YXIgTkFUSVZFID0gaXNGb3JjZWQuTkFUSVZFID0gIk4iOwogICAgICB2YXIgUE9MWUZJTEwgPSBpc0ZvcmNlZC5QT0xZRklMTCA9ICJQIjsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBpc0ZvcmNlZDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0LmpzCiAgdmFyIHJlcXVpcmVfZnVuY3Rpb25fYmluZF9jb250ZXh0ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgYUNhbGxhYmxlID0gcmVxdWlyZV9hX2NhbGxhYmxlKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCkgewogICAgICAgIGFDYWxsYWJsZShmbik7CiAgICAgICAgaWYgKHRoYXQgPT09IHZvaWQgMCkKICAgICAgICAgIHJldHVybiBmbjsKICAgICAgICBzd2l0Y2ggKGxlbmd0aCkgewogICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCk7CiAgICAgICAgICAgIH07CiAgICAgICAgICBjYXNlIDE6CiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihhKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7CiAgICAgICAgICAgIH07CiAgICAgICAgICBjYXNlIDI6CiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihhLCBiKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7CiAgICAgICAgICAgIH07CiAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihhLCBiLCBjKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7CiAgICAgICAgICAgIH07CiAgICAgICAgfQogICAgICAgIHJldHVybiBmdW5jdGlvbigpIHsKICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpOwogICAgICAgIH07CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2FuLW9iamVjdC5qcwogIHZhciByZXF1aXJlX2FuX29iamVjdCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2FuLW9iamVjdC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGlzT2JqZWN0ID0gcmVxdWlyZV9pc19vYmplY3QoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcmd1bWVudCkgewogICAgICAgIGlmIChpc09iamVjdChhcmd1bWVudCkpCiAgICAgICAgICByZXR1cm4gYXJndW1lbnQ7CiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFN0cmluZyhhcmd1bWVudCkgKyAiIGlzIG5vdCBhbiBvYmplY3QiKTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qcwogIHZhciByZXF1aXJlX29iamVjdF9kZWZpbmVfcHJvcGVydHkgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZV9kZXNjcmlwdG9ycygpOwogICAgICB2YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlX2llOF9kb21fZGVmaW5lKCk7CiAgICAgIHZhciBhbk9iamVjdCA9IHJlcXVpcmVfYW5fb2JqZWN0KCk7CiAgICAgIHZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZV90b19wcm9wZXJ0eV9rZXkoKTsKICAgICAgdmFyICRkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTsKICAgICAgZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyAkZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7CiAgICAgICAgYW5PYmplY3QoTyk7CiAgICAgICAgUCA9IHRvUHJvcGVydHlLZXkoUCk7CiAgICAgICAgYW5PYmplY3QoQXR0cmlidXRlcyk7CiAgICAgICAgaWYgKElFOF9ET01fREVGSU5FKQogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTsKICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgICB9CiAgICAgICAgaWYgKCJnZXQiIGluIEF0dHJpYnV0ZXMgfHwgInNldCIgaW4gQXR0cmlidXRlcykKICAgICAgICAgIHRocm93IFR5cGVFcnJvcigiQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQiKTsKICAgICAgICBpZiAoInZhbHVlIiBpbiBBdHRyaWJ1dGVzKQogICAgICAgICAgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7CiAgICAgICAgcmV0dXJuIE87CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qcwogIHZhciByZXF1aXJlX2NyZWF0ZV9ub25fZW51bWVyYWJsZV9wcm9wZXJ0eSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZV9kZXNjcmlwdG9ycygpOwogICAgICB2YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlX29iamVjdF9kZWZpbmVfcHJvcGVydHkoKTsKICAgICAgdmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmVfY3JlYXRlX3Byb3BlcnR5X2Rlc2NyaXB0b3IoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSkgewogICAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKG9iamVjdCwga2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgdmFsdWUpKTsKICAgICAgfSA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSkgewogICAgICAgIG9iamVjdFtrZXldID0gdmFsdWU7CiAgICAgICAgcmV0dXJuIG9iamVjdDsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZXhwb3J0LmpzCiAgdmFyIHJlcXVpcmVfZXhwb3J0ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZXhwb3J0LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBnbG9iYWwyID0gcmVxdWlyZV9nbG9iYWwoKTsKICAgICAgdmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlX2lzX2NhbGxhYmxlKCk7CiAgICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlX29iamVjdF9nZXRfb3duX3Byb3BlcnR5X2Rlc2NyaXB0b3IoKS5mOwogICAgICB2YXIgaXNGb3JjZWQgPSByZXF1aXJlX2lzX2ZvcmNlZCgpOwogICAgICB2YXIgcGF0aCA9IHJlcXVpcmVfcGF0aCgpOwogICAgICB2YXIgYmluZCA9IHJlcXVpcmVfZnVuY3Rpb25fYmluZF9jb250ZXh0KCk7CiAgICAgIHZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlX2NyZWF0ZV9ub25fZW51bWVyYWJsZV9wcm9wZXJ0eSgpOwogICAgICB2YXIgaGFzID0gcmVxdWlyZV9oYXMoKTsKICAgICAgdmFyIHdyYXBDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKE5hdGl2ZUNvbnN0cnVjdG9yKSB7CiAgICAgICAgdmFyIFdyYXBwZXIgPSBmdW5jdGlvbihhLCBiLCBjKSB7CiAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIE5hdGl2ZUNvbnN0cnVjdG9yKSB7CiAgICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkgewogICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTmF0aXZlQ29uc3RydWN0b3IoKTsKICAgICAgICAgICAgICBjYXNlIDE6CiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKGEpOwogICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTmF0aXZlQ29uc3RydWN0b3IoYSwgYik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVDb25zdHJ1Y3RvcihhLCBiLCBjKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBOYXRpdmVDb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgIH07CiAgICAgICAgV3JhcHBlci5wcm90b3R5cGUgPSBOYXRpdmVDb25zdHJ1Y3Rvci5wcm90b3R5cGU7CiAgICAgICAgcmV0dXJuIFdyYXBwZXI7CiAgICAgIH07CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0aW9ucywgc291cmNlKSB7CiAgICAgICAgdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0OwogICAgICAgIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDsKICAgICAgICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0OwogICAgICAgIHZhciBQUk9UTyA9IG9wdGlvbnMucHJvdG87CiAgICAgICAgdmFyIG5hdGl2ZVNvdXJjZSA9IEdMT0JBTCA/IGdsb2JhbDIgOiBTVEFUSUMgPyBnbG9iYWwyW1RBUkdFVF0gOiAoZ2xvYmFsMltUQVJHRVRdIHx8IHt9KS5wcm90b3R5cGU7CiAgICAgICAgdmFyIHRhcmdldCA9IEdMT0JBTCA/IHBhdGggOiBwYXRoW1RBUkdFVF0gfHwgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHBhdGgsIFRBUkdFVCwge30pW1RBUkdFVF07CiAgICAgICAgdmFyIHRhcmdldFByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7CiAgICAgICAgdmFyIEZPUkNFRCwgVVNFX05BVElWRSwgVklSVFVBTF9QUk9UT1RZUEU7CiAgICAgICAgdmFyIGtleSwgc291cmNlUHJvcGVydHksIHRhcmdldFByb3BlcnR5LCBuYXRpdmVQcm9wZXJ0eSwgcmVzdWx0UHJvcGVydHksIGRlc2NyaXB0b3I7CiAgICAgICAgZm9yIChrZXkgaW4gc291cmNlKSB7CiAgICAgICAgICBGT1JDRUQgPSBpc0ZvcmNlZChHTE9CQUwgPyBrZXkgOiBUQVJHRVQgKyAoU1RBVElDID8gIi4iIDogIiMiKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpOwogICAgICAgICAgVVNFX05BVElWRSA9ICFGT1JDRUQgJiYgbmF0aXZlU291cmNlICYmIGhhcyhuYXRpdmVTb3VyY2UsIGtleSk7CiAgICAgICAgICB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldOwogICAgICAgICAgaWYgKFVTRV9OQVRJVkUpCiAgICAgICAgICAgIGlmIChvcHRpb25zLm5vVGFyZ2V0R2V0KSB7CiAgICAgICAgICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihuYXRpdmVTb3VyY2UsIGtleSk7CiAgICAgICAgICAgICAgbmF0aXZlUHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7CiAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgIG5hdGl2ZVByb3BlcnR5ID0gbmF0aXZlU291cmNlW2tleV07CiAgICAgICAgICBzb3VyY2VQcm9wZXJ0eSA9IFVTRV9OQVRJVkUgJiYgbmF0aXZlUHJvcGVydHkgPyBuYXRpdmVQcm9wZXJ0eSA6IHNvdXJjZVtrZXldOwogICAgICAgICAgaWYgKFVTRV9OQVRJVkUgJiYgdHlwZW9mIHRhcmdldFByb3BlcnR5ID09PSB0eXBlb2Ygc291cmNlUHJvcGVydHkpCiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgaWYgKG9wdGlvbnMuYmluZCAmJiBVU0VfTkFUSVZFKQogICAgICAgICAgICByZXN1bHRQcm9wZXJ0eSA9IGJpbmQoc291cmNlUHJvcGVydHksIGdsb2JhbDIpOwogICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy53cmFwICYmIFVTRV9OQVRJVkUpCiAgICAgICAgICAgIHJlc3VsdFByb3BlcnR5ID0gd3JhcENvbnN0cnVjdG9yKHNvdXJjZVByb3BlcnR5KTsKICAgICAgICAgIGVsc2UgaWYgKFBST1RPICYmIGlzQ2FsbGFibGUoc291cmNlUHJvcGVydHkpKQogICAgICAgICAgICByZXN1bHRQcm9wZXJ0eSA9IGJpbmQoRnVuY3Rpb24uY2FsbCwgc291cmNlUHJvcGVydHkpOwogICAgICAgICAgZWxzZQogICAgICAgICAgICByZXN1bHRQcm9wZXJ0eSA9IHNvdXJjZVByb3BlcnR5OwogICAgICAgICAgaWYgKG9wdGlvbnMuc2hhbSB8fCBzb3VyY2VQcm9wZXJ0eSAmJiBzb3VyY2VQcm9wZXJ0eS5zaGFtIHx8IHRhcmdldFByb3BlcnR5ICYmIHRhcmdldFByb3BlcnR5LnNoYW0pIHsKICAgICAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHJlc3VsdFByb3BlcnR5LCAic2hhbSIsIHRydWUpOwogICAgICAgICAgfQogICAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHRhcmdldCwga2V5LCByZXN1bHRQcm9wZXJ0eSk7CiAgICAgICAgICBpZiAoUFJPVE8pIHsKICAgICAgICAgICAgVklSVFVBTF9QUk9UT1RZUEUgPSBUQVJHRVQgKyAiUHJvdG90eXBlIjsKICAgICAgICAgICAgaWYgKCFoYXMocGF0aCwgVklSVFVBTF9QUk9UT1RZUEUpKSB7CiAgICAgICAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHBhdGgsIFZJUlRVQUxfUFJPVE9UWVBFLCB7fSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHBhdGhbVklSVFVBTF9QUk9UT1RZUEVdLCBrZXksIHNvdXJjZVByb3BlcnR5KTsKICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVhbCAmJiB0YXJnZXRQcm90b3R5cGUgJiYgIXRhcmdldFByb3RvdHlwZVtrZXldKSB7CiAgICAgICAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHRhcmdldFByb3RvdHlwZSwga2V5LCBzb3VyY2VQcm9wZXJ0eSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzCiAgdmFyIHJlcXVpcmVfZXNfb2JqZWN0X2RlZmluZV9wcm9wZXJ0eSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgJCA9IHJlcXVpcmVfZXhwb3J0KCk7CiAgICAgIHZhciBERVNDUklQVE9SUyA9IHJlcXVpcmVfZGVzY3JpcHRvcnMoKTsKICAgICAgdmFyIG9iamVjdERlZmluZVByb3BlcnR5TW9kaWxlID0gcmVxdWlyZV9vYmplY3RfZGVmaW5lX3Byb3BlcnR5KCk7CiAgICAgICQoeyB0YXJnZXQ6ICJPYmplY3QiLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFERVNDUklQVE9SUywgc2hhbTogIURFU0NSSVBUT1JTIH0sIHsKICAgICAgICBkZWZpbmVQcm9wZXJ0eTogb2JqZWN0RGVmaW5lUHJvcGVydHlNb2RpbGUuZgogICAgICB9KTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzCiAgdmFyIHJlcXVpcmVfZGVmaW5lX3Byb3BlcnR5ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICByZXF1aXJlX2VzX29iamVjdF9kZWZpbmVfcHJvcGVydHkoKTsKICAgICAgdmFyIHBhdGggPSByZXF1aXJlX3BhdGgoKTsKICAgICAgdmFyIE9iamVjdDIgPSBwYXRoLk9iamVjdDsKICAgICAgdmFyIGRlZmluZVByb3BlcnR5ID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eTIoaXQsIGtleSwgZGVzYykgewogICAgICAgIHJldHVybiBPYmplY3QyLmRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpOwogICAgICB9OwogICAgICBpZiAoT2JqZWN0Mi5kZWZpbmVQcm9wZXJ0eS5zaGFtKQogICAgICAgIGRlZmluZVByb3BlcnR5LnNoYW0gPSB0cnVlOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzCiAgdmFyIHJlcXVpcmVfZGVmaW5lX3Byb3BlcnR5MiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBwYXJlbnQgPSByZXF1aXJlX2RlZmluZV9wcm9wZXJ0eSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcmVudDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcwogIHZhciByZXF1aXJlX2RlZmluZV9wcm9wZXJ0eTMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVfZGVmaW5lX3Byb3BlcnR5MigpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXMuanMKICB2YXIgcmVxdWlyZV9hZGRfdG9fdW5zY29wYWJsZXMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXMuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qcwogIHZhciByZXF1aXJlX2l0ZXJhdG9ycyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSB7fTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UuanMKICB2YXIgcmVxdWlyZV9pbnNwZWN0X3NvdXJjZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmVfaXNfY2FsbGFibGUoKTsKICAgICAgdmFyIHN0b3JlID0gcmVxdWlyZV9zaGFyZWRfc3RvcmUoKTsKICAgICAgdmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSBGdW5jdGlvbi50b1N0cmluZzsKICAgICAgaWYgKCFpc0NhbGxhYmxlKHN0b3JlLmluc3BlY3RTb3VyY2UpKSB7CiAgICAgICAgc3RvcmUuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uKGl0KSB7CiAgICAgICAgICByZXR1cm4gZnVuY3Rpb25Ub1N0cmluZy5jYWxsKGl0KTsKICAgICAgICB9OwogICAgICB9CiAgICAgIG1vZHVsZS5leHBvcnRzID0gc3RvcmUuaW5zcGVjdFNvdXJjZTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvbmF0aXZlLXdlYWstbWFwLmpzCiAgdmFyIHJlcXVpcmVfbmF0aXZlX3dlYWtfbWFwID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvbmF0aXZlLXdlYWstbWFwLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgZ2xvYmFsMiA9IHJlcXVpcmVfZ2xvYmFsKCk7CiAgICAgIHZhciBpc0NhbGxhYmxlID0gcmVxdWlyZV9pc19jYWxsYWJsZSgpOwogICAgICB2YXIgaW5zcGVjdFNvdXJjZSA9IHJlcXVpcmVfaW5zcGVjdF9zb3VyY2UoKTsKICAgICAgdmFyIFdlYWtNYXAgPSBnbG9iYWwyLldlYWtNYXA7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gaXNDYWxsYWJsZShXZWFrTWFwKSAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoaW5zcGVjdFNvdXJjZShXZWFrTWFwKSk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3NoYXJlZC1rZXkuanMKICB2YXIgcmVxdWlyZV9zaGFyZWRfa2V5ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvc2hhcmVkLWtleS5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHNoYXJlZCA9IHJlcXVpcmVfc2hhcmVkKCk7CiAgICAgIHZhciB1aWQgPSByZXF1aXJlX3VpZCgpOwogICAgICB2YXIga2V5cyA9IHNoYXJlZCgia2V5cyIpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSkgewogICAgICAgIHJldHVybiBrZXlzW2tleV0gfHwgKGtleXNba2V5XSA9IHVpZChrZXkpKTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvaGlkZGVuLWtleXMuanMKICB2YXIgcmVxdWlyZV9oaWRkZW5fa2V5cyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHt9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qcwogIHZhciByZXF1aXJlX2ludGVybmFsX3N0YXRlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBOQVRJVkVfV0VBS19NQVAgPSByZXF1aXJlX25hdGl2ZV93ZWFrX21hcCgpOwogICAgICB2YXIgZ2xvYmFsMiA9IHJlcXVpcmVfZ2xvYmFsKCk7CiAgICAgIHZhciBpc09iamVjdCA9IHJlcXVpcmVfaXNfb2JqZWN0KCk7CiAgICAgIHZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlX2NyZWF0ZV9ub25fZW51bWVyYWJsZV9wcm9wZXJ0eSgpOwogICAgICB2YXIgb2JqZWN0SGFzID0gcmVxdWlyZV9oYXMoKTsKICAgICAgdmFyIHNoYXJlZCA9IHJlcXVpcmVfc2hhcmVkX3N0b3JlKCk7CiAgICAgIHZhciBzaGFyZWRLZXkgPSByZXF1aXJlX3NoYXJlZF9rZXkoKTsKICAgICAgdmFyIGhpZGRlbktleXMgPSByZXF1aXJlX2hpZGRlbl9rZXlzKCk7CiAgICAgIHZhciBPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCA9ICJPYmplY3QgYWxyZWFkeSBpbml0aWFsaXplZCI7CiAgICAgIHZhciBXZWFrTWFwID0gZ2xvYmFsMi5XZWFrTWFwOwogICAgICB2YXIgc2V0OwogICAgICB2YXIgZ2V0OwogICAgICB2YXIgaGFzOwogICAgICB2YXIgZW5mb3JjZSA9IGZ1bmN0aW9uKGl0KSB7CiAgICAgICAgcmV0dXJuIGhhcyhpdCkgPyBnZXQoaXQpIDogc2V0KGl0LCB7fSk7CiAgICAgIH07CiAgICAgIHZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbihUWVBFKSB7CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGl0KSB7CiAgICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgICBpZiAoIWlzT2JqZWN0KGl0KSB8fCAoc3RhdGUgPSBnZXQoaXQpKS50eXBlICE9PSBUWVBFKSB7CiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcigiSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAiICsgVFlQRSArICIgcmVxdWlyZWQiKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBzdGF0ZTsKICAgICAgICB9OwogICAgICB9OwogICAgICBpZiAoTkFUSVZFX1dFQUtfTUFQIHx8IHNoYXJlZC5zdGF0ZSkgewogICAgICAgIHN0b3JlID0gc2hhcmVkLnN0YXRlIHx8IChzaGFyZWQuc3RhdGUgPSBuZXcgV2Vha01hcCgpKTsKICAgICAgICB3bWdldCA9IHN0b3JlLmdldDsKICAgICAgICB3bWhhcyA9IHN0b3JlLmhhczsKICAgICAgICB3bXNldCA9IHN0b3JlLnNldDsKICAgICAgICBzZXQgPSBmdW5jdGlvbihpdCwgbWV0YWRhdGEpIHsKICAgICAgICAgIGlmICh3bWhhcy5jYWxsKHN0b3JlLCBpdCkpCiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQpOwogICAgICAgICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7CiAgICAgICAgICB3bXNldC5jYWxsKHN0b3JlLCBpdCwgbWV0YWRhdGEpOwogICAgICAgICAgcmV0dXJuIG1ldGFkYXRhOwogICAgICAgIH07CiAgICAgICAgZ2V0ID0gZnVuY3Rpb24oaXQpIHsKICAgICAgICAgIHJldHVybiB3bWdldC5jYWxsKHN0b3JlLCBpdCkgfHwge307CiAgICAgICAgfTsKICAgICAgICBoYXMgPSBmdW5jdGlvbihpdCkgewogICAgICAgICAgcmV0dXJuIHdtaGFzLmNhbGwoc3RvcmUsIGl0KTsKICAgICAgICB9OwogICAgICB9IGVsc2UgewogICAgICAgIFNUQVRFID0gc2hhcmVkS2V5KCJzdGF0ZSIpOwogICAgICAgIGhpZGRlbktleXNbU1RBVEVdID0gdHJ1ZTsKICAgICAgICBzZXQgPSBmdW5jdGlvbihpdCwgbWV0YWRhdGEpIHsKICAgICAgICAgIGlmIChvYmplY3RIYXMoaXQsIFNUQVRFKSkKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7CiAgICAgICAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDsKICAgICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShpdCwgU1RBVEUsIG1ldGFkYXRhKTsKICAgICAgICAgIHJldHVybiBtZXRhZGF0YTsKICAgICAgICB9OwogICAgICAgIGdldCA9IGZ1bmN0aW9uKGl0KSB7CiAgICAgICAgICByZXR1cm4gb2JqZWN0SGFzKGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTsKICAgICAgICB9OwogICAgICAgIGhhcyA9IGZ1bmN0aW9uKGl0KSB7CiAgICAgICAgICByZXR1cm4gb2JqZWN0SGFzKGl0LCBTVEFURSk7CiAgICAgICAgfTsKICAgICAgfQogICAgICB2YXIgc3RvcmU7CiAgICAgIHZhciB3bWdldDsKICAgICAgdmFyIHdtaGFzOwogICAgICB2YXIgd21zZXQ7CiAgICAgIHZhciBTVEFURTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSB7CiAgICAgICAgc2V0LAogICAgICAgIGdldCwKICAgICAgICBoYXMsCiAgICAgICAgZW5mb3JjZSwKICAgICAgICBnZXR0ZXJGb3IKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZnVuY3Rpb24tbmFtZS5qcwogIHZhciByZXF1aXJlX2Z1bmN0aW9uX25hbWUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9mdW5jdGlvbi1uYW1lLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlX2Rlc2NyaXB0b3JzKCk7CiAgICAgIHZhciBoYXMgPSByZXF1aXJlX2hhcygpOwogICAgICB2YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7CiAgICAgIHZhciBnZXREZXNjcmlwdG9yID0gREVTQ1JJUFRPUlMgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsKICAgICAgdmFyIEVYSVNUUyA9IGhhcyhGdW5jdGlvblByb3RvdHlwZSwgIm5hbWUiKTsKICAgICAgdmFyIFBST1BFUiA9IEVYSVNUUyAmJiBmdW5jdGlvbiBzb21ldGhpbmcoKSB7CiAgICAgIH0ubmFtZSA9PT0gInNvbWV0aGluZyI7CiAgICAgIHZhciBDT05GSUdVUkFCTEUgPSBFWElTVFMgJiYgKCFERVNDUklQVE9SUyB8fCBERVNDUklQVE9SUyAmJiBnZXREZXNjcmlwdG9yKEZ1bmN0aW9uUHJvdG90eXBlLCAibmFtZSIpLmNvbmZpZ3VyYWJsZSk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gewogICAgICAgIEVYSVNUUywKICAgICAgICBQUk9QRVIsCiAgICAgICAgQ09ORklHVVJBQkxFCiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3RvLWludGVnZXIuanMKICB2YXIgcmVxdWlyZV90b19pbnRlZ2VyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvdG8taW50ZWdlci5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGNlaWwgPSBNYXRoLmNlaWw7CiAgICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJndW1lbnQpIHsKICAgICAgICByZXR1cm4gaXNOYU4oYXJndW1lbnQgPSArYXJndW1lbnQpID8gMCA6IChhcmd1bWVudCA+IDAgPyBmbG9vciA6IGNlaWwpKGFyZ3VtZW50KTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvdG8tbGVuZ3RoLmpzCiAgdmFyIHJlcXVpcmVfdG9fbGVuZ3RoID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvdG8tbGVuZ3RoLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZV90b19pbnRlZ2VyKCk7CiAgICAgIHZhciBtaW4gPSBNYXRoLm1pbjsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcmd1bWVudCkgewogICAgICAgIHJldHVybiBhcmd1bWVudCA+IDAgPyBtaW4odG9JbnRlZ2VyKGFyZ3VtZW50KSwgOTAwNzE5OTI1NDc0MDk5MSkgOiAwOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleC5qcwogIHZhciByZXF1aXJlX3RvX2Fic29sdXRlX2luZGV4ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXguanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciB0b0ludGVnZXIgPSByZXF1aXJlX3RvX2ludGVnZXIoKTsKICAgICAgdmFyIG1heCA9IE1hdGgubWF4OwogICAgICB2YXIgbWluID0gTWF0aC5taW47CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCkgewogICAgICAgIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyKGluZGV4KTsKICAgICAgICByZXR1cm4gaW50ZWdlciA8IDAgPyBtYXgoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4oaW50ZWdlciwgbGVuZ3RoKTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMuanMKICB2YXIgcmVxdWlyZV9hcnJheV9pbmNsdWRlcyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZV90b19pbmRleGVkX29iamVjdCgpOwogICAgICB2YXIgdG9MZW5ndGggPSByZXF1aXJlX3RvX2xlbmd0aCgpOwogICAgICB2YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZV90b19hYnNvbHV0ZV9pbmRleCgpOwogICAgICB2YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24oSVNfSU5DTFVERVMpIHsKICAgICAgICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHsKICAgICAgICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KCR0aGlzKTsKICAgICAgICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7CiAgICAgICAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpOwogICAgICAgICAgdmFyIHZhbHVlOwogICAgICAgICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKQogICAgICAgICAgICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHsKICAgICAgICAgICAgICB2YWx1ZSA9IE9baW5kZXgrK107CiAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKQogICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgIH0KICAgICAgICAgIGVsc2UKICAgICAgICAgICAgZm9yICg7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7CiAgICAgICAgICAgICAgaWYgKChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSAmJiBPW2luZGV4XSA9PT0gZWwpCiAgICAgICAgICAgICAgICByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDsKICAgICAgICAgICAgfQogICAgICAgICAgcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTsKICAgICAgICB9OwogICAgICB9OwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHsKICAgICAgICBpbmNsdWRlczogY3JlYXRlTWV0aG9kKHRydWUpLAogICAgICAgIGluZGV4T2Y6IGNyZWF0ZU1ldGhvZChmYWxzZSkKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwuanMKICB2YXIgcmVxdWlyZV9vYmplY3Rfa2V5c19pbnRlcm5hbCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgaGFzID0gcmVxdWlyZV9oYXMoKTsKICAgICAgdmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmVfdG9faW5kZXhlZF9vYmplY3QoKTsKICAgICAgdmFyIGluZGV4T2YgPSByZXF1aXJlX2FycmF5X2luY2x1ZGVzKCkuaW5kZXhPZjsKICAgICAgdmFyIGhpZGRlbktleXMgPSByZXF1aXJlX2hpZGRlbl9rZXlzKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBuYW1lcykgewogICAgICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KG9iamVjdCk7CiAgICAgICAgdmFyIGkgPSAwOwogICAgICAgIHZhciByZXN1bHQgPSBbXTsKICAgICAgICB2YXIga2V5OwogICAgICAgIGZvciAoa2V5IGluIE8pCiAgICAgICAgICAhaGFzKGhpZGRlbktleXMsIGtleSkgJiYgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTsKICAgICAgICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkKICAgICAgICAgIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHsKICAgICAgICAgICAgfmluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7CiAgICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZW51bS1idWcta2V5cy5qcwogIHZhciByZXF1aXJlX2VudW1fYnVnX2tleXMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IFsKICAgICAgICAiY29uc3RydWN0b3IiLAogICAgICAgICJoYXNPd25Qcm9wZXJ0eSIsCiAgICAgICAgImlzUHJvdG90eXBlT2YiLAogICAgICAgICJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsCiAgICAgICAgInRvTG9jYWxlU3RyaW5nIiwKICAgICAgICAidG9TdHJpbmciLAogICAgICAgICJ2YWx1ZU9mIgogICAgICBdOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9vYmplY3Qta2V5cy5qcwogIHZhciByZXF1aXJlX29iamVjdF9rZXlzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvb2JqZWN0LWtleXMuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBpbnRlcm5hbE9iamVjdEtleXMgPSByZXF1aXJlX29iamVjdF9rZXlzX2ludGVybmFsKCk7CiAgICAgIHZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmVfZW51bV9idWdfa2V5cygpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykgewogICAgICAgIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgZW51bUJ1Z0tleXMpOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMuanMKICB2YXIgcmVxdWlyZV9vYmplY3RfZGVmaW5lX3Byb3BlcnRpZXMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBERVNDUklQVE9SUyA9IHJlcXVpcmVfZGVzY3JpcHRvcnMoKTsKICAgICAgdmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZV9vYmplY3RfZGVmaW5lX3Byb3BlcnR5KCk7CiAgICAgIHZhciBhbk9iamVjdCA9IHJlcXVpcmVfYW5fb2JqZWN0KCk7CiAgICAgIHZhciBvYmplY3RLZXlzID0gcmVxdWlyZV9vYmplY3Rfa2V5cygpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHsKICAgICAgICBhbk9iamVjdChPKTsKICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMoUHJvcGVydGllcyk7CiAgICAgICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoOwogICAgICAgIHZhciBpbmRleCA9IDA7CiAgICAgICAgdmFyIGtleTsKICAgICAgICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpCiAgICAgICAgICBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIFByb3BlcnRpZXNba2V5XSk7CiAgICAgICAgcmV0dXJuIE87CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2h0bWwuanMKICB2YXIgcmVxdWlyZV9odG1sID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvaHRtbC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlX2dldF9idWlsdF9pbigpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oImRvY3VtZW50IiwgImRvY3VtZW50RWxlbWVudCIpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzCiAgdmFyIHJlcXVpcmVfb2JqZWN0X2NyZWF0ZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL29iamVjdC1jcmVhdGUuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBhbk9iamVjdCA9IHJlcXVpcmVfYW5fb2JqZWN0KCk7CiAgICAgIHZhciBkZWZpbmVQcm9wZXJ0aWVzID0gcmVxdWlyZV9vYmplY3RfZGVmaW5lX3Byb3BlcnRpZXMoKTsKICAgICAgdmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZV9lbnVtX2J1Z19rZXlzKCk7CiAgICAgIHZhciBoaWRkZW5LZXlzID0gcmVxdWlyZV9oaWRkZW5fa2V5cygpOwogICAgICB2YXIgaHRtbCA9IHJlcXVpcmVfaHRtbCgpOwogICAgICB2YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50ID0gcmVxdWlyZV9kb2N1bWVudF9jcmVhdGVfZWxlbWVudCgpOwogICAgICB2YXIgc2hhcmVkS2V5ID0gcmVxdWlyZV9zaGFyZWRfa2V5KCk7CiAgICAgIHZhciBHVCA9ICI+IjsKICAgICAgdmFyIExUID0gIjwiOwogICAgICB2YXIgUFJPVE9UWVBFID0gInByb3RvdHlwZSI7CiAgICAgIHZhciBTQ1JJUFQgPSAic2NyaXB0IjsKICAgICAgdmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCJJRV9QUk9UTyIpOwogICAgICB2YXIgRW1wdHlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCkgewogICAgICB9OwogICAgICB2YXIgc2NyaXB0VGFnID0gZnVuY3Rpb24oY29udGVudCkgewogICAgICAgIHJldHVybiBMVCArIFNDUklQVCArIEdUICsgY29udGVudCArIExUICsgIi8iICsgU0NSSVBUICsgR1Q7CiAgICAgIH07CiAgICAgIHZhciBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYID0gZnVuY3Rpb24oYWN0aXZlWERvY3VtZW50MikgewogICAgICAgIGFjdGl2ZVhEb2N1bWVudDIud3JpdGUoc2NyaXB0VGFnKCIiKSk7CiAgICAgICAgYWN0aXZlWERvY3VtZW50Mi5jbG9zZSgpOwogICAgICAgIHZhciB0ZW1wID0gYWN0aXZlWERvY3VtZW50Mi5wYXJlbnRXaW5kb3cuT2JqZWN0OwogICAgICAgIGFjdGl2ZVhEb2N1bWVudDIgPSBudWxsOwogICAgICAgIHJldHVybiB0ZW1wOwogICAgICB9OwogICAgICB2YXIgTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lID0gZnVuY3Rpb24oKSB7CiAgICAgICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCgiaWZyYW1lIik7CiAgICAgICAgdmFyIEpTID0gImphdmEiICsgU0NSSVBUICsgIjoiOwogICAgICAgIHZhciBpZnJhbWVEb2N1bWVudDsKICAgICAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICJub25lIjsKICAgICAgICBodG1sLmFwcGVuZENoaWxkKGlmcmFtZSk7CiAgICAgICAgaWZyYW1lLnNyYyA9IFN0cmluZyhKUyk7CiAgICAgICAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDsKICAgICAgICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7CiAgICAgICAgaWZyYW1lRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCJkb2N1bWVudC5GPU9iamVjdCIpKTsKICAgICAgICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpOwogICAgICAgIHJldHVybiBpZnJhbWVEb2N1bWVudC5GOwogICAgICB9OwogICAgICB2YXIgYWN0aXZlWERvY3VtZW50OwogICAgICB2YXIgTnVsbFByb3RvT2JqZWN0ID0gZnVuY3Rpb24oKSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGFjdGl2ZVhEb2N1bWVudCA9IG5ldyBBY3RpdmVYT2JqZWN0KCJodG1sZmlsZSIpOwogICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgfQogICAgICAgIE51bGxQcm90b09iamVjdCA9IHR5cGVvZiBkb2N1bWVudCAhPSAidW5kZWZpbmVkIiA/IGRvY3VtZW50LmRvbWFpbiAmJiBhY3RpdmVYRG9jdW1lbnQgPyBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCkgOiBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUoKSA6IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KTsKICAgICAgICB2YXIgbGVuZ3RoID0gZW51bUJ1Z0tleXMubGVuZ3RoOwogICAgICAgIHdoaWxlIChsZW5ndGgtLSkKICAgICAgICAgIGRlbGV0ZSBOdWxsUHJvdG9PYmplY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tsZW5ndGhdXTsKICAgICAgICByZXR1cm4gTnVsbFByb3RvT2JqZWN0KCk7CiAgICAgIH07CiAgICAgIGhpZGRlbktleXNbSUVfUFJPVE9dID0gdHJ1ZTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7CiAgICAgICAgdmFyIHJlc3VsdDsKICAgICAgICBpZiAoTyAhPT0gbnVsbCkgewogICAgICAgICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7CiAgICAgICAgICByZXN1bHQgPSBuZXcgRW1wdHlDb25zdHJ1Y3RvcigpOwogICAgICAgICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gbnVsbDsKICAgICAgICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPOwogICAgICAgIH0gZWxzZQogICAgICAgICAgcmVzdWx0ID0gTnVsbFByb3RvT2JqZWN0KCk7CiAgICAgICAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHZvaWQgMCA/IHJlc3VsdCA6IGRlZmluZVByb3BlcnRpZXMocmVzdWx0LCBQcm9wZXJ0aWVzKTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyLmpzCiAgdmFyIHJlcXVpcmVfY29ycmVjdF9wcm90b3R5cGVfZ2V0dGVyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgZmFpbHMgPSByZXF1aXJlX2ZhaWxzKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uKCkgewogICAgICAgIGZ1bmN0aW9uIEYoKSB7CiAgICAgICAgfQogICAgICAgIEYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbnVsbDsKICAgICAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTsKICAgICAgfSk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mLmpzCiAgdmFyIHJlcXVpcmVfb2JqZWN0X2dldF9wcm90b3R5cGVfb2YgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZi5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGhhcyA9IHJlcXVpcmVfaGFzKCk7CiAgICAgIHZhciBpc0NhbGxhYmxlID0gcmVxdWlyZV9pc19jYWxsYWJsZSgpOwogICAgICB2YXIgdG9PYmplY3QgPSByZXF1aXJlX3RvX29iamVjdCgpOwogICAgICB2YXIgc2hhcmVkS2V5ID0gcmVxdWlyZV9zaGFyZWRfa2V5KCk7CiAgICAgIHZhciBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPSByZXF1aXJlX2NvcnJlY3RfcHJvdG90eXBlX2dldHRlcigpOwogICAgICB2YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoIklFX1BST1RPIik7CiAgICAgIHZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uKE8pIHsKICAgICAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3QoTyk7CiAgICAgICAgaWYgKGhhcyhvYmplY3QsIElFX1BST1RPKSkKICAgICAgICAgIHJldHVybiBvYmplY3RbSUVfUFJPVE9dOwogICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjsKICAgICAgICBpZiAoaXNDYWxsYWJsZShjb25zdHJ1Y3RvcikgJiYgb2JqZWN0IGluc3RhbmNlb2YgY29uc3RydWN0b3IpIHsKICAgICAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7CiAgICAgICAgfQogICAgICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90b3R5cGUgOiBudWxsOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9yZWRlZmluZS5qcwogIHZhciByZXF1aXJlX3JlZGVmaW5lID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvcmVkZWZpbmUuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlX2NyZWF0ZV9ub25fZW51bWVyYWJsZV9wcm9wZXJ0eSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldCwga2V5LCB2YWx1ZSwgb3B0aW9ucykgewogICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZW51bWVyYWJsZSkKICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7CiAgICAgICAgZWxzZQogICAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHRhcmdldCwga2V5LCB2YWx1ZSk7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlLmpzCiAgdmFyIHJlcXVpcmVfaXRlcmF0b3JzX2NvcmUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pdGVyYXRvcnMtY29yZS5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgZmFpbHMgPSByZXF1aXJlX2ZhaWxzKCk7CiAgICAgIHZhciBpc0NhbGxhYmxlID0gcmVxdWlyZV9pc19jYWxsYWJsZSgpOwogICAgICB2YXIgY3JlYXRlID0gcmVxdWlyZV9vYmplY3RfY3JlYXRlKCk7CiAgICAgIHZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmVfb2JqZWN0X2dldF9wcm90b3R5cGVfb2YoKTsKICAgICAgdmFyIHJlZGVmaW5lID0gcmVxdWlyZV9yZWRlZmluZSgpOwogICAgICB2YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZV93ZWxsX2tub3duX3N5bWJvbCgpOwogICAgICB2YXIgSVNfUFVSRSA9IHJlcXVpcmVfaXNfcHVyZSgpOwogICAgICB2YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woIml0ZXJhdG9yIik7CiAgICAgIHZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gZmFsc2U7CiAgICAgIHZhciBJdGVyYXRvclByb3RvdHlwZTsKICAgICAgdmFyIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZTsKICAgICAgdmFyIGFycmF5SXRlcmF0b3I7CiAgICAgIGlmIChbXS5rZXlzKSB7CiAgICAgICAgYXJyYXlJdGVyYXRvciA9IFtdLmtleXMoKTsKICAgICAgICBpZiAoISgibmV4dCIgaW4gYXJyYXlJdGVyYXRvcikpCiAgICAgICAgICBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gdHJ1ZTsKICAgICAgICBlbHNlIHsKICAgICAgICAgIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKGdldFByb3RvdHlwZU9mKGFycmF5SXRlcmF0b3IpKTsKICAgICAgICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpCiAgICAgICAgICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlOwogICAgICAgIH0KICAgICAgfQogICAgICB2YXIgTkVXX0lURVJBVE9SX1BST1RPVFlQRSA9IEl0ZXJhdG9yUHJvdG90eXBlID09IHZvaWQgMCB8fCBmYWlscyhmdW5jdGlvbigpIHsKICAgICAgICB2YXIgdGVzdCA9IHt9OwogICAgICAgIHJldHVybiBJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0uY2FsbCh0ZXN0KSAhPT0gdGVzdDsKICAgICAgfSk7CiAgICAgIGlmIChORVdfSVRFUkFUT1JfUFJPVE9UWVBFKQogICAgICAgIEl0ZXJhdG9yUHJvdG90eXBlID0ge307CiAgICAgIGVsc2UgaWYgKElTX1BVUkUpCiAgICAgICAgSXRlcmF0b3JQcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpOwogICAgICBpZiAoIWlzQ2FsbGFibGUoSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdKSkgewogICAgICAgIHJlZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgZnVuY3Rpb24oKSB7CiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9KTsKICAgICAgfQogICAgICBtb2R1bGUuZXhwb3J0cyA9IHsKICAgICAgICBJdGVyYXRvclByb3RvdHlwZSwKICAgICAgICBCVUdHWV9TQUZBUklfSVRFUkFUT1JTCiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydC5qcwogIHZhciByZXF1aXJlX3RvX3N0cmluZ190YWdfc3VwcG9ydCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmVfd2VsbF9rbm93bl9zeW1ib2woKTsKICAgICAgdmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woInRvU3RyaW5nVGFnIik7CiAgICAgIHZhciB0ZXN0ID0ge307CiAgICAgIHRlc3RbVE9fU1RSSU5HX1RBR10gPSAieiI7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gU3RyaW5nKHRlc3QpID09PSAiW29iamVjdCB6XSI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2NsYXNzb2YuanMKICB2YXIgcmVxdWlyZV9jbGFzc29mID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvY2xhc3NvZi5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IHJlcXVpcmVfdG9fc3RyaW5nX3RhZ19zdXBwb3J0KCk7CiAgICAgIHZhciBpc0NhbGxhYmxlID0gcmVxdWlyZV9pc19jYWxsYWJsZSgpOwogICAgICB2YXIgY2xhc3NvZlJhdyA9IHJlcXVpcmVfY2xhc3NvZl9yYXcoKTsKICAgICAgdmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmVfd2VsbF9rbm93bl9zeW1ib2woKTsKICAgICAgdmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woInRvU3RyaW5nVGFnIik7CiAgICAgIHZhciBDT1JSRUNUX0FSR1VNRU5UUyA9IGNsYXNzb2ZSYXcoZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIGFyZ3VtZW50czsKICAgICAgfSgpKSA9PSAiQXJndW1lbnRzIjsKICAgICAgdmFyIHRyeUdldCA9IGZ1bmN0aW9uKGl0LCBrZXkpIHsKICAgICAgICB0cnkgewogICAgICAgICAgcmV0dXJuIGl0W2tleV07CiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICB9CiAgICAgIH07CiAgICAgIG1vZHVsZS5leHBvcnRzID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUID8gY2xhc3NvZlJhdyA6IGZ1bmN0aW9uKGl0KSB7CiAgICAgICAgdmFyIE8sIHRhZywgcmVzdWx0OwogICAgICAgIHJldHVybiBpdCA9PT0gdm9pZCAwID8gIlVuZGVmaW5lZCIgOiBpdCA9PT0gbnVsbCA/ICJOdWxsIiA6IHR5cGVvZiAodGFnID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUT19TVFJJTkdfVEFHKSkgPT0gInN0cmluZyIgPyB0YWcgOiBDT1JSRUNUX0FSR1VNRU5UUyA/IGNsYXNzb2ZSYXcoTykgOiAocmVzdWx0ID0gY2xhc3NvZlJhdyhPKSkgPT0gIk9iamVjdCIgJiYgaXNDYWxsYWJsZShPLmNhbGxlZSkgPyAiQXJndW1lbnRzIiA6IHJlc3VsdDsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvb2JqZWN0LXRvLXN0cmluZy5qcwogIHZhciByZXF1aXJlX29iamVjdF90b19zdHJpbmcgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9vYmplY3QtdG8tc3RyaW5nLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSByZXF1aXJlX3RvX3N0cmluZ190YWdfc3VwcG9ydCgpOwogICAgICB2YXIgY2xhc3NvZiA9IHJlcXVpcmVfY2xhc3NvZigpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IHt9LnRvU3RyaW5nIDogZnVuY3Rpb24gdG9TdHJpbmcoKSB7CiAgICAgICAgcmV0dXJuICJbb2JqZWN0ICIgKyBjbGFzc29mKHRoaXMpICsgIl0iOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZy5qcwogIHZhciByZXF1aXJlX3NldF90b19zdHJpbmdfdGFnID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSByZXF1aXJlX3RvX3N0cmluZ190YWdfc3VwcG9ydCgpOwogICAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlX29iamVjdF9kZWZpbmVfcHJvcGVydHkoKS5mOwogICAgICB2YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZV9jcmVhdGVfbm9uX2VudW1lcmFibGVfcHJvcGVydHkoKTsKICAgICAgdmFyIGhhcyA9IHJlcXVpcmVfaGFzKCk7CiAgICAgIHZhciB0b1N0cmluZyA9IHJlcXVpcmVfb2JqZWN0X3RvX3N0cmluZygpOwogICAgICB2YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZV93ZWxsX2tub3duX3N5bWJvbCgpOwogICAgICB2YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgidG9TdHJpbmdUYWciKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgVEFHLCBTVEFUSUMsIFNFVF9NRVRIT0QpIHsKICAgICAgICBpZiAoaXQpIHsKICAgICAgICAgIHZhciB0YXJnZXQgPSBTVEFUSUMgPyBpdCA6IGl0LnByb3RvdHlwZTsKICAgICAgICAgIGlmICghaGFzKHRhcmdldCwgVE9fU1RSSU5HX1RBRykpIHsKICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBUT19TVFJJTkdfVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IFRBRyB9KTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChTRVRfTUVUSE9EICYmICFUT19TVFJJTkdfVEFHX1NVUFBPUlQpIHsKICAgICAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHRhcmdldCwgInRvU3RyaW5nIiwgdG9TdHJpbmcpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvY3JlYXRlLWl0ZXJhdG9yLWNvbnN0cnVjdG9yLmpzCiAgdmFyIHJlcXVpcmVfY3JlYXRlX2l0ZXJhdG9yX2NvbnN0cnVjdG9yID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvY3JlYXRlLWl0ZXJhdG9yLWNvbnN0cnVjdG9yLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHJlcXVpcmVfaXRlcmF0b3JzX2NvcmUoKS5JdGVyYXRvclByb3RvdHlwZTsKICAgICAgdmFyIGNyZWF0ZSA9IHJlcXVpcmVfb2JqZWN0X2NyZWF0ZSgpOwogICAgICB2YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZV9jcmVhdGVfcHJvcGVydHlfZGVzY3JpcHRvcigpOwogICAgICB2YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlX3NldF90b19zdHJpbmdfdGFnKCk7CiAgICAgIHZhciBJdGVyYXRvcnMgPSByZXF1aXJlX2l0ZXJhdG9ycygpOwogICAgICB2YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9OwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHsKICAgICAgICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAiIEl0ZXJhdG9yIjsKICAgICAgICBJdGVyYXRvckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgbmV4dCkgfSk7CiAgICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JDb25zdHJ1Y3RvciwgVE9fU1RSSU5HX1RBRywgZmFsc2UsIHRydWUpOwogICAgICAgIEl0ZXJhdG9yc1tUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXM7CiAgICAgICAgcmV0dXJuIEl0ZXJhdG9yQ29uc3RydWN0b3I7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2EtcG9zc2libGUtcHJvdG90eXBlLmpzCiAgdmFyIHJlcXVpcmVfYV9wb3NzaWJsZV9wcm90b3R5cGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9hLXBvc3NpYmxlLXByb3RvdHlwZS5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlX2lzX2NhbGxhYmxlKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJndW1lbnQpIHsKICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50ID09PSAib2JqZWN0IiB8fCBpc0NhbGxhYmxlKGFyZ3VtZW50KSkKICAgICAgICAgIHJldHVybiBhcmd1bWVudDsKICAgICAgICB0aHJvdyBUeXBlRXJyb3IoIkNhbid0IHNldCAiICsgU3RyaW5nKGFyZ3VtZW50KSArICIgYXMgYSBwcm90b3R5cGUiKTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YuanMKICB2YXIgcmVxdWlyZV9vYmplY3Rfc2V0X3Byb3RvdHlwZV9vZiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgYW5PYmplY3QgPSByZXF1aXJlX2FuX29iamVjdCgpOwogICAgICB2YXIgYVBvc3NpYmxlUHJvdG90eXBlID0gcmVxdWlyZV9hX3Bvc3NpYmxlX3Byb3RvdHlwZSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoIl9fcHJvdG9fXyIgaW4ge30gPyBmdW5jdGlvbigpIHsKICAgICAgICB2YXIgQ09SUkVDVF9TRVRURVIgPSBmYWxzZTsKICAgICAgICB2YXIgdGVzdCA9IHt9OwogICAgICAgIHZhciBzZXR0ZXI7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIHNldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LnByb3RvdHlwZSwgIl9fcHJvdG9fXyIpLnNldDsKICAgICAgICAgIHNldHRlci5jYWxsKHRlc3QsIFtdKTsKICAgICAgICAgIENPUlJFQ1RfU0VUVEVSID0gdGVzdCBpbnN0YW5jZW9mIEFycmF5OwogICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgfQogICAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykgewogICAgICAgICAgYW5PYmplY3QoTyk7CiAgICAgICAgICBhUG9zc2libGVQcm90b3R5cGUocHJvdG8pOwogICAgICAgICAgaWYgKENPUlJFQ1RfU0VUVEVSKQogICAgICAgICAgICBzZXR0ZXIuY2FsbChPLCBwcm90byk7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIE8uX19wcm90b19fID0gcHJvdG87CiAgICAgICAgICByZXR1cm4gTzsKICAgICAgICB9OwogICAgICB9KCkgOiB2b2lkIDApOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3IuanMKICB2YXIgcmVxdWlyZV9kZWZpbmVfaXRlcmF0b3IgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3IuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyICQgPSByZXF1aXJlX2V4cG9ydCgpOwogICAgICB2YXIgSVNfUFVSRSA9IHJlcXVpcmVfaXNfcHVyZSgpOwogICAgICB2YXIgRnVuY3Rpb25OYW1lID0gcmVxdWlyZV9mdW5jdGlvbl9uYW1lKCk7CiAgICAgIHZhciBpc0NhbGxhYmxlID0gcmVxdWlyZV9pc19jYWxsYWJsZSgpOwogICAgICB2YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciA9IHJlcXVpcmVfY3JlYXRlX2l0ZXJhdG9yX2NvbnN0cnVjdG9yKCk7CiAgICAgIHZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmVfb2JqZWN0X2dldF9wcm90b3R5cGVfb2YoKTsKICAgICAgdmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZV9vYmplY3Rfc2V0X3Byb3RvdHlwZV9vZigpOwogICAgICB2YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlX3NldF90b19zdHJpbmdfdGFnKCk7CiAgICAgIHZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlX2NyZWF0ZV9ub25fZW51bWVyYWJsZV9wcm9wZXJ0eSgpOwogICAgICB2YXIgcmVkZWZpbmUgPSByZXF1aXJlX3JlZGVmaW5lKCk7CiAgICAgIHZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlX3dlbGxfa25vd25fc3ltYm9sKCk7CiAgICAgIHZhciBJdGVyYXRvcnMgPSByZXF1aXJlX2l0ZXJhdG9ycygpOwogICAgICB2YXIgSXRlcmF0b3JzQ29yZSA9IHJlcXVpcmVfaXRlcmF0b3JzX2NvcmUoKTsKICAgICAgdmFyIFBST1BFUl9GVU5DVElPTl9OQU1FID0gRnVuY3Rpb25OYW1lLlBST1BFUjsKICAgICAgdmFyIENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FID0gRnVuY3Rpb25OYW1lLkNPTkZJR1VSQUJMRTsKICAgICAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gSXRlcmF0b3JzQ29yZS5JdGVyYXRvclByb3RvdHlwZTsKICAgICAgdmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSBJdGVyYXRvcnNDb3JlLkJVR0dZX1NBRkFSSV9JVEVSQVRPUlM7CiAgICAgIHZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgiaXRlcmF0b3IiKTsKICAgICAgdmFyIEtFWVMgPSAia2V5cyI7CiAgICAgIHZhciBWQUxVRVMgPSAidmFsdWVzIjsKICAgICAgdmFyIEVOVFJJRVMgPSAiZW50cmllcyI7CiAgICAgIHZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oSXRlcmFibGUsIE5BTUUsIEl0ZXJhdG9yQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7CiAgICAgICAgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvcihJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTsKICAgICAgICB2YXIgZ2V0SXRlcmF0aW9uTWV0aG9kID0gZnVuY3Rpb24oS0lORCkgewogICAgICAgICAgaWYgKEtJTkQgPT09IERFRkFVTFQgJiYgZGVmYXVsdEl0ZXJhdG9yKQogICAgICAgICAgICByZXR1cm4gZGVmYXVsdEl0ZXJhdG9yOwogICAgICAgICAgaWYgKCFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIEtJTkQgaW4gSXRlcmFibGVQcm90b3R5cGUpCiAgICAgICAgICAgIHJldHVybiBJdGVyYWJsZVByb3RvdHlwZVtLSU5EXTsKICAgICAgICAgIHN3aXRjaCAoS0lORCkgewogICAgICAgICAgICBjYXNlIEtFWVM6CiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7CiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgY2FzZSBWQUxVRVM6CiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsKICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsKICAgICAgICAgICAgICB9OwogICAgICAgICAgICBjYXNlIEVOVFJJRVM6CiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7CiAgICAgICAgICAgICAgfTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMpOwogICAgICAgICAgfTsKICAgICAgICB9OwogICAgICAgIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICIgSXRlcmF0b3IiOwogICAgICAgIHZhciBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSBmYWxzZTsKICAgICAgICB2YXIgSXRlcmFibGVQcm90b3R5cGUgPSBJdGVyYWJsZS5wcm90b3R5cGU7CiAgICAgICAgdmFyIG5hdGl2ZUl0ZXJhdG9yID0gSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JdIHx8IEl0ZXJhYmxlUHJvdG90eXBlWyJAQGl0ZXJhdG9yIl0gfHwgREVGQVVMVCAmJiBJdGVyYWJsZVByb3RvdHlwZVtERUZBVUxUXTsKICAgICAgICB2YXIgZGVmYXVsdEl0ZXJhdG9yID0gIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgbmF0aXZlSXRlcmF0b3IgfHwgZ2V0SXRlcmF0aW9uTWV0aG9kKERFRkFVTFQpOwogICAgICAgIHZhciBhbnlOYXRpdmVJdGVyYXRvciA9IE5BTUUgPT0gIkFycmF5IiA/IEl0ZXJhYmxlUHJvdG90eXBlLmVudHJpZXMgfHwgbmF0aXZlSXRlcmF0b3IgOiBuYXRpdmVJdGVyYXRvcjsKICAgICAgICB2YXIgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBtZXRob2RzLCBLRVk7CiAgICAgICAgaWYgKGFueU5hdGl2ZUl0ZXJhdG9yKSB7CiAgICAgICAgICBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZihhbnlOYXRpdmVJdGVyYXRvci5jYWxsKG5ldyBJdGVyYWJsZSgpKSk7CiAgICAgICAgICBpZiAoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7CiAgICAgICAgICAgIGlmICghSVNfUFVSRSAmJiBnZXRQcm90b3R5cGVPZihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUpICE9PSBJdGVyYXRvclByb3RvdHlwZSkgewogICAgICAgICAgICAgIGlmIChzZXRQcm90b3R5cGVPZikgewogICAgICAgICAgICAgICAgc2V0UHJvdG90eXBlT2YoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJdGVyYXRvclByb3RvdHlwZSk7CiAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXNDYWxsYWJsZShDdXJyZW50SXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdKSkgewogICAgICAgICAgICAgICAgcmVkZWZpbmUoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHNldFRvU3RyaW5nVGFnKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgdHJ1ZSwgdHJ1ZSk7CiAgICAgICAgICAgIGlmIChJU19QVVJFKQogICAgICAgICAgICAgIEl0ZXJhdG9yc1tUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXM7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChQUk9QRVJfRlVOQ1RJT05fTkFNRSAmJiBERUZBVUxUID09IFZBTFVFUyAmJiBuYXRpdmVJdGVyYXRvciAmJiBuYXRpdmVJdGVyYXRvci5uYW1lICE9PSBWQUxVRVMpIHsKICAgICAgICAgIGlmICghSVNfUFVSRSAmJiBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSkgewogICAgICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoSXRlcmFibGVQcm90b3R5cGUsICJuYW1lIiwgVkFMVUVTKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IHRydWU7CiAgICAgICAgICAgIGRlZmF1bHRJdGVyYXRvciA9IGZ1bmN0aW9uIHZhbHVlcygpIHsKICAgICAgICAgICAgICByZXR1cm4gbmF0aXZlSXRlcmF0b3IuY2FsbCh0aGlzKTsKICAgICAgICAgICAgfTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKERFRkFVTFQpIHsKICAgICAgICAgIG1ldGhvZHMgPSB7CiAgICAgICAgICAgIHZhbHVlczogZ2V0SXRlcmF0aW9uTWV0aG9kKFZBTFVFUyksCiAgICAgICAgICAgIGtleXM6IElTX1NFVCA/IGRlZmF1bHRJdGVyYXRvciA6IGdldEl0ZXJhdGlvbk1ldGhvZChLRVlTKSwKICAgICAgICAgICAgZW50cmllczogZ2V0SXRlcmF0aW9uTWV0aG9kKEVOVFJJRVMpCiAgICAgICAgICB9OwogICAgICAgICAgaWYgKEZPUkNFRCkKICAgICAgICAgICAgZm9yIChLRVkgaW4gbWV0aG9kcykgewogICAgICAgICAgICAgIGlmIChCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB8fCAhKEtFWSBpbiBJdGVyYWJsZVByb3RvdHlwZSkpIHsKICAgICAgICAgICAgICAgIHJlZGVmaW5lKEl0ZXJhYmxlUHJvdG90eXBlLCBLRVksIG1ldGhvZHNbS0VZXSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgICQoeyB0YXJnZXQ6IE5BTUUsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIH0sIG1ldGhvZHMpOwogICAgICAgIH0KICAgICAgICBpZiAoKCFJU19QVVJFIHx8IEZPUkNFRCkgJiYgSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JdICE9PSBkZWZhdWx0SXRlcmF0b3IpIHsKICAgICAgICAgIHJlZGVmaW5lKEl0ZXJhYmxlUHJvdG90eXBlLCBJVEVSQVRPUiwgZGVmYXVsdEl0ZXJhdG9yLCB7IG5hbWU6IERFRkFVTFQgfSk7CiAgICAgICAgfQogICAgICAgIEl0ZXJhdG9yc1tOQU1FXSA9IGRlZmF1bHRJdGVyYXRvcjsKICAgICAgICByZXR1cm4gbWV0aG9kczsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yLmpzCiAgdmFyIHJlcXVpcmVfZXNfYXJyYXlfaXRlcmF0b3IgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmVfdG9faW5kZXhlZF9vYmplY3QoKTsKICAgICAgdmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlX2FkZF90b191bnNjb3BhYmxlcygpOwogICAgICB2YXIgSXRlcmF0b3JzID0gcmVxdWlyZV9pdGVyYXRvcnMoKTsKICAgICAgdmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlX2ludGVybmFsX3N0YXRlKCk7CiAgICAgIHZhciBkZWZpbmVJdGVyYXRvciA9IHJlcXVpcmVfZGVmaW5lX2l0ZXJhdG9yKCk7CiAgICAgIHZhciBBUlJBWV9JVEVSQVRPUiA9ICJBcnJheSBJdGVyYXRvciI7CiAgICAgIHZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7CiAgICAgIHZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoQVJSQVlfSVRFUkFUT1IpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluZUl0ZXJhdG9yKEFycmF5LCAiQXJyYXkiLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCkgewogICAgICAgIHNldEludGVybmFsU3RhdGUodGhpcywgewogICAgICAgICAgdHlwZTogQVJSQVlfSVRFUkFUT1IsCiAgICAgICAgICB0YXJnZXQ6IHRvSW5kZXhlZE9iamVjdChpdGVyYXRlZCksCiAgICAgICAgICBpbmRleDogMCwKICAgICAgICAgIGtpbmQKICAgICAgICB9KTsKICAgICAgfSwgZnVuY3Rpb24oKSB7CiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTsKICAgICAgICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0OwogICAgICAgIHZhciBraW5kID0gc3RhdGUua2luZDsKICAgICAgICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleCsrOwogICAgICAgIGlmICghdGFyZ2V0IHx8IGluZGV4ID49IHRhcmdldC5sZW5ndGgpIHsKICAgICAgICAgIHN0YXRlLnRhcmdldCA9IHZvaWQgMDsKICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB2b2lkIDAsIGRvbmU6IHRydWUgfTsKICAgICAgICB9CiAgICAgICAgaWYgKGtpbmQgPT0gImtleXMiKQogICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGluZGV4LCBkb25lOiBmYWxzZSB9OwogICAgICAgIGlmIChraW5kID09ICJ2YWx1ZXMiKQogICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHRhcmdldFtpbmRleF0sIGRvbmU6IGZhbHNlIH07CiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IFtpbmRleCwgdGFyZ2V0W2luZGV4XV0sIGRvbmU6IGZhbHNlIH07CiAgICAgIH0sICJ2YWx1ZXMiKTsKICAgICAgSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTsKICAgICAgYWRkVG9VbnNjb3BhYmxlcygia2V5cyIpOwogICAgICBhZGRUb1Vuc2NvcGFibGVzKCJ2YWx1ZXMiKTsKICAgICAgYWRkVG9VbnNjb3BhYmxlcygiZW50cmllcyIpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy90by1zdHJpbmcuanMKICB2YXIgcmVxdWlyZV90b19zdHJpbmcgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy90by1zdHJpbmcuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBjbGFzc29mID0gcmVxdWlyZV9jbGFzc29mKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJndW1lbnQpIHsKICAgICAgICBpZiAoY2xhc3NvZihhcmd1bWVudCkgPT09ICJTeW1ib2wiKQogICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCJDYW5ub3QgY29udmVydCBhIFN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyIpOwogICAgICAgIHJldHVybiBTdHJpbmcoYXJndW1lbnQpOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9zdHJpbmctbXVsdGlieXRlLmpzCiAgdmFyIHJlcXVpcmVfc3RyaW5nX211bHRpYnl0ZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3N0cmluZy1tdWx0aWJ5dGUuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciB0b0ludGVnZXIgPSByZXF1aXJlX3RvX2ludGVnZXIoKTsKICAgICAgdmFyIHRvU3RyaW5nID0gcmVxdWlyZV90b19zdHJpbmcoKTsKICAgICAgdmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlX3JlcXVpcmVfb2JqZWN0X2NvZXJjaWJsZSgpOwogICAgICB2YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24oQ09OVkVSVF9UT19TVFJJTkcpIHsKICAgICAgICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIHBvcykgewogICAgICAgICAgdmFyIFMgPSB0b1N0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKCR0aGlzKSk7CiAgICAgICAgICB2YXIgcG9zaXRpb24gPSB0b0ludGVnZXIocG9zKTsKICAgICAgICAgIHZhciBzaXplID0gUy5sZW5ndGg7CiAgICAgICAgICB2YXIgZmlyc3QsIHNlY29uZDsKICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gc2l6ZSkKICAgICAgICAgICAgcmV0dXJuIENPTlZFUlRfVE9fU1RSSU5HID8gIiIgOiB2b2lkIDA7CiAgICAgICAgICBmaXJzdCA9IFMuY2hhckNvZGVBdChwb3NpdGlvbik7CiAgICAgICAgICByZXR1cm4gZmlyc3QgPCA1NTI5NiB8fCBmaXJzdCA+IDU2MzE5IHx8IHBvc2l0aW9uICsgMSA9PT0gc2l6ZSB8fCAoc2Vjb25kID0gUy5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkpIDwgNTYzMjAgfHwgc2Vjb25kID4gNTczNDMgPyBDT05WRVJUX1RPX1NUUklORyA/IFMuY2hhckF0KHBvc2l0aW9uKSA6IGZpcnN0IDogQ09OVkVSVF9UT19TVFJJTkcgPyBTLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIDIpIDogKGZpcnN0IC0gNTUyOTYgPDwgMTApICsgKHNlY29uZCAtIDU2MzIwKSArIDY1NTM2OwogICAgICAgIH07CiAgICAgIH07CiAgICAgIG1vZHVsZS5leHBvcnRzID0gewogICAgICAgIGNvZGVBdDogY3JlYXRlTWV0aG9kKGZhbHNlKSwKICAgICAgICBjaGFyQXQ6IGNyZWF0ZU1ldGhvZCh0cnVlKQogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzCiAgdmFyIHJlcXVpcmVfZXNfc3RyaW5nX2l0ZXJhdG9yID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgY2hhckF0ID0gcmVxdWlyZV9zdHJpbmdfbXVsdGlieXRlKCkuY2hhckF0OwogICAgICB2YXIgdG9TdHJpbmcgPSByZXF1aXJlX3RvX3N0cmluZygpOwogICAgICB2YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmVfaW50ZXJuYWxfc3RhdGUoKTsKICAgICAgdmFyIGRlZmluZUl0ZXJhdG9yID0gcmVxdWlyZV9kZWZpbmVfaXRlcmF0b3IoKTsKICAgICAgdmFyIFNUUklOR19JVEVSQVRPUiA9ICJTdHJpbmcgSXRlcmF0b3IiOwogICAgICB2YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0OwogICAgICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFNUUklOR19JVEVSQVRPUik7CiAgICAgIGRlZmluZUl0ZXJhdG9yKFN0cmluZywgIlN0cmluZyIsIGZ1bmN0aW9uKGl0ZXJhdGVkKSB7CiAgICAgICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7CiAgICAgICAgICB0eXBlOiBTVFJJTkdfSVRFUkFUT1IsCiAgICAgICAgICBzdHJpbmc6IHRvU3RyaW5nKGl0ZXJhdGVkKSwKICAgICAgICAgIGluZGV4OiAwCiAgICAgICAgfSk7CiAgICAgIH0sIGZ1bmN0aW9uIG5leHQoKSB7CiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTsKICAgICAgICB2YXIgc3RyaW5nID0gc3RhdGUuc3RyaW5nOwogICAgICAgIHZhciBpbmRleCA9IHN0YXRlLmluZGV4OwogICAgICAgIHZhciBwb2ludDsKICAgICAgICBpZiAoaW5kZXggPj0gc3RyaW5nLmxlbmd0aCkKICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB2b2lkIDAsIGRvbmU6IHRydWUgfTsKICAgICAgICBwb2ludCA9IGNoYXJBdChzdHJpbmcsIGluZGV4KTsKICAgICAgICBzdGF0ZS5pbmRleCArPSBwb2ludC5sZW5ndGg7CiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9OwogICAgICB9KTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcwogIHZhciByZXF1aXJlX2dldF9pdGVyYXRvcl9tZXRob2QgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgY2xhc3NvZiA9IHJlcXVpcmVfY2xhc3NvZigpOwogICAgICB2YXIgZ2V0TWV0aG9kID0gcmVxdWlyZV9nZXRfbWV0aG9kKCk7CiAgICAgIHZhciBJdGVyYXRvcnMgPSByZXF1aXJlX2l0ZXJhdG9ycygpOwogICAgICB2YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZV93ZWxsX2tub3duX3N5bWJvbCgpOwogICAgICB2YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woIml0ZXJhdG9yIik7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpIHsKICAgICAgICBpZiAoaXQgIT0gdm9pZCAwKQogICAgICAgICAgcmV0dXJuIGdldE1ldGhvZChpdCwgSVRFUkFUT1IpIHx8IGdldE1ldGhvZChpdCwgIkBAaXRlcmF0b3IiKSB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9nZXQtaXRlcmF0b3IuanMKICB2YXIgcmVxdWlyZV9nZXRfaXRlcmF0b3IgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9nZXQtaXRlcmF0b3IuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBhQ2FsbGFibGUgPSByZXF1aXJlX2FfY2FsbGFibGUoKTsKICAgICAgdmFyIGFuT2JqZWN0ID0gcmVxdWlyZV9hbl9vYmplY3QoKTsKICAgICAgdmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZV9nZXRfaXRlcmF0b3JfbWV0aG9kKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJndW1lbnQsIHVzaW5nSXRlcmF0b3IpIHsKICAgICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGdldEl0ZXJhdG9yTWV0aG9kKGFyZ3VtZW50KSA6IHVzaW5nSXRlcmF0b3I7CiAgICAgICAgaWYgKGFDYWxsYWJsZShpdGVyYXRvck1ldGhvZCkpCiAgICAgICAgICByZXR1cm4gYW5PYmplY3QoaXRlcmF0b3JNZXRob2QuY2FsbChhcmd1bWVudCkpOwogICAgICAgIHRocm93IFR5cGVFcnJvcihTdHJpbmcoYXJndW1lbnQpICsgIiBpcyBub3QgaXRlcmFibGUiKTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9nZXQtaXRlcmF0b3IuanMKICB2YXIgcmVxdWlyZV9nZXRfaXRlcmF0b3IyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9nZXQtaXRlcmF0b3IuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHJlcXVpcmVfZXNfYXJyYXlfaXRlcmF0b3IoKTsKICAgICAgcmVxdWlyZV9lc19zdHJpbmdfaXRlcmF0b3IoKTsKICAgICAgdmFyIGdldEl0ZXJhdG9yID0gcmVxdWlyZV9nZXRfaXRlcmF0b3IoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBnZXRJdGVyYXRvcjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZG9tLWl0ZXJhYmxlcy5qcwogIHZhciByZXF1aXJlX2RvbV9pdGVyYWJsZXMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9kb20taXRlcmFibGVzLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHsKICAgICAgICBDU1NSdWxlTGlzdDogMCwKICAgICAgICBDU1NTdHlsZURlY2xhcmF0aW9uOiAwLAogICAgICAgIENTU1ZhbHVlTGlzdDogMCwKICAgICAgICBDbGllbnRSZWN0TGlzdDogMCwKICAgICAgICBET01SZWN0TGlzdDogMCwKICAgICAgICBET01TdHJpbmdMaXN0OiAwLAogICAgICAgIERPTVRva2VuTGlzdDogMSwKICAgICAgICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogMCwKICAgICAgICBGaWxlTGlzdDogMCwKICAgICAgICBIVE1MQWxsQ29sbGVjdGlvbjogMCwKICAgICAgICBIVE1MQ29sbGVjdGlvbjogMCwKICAgICAgICBIVE1MRm9ybUVsZW1lbnQ6IDAsCiAgICAgICAgSFRNTFNlbGVjdEVsZW1lbnQ6IDAsCiAgICAgICAgTWVkaWFMaXN0OiAwLAogICAgICAgIE1pbWVUeXBlQXJyYXk6IDAsCiAgICAgICAgTmFtZWROb2RlTWFwOiAwLAogICAgICAgIE5vZGVMaXN0OiAxLAogICAgICAgIFBhaW50UmVxdWVzdExpc3Q6IDAsCiAgICAgICAgUGx1Z2luOiAwLAogICAgICAgIFBsdWdpbkFycmF5OiAwLAogICAgICAgIFNWR0xlbmd0aExpc3Q6IDAsCiAgICAgICAgU1ZHTnVtYmVyTGlzdDogMCwKICAgICAgICBTVkdQYXRoU2VnTGlzdDogMCwKICAgICAgICBTVkdQb2ludExpc3Q6IDAsCiAgICAgICAgU1ZHU3RyaW5nTGlzdDogMCwKICAgICAgICBTVkdUcmFuc2Zvcm1MaXN0OiAwLAogICAgICAgIFNvdXJjZUJ1ZmZlckxpc3Q6IDAsCiAgICAgICAgU3R5bGVTaGVldExpc3Q6IDAsCiAgICAgICAgVGV4dFRyYWNrQ3VlTGlzdDogMCwKICAgICAgICBUZXh0VHJhY2tMaXN0OiAwLAogICAgICAgIFRvdWNoTGlzdDogMAogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qcwogIHZhciByZXF1aXJlX3dlYl9kb21fY29sbGVjdGlvbnNfaXRlcmF0b3IgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgcmVxdWlyZV9lc19hcnJheV9pdGVyYXRvcigpOwogICAgICB2YXIgRE9NSXRlcmFibGVzID0gcmVxdWlyZV9kb21faXRlcmFibGVzKCk7CiAgICAgIHZhciBnbG9iYWwyID0gcmVxdWlyZV9nbG9iYWwoKTsKICAgICAgdmFyIGNsYXNzb2YgPSByZXF1aXJlX2NsYXNzb2YoKTsKICAgICAgdmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmVfY3JlYXRlX25vbl9lbnVtZXJhYmxlX3Byb3BlcnR5KCk7CiAgICAgIHZhciBJdGVyYXRvcnMgPSByZXF1aXJlX2l0ZXJhdG9ycygpOwogICAgICB2YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZV93ZWxsX2tub3duX3N5bWJvbCgpOwogICAgICB2YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgidG9TdHJpbmdUYWciKTsKICAgICAgZm9yIChDT0xMRUNUSU9OX05BTUUgaW4gRE9NSXRlcmFibGVzKSB7CiAgICAgICAgQ29sbGVjdGlvbiA9IGdsb2JhbDJbQ09MTEVDVElPTl9OQU1FXTsKICAgICAgICBDb2xsZWN0aW9uUHJvdG90eXBlID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTsKICAgICAgICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZSAmJiBjbGFzc29mKENvbGxlY3Rpb25Qcm90b3R5cGUpICE9PSBUT19TVFJJTkdfVEFHKSB7CiAgICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgQ09MTEVDVElPTl9OQU1FKTsKICAgICAgICB9CiAgICAgICAgSXRlcmF0b3JzW0NPTExFQ1RJT05fTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7CiAgICAgIH0KICAgICAgdmFyIENvbGxlY3Rpb247CiAgICAgIHZhciBDb2xsZWN0aW9uUHJvdG90eXBlOwogICAgICB2YXIgQ09MTEVDVElPTl9OQU1FOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9nZXQtaXRlcmF0b3IuanMKICB2YXIgcmVxdWlyZV9nZXRfaXRlcmF0b3IzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvZ2V0LWl0ZXJhdG9yLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgcGFyZW50ID0gcmVxdWlyZV9nZXRfaXRlcmF0b3IyKCk7CiAgICAgIHJlcXVpcmVfd2ViX2RvbV9jb2xsZWN0aW9uc19pdGVyYXRvcigpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcmVudDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9mZWF0dXJlcy9nZXQtaXRlcmF0b3IuanMKICB2YXIgcmVxdWlyZV9nZXRfaXRlcmF0b3I0ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9mZWF0dXJlcy9nZXQtaXRlcmF0b3IuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBwYXJlbnQgPSByZXF1aXJlX2dldF9pdGVyYXRvcjMoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMvZ2V0LWl0ZXJhdG9yLmpzCiAgdmFyIHJlcXVpcmVfZ2V0X2l0ZXJhdG9yNSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMvZ2V0LWl0ZXJhdG9yLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVfZ2V0X2l0ZXJhdG9yNCgpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pcy1hcnJheS5qcwogIHZhciByZXF1aXJlX2lzX2FycmF5ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvaXMtYXJyYXkuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBjbGFzc29mID0gcmVxdWlyZV9jbGFzc29mX3JhdygpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmd1bWVudCkgewogICAgICAgIHJldHVybiBjbGFzc29mKGFyZ3VtZW50KSA9PSAiQXJyYXkiOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuYXJyYXkuaXMtYXJyYXkuanMKICB2YXIgcmVxdWlyZV9lc19hcnJheV9pc19hcnJheSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5hcnJheS5pcy1hcnJheS5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyICQgPSByZXF1aXJlX2V4cG9ydCgpOwogICAgICB2YXIgaXNBcnJheSA9IHJlcXVpcmVfaXNfYXJyYXkoKTsKICAgICAgJCh7IHRhcmdldDogIkFycmF5Iiwgc3RhdDogdHJ1ZSB9LCB7CiAgICAgICAgaXNBcnJheQogICAgICB9KTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9hcnJheS9pcy1hcnJheS5qcwogIHZhciByZXF1aXJlX2lzX2FycmF5MiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvYXJyYXkvaXMtYXJyYXkuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHJlcXVpcmVfZXNfYXJyYXlfaXNfYXJyYXkoKTsKICAgICAgdmFyIHBhdGggPSByZXF1aXJlX3BhdGgoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBwYXRoLkFycmF5LmlzQXJyYXk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL2FycmF5L2lzLWFycmF5LmpzCiAgdmFyIHJlcXVpcmVfaXNfYXJyYXkzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvYXJyYXkvaXMtYXJyYXkuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBwYXJlbnQgPSByZXF1aXJlX2lzX2FycmF5MigpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcmVudDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvYXJyYXkvaXMtYXJyYXkuanMKICB2YXIgcmVxdWlyZV9pc19hcnJheTQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9hcnJheS9pcy1hcnJheS5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlX2lzX2FycmF5MygpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2dldC1pdGVyYXRvci1tZXRob2QuanMKICB2YXIgcmVxdWlyZV9nZXRfaXRlcmF0b3JfbWV0aG9kMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgcmVxdWlyZV9lc19hcnJheV9pdGVyYXRvcigpOwogICAgICByZXF1aXJlX2VzX3N0cmluZ19pdGVyYXRvcigpOwogICAgICB2YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlX2dldF9pdGVyYXRvcl9tZXRob2QoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBnZXRJdGVyYXRvck1ldGhvZDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcwogIHZhciByZXF1aXJlX2dldF9pdGVyYXRvcl9tZXRob2QzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHBhcmVudCA9IHJlcXVpcmVfZ2V0X2l0ZXJhdG9yX21ldGhvZDIoKTsKICAgICAgcmVxdWlyZV93ZWJfZG9tX2NvbGxlY3Rpb25zX2l0ZXJhdG9yKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGFyZW50OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ZlYXR1cmVzL2dldC1pdGVyYXRvci1tZXRob2QuanMKICB2YXIgcmVxdWlyZV9nZXRfaXRlcmF0b3JfbWV0aG9kNCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZmVhdHVyZXMvZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHBhcmVudCA9IHJlcXVpcmVfZ2V0X2l0ZXJhdG9yX21ldGhvZDMoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMvZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcwogIHZhciByZXF1aXJlX2dldF9pdGVyYXRvcl9tZXRob2Q1ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy9nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVfZ2V0X2l0ZXJhdG9yX21ldGhvZDQoKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LmpzCiAgdmFyIHJlcXVpcmVfY3JlYXRlX3Byb3BlcnR5ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZV90b19wcm9wZXJ0eV9rZXkoKTsKICAgICAgdmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZV9vYmplY3RfZGVmaW5lX3Byb3BlcnR5KCk7CiAgICAgIHZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlX2NyZWF0ZV9wcm9wZXJ0eV9kZXNjcmlwdG9yKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKSB7CiAgICAgICAgdmFyIHByb3BlcnR5S2V5ID0gdG9Qcm9wZXJ0eUtleShrZXkpOwogICAgICAgIGlmIChwcm9wZXJ0eUtleSBpbiBvYmplY3QpCiAgICAgICAgICBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKG9iamVjdCwgcHJvcGVydHlLZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCB2YWx1ZSkpOwogICAgICAgIGVsc2UKICAgICAgICAgIG9iamVjdFtwcm9wZXJ0eUtleV0gPSB2YWx1ZTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvaXMtY29uc3RydWN0b3IuanMKICB2YXIgcmVxdWlyZV9pc19jb25zdHJ1Y3RvciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2lzLWNvbnN0cnVjdG9yLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgZmFpbHMgPSByZXF1aXJlX2ZhaWxzKCk7CiAgICAgIHZhciBpc0NhbGxhYmxlID0gcmVxdWlyZV9pc19jYWxsYWJsZSgpOwogICAgICB2YXIgY2xhc3NvZiA9IHJlcXVpcmVfY2xhc3NvZigpOwogICAgICB2YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmVfZ2V0X2J1aWx0X2luKCk7CiAgICAgIHZhciBpbnNwZWN0U291cmNlID0gcmVxdWlyZV9pbnNwZWN0X3NvdXJjZSgpOwogICAgICB2YXIgZW1wdHkgPSBbXTsKICAgICAgdmFyIGNvbnN0cnVjdCA9IGdldEJ1aWx0SW4oIlJlZmxlY3QiLCAiY29uc3RydWN0Iik7CiAgICAgIHZhciBjb25zdHJ1Y3RvclJlZ0V4cCA9IC9eXHMqKD86Y2xhc3N8ZnVuY3Rpb24pXGIvOwogICAgICB2YXIgZXhlYyA9IGNvbnN0cnVjdG9yUmVnRXhwLmV4ZWM7CiAgICAgIHZhciBJTkNPUlJFQ1RfVE9fU1RSSU5HID0gIWNvbnN0cnVjdG9yUmVnRXhwLmV4ZWMoZnVuY3Rpb24oKSB7CiAgICAgIH0pOwogICAgICB2YXIgaXNDb25zdHJ1Y3Rvck1vZGVybiA9IGZ1bmN0aW9uKGFyZ3VtZW50KSB7CiAgICAgICAgaWYgKCFpc0NhbGxhYmxlKGFyZ3VtZW50KSkKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB0cnkgewogICAgICAgICAgY29uc3RydWN0KE9iamVjdCwgZW1wdHksIGFyZ3VtZW50KTsKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICB9OwogICAgICB2YXIgaXNDb25zdHJ1Y3RvckxlZ2FjeSA9IGZ1bmN0aW9uKGFyZ3VtZW50KSB7CiAgICAgICAgaWYgKCFpc0NhbGxhYmxlKGFyZ3VtZW50KSkKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICBzd2l0Y2ggKGNsYXNzb2YoYXJndW1lbnQpKSB7CiAgICAgICAgICBjYXNlICJBc3luY0Z1bmN0aW9uIjoKICAgICAgICAgIGNhc2UgIkdlbmVyYXRvckZ1bmN0aW9uIjoKICAgICAgICAgIGNhc2UgIkFzeW5jR2VuZXJhdG9yRnVuY3Rpb24iOgogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIHJldHVybiBJTkNPUlJFQ1RfVE9fU1RSSU5HIHx8ICEhZXhlYy5jYWxsKGNvbnN0cnVjdG9yUmVnRXhwLCBpbnNwZWN0U291cmNlKGFyZ3VtZW50KSk7CiAgICAgIH07CiAgICAgIG1vZHVsZS5leHBvcnRzID0gIWNvbnN0cnVjdCB8fCBmYWlscyhmdW5jdGlvbigpIHsKICAgICAgICB2YXIgY2FsbGVkOwogICAgICAgIHJldHVybiBpc0NvbnN0cnVjdG9yTW9kZXJuKGlzQ29uc3RydWN0b3JNb2Rlcm4uY2FsbCkgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oT2JqZWN0KSB8fCAhaXNDb25zdHJ1Y3Rvck1vZGVybihmdW5jdGlvbigpIHsKICAgICAgICAgIGNhbGxlZCA9IHRydWU7CiAgICAgICAgfSkgfHwgY2FsbGVkOwogICAgICB9KSA/IGlzQ29uc3RydWN0b3JMZWdhY3kgOiBpc0NvbnN0cnVjdG9yTW9kZXJuOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzCiAgdmFyIHJlcXVpcmVfYXJyYXlfc3BlY2llc19jb25zdHJ1Y3RvciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBpc0FycmF5ID0gcmVxdWlyZV9pc19hcnJheSgpOwogICAgICB2YXIgaXNDb25zdHJ1Y3RvciA9IHJlcXVpcmVfaXNfY29uc3RydWN0b3IoKTsKICAgICAgdmFyIGlzT2JqZWN0ID0gcmVxdWlyZV9pc19vYmplY3QoKTsKICAgICAgdmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmVfd2VsbF9rbm93bl9zeW1ib2woKTsKICAgICAgdmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woInNwZWNpZXMiKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbEFycmF5KSB7CiAgICAgICAgdmFyIEM7CiAgICAgICAgaWYgKGlzQXJyYXkob3JpZ2luYWxBcnJheSkpIHsKICAgICAgICAgIEMgPSBvcmlnaW5hbEFycmF5LmNvbnN0cnVjdG9yOwogICAgICAgICAgaWYgKGlzQ29uc3RydWN0b3IoQykgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkKICAgICAgICAgICAgQyA9IHZvaWQgMDsKICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KEMpKSB7CiAgICAgICAgICAgIEMgPSBDW1NQRUNJRVNdOwogICAgICAgICAgICBpZiAoQyA9PT0gbnVsbCkKICAgICAgICAgICAgICBDID0gdm9pZCAwOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gQyA9PT0gdm9pZCAwID8gQXJyYXkgOiBDOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcwogIHZhciByZXF1aXJlX2FycmF5X3NwZWNpZXNfY3JlYXRlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBhcnJheVNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmVfYXJyYXlfc3BlY2llc19jb25zdHJ1Y3RvcigpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsQXJyYXksIGxlbmd0aCkgewogICAgICAgIHJldHVybiBuZXcgKGFycmF5U3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsQXJyYXkpKShsZW5ndGggPT09IDAgPyAwIDogbGVuZ3RoKTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQuanMKICB2YXIgcmVxdWlyZV9hcnJheV9tZXRob2RfaGFzX3NwZWNpZXNfc3VwcG9ydCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgZmFpbHMgPSByZXF1aXJlX2ZhaWxzKCk7CiAgICAgIHZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlX3dlbGxfa25vd25fc3ltYm9sKCk7CiAgICAgIHZhciBWOF9WRVJTSU9OID0gcmVxdWlyZV9lbmdpbmVfdjhfdmVyc2lvbigpOwogICAgICB2YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgic3BlY2llcyIpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE1FVEhPRF9OQU1FKSB7CiAgICAgICAgcmV0dXJuIFY4X1ZFUlNJT04gPj0gNTEgfHwgIWZhaWxzKGZ1bmN0aW9uKCkgewogICAgICAgICAgdmFyIGFycmF5ID0gW107CiAgICAgICAgICB2YXIgY29uc3RydWN0b3IgPSBhcnJheS5jb25zdHJ1Y3RvciA9IHt9OwogICAgICAgICAgY29uc3RydWN0b3JbU1BFQ0lFU10gPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgcmV0dXJuIHsgZm9vOiAxIH07CiAgICAgICAgICB9OwogICAgICAgICAgcmV0dXJuIGFycmF5W01FVEhPRF9OQU1FXShCb29sZWFuKS5mb28gIT09IDE7CiAgICAgICAgfSk7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5hcnJheS5jb25jYXQuanMKICB2YXIgcmVxdWlyZV9lc19hcnJheV9jb25jYXQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0LmpzIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciAkID0gcmVxdWlyZV9leHBvcnQoKTsKICAgICAgdmFyIGZhaWxzID0gcmVxdWlyZV9mYWlscygpOwogICAgICB2YXIgaXNBcnJheSA9IHJlcXVpcmVfaXNfYXJyYXkoKTsKICAgICAgdmFyIGlzT2JqZWN0ID0gcmVxdWlyZV9pc19vYmplY3QoKTsKICAgICAgdmFyIHRvT2JqZWN0ID0gcmVxdWlyZV90b19vYmplY3QoKTsKICAgICAgdmFyIHRvTGVuZ3RoID0gcmVxdWlyZV90b19sZW5ndGgoKTsKICAgICAgdmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZV9jcmVhdGVfcHJvcGVydHkoKTsKICAgICAgdmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IHJlcXVpcmVfYXJyYXlfc3BlY2llc19jcmVhdGUoKTsKICAgICAgdmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQgPSByZXF1aXJlX2FycmF5X21ldGhvZF9oYXNfc3BlY2llc19zdXBwb3J0KCk7CiAgICAgIHZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlX3dlbGxfa25vd25fc3ltYm9sKCk7CiAgICAgIHZhciBWOF9WRVJTSU9OID0gcmVxdWlyZV9lbmdpbmVfdjhfdmVyc2lvbigpOwogICAgICB2YXIgSVNfQ09OQ0FUX1NQUkVBREFCTEUgPSB3ZWxsS25vd25TeW1ib2woImlzQ29uY2F0U3ByZWFkYWJsZSIpOwogICAgICB2YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7CiAgICAgIHZhciBNQVhJTVVNX0FMTE9XRURfSU5ERVhfRVhDRUVERUQgPSAiTWF4aW11bSBhbGxvd2VkIGluZGV4IGV4Y2VlZGVkIjsKICAgICAgdmFyIElTX0NPTkNBVF9TUFJFQURBQkxFX1NVUFBPUlQgPSBWOF9WRVJTSU9OID49IDUxIHx8ICFmYWlscyhmdW5jdGlvbigpIHsKICAgICAgICB2YXIgYXJyYXkgPSBbXTsKICAgICAgICBhcnJheVtJU19DT05DQVRfU1BSRUFEQUJMRV0gPSBmYWxzZTsKICAgICAgICByZXR1cm4gYXJyYXkuY29uY2F0KClbMF0gIT09IGFycmF5OwogICAgICB9KTsKICAgICAgdmFyIFNQRUNJRVNfU1VQUE9SVCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQoImNvbmNhdCIpOwogICAgICB2YXIgaXNDb25jYXRTcHJlYWRhYmxlID0gZnVuY3Rpb24oTykgewogICAgICAgIGlmICghaXNPYmplY3QoTykpCiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgdmFyIHNwcmVhZGFibGUgPSBPW0lTX0NPTkNBVF9TUFJFQURBQkxFXTsKICAgICAgICByZXR1cm4gc3ByZWFkYWJsZSAhPT0gdm9pZCAwID8gISFzcHJlYWRhYmxlIDogaXNBcnJheShPKTsKICAgICAgfTsKICAgICAgdmFyIEZPUkNFRCA9ICFJU19DT05DQVRfU1BSRUFEQUJMRV9TVVBQT1JUIHx8ICFTUEVDSUVTX1NVUFBPUlQ7CiAgICAgICQoeyB0YXJnZXQ6ICJBcnJheSIsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7CiAgICAgICAgY29uY2F0OiBmdW5jdGlvbiBjb25jYXQoYXJnKSB7CiAgICAgICAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpOwogICAgICAgICAgdmFyIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUoTywgMCk7CiAgICAgICAgICB2YXIgbiA9IDA7CiAgICAgICAgICB2YXIgaSwgaywgbGVuZ3RoLCBsZW4sIEU7CiAgICAgICAgICBmb3IgKGkgPSAtMSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIEUgPSBpID09PSAtMSA/IE8gOiBhcmd1bWVudHNbaV07CiAgICAgICAgICAgIGlmIChpc0NvbmNhdFNwcmVhZGFibGUoRSkpIHsKICAgICAgICAgICAgICBsZW4gPSB0b0xlbmd0aChFLmxlbmd0aCk7CiAgICAgICAgICAgICAgaWYgKG4gKyBsZW4gPiBNQVhfU0FGRV9JTlRFR0VSKQogICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKE1BWElNVU1fQUxMT1dFRF9JTkRFWF9FWENFRURFRCk7CiAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGxlbjsgaysrLCBuKyspCiAgICAgICAgICAgICAgICBpZiAoayBpbiBFKQogICAgICAgICAgICAgICAgICBjcmVhdGVQcm9wZXJ0eShBLCBuLCBFW2tdKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBpZiAobiA+PSBNQVhfU0FGRV9JTlRFR0VSKQogICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKE1BWElNVU1fQUxMT1dFRF9JTkRFWF9FWENFRURFRCk7CiAgICAgICAgICAgICAgY3JlYXRlUHJvcGVydHkoQSwgbisrLCBFKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgQS5sZW5ndGggPSBuOwogICAgICAgICAgcmV0dXJuIEE7CiAgICAgICAgfQogICAgICB9KTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMKICB2YXIgcmVxdWlyZV9lc19vYmplY3RfdG9fc3RyaW5nID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzCiAgdmFyIHJlcXVpcmVfb2JqZWN0X2dldF9vd25fcHJvcGVydHlfbmFtZXMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBpbnRlcm5hbE9iamVjdEtleXMgPSByZXF1aXJlX29iamVjdF9rZXlzX2ludGVybmFsKCk7CiAgICAgIHZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmVfZW51bV9idWdfa2V5cygpOwogICAgICB2YXIgaGlkZGVuS2V5cyA9IGVudW1CdWdLZXlzLmNvbmNhdCgibGVuZ3RoIiwgInByb3RvdHlwZSIpOwogICAgICBleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHsKICAgICAgICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGhpZGRlbktleXMpOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy1leHRlcm5hbC5qcwogIHZhciByZXF1aXJlX29iamVjdF9nZXRfb3duX3Byb3BlcnR5X25hbWVzX2V4dGVybmFsID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMtZXh0ZXJuYWwuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlX3RvX2luZGV4ZWRfb2JqZWN0KCk7CiAgICAgIHZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IHJlcXVpcmVfb2JqZWN0X2dldF9vd25fcHJvcGVydHlfbmFtZXMoKS5mOwogICAgICB2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZzsKICAgICAgdmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAib2JqZWN0IiAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107CiAgICAgIHZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uKGl0KSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlOYW1lcyhpdCk7CiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpOwogICAgICAgIH0KICAgICAgfTsKICAgICAgbW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHsKICAgICAgICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gIltvYmplY3QgV2luZG93XSIgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiAkZ2V0T3duUHJvcGVydHlOYW1lcyh0b0luZGV4ZWRPYmplY3QoaXQpKTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scy5qcwogIHZhciByZXF1aXJlX29iamVjdF9nZXRfb3duX3Byb3BlcnR5X3N5bWJvbHMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sczsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtd3JhcHBlZC5qcwogIHZhciByZXF1aXJlX3dlbGxfa25vd25fc3ltYm9sX3dyYXBwZWQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC13cmFwcGVkLmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmVfd2VsbF9rbm93bl9zeW1ib2woKTsKICAgICAgZXhwb3J0cy5mID0gd2VsbEtub3duU3ltYm9sOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wuanMKICB2YXIgcmVxdWlyZV9kZWZpbmVfd2VsbF9rbm93bl9zeW1ib2wgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBwYXRoID0gcmVxdWlyZV9wYXRoKCk7CiAgICAgIHZhciBoYXMgPSByZXF1aXJlX2hhcygpOwogICAgICB2YXIgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSA9IHJlcXVpcmVfd2VsbF9rbm93bl9zeW1ib2xfd3JhcHBlZCgpOwogICAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlX29iamVjdF9kZWZpbmVfcHJvcGVydHkoKS5mOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUpIHsKICAgICAgICB2YXIgU3ltYm9sMiA9IHBhdGguU3ltYm9sIHx8IChwYXRoLlN5bWJvbCA9IHt9KTsKICAgICAgICBpZiAoIWhhcyhTeW1ib2wyLCBOQU1FKSkKICAgICAgICAgIGRlZmluZVByb3BlcnR5KFN5bWJvbDIsIE5BTUUsIHsKICAgICAgICAgICAgdmFsdWU6IHdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUuZihOQU1FKQogICAgICAgICAgfSk7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbi5qcwogIHZhciByZXF1aXJlX2FycmF5X2l0ZXJhdGlvbiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbi5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGJpbmQgPSByZXF1aXJlX2Z1bmN0aW9uX2JpbmRfY29udGV4dCgpOwogICAgICB2YXIgSW5kZXhlZE9iamVjdCA9IHJlcXVpcmVfaW5kZXhlZF9vYmplY3QoKTsKICAgICAgdmFyIHRvT2JqZWN0ID0gcmVxdWlyZV90b19vYmplY3QoKTsKICAgICAgdmFyIHRvTGVuZ3RoID0gcmVxdWlyZV90b19sZW5ndGgoKTsKICAgICAgdmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IHJlcXVpcmVfYXJyYXlfc3BlY2llc19jcmVhdGUoKTsKICAgICAgdmFyIHB1c2ggPSBbXS5wdXNoOwogICAgICB2YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24oVFlQRSkgewogICAgICAgIHZhciBJU19NQVAgPSBUWVBFID09IDE7CiAgICAgICAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjsKICAgICAgICB2YXIgSVNfU09NRSA9IFRZUEUgPT0gMzsKICAgICAgICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7CiAgICAgICAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7CiAgICAgICAgdmFyIElTX0ZJTFRFUl9SRUpFQ1QgPSBUWVBFID09IDc7CiAgICAgICAgdmFyIE5PX0hPTEVTID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVg7CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0LCBzcGVjaWZpY0NyZWF0ZSkgewogICAgICAgICAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7CiAgICAgICAgICB2YXIgc2VsZjIgPSBJbmRleGVkT2JqZWN0KE8pOwogICAgICAgICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGNhbGxiYWNrZm4sIHRoYXQsIDMpOwogICAgICAgICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYyLmxlbmd0aCk7CiAgICAgICAgICB2YXIgaW5kZXggPSAwOwogICAgICAgICAgdmFyIGNyZWF0ZSA9IHNwZWNpZmljQ3JlYXRlIHx8IGFycmF5U3BlY2llc0NyZWF0ZTsKICAgICAgICAgIHZhciB0YXJnZXQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgfHwgSVNfRklMVEVSX1JFSkVDVCA/IGNyZWF0ZSgkdGhpcywgMCkgOiB2b2lkIDA7CiAgICAgICAgICB2YXIgdmFsdWUsIHJlc3VsdDsKICAgICAgICAgIGZvciAoOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykKICAgICAgICAgICAgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYyKSB7CiAgICAgICAgICAgICAgdmFsdWUgPSBzZWxmMltpbmRleF07CiAgICAgICAgICAgICAgcmVzdWx0ID0gYm91bmRGdW5jdGlvbih2YWx1ZSwgaW5kZXgsIE8pOwogICAgICAgICAgICAgIGlmIChUWVBFKSB7CiAgICAgICAgICAgICAgICBpZiAoSVNfTUFQKQogICAgICAgICAgICAgICAgICB0YXJnZXRbaW5kZXhdID0gcmVzdWx0OwogICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0KQogICAgICAgICAgICAgICAgICBzd2l0Y2ggKFRZUEUpIHsKICAgICAgICAgICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDU6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4OwogICAgICAgICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgICAgICAgIHB1c2guY2FsbCh0YXJnZXQsIHZhbHVlKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICAgICBzd2l0Y2ggKFRZUEUpIHsKICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OgogICAgICAgICAgICAgICAgICAgICAgcHVzaC5jYWxsKHRhcmdldCwgdmFsdWUpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogdGFyZ2V0OwogICAgICAgIH07CiAgICAgIH07CiAgICAgIG1vZHVsZS5leHBvcnRzID0gewogICAgICAgIGZvckVhY2g6IGNyZWF0ZU1ldGhvZCgwKSwKICAgICAgICBtYXA6IGNyZWF0ZU1ldGhvZCgxKSwKICAgICAgICBmaWx0ZXI6IGNyZWF0ZU1ldGhvZCgyKSwKICAgICAgICBzb21lOiBjcmVhdGVNZXRob2QoMyksCiAgICAgICAgZXZlcnk6IGNyZWF0ZU1ldGhvZCg0KSwKICAgICAgICBmaW5kOiBjcmVhdGVNZXRob2QoNSksCiAgICAgICAgZmluZEluZGV4OiBjcmVhdGVNZXRob2QoNiksCiAgICAgICAgZmlsdGVyUmVqZWN0OiBjcmVhdGVNZXRob2QoNykKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC5qcwogIHZhciByZXF1aXJlX2VzX3N5bWJvbCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5zeW1ib2wuanMiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyICQgPSByZXF1aXJlX2V4cG9ydCgpOwogICAgICB2YXIgZ2xvYmFsMiA9IHJlcXVpcmVfZ2xvYmFsKCk7CiAgICAgIHZhciBnZXRCdWlsdEluID0gcmVxdWlyZV9nZXRfYnVpbHRfaW4oKTsKICAgICAgdmFyIElTX1BVUkUgPSByZXF1aXJlX2lzX3B1cmUoKTsKICAgICAgdmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZV9kZXNjcmlwdG9ycygpOwogICAgICB2YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmVfbmF0aXZlX3N5bWJvbCgpOwogICAgICB2YXIgZmFpbHMgPSByZXF1aXJlX2ZhaWxzKCk7CiAgICAgIHZhciBoYXMgPSByZXF1aXJlX2hhcygpOwogICAgICB2YXIgaXNBcnJheSA9IHJlcXVpcmVfaXNfYXJyYXkoKTsKICAgICAgdmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlX2lzX2NhbGxhYmxlKCk7CiAgICAgIHZhciBpc09iamVjdCA9IHJlcXVpcmVfaXNfb2JqZWN0KCk7CiAgICAgIHZhciBpc1N5bWJvbCA9IHJlcXVpcmVfaXNfc3ltYm9sKCk7CiAgICAgIHZhciBhbk9iamVjdCA9IHJlcXVpcmVfYW5fb2JqZWN0KCk7CiAgICAgIHZhciB0b09iamVjdCA9IHJlcXVpcmVfdG9fb2JqZWN0KCk7CiAgICAgIHZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlX3RvX2luZGV4ZWRfb2JqZWN0KCk7CiAgICAgIHZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZV90b19wcm9wZXJ0eV9rZXkoKTsKICAgICAgdmFyICR0b1N0cmluZyA9IHJlcXVpcmVfdG9fc3RyaW5nKCk7CiAgICAgIHZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlX2NyZWF0ZV9wcm9wZXJ0eV9kZXNjcmlwdG9yKCk7CiAgICAgIHZhciBuYXRpdmVPYmplY3RDcmVhdGUgPSByZXF1aXJlX29iamVjdF9jcmVhdGUoKTsKICAgICAgdmFyIG9iamVjdEtleXMgPSByZXF1aXJlX29iamVjdF9rZXlzKCk7CiAgICAgIHZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gcmVxdWlyZV9vYmplY3RfZ2V0X293bl9wcm9wZXJ0eV9uYW1lcygpOwogICAgICB2YXIgZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsID0gcmVxdWlyZV9vYmplY3RfZ2V0X293bl9wcm9wZXJ0eV9uYW1lc19leHRlcm5hbCgpOwogICAgICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gcmVxdWlyZV9vYmplY3RfZ2V0X293bl9wcm9wZXJ0eV9zeW1ib2xzKCk7CiAgICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSByZXF1aXJlX29iamVjdF9nZXRfb3duX3Byb3BlcnR5X2Rlc2NyaXB0b3IoKTsKICAgICAgdmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZV9vYmplY3RfZGVmaW5lX3Byb3BlcnR5KCk7CiAgICAgIHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IHJlcXVpcmVfb2JqZWN0X3Byb3BlcnR5X2lzX2VudW1lcmFibGUoKTsKICAgICAgdmFyIHJlZGVmaW5lID0gcmVxdWlyZV9yZWRlZmluZSgpOwogICAgICB2YXIgc2hhcmVkID0gcmVxdWlyZV9zaGFyZWQoKTsKICAgICAgdmFyIHNoYXJlZEtleSA9IHJlcXVpcmVfc2hhcmVkX2tleSgpOwogICAgICB2YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmVfaGlkZGVuX2tleXMoKTsKICAgICAgdmFyIHVpZCA9IHJlcXVpcmVfdWlkKCk7CiAgICAgIHZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlX3dlbGxfa25vd25fc3ltYm9sKCk7CiAgICAgIHZhciB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlID0gcmVxdWlyZV93ZWxsX2tub3duX3N5bWJvbF93cmFwcGVkKCk7CiAgICAgIHZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlX2RlZmluZV93ZWxsX2tub3duX3N5bWJvbCgpOwogICAgICB2YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlX3NldF90b19zdHJpbmdfdGFnKCk7CiAgICAgIHZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZV9pbnRlcm5hbF9zdGF0ZSgpOwogICAgICB2YXIgJGZvckVhY2ggPSByZXF1aXJlX2FycmF5X2l0ZXJhdGlvbigpLmZvckVhY2g7CiAgICAgIHZhciBISURERU4gPSBzaGFyZWRLZXkoImhpZGRlbiIpOwogICAgICB2YXIgU1lNQk9MID0gIlN5bWJvbCI7CiAgICAgIHZhciBQUk9UT1RZUEUgPSAicHJvdG90eXBlIjsKICAgICAgdmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCgidG9QcmltaXRpdmUiKTsKICAgICAgdmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDsKICAgICAgdmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihTWU1CT0wpOwogICAgICB2YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0W1BST1RPVFlQRV07CiAgICAgIHZhciAkU3ltYm9sID0gZ2xvYmFsMi5TeW1ib2w7CiAgICAgIHZhciAkc3RyaW5naWZ5ID0gZ2V0QnVpbHRJbigiSlNPTiIsICJzdHJpbmdpZnkiKTsKICAgICAgdmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mOwogICAgICB2YXIgbmF0aXZlRGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mOwogICAgICB2YXIgbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyA9IGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbC5mOwogICAgICB2YXIgbmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mOwogICAgICB2YXIgQWxsU3ltYm9scyA9IHNoYXJlZCgic3ltYm9scyIpOwogICAgICB2YXIgT2JqZWN0UHJvdG90eXBlU3ltYm9scyA9IHNoYXJlZCgib3Atc3ltYm9scyIpOwogICAgICB2YXIgU3RyaW5nVG9TeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgic3RyaW5nLXRvLXN5bWJvbC1yZWdpc3RyeSIpOwogICAgICB2YXIgU3ltYm9sVG9TdHJpbmdSZWdpc3RyeSA9IHNoYXJlZCgic3ltYm9sLXRvLXN0cmluZy1yZWdpc3RyeSIpOwogICAgICB2YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkKCJ3a3MiKTsKICAgICAgdmFyIFFPYmplY3QgPSBnbG9iYWwyLlFPYmplY3Q7CiAgICAgIHZhciBVU0VfU0VUVEVSID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDsKICAgICAgdmFyIHNldFN5bWJvbERlc2NyaXB0b3IgPSBERVNDUklQVE9SUyAmJiBmYWlscyhmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gbmF0aXZlT2JqZWN0Q3JlYXRlKG5hdGl2ZURlZmluZVByb3BlcnR5KHt9LCAiYSIsIHsKICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eSh0aGlzLCAiYSIsIHsgdmFsdWU6IDcgfSkuYTsKICAgICAgICAgIH0KICAgICAgICB9KSkuYSAhPSA3OwogICAgICB9KSA/IGZ1bmN0aW9uKE8sIFAsIEF0dHJpYnV0ZXMpIHsKICAgICAgICB2YXIgT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvciA9IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3RQcm90b3R5cGUsIFApOwogICAgICAgIGlmIChPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yKQogICAgICAgICAgZGVsZXRlIE9iamVjdFByb3RvdHlwZVtQXTsKICAgICAgICBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTsKICAgICAgICBpZiAoT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvciAmJiBPICE9PSBPYmplY3RQcm90b3R5cGUpIHsKICAgICAgICAgIG5hdGl2ZURlZmluZVByb3BlcnR5KE9iamVjdFByb3RvdHlwZSwgUCwgT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvcik7CiAgICAgICAgfQogICAgICB9IDogbmF0aXZlRGVmaW5lUHJvcGVydHk7CiAgICAgIHZhciB3cmFwID0gZnVuY3Rpb24odGFnLCBkZXNjcmlwdGlvbikgewogICAgICAgIHZhciBzeW1ib2wgPSBBbGxTeW1ib2xzW3RhZ10gPSBuYXRpdmVPYmplY3RDcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTsKICAgICAgICBzZXRJbnRlcm5hbFN0YXRlKHN5bWJvbCwgewogICAgICAgICAgdHlwZTogU1lNQk9MLAogICAgICAgICAgdGFnLAogICAgICAgICAgZGVzY3JpcHRpb24KICAgICAgICB9KTsKICAgICAgICBpZiAoIURFU0NSSVBUT1JTKQogICAgICAgICAgc3ltYm9sLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247CiAgICAgICAgcmV0dXJuIHN5bWJvbDsKICAgICAgfTsKICAgICAgdmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHsKICAgICAgICBpZiAoTyA9PT0gT2JqZWN0UHJvdG90eXBlKQogICAgICAgICAgJGRlZmluZVByb3BlcnR5KE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIFAsIEF0dHJpYnV0ZXMpOwogICAgICAgIGFuT2JqZWN0KE8pOwogICAgICAgIHZhciBrZXkgPSB0b1Byb3BlcnR5S2V5KFApOwogICAgICAgIGFuT2JqZWN0KEF0dHJpYnV0ZXMpOwogICAgICAgIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSkgewogICAgICAgICAgaWYgKCFBdHRyaWJ1dGVzLmVudW1lcmFibGUpIHsKICAgICAgICAgICAgaWYgKCFoYXMoTywgSElEREVOKSkKICAgICAgICAgICAgICBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBISURERU4sIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB7fSkpOwogICAgICAgICAgICBPW0hJRERFTl1ba2V5XSA9IHRydWU7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBpZiAoaGFzKE8sIEhJRERFTikgJiYgT1tISURERU5dW2tleV0pCiAgICAgICAgICAgICAgT1tISURERU5dW2tleV0gPSBmYWxzZTsKICAgICAgICAgICAgQXR0cmlidXRlcyA9IG5hdGl2ZU9iamVjdENyZWF0ZShBdHRyaWJ1dGVzLCB7IGVudW1lcmFibGU6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCBmYWxzZSkgfSk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gc2V0U3ltYm9sRGVzY3JpcHRvcihPLCBrZXksIEF0dHJpYnV0ZXMpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkoTywga2V5LCBBdHRyaWJ1dGVzKTsKICAgICAgfTsKICAgICAgdmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7CiAgICAgICAgYW5PYmplY3QoTyk7CiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB0b0luZGV4ZWRPYmplY3QoUHJvcGVydGllcyk7CiAgICAgICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKHByb3BlcnRpZXMpLmNvbmNhdCgkZ2V0T3duUHJvcGVydHlTeW1ib2xzKHByb3BlcnRpZXMpKTsKICAgICAgICAkZm9yRWFjaChrZXlzLCBmdW5jdGlvbihrZXkpIHsKICAgICAgICAgIGlmICghREVTQ1JJUFRPUlMgfHwgJHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocHJvcGVydGllcywga2V5KSkKICAgICAgICAgICAgJGRlZmluZVByb3BlcnR5KE8sIGtleSwgcHJvcGVydGllc1trZXldKTsKICAgICAgICB9KTsKICAgICAgICByZXR1cm4gTzsKICAgICAgfTsKICAgICAgdmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykgewogICAgICAgIHJldHVybiBQcm9wZXJ0aWVzID09PSB2b2lkIDAgPyBuYXRpdmVPYmplY3RDcmVhdGUoTykgOiAkZGVmaW5lUHJvcGVydGllcyhuYXRpdmVPYmplY3RDcmVhdGUoTyksIFByb3BlcnRpZXMpOwogICAgICB9OwogICAgICB2YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikgewogICAgICAgIHZhciBQID0gdG9Qcm9wZXJ0eUtleShWKTsKICAgICAgICB2YXIgZW51bWVyYWJsZSA9IG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodGhpcywgUCk7CiAgICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvdHlwZSAmJiBoYXMoQWxsU3ltYm9scywgUCkgJiYgIWhhcyhPYmplY3RQcm90b3R5cGVTeW1ib2xzLCBQKSkKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICByZXR1cm4gZW51bWVyYWJsZSB8fCAhaGFzKHRoaXMsIFApIHx8ICFoYXMoQWxsU3ltYm9scywgUCkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW1BdID8gZW51bWVyYWJsZSA6IHRydWU7CiAgICAgIH07CiAgICAgIHZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHsKICAgICAgICB2YXIgaXQgPSB0b0luZGV4ZWRPYmplY3QoTyk7CiAgICAgICAgdmFyIGtleSA9IHRvUHJvcGVydHlLZXkoUCk7CiAgICAgICAgaWYgKGl0ID09PSBPYmplY3RQcm90b3R5cGUgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPYmplY3RQcm90b3R5cGVTeW1ib2xzLCBrZXkpKQogICAgICAgICAgcmV0dXJuOwogICAgICAgIHZhciBkZXNjcmlwdG9yID0gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpOwogICAgICAgIGlmIChkZXNjcmlwdG9yICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIHsKICAgICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IHRydWU7CiAgICAgICAgfQogICAgICAgIHJldHVybiBkZXNjcmlwdG9yOwogICAgICB9OwogICAgICB2YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHsKICAgICAgICB2YXIgbmFtZXMgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzKHRvSW5kZXhlZE9iamVjdChPKSk7CiAgICAgICAgdmFyIHJlc3VsdCA9IFtdOwogICAgICAgICRmb3JFYWNoKG5hbWVzLCBmdW5jdGlvbihrZXkpIHsKICAgICAgICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhoaWRkZW5LZXlzLCBrZXkpKQogICAgICAgICAgICByZXN1bHQucHVzaChrZXkpOwogICAgICAgIH0pOwogICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgIH07CiAgICAgIHZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pIHsKICAgICAgICB2YXIgSVNfT0JKRUNUX1BST1RPVFlQRSA9IE8gPT09IE9iamVjdFByb3RvdHlwZTsKICAgICAgICB2YXIgbmFtZXMgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzKElTX09CSkVDVF9QUk9UT1RZUEUgPyBPYmplY3RQcm90b3R5cGVTeW1ib2xzIDogdG9JbmRleGVkT2JqZWN0KE8pKTsKICAgICAgICB2YXIgcmVzdWx0ID0gW107CiAgICAgICAgJGZvckVhY2gobmFtZXMsIGZ1bmN0aW9uKGtleSkgewogICAgICAgICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICghSVNfT0JKRUNUX1BST1RPVFlQRSB8fCBoYXMoT2JqZWN0UHJvdG90eXBlLCBrZXkpKSkgewogICAgICAgICAgICByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pOwogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgIH07CiAgICAgIGlmICghTkFUSVZFX1NZTUJPTCkgewogICAgICAgICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2wyKCkgewogICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKQogICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoIlN5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciIpOwogICAgICAgICAgdmFyIGRlc2NyaXB0aW9uID0gIWFyZ3VtZW50cy5sZW5ndGggfHwgYXJndW1lbnRzWzBdID09PSB2b2lkIDAgPyB2b2lkIDAgOiAkdG9TdHJpbmcoYXJndW1lbnRzWzBdKTsKICAgICAgICAgIHZhciB0YWcgPSB1aWQoZGVzY3JpcHRpb24pOwogICAgICAgICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uKHZhbHVlKSB7CiAgICAgICAgICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90b3R5cGUpCiAgICAgICAgICAgICAgc2V0dGVyLmNhbGwoT2JqZWN0UHJvdG90eXBlU3ltYm9scywgdmFsdWUpOwogICAgICAgICAgICBpZiAoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSkKICAgICAgICAgICAgICB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlOwogICAgICAgICAgICBzZXRTeW1ib2xEZXNjcmlwdG9yKHRoaXMsIHRhZywgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7CiAgICAgICAgICB9OwogICAgICAgICAgaWYgKERFU0NSSVBUT1JTICYmIFVTRV9TRVRURVIpCiAgICAgICAgICAgIHNldFN5bWJvbERlc2NyaXB0b3IoT2JqZWN0UHJvdG90eXBlLCB0YWcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IHNldHRlciB9KTsKICAgICAgICAgIHJldHVybiB3cmFwKHRhZywgZGVzY3JpcHRpb24pOwogICAgICAgIH07CiAgICAgICAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAidG9TdHJpbmciLCBmdW5jdGlvbiB0b1N0cmluZygpIHsKICAgICAgICAgIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnRhZzsKICAgICAgICB9KTsKICAgICAgICByZWRlZmluZSgkU3ltYm9sLCAid2l0aG91dFNldHRlciIsIGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7CiAgICAgICAgICByZXR1cm4gd3JhcCh1aWQoZGVzY3JpcHRpb24pLCBkZXNjcmlwdGlvbik7CiAgICAgICAgfSk7CiAgICAgICAgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTsKICAgICAgICBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mID0gJGRlZmluZVByb3BlcnR5OwogICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjsKICAgICAgICBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzOwogICAgICAgIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mID0gJGdldE93blByb3BlcnR5U3ltYm9sczsKICAgICAgICB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlLmYgPSBmdW5jdGlvbihuYW1lKSB7CiAgICAgICAgICByZXR1cm4gd3JhcCh3ZWxsS25vd25TeW1ib2wobmFtZSksIG5hbWUpOwogICAgICAgIH07CiAgICAgICAgaWYgKERFU0NSSVBUT1JTKSB7CiAgICAgICAgICBuYXRpdmVEZWZpbmVQcm9wZXJ0eSgkU3ltYm9sW1BST1RPVFlQRV0sICJkZXNjcmlwdGlvbiIsIHsKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkgewogICAgICAgICAgICAgIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLmRlc2NyaXB0aW9uOwogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICAgIGlmICghSVNfUFVSRSkgewogICAgICAgICAgICByZWRlZmluZShPYmplY3RQcm90b3R5cGUsICJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgeyB1bnNhZmU6IHRydWUgfSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgICQoeyBnbG9iYWw6IHRydWUsIHdyYXA6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0wsIHNoYW06ICFOQVRJVkVfU1lNQk9MIH0sIHsKICAgICAgICBTeW1ib2w6ICRTeW1ib2wKICAgICAgfSk7CiAgICAgICRmb3JFYWNoKG9iamVjdEtleXMoV2VsbEtub3duU3ltYm9sc1N0b3JlKSwgZnVuY3Rpb24obmFtZSkgewogICAgICAgIGRlZmluZVdlbGxLbm93blN5bWJvbChuYW1lKTsKICAgICAgfSk7CiAgICAgICQoeyB0YXJnZXQ6IFNZTUJPTCwgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCB9LCB7CiAgICAgICAgImZvciI6IGZ1bmN0aW9uKGtleSkgewogICAgICAgICAgdmFyIHN0cmluZyA9ICR0b1N0cmluZyhrZXkpOwogICAgICAgICAgaWYgKGhhcyhTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5LCBzdHJpbmcpKQogICAgICAgICAgICByZXR1cm4gU3RyaW5nVG9TeW1ib2xSZWdpc3RyeVtzdHJpbmddOwogICAgICAgICAgdmFyIHN5bWJvbCA9ICRTeW1ib2woc3RyaW5nKTsKICAgICAgICAgIFN0cmluZ1RvU3ltYm9sUmVnaXN0cnlbc3RyaW5nXSA9IHN5bWJvbDsKICAgICAgICAgIFN5bWJvbFRvU3RyaW5nUmVnaXN0cnlbc3ltYm9sXSA9IHN0cmluZzsKICAgICAgICAgIHJldHVybiBzeW1ib2w7CiAgICAgICAgfSwKICAgICAgICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihzeW0pIHsKICAgICAgICAgIGlmICghaXNTeW1ib2woc3ltKSkKICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKHN5bSArICIgaXMgbm90IGEgc3ltYm9sIik7CiAgICAgICAgICBpZiAoaGFzKFN5bWJvbFRvU3RyaW5nUmVnaXN0cnksIHN5bSkpCiAgICAgICAgICAgIHJldHVybiBTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5W3N5bV07CiAgICAgICAgfSwKICAgICAgICB1c2VTZXR0ZXI6IGZ1bmN0aW9uKCkgewogICAgICAgICAgVVNFX1NFVFRFUiA9IHRydWU7CiAgICAgICAgfSwKICAgICAgICB1c2VTaW1wbGU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgVVNFX1NFVFRFUiA9IGZhbHNlOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgICQoeyB0YXJnZXQ6ICJPYmplY3QiLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MLCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwgewogICAgICAgIGNyZWF0ZTogJGNyZWF0ZSwKICAgICAgICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LAogICAgICAgIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLAogICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcgogICAgICB9KTsKICAgICAgJCh7IHRhcmdldDogIk9iamVjdCIsIHN0YXQ6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0wgfSwgewogICAgICAgIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLAogICAgICAgIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9scwogICAgICB9KTsKICAgICAgJCh7IHRhcmdldDogIk9iamVjdCIsIHN0YXQ6IHRydWUsIGZvcmNlZDogZmFpbHMoZnVuY3Rpb24oKSB7CiAgICAgICAgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmYoMSk7CiAgICAgIH0pIH0sIHsKICAgICAgICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkgewogICAgICAgICAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mKHRvT2JqZWN0KGl0KSk7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgaWYgKCRzdHJpbmdpZnkpIHsKICAgICAgICBGT1JDRURfSlNPTl9TVFJJTkdJRlkgPSAhTkFUSVZFX1NZTUJPTCB8fCBmYWlscyhmdW5jdGlvbigpIHsKICAgICAgICAgIHZhciBzeW1ib2wgPSAkU3ltYm9sKCk7CiAgICAgICAgICByZXR1cm4gJHN0cmluZ2lmeShbc3ltYm9sXSkgIT0gIltudWxsXSIgfHwgJHN0cmluZ2lmeSh7IGE6IHN5bWJvbCB9KSAhPSAie30iIHx8ICRzdHJpbmdpZnkoT2JqZWN0KHN5bWJvbCkpICE9ICJ7fSI7CiAgICAgICAgfSk7CiAgICAgICAgJCh7IHRhcmdldDogIkpTT04iLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9KU09OX1NUUklOR0lGWSB9LCB7CiAgICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCwgcmVwbGFjZXIsIHNwYWNlKSB7CiAgICAgICAgICAgIHZhciBhcmdzID0gW2l0XTsKICAgICAgICAgICAgdmFyIGluZGV4ID0gMTsKICAgICAgICAgICAgdmFyICRyZXBsYWNlcjsKICAgICAgICAgICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpbmRleCkKICAgICAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2luZGV4KytdKTsKICAgICAgICAgICAgJHJlcGxhY2VyID0gcmVwbGFjZXI7CiAgICAgICAgICAgIGlmICghaXNPYmplY3QocmVwbGFjZXIpICYmIGl0ID09PSB2b2lkIDAgfHwgaXNTeW1ib2woaXQpKQogICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgaWYgKCFpc0FycmF5KHJlcGxhY2VyKSkKICAgICAgICAgICAgICByZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHsKICAgICAgICAgICAgICAgIGlmIChpc0NhbGxhYmxlKCRyZXBsYWNlcikpCiAgICAgICAgICAgICAgICAgIHZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7CiAgICAgICAgICAgICAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkKICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlOwogICAgICAgICAgICAgIH07CiAgICAgICAgICAgIGFyZ3NbMV0gPSByZXBsYWNlcjsKICAgICAgICAgICAgcmV0dXJuICRzdHJpbmdpZnkuYXBwbHkobnVsbCwgYXJncyk7CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgdmFyIEZPUkNFRF9KU09OX1NUUklOR0lGWTsKICAgICAgaWYgKCEkU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSkgewogICAgICAgIHZhbHVlT2YgPSAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZjsKICAgICAgICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgZnVuY3Rpb24oKSB7CiAgICAgICAgICByZXR1cm4gdmFsdWVPZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgIH0pOwogICAgICB9CiAgICAgIHZhciB2YWx1ZU9mOwogICAgICBzZXRUb1N0cmluZ1RhZygkU3ltYm9sLCBTWU1CT0wpOwogICAgICBoaWRkZW5LZXlzW0hJRERFTl0gPSB0cnVlOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzCiAgdmFyIHJlcXVpcmVfZXNfc3ltYm9sX2FzeW5jX2l0ZXJhdG9yID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmVfZGVmaW5lX3dlbGxfa25vd25fc3ltYm9sKCk7CiAgICAgIGRlZmluZVdlbGxLbm93blN5bWJvbCgiYXN5bmNJdGVyYXRvciIpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uLmpzCiAgdmFyIHJlcXVpcmVfZXNfc3ltYm9sX2Rlc2NyaXB0aW9uID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvbi5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC5oYXMtaW5zdGFuY2UuanMKICB2YXIgcmVxdWlyZV9lc19zeW1ib2xfaGFzX2luc3RhbmNlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC5oYXMtaW5zdGFuY2UuanMiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlX2RlZmluZV93ZWxsX2tub3duX3N5bWJvbCgpOwogICAgICBkZWZpbmVXZWxsS25vd25TeW1ib2woImhhc0luc3RhbmNlIik7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5zeW1ib2wuaXMtY29uY2F0LXNwcmVhZGFibGUuanMKICB2YXIgcmVxdWlyZV9lc19zeW1ib2xfaXNfY29uY2F0X3NwcmVhZGFibGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuc3ltYm9sLmlzLWNvbmNhdC1zcHJlYWRhYmxlLmpzIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZV9kZWZpbmVfd2VsbF9rbm93bl9zeW1ib2woKTsKICAgICAgZGVmaW5lV2VsbEtub3duU3ltYm9sKCJpc0NvbmNhdFNwcmVhZGFibGUiKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvci5qcwogIHZhciByZXF1aXJlX2VzX3N5bWJvbF9pdGVyYXRvciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3IuanMiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlX2RlZmluZV93ZWxsX2tub3duX3N5bWJvbCgpOwogICAgICBkZWZpbmVXZWxsS25vd25TeW1ib2woIml0ZXJhdG9yIik7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5zeW1ib2wubWF0Y2guanMKICB2YXIgcmVxdWlyZV9lc19zeW1ib2xfbWF0Y2ggPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuc3ltYm9sLm1hdGNoLmpzIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZV9kZWZpbmVfd2VsbF9rbm93bl9zeW1ib2woKTsKICAgICAgZGVmaW5lV2VsbEtub3duU3ltYm9sKCJtYXRjaCIpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuc3ltYm9sLm1hdGNoLWFsbC5qcwogIHZhciByZXF1aXJlX2VzX3N5bWJvbF9tYXRjaF9hbGwgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuc3ltYm9sLm1hdGNoLWFsbC5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmVfZGVmaW5lX3dlbGxfa25vd25fc3ltYm9sKCk7CiAgICAgIGRlZmluZVdlbGxLbm93blN5bWJvbCgibWF0Y2hBbGwiKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC5yZXBsYWNlLmpzCiAgdmFyIHJlcXVpcmVfZXNfc3ltYm9sX3JlcGxhY2UgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuc3ltYm9sLnJlcGxhY2UuanMiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlX2RlZmluZV93ZWxsX2tub3duX3N5bWJvbCgpOwogICAgICBkZWZpbmVXZWxsS25vd25TeW1ib2woInJlcGxhY2UiKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC5zZWFyY2guanMKICB2YXIgcmVxdWlyZV9lc19zeW1ib2xfc2VhcmNoID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC5zZWFyY2guanMiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlX2RlZmluZV93ZWxsX2tub3duX3N5bWJvbCgpOwogICAgICBkZWZpbmVXZWxsS25vd25TeW1ib2woInNlYXJjaCIpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuc3ltYm9sLnNwZWNpZXMuanMKICB2YXIgcmVxdWlyZV9lc19zeW1ib2xfc3BlY2llcyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5zeW1ib2wuc3BlY2llcy5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmVfZGVmaW5lX3dlbGxfa25vd25fc3ltYm9sKCk7CiAgICAgIGRlZmluZVdlbGxLbm93blN5bWJvbCgic3BlY2llcyIpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuc3ltYm9sLnNwbGl0LmpzCiAgdmFyIHJlcXVpcmVfZXNfc3ltYm9sX3NwbGl0ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC5zcGxpdC5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmVfZGVmaW5lX3dlbGxfa25vd25fc3ltYm9sKCk7CiAgICAgIGRlZmluZVdlbGxLbm93blN5bWJvbCgic3BsaXQiKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC50by1wcmltaXRpdmUuanMKICB2YXIgcmVxdWlyZV9lc19zeW1ib2xfdG9fcHJpbWl0aXZlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC50by1wcmltaXRpdmUuanMiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlX2RlZmluZV93ZWxsX2tub3duX3N5bWJvbCgpOwogICAgICBkZWZpbmVXZWxsS25vd25TeW1ib2woInRvUHJpbWl0aXZlIik7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5zeW1ib2wudG8tc3RyaW5nLXRhZy5qcwogIHZhciByZXF1aXJlX2VzX3N5bWJvbF90b19zdHJpbmdfdGFnID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC50by1zdHJpbmctdGFnLmpzIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZV9kZWZpbmVfd2VsbF9rbm93bl9zeW1ib2woKTsKICAgICAgZGVmaW5lV2VsbEtub3duU3ltYm9sKCJ0b1N0cmluZ1RhZyIpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuc3ltYm9sLnVuc2NvcGFibGVzLmpzCiAgdmFyIHJlcXVpcmVfZXNfc3ltYm9sX3Vuc2NvcGFibGVzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC51bnNjb3BhYmxlcy5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmVfZGVmaW5lX3dlbGxfa25vd25fc3ltYm9sKCk7CiAgICAgIGRlZmluZVdlbGxLbm93blN5bWJvbCgidW5zY29wYWJsZXMiKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLmpzb24udG8tc3RyaW5nLXRhZy5qcwogIHZhciByZXF1aXJlX2VzX2pzb25fdG9fc3RyaW5nX3RhZyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5qc29uLnRvLXN0cmluZy10YWcuanMiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBnbG9iYWwyID0gcmVxdWlyZV9nbG9iYWwoKTsKICAgICAgdmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZV9zZXRfdG9fc3RyaW5nX3RhZygpOwogICAgICBzZXRUb1N0cmluZ1RhZyhnbG9iYWwyLkpTT04sICJKU09OIiwgdHJ1ZSk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5tYXRoLnRvLXN0cmluZy10YWcuanMKICB2YXIgcmVxdWlyZV9lc19tYXRoX3RvX3N0cmluZ190YWcgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMubWF0aC50by1zdHJpbmctdGFnLmpzIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMucmVmbGVjdC50by1zdHJpbmctdGFnLmpzCiAgdmFyIHJlcXVpcmVfZXNfcmVmbGVjdF90b19zdHJpbmdfdGFnID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnJlZmxlY3QudG8tc3RyaW5nLXRhZy5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9zeW1ib2wvaW5kZXguanMKICB2YXIgcmVxdWlyZV9zeW1ib2wgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL3N5bWJvbC9pbmRleC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgcmVxdWlyZV9lc19hcnJheV9jb25jYXQoKTsKICAgICAgcmVxdWlyZV9lc19vYmplY3RfdG9fc3RyaW5nKCk7CiAgICAgIHJlcXVpcmVfZXNfc3ltYm9sKCk7CiAgICAgIHJlcXVpcmVfZXNfc3ltYm9sX2FzeW5jX2l0ZXJhdG9yKCk7CiAgICAgIHJlcXVpcmVfZXNfc3ltYm9sX2Rlc2NyaXB0aW9uKCk7CiAgICAgIHJlcXVpcmVfZXNfc3ltYm9sX2hhc19pbnN0YW5jZSgpOwogICAgICByZXF1aXJlX2VzX3N5bWJvbF9pc19jb25jYXRfc3ByZWFkYWJsZSgpOwogICAgICByZXF1aXJlX2VzX3N5bWJvbF9pdGVyYXRvcigpOwogICAgICByZXF1aXJlX2VzX3N5bWJvbF9tYXRjaCgpOwogICAgICByZXF1aXJlX2VzX3N5bWJvbF9tYXRjaF9hbGwoKTsKICAgICAgcmVxdWlyZV9lc19zeW1ib2xfcmVwbGFjZSgpOwogICAgICByZXF1aXJlX2VzX3N5bWJvbF9zZWFyY2goKTsKICAgICAgcmVxdWlyZV9lc19zeW1ib2xfc3BlY2llcygpOwogICAgICByZXF1aXJlX2VzX3N5bWJvbF9zcGxpdCgpOwogICAgICByZXF1aXJlX2VzX3N5bWJvbF90b19wcmltaXRpdmUoKTsKICAgICAgcmVxdWlyZV9lc19zeW1ib2xfdG9fc3RyaW5nX3RhZygpOwogICAgICByZXF1aXJlX2VzX3N5bWJvbF91bnNjb3BhYmxlcygpOwogICAgICByZXF1aXJlX2VzX2pzb25fdG9fc3RyaW5nX3RhZygpOwogICAgICByZXF1aXJlX2VzX21hdGhfdG9fc3RyaW5nX3RhZygpOwogICAgICByZXF1aXJlX2VzX3JlZmxlY3RfdG9fc3RyaW5nX3RhZygpOwogICAgICB2YXIgcGF0aCA9IHJlcXVpcmVfcGF0aCgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHBhdGguU3ltYm9sOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9zeW1ib2wvaW5kZXguanMKICB2YXIgcmVxdWlyZV9zeW1ib2wyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvc3ltYm9sL2luZGV4LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgcGFyZW50ID0gcmVxdWlyZV9zeW1ib2woKTsKICAgICAgcmVxdWlyZV93ZWJfZG9tX2NvbGxlY3Rpb25zX2l0ZXJhdG9yKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGFyZW50OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9zeW1ib2wuanMKICB2YXIgcmVxdWlyZV9zeW1ib2wzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvc3ltYm9sLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVfc3ltYm9sMigpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pdGVyYXRvci1jbG9zZS5qcwogIHZhciByZXF1aXJlX2l0ZXJhdG9yX2Nsb3NlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvaXRlcmF0b3ItY2xvc2UuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBhbk9iamVjdCA9IHJlcXVpcmVfYW5fb2JqZWN0KCk7CiAgICAgIHZhciBnZXRNZXRob2QgPSByZXF1aXJlX2dldF9tZXRob2QoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYXRvciwga2luZCwgdmFsdWUpIHsKICAgICAgICB2YXIgaW5uZXJSZXN1bHQsIGlubmVyRXJyb3I7CiAgICAgICAgYW5PYmplY3QoaXRlcmF0b3IpOwogICAgICAgIHRyeSB7CiAgICAgICAgICBpbm5lclJlc3VsdCA9IGdldE1ldGhvZChpdGVyYXRvciwgInJldHVybiIpOwogICAgICAgICAgaWYgKCFpbm5lclJlc3VsdCkgewogICAgICAgICAgICBpZiAoa2luZCA9PT0gInRocm93IikKICAgICAgICAgICAgICB0aHJvdyB2YWx1ZTsKICAgICAgICAgICAgcmV0dXJuIHZhbHVlOwogICAgICAgICAgfQogICAgICAgICAgaW5uZXJSZXN1bHQgPSBpbm5lclJlc3VsdC5jYWxsKGl0ZXJhdG9yKTsKICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgaW5uZXJFcnJvciA9IHRydWU7CiAgICAgICAgICBpbm5lclJlc3VsdCA9IGVycm9yOwogICAgICAgIH0KICAgICAgICBpZiAoa2luZCA9PT0gInRocm93IikKICAgICAgICAgIHRocm93IHZhbHVlOwogICAgICAgIGlmIChpbm5lckVycm9yKQogICAgICAgICAgdGhyb3cgaW5uZXJSZXN1bHQ7CiAgICAgICAgYW5PYmplY3QoaW5uZXJSZXN1bHQpOwogICAgICAgIHJldHVybiB2YWx1ZTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvY2FsbC13aXRoLXNhZmUtaXRlcmF0aW9uLWNsb3NpbmcuanMKICB2YXIgcmVxdWlyZV9jYWxsX3dpdGhfc2FmZV9pdGVyYXRpb25fY2xvc2luZyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2NhbGwtd2l0aC1zYWZlLWl0ZXJhdGlvbi1jbG9zaW5nLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgYW5PYmplY3QgPSByZXF1aXJlX2FuX29iamVjdCgpOwogICAgICB2YXIgaXRlcmF0b3JDbG9zZSA9IHJlcXVpcmVfaXRlcmF0b3JfY2xvc2UoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYXRvciwgZm4sIHZhbHVlLCBFTlRSSUVTKSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIHJldHVybiBFTlRSSUVTID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7CiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsICJ0aHJvdyIsIGVycm9yKTsKICAgICAgICB9CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2lzLWFycmF5LWl0ZXJhdG9yLW1ldGhvZC5qcwogIHZhciByZXF1aXJlX2lzX2FycmF5X2l0ZXJhdG9yX21ldGhvZCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2lzLWFycmF5LWl0ZXJhdG9yLW1ldGhvZC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmVfd2VsbF9rbm93bl9zeW1ib2woKTsKICAgICAgdmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmVfaXRlcmF0b3JzKCk7CiAgICAgIHZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgiaXRlcmF0b3IiKTsKICAgICAgdmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KSB7CiAgICAgICAgcmV0dXJuIGl0ICE9PSB2b2lkIDAgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdID09PSBpdCk7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2FycmF5LWZyb20uanMKICB2YXIgcmVxdWlyZV9hcnJheV9mcm9tID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvYXJyYXktZnJvbS5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgYmluZCA9IHJlcXVpcmVfZnVuY3Rpb25fYmluZF9jb250ZXh0KCk7CiAgICAgIHZhciB0b09iamVjdCA9IHJlcXVpcmVfdG9fb2JqZWN0KCk7CiAgICAgIHZhciBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nID0gcmVxdWlyZV9jYWxsX3dpdGhfc2FmZV9pdGVyYXRpb25fY2xvc2luZygpOwogICAgICB2YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZV9pc19hcnJheV9pdGVyYXRvcl9tZXRob2QoKTsKICAgICAgdmFyIGlzQ29uc3RydWN0b3IgPSByZXF1aXJlX2lzX2NvbnN0cnVjdG9yKCk7CiAgICAgIHZhciB0b0xlbmd0aCA9IHJlcXVpcmVfdG9fbGVuZ3RoKCk7CiAgICAgIHZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmVfY3JlYXRlX3Byb3BlcnR5KCk7CiAgICAgIHZhciBnZXRJdGVyYXRvciA9IHJlcXVpcmVfZ2V0X2l0ZXJhdG9yKCk7CiAgICAgIHZhciBnZXRJdGVyYXRvck1ldGhvZCA9IHJlcXVpcmVfZ2V0X2l0ZXJhdG9yX21ldGhvZCgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlKSB7CiAgICAgICAgdmFyIE8gPSB0b09iamVjdChhcnJheUxpa2UpOwogICAgICAgIHZhciBJU19DT05TVFJVQ1RPUiA9IGlzQ29uc3RydWN0b3IodGhpcyk7CiAgICAgICAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7CiAgICAgICAgdmFyIG1hcGZuID0gYXJndW1lbnRzTGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMDsKICAgICAgICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB2b2lkIDA7CiAgICAgICAgaWYgKG1hcHBpbmcpCiAgICAgICAgICBtYXBmbiA9IGJpbmQobWFwZm4sIGFyZ3VtZW50c0xlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB2b2lkIDAsIDIpOwogICAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kKE8pOwogICAgICAgIHZhciBpbmRleCA9IDA7CiAgICAgICAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvciwgbmV4dCwgdmFsdWU7CiAgICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kICYmICEodGhpcyA9PSBBcnJheSAmJiBpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlcmF0b3JNZXRob2QpKSkgewogICAgICAgICAgaXRlcmF0b3IgPSBnZXRJdGVyYXRvcihPLCBpdGVyYXRvck1ldGhvZCk7CiAgICAgICAgICBuZXh0ID0gaXRlcmF0b3IubmV4dDsKICAgICAgICAgIHJlc3VsdCA9IElTX0NPTlNUUlVDVE9SID8gbmV3IHRoaXMoKSA6IFtdOwogICAgICAgICAgZm9yICg7ICEoc3RlcCA9IG5leHQuY2FsbChpdGVyYXRvcikpLmRvbmU7IGluZGV4KyspIHsKICAgICAgICAgICAgdmFsdWUgPSBtYXBwaW5nID8gY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyhpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZTsKICAgICAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgdmFsdWUpOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7CiAgICAgICAgICByZXN1bHQgPSBJU19DT05TVFJVQ1RPUiA/IG5ldyB0aGlzKGxlbmd0aCkgOiBBcnJheShsZW5ndGgpOwogICAgICAgICAgZm9yICg7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7CiAgICAgICAgICAgIHZhbHVlID0gbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XTsKICAgICAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgdmFsdWUpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7CiAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvY2hlY2stY29ycmVjdG5lc3Mtb2YtaXRlcmF0aW9uLmpzCiAgdmFyIHJlcXVpcmVfY2hlY2tfY29ycmVjdG5lc3Nfb2ZfaXRlcmF0aW9uID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvY2hlY2stY29ycmVjdG5lc3Mtb2YtaXRlcmF0aW9uLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZV93ZWxsX2tub3duX3N5bWJvbCgpOwogICAgICB2YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woIml0ZXJhdG9yIik7CiAgICAgIHZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTsKICAgICAgdHJ5IHsKICAgICAgICBjYWxsZWQgPSAwOwogICAgICAgIGl0ZXJhdG9yV2l0aFJldHVybiA9IHsKICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICByZXR1cm4geyBkb25lOiAhIWNhbGxlZCsrIH07CiAgICAgICAgICB9LAogICAgICAgICAgInJldHVybiI6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICBTQUZFX0NMT1NJTkcgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgIH07CiAgICAgICAgaXRlcmF0b3JXaXRoUmV0dXJuW0lURVJBVE9SXSA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfTsKICAgICAgICBBcnJheS5mcm9tKGl0ZXJhdG9yV2l0aFJldHVybiwgZnVuY3Rpb24oKSB7CiAgICAgICAgICB0aHJvdyAyOwogICAgICAgIH0pOwogICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICB9CiAgICAgIHZhciBjYWxsZWQ7CiAgICAgIHZhciBpdGVyYXRvcldpdGhSZXR1cm47CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYywgU0tJUF9DTE9TSU5HKSB7CiAgICAgICAgaWYgKCFTS0lQX0NMT1NJTkcgJiYgIVNBRkVfQ0xPU0lORykKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB2YXIgSVRFUkFUSU9OX1NVUFBPUlQgPSBmYWxzZTsKICAgICAgICB0cnkgewogICAgICAgICAgdmFyIG9iamVjdCA9IHt9OwogICAgICAgICAgb2JqZWN0W0lURVJBVE9SXSA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogSVRFUkFUSU9OX1NVUFBPUlQgPSB0cnVlIH07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9OwogICAgICAgICAgfTsKICAgICAgICAgIGV4ZWMob2JqZWN0KTsKICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgIH0KICAgICAgICByZXR1cm4gSVRFUkFUSU9OX1NVUFBPUlQ7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5hcnJheS5mcm9tLmpzCiAgdmFyIHJlcXVpcmVfZXNfYXJyYXlfZnJvbSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5hcnJheS5mcm9tLmpzIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgJCA9IHJlcXVpcmVfZXhwb3J0KCk7CiAgICAgIHZhciBmcm9tID0gcmVxdWlyZV9hcnJheV9mcm9tKCk7CiAgICAgIHZhciBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24gPSByZXF1aXJlX2NoZWNrX2NvcnJlY3RuZXNzX29mX2l0ZXJhdGlvbigpOwogICAgICB2YXIgSU5DT1JSRUNUX0lURVJBVElPTiA9ICFjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24oZnVuY3Rpb24oaXRlcmFibGUpIHsKICAgICAgICBBcnJheS5mcm9tKGl0ZXJhYmxlKTsKICAgICAgfSk7CiAgICAgICQoeyB0YXJnZXQ6ICJBcnJheSIsIHN0YXQ6IHRydWUsIGZvcmNlZDogSU5DT1JSRUNUX0lURVJBVElPTiB9LCB7CiAgICAgICAgZnJvbQogICAgICB9KTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9hcnJheS9mcm9tLmpzCiAgdmFyIHJlcXVpcmVfZnJvbSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvYXJyYXkvZnJvbS5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgcmVxdWlyZV9lc19zdHJpbmdfaXRlcmF0b3IoKTsKICAgICAgcmVxdWlyZV9lc19hcnJheV9mcm9tKCk7CiAgICAgIHZhciBwYXRoID0gcmVxdWlyZV9wYXRoKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGF0aC5BcnJheS5mcm9tOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9hcnJheS9mcm9tLmpzCiAgdmFyIHJlcXVpcmVfZnJvbTIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9hcnJheS9mcm9tLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgcGFyZW50ID0gcmVxdWlyZV9mcm9tKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGFyZW50OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9hcnJheS9mcm9tLmpzCiAgdmFyIHJlcXVpcmVfZnJvbTMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9hcnJheS9mcm9tLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVfZnJvbTIoKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qcwogIHZhciByZXF1aXJlX2VzX29iamVjdF9kZWZpbmVfcHJvcGVydGllcyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5vYmplY3QuZGVmaW5lLXByb3BlcnRpZXMuanMiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciAkID0gcmVxdWlyZV9leHBvcnQoKTsKICAgICAgdmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZV9kZXNjcmlwdG9ycygpOwogICAgICB2YXIgZGVmaW5lUHJvcGVydGllcyA9IHJlcXVpcmVfb2JqZWN0X2RlZmluZV9wcm9wZXJ0aWVzKCk7CiAgICAgICQoeyB0YXJnZXQ6ICJPYmplY3QiLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFERVNDUklQVE9SUywgc2hhbTogIURFU0NSSVBUT1JTIH0sIHsKICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzCiAgICAgIH0pOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL29iamVjdC9kZWZpbmUtcHJvcGVydGllcy5qcwogIHZhciByZXF1aXJlX2RlZmluZV9wcm9wZXJ0aWVzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9vYmplY3QvZGVmaW5lLXByb3BlcnRpZXMuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHJlcXVpcmVfZXNfb2JqZWN0X2RlZmluZV9wcm9wZXJ0aWVzKCk7CiAgICAgIHZhciBwYXRoID0gcmVxdWlyZV9wYXRoKCk7CiAgICAgIHZhciBPYmplY3QyID0gcGF0aC5PYmplY3Q7CiAgICAgIHZhciBkZWZpbmVQcm9wZXJ0aWVzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzMihULCBEKSB7CiAgICAgICAgcmV0dXJuIE9iamVjdDIuZGVmaW5lUHJvcGVydGllcyhULCBEKTsKICAgICAgfTsKICAgICAgaWYgKE9iamVjdDIuZGVmaW5lUHJvcGVydGllcy5zaGFtKQogICAgICAgIGRlZmluZVByb3BlcnRpZXMuc2hhbSA9IHRydWU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL29iamVjdC9kZWZpbmUtcHJvcGVydGllcy5qcwogIHZhciByZXF1aXJlX2RlZmluZV9wcm9wZXJ0aWVzMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL29iamVjdC9kZWZpbmUtcHJvcGVydGllcy5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHBhcmVudCA9IHJlcXVpcmVfZGVmaW5lX3Byb3BlcnRpZXMoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL29iamVjdC9kZWZpbmUtcHJvcGVydGllcy5qcwogIHZhciByZXF1aXJlX2RlZmluZV9wcm9wZXJ0aWVzMyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL29iamVjdC9kZWZpbmUtcHJvcGVydGllcy5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlX2RlZmluZV9wcm9wZXJ0aWVzMigpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9vd24ta2V5cy5qcwogIHZhciByZXF1aXJlX293bl9rZXlzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvb3duLWtleXMuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBnZXRCdWlsdEluID0gcmVxdWlyZV9nZXRfYnVpbHRfaW4oKTsKICAgICAgdmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSByZXF1aXJlX29iamVjdF9nZXRfb3duX3Byb3BlcnR5X25hbWVzKCk7CiAgICAgIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSByZXF1aXJlX29iamVjdF9nZXRfb3duX3Byb3BlcnR5X3N5bWJvbHMoKTsKICAgICAgdmFyIGFuT2JqZWN0ID0gcmVxdWlyZV9hbl9vYmplY3QoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCJSZWZsZWN0IiwgIm93bktleXMiKSB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7CiAgICAgICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QoaXQpKTsKICAgICAgICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7CiAgICAgICAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5czsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzCiAgdmFyIHJlcXVpcmVfZXNfb2JqZWN0X2dldF9vd25fcHJvcGVydHlfZGVzY3JpcHRvcnMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMuanMiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciAkID0gcmVxdWlyZV9leHBvcnQoKTsKICAgICAgdmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZV9kZXNjcmlwdG9ycygpOwogICAgICB2YXIgb3duS2V5cyA9IHJlcXVpcmVfb3duX2tleXMoKTsKICAgICAgdmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmVfdG9faW5kZXhlZF9vYmplY3QoKTsKICAgICAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IHJlcXVpcmVfb2JqZWN0X2dldF9vd25fcHJvcGVydHlfZGVzY3JpcHRvcigpOwogICAgICB2YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlX2NyZWF0ZV9wcm9wZXJ0eSgpOwogICAgICAkKHsgdGFyZ2V0OiAiT2JqZWN0Iiwgc3RhdDogdHJ1ZSwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHsKICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iamVjdCkgewogICAgICAgICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3Qob2JqZWN0KTsKICAgICAgICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjsKICAgICAgICAgIHZhciBrZXlzID0gb3duS2V5cyhPKTsKICAgICAgICAgIHZhciByZXN1bHQgPSB7fTsKICAgICAgICAgIHZhciBpbmRleCA9IDA7CiAgICAgICAgICB2YXIga2V5LCBkZXNjcmlwdG9yOwogICAgICAgICAgd2hpbGUgKGtleXMubGVuZ3RoID4gaW5kZXgpIHsKICAgICAgICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBrZXkgPSBrZXlzW2luZGV4KytdKTsKICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3IgIT09IHZvaWQgMCkKICAgICAgICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGtleSwgZGVzY3JpcHRvcik7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgIH0KICAgICAgfSk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMuanMKICB2YXIgcmVxdWlyZV9nZXRfb3duX3Byb3BlcnR5X2Rlc2NyaXB0b3JzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgcmVxdWlyZV9lc19vYmplY3RfZ2V0X293bl9wcm9wZXJ0eV9kZXNjcmlwdG9ycygpOwogICAgICB2YXIgcGF0aCA9IHJlcXVpcmVfcGF0aCgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHBhdGguT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzCiAgdmFyIHJlcXVpcmVfZ2V0X293bl9wcm9wZXJ0eV9kZXNjcmlwdG9yczIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHBhcmVudCA9IHJlcXVpcmVfZ2V0X293bl9wcm9wZXJ0eV9kZXNjcmlwdG9ycygpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcmVudDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMuanMKICB2YXIgcmVxdWlyZV9nZXRfb3duX3Byb3BlcnR5X2Rlc2NyaXB0b3JzMyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVfZ2V0X293bl9wcm9wZXJ0eV9kZXNjcmlwdG9yczIoKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWlzLXN0cmljdC5qcwogIHZhciByZXF1aXJlX2FycmF5X21ldGhvZF9pc19zdHJpY3QgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9hcnJheS1tZXRob2QtaXMtc3RyaWN0LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBmYWlscyA9IHJlcXVpcmVfZmFpbHMoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihNRVRIT0RfTkFNRSwgYXJndW1lbnQpIHsKICAgICAgICB2YXIgbWV0aG9kID0gW11bTUVUSE9EX05BTUVdOwogICAgICAgIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyhmdW5jdGlvbigpIHsKICAgICAgICAgIG1ldGhvZC5jYWxsKG51bGwsIGFyZ3VtZW50IHx8IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB0aHJvdyAxOwogICAgICAgICAgfSwgMSk7CiAgICAgICAgfSk7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2FycmF5LWZvci1lYWNoLmpzCiAgdmFyIHJlcXVpcmVfYXJyYXlfZm9yX2VhY2ggPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9hcnJheS1mb3ItZWFjaC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgJGZvckVhY2ggPSByZXF1aXJlX2FycmF5X2l0ZXJhdGlvbigpLmZvckVhY2g7CiAgICAgIHZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gcmVxdWlyZV9hcnJheV9tZXRob2RfaXNfc3RyaWN0KCk7CiAgICAgIHZhciBTVFJJQ1RfTUVUSE9EID0gYXJyYXlNZXRob2RJc1N0cmljdCgiZm9yRWFjaCIpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9ICFTVFJJQ1RfTUVUSE9EID8gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuKSB7CiAgICAgICAgcmV0dXJuICRmb3JFYWNoKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdm9pZCAwKTsKICAgICAgfSA6IFtdLmZvckVhY2g7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5hcnJheS5mb3ItZWFjaC5qcwogIHZhciByZXF1aXJlX2VzX2FycmF5X2Zvcl9lYWNoID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLmFycmF5LmZvci1lYWNoLmpzIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciAkID0gcmVxdWlyZV9leHBvcnQoKTsKICAgICAgdmFyIGZvckVhY2ggPSByZXF1aXJlX2FycmF5X2Zvcl9lYWNoKCk7CiAgICAgICQoeyB0YXJnZXQ6ICJBcnJheSIsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IFtdLmZvckVhY2ggIT0gZm9yRWFjaCB9LCB7CiAgICAgICAgZm9yRWFjaAogICAgICB9KTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZW50cnktdmlydHVhbC5qcwogIHZhciByZXF1aXJlX2VudHJ5X3ZpcnR1YWwgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9lbnRyeS12aXJ0dWFsLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgcGF0aCA9IHJlcXVpcmVfcGF0aCgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENPTlNUUlVDVE9SKSB7CiAgICAgICAgcmV0dXJuIHBhdGhbQ09OU1RSVUNUT1IgKyAiUHJvdG90eXBlIl07CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvYXJyYXkvdmlydHVhbC9mb3ItZWFjaC5qcwogIHZhciByZXF1aXJlX2Zvcl9lYWNoID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9hcnJheS92aXJ0dWFsL2Zvci1lYWNoLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICByZXF1aXJlX2VzX2FycmF5X2Zvcl9lYWNoKCk7CiAgICAgIHZhciBlbnRyeVZpcnR1YWwgPSByZXF1aXJlX2VudHJ5X3ZpcnR1YWwoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBlbnRyeVZpcnR1YWwoIkFycmF5IikuZm9yRWFjaDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvYXJyYXkvdmlydHVhbC9mb3ItZWFjaC5qcwogIHZhciByZXF1aXJlX2Zvcl9lYWNoMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL2FycmF5L3ZpcnR1YWwvZm9yLWVhY2guanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBwYXJlbnQgPSByZXF1aXJlX2Zvcl9lYWNoKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGFyZW50OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9pbnN0YW5jZS9mb3ItZWFjaC5qcwogIHZhciByZXF1aXJlX2Zvcl9lYWNoMyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL2luc3RhbmNlL2Zvci1lYWNoLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICByZXF1aXJlX3dlYl9kb21fY29sbGVjdGlvbnNfaXRlcmF0b3IoKTsKICAgICAgdmFyIGZvckVhY2ggPSByZXF1aXJlX2Zvcl9lYWNoMigpOwogICAgICB2YXIgY2xhc3NvZiA9IHJlcXVpcmVfY2xhc3NvZigpOwogICAgICB2YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7CiAgICAgIHZhciBET01JdGVyYWJsZXMgPSB7CiAgICAgICAgRE9NVG9rZW5MaXN0OiB0cnVlLAogICAgICAgIE5vZGVMaXN0OiB0cnVlCiAgICAgIH07CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpIHsKICAgICAgICB2YXIgb3duID0gaXQuZm9yRWFjaDsKICAgICAgICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlIHx8IGl0IGluc3RhbmNlb2YgQXJyYXkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZS5mb3JFYWNoIHx8IERPTUl0ZXJhYmxlcy5oYXNPd25Qcm9wZXJ0eShjbGFzc29mKGl0KSkgPyBmb3JFYWNoIDogb3duOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9pbnN0YW5jZS9mb3ItZWFjaC5qcwogIHZhciByZXF1aXJlX2Zvcl9lYWNoNCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL2luc3RhbmNlL2Zvci1lYWNoLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVfZm9yX2VhY2gzKCk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzCiAgdmFyIHJlcXVpcmVfZXNfb2JqZWN0X2dldF9vd25fcHJvcGVydHlfZGVzY3JpcHRvciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgJCA9IHJlcXVpcmVfZXhwb3J0KCk7CiAgICAgIHZhciBmYWlscyA9IHJlcXVpcmVfZmFpbHMoKTsKICAgICAgdmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmVfdG9faW5kZXhlZF9vYmplY3QoKTsKICAgICAgdmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmVfb2JqZWN0X2dldF9vd25fcHJvcGVydHlfZGVzY3JpcHRvcigpLmY7CiAgICAgIHZhciBERVNDUklQVE9SUyA9IHJlcXVpcmVfZGVzY3JpcHRvcnMoKTsKICAgICAgdmFyIEZBSUxTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbigpIHsKICAgICAgICBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoMSk7CiAgICAgIH0pOwogICAgICB2YXIgRk9SQ0VEID0gIURFU0NSSVBUT1JTIHx8IEZBSUxTX09OX1BSSU1JVElWRVM7CiAgICAgICQoeyB0YXJnZXQ6ICJPYmplY3QiLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHsKICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7CiAgICAgICAgICByZXR1cm4gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSW5kZXhlZE9iamVjdChpdCksIGtleSk7CiAgICAgICAgfQogICAgICB9KTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzCiAgdmFyIHJlcXVpcmVfZ2V0X293bl9wcm9wZXJ0eV9kZXNjcmlwdG9yID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICByZXF1aXJlX2VzX29iamVjdF9nZXRfb3duX3Byb3BlcnR5X2Rlc2NyaXB0b3IoKTsKICAgICAgdmFyIHBhdGggPSByZXF1aXJlX3BhdGgoKTsKICAgICAgdmFyIE9iamVjdDIgPSBwYXRoLk9iamVjdDsKICAgICAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yMihpdCwga2V5KSB7CiAgICAgICAgcmV0dXJuIE9iamVjdDIuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpOwogICAgICB9OwogICAgICBpZiAoT2JqZWN0Mi5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iuc2hhbSkKICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iuc2hhbSA9IHRydWU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMKICB2YXIgcmVxdWlyZV9nZXRfb3duX3Byb3BlcnR5X2Rlc2NyaXB0b3IyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHBhcmVudCA9IHJlcXVpcmVfZ2V0X293bl9wcm9wZXJ0eV9kZXNjcmlwdG9yKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGFyZW50OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzCiAgdmFyIHJlcXVpcmVfZ2V0X293bl9wcm9wZXJ0eV9kZXNjcmlwdG9yMyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZV9nZXRfb3duX3Byb3BlcnR5X2Rlc2NyaXB0b3IyKCk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5hcnJheS5maWx0ZXIuanMKICB2YXIgcmVxdWlyZV9lc19hcnJheV9maWx0ZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyLmpzIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciAkID0gcmVxdWlyZV9leHBvcnQoKTsKICAgICAgdmFyICRmaWx0ZXIgPSByZXF1aXJlX2FycmF5X2l0ZXJhdGlvbigpLmZpbHRlcjsKICAgICAgdmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQgPSByZXF1aXJlX2FycmF5X21ldGhvZF9oYXNfc3BlY2llc19zdXBwb3J0KCk7CiAgICAgIHZhciBIQVNfU1BFQ0lFU19TVVBQT1JUID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgiZmlsdGVyIik7CiAgICAgICQoeyB0YXJnZXQ6ICJBcnJheSIsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFIQVNfU1BFQ0lFU19TVVBQT1JUIH0sIHsKICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuKSB7CiAgICAgICAgICByZXR1cm4gJGZpbHRlcih0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMCk7CiAgICAgICAgfQogICAgICB9KTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9hcnJheS92aXJ0dWFsL2ZpbHRlci5qcwogIHZhciByZXF1aXJlX2ZpbHRlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvYXJyYXkvdmlydHVhbC9maWx0ZXIuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHJlcXVpcmVfZXNfYXJyYXlfZmlsdGVyKCk7CiAgICAgIHZhciBlbnRyeVZpcnR1YWwgPSByZXF1aXJlX2VudHJ5X3ZpcnR1YWwoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBlbnRyeVZpcnR1YWwoIkFycmF5IikuZmlsdGVyOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2luc3RhbmNlL2ZpbHRlci5qcwogIHZhciByZXF1aXJlX2ZpbHRlcjIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2luc3RhbmNlL2ZpbHRlci5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGZpbHRlciA9IHJlcXVpcmVfZmlsdGVyKCk7CiAgICAgIHZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCkgewogICAgICAgIHZhciBvd24gPSBpdC5maWx0ZXI7CiAgICAgICAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSB8fCBpdCBpbnN0YW5jZW9mIEFycmF5ICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUuZmlsdGVyID8gZmlsdGVyIDogb3duOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9pbnN0YW5jZS9maWx0ZXIuanMKICB2YXIgcmVxdWlyZV9maWx0ZXIzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvaW5zdGFuY2UvZmlsdGVyLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgcGFyZW50ID0gcmVxdWlyZV9maWx0ZXIyKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGFyZW50OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9pbnN0YW5jZS9maWx0ZXIuanMKICB2YXIgcmVxdWlyZV9maWx0ZXI0ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvaW5zdGFuY2UvZmlsdGVyLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVfZmlsdGVyMygpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL29iamVjdC9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMKICB2YXIgcmVxdWlyZV9nZXRfb3duX3Byb3BlcnR5X3N5bWJvbHMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL29iamVjdC9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHJlcXVpcmVfZXNfc3ltYm9sKCk7CiAgICAgIHZhciBwYXRoID0gcmVxdWlyZV9wYXRoKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGF0aC5PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzCiAgdmFyIHJlcXVpcmVfZ2V0X293bl9wcm9wZXJ0eV9zeW1ib2xzMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL29iamVjdC9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBwYXJlbnQgPSByZXF1aXJlX2dldF9vd25fcHJvcGVydHlfc3ltYm9scygpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcmVudDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvb2JqZWN0L2dldC1vd24tcHJvcGVydHktc3ltYm9scy5qcwogIHZhciByZXF1aXJlX2dldF9vd25fcHJvcGVydHlfc3ltYm9sczMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVfZ2V0X293bl9wcm9wZXJ0eV9zeW1ib2xzMigpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMub2JqZWN0LmtleXMuanMKICB2YXIgcmVxdWlyZV9lc19vYmplY3Rfa2V5cyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5vYmplY3Qua2V5cy5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyICQgPSByZXF1aXJlX2V4cG9ydCgpOwogICAgICB2YXIgdG9PYmplY3QgPSByZXF1aXJlX3RvX29iamVjdCgpOwogICAgICB2YXIgbmF0aXZlS2V5cyA9IHJlcXVpcmVfb2JqZWN0X2tleXMoKTsKICAgICAgdmFyIGZhaWxzID0gcmVxdWlyZV9mYWlscygpOwogICAgICB2YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uKCkgewogICAgICAgIG5hdGl2ZUtleXMoMSk7CiAgICAgIH0pOwogICAgICAkKHsgdGFyZ2V0OiAiT2JqZWN0Iiwgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGQUlMU19PTl9QUklNSVRJVkVTIH0sIHsKICAgICAgICBrZXlzOiBmdW5jdGlvbiBrZXlzKGl0KSB7CiAgICAgICAgICByZXR1cm4gbmF0aXZlS2V5cyh0b09iamVjdChpdCkpOwogICAgICAgIH0KICAgICAgfSk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvb2JqZWN0L2tleXMuanMKICB2YXIgcmVxdWlyZV9rZXlzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9vYmplY3Qva2V5cy5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgcmVxdWlyZV9lc19vYmplY3Rfa2V5cygpOwogICAgICB2YXIgcGF0aCA9IHJlcXVpcmVfcGF0aCgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHBhdGguT2JqZWN0LmtleXM7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL29iamVjdC9rZXlzLmpzCiAgdmFyIHJlcXVpcmVfa2V5czIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9vYmplY3Qva2V5cy5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHBhcmVudCA9IHJlcXVpcmVfa2V5cygpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcmVudDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvb2JqZWN0L2tleXMuanMKICB2YXIgcmVxdWlyZV9rZXlzMyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL29iamVjdC9rZXlzLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVfa2V5czIoKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvYS1jb25zdHJ1Y3Rvci5qcwogIHZhciByZXF1aXJlX2FfY29uc3RydWN0b3IgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9hLWNvbnN0cnVjdG9yLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgaXNDb25zdHJ1Y3RvciA9IHJlcXVpcmVfaXNfY29uc3RydWN0b3IoKTsKICAgICAgdmFyIHRyeVRvU3RyaW5nID0gcmVxdWlyZV90cnlfdG9fc3RyaW5nKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJndW1lbnQpIHsKICAgICAgICBpZiAoaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkpCiAgICAgICAgICByZXR1cm4gYXJndW1lbnQ7CiAgICAgICAgdGhyb3cgVHlwZUVycm9yKHRyeVRvU3RyaW5nKGFyZ3VtZW50KSArICIgaXMgbm90IGEgY29uc3RydWN0b3IiKTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC5qcwogIHZhciByZXF1aXJlX2Z1bmN0aW9uX2JpbmQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBhQ2FsbGFibGUgPSByZXF1aXJlX2FfY2FsbGFibGUoKTsKICAgICAgdmFyIGlzT2JqZWN0ID0gcmVxdWlyZV9pc19vYmplY3QoKTsKICAgICAgdmFyIHNsaWNlID0gW10uc2xpY2U7CiAgICAgIHZhciBmYWN0b3JpZXMgPSB7fTsKICAgICAgdmFyIGNvbnN0cnVjdCA9IGZ1bmN0aW9uKEMsIGFyZ3NMZW5ndGgsIGFyZ3MpIHsKICAgICAgICBpZiAoIShhcmdzTGVuZ3RoIGluIGZhY3RvcmllcykpIHsKICAgICAgICAgIGZvciAodmFyIGxpc3QgPSBbXSwgaSA9IDA7IGkgPCBhcmdzTGVuZ3RoOyBpKyspCiAgICAgICAgICAgIGxpc3RbaV0gPSAiYVsiICsgaSArICJdIjsKICAgICAgICAgIGZhY3Rvcmllc1thcmdzTGVuZ3RoXSA9IEZ1bmN0aW9uKCJDLGEiLCAicmV0dXJuIG5ldyBDKCIgKyBsaXN0LmpvaW4oIiwiKSArICIpIik7CiAgICAgICAgfQogICAgICAgIHJldHVybiBmYWN0b3JpZXNbYXJnc0xlbmd0aF0oQywgYXJncyk7CiAgICAgIH07CiAgICAgIG1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uYmluZCB8fCBmdW5jdGlvbiBiaW5kKHRoYXQpIHsKICAgICAgICB2YXIgZm4gPSBhQ2FsbGFibGUodGhpcyk7CiAgICAgICAgdmFyIHBhcnRBcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOwogICAgICAgIHZhciBib3VuZEZ1bmN0aW9uID0gZnVuY3Rpb24gYm91bmQoKSB7CiAgICAgICAgICB2YXIgYXJncyA9IHBhcnRBcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpOwogICAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBib3VuZEZ1bmN0aW9uID8gY29uc3RydWN0KGZuLCBhcmdzLmxlbmd0aCwgYXJncykgOiBmbi5hcHBseSh0aGF0LCBhcmdzKTsKICAgICAgICB9OwogICAgICAgIGlmIChpc09iamVjdChmbi5wcm90b3R5cGUpKQogICAgICAgICAgYm91bmRGdW5jdGlvbi5wcm90b3R5cGUgPSBmbi5wcm90b3R5cGU7CiAgICAgICAgcmV0dXJuIGJvdW5kRnVuY3Rpb247CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5yZWZsZWN0LmNvbnN0cnVjdC5qcwogIHZhciByZXF1aXJlX2VzX3JlZmxlY3RfY29uc3RydWN0ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnJlZmxlY3QuY29uc3RydWN0LmpzIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgJCA9IHJlcXVpcmVfZXhwb3J0KCk7CiAgICAgIHZhciBnZXRCdWlsdEluID0gcmVxdWlyZV9nZXRfYnVpbHRfaW4oKTsKICAgICAgdmFyIGFDb25zdHJ1Y3RvciA9IHJlcXVpcmVfYV9jb25zdHJ1Y3RvcigpOwogICAgICB2YXIgYW5PYmplY3QgPSByZXF1aXJlX2FuX29iamVjdCgpOwogICAgICB2YXIgaXNPYmplY3QgPSByZXF1aXJlX2lzX29iamVjdCgpOwogICAgICB2YXIgY3JlYXRlID0gcmVxdWlyZV9vYmplY3RfY3JlYXRlKCk7CiAgICAgIHZhciBiaW5kID0gcmVxdWlyZV9mdW5jdGlvbl9iaW5kKCk7CiAgICAgIHZhciBmYWlscyA9IHJlcXVpcmVfZmFpbHMoKTsKICAgICAgdmFyIG5hdGl2ZUNvbnN0cnVjdCA9IGdldEJ1aWx0SW4oIlJlZmxlY3QiLCAiY29uc3RydWN0Iik7CiAgICAgIHZhciBORVdfVEFSR0VUX0JVRyA9IGZhaWxzKGZ1bmN0aW9uKCkgewogICAgICAgIGZ1bmN0aW9uIEYoKSB7CiAgICAgICAgfQogICAgICAgIHJldHVybiAhKG5hdGl2ZUNvbnN0cnVjdChmdW5jdGlvbigpIHsKICAgICAgICB9LCBbXSwgRikgaW5zdGFuY2VvZiBGKTsKICAgICAgfSk7CiAgICAgIHZhciBBUkdTX0JVRyA9ICFmYWlscyhmdW5jdGlvbigpIHsKICAgICAgICBuYXRpdmVDb25zdHJ1Y3QoZnVuY3Rpb24oKSB7CiAgICAgICAgfSk7CiAgICAgIH0pOwogICAgICB2YXIgRk9SQ0VEID0gTkVXX1RBUkdFVF9CVUcgfHwgQVJHU19CVUc7CiAgICAgICQoeyB0YXJnZXQ6ICJSZWZsZWN0Iiwgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQsIHNoYW06IEZPUkNFRCB9LCB7CiAgICAgICAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzKSB7CiAgICAgICAgICBhQ29uc3RydWN0b3IoVGFyZ2V0KTsKICAgICAgICAgIGFuT2JqZWN0KGFyZ3MpOwogICAgICAgICAgdmFyIG5ld1RhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gVGFyZ2V0IDogYUNvbnN0cnVjdG9yKGFyZ3VtZW50c1syXSk7CiAgICAgICAgICBpZiAoQVJHU19CVUcgJiYgIU5FV19UQVJHRVRfQlVHKQogICAgICAgICAgICByZXR1cm4gbmF0aXZlQ29uc3RydWN0KFRhcmdldCwgYXJncywgbmV3VGFyZ2V0KTsKICAgICAgICAgIGlmIChUYXJnZXQgPT0gbmV3VGFyZ2V0KSB7CiAgICAgICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHsKICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRhcmdldCgpOwogICAgICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0pOwogICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0pOwogICAgICAgICAgICAgIGNhc2UgMzoKICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pOwogICAgICAgICAgICAgIGNhc2UgNDoKICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciAkYXJncyA9IFtudWxsXTsKICAgICAgICAgICAgJGFyZ3MucHVzaC5hcHBseSgkYXJncywgYXJncyk7CiAgICAgICAgICAgIHJldHVybiBuZXcgKGJpbmQuYXBwbHkoVGFyZ2V0LCAkYXJncykpKCk7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgcHJvdG8gPSBuZXdUYXJnZXQucHJvdG90eXBlOwogICAgICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlKGlzT2JqZWN0KHByb3RvKSA/IHByb3RvIDogT2JqZWN0LnByb3RvdHlwZSk7CiAgICAgICAgICB2YXIgcmVzdWx0ID0gRnVuY3Rpb24uYXBwbHkuY2FsbChUYXJnZXQsIGluc3RhbmNlLCBhcmdzKTsKICAgICAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogaW5zdGFuY2U7CiAgICAgICAgfQogICAgICB9KTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9yZWZsZWN0L2NvbnN0cnVjdC5qcwogIHZhciByZXF1aXJlX2NvbnN0cnVjdCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvcmVmbGVjdC9jb25zdHJ1Y3QuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHJlcXVpcmVfZXNfcmVmbGVjdF9jb25zdHJ1Y3QoKTsKICAgICAgdmFyIHBhdGggPSByZXF1aXJlX3BhdGgoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBwYXRoLlJlZmxlY3QuY29uc3RydWN0OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9yZWZsZWN0L2NvbnN0cnVjdC5qcwogIHZhciByZXF1aXJlX2NvbnN0cnVjdDIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9yZWZsZWN0L2NvbnN0cnVjdC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHBhcmVudCA9IHJlcXVpcmVfY29uc3RydWN0KCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGFyZW50OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9yZWZsZWN0L2NvbnN0cnVjdC5qcwogIHZhciByZXF1aXJlX2NvbnN0cnVjdDMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9yZWZsZWN0L2NvbnN0cnVjdC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlX2NvbnN0cnVjdDIoKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9mZWF0dXJlcy9hcnJheS9pcy1hcnJheS5qcwogIHZhciByZXF1aXJlX2lzX2FycmF5NSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZmVhdHVyZXMvYXJyYXkvaXMtYXJyYXkuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBwYXJlbnQgPSByZXF1aXJlX2lzX2FycmF5MygpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcmVudDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy9hcnJheS9pcy1hcnJheS5qcwogIHZhciByZXF1aXJlX2lzX2FycmF5NiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMvYXJyYXkvaXMtYXJyYXkuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZV9pc19hcnJheTUoKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvaGVscGVycy9hcnJheVdpdGhIb2xlcy5qcwogIHZhciByZXF1aXJlX2FycmF5V2l0aEhvbGVzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvaGVscGVycy9hcnJheVdpdGhIb2xlcy5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIF9BcnJheSRpc0FycmF5ID0gcmVxdWlyZV9pc19hcnJheTYoKTsKICAgICAgZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgewogICAgICAgIGlmIChfQXJyYXkkaXNBcnJheShhcnIpKQogICAgICAgICAgcmV0dXJuIGFycjsKICAgICAgfQogICAgICBtb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhIb2xlczsKICAgICAgbW9kdWxlLmV4cG9ydHNbImRlZmF1bHQiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzbmV4dC5zeW1ib2wuYXN5bmMtZGlzcG9zZS5qcwogIHZhciByZXF1aXJlX2VzbmV4dF9zeW1ib2xfYXN5bmNfZGlzcG9zZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lc25leHQuc3ltYm9sLmFzeW5jLWRpc3Bvc2UuanMiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlX2RlZmluZV93ZWxsX2tub3duX3N5bWJvbCgpOwogICAgICBkZWZpbmVXZWxsS25vd25TeW1ib2woImFzeW5jRGlzcG9zZSIpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXNuZXh0LnN5bWJvbC5kaXNwb3NlLmpzCiAgdmFyIHJlcXVpcmVfZXNuZXh0X3N5bWJvbF9kaXNwb3NlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzbmV4dC5zeW1ib2wuZGlzcG9zZS5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmVfZGVmaW5lX3dlbGxfa25vd25fc3ltYm9sKCk7CiAgICAgIGRlZmluZVdlbGxLbm93blN5bWJvbCgiZGlzcG9zZSIpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXNuZXh0LnN5bWJvbC5tYXRjaGVyLmpzCiAgdmFyIHJlcXVpcmVfZXNuZXh0X3N5bWJvbF9tYXRjaGVyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzbmV4dC5zeW1ib2wubWF0Y2hlci5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmVfZGVmaW5lX3dlbGxfa25vd25fc3ltYm9sKCk7CiAgICAgIGRlZmluZVdlbGxLbm93blN5bWJvbCgibWF0Y2hlciIpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXNuZXh0LnN5bWJvbC5tZXRhZGF0YS5qcwogIHZhciByZXF1aXJlX2VzbmV4dF9zeW1ib2xfbWV0YWRhdGEgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXNuZXh0LnN5bWJvbC5tZXRhZGF0YS5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmVfZGVmaW5lX3dlbGxfa25vd25fc3ltYm9sKCk7CiAgICAgIGRlZmluZVdlbGxLbm93blN5bWJvbCgibWV0YWRhdGEiKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzbmV4dC5zeW1ib2wub2JzZXJ2YWJsZS5qcwogIHZhciByZXF1aXJlX2VzbmV4dF9zeW1ib2xfb2JzZXJ2YWJsZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lc25leHQuc3ltYm9sLm9ic2VydmFibGUuanMiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlX2RlZmluZV93ZWxsX2tub3duX3N5bWJvbCgpOwogICAgICBkZWZpbmVXZWxsS25vd25TeW1ib2woIm9ic2VydmFibGUiKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzbmV4dC5zeW1ib2wucGF0dGVybi1tYXRjaC5qcwogIHZhciByZXF1aXJlX2VzbmV4dF9zeW1ib2xfcGF0dGVybl9tYXRjaCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lc25leHQuc3ltYm9sLnBhdHRlcm4tbWF0Y2guanMiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlX2RlZmluZV93ZWxsX2tub3duX3N5bWJvbCgpOwogICAgICBkZWZpbmVXZWxsS25vd25TeW1ib2woInBhdHRlcm5NYXRjaCIpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXNuZXh0LnN5bWJvbC5yZXBsYWNlLWFsbC5qcwogIHZhciByZXF1aXJlX2VzbmV4dF9zeW1ib2xfcmVwbGFjZV9hbGwgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXNuZXh0LnN5bWJvbC5yZXBsYWNlLWFsbC5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmVfZGVmaW5lX3dlbGxfa25vd25fc3ltYm9sKCk7CiAgICAgIGRlZmluZVdlbGxLbm93blN5bWJvbCgicmVwbGFjZUFsbCIpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ZlYXR1cmVzL3N5bWJvbC9pbmRleC5qcwogIHZhciByZXF1aXJlX3N5bWJvbDQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ZlYXR1cmVzL3N5bWJvbC9pbmRleC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHBhcmVudCA9IHJlcXVpcmVfc3ltYm9sMigpOwogICAgICByZXF1aXJlX2VzbmV4dF9zeW1ib2xfYXN5bmNfZGlzcG9zZSgpOwogICAgICByZXF1aXJlX2VzbmV4dF9zeW1ib2xfZGlzcG9zZSgpOwogICAgICByZXF1aXJlX2VzbmV4dF9zeW1ib2xfbWF0Y2hlcigpOwogICAgICByZXF1aXJlX2VzbmV4dF9zeW1ib2xfbWV0YWRhdGEoKTsKICAgICAgcmVxdWlyZV9lc25leHRfc3ltYm9sX29ic2VydmFibGUoKTsKICAgICAgcmVxdWlyZV9lc25leHRfc3ltYm9sX3BhdHRlcm5fbWF0Y2goKTsKICAgICAgcmVxdWlyZV9lc25leHRfc3ltYm9sX3JlcGxhY2VfYWxsKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGFyZW50OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzL3N5bWJvbC5qcwogIHZhciByZXF1aXJlX3N5bWJvbDUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzL3N5bWJvbC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlX3N5bWJvbDQoKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvaGVscGVycy9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcwogIHZhciByZXF1aXJlX2l0ZXJhYmxlVG9BcnJheUxpbWl0ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvaGVscGVycy9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIF9TeW1ib2wgPSByZXF1aXJlX3N5bWJvbDUoKTsKICAgICAgdmFyIF9nZXRJdGVyYXRvck1ldGhvZCA9IHJlcXVpcmVfZ2V0X2l0ZXJhdG9yX21ldGhvZDUoKTsKICAgICAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgewogICAgICAgIHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBfU3ltYm9sICE9PSAidW5kZWZpbmVkIiAmJiBfZ2V0SXRlcmF0b3JNZXRob2QoYXJyKSB8fCBhcnJbIkBAaXRlcmF0b3IiXTsKICAgICAgICBpZiAoX2kgPT0gbnVsbCkKICAgICAgICAgIHJldHVybjsKICAgICAgICB2YXIgX2FyciA9IFtdOwogICAgICAgIHZhciBfbiA9IHRydWU7CiAgICAgICAgdmFyIF9kID0gZmFsc2U7CiAgICAgICAgdmFyIF9zLCBfZTsKICAgICAgICB0cnkgewogICAgICAgICAgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgewogICAgICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpOwogICAgICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgIF9kID0gdHJ1ZTsKICAgICAgICAgIF9lID0gZXJyOwogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBpZiAoIV9uICYmIF9pWyJyZXR1cm4iXSAhPSBudWxsKQogICAgICAgICAgICAgIF9pWyJyZXR1cm4iXSgpOwogICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgaWYgKF9kKQogICAgICAgICAgICAgIHRocm93IF9lOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gX2FycjsKICAgICAgfQogICAgICBtb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdDsKICAgICAgbW9kdWxlLmV4cG9ydHNbImRlZmF1bHQiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLmFycmF5LnNsaWNlLmpzCiAgdmFyIHJlcXVpcmVfZXNfYXJyYXlfc2xpY2UgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UuanMiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyICQgPSByZXF1aXJlX2V4cG9ydCgpOwogICAgICB2YXIgaXNBcnJheSA9IHJlcXVpcmVfaXNfYXJyYXkoKTsKICAgICAgdmFyIGlzQ29uc3RydWN0b3IgPSByZXF1aXJlX2lzX2NvbnN0cnVjdG9yKCk7CiAgICAgIHZhciBpc09iamVjdCA9IHJlcXVpcmVfaXNfb2JqZWN0KCk7CiAgICAgIHZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlX3RvX2Fic29sdXRlX2luZGV4KCk7CiAgICAgIHZhciB0b0xlbmd0aCA9IHJlcXVpcmVfdG9fbGVuZ3RoKCk7CiAgICAgIHZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlX3RvX2luZGV4ZWRfb2JqZWN0KCk7CiAgICAgIHZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmVfY3JlYXRlX3Byb3BlcnR5KCk7CiAgICAgIHZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlX3dlbGxfa25vd25fc3ltYm9sKCk7CiAgICAgIHZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gcmVxdWlyZV9hcnJheV9tZXRob2RfaGFzX3NwZWNpZXNfc3VwcG9ydCgpOwogICAgICB2YXIgSEFTX1NQRUNJRVNfU1VQUE9SVCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQoInNsaWNlIik7CiAgICAgIHZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCJzcGVjaWVzIik7CiAgICAgIHZhciBuYXRpdmVTbGljZSA9IFtdLnNsaWNlOwogICAgICB2YXIgbWF4ID0gTWF0aC5tYXg7CiAgICAgICQoeyB0YXJnZXQ6ICJBcnJheSIsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFIQVNfU1BFQ0lFU19TVVBQT1JUIH0sIHsKICAgICAgICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkgewogICAgICAgICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QodGhpcyk7CiAgICAgICAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpOwogICAgICAgICAgdmFyIGsgPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbmd0aCk7CiAgICAgICAgICB2YXIgZmluID0gdG9BYnNvbHV0ZUluZGV4KGVuZCA9PT0gdm9pZCAwID8gbGVuZ3RoIDogZW5kLCBsZW5ndGgpOwogICAgICAgICAgdmFyIENvbnN0cnVjdG9yLCByZXN1bHQsIG47CiAgICAgICAgICBpZiAoaXNBcnJheShPKSkgewogICAgICAgICAgICBDb25zdHJ1Y3RvciA9IE8uY29uc3RydWN0b3I7CiAgICAgICAgICAgIGlmIChpc0NvbnN0cnVjdG9yKENvbnN0cnVjdG9yKSAmJiAoQ29uc3RydWN0b3IgPT09IEFycmF5IHx8IGlzQXJyYXkoQ29uc3RydWN0b3IucHJvdG90eXBlKSkpIHsKICAgICAgICAgICAgICBDb25zdHJ1Y3RvciA9IHZvaWQgMDsKICAgICAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChDb25zdHJ1Y3RvcikpIHsKICAgICAgICAgICAgICBDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yW1NQRUNJRVNdOwogICAgICAgICAgICAgIGlmIChDb25zdHJ1Y3RvciA9PT0gbnVsbCkKICAgICAgICAgICAgICAgIENvbnN0cnVjdG9yID0gdm9pZCAwOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChDb25zdHJ1Y3RvciA9PT0gQXJyYXkgfHwgQ29uc3RydWN0b3IgPT09IHZvaWQgMCkgewogICAgICAgICAgICAgIHJldHVybiBuYXRpdmVTbGljZS5jYWxsKE8sIGssIGZpbik7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJlc3VsdCA9IG5ldyAoQ29uc3RydWN0b3IgPT09IHZvaWQgMCA/IEFycmF5IDogQ29uc3RydWN0b3IpKG1heChmaW4gLSBrLCAwKSk7CiAgICAgICAgICBmb3IgKG4gPSAwOyBrIDwgZmluOyBrKyssIG4rKykKICAgICAgICAgICAgaWYgKGsgaW4gTykKICAgICAgICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIG4sIE9ba10pOwogICAgICAgICAgcmVzdWx0Lmxlbmd0aCA9IG47CiAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgIH0KICAgICAgfSk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvYXJyYXkvdmlydHVhbC9zbGljZS5qcwogIHZhciByZXF1aXJlX3NsaWNlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9hcnJheS92aXJ0dWFsL3NsaWNlLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICByZXF1aXJlX2VzX2FycmF5X3NsaWNlKCk7CiAgICAgIHZhciBlbnRyeVZpcnR1YWwgPSByZXF1aXJlX2VudHJ5X3ZpcnR1YWwoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBlbnRyeVZpcnR1YWwoIkFycmF5Iikuc2xpY2U7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvaW5zdGFuY2Uvc2xpY2UuanMKICB2YXIgcmVxdWlyZV9zbGljZTIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2luc3RhbmNlL3NsaWNlLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgc2xpY2UgPSByZXF1aXJlX3NsaWNlKCk7CiAgICAgIHZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCkgewogICAgICAgIHZhciBvd24gPSBpdC5zbGljZTsKICAgICAgICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlIHx8IGl0IGluc3RhbmNlb2YgQXJyYXkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZS5zbGljZSA/IHNsaWNlIDogb3duOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9pbnN0YW5jZS9zbGljZS5qcwogIHZhciByZXF1aXJlX3NsaWNlMyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL2luc3RhbmNlL3NsaWNlLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgcGFyZW50ID0gcmVxdWlyZV9zbGljZTIoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZmVhdHVyZXMvaW5zdGFuY2Uvc2xpY2UuanMKICB2YXIgcmVxdWlyZV9zbGljZTQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ZlYXR1cmVzL2luc3RhbmNlL3NsaWNlLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgcGFyZW50ID0gcmVxdWlyZV9zbGljZTMoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMvaW5zdGFuY2Uvc2xpY2UuanMKICB2YXIgcmVxdWlyZV9zbGljZTUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzL2luc3RhbmNlL3NsaWNlLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVfc2xpY2U0KCk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZmVhdHVyZXMvYXJyYXkvZnJvbS5qcwogIHZhciByZXF1aXJlX2Zyb200ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9mZWF0dXJlcy9hcnJheS9mcm9tLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgcGFyZW50ID0gcmVxdWlyZV9mcm9tMigpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcmVudDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy9hcnJheS9mcm9tLmpzCiAgdmFyIHJlcXVpcmVfZnJvbTUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzL2FycmF5L2Zyb20uanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZV9mcm9tNCgpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9oZWxwZXJzL2FycmF5TGlrZVRvQXJyYXkuanMKICB2YXIgcmVxdWlyZV9hcnJheUxpa2VUb0FycmF5ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgewogICAgICAgIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKQogICAgICAgICAgbGVuID0gYXJyLmxlbmd0aDsKICAgICAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsKICAgICAgICAgIGFycjJbaV0gPSBhcnJbaV07CiAgICAgICAgfQogICAgICAgIHJldHVybiBhcnIyOwogICAgICB9CiAgICAgIG1vZHVsZS5leHBvcnRzID0gX2FycmF5TGlrZVRvQXJyYXk7CiAgICAgIG1vZHVsZS5leHBvcnRzWyJkZWZhdWx0Il0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanMKICB2YXIgcmVxdWlyZV91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBfc2xpY2VJbnN0YW5jZVByb3BlcnR5ID0gcmVxdWlyZV9zbGljZTUoKTsKICAgICAgdmFyIF9BcnJheSRmcm9tID0gcmVxdWlyZV9mcm9tNSgpOwogICAgICB2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmVfYXJyYXlMaWtlVG9BcnJheSgpOwogICAgICBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7CiAgICAgICAgdmFyIF9jb250ZXh0OwogICAgICAgIGlmICghbykKICAgICAgICAgIHJldHVybjsKICAgICAgICBpZiAodHlwZW9mIG8gPT09ICJzdHJpbmciKQogICAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsKICAgICAgICB2YXIgbiA9IF9zbGljZUluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpLmNhbGwoX2NvbnRleHQsIDgsIC0xKTsKICAgICAgICBpZiAobiA9PT0gIk9iamVjdCIgJiYgby5jb25zdHJ1Y3RvcikKICAgICAgICAgIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7CiAgICAgICAgaWYgKG4gPT09ICJNYXAiIHx8IG4gPT09ICJTZXQiKQogICAgICAgICAgcmV0dXJuIF9BcnJheSRmcm9tKG8pOwogICAgICAgIGlmIChuID09PSAiQXJndW1lbnRzIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkKICAgICAgICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7CiAgICAgIH0KICAgICAgbW9kdWxlLmV4cG9ydHMgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXk7CiAgICAgIG1vZHVsZS5leHBvcnRzWyJkZWZhdWx0Il0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvbm9uSXRlcmFibGVSZXN0LmpzCiAgdmFyIHJlcXVpcmVfbm9uSXRlcmFibGVSZXN0ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvaGVscGVycy9ub25JdGVyYWJsZVJlc3QuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC4iKTsKICAgICAgfQogICAgICBtb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVJlc3Q7CiAgICAgIG1vZHVsZS5leHBvcnRzWyJkZWZhdWx0Il0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qcwogIHZhciByZXF1aXJlX3NsaWNlZFRvQXJyYXkgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBhcnJheVdpdGhIb2xlcyA9IHJlcXVpcmVfYXJyYXlXaXRoSG9sZXMoKTsKICAgICAgdmFyIGl0ZXJhYmxlVG9BcnJheUxpbWl0ID0gcmVxdWlyZV9pdGVyYWJsZVRvQXJyYXlMaW1pdCgpOwogICAgICB2YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KCk7CiAgICAgIHZhciBub25JdGVyYWJsZVJlc3QgPSByZXF1aXJlX25vbkl0ZXJhYmxlUmVzdCgpOwogICAgICBmdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsKICAgICAgICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgbm9uSXRlcmFibGVSZXN0KCk7CiAgICAgIH0KICAgICAgbW9kdWxlLmV4cG9ydHMgPSBfc2xpY2VkVG9BcnJheTsKICAgICAgbW9kdWxlLmV4cG9ydHNbImRlZmF1bHQiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9mZWF0dXJlcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzCiAgdmFyIHJlcXVpcmVfZGVmaW5lX3Byb3BlcnR5NCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZmVhdHVyZXMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHBhcmVudCA9IHJlcXVpcmVfZGVmaW5lX3Byb3BlcnR5MigpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcmVudDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzCiAgdmFyIHJlcXVpcmVfZGVmaW5lX3Byb3BlcnR5NSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlX2RlZmluZV9wcm9wZXJ0eTQoKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcwogIHZhciByZXF1aXJlX2RlZmluZVByb3BlcnR5ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIF9PYmplY3QkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlX2RlZmluZV9wcm9wZXJ0eTUoKTsKICAgICAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgewogICAgICAgIGlmIChrZXkgaW4gb2JqKSB7CiAgICAgICAgICBfT2JqZWN0JGRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7CiAgICAgICAgICAgIHZhbHVlLAogICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG9iajsKICAgICAgfQogICAgICBtb2R1bGUuZXhwb3J0cyA9IF9kZWZpbmVQcm9wZXJ0eTsKICAgICAgbW9kdWxlLmV4cG9ydHNbImRlZmF1bHQiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLmFycmF5Lm1hcC5qcwogIHZhciByZXF1aXJlX2VzX2FycmF5X21hcCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5hcnJheS5tYXAuanMiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyICQgPSByZXF1aXJlX2V4cG9ydCgpOwogICAgICB2YXIgJG1hcCA9IHJlcXVpcmVfYXJyYXlfaXRlcmF0aW9uKCkubWFwOwogICAgICB2YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCA9IHJlcXVpcmVfYXJyYXlfbWV0aG9kX2hhc19zcGVjaWVzX3N1cHBvcnQoKTsKICAgICAgdmFyIEhBU19TUEVDSUVTX1NVUFBPUlQgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0KCJtYXAiKTsKICAgICAgJCh7IHRhcmdldDogIkFycmF5IiwgcHJvdG86IHRydWUsIGZvcmNlZDogIUhBU19TUEVDSUVTX1NVUFBPUlQgfSwgewogICAgICAgIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4pIHsKICAgICAgICAgIHJldHVybiAkbWFwKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdm9pZCAwKTsKICAgICAgICB9CiAgICAgIH0pOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2FycmF5L3ZpcnR1YWwvbWFwLmpzCiAgdmFyIHJlcXVpcmVfbWFwID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9hcnJheS92aXJ0dWFsL21hcC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgcmVxdWlyZV9lc19hcnJheV9tYXAoKTsKICAgICAgdmFyIGVudHJ5VmlydHVhbCA9IHJlcXVpcmVfZW50cnlfdmlydHVhbCgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGVudHJ5VmlydHVhbCgiQXJyYXkiKS5tYXA7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvaW5zdGFuY2UvbWFwLmpzCiAgdmFyIHJlcXVpcmVfbWFwMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvaW5zdGFuY2UvbWFwLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgbWFwID0gcmVxdWlyZV9tYXAoKTsKICAgICAgdmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KSB7CiAgICAgICAgdmFyIG93biA9IGl0Lm1hcDsKICAgICAgICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlIHx8IGl0IGluc3RhbmNlb2YgQXJyYXkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZS5tYXAgPyBtYXAgOiBvd247CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL2luc3RhbmNlL21hcC5qcwogIHZhciByZXF1aXJlX21hcDMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9pbnN0YW5jZS9tYXAuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBwYXJlbnQgPSByZXF1aXJlX21hcDIoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL2luc3RhbmNlL21hcC5qcwogIHZhciByZXF1aXJlX21hcDQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9pbnN0YW5jZS9tYXAuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZV9tYXAzKCk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMKICB2YXIgcmVxdWlyZV9ydW50aW1lID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHJ1bnRpbWUgPSBmdW5jdGlvbihleHBvcnRzMikgewogICAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlOwogICAgICAgIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTsKICAgICAgICB2YXIgdW5kZWZpbmVkMjsKICAgICAgICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICJmdW5jdGlvbiIgPyBTeW1ib2wgOiB7fTsKICAgICAgICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8ICJAQGl0ZXJhdG9yIjsKICAgICAgICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCAiQEBhc3luY0l0ZXJhdG9yIjsKICAgICAgICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8ICJAQHRvU3RyaW5nVGFnIjsKICAgICAgICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsKICAgICAgICAgICAgdmFsdWUsCiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsCiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgICAgICAgICAgd3JpdGFibGU6IHRydWUKICAgICAgICAgIH0pOwogICAgICAgICAgcmV0dXJuIG9ialtrZXldOwogICAgICAgIH0KICAgICAgICB0cnkgewogICAgICAgICAgZGVmaW5lKHt9LCAiIik7CiAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICBkZWZpbmUgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHsKICAgICAgICAgICAgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7CiAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYyLCB0cnlMb2NzTGlzdCkgewogICAgICAgICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7CiAgICAgICAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpOwogICAgICAgICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7CiAgICAgICAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZjIsIGNvbnRleHQpOwogICAgICAgICAgcmV0dXJuIGdlbmVyYXRvcjsKICAgICAgICB9CiAgICAgICAgZXhwb3J0czIud3JhcCA9IHdyYXA7CiAgICAgICAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICByZXR1cm4geyB0eXBlOiAibm9ybWFsIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9OwogICAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICJ0aHJvdyIsIGFyZzogZXJyIH07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gInN1c3BlbmRlZFN0YXJ0IjsKICAgICAgICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9ICJzdXNwZW5kZWRZaWVsZCI7CiAgICAgICAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gImV4ZWN1dGluZyI7CiAgICAgICAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gImNvbXBsZXRlZCI7CiAgICAgICAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTsKICAgICAgICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkgewogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHsKICAgICAgICB9CiAgICAgICAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307CiAgICAgICAgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24oKSB7CiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9KTsKICAgICAgICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7CiAgICAgICAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpOwogICAgICAgIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJiBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiYgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkgewogICAgICAgICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTsKICAgICAgICB9CiAgICAgICAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpOwogICAgICAgIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlOwogICAgICAgIGRlZmluZShHcCwgImNvbnN0cnVjdG9yIiwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpOwogICAgICAgIGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgImNvbnN0cnVjdG9yIiwgR2VuZXJhdG9yRnVuY3Rpb24pOwogICAgICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCB0b1N0cmluZ1RhZ1N5bWJvbCwgIkdlbmVyYXRvckZ1bmN0aW9uIik7CiAgICAgICAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkgewogICAgICAgICAgWyJuZXh0IiwgInRocm93IiwgInJldHVybiJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7CiAgICAgICAgICAgIGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24oYXJnKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICAgIGV4cG9ydHMyLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHsKICAgICAgICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gImZ1bmN0aW9uIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7CiAgICAgICAgICByZXR1cm4gY3RvciA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8IChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09ICJHZW5lcmF0b3JGdW5jdGlvbiIgOiBmYWxzZTsKICAgICAgICB9OwogICAgICAgIGV4cG9ydHMyLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHsKICAgICAgICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHsKICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlOwogICAgICAgICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgIkdlbmVyYXRvckZ1bmN0aW9uIik7CiAgICAgICAgICB9CiAgICAgICAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7CiAgICAgICAgICByZXR1cm4gZ2VuRnVuOwogICAgICAgIH07CiAgICAgICAgZXhwb3J0czIuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHsKICAgICAgICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9OwogICAgICAgIH07CiAgICAgICAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7CiAgICAgICAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkgewogICAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTsKICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSAidGhyb3ciKSB7CiAgICAgICAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnOwogICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTsKICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAib2JqZWN0IiAmJiBoYXNPd24uY2FsbCh2YWx1ZSwgIl9fYXdhaXQiKSkgewogICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZTIpIHsKICAgICAgICAgICAgICAgICAgaW52b2tlKCJuZXh0IiwgdmFsdWUyLCByZXNvbHZlLCByZWplY3QpOwogICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7CiAgICAgICAgICAgICAgICAgIGludm9rZSgidGhyb3ciLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7CiAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7CiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7CiAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHsKICAgICAgICAgICAgICAgIHJldHVybiBpbnZva2UoInRocm93IiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7CiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHZhciBwcmV2aW91c1Byb21pc2U7CiAgICAgICAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7CiAgICAgICAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkgewogICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7CiAgICAgICAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7CiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9IHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLCBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTsKICAgICAgICB9CiAgICAgICAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTsKICAgICAgICBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uKCkgewogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfSk7CiAgICAgICAgZXhwb3J0czIuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7CiAgICAgICAgZXhwb3J0czIuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmMiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7CiAgICAgICAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkKICAgICAgICAgICAgUHJvbWlzZUltcGwgPSBQcm9taXNlOwogICAgICAgICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYyLCB0cnlMb2NzTGlzdCksIFByb21pc2VJbXBsKTsKICAgICAgICAgIHJldHVybiBleHBvcnRzMi5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pID8gaXRlciA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7CiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpOwogICAgICAgICAgfSk7CiAgICAgICAgfTsKICAgICAgICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYyLCBjb250ZXh0KSB7CiAgICAgICAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0OwogICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykgewogICAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nIik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkgewogICAgICAgICAgICAgIGlmIChtZXRob2QgPT09ICJ0aHJvdyIpIHsKICAgICAgICAgICAgICAgIHRocm93IGFyZzsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDsKICAgICAgICAgICAgY29udGV4dC5hcmcgPSBhcmc7CiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7CiAgICAgICAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTsKICAgICAgICAgICAgICBpZiAoZGVsZWdhdGUpIHsKICAgICAgICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpOwogICAgICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7CiAgICAgICAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkKICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09ICJuZXh0IikgewogICAgICAgICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09ICJ0aHJvdyIpIHsKICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkgewogICAgICAgICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkOwogICAgICAgICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZzsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09ICJyZXR1cm4iKSB7CiAgICAgICAgICAgICAgICBjb250ZXh0LmFicnVwdCgicmV0dXJuIiwgY29udGV4dC5hcmcpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nOwogICAgICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmMiwgY29udGV4dCk7CiAgICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSAibm9ybWFsIikgewogICAgICAgICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBHZW5TdGF0ZUNvbXBsZXRlZCA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7CiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkgewogICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLAogICAgICAgICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmUKICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gInRocm93IikgewogICAgICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDsKICAgICAgICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gInRocm93IjsKICAgICAgICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZzsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH07CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHsKICAgICAgICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07CiAgICAgICAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQyKSB7CiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsOwogICAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09ICJ0aHJvdyIpIHsKICAgICAgICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbInJldHVybiJdKSB7CiAgICAgICAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9ICJyZXR1cm4iOwogICAgICAgICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQyOwogICAgICAgICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7CiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09ICJ0aHJvdyIpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gInRocm93IjsKICAgICAgICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2QiKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDsKICAgICAgICAgIH0KICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7CiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09ICJ0aHJvdyIpIHsKICAgICAgICAgICAgY29udGV4dC5tZXRob2QgPSAidGhyb3ciOwogICAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7CiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsOwogICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZzsKICAgICAgICAgIGlmICghaW5mbykgewogICAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9ICJ0aHJvdyI7CiAgICAgICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcigiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3QiKTsKICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7CiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGluZm8uZG9uZSkgewogICAgICAgICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTsKICAgICAgICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYzsKICAgICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSAicmV0dXJuIikgewogICAgICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gIm5leHQiOwogICAgICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkMjsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIGluZm87CiAgICAgICAgICB9CiAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDsKICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsOwogICAgICAgIH0KICAgICAgICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApOwogICAgICAgIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsICJHZW5lcmF0b3IiKTsKICAgICAgICBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbigpIHsKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIH0pOwogICAgICAgIGRlZmluZShHcCwgInRvU3RyaW5nIiwgZnVuY3Rpb24oKSB7CiAgICAgICAgICByZXR1cm4gIltvYmplY3QgR2VuZXJhdG9yXSI7CiAgICAgICAgfSk7CiAgICAgICAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHsKICAgICAgICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07CiAgICAgICAgICBpZiAoMSBpbiBsb2NzKSB7CiAgICAgICAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICgyIGluIGxvY3MpIHsKICAgICAgICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07CiAgICAgICAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkgewogICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307CiAgICAgICAgICByZWNvcmQudHlwZSA9ICJub3JtYWwiOwogICAgICAgICAgZGVsZXRlIHJlY29yZC5hcmc7CiAgICAgICAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7CiAgICAgICAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6ICJyb290IiB9XTsKICAgICAgICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTsKICAgICAgICAgIHRoaXMucmVzZXQodHJ1ZSk7CiAgICAgICAgfQogICAgICAgIGV4cG9ydHMyLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHsKICAgICAgICAgIHZhciBrZXlzID0gW107CiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7CiAgICAgICAgICAgIGtleXMucHVzaChrZXkpOwogICAgICAgICAgfQogICAgICAgICAga2V5cy5yZXZlcnNlKCk7CiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHsKICAgICAgICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7CiAgICAgICAgICAgICAgdmFyIGtleTIgPSBrZXlzLnBvcCgpOwogICAgICAgICAgICAgIGlmIChrZXkyIGluIG9iamVjdCkgewogICAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTI7CiAgICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTsKICAgICAgICAgICAgICAgIHJldHVybiBuZXh0OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlOwogICAgICAgICAgICByZXR1cm4gbmV4dDsKICAgICAgICAgIH07CiAgICAgICAgfTsKICAgICAgICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHsKICAgICAgICAgIGlmIChpdGVyYWJsZSkgewogICAgICAgICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07CiAgICAgICAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkgewogICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgICAgICByZXR1cm4gaXRlcmFibGU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7CiAgICAgICAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQyKCkgewogICAgICAgICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7CiAgICAgICAgICAgICAgICAgICAgbmV4dDIudmFsdWUgPSBpdGVyYWJsZVtpXTsKICAgICAgICAgICAgICAgICAgICBuZXh0Mi5kb25lID0gZmFsc2U7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQyOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBuZXh0Mi52YWx1ZSA9IHVuZGVmaW5lZDI7CiAgICAgICAgICAgICAgICBuZXh0Mi5kb25lID0gdHJ1ZTsKICAgICAgICAgICAgICAgIHJldHVybiBuZXh0MjsKICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0OwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07CiAgICAgICAgfQogICAgICAgIGV4cG9ydHMyLnZhbHVlcyA9IHZhbHVlczsKICAgICAgICBmdW5jdGlvbiBkb25lUmVzdWx0KCkgewogICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZDIsIGRvbmU6IHRydWUgfTsKICAgICAgICB9CiAgICAgICAgQ29udGV4dC5wcm90b3R5cGUgPSB7CiAgICAgICAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCwKICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7CiAgICAgICAgICAgIHRoaXMucHJldiA9IDA7CiAgICAgICAgICAgIHRoaXMubmV4dCA9IDA7CiAgICAgICAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQyOwogICAgICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTsKICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7CiAgICAgICAgICAgIHRoaXMubWV0aG9kID0gIm5leHQiOwogICAgICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDI7CiAgICAgICAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpOwogICAgICAgICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHsKICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHsKICAgICAgICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gInQiICYmIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHsKICAgICAgICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDI7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9LAogICAgICAgICAgc3RvcDogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7CiAgICAgICAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07CiAgICAgICAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247CiAgICAgICAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09ICJ0aHJvdyIpIHsKICAgICAgICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZzsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gdGhpcy5ydmFsOwogICAgICAgICAgfSwKICAgICAgICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHsKICAgICAgICAgICAgaWYgKHRoaXMuZG9uZSkgewogICAgICAgICAgICAgIHRocm93IGV4Y2VwdGlvbjsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7CiAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkgewogICAgICAgICAgICAgIHJlY29yZC50eXBlID0gInRocm93IjsKICAgICAgICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uOwogICAgICAgICAgICAgIGNvbnRleHQubmV4dCA9IGxvYzsKICAgICAgICAgICAgICBpZiAoY2F1Z2h0KSB7CiAgICAgICAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9ICJuZXh0IjsKICAgICAgICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkMjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuICEhY2F1Z2h0OwogICAgICAgICAgICB9CiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsKICAgICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07CiAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247CiAgICAgICAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gInJvb3QiKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKCJlbmQiKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHsKICAgICAgICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCAiY2F0Y2hMb2MiKTsKICAgICAgICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksICJmaW5hbGx5TG9jIik7CiAgICAgICAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkgewogICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTsKICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkgewogICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7CiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseSIpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfSwKICAgICAgICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7CiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsKICAgICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07CiAgICAgICAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiYgaGFzT3duLmNhbGwoZW50cnksICJmaW5hbGx5TG9jIikgJiYgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgewogICAgICAgICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5OwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChmaW5hbGx5RW50cnkgJiYgKHR5cGUgPT09ICJicmVhayIgfHwgdHlwZSA9PT0gImNvbnRpbnVlIikgJiYgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiYgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7CiAgICAgICAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTsKICAgICAgICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlOwogICAgICAgICAgICByZWNvcmQuYXJnID0gYXJnOwogICAgICAgICAgICBpZiAoZmluYWxseUVudHJ5KSB7CiAgICAgICAgICAgICAgdGhpcy5tZXRob2QgPSAibmV4dCI7CiAgICAgICAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7CiAgICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTsKICAgICAgICAgIH0sCiAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykgewogICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09ICJ0aHJvdyIpIHsKICAgICAgICAgICAgICB0aHJvdyByZWNvcmQuYXJnOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gImJyZWFrIiB8fCByZWNvcmQudHlwZSA9PT0gImNvbnRpbnVlIikgewogICAgICAgICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7CiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09ICJyZXR1cm4iKSB7CiAgICAgICAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnOwogICAgICAgICAgICAgIHRoaXMubWV0aG9kID0gInJldHVybiI7CiAgICAgICAgICAgICAgdGhpcy5uZXh0ID0gImVuZCI7CiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09ICJub3JtYWwiICYmIGFmdGVyTG9jKSB7CiAgICAgICAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7CiAgICAgICAgICB9LAogICAgICAgICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7CiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsKICAgICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07CiAgICAgICAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHsKICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpOwogICAgICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7CiAgICAgICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0sCiAgICAgICAgICAiY2F0Y2giOiBmdW5jdGlvbih0cnlMb2MpIHsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgewogICAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsKICAgICAgICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHsKICAgICAgICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uOwogICAgICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSAidGhyb3ciKSB7CiAgICAgICAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnOwogICAgICAgICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHJldHVybiB0aHJvd247CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiaWxsZWdhbCBjYXRjaCBhdHRlbXB0Iik7CiAgICAgICAgICB9LAogICAgICAgICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHsKICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHsKICAgICAgICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSwKICAgICAgICAgICAgICByZXN1bHROYW1lLAogICAgICAgICAgICAgIG5leHRMb2MKICAgICAgICAgICAgfTsKICAgICAgICAgICAgaWYgKHRoaXMubWV0aG9kID09PSAibmV4dCIpIHsKICAgICAgICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDI7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgICByZXR1cm4gZXhwb3J0czI7CiAgICAgIH0odHlwZW9mIG1vZHVsZSA9PT0gIm9iamVjdCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9KTsKICAgICAgdHJ5IHsKICAgICAgICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lOwogICAgICB9IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkgewogICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gIm9iamVjdCIpIHsKICAgICAgICAgIGdsb2JhbFRoaXMucmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgRnVuY3Rpb24oInIiLCAicmVnZW5lcmF0b3JSdW50aW1lID0gciIpKHJ1bnRpbWUpOwogICAgICAgIH0KICAgICAgfQogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9yZWdlbmVyYXRvci9pbmRleC5qcwogIHZhciByZXF1aXJlX3JlZ2VuZXJhdG9yID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvcmVnZW5lcmF0b3IvaW5kZXguanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZV9ydW50aW1lKCk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2l0ZXJhdGUuanMKICB2YXIgcmVxdWlyZV9pdGVyYXRlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvaXRlcmF0ZS5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGFuT2JqZWN0ID0gcmVxdWlyZV9hbl9vYmplY3QoKTsKICAgICAgdmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCA9IHJlcXVpcmVfaXNfYXJyYXlfaXRlcmF0b3JfbWV0aG9kKCk7CiAgICAgIHZhciB0b0xlbmd0aCA9IHJlcXVpcmVfdG9fbGVuZ3RoKCk7CiAgICAgIHZhciBiaW5kID0gcmVxdWlyZV9mdW5jdGlvbl9iaW5kX2NvbnRleHQoKTsKICAgICAgdmFyIGdldEl0ZXJhdG9yID0gcmVxdWlyZV9nZXRfaXRlcmF0b3IoKTsKICAgICAgdmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZV9nZXRfaXRlcmF0b3JfbWV0aG9kKCk7CiAgICAgIHZhciBpdGVyYXRvckNsb3NlID0gcmVxdWlyZV9pdGVyYXRvcl9jbG9zZSgpOwogICAgICB2YXIgUmVzdWx0ID0gZnVuY3Rpb24oc3RvcHBlZCwgcmVzdWx0KSB7CiAgICAgICAgdGhpcy5zdG9wcGVkID0gc3RvcHBlZDsKICAgICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDsKICAgICAgfTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYWJsZSwgdW5ib3VuZEZ1bmN0aW9uLCBvcHRpb25zKSB7CiAgICAgICAgdmFyIHRoYXQgPSBvcHRpb25zICYmIG9wdGlvbnMudGhhdDsKICAgICAgICB2YXIgQVNfRU5UUklFUyA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5BU19FTlRSSUVTKTsKICAgICAgICB2YXIgSVNfSVRFUkFUT1IgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSVNfSVRFUkFUT1IpOwogICAgICAgIHZhciBJTlRFUlJVUFRFRCA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JTlRFUlJVUFRFRCk7CiAgICAgICAgdmFyIGZuID0gYmluZCh1bmJvdW5kRnVuY3Rpb24sIHRoYXQsIDEgKyBBU19FTlRSSUVTICsgSU5URVJSVVBURUQpOwogICAgICAgIHZhciBpdGVyYXRvciwgaXRlckZuLCBpbmRleCwgbGVuZ3RoLCByZXN1bHQsIG5leHQsIHN0ZXA7CiAgICAgICAgdmFyIHN0b3AgPSBmdW5jdGlvbihjb25kaXRpb24pIHsKICAgICAgICAgIGlmIChpdGVyYXRvcikKICAgICAgICAgICAgaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgIm5vcm1hbCIsIGNvbmRpdGlvbik7CiAgICAgICAgICByZXR1cm4gbmV3IFJlc3VsdCh0cnVlLCBjb25kaXRpb24pOwogICAgICAgIH07CiAgICAgICAgdmFyIGNhbGxGbiA9IGZ1bmN0aW9uKHZhbHVlKSB7CiAgICAgICAgICBpZiAoQVNfRU5UUklFUykgewogICAgICAgICAgICBhbk9iamVjdCh2YWx1ZSk7CiAgICAgICAgICAgIHJldHVybiBJTlRFUlJVUFRFRCA/IGZuKHZhbHVlWzBdLCB2YWx1ZVsxXSwgc3RvcCkgOiBmbih2YWx1ZVswXSwgdmFsdWVbMV0pOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIElOVEVSUlVQVEVEID8gZm4odmFsdWUsIHN0b3ApIDogZm4odmFsdWUpOwogICAgICAgIH07CiAgICAgICAgaWYgKElTX0lURVJBVE9SKSB7CiAgICAgICAgICBpdGVyYXRvciA9IGl0ZXJhYmxlOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpdGVyRm4gPSBnZXRJdGVyYXRvck1ldGhvZChpdGVyYWJsZSk7CiAgICAgICAgICBpZiAoIWl0ZXJGbikKICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFN0cmluZyhpdGVyYWJsZSkgKyAiIGlzIG5vdCBpdGVyYWJsZSIpOwogICAgICAgICAgaWYgKGlzQXJyYXlJdGVyYXRvck1ldGhvZChpdGVyRm4pKSB7CiAgICAgICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgewogICAgICAgICAgICAgIHJlc3VsdCA9IGNhbGxGbihpdGVyYWJsZVtpbmRleF0pOwogICAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0IGluc3RhbmNlb2YgUmVzdWx0KQogICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7CiAgICAgICAgICB9CiAgICAgICAgICBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGl0ZXJhYmxlLCBpdGVyRm4pOwogICAgICAgIH0KICAgICAgICBuZXh0ID0gaXRlcmF0b3IubmV4dDsKICAgICAgICB3aGlsZSAoIShzdGVwID0gbmV4dC5jYWxsKGl0ZXJhdG9yKSkuZG9uZSkgewogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgcmVzdWx0ID0gY2FsbEZuKHN0ZXAudmFsdWUpOwogICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgICAgaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgInRocm93IiwgZXJyb3IpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gIm9iamVjdCIgJiYgcmVzdWx0ICYmIHJlc3VsdCBpbnN0YW5jZW9mIFJlc3VsdCkKICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuYWdncmVnYXRlLWVycm9yLmpzCiAgdmFyIHJlcXVpcmVfZXNfYWdncmVnYXRlX2Vycm9yID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLmFnZ3JlZ2F0ZS1lcnJvci5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgJCA9IHJlcXVpcmVfZXhwb3J0KCk7CiAgICAgIHZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmVfb2JqZWN0X2dldF9wcm90b3R5cGVfb2YoKTsKICAgICAgdmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZV9vYmplY3Rfc2V0X3Byb3RvdHlwZV9vZigpOwogICAgICB2YXIgY3JlYXRlID0gcmVxdWlyZV9vYmplY3RfY3JlYXRlKCk7CiAgICAgIHZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlX2NyZWF0ZV9ub25fZW51bWVyYWJsZV9wcm9wZXJ0eSgpOwogICAgICB2YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZV9jcmVhdGVfcHJvcGVydHlfZGVzY3JpcHRvcigpOwogICAgICB2YXIgaXRlcmF0ZSA9IHJlcXVpcmVfaXRlcmF0ZSgpOwogICAgICB2YXIgdG9TdHJpbmcgPSByZXF1aXJlX3RvX3N0cmluZygpOwogICAgICB2YXIgJEFnZ3JlZ2F0ZUVycm9yID0gZnVuY3Rpb24gQWdncmVnYXRlRXJyb3IoZXJyb3JzLCBtZXNzYWdlKSB7CiAgICAgICAgdmFyIHRoYXQgPSB0aGlzOwogICAgICAgIGlmICghKHRoYXQgaW5zdGFuY2VvZiAkQWdncmVnYXRlRXJyb3IpKQogICAgICAgICAgcmV0dXJuIG5ldyAkQWdncmVnYXRlRXJyb3IoZXJyb3JzLCBtZXNzYWdlKTsKICAgICAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHsKICAgICAgICAgIHRoYXQgPSBzZXRQcm90b3R5cGVPZihuZXcgRXJyb3Iodm9pZCAwKSwgZ2V0UHJvdG90eXBlT2YodGhhdCkpOwogICAgICAgIH0KICAgICAgICBpZiAobWVzc2FnZSAhPT0gdm9pZCAwKQogICAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHRoYXQsICJtZXNzYWdlIiwgdG9TdHJpbmcobWVzc2FnZSkpOwogICAgICAgIHZhciBlcnJvcnNBcnJheSA9IFtdOwogICAgICAgIGl0ZXJhdGUoZXJyb3JzLCBlcnJvcnNBcnJheS5wdXNoLCB7IHRoYXQ6IGVycm9yc0FycmF5IH0pOwogICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSh0aGF0LCAiZXJyb3JzIiwgZXJyb3JzQXJyYXkpOwogICAgICAgIHJldHVybiB0aGF0OwogICAgICB9OwogICAgICAkQWdncmVnYXRlRXJyb3IucHJvdG90eXBlID0gY3JlYXRlKEVycm9yLnByb3RvdHlwZSwgewogICAgICAgIGNvbnN0cnVjdG9yOiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoNSwgJEFnZ3JlZ2F0ZUVycm9yKSwKICAgICAgICBtZXNzYWdlOiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoNSwgIiIpLAogICAgICAgIG5hbWU6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcig1LCAiQWdncmVnYXRlRXJyb3IiKQogICAgICB9KTsKICAgICAgJCh7IGdsb2JhbDogdHJ1ZSB9LCB7CiAgICAgICAgQWdncmVnYXRlRXJyb3I6ICRBZ2dyZWdhdGVFcnJvcgogICAgICB9KTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvbmF0aXZlLXByb21pc2UtY29uc3RydWN0b3IuanMKICB2YXIgcmVxdWlyZV9uYXRpdmVfcHJvbWlzZV9jb25zdHJ1Y3RvciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL25hdGl2ZS1wcm9taXNlLWNvbnN0cnVjdG9yLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgZ2xvYmFsMiA9IHJlcXVpcmVfZ2xvYmFsKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsMi5Qcm9taXNlOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9yZWRlZmluZS1hbGwuanMKICB2YXIgcmVxdWlyZV9yZWRlZmluZV9hbGwgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9yZWRlZmluZS1hbGwuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciByZWRlZmluZSA9IHJlcXVpcmVfcmVkZWZpbmUoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0YXJnZXQsIHNyYywgb3B0aW9ucykgewogICAgICAgIGZvciAodmFyIGtleSBpbiBzcmMpIHsKICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudW5zYWZlICYmIHRhcmdldFtrZXldKQogICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNyY1trZXldOwogICAgICAgICAgZWxzZQogICAgICAgICAgICByZWRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0sIG9wdGlvbnMpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGFyZ2V0OwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9zZXQtc3BlY2llcy5qcwogIHZhciByZXF1aXJlX3NldF9zcGVjaWVzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvc2V0LXNwZWNpZXMuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlX2dldF9idWlsdF9pbigpOwogICAgICB2YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlX29iamVjdF9kZWZpbmVfcHJvcGVydHkoKTsKICAgICAgdmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmVfd2VsbF9rbm93bl9zeW1ib2woKTsKICAgICAgdmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZV9kZXNjcmlwdG9ycygpOwogICAgICB2YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgic3BlY2llcyIpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENPTlNUUlVDVE9SX05BTUUpIHsKICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSBnZXRCdWlsdEluKENPTlNUUlVDVE9SX05BTUUpOwogICAgICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7CiAgICAgICAgaWYgKERFU0NSSVBUT1JTICYmIENvbnN0cnVjdG9yICYmICFDb25zdHJ1Y3RvcltTUEVDSUVTXSkgewogICAgICAgICAgZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFNQRUNJRVMsIHsKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2FuLWluc3RhbmNlLmpzCiAgdmFyIHJlcXVpcmVfYW5faW5zdGFuY2UgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9hbi1pbnN0YW5jZS5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgQ29uc3RydWN0b3IsIG5hbWUpIHsKICAgICAgICBpZiAoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikKICAgICAgICAgIHJldHVybiBpdDsKICAgICAgICB0aHJvdyBUeXBlRXJyb3IoIkluY29ycmVjdCAiICsgKG5hbWUgPyBuYW1lICsgIiAiIDogIiIpICsgImludm9jYXRpb24iKTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvc3BlY2llcy1jb25zdHJ1Y3Rvci5qcwogIHZhciByZXF1aXJlX3NwZWNpZXNfY29uc3RydWN0b3IgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgYW5PYmplY3QgPSByZXF1aXJlX2FuX29iamVjdCgpOwogICAgICB2YXIgYUNvbnN0cnVjdG9yID0gcmVxdWlyZV9hX2NvbnN0cnVjdG9yKCk7CiAgICAgIHZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlX3dlbGxfa25vd25fc3ltYm9sKCk7CiAgICAgIHZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCJzcGVjaWVzIik7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTywgZGVmYXVsdENvbnN0cnVjdG9yKSB7CiAgICAgICAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvcjsKICAgICAgICB2YXIgUzsKICAgICAgICByZXR1cm4gQyA9PT0gdm9pZCAwIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHZvaWQgMCA/IGRlZmF1bHRDb25zdHJ1Y3RvciA6IGFDb25zdHJ1Y3RvcihTKTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZW5naW5lLWlzLWlvcy5qcwogIHZhciByZXF1aXJlX2VuZ2luZV9pc19pb3MgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9lbmdpbmUtaXMtaW9zLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgdXNlckFnZW50ID0gcmVxdWlyZV9lbmdpbmVfdXNlcl9hZ2VudCgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IC8oPzppcGFkfGlwaG9uZXxpcG9kKS4qYXBwbGV3ZWJraXQvaS50ZXN0KHVzZXJBZ2VudCk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2VuZ2luZS1pcy1ub2RlLmpzCiAgdmFyIHJlcXVpcmVfZW5naW5lX2lzX25vZGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9lbmdpbmUtaXMtbm9kZS5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGNsYXNzb2YgPSByZXF1aXJlX2NsYXNzb2ZfcmF3KCk7CiAgICAgIHZhciBnbG9iYWwyID0gcmVxdWlyZV9nbG9iYWwoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBjbGFzc29mKGdsb2JhbDIucHJvY2VzcykgPT0gInByb2Nlc3MiOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy90YXNrLmpzCiAgdmFyIHJlcXVpcmVfdGFzayA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3Rhc2suanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBnbG9iYWwyID0gcmVxdWlyZV9nbG9iYWwoKTsKICAgICAgdmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlX2lzX2NhbGxhYmxlKCk7CiAgICAgIHZhciBmYWlscyA9IHJlcXVpcmVfZmFpbHMoKTsKICAgICAgdmFyIGJpbmQgPSByZXF1aXJlX2Z1bmN0aW9uX2JpbmRfY29udGV4dCgpOwogICAgICB2YXIgaHRtbCA9IHJlcXVpcmVfaHRtbCgpOwogICAgICB2YXIgY3JlYXRlRWxlbWVudCA9IHJlcXVpcmVfZG9jdW1lbnRfY3JlYXRlX2VsZW1lbnQoKTsKICAgICAgdmFyIElTX0lPUyA9IHJlcXVpcmVfZW5naW5lX2lzX2lvcygpOwogICAgICB2YXIgSVNfTk9ERSA9IHJlcXVpcmVfZW5naW5lX2lzX25vZGUoKTsKICAgICAgdmFyIHNldCA9IGdsb2JhbDIuc2V0SW1tZWRpYXRlOwogICAgICB2YXIgY2xlYXIgPSBnbG9iYWwyLmNsZWFySW1tZWRpYXRlOwogICAgICB2YXIgcHJvY2VzczIgPSBnbG9iYWwyLnByb2Nlc3M7CiAgICAgIHZhciBNZXNzYWdlQ2hhbm5lbCA9IGdsb2JhbDIuTWVzc2FnZUNoYW5uZWw7CiAgICAgIHZhciBEaXNwYXRjaCA9IGdsb2JhbDIuRGlzcGF0Y2g7CiAgICAgIHZhciBjb3VudGVyID0gMDsKICAgICAgdmFyIHF1ZXVlID0ge307CiAgICAgIHZhciBPTlJFQURZU1RBVEVDSEFOR0UgPSAib25yZWFkeXN0YXRlY2hhbmdlIjsKICAgICAgdmFyIGxvY2F0aW9uOwogICAgICB2YXIgZGVmZXI7CiAgICAgIHZhciBjaGFubmVsOwogICAgICB2YXIgcG9ydDsKICAgICAgdHJ5IHsKICAgICAgICBsb2NhdGlvbiA9IGdsb2JhbDIubG9jYXRpb247CiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgIH0KICAgICAgdmFyIHJ1biA9IGZ1bmN0aW9uKGlkKSB7CiAgICAgICAgaWYgKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSkgewogICAgICAgICAgdmFyIGZuID0gcXVldWVbaWRdOwogICAgICAgICAgZGVsZXRlIHF1ZXVlW2lkXTsKICAgICAgICAgIGZuKCk7CiAgICAgICAgfQogICAgICB9OwogICAgICB2YXIgcnVubmVyID0gZnVuY3Rpb24oaWQpIHsKICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7CiAgICAgICAgICBydW4oaWQpOwogICAgICAgIH07CiAgICAgIH07CiAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50KSB7CiAgICAgICAgcnVuKGV2ZW50LmRhdGEpOwogICAgICB9OwogICAgICB2YXIgcG9zdCA9IGZ1bmN0aW9uKGlkKSB7CiAgICAgICAgZ2xvYmFsMi5wb3N0TWVzc2FnZShTdHJpbmcoaWQpLCBsb2NhdGlvbi5wcm90b2NvbCArICIvLyIgKyBsb2NhdGlvbi5ob3N0KTsKICAgICAgfTsKICAgICAgaWYgKCFzZXQgfHwgIWNsZWFyKSB7CiAgICAgICAgc2V0ID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKSB7CiAgICAgICAgICB2YXIgYXJncyA9IFtdOwogICAgICAgICAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7CiAgICAgICAgICB2YXIgaSA9IDE7CiAgICAgICAgICB3aGlsZSAoYXJndW1lbnRzTGVuZ3RoID4gaSkKICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTsKICAgICAgICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgKGlzQ2FsbGFibGUoZm4pID8gZm4gOiBGdW5jdGlvbihmbikpLmFwcGx5KHZvaWQgMCwgYXJncyk7CiAgICAgICAgICB9OwogICAgICAgICAgZGVmZXIoY291bnRlcik7CiAgICAgICAgICByZXR1cm4gY291bnRlcjsKICAgICAgICB9OwogICAgICAgIGNsZWFyID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHsKICAgICAgICAgIGRlbGV0ZSBxdWV1ZVtpZF07CiAgICAgICAgfTsKICAgICAgICBpZiAoSVNfTk9ERSkgewogICAgICAgICAgZGVmZXIgPSBmdW5jdGlvbihpZCkgewogICAgICAgICAgICBwcm9jZXNzMi5uZXh0VGljayhydW5uZXIoaWQpKTsKICAgICAgICAgIH07CiAgICAgICAgfSBlbHNlIGlmIChEaXNwYXRjaCAmJiBEaXNwYXRjaC5ub3cpIHsKICAgICAgICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpIHsKICAgICAgICAgICAgRGlzcGF0Y2gubm93KHJ1bm5lcihpZCkpOwogICAgICAgICAgfTsKICAgICAgICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsICYmICFJU19JT1MpIHsKICAgICAgICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTsKICAgICAgICAgIHBvcnQgPSBjaGFubmVsLnBvcnQyOwogICAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjsKICAgICAgICAgIGRlZmVyID0gYmluZChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTsKICAgICAgICB9IGVsc2UgaWYgKGdsb2JhbDIuYWRkRXZlbnRMaXN0ZW5lciAmJiBpc0NhbGxhYmxlKGdsb2JhbDIucG9zdE1lc3NhZ2UpICYmICFnbG9iYWwyLmltcG9ydFNjcmlwdHMgJiYgbG9jYXRpb24gJiYgbG9jYXRpb24ucHJvdG9jb2wgIT09ICJmaWxlOiIgJiYgIWZhaWxzKHBvc3QpKSB7CiAgICAgICAgICBkZWZlciA9IHBvc3Q7CiAgICAgICAgICBnbG9iYWwyLmFkZEV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLCBsaXN0ZW5lciwgZmFsc2UpOwogICAgICAgIH0gZWxzZSBpZiAoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNyZWF0ZUVsZW1lbnQoInNjcmlwdCIpKSB7CiAgICAgICAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKSB7CiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY3JlYXRlRWxlbWVudCgic2NyaXB0IikpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpOwogICAgICAgICAgICAgIHJ1bihpZCk7CiAgICAgICAgICAgIH07CiAgICAgICAgICB9OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKSB7CiAgICAgICAgICAgIHNldFRpbWVvdXQocnVubmVyKGlkKSwgMCk7CiAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgfQogICAgICBtb2R1bGUuZXhwb3J0cyA9IHsKICAgICAgICBzZXQsCiAgICAgICAgY2xlYXIKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZW5naW5lLWlzLWlvcy1wZWJibGUuanMKICB2YXIgcmVxdWlyZV9lbmdpbmVfaXNfaW9zX3BlYmJsZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2VuZ2luZS1pcy1pb3MtcGViYmxlLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgdXNlckFnZW50ID0gcmVxdWlyZV9lbmdpbmVfdXNlcl9hZ2VudCgpOwogICAgICB2YXIgZ2xvYmFsMiA9IHJlcXVpcmVfZ2xvYmFsKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gL2lwYWR8aXBob25lfGlwb2QvaS50ZXN0KHVzZXJBZ2VudCkgJiYgZ2xvYmFsMi5QZWJibGUgIT09IHZvaWQgMDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZW5naW5lLWlzLXdlYm9zLXdlYmtpdC5qcwogIHZhciByZXF1aXJlX2VuZ2luZV9pc193ZWJvc193ZWJraXQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9lbmdpbmUtaXMtd2Vib3Mtd2Via2l0LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgdXNlckFnZW50ID0gcmVxdWlyZV9lbmdpbmVfdXNlcl9hZ2VudCgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IC93ZWIwcyg/IS4qY2hyb21lKS9pLnRlc3QodXNlckFnZW50KTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvbWljcm90YXNrLmpzCiAgdmFyIHJlcXVpcmVfbWljcm90YXNrID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvbWljcm90YXNrLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgZ2xvYmFsMiA9IHJlcXVpcmVfZ2xvYmFsKCk7CiAgICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlX29iamVjdF9nZXRfb3duX3Byb3BlcnR5X2Rlc2NyaXB0b3IoKS5mOwogICAgICB2YXIgbWFjcm90YXNrID0gcmVxdWlyZV90YXNrKCkuc2V0OwogICAgICB2YXIgSVNfSU9TID0gcmVxdWlyZV9lbmdpbmVfaXNfaW9zKCk7CiAgICAgIHZhciBJU19JT1NfUEVCQkxFID0gcmVxdWlyZV9lbmdpbmVfaXNfaW9zX3BlYmJsZSgpOwogICAgICB2YXIgSVNfV0VCT1NfV0VCS0lUID0gcmVxdWlyZV9lbmdpbmVfaXNfd2Vib3Nfd2Via2l0KCk7CiAgICAgIHZhciBJU19OT0RFID0gcmVxdWlyZV9lbmdpbmVfaXNfbm9kZSgpOwogICAgICB2YXIgTXV0YXRpb25PYnNlcnZlciA9IGdsb2JhbDIuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwyLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7CiAgICAgIHZhciBkb2N1bWVudDIgPSBnbG9iYWwyLmRvY3VtZW50OwogICAgICB2YXIgcHJvY2VzczIgPSBnbG9iYWwyLnByb2Nlc3M7CiAgICAgIHZhciBQcm9taXNlMiA9IGdsb2JhbDIuUHJvbWlzZTsKICAgICAgdmFyIHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihnbG9iYWwyLCAicXVldWVNaWNyb3Rhc2siKTsKICAgICAgdmFyIHF1ZXVlTWljcm90YXNrID0gcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yICYmIHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvci52YWx1ZTsKICAgICAgdmFyIGZsdXNoOwogICAgICB2YXIgaGVhZDsKICAgICAgdmFyIGxhc3Q7CiAgICAgIHZhciBub3RpZnk7CiAgICAgIHZhciB0b2dnbGU7CiAgICAgIHZhciBub2RlOwogICAgICB2YXIgcHJvbWlzZTsKICAgICAgdmFyIHRoZW47CiAgICAgIGlmICghcXVldWVNaWNyb3Rhc2spIHsKICAgICAgICBmbHVzaCA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgdmFyIHBhcmVudCwgZm47CiAgICAgICAgICBpZiAoSVNfTk9ERSAmJiAocGFyZW50ID0gcHJvY2VzczIuZG9tYWluKSkKICAgICAgICAgICAgcGFyZW50LmV4aXQoKTsKICAgICAgICAgIHdoaWxlIChoZWFkKSB7CiAgICAgICAgICAgIGZuID0gaGVhZC5mbjsKICAgICAgICAgICAgaGVhZCA9IGhlYWQubmV4dDsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBmbigpOwogICAgICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgICAgIGlmIChoZWFkKQogICAgICAgICAgICAgICAgbm90aWZ5KCk7CiAgICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICAgbGFzdCA9IHZvaWQgMDsKICAgICAgICAgICAgICB0aHJvdyBlcnJvcjsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgbGFzdCA9IHZvaWQgMDsKICAgICAgICAgIGlmIChwYXJlbnQpCiAgICAgICAgICAgIHBhcmVudC5lbnRlcigpOwogICAgICAgIH07CiAgICAgICAgaWYgKCFJU19JT1MgJiYgIUlTX05PREUgJiYgIUlTX1dFQk9TX1dFQktJVCAmJiBNdXRhdGlvbk9ic2VydmVyICYmIGRvY3VtZW50MikgewogICAgICAgICAgdG9nZ2xlID0gdHJ1ZTsKICAgICAgICAgIG5vZGUgPSBkb2N1bWVudDIuY3JlYXRlVGV4dE5vZGUoIiIpOwogICAgICAgICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pOwogICAgICAgICAgbm90aWZ5ID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7CiAgICAgICAgICB9OwogICAgICAgIH0gZWxzZSBpZiAoIUlTX0lPU19QRUJCTEUgJiYgUHJvbWlzZTIgJiYgUHJvbWlzZTIucmVzb2x2ZSkgewogICAgICAgICAgcHJvbWlzZSA9IFByb21pc2UyLnJlc29sdmUodm9pZCAwKTsKICAgICAgICAgIHByb21pc2UuY29uc3RydWN0b3IgPSBQcm9taXNlMjsKICAgICAgICAgIHRoZW4gPSBwcm9taXNlLnRoZW47CiAgICAgICAgICBub3RpZnkgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgdGhlbi5jYWxsKHByb21pc2UsIGZsdXNoKTsKICAgICAgICAgIH07CiAgICAgICAgfSBlbHNlIGlmIChJU19OT0RFKSB7CiAgICAgICAgICBub3RpZnkgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgcHJvY2VzczIubmV4dFRpY2soZmx1c2gpOwogICAgICAgICAgfTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgbm90aWZ5ID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbDIsIGZsdXNoKTsKICAgICAgICAgIH07CiAgICAgICAgfQogICAgICB9CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcXVldWVNaWNyb3Rhc2sgfHwgZnVuY3Rpb24oZm4pIHsKICAgICAgICB2YXIgdGFzayA9IHsgZm4sIG5leHQ6IHZvaWQgMCB9OwogICAgICAgIGlmIChsYXN0KQogICAgICAgICAgbGFzdC5uZXh0ID0gdGFzazsKICAgICAgICBpZiAoIWhlYWQpIHsKICAgICAgICAgIGhlYWQgPSB0YXNrOwogICAgICAgICAgbm90aWZ5KCk7CiAgICAgICAgfQogICAgICAgIGxhc3QgPSB0YXNrOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzCiAgdmFyIHJlcXVpcmVfbmV3X3Byb21pc2VfY2FwYWJpbGl0eSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL25ldy1wcm9taXNlLWNhcGFiaWxpdHkuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIGFDYWxsYWJsZSA9IHJlcXVpcmVfYV9jYWxsYWJsZSgpOwogICAgICB2YXIgUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbihDKSB7CiAgICAgICAgdmFyIHJlc29sdmUsIHJlamVjdDsKICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbigkJHJlc29sdmUsICQkcmVqZWN0KSB7CiAgICAgICAgICBpZiAocmVzb2x2ZSAhPT0gdm9pZCAwIHx8IHJlamVjdCAhPT0gdm9pZCAwKQogICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoIkJhZCBQcm9taXNlIGNvbnN0cnVjdG9yIik7CiAgICAgICAgICByZXNvbHZlID0gJCRyZXNvbHZlOwogICAgICAgICAgcmVqZWN0ID0gJCRyZWplY3Q7CiAgICAgICAgfSk7CiAgICAgICAgdGhpcy5yZXNvbHZlID0gYUNhbGxhYmxlKHJlc29sdmUpOwogICAgICAgIHRoaXMucmVqZWN0ID0gYUNhbGxhYmxlKHJlamVjdCk7CiAgICAgIH07CiAgICAgIG1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbihDKSB7CiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvcHJvbWlzZS1yZXNvbHZlLmpzCiAgdmFyIHJlcXVpcmVfcHJvbWlzZV9yZXNvbHZlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvcHJvbWlzZS1yZXNvbHZlLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgYW5PYmplY3QgPSByZXF1aXJlX2FuX29iamVjdCgpOwogICAgICB2YXIgaXNPYmplY3QgPSByZXF1aXJlX2lzX29iamVjdCgpOwogICAgICB2YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlX25ld19wcm9taXNlX2NhcGFiaWxpdHkoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDLCB4KSB7CiAgICAgICAgYW5PYmplY3QoQyk7CiAgICAgICAgaWYgKGlzT2JqZWN0KHgpICYmIHguY29uc3RydWN0b3IgPT09IEMpCiAgICAgICAgICByZXR1cm4geDsKICAgICAgICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKEMpOwogICAgICAgIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTsKICAgICAgICByZXNvbHZlKHgpOwogICAgICAgIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9ob3N0LXJlcG9ydC1lcnJvcnMuanMKICB2YXIgcmVxdWlyZV9ob3N0X3JlcG9ydF9lcnJvcnMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9ob3N0LXJlcG9ydC1lcnJvcnMuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBnbG9iYWwyID0gcmVxdWlyZV9nbG9iYWwoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhLCBiKSB7CiAgICAgICAgdmFyIGNvbnNvbGUyID0gZ2xvYmFsMi5jb25zb2xlOwogICAgICAgIGlmIChjb25zb2xlMiAmJiBjb25zb2xlMi5lcnJvcikgewogICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGNvbnNvbGUyLmVycm9yKGEpIDogY29uc29sZTIuZXJyb3IoYSwgYik7CiAgICAgICAgfQogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9wZXJmb3JtLmpzCiAgdmFyIHJlcXVpcmVfcGVyZm9ybSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3BlcmZvcm0uanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYykgewogICAgICAgIHRyeSB7CiAgICAgICAgICByZXR1cm4geyBlcnJvcjogZmFsc2UsIHZhbHVlOiBleGVjKCkgfTsKICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHRydWUsIHZhbHVlOiBlcnJvciB9OwogICAgICAgIH0KICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZW5naW5lLWlzLWJyb3dzZXIuanMKICB2YXIgcmVxdWlyZV9lbmdpbmVfaXNfYnJvd3NlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2VuZ2luZS1pcy1icm93c2VyLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgPT0gIm9iamVjdCI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5wcm9taXNlLmpzCiAgdmFyIHJlcXVpcmVfZXNfcHJvbWlzZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5wcm9taXNlLmpzIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciAkID0gcmVxdWlyZV9leHBvcnQoKTsKICAgICAgdmFyIElTX1BVUkUgPSByZXF1aXJlX2lzX3B1cmUoKTsKICAgICAgdmFyIGdsb2JhbDIgPSByZXF1aXJlX2dsb2JhbCgpOwogICAgICB2YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmVfZ2V0X2J1aWx0X2luKCk7CiAgICAgIHZhciBOYXRpdmVQcm9taXNlID0gcmVxdWlyZV9uYXRpdmVfcHJvbWlzZV9jb25zdHJ1Y3RvcigpOwogICAgICB2YXIgcmVkZWZpbmUgPSByZXF1aXJlX3JlZGVmaW5lKCk7CiAgICAgIHZhciByZWRlZmluZUFsbCA9IHJlcXVpcmVfcmVkZWZpbmVfYWxsKCk7CiAgICAgIHZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmVfb2JqZWN0X3NldF9wcm90b3R5cGVfb2YoKTsKICAgICAgdmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZV9zZXRfdG9fc3RyaW5nX3RhZygpOwogICAgICB2YXIgc2V0U3BlY2llcyA9IHJlcXVpcmVfc2V0X3NwZWNpZXMoKTsKICAgICAgdmFyIGFDYWxsYWJsZSA9IHJlcXVpcmVfYV9jYWxsYWJsZSgpOwogICAgICB2YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmVfaXNfY2FsbGFibGUoKTsKICAgICAgdmFyIGlzT2JqZWN0ID0gcmVxdWlyZV9pc19vYmplY3QoKTsKICAgICAgdmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlX2FuX2luc3RhbmNlKCk7CiAgICAgIHZhciBpbnNwZWN0U291cmNlID0gcmVxdWlyZV9pbnNwZWN0X3NvdXJjZSgpOwogICAgICB2YXIgaXRlcmF0ZSA9IHJlcXVpcmVfaXRlcmF0ZSgpOwogICAgICB2YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gcmVxdWlyZV9jaGVja19jb3JyZWN0bmVzc19vZl9pdGVyYXRpb24oKTsKICAgICAgdmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmVfc3BlY2llc19jb25zdHJ1Y3RvcigpOwogICAgICB2YXIgdGFzayA9IHJlcXVpcmVfdGFzaygpLnNldDsKICAgICAgdmFyIG1pY3JvdGFzayA9IHJlcXVpcmVfbWljcm90YXNrKCk7CiAgICAgIHZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmVfcHJvbWlzZV9yZXNvbHZlKCk7CiAgICAgIHZhciBob3N0UmVwb3J0RXJyb3JzID0gcmVxdWlyZV9ob3N0X3JlcG9ydF9lcnJvcnMoKTsKICAgICAgdmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gcmVxdWlyZV9uZXdfcHJvbWlzZV9jYXBhYmlsaXR5KCk7CiAgICAgIHZhciBwZXJmb3JtID0gcmVxdWlyZV9wZXJmb3JtKCk7CiAgICAgIHZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZV9pbnRlcm5hbF9zdGF0ZSgpOwogICAgICB2YXIgaXNGb3JjZWQgPSByZXF1aXJlX2lzX2ZvcmNlZCgpOwogICAgICB2YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZV93ZWxsX2tub3duX3N5bWJvbCgpOwogICAgICB2YXIgSVNfQlJPV1NFUiA9IHJlcXVpcmVfZW5naW5lX2lzX2Jyb3dzZXIoKTsKICAgICAgdmFyIElTX05PREUgPSByZXF1aXJlX2VuZ2luZV9pc19ub2RlKCk7CiAgICAgIHZhciBWOF9WRVJTSU9OID0gcmVxdWlyZV9lbmdpbmVfdjhfdmVyc2lvbigpOwogICAgICB2YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgic3BlY2llcyIpOwogICAgICB2YXIgUFJPTUlTRSA9ICJQcm9taXNlIjsKICAgICAgdmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDsKICAgICAgdmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDsKICAgICAgdmFyIGdldEludGVybmFsUHJvbWlzZVN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoUFJPTUlTRSk7CiAgICAgIHZhciBOYXRpdmVQcm9taXNlUHJvdG90eXBlID0gTmF0aXZlUHJvbWlzZSAmJiBOYXRpdmVQcm9taXNlLnByb3RvdHlwZTsKICAgICAgdmFyIFByb21pc2VDb25zdHJ1Y3RvciA9IE5hdGl2ZVByb21pc2U7CiAgICAgIHZhciBQcm9taXNlQ29uc3RydWN0b3JQcm90b3R5cGUgPSBOYXRpdmVQcm9taXNlUHJvdG90eXBlOwogICAgICB2YXIgVHlwZUVycm9yMiA9IGdsb2JhbDIuVHlwZUVycm9yOwogICAgICB2YXIgZG9jdW1lbnQyID0gZ2xvYmFsMi5kb2N1bWVudDsKICAgICAgdmFyIHByb2Nlc3MyID0gZ2xvYmFsMi5wcm9jZXNzOwogICAgICB2YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mOwogICAgICB2YXIgbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHk7CiAgICAgIHZhciBESVNQQVRDSF9FVkVOVCA9ICEhKGRvY3VtZW50MiAmJiBkb2N1bWVudDIuY3JlYXRlRXZlbnQgJiYgZ2xvYmFsMi5kaXNwYXRjaEV2ZW50KTsKICAgICAgdmFyIE5BVElWRV9SRUpFQ1RJT05fRVZFTlQgPSBpc0NhbGxhYmxlKGdsb2JhbDIuUHJvbWlzZVJlamVjdGlvbkV2ZW50KTsKICAgICAgdmFyIFVOSEFORExFRF9SRUpFQ1RJT04gPSAidW5oYW5kbGVkcmVqZWN0aW9uIjsKICAgICAgdmFyIFJFSkVDVElPTl9IQU5ETEVEID0gInJlamVjdGlvbmhhbmRsZWQiOwogICAgICB2YXIgUEVORElORyA9IDA7CiAgICAgIHZhciBGVUxGSUxMRUQgPSAxOwogICAgICB2YXIgUkVKRUNURUQgPSAyOwogICAgICB2YXIgSEFORExFRCA9IDE7CiAgICAgIHZhciBVTkhBTkRMRUQgPSAyOwogICAgICB2YXIgU1VCQ0xBU1NJTkcgPSBmYWxzZTsKICAgICAgdmFyIEludGVybmFsOwogICAgICB2YXIgT3duUHJvbWlzZUNhcGFiaWxpdHk7CiAgICAgIHZhciBQcm9taXNlV3JhcHBlcjsKICAgICAgdmFyIG5hdGl2ZVRoZW47CiAgICAgIHZhciBGT1JDRUQgPSBpc0ZvcmNlZChQUk9NSVNFLCBmdW5jdGlvbigpIHsKICAgICAgICB2YXIgUFJPTUlTRV9DT05TVFJVQ1RPUl9TT1VSQ0UgPSBpbnNwZWN0U291cmNlKFByb21pc2VDb25zdHJ1Y3Rvcik7CiAgICAgICAgdmFyIEdMT0JBTF9DT1JFX0pTX1BST01JU0UgPSBQUk9NSVNFX0NPTlNUUlVDVE9SX1NPVVJDRSAhPT0gU3RyaW5nKFByb21pc2VDb25zdHJ1Y3Rvcik7CiAgICAgICAgaWYgKCFHTE9CQUxfQ09SRV9KU19QUk9NSVNFICYmIFY4X1ZFUlNJT04gPT09IDY2KQogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgaWYgKElTX1BVUkUgJiYgIVByb21pc2VDb25zdHJ1Y3RvclByb3RvdHlwZVsiZmluYWxseSJdKQogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgaWYgKFY4X1ZFUlNJT04gPj0gNTEgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KFBST01JU0VfQ09OU1RSVUNUT1JfU09VUkNFKSkKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlQ29uc3RydWN0b3IoZnVuY3Rpb24ocmVzb2x2ZSkgewogICAgICAgICAgcmVzb2x2ZSgxKTsKICAgICAgICB9KTsKICAgICAgICB2YXIgRmFrZVByb21pc2UgPSBmdW5jdGlvbihleGVjKSB7CiAgICAgICAgICBleGVjKGZ1bmN0aW9uKCkgewogICAgICAgICAgfSwgZnVuY3Rpb24oKSB7CiAgICAgICAgICB9KTsKICAgICAgICB9OwogICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IHByb21pc2UuY29uc3RydWN0b3IgPSB7fTsKICAgICAgICBjb25zdHJ1Y3RvcltTUEVDSUVTXSA9IEZha2VQcm9taXNlOwogICAgICAgIFNVQkNMQVNTSU5HID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkgewogICAgICAgIH0pIGluc3RhbmNlb2YgRmFrZVByb21pc2U7CiAgICAgICAgaWYgKCFTVUJDTEFTU0lORykKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIHJldHVybiAhR0xPQkFMX0NPUkVfSlNfUFJPTUlTRSAmJiBJU19CUk9XU0VSICYmICFOQVRJVkVfUkVKRUNUSU9OX0VWRU5UOwogICAgICB9KTsKICAgICAgdmFyIElOQ09SUkVDVF9JVEVSQVRJT04gPSBGT1JDRUQgfHwgIWNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbihpdGVyYWJsZSkgewogICAgICAgIFByb21pc2VDb25zdHJ1Y3Rvci5hbGwoaXRlcmFibGUpWyJjYXRjaCJdKGZ1bmN0aW9uKCkgewogICAgICAgIH0pOwogICAgICB9KTsKICAgICAgdmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbihpdCkgewogICAgICAgIHZhciB0aGVuOwogICAgICAgIHJldHVybiBpc09iamVjdChpdCkgJiYgaXNDYWxsYWJsZSh0aGVuID0gaXQudGhlbikgPyB0aGVuIDogZmFsc2U7CiAgICAgIH07CiAgICAgIHZhciBub3RpZnkgPSBmdW5jdGlvbihzdGF0ZSwgaXNSZWplY3QpIHsKICAgICAgICBpZiAoc3RhdGUubm90aWZpZWQpCiAgICAgICAgICByZXR1cm47CiAgICAgICAgc3RhdGUubm90aWZpZWQgPSB0cnVlOwogICAgICAgIHZhciBjaGFpbiA9IHN0YXRlLnJlYWN0aW9uczsKICAgICAgICBtaWNyb3Rhc2soZnVuY3Rpb24oKSB7CiAgICAgICAgICB2YXIgdmFsdWUgPSBzdGF0ZS52YWx1ZTsKICAgICAgICAgIHZhciBvayA9IHN0YXRlLnN0YXRlID09IEZVTEZJTExFRDsKICAgICAgICAgIHZhciBpbmRleCA9IDA7CiAgICAgICAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaW5kZXgpIHsKICAgICAgICAgICAgdmFyIHJlYWN0aW9uID0gY2hhaW5baW5kZXgrK107CiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWw7CiAgICAgICAgICAgIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTsKICAgICAgICAgICAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDsKICAgICAgICAgICAgdmFyIGRvbWFpbiA9IHJlYWN0aW9uLmRvbWFpbjsKICAgICAgICAgICAgdmFyIHJlc3VsdCwgdGhlbiwgZXhpdGVkOwogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7CiAgICAgICAgICAgICAgICBpZiAoIW9rKSB7CiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5yZWplY3Rpb24gPT09IFVOSEFORExFRCkKICAgICAgICAgICAgICAgICAgICBvbkhhbmRsZVVuaGFuZGxlZChzdGF0ZSk7CiAgICAgICAgICAgICAgICAgIHN0YXRlLnJlamVjdGlvbiA9IEhBTkRMRUQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gdHJ1ZSkKICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7CiAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbikKICAgICAgICAgICAgICAgICAgICBkb21haW4uZW50ZXIoKTsKICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7CiAgICAgICAgICAgICAgICAgIGlmIChkb21haW4pIHsKICAgICAgICAgICAgICAgICAgICBkb21haW4uZXhpdCgpOwogICAgICAgICAgICAgICAgICAgIGV4aXRlZCA9IHRydWU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHsKICAgICAgICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcjIoIlByb21pc2UtY2hhaW4gY3ljbGUiKSk7CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHsKICAgICAgICAgICAgICAgICAgdGhlbi5jYWxsKHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTsKICAgICAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7CiAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICByZWplY3QodmFsdWUpOwogICAgICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgICAgIGlmIChkb21haW4gJiYgIWV4aXRlZCkKICAgICAgICAgICAgICAgIGRvbWFpbi5leGl0KCk7CiAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgc3RhdGUucmVhY3Rpb25zID0gW107CiAgICAgICAgICBzdGF0ZS5ub3RpZmllZCA9IGZhbHNlOwogICAgICAgICAgaWYgKGlzUmVqZWN0ICYmICFzdGF0ZS5yZWplY3Rpb24pCiAgICAgICAgICAgIG9uVW5oYW5kbGVkKHN0YXRlKTsKICAgICAgICB9KTsKICAgICAgfTsKICAgICAgdmFyIGRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihuYW1lLCBwcm9taXNlLCByZWFzb24pIHsKICAgICAgICB2YXIgZXZlbnQsIGhhbmRsZXI7CiAgICAgICAgaWYgKERJU1BBVENIX0VWRU5UKSB7CiAgICAgICAgICBldmVudCA9IGRvY3VtZW50Mi5jcmVhdGVFdmVudCgiRXZlbnQiKTsKICAgICAgICAgIGV2ZW50LnByb21pc2UgPSBwcm9taXNlOwogICAgICAgICAgZXZlbnQucmVhc29uID0gcmVhc29uOwogICAgICAgICAgZXZlbnQuaW5pdEV2ZW50KG5hbWUsIGZhbHNlLCB0cnVlKTsKICAgICAgICAgIGdsb2JhbDIuZGlzcGF0Y2hFdmVudChldmVudCk7CiAgICAgICAgfSBlbHNlCiAgICAgICAgICBldmVudCA9IHsgcHJvbWlzZSwgcmVhc29uIH07CiAgICAgICAgaWYgKCFOQVRJVkVfUkVKRUNUSU9OX0VWRU5UICYmIChoYW5kbGVyID0gZ2xvYmFsMlsib24iICsgbmFtZV0pKQogICAgICAgICAgaGFuZGxlcihldmVudCk7CiAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gVU5IQU5ETEVEX1JFSkVDVElPTikKICAgICAgICAgIGhvc3RSZXBvcnRFcnJvcnMoIlVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbiIsIHJlYXNvbik7CiAgICAgIH07CiAgICAgIHZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uKHN0YXRlKSB7CiAgICAgICAgdGFzay5jYWxsKGdsb2JhbDIsIGZ1bmN0aW9uKCkgewogICAgICAgICAgdmFyIHByb21pc2UgPSBzdGF0ZS5mYWNhZGU7CiAgICAgICAgICB2YXIgdmFsdWUgPSBzdGF0ZS52YWx1ZTsKICAgICAgICAgIHZhciBJU19VTkhBTkRMRUQgPSBpc1VuaGFuZGxlZChzdGF0ZSk7CiAgICAgICAgICB2YXIgcmVzdWx0OwogICAgICAgICAgaWYgKElTX1VOSEFORExFRCkgewogICAgICAgICAgICByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgIGlmIChJU19OT0RFKSB7CiAgICAgICAgICAgICAgICBwcm9jZXNzMi5lbWl0KCJ1bmhhbmRsZWRSZWplY3Rpb24iLCB2YWx1ZSwgcHJvbWlzZSk7CiAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICBkaXNwYXRjaEV2ZW50KFVOSEFORExFRF9SRUpFQ1RJT04sIHByb21pc2UsIHZhbHVlKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIHN0YXRlLnJlamVjdGlvbiA9IElTX05PREUgfHwgaXNVbmhhbmRsZWQoc3RhdGUpID8gVU5IQU5ETEVEIDogSEFORExFRDsKICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikKICAgICAgICAgICAgICB0aHJvdyByZXN1bHQudmFsdWU7CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgIH07CiAgICAgIHZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uKHN0YXRlKSB7CiAgICAgICAgcmV0dXJuIHN0YXRlLnJlamVjdGlvbiAhPT0gSEFORExFRCAmJiAhc3RhdGUucGFyZW50OwogICAgICB9OwogICAgICB2YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbihzdGF0ZSkgewogICAgICAgIHRhc2suY2FsbChnbG9iYWwyLCBmdW5jdGlvbigpIHsKICAgICAgICAgIHZhciBwcm9taXNlID0gc3RhdGUuZmFjYWRlOwogICAgICAgICAgaWYgKElTX05PREUpIHsKICAgICAgICAgICAgcHJvY2VzczIuZW1pdCgicmVqZWN0aW9uSGFuZGxlZCIsIHByb21pc2UpOwogICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgIGRpc3BhdGNoRXZlbnQoUkVKRUNUSU9OX0hBTkRMRUQsIHByb21pc2UsIHN0YXRlLnZhbHVlKTsKICAgICAgICB9KTsKICAgICAgfTsKICAgICAgdmFyIGJpbmQgPSBmdW5jdGlvbihmbiwgc3RhdGUsIHVud3JhcCkgewogICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkgewogICAgICAgICAgZm4oc3RhdGUsIHZhbHVlLCB1bndyYXApOwogICAgICAgIH07CiAgICAgIH07CiAgICAgIHZhciBpbnRlcm5hbFJlamVjdCA9IGZ1bmN0aW9uKHN0YXRlLCB2YWx1ZSwgdW53cmFwKSB7CiAgICAgICAgaWYgKHN0YXRlLmRvbmUpCiAgICAgICAgICByZXR1cm47CiAgICAgICAgc3RhdGUuZG9uZSA9IHRydWU7CiAgICAgICAgaWYgKHVud3JhcCkKICAgICAgICAgIHN0YXRlID0gdW53cmFwOwogICAgICAgIHN0YXRlLnZhbHVlID0gdmFsdWU7CiAgICAgICAgc3RhdGUuc3RhdGUgPSBSRUpFQ1RFRDsKICAgICAgICBub3RpZnkoc3RhdGUsIHRydWUpOwogICAgICB9OwogICAgICB2YXIgaW50ZXJuYWxSZXNvbHZlID0gZnVuY3Rpb24oc3RhdGUsIHZhbHVlLCB1bndyYXApIHsKICAgICAgICBpZiAoc3RhdGUuZG9uZSkKICAgICAgICAgIHJldHVybjsKICAgICAgICBzdGF0ZS5kb25lID0gdHJ1ZTsKICAgICAgICBpZiAodW53cmFwKQogICAgICAgICAgc3RhdGUgPSB1bndyYXA7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmIChzdGF0ZS5mYWNhZGUgPT09IHZhbHVlKQogICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IyKCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZiIpOwogICAgICAgICAgdmFyIHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKTsKICAgICAgICAgIGlmICh0aGVuKSB7CiAgICAgICAgICAgIG1pY3JvdGFzayhmdW5jdGlvbigpIHsKICAgICAgICAgICAgICB2YXIgd3JhcHBlciA9IHsgZG9uZTogZmFsc2UgfTsKICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBiaW5kKGludGVybmFsUmVzb2x2ZSwgd3JhcHBlciwgc3RhdGUpLCBiaW5kKGludGVybmFsUmVqZWN0LCB3cmFwcGVyLCBzdGF0ZSkpOwogICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgICAgICAgICBpbnRlcm5hbFJlamVjdCh3cmFwcGVyLCBlcnJvciwgc3RhdGUpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzdGF0ZS52YWx1ZSA9IHZhbHVlOwogICAgICAgICAgICBzdGF0ZS5zdGF0ZSA9IEZVTEZJTExFRDsKICAgICAgICAgICAgbm90aWZ5KHN0YXRlLCBmYWxzZSk7CiAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgIGludGVybmFsUmVqZWN0KHsgZG9uZTogZmFsc2UgfSwgZXJyb3IsIHN0YXRlKTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIGlmIChGT1JDRUQpIHsKICAgICAgICBQcm9taXNlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBQcm9taXNlMihleGVjdXRvcikgewogICAgICAgICAgYW5JbnN0YW5jZSh0aGlzLCBQcm9taXNlQ29uc3RydWN0b3IsIFBST01JU0UpOwogICAgICAgICAgYUNhbGxhYmxlKGV4ZWN1dG9yKTsKICAgICAgICAgIEludGVybmFsLmNhbGwodGhpcyk7CiAgICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpOwogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgZXhlY3V0b3IoYmluZChpbnRlcm5hbFJlc29sdmUsIHN0YXRlKSwgYmluZChpbnRlcm5hbFJlamVjdCwgc3RhdGUpKTsKICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgICAgIGludGVybmFsUmVqZWN0KHN0YXRlLCBlcnJvcik7CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgICBQcm9taXNlQ29uc3RydWN0b3JQcm90b3R5cGUgPSBQcm9taXNlQ29uc3RydWN0b3IucHJvdG90eXBlOwogICAgICAgIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZTIoZXhlY3V0b3IpIHsKICAgICAgICAgIHNldEludGVybmFsU3RhdGUodGhpcywgewogICAgICAgICAgICB0eXBlOiBQUk9NSVNFLAogICAgICAgICAgICBkb25lOiBmYWxzZSwKICAgICAgICAgICAgbm90aWZpZWQ6IGZhbHNlLAogICAgICAgICAgICBwYXJlbnQ6IGZhbHNlLAogICAgICAgICAgICByZWFjdGlvbnM6IFtdLAogICAgICAgICAgICByZWplY3Rpb246IGZhbHNlLAogICAgICAgICAgICBzdGF0ZTogUEVORElORywKICAgICAgICAgICAgdmFsdWU6IHZvaWQgMAogICAgICAgICAgfSk7CiAgICAgICAgfTsKICAgICAgICBJbnRlcm5hbC5wcm90b3R5cGUgPSByZWRlZmluZUFsbChQcm9taXNlQ29uc3RydWN0b3JQcm90b3R5cGUsIHsKICAgICAgICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHsKICAgICAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQcm9taXNlU3RhdGUodGhpcyk7CiAgICAgICAgICAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBQcm9taXNlQ29uc3RydWN0b3IpKTsKICAgICAgICAgICAgcmVhY3Rpb24ub2sgPSBpc0NhbGxhYmxlKG9uRnVsZmlsbGVkKSA/IG9uRnVsZmlsbGVkIDogdHJ1ZTsKICAgICAgICAgICAgcmVhY3Rpb24uZmFpbCA9IGlzQ2FsbGFibGUob25SZWplY3RlZCkgJiYgb25SZWplY3RlZDsKICAgICAgICAgICAgcmVhY3Rpb24uZG9tYWluID0gSVNfTk9ERSA/IHByb2Nlc3MyLmRvbWFpbiA6IHZvaWQgMDsKICAgICAgICAgICAgc3RhdGUucGFyZW50ID0gdHJ1ZTsKICAgICAgICAgICAgc3RhdGUucmVhY3Rpb25zLnB1c2gocmVhY3Rpb24pOwogICAgICAgICAgICBpZiAoc3RhdGUuc3RhdGUgIT0gUEVORElORykKICAgICAgICAgICAgICBub3RpZnkoc3RhdGUsIGZhbHNlKTsKICAgICAgICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7CiAgICAgICAgICB9LAogICAgICAgICAgImNhdGNoIjogZnVuY3Rpb24ob25SZWplY3RlZCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKHZvaWQgMCwgb25SZWplY3RlZCk7CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgICAgT3duUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbigpIHsKICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IEludGVybmFsKCk7CiAgICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHByb21pc2UpOwogICAgICAgICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTsKICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IGJpbmQoaW50ZXJuYWxSZXNvbHZlLCBzdGF0ZSk7CiAgICAgICAgICB0aGlzLnJlamVjdCA9IGJpbmQoaW50ZXJuYWxSZWplY3QsIHN0YXRlKTsKICAgICAgICB9OwogICAgICAgIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKEMpIHsKICAgICAgICAgIHJldHVybiBDID09PSBQcm9taXNlQ29uc3RydWN0b3IgfHwgQyA9PT0gUHJvbWlzZVdyYXBwZXIgPyBuZXcgT3duUHJvbWlzZUNhcGFiaWxpdHkoQykgOiBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7CiAgICAgICAgfTsKICAgICAgICBpZiAoIUlTX1BVUkUgJiYgaXNDYWxsYWJsZShOYXRpdmVQcm9taXNlKSAmJiBOYXRpdmVQcm9taXNlUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKSB7CiAgICAgICAgICBuYXRpdmVUaGVuID0gTmF0aXZlUHJvbWlzZVByb3RvdHlwZS50aGVuOwogICAgICAgICAgaWYgKCFTVUJDTEFTU0lORykgewogICAgICAgICAgICByZWRlZmluZShOYXRpdmVQcm9taXNlUHJvdG90eXBlLCAidGhlbiIsIGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHsKICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7CiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlQ29uc3RydWN0b3IoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7CiAgICAgICAgICAgICAgICBuYXRpdmVUaGVuLmNhbGwodGhhdCwgcmVzb2x2ZSwgcmVqZWN0KTsKICAgICAgICAgICAgICB9KS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTsKICAgICAgICAgICAgfSwgeyB1bnNhZmU6IHRydWUgfSk7CiAgICAgICAgICAgIHJlZGVmaW5lKE5hdGl2ZVByb21pc2VQcm90b3R5cGUsICJjYXRjaCIsIFByb21pc2VDb25zdHJ1Y3RvclByb3RvdHlwZVsiY2F0Y2giXSwgeyB1bnNhZmU6IHRydWUgfSk7CiAgICAgICAgICB9CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBkZWxldGUgTmF0aXZlUHJvbWlzZVByb3RvdHlwZS5jb25zdHJ1Y3RvcjsKICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHsKICAgICAgICAgICAgc2V0UHJvdG90eXBlT2YoTmF0aXZlUHJvbWlzZVByb3RvdHlwZSwgUHJvbWlzZUNvbnN0cnVjdG9yUHJvdG90eXBlKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgJCh7IGdsb2JhbDogdHJ1ZSwgd3JhcDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwgewogICAgICAgIFByb21pc2U6IFByb21pc2VDb25zdHJ1Y3RvcgogICAgICB9KTsKICAgICAgc2V0VG9TdHJpbmdUYWcoUHJvbWlzZUNvbnN0cnVjdG9yLCBQUk9NSVNFLCBmYWxzZSwgdHJ1ZSk7CiAgICAgIHNldFNwZWNpZXMoUFJPTUlTRSk7CiAgICAgIFByb21pc2VXcmFwcGVyID0gZ2V0QnVpbHRJbihQUk9NSVNFKTsKICAgICAgJCh7IHRhcmdldDogUFJPTUlTRSwgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwgewogICAgICAgIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHsKICAgICAgICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcyk7CiAgICAgICAgICBjYXBhYmlsaXR5LnJlamVjdC5jYWxsKHZvaWQgMCwgcik7CiAgICAgICAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgICQoeyB0YXJnZXQ6IFBST01JU0UsIHN0YXQ6IHRydWUsIGZvcmNlZDogSVNfUFVSRSB8fCBGT1JDRUQgfSwgewogICAgICAgIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkgewogICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKElTX1BVUkUgJiYgdGhpcyA9PT0gUHJvbWlzZVdyYXBwZXIgPyBQcm9taXNlQ29uc3RydWN0b3IgOiB0aGlzLCB4KTsKICAgICAgICB9CiAgICAgIH0pOwogICAgICAkKHsgdGFyZ2V0OiBQUk9NSVNFLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IElOQ09SUkVDVF9JVEVSQVRJT04gfSwgewogICAgICAgIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7CiAgICAgICAgICB2YXIgQyA9IHRoaXM7CiAgICAgICAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpOwogICAgICAgICAgdmFyIHJlc29sdmUgPSBjYXBhYmlsaXR5LnJlc29sdmU7CiAgICAgICAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7CiAgICAgICAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbigpIHsKICAgICAgICAgICAgdmFyICRwcm9taXNlUmVzb2x2ZSA9IGFDYWxsYWJsZShDLnJlc29sdmUpOwogICAgICAgICAgICB2YXIgdmFsdWVzID0gW107CiAgICAgICAgICAgIHZhciBjb3VudGVyID0gMDsKICAgICAgICAgICAgdmFyIHJlbWFpbmluZyA9IDE7CiAgICAgICAgICAgIGl0ZXJhdGUoaXRlcmFibGUsIGZ1bmN0aW9uKHByb21pc2UpIHsKICAgICAgICAgICAgICB2YXIgaW5kZXggPSBjb3VudGVyKys7CiAgICAgICAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTsKICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh2b2lkIDApOwogICAgICAgICAgICAgIHJlbWFpbmluZysrOwogICAgICAgICAgICAgICRwcm9taXNlUmVzb2x2ZS5jYWxsKEMsIHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHsKICAgICAgICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKQogICAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTsKICAgICAgICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTsKICAgICAgICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTsKICAgICAgICAgICAgICB9LCByZWplY3QpOwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpOwogICAgICAgICAgfSk7CiAgICAgICAgICBpZiAocmVzdWx0LmVycm9yKQogICAgICAgICAgICByZWplY3QocmVzdWx0LnZhbHVlKTsKICAgICAgICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7CiAgICAgICAgfSwKICAgICAgICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7CiAgICAgICAgICB2YXIgQyA9IHRoaXM7CiAgICAgICAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpOwogICAgICAgICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0OwogICAgICAgICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciAkcHJvbWlzZVJlc29sdmUgPSBhQ2FsbGFibGUoQy5yZXNvbHZlKTsKICAgICAgICAgICAgaXRlcmF0ZShpdGVyYWJsZSwgZnVuY3Rpb24ocHJvbWlzZSkgewogICAgICAgICAgICAgICRwcm9taXNlUmVzb2x2ZS5jYWxsKEMsIHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpOwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0pOwogICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikKICAgICAgICAgICAgcmVqZWN0KHJlc3VsdC52YWx1ZSk7CiAgICAgICAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlOwogICAgICAgIH0KICAgICAgfSk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5wcm9taXNlLmFsbC1zZXR0bGVkLmpzCiAgdmFyIHJlcXVpcmVfZXNfcHJvbWlzZV9hbGxfc2V0dGxlZCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5wcm9taXNlLmFsbC1zZXR0bGVkLmpzIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciAkID0gcmVxdWlyZV9leHBvcnQoKTsKICAgICAgdmFyIGFDYWxsYWJsZSA9IHJlcXVpcmVfYV9jYWxsYWJsZSgpOwogICAgICB2YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUgPSByZXF1aXJlX25ld19wcm9taXNlX2NhcGFiaWxpdHkoKTsKICAgICAgdmFyIHBlcmZvcm0gPSByZXF1aXJlX3BlcmZvcm0oKTsKICAgICAgdmFyIGl0ZXJhdGUgPSByZXF1aXJlX2l0ZXJhdGUoKTsKICAgICAgJCh7IHRhcmdldDogIlByb21pc2UiLCBzdGF0OiB0cnVlIH0sIHsKICAgICAgICBhbGxTZXR0bGVkOiBmdW5jdGlvbiBhbGxTZXR0bGVkKGl0ZXJhYmxlKSB7CiAgICAgICAgICB2YXIgQyA9IHRoaXM7CiAgICAgICAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYoQyk7CiAgICAgICAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTsKICAgICAgICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDsKICAgICAgICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgcHJvbWlzZVJlc29sdmUgPSBhQ2FsbGFibGUoQy5yZXNvbHZlKTsKICAgICAgICAgICAgdmFyIHZhbHVlcyA9IFtdOwogICAgICAgICAgICB2YXIgY291bnRlciA9IDA7CiAgICAgICAgICAgIHZhciByZW1haW5pbmcgPSAxOwogICAgICAgICAgICBpdGVyYXRlKGl0ZXJhYmxlLCBmdW5jdGlvbihwcm9taXNlKSB7CiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gY291bnRlcisrOwogICAgICAgICAgICAgIHZhciBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7CiAgICAgICAgICAgICAgdmFsdWVzLnB1c2godm9pZCAwKTsKICAgICAgICAgICAgICByZW1haW5pbmcrKzsKICAgICAgICAgICAgICBwcm9taXNlUmVzb2x2ZS5jYWxsKEMsIHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHsKICAgICAgICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKQogICAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTsKICAgICAgICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSB7IHN0YXR1czogImZ1bGZpbGxlZCIsIHZhbHVlIH07CiAgICAgICAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7CiAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHsKICAgICAgICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKQogICAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTsKICAgICAgICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSB7IHN0YXR1czogInJlamVjdGVkIiwgcmVhc29uOiBlcnJvciB9OwogICAgICAgICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpOwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpOwogICAgICAgICAgfSk7CiAgICAgICAgICBpZiAocmVzdWx0LmVycm9yKQogICAgICAgICAgICByZWplY3QocmVzdWx0LnZhbHVlKTsKICAgICAgICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7CiAgICAgICAgfQogICAgICB9KTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnByb21pc2UuYW55LmpzCiAgdmFyIHJlcXVpcmVfZXNfcHJvbWlzZV9hbnkgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMucHJvbWlzZS5hbnkuanMiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyICQgPSByZXF1aXJlX2V4cG9ydCgpOwogICAgICB2YXIgYUNhbGxhYmxlID0gcmVxdWlyZV9hX2NhbGxhYmxlKCk7CiAgICAgIHZhciBnZXRCdWlsdEluID0gcmVxdWlyZV9nZXRfYnVpbHRfaW4oKTsKICAgICAgdmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gcmVxdWlyZV9uZXdfcHJvbWlzZV9jYXBhYmlsaXR5KCk7CiAgICAgIHZhciBwZXJmb3JtID0gcmVxdWlyZV9wZXJmb3JtKCk7CiAgICAgIHZhciBpdGVyYXRlID0gcmVxdWlyZV9pdGVyYXRlKCk7CiAgICAgIHZhciBQUk9NSVNFX0FOWV9FUlJPUiA9ICJObyBvbmUgcHJvbWlzZSByZXNvbHZlZCI7CiAgICAgICQoeyB0YXJnZXQ6ICJQcm9taXNlIiwgc3RhdDogdHJ1ZSB9LCB7CiAgICAgICAgYW55OiBmdW5jdGlvbiBhbnkoaXRlcmFibGUpIHsKICAgICAgICAgIHZhciBDID0gdGhpczsKICAgICAgICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZihDKTsKICAgICAgICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlOwogICAgICAgICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0OwogICAgICAgICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciBwcm9taXNlUmVzb2x2ZSA9IGFDYWxsYWJsZShDLnJlc29sdmUpOwogICAgICAgICAgICB2YXIgZXJyb3JzID0gW107CiAgICAgICAgICAgIHZhciBjb3VudGVyID0gMDsKICAgICAgICAgICAgdmFyIHJlbWFpbmluZyA9IDE7CiAgICAgICAgICAgIHZhciBhbHJlYWR5UmVzb2x2ZWQgPSBmYWxzZTsKICAgICAgICAgICAgaXRlcmF0ZShpdGVyYWJsZSwgZnVuY3Rpb24ocHJvbWlzZSkgewogICAgICAgICAgICAgIHZhciBpbmRleCA9IGNvdW50ZXIrKzsKICAgICAgICAgICAgICB2YXIgYWxyZWFkeVJlamVjdGVkID0gZmFsc2U7CiAgICAgICAgICAgICAgZXJyb3JzLnB1c2godm9pZCAwKTsKICAgICAgICAgICAgICByZW1haW5pbmcrKzsKICAgICAgICAgICAgICBwcm9taXNlUmVzb2x2ZS5jYWxsKEMsIHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHsKICAgICAgICAgICAgICAgIGlmIChhbHJlYWR5UmVqZWN0ZWQgfHwgYWxyZWFkeVJlc29sdmVkKQogICAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgICAgICBhbHJlYWR5UmVzb2x2ZWQgPSB0cnVlOwogICAgICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7CiAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHsKICAgICAgICAgICAgICAgIGlmIChhbHJlYWR5UmVqZWN0ZWQgfHwgYWxyZWFkeVJlc29sdmVkKQogICAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgICAgICBhbHJlYWR5UmVqZWN0ZWQgPSB0cnVlOwogICAgICAgICAgICAgICAgZXJyb3JzW2luZGV4XSA9IGVycm9yOwogICAgICAgICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVqZWN0KG5ldyAoZ2V0QnVpbHRJbigiQWdncmVnYXRlRXJyb3IiKSkoZXJyb3JzLCBQUk9NSVNFX0FOWV9FUlJPUikpOwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVqZWN0KG5ldyAoZ2V0QnVpbHRJbigiQWdncmVnYXRlRXJyb3IiKSkoZXJyb3JzLCBQUk9NSVNFX0FOWV9FUlJPUikpOwogICAgICAgICAgfSk7CiAgICAgICAgICBpZiAocmVzdWx0LmVycm9yKQogICAgICAgICAgICByZWplY3QocmVzdWx0LnZhbHVlKTsKICAgICAgICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7CiAgICAgICAgfQogICAgICB9KTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnByb21pc2UuZmluYWxseS5qcwogIHZhciByZXF1aXJlX2VzX3Byb21pc2VfZmluYWxseSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5wcm9taXNlLmZpbmFsbHkuanMiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyICQgPSByZXF1aXJlX2V4cG9ydCgpOwogICAgICB2YXIgSVNfUFVSRSA9IHJlcXVpcmVfaXNfcHVyZSgpOwogICAgICB2YXIgTmF0aXZlUHJvbWlzZSA9IHJlcXVpcmVfbmF0aXZlX3Byb21pc2VfY29uc3RydWN0b3IoKTsKICAgICAgdmFyIGZhaWxzID0gcmVxdWlyZV9mYWlscygpOwogICAgICB2YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmVfZ2V0X2J1aWx0X2luKCk7CiAgICAgIHZhciBpc0NhbGxhYmxlID0gcmVxdWlyZV9pc19jYWxsYWJsZSgpOwogICAgICB2YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZV9zcGVjaWVzX2NvbnN0cnVjdG9yKCk7CiAgICAgIHZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmVfcHJvbWlzZV9yZXNvbHZlKCk7CiAgICAgIHZhciByZWRlZmluZSA9IHJlcXVpcmVfcmVkZWZpbmUoKTsKICAgICAgdmFyIE5PTl9HRU5FUklDID0gISFOYXRpdmVQcm9taXNlICYmIGZhaWxzKGZ1bmN0aW9uKCkgewogICAgICAgIE5hdGl2ZVByb21pc2UucHJvdG90eXBlWyJmaW5hbGx5Il0uY2FsbCh7IHRoZW46IGZ1bmN0aW9uKCkgewogICAgICAgIH0gfSwgZnVuY3Rpb24oKSB7CiAgICAgICAgfSk7CiAgICAgIH0pOwogICAgICAkKHsgdGFyZ2V0OiAiUHJvbWlzZSIsIHByb3RvOiB0cnVlLCByZWFsOiB0cnVlLCBmb3JjZWQ6IE5PTl9HRU5FUklDIH0sIHsKICAgICAgICAiZmluYWxseSI6IGZ1bmN0aW9uKG9uRmluYWxseSkgewogICAgICAgICAgdmFyIEMgPSBzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgZ2V0QnVpbHRJbigiUHJvbWlzZSIpKTsKICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gaXNDYWxsYWJsZShvbkZpbmFsbHkpOwogICAgICAgICAgcmV0dXJuIHRoaXMudGhlbihpc0Z1bmN0aW9uID8gZnVuY3Rpb24oeCkgewogICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoQywgb25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHg7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSA6IG9uRmluYWxseSwgaXNGdW5jdGlvbiA/IGZ1bmN0aW9uKGUpIHsKICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgIHRocm93IGU7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSA6IG9uRmluYWxseSk7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgaWYgKCFJU19QVVJFICYmIGlzQ2FsbGFibGUoTmF0aXZlUHJvbWlzZSkpIHsKICAgICAgICBtZXRob2QgPSBnZXRCdWlsdEluKCJQcm9taXNlIikucHJvdG90eXBlWyJmaW5hbGx5Il07CiAgICAgICAgaWYgKE5hdGl2ZVByb21pc2UucHJvdG90eXBlWyJmaW5hbGx5Il0gIT09IG1ldGhvZCkgewogICAgICAgICAgcmVkZWZpbmUoTmF0aXZlUHJvbWlzZS5wcm90b3R5cGUsICJmaW5hbGx5IiwgbWV0aG9kLCB7IHVuc2FmZTogdHJ1ZSB9KTsKICAgICAgICB9CiAgICAgIH0KICAgICAgdmFyIG1ldGhvZDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9wcm9taXNlL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfcHJvbWlzZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvcHJvbWlzZS9pbmRleC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgcmVxdWlyZV9lc19hZ2dyZWdhdGVfZXJyb3IoKTsKICAgICAgcmVxdWlyZV9lc19hcnJheV9pdGVyYXRvcigpOwogICAgICByZXF1aXJlX2VzX29iamVjdF90b19zdHJpbmcoKTsKICAgICAgcmVxdWlyZV9lc19wcm9taXNlKCk7CiAgICAgIHJlcXVpcmVfZXNfcHJvbWlzZV9hbGxfc2V0dGxlZCgpOwogICAgICByZXF1aXJlX2VzX3Byb21pc2VfYW55KCk7CiAgICAgIHJlcXVpcmVfZXNfcHJvbWlzZV9maW5hbGx5KCk7CiAgICAgIHJlcXVpcmVfZXNfc3RyaW5nX2l0ZXJhdG9yKCk7CiAgICAgIHZhciBwYXRoID0gcmVxdWlyZV9wYXRoKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGF0aC5Qcm9taXNlOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9wcm9taXNlL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfcHJvbWlzZTIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9wcm9taXNlL2luZGV4LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgcGFyZW50ID0gcmVxdWlyZV9wcm9taXNlKCk7CiAgICAgIHJlcXVpcmVfd2ViX2RvbV9jb2xsZWN0aW9uc19pdGVyYXRvcigpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcmVudDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzbmV4dC5hZ2dyZWdhdGUtZXJyb3IuanMKICB2YXIgcmVxdWlyZV9lc25leHRfYWdncmVnYXRlX2Vycm9yID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzbmV4dC5hZ2dyZWdhdGUtZXJyb3IuanMiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHJlcXVpcmVfZXNfYWdncmVnYXRlX2Vycm9yKCk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lc25leHQucHJvbWlzZS5hbGwtc2V0dGxlZC5qcwogIHZhciByZXF1aXJlX2VzbmV4dF9wcm9taXNlX2FsbF9zZXR0bGVkID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzbmV4dC5wcm9taXNlLmFsbC1zZXR0bGVkLmpzIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICByZXF1aXJlX2VzX3Byb21pc2VfYWxsX3NldHRsZWQoKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzbmV4dC5wcm9taXNlLnRyeS5qcwogIHZhciByZXF1aXJlX2VzbmV4dF9wcm9taXNlX3RyeSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lc25leHQucHJvbWlzZS50cnkuanMiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyICQgPSByZXF1aXJlX2V4cG9ydCgpOwogICAgICB2YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUgPSByZXF1aXJlX25ld19wcm9taXNlX2NhcGFiaWxpdHkoKTsKICAgICAgdmFyIHBlcmZvcm0gPSByZXF1aXJlX3BlcmZvcm0oKTsKICAgICAgJCh7IHRhcmdldDogIlByb21pc2UiLCBzdGF0OiB0cnVlIH0sIHsKICAgICAgICAidHJ5IjogZnVuY3Rpb24oY2FsbGJhY2tmbikgewogICAgICAgICAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZih0aGlzKTsKICAgICAgICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGNhbGxiYWNrZm4pOwogICAgICAgICAgKHJlc3VsdC5lcnJvciA/IHByb21pc2VDYXBhYmlsaXR5LnJlamVjdCA6IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmUpKHJlc3VsdC52YWx1ZSk7CiAgICAgICAgICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTsKICAgICAgICB9CiAgICAgIH0pOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXNuZXh0LnByb21pc2UuYW55LmpzCiAgdmFyIHJlcXVpcmVfZXNuZXh0X3Byb21pc2VfYW55ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzbmV4dC5wcm9taXNlLmFueS5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgcmVxdWlyZV9lc19wcm9taXNlX2FueSgpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ZlYXR1cmVzL3Byb21pc2UvaW5kZXguanMKICB2YXIgcmVxdWlyZV9wcm9taXNlMyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZmVhdHVyZXMvcHJvbWlzZS9pbmRleC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHBhcmVudCA9IHJlcXVpcmVfcHJvbWlzZTIoKTsKICAgICAgcmVxdWlyZV9lc25leHRfYWdncmVnYXRlX2Vycm9yKCk7CiAgICAgIHJlcXVpcmVfZXNuZXh0X3Byb21pc2VfYWxsX3NldHRsZWQoKTsKICAgICAgcmVxdWlyZV9lc25leHRfcHJvbWlzZV90cnkoKTsKICAgICAgcmVxdWlyZV9lc25leHRfcHJvbWlzZV9hbnkoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMvcHJvbWlzZS5qcwogIHZhciByZXF1aXJlX3Byb21pc2U0ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy9wcm9taXNlLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVfcHJvbWlzZTMoKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzCiAgdmFyIHJlcXVpcmVfYXN5bmNUb0dlbmVyYXRvciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIF9Qcm9taXNlID0gcmVxdWlyZV9wcm9taXNlNCgpOwogICAgICBmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsKICAgICAgICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7CiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgIHJlamVjdChlcnJvcik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGlmIChpbmZvLmRvbmUpIHsKICAgICAgICAgIHJlc29sdmUodmFsdWUpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBfUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgewogICAgICAgIHJldHVybiBmdW5jdGlvbigpIHsKICAgICAgICAgIHZhciBzZWxmMiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7CiAgICAgICAgICByZXR1cm4gbmV3IF9Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkgewogICAgICAgICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZjIsIGFyZ3MpOwogICAgICAgICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkgewogICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgIm5leHQiLCB2YWx1ZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikgewogICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgInRocm93IiwgZXJyKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBfbmV4dCh2b2lkIDApOwogICAgICAgICAgfSk7CiAgICAgICAgfTsKICAgICAgfQogICAgICBtb2R1bGUuZXhwb3J0cyA9IF9hc3luY1RvR2VuZXJhdG9yOwogICAgICBtb2R1bGUuZXhwb3J0c1siZGVmYXVsdCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9pbnN0YW5jZS9zbGljZS5qcwogIHZhciByZXF1aXJlX3NsaWNlNiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL2luc3RhbmNlL3NsaWNlLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVfc2xpY2UzKCk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMKICB2YXIgcmVxdWlyZV9jbGFzc0NhbGxDaGVjayA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsKICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uIik7CiAgICAgICAgfQogICAgICB9CiAgICAgIG1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrOwogICAgICBtb2R1bGUuZXhwb3J0c1siZGVmYXVsdCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzCiAgdmFyIHJlcXVpcmVfY3JlYXRlQ2xhc3MgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgX09iamVjdCRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmVfZGVmaW5lX3Byb3BlcnR5NSgpOwogICAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7CiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsKICAgICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsKICAgICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsKICAgICAgICAgIGlmICgidmFsdWUiIGluIGRlc2NyaXB0b3IpCiAgICAgICAgICAgIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOwogICAgICAgICAgX09iamVjdCRkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgewogICAgICAgIGlmIChwcm90b1Byb3BzKQogICAgICAgICAgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsKICAgICAgICBpZiAoc3RhdGljUHJvcHMpCiAgICAgICAgICBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOwogICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjsKICAgICAgfQogICAgICBtb2R1bGUuZXhwb3J0cyA9IF9jcmVhdGVDbGFzczsKICAgICAgbW9kdWxlLmV4cG9ydHNbImRlZmF1bHQiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLm9iamVjdC5jcmVhdGUuanMKICB2YXIgcmVxdWlyZV9lc19vYmplY3RfY3JlYXRlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLm9iamVjdC5jcmVhdGUuanMiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciAkID0gcmVxdWlyZV9leHBvcnQoKTsKICAgICAgdmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZV9kZXNjcmlwdG9ycygpOwogICAgICB2YXIgY3JlYXRlID0gcmVxdWlyZV9vYmplY3RfY3JlYXRlKCk7CiAgICAgICQoeyB0YXJnZXQ6ICJPYmplY3QiLCBzdGF0OiB0cnVlLCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwgewogICAgICAgIGNyZWF0ZQogICAgICB9KTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9vYmplY3QvY3JlYXRlLmpzCiAgdmFyIHJlcXVpcmVfY3JlYXRlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9vYmplY3QvY3JlYXRlLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICByZXF1aXJlX2VzX29iamVjdF9jcmVhdGUoKTsKICAgICAgdmFyIHBhdGggPSByZXF1aXJlX3BhdGgoKTsKICAgICAgdmFyIE9iamVjdDIgPSBwYXRoLk9iamVjdDsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGUoUCwgRCkgewogICAgICAgIHJldHVybiBPYmplY3QyLmNyZWF0ZShQLCBEKTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvb2JqZWN0L2NyZWF0ZS5qcwogIHZhciByZXF1aXJlX2NyZWF0ZTIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9vYmplY3QvY3JlYXRlLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgcGFyZW50ID0gcmVxdWlyZV9jcmVhdGUoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZmVhdHVyZXMvb2JqZWN0L2NyZWF0ZS5qcwogIHZhciByZXF1aXJlX2NyZWF0ZTMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ZlYXR1cmVzL29iamVjdC9jcmVhdGUuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBwYXJlbnQgPSByZXF1aXJlX2NyZWF0ZTIoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qcwogIHZhciByZXF1aXJlX2NyZWF0ZTQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzL29iamVjdC9jcmVhdGUuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZV9jcmVhdGUzKCk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcwogIHZhciByZXF1aXJlX2VzX29iamVjdF9zZXRfcHJvdG90eXBlX29mID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgJCA9IHJlcXVpcmVfZXhwb3J0KCk7CiAgICAgIHZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmVfb2JqZWN0X3NldF9wcm90b3R5cGVfb2YoKTsKICAgICAgJCh7IHRhcmdldDogIk9iamVjdCIsIHN0YXQ6IHRydWUgfSwgewogICAgICAgIHNldFByb3RvdHlwZU9mCiAgICAgIH0pOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzCiAgdmFyIHJlcXVpcmVfc2V0X3Byb3RvdHlwZV9vZiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHJlcXVpcmVfZXNfb2JqZWN0X3NldF9wcm90b3R5cGVfb2YoKTsKICAgICAgdmFyIHBhdGggPSByZXF1aXJlX3BhdGgoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBwYXRoLk9iamVjdC5zZXRQcm90b3R5cGVPZjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMKICB2YXIgcmVxdWlyZV9zZXRfcHJvdG90eXBlX29mMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgcGFyZW50ID0gcmVxdWlyZV9zZXRfcHJvdG90eXBlX29mKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGFyZW50OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ZlYXR1cmVzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzCiAgdmFyIHJlcXVpcmVfc2V0X3Byb3RvdHlwZV9vZjMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ZlYXR1cmVzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgcGFyZW50ID0gcmVxdWlyZV9zZXRfcHJvdG90eXBlX29mMigpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcmVudDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcwogIHZhciByZXF1aXJlX3NldF9wcm90b3R5cGVfb2Y0ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlX3NldF9wcm90b3R5cGVfb2YzKCk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanMKICB2YXIgcmVxdWlyZV9zZXRQcm90b3R5cGVPZiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBfT2JqZWN0JHNldFByb3RvdHlwZU9mID0gcmVxdWlyZV9zZXRfcHJvdG90eXBlX29mNCgpOwogICAgICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgewogICAgICAgIG1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mID0gX09iamVjdCRzZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YyKG8yLCBwMikgewogICAgICAgICAgbzIuX19wcm90b19fID0gcDI7CiAgICAgICAgICByZXR1cm4gbzI7CiAgICAgICAgfTsKICAgICAgICBtb2R1bGUuZXhwb3J0c1siZGVmYXVsdCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOwogICAgICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7CiAgICAgIH0KICAgICAgbW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2Y7CiAgICAgIG1vZHVsZS5leHBvcnRzWyJkZWZhdWx0Il0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvaW5oZXJpdHMuanMKICB2YXIgcmVxdWlyZV9pbmhlcml0cyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvaW5oZXJpdHMuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBfT2JqZWN0JGNyZWF0ZSA9IHJlcXVpcmVfY3JlYXRlNCgpOwogICAgICB2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlX3NldFByb3RvdHlwZU9mKCk7CiAgICAgIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgewogICAgICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gImZ1bmN0aW9uIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiIpOwogICAgICAgIH0KICAgICAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBfT2JqZWN0JGNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7CiAgICAgICAgICBjb25zdHJ1Y3RvcjogewogICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsCiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLAogICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgICBpZiAoc3VwZXJDbGFzcykKICAgICAgICAgIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsKICAgICAgfQogICAgICBtb2R1bGUuZXhwb3J0cyA9IF9pbmhlcml0czsKICAgICAgbW9kdWxlLmV4cG9ydHNbImRlZmF1bHQiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9zeW1ib2wvaXRlcmF0b3IuanMKICB2YXIgcmVxdWlyZV9pdGVyYXRvciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvc3ltYm9sL2l0ZXJhdG9yLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICByZXF1aXJlX2VzX2FycmF5X2l0ZXJhdG9yKCk7CiAgICAgIHJlcXVpcmVfZXNfb2JqZWN0X3RvX3N0cmluZygpOwogICAgICByZXF1aXJlX2VzX3N0cmluZ19pdGVyYXRvcigpOwogICAgICByZXF1aXJlX2VzX3N5bWJvbF9pdGVyYXRvcigpOwogICAgICB2YXIgV3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSA9IHJlcXVpcmVfd2VsbF9rbm93bl9zeW1ib2xfd3JhcHBlZCgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IFdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUuZigiaXRlcmF0b3IiKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvc3ltYm9sL2l0ZXJhdG9yLmpzCiAgdmFyIHJlcXVpcmVfaXRlcmF0b3IyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvc3ltYm9sL2l0ZXJhdG9yLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgcGFyZW50ID0gcmVxdWlyZV9pdGVyYXRvcigpOwogICAgICByZXF1aXJlX3dlYl9kb21fY29sbGVjdGlvbnNfaXRlcmF0b3IoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZmVhdHVyZXMvc3ltYm9sL2l0ZXJhdG9yLmpzCiAgdmFyIHJlcXVpcmVfaXRlcmF0b3IzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9mZWF0dXJlcy9zeW1ib2wvaXRlcmF0b3IuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBwYXJlbnQgPSByZXF1aXJlX2l0ZXJhdG9yMigpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcmVudDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IuanMKICB2YXIgcmVxdWlyZV9pdGVyYXRvcjQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlX2l0ZXJhdG9yMygpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9oZWxwZXJzL3R5cGVvZi5qcwogIHZhciByZXF1aXJlX3R5cGVvZiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvdHlwZW9mLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgX1N5bWJvbCA9IHJlcXVpcmVfc3ltYm9sNSgpOwogICAgICB2YXIgX1N5bWJvbCRpdGVyYXRvciA9IHJlcXVpcmVfaXRlcmF0b3I0KCk7CiAgICAgIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7CiAgICAgICAgIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mIjsKICAgICAgICBpZiAodHlwZW9mIF9TeW1ib2wgPT09ICJmdW5jdGlvbiIgJiYgdHlwZW9mIF9TeW1ib2wkaXRlcmF0b3IgPT09ICJzeW1ib2wiKSB7CiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mMihvYmoyKSB7CiAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqMjsKICAgICAgICAgIH07CiAgICAgICAgICBtb2R1bGUuZXhwb3J0c1siZGVmYXVsdCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mMihvYmoyKSB7CiAgICAgICAgICAgIHJldHVybiBvYmoyICYmIHR5cGVvZiBfU3ltYm9sID09PSAiZnVuY3Rpb24iICYmIG9iajIuY29uc3RydWN0b3IgPT09IF9TeW1ib2wgJiYgb2JqMiAhPT0gX1N5bWJvbC5wcm90b3R5cGUgPyAic3ltYm9sIiA6IHR5cGVvZiBvYmoyOwogICAgICAgICAgfTsKICAgICAgICAgIG1vZHVsZS5leHBvcnRzWyJkZWZhdWx0Il0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7CiAgICAgICAgfQogICAgICAgIHJldHVybiBfdHlwZW9mKG9iaik7CiAgICAgIH0KICAgICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mOwogICAgICBtb2R1bGUuZXhwb3J0c1siZGVmYXVsdCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qcwogIHZhciByZXF1aXJlX2Fzc2VydFRoaXNJbml0aWFsaXplZCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYyKSB7CiAgICAgICAgaWYgKHNlbGYyID09PSB2b2lkIDApIHsKICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcigidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkIik7CiAgICAgICAgfQogICAgICAgIHJldHVybiBzZWxmMjsKICAgICAgfQogICAgICBtb2R1bGUuZXhwb3J0cyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQ7CiAgICAgIG1vZHVsZS5leHBvcnRzWyJkZWZhdWx0Il0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcwogIHZhciByZXF1aXJlX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBfdHlwZW9mID0gcmVxdWlyZV90eXBlb2YoKVsiZGVmYXVsdCJdOwogICAgICB2YXIgYXNzZXJ0VGhpc0luaXRpYWxpemVkID0gcmVxdWlyZV9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoKTsKICAgICAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZjIsIGNhbGwpIHsKICAgICAgICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gIm9iamVjdCIgfHwgdHlwZW9mIGNhbGwgPT09ICJmdW5jdGlvbiIpKSB7CiAgICAgICAgICByZXR1cm4gY2FsbDsKICAgICAgICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWQiKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmMik7CiAgICAgIH0KICAgICAgbW9kdWxlLmV4cG9ydHMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjsKICAgICAgbW9kdWxlLmV4cG9ydHNbImRlZmF1bHQiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLm9iamVjdC5nZXQtcHJvdG90eXBlLW9mLmpzCiAgdmFyIHJlcXVpcmVfZXNfb2JqZWN0X2dldF9wcm90b3R5cGVfb2YgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciAkID0gcmVxdWlyZV9leHBvcnQoKTsKICAgICAgdmFyIGZhaWxzID0gcmVxdWlyZV9mYWlscygpOwogICAgICB2YXIgdG9PYmplY3QgPSByZXF1aXJlX3RvX29iamVjdCgpOwogICAgICB2YXIgbmF0aXZlR2V0UHJvdG90eXBlT2YgPSByZXF1aXJlX29iamVjdF9nZXRfcHJvdG90eXBlX29mKCk7CiAgICAgIHZhciBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPSByZXF1aXJlX2NvcnJlY3RfcHJvdG90eXBlX2dldHRlcigpOwogICAgICB2YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uKCkgewogICAgICAgIG5hdGl2ZUdldFByb3RvdHlwZU9mKDEpOwogICAgICB9KTsKICAgICAgJCh7IHRhcmdldDogIk9iamVjdCIsIHN0YXQ6IHRydWUsIGZvcmNlZDogRkFJTFNfT05fUFJJTUlUSVZFUywgc2hhbTogIUNPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiB9LCB7CiAgICAgICAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KSB7CiAgICAgICAgICByZXR1cm4gbmF0aXZlR2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTsKICAgICAgICB9CiAgICAgIH0pOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzCiAgdmFyIHJlcXVpcmVfZ2V0X3Byb3RvdHlwZV9vZiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHJlcXVpcmVfZXNfb2JqZWN0X2dldF9wcm90b3R5cGVfb2YoKTsKICAgICAgdmFyIHBhdGggPSByZXF1aXJlX3BhdGgoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBwYXRoLk9iamVjdC5nZXRQcm90b3R5cGVPZjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YuanMKICB2YXIgcmVxdWlyZV9nZXRfcHJvdG90eXBlX29mMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgcGFyZW50ID0gcmVxdWlyZV9nZXRfcHJvdG90eXBlX29mKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGFyZW50OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ZlYXR1cmVzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzCiAgdmFyIHJlcXVpcmVfZ2V0X3Byb3RvdHlwZV9vZjMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ZlYXR1cmVzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgcGFyZW50ID0gcmVxdWlyZV9nZXRfcHJvdG90eXBlX29mMigpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcmVudDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcwogIHZhciByZXF1aXJlX2dldF9wcm90b3R5cGVfb2Y0ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlX2dldF9wcm90b3R5cGVfb2YzKCk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YuanMKICB2YXIgcmVxdWlyZV9nZXRQcm90b3R5cGVPZiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBfT2JqZWN0JHNldFByb3RvdHlwZU9mID0gcmVxdWlyZV9zZXRfcHJvdG90eXBlX29mNCgpOwogICAgICB2YXIgX09iamVjdCRnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmVfZ2V0X3Byb3RvdHlwZV9vZjQoKTsKICAgICAgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsKICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZiA9IF9PYmplY3Qkc2V0UHJvdG90eXBlT2YgPyBfT2JqZWN0JGdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mMihvMikgewogICAgICAgICAgcmV0dXJuIG8yLl9fcHJvdG9fXyB8fCBfT2JqZWN0JGdldFByb3RvdHlwZU9mKG8yKTsKICAgICAgICB9OwogICAgICAgIG1vZHVsZS5leHBvcnRzWyJkZWZhdWx0Il0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7CiAgICAgICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsKICAgICAgfQogICAgICBtb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZjsKICAgICAgbW9kdWxlLmV4cG9ydHNbImRlZmF1bHQiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvbmcvc3JjL2xvbmcuanMKICB2YXIgcmVxdWlyZV9sb25nID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2xvbmcvc3JjL2xvbmcuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gTG9uZzsKICAgICAgdmFyIHdhc20gPSBudWxsOwogICAgICB0cnkgewogICAgICAgIHdhc20gPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheShbCiAgICAgICAgICAwLAogICAgICAgICAgOTcsCiAgICAgICAgICAxMTUsCiAgICAgICAgICAxMDksCiAgICAgICAgICAxLAogICAgICAgICAgMCwKICAgICAgICAgIDAsCiAgICAgICAgICAwLAogICAgICAgICAgMSwKICAgICAgICAgIDEzLAogICAgICAgICAgMiwKICAgICAgICAgIDk2LAogICAgICAgICAgMCwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjcsCiAgICAgICAgICA5NiwKICAgICAgICAgIDQsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxLAogICAgICAgICAgMTI3LAogICAgICAgICAgMywKICAgICAgICAgIDcsCiAgICAgICAgICA2LAogICAgICAgICAgMCwKICAgICAgICAgIDEsCiAgICAgICAgICAxLAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxLAogICAgICAgICAgNiwKICAgICAgICAgIDYsCiAgICAgICAgICAxLAogICAgICAgICAgMTI3LAogICAgICAgICAgMSwKICAgICAgICAgIDY1LAogICAgICAgICAgMCwKICAgICAgICAgIDExLAogICAgICAgICAgNywKICAgICAgICAgIDUwLAogICAgICAgICAgNiwKICAgICAgICAgIDMsCiAgICAgICAgICAxMDksCiAgICAgICAgICAxMTcsCiAgICAgICAgICAxMDgsCiAgICAgICAgICAwLAogICAgICAgICAgMSwKICAgICAgICAgIDUsCiAgICAgICAgICAxMDAsCiAgICAgICAgICAxMDUsCiAgICAgICAgICAxMTgsCiAgICAgICAgICA5NSwKICAgICAgICAgIDExNSwKICAgICAgICAgIDAsCiAgICAgICAgICAyLAogICAgICAgICAgNSwKICAgICAgICAgIDEwMCwKICAgICAgICAgIDEwNSwKICAgICAgICAgIDExOCwKICAgICAgICAgIDk1LAogICAgICAgICAgMTE3LAogICAgICAgICAgMCwKICAgICAgICAgIDMsCiAgICAgICAgICA1LAogICAgICAgICAgMTE0LAogICAgICAgICAgMTAxLAogICAgICAgICAgMTA5LAogICAgICAgICAgOTUsCiAgICAgICAgICAxMTUsCiAgICAgICAgICAwLAogICAgICAgICAgNCwKICAgICAgICAgIDUsCiAgICAgICAgICAxMTQsCiAgICAgICAgICAxMDEsCiAgICAgICAgICAxMDksCiAgICAgICAgICA5NSwKICAgICAgICAgIDExNywKICAgICAgICAgIDAsCiAgICAgICAgICA1LAogICAgICAgICAgOCwKICAgICAgICAgIDEwMywKICAgICAgICAgIDEwMSwKICAgICAgICAgIDExNiwKICAgICAgICAgIDk1LAogICAgICAgICAgMTA0LAogICAgICAgICAgMTA1LAogICAgICAgICAgMTAzLAogICAgICAgICAgMTA0LAogICAgICAgICAgMCwKICAgICAgICAgIDAsCiAgICAgICAgICAxMCwKICAgICAgICAgIDE5MSwKICAgICAgICAgIDEsCiAgICAgICAgICA2LAogICAgICAgICAgNCwKICAgICAgICAgIDAsCiAgICAgICAgICAzNSwKICAgICAgICAgIDAsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyNiwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyNywKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyOCwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyOSwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEzMCwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMQogICAgICAgIF0pKSwge30pLmV4cG9ydHM7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgfQogICAgICBmdW5jdGlvbiBMb25nKGxvdywgaGlnaCwgdW5zaWduZWQpIHsKICAgICAgICB0aGlzLmxvdyA9IGxvdyB8IDA7CiAgICAgICAgdGhpcy5oaWdoID0gaGlnaCB8IDA7CiAgICAgICAgdGhpcy51bnNpZ25lZCA9ICEhdW5zaWduZWQ7CiAgICAgIH0KICAgICAgTG9uZy5wcm90b3R5cGUuX19pc0xvbmdfXzsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvbmcucHJvdG90eXBlLCAiX19pc0xvbmdfXyIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGZ1bmN0aW9uIGlzTG9uZyhvYmopIHsKICAgICAgICByZXR1cm4gKG9iaiAmJiBvYmpbIl9faXNMb25nX18iXSkgPT09IHRydWU7CiAgICAgIH0KICAgICAgTG9uZy5pc0xvbmcgPSBpc0xvbmc7CiAgICAgIHZhciBJTlRfQ0FDSEUgPSB7fTsKICAgICAgdmFyIFVJTlRfQ0FDSEUgPSB7fTsKICAgICAgZnVuY3Rpb24gZnJvbUludCh2YWx1ZSwgdW5zaWduZWQpIHsKICAgICAgICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlOwogICAgICAgIGlmICh1bnNpZ25lZCkgewogICAgICAgICAgdmFsdWUgPj4+PSAwOwogICAgICAgICAgaWYgKGNhY2hlID0gMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1NikgewogICAgICAgICAgICBjYWNoZWRPYmogPSBVSU5UX0NBQ0hFW3ZhbHVlXTsKICAgICAgICAgICAgaWYgKGNhY2hlZE9iaikKICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqOwogICAgICAgICAgfQogICAgICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsICh2YWx1ZSB8IDApIDwgMCA/IC0xIDogMCwgdHJ1ZSk7CiAgICAgICAgICBpZiAoY2FjaGUpCiAgICAgICAgICAgIFVJTlRfQ0FDSEVbdmFsdWVdID0gb2JqOwogICAgICAgICAgcmV0dXJuIG9iajsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdmFsdWUgfD0gMDsKICAgICAgICAgIGlmIChjYWNoZSA9IC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpIHsKICAgICAgICAgICAgY2FjaGVkT2JqID0gSU5UX0NBQ0hFW3ZhbHVlXTsKICAgICAgICAgICAgaWYgKGNhY2hlZE9iaikKICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqOwogICAgICAgICAgfQogICAgICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpOwogICAgICAgICAgaWYgKGNhY2hlKQogICAgICAgICAgICBJTlRfQ0FDSEVbdmFsdWVdID0gb2JqOwogICAgICAgICAgcmV0dXJuIG9iajsKICAgICAgICB9CiAgICAgIH0KICAgICAgTG9uZy5mcm9tSW50ID0gZnJvbUludDsKICAgICAgZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSwgdW5zaWduZWQpIHsKICAgICAgICBpZiAoaXNOYU4odmFsdWUpKQogICAgICAgICAgcmV0dXJuIHVuc2lnbmVkID8gVVpFUk8gOiBaRVJPOwogICAgICAgIGlmICh1bnNpZ25lZCkgewogICAgICAgICAgaWYgKHZhbHVlIDwgMCkKICAgICAgICAgICAgcmV0dXJuIFVaRVJPOwogICAgICAgICAgaWYgKHZhbHVlID49IFRXT19QV1JfNjRfREJMKQogICAgICAgICAgICByZXR1cm4gTUFYX1VOU0lHTkVEX1ZBTFVFOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAodmFsdWUgPD0gLVRXT19QV1JfNjNfREJMKQogICAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFOwogICAgICAgICAgaWYgKHZhbHVlICsgMSA+PSBUV09fUFdSXzYzX0RCTCkKICAgICAgICAgICAgcmV0dXJuIE1BWF9WQUxVRTsKICAgICAgICB9CiAgICAgICAgaWYgKHZhbHVlIDwgMCkKICAgICAgICAgIHJldHVybiBmcm9tTnVtYmVyKC12YWx1ZSwgdW5zaWduZWQpLm5lZygpOwogICAgICAgIHJldHVybiBmcm9tQml0cyh2YWx1ZSAlIFRXT19QV1JfMzJfREJMIHwgMCwgdmFsdWUgLyBUV09fUFdSXzMyX0RCTCB8IDAsIHVuc2lnbmVkKTsKICAgICAgfQogICAgICBMb25nLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyOwogICAgICBmdW5jdGlvbiBmcm9tQml0cyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpIHsKICAgICAgICByZXR1cm4gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTsKICAgICAgfQogICAgICBMb25nLmZyb21CaXRzID0gZnJvbUJpdHM7CiAgICAgIHZhciBwb3dfZGJsID0gTWF0aC5wb3c7CiAgICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyLCB1bnNpZ25lZCwgcmFkaXgpIHsKICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkKICAgICAgICAgIHRocm93IEVycm9yKCJlbXB0eSBzdHJpbmciKTsKICAgICAgICBpZiAoc3RyID09PSAiTmFOIiB8fCBzdHIgPT09ICJJbmZpbml0eSIgfHwgc3RyID09PSAiK0luZmluaXR5IiB8fCBzdHIgPT09ICItSW5maW5pdHkiKQogICAgICAgICAgcmV0dXJuIFpFUk87CiAgICAgICAgaWYgKHR5cGVvZiB1bnNpZ25lZCA9PT0gIm51bWJlciIpIHsKICAgICAgICAgIHJhZGl4ID0gdW5zaWduZWQsIHVuc2lnbmVkID0gZmFsc2U7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHVuc2lnbmVkID0gISF1bnNpZ25lZDsKICAgICAgICB9CiAgICAgICAgcmFkaXggPSByYWRpeCB8fCAxMDsKICAgICAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpCiAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCJyYWRpeCIpOwogICAgICAgIHZhciBwOwogICAgICAgIGlmICgocCA9IHN0ci5pbmRleE9mKCItIikpID4gMCkKICAgICAgICAgIHRocm93IEVycm9yKCJpbnRlcmlvciBoeXBoZW4iKTsKICAgICAgICBlbHNlIGlmIChwID09PSAwKSB7CiAgICAgICAgICByZXR1cm4gZnJvbVN0cmluZyhzdHIuc3Vic3RyaW5nKDEpLCB1bnNpZ25lZCwgcmFkaXgpLm5lZygpOwogICAgICAgIH0KICAgICAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA4KSk7CiAgICAgICAgdmFyIHJlc3VsdCA9IFpFUk87CiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDgpIHsKICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oOCwgc3RyLmxlbmd0aCAtIGkpLCB2YWx1ZSA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoaSwgaSArIHNpemUpLCByYWRpeCk7CiAgICAgICAgICBpZiAoc2l6ZSA8IDgpIHsKICAgICAgICAgICAgdmFyIHBvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCBzaXplKSk7CiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocG93ZXIpLmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHJhZGl4VG9Qb3dlcik7CiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZnJvbU51bWJlcih2YWx1ZSkpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXN1bHQudW5zaWduZWQgPSB1bnNpZ25lZDsKICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICB9CiAgICAgIExvbmcuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7CiAgICAgIGZ1bmN0aW9uIGZyb21WYWx1ZSh2YWwsIHVuc2lnbmVkKSB7CiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICJudW1iZXIiKQogICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodmFsLCB1bnNpZ25lZCk7CiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICJzdHJpbmciKQogICAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcodmFsLCB1bnNpZ25lZCk7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHZhbC5sb3csIHZhbC5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICJib29sZWFuIiA/IHVuc2lnbmVkIDogdmFsLnVuc2lnbmVkKTsKICAgICAgfQogICAgICBMb25nLmZyb21WYWx1ZSA9IGZyb21WYWx1ZTsKICAgICAgdmFyIFRXT19QV1JfMTZfREJMID0gMSA8PCAxNjsKICAgICAgdmFyIFRXT19QV1JfMjRfREJMID0gMSA8PCAyNDsKICAgICAgdmFyIFRXT19QV1JfMzJfREJMID0gVFdPX1BXUl8xNl9EQkwgKiBUV09fUFdSXzE2X0RCTDsKICAgICAgdmFyIFRXT19QV1JfNjRfREJMID0gVFdPX1BXUl8zMl9EQkwgKiBUV09fUFdSXzMyX0RCTDsKICAgICAgdmFyIFRXT19QV1JfNjNfREJMID0gVFdPX1BXUl82NF9EQkwgLyAyOwogICAgICB2YXIgVFdPX1BXUl8yNCA9IGZyb21JbnQoVFdPX1BXUl8yNF9EQkwpOwogICAgICB2YXIgWkVSTyA9IGZyb21JbnQoMCk7CiAgICAgIExvbmcuWkVSTyA9IFpFUk87CiAgICAgIHZhciBVWkVSTyA9IGZyb21JbnQoMCwgdHJ1ZSk7CiAgICAgIExvbmcuVVpFUk8gPSBVWkVSTzsKICAgICAgdmFyIE9ORSA9IGZyb21JbnQoMSk7CiAgICAgIExvbmcuT05FID0gT05FOwogICAgICB2YXIgVU9ORSA9IGZyb21JbnQoMSwgdHJ1ZSk7CiAgICAgIExvbmcuVU9ORSA9IFVPTkU7CiAgICAgIHZhciBORUdfT05FID0gZnJvbUludCgtMSk7CiAgICAgIExvbmcuTkVHX09ORSA9IE5FR19PTkU7CiAgICAgIHZhciBNQVhfVkFMVUUgPSBmcm9tQml0cyg0Mjk0OTY3Mjk1IHwgMCwgMjE0NzQ4MzY0NyB8IDAsIGZhbHNlKTsKICAgICAgTG9uZy5NQVhfVkFMVUUgPSBNQVhfVkFMVUU7CiAgICAgIHZhciBNQVhfVU5TSUdORURfVkFMVUUgPSBmcm9tQml0cyg0Mjk0OTY3Mjk1IHwgMCwgNDI5NDk2NzI5NSB8IDAsIHRydWUpOwogICAgICBMb25nLk1BWF9VTlNJR05FRF9WQUxVRSA9IE1BWF9VTlNJR05FRF9WQUxVRTsKICAgICAgdmFyIE1JTl9WQUxVRSA9IGZyb21CaXRzKDAsIDIxNDc0ODM2NDggfCAwLCBmYWxzZSk7CiAgICAgIExvbmcuTUlOX1ZBTFVFID0gTUlOX1ZBTFVFOwogICAgICB2YXIgTG9uZ1Byb3RvdHlwZSA9IExvbmcucHJvdG90eXBlOwogICAgICBMb25nUHJvdG90eXBlLnRvSW50ID0gZnVuY3Rpb24gdG9JbnQoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyB0aGlzLmxvdyA+Pj4gMCA6IHRoaXMubG93OwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIoKSB7CiAgICAgICAgaWYgKHRoaXMudW5zaWduZWQpCiAgICAgICAgICByZXR1cm4gKHRoaXMuaGlnaCA+Pj4gMCkgKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7CiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHJhZGl4KSB7CiAgICAgICAgcmFkaXggPSByYWRpeCB8fCAxMDsKICAgICAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpCiAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCJyYWRpeCIpOwogICAgICAgIGlmICh0aGlzLmlzWmVybygpKQogICAgICAgICAgcmV0dXJuICIwIjsKICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsKICAgICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHsKICAgICAgICAgICAgdmFyIHJhZGl4TG9uZyA9IGZyb21OdW1iZXIocmFkaXgpLCBkaXYgPSB0aGlzLmRpdihyYWRpeExvbmcpLCByZW0xID0gZGl2Lm11bChyYWRpeExvbmcpLnN1Yih0aGlzKTsKICAgICAgICAgICAgcmV0dXJuIGRpdi50b1N0cmluZyhyYWRpeCkgKyByZW0xLnRvSW50KCkudG9TdHJpbmcocmFkaXgpOwogICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgIHJldHVybiAiLSIgKyB0aGlzLm5lZygpLnRvU3RyaW5nKHJhZGl4KTsKICAgICAgICB9CiAgICAgICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgNiksIHRoaXMudW5zaWduZWQpLCByZW0gPSB0aGlzOwogICAgICAgIHZhciByZXN1bHQgPSAiIjsKICAgICAgICB3aGlsZSAodHJ1ZSkgewogICAgICAgICAgdmFyIHJlbURpdiA9IHJlbS5kaXYocmFkaXhUb1Bvd2VyKSwgaW50dmFsID0gcmVtLnN1YihyZW1EaXYubXVsKHJhZGl4VG9Qb3dlcikpLnRvSW50KCkgPj4+IDAsIGRpZ2l0cyA9IGludHZhbC50b1N0cmluZyhyYWRpeCk7CiAgICAgICAgICByZW0gPSByZW1EaXY7CiAgICAgICAgICBpZiAocmVtLmlzWmVybygpKQogICAgICAgICAgICByZXR1cm4gZGlnaXRzICsgcmVzdWx0OwogICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIHdoaWxlIChkaWdpdHMubGVuZ3RoIDwgNikKICAgICAgICAgICAgICBkaWdpdHMgPSAiMCIgKyBkaWdpdHM7CiAgICAgICAgICAgIHJlc3VsdCA9ICIiICsgZGlnaXRzICsgcmVzdWx0OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0cyA9IGZ1bmN0aW9uIGdldEhpZ2hCaXRzKCkgewogICAgICAgIHJldHVybiB0aGlzLmhpZ2g7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldEhpZ2hCaXRzVW5zaWduZWQoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCA+Pj4gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5nZXRMb3dCaXRzID0gZnVuY3Rpb24gZ2V0TG93Qml0cygpIHsKICAgICAgICByZXR1cm4gdGhpcy5sb3c7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuZ2V0TG93Qml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0TG93Qml0c1Vuc2lnbmVkKCkgewogICAgICAgIHJldHVybiB0aGlzLmxvdyA+Pj4gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5nZXROdW1CaXRzQWJzID0gZnVuY3Rpb24gZ2V0TnVtQml0c0FicygpIHsKICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpCiAgICAgICAgICByZXR1cm4gdGhpcy5lcShNSU5fVkFMVUUpID8gNjQgOiB0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTsKICAgICAgICB2YXIgdmFsID0gdGhpcy5oaWdoICE9IDAgPyB0aGlzLmhpZ2ggOiB0aGlzLmxvdzsKICAgICAgICBmb3IgKHZhciBiaXQgPSAzMTsgYml0ID4gMDsgYml0LS0pCiAgICAgICAgICBpZiAoKHZhbCAmIDEgPDwgYml0KSAhPSAwKQogICAgICAgICAgICBicmVhazsKICAgICAgICByZXR1cm4gdGhpcy5oaWdoICE9IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvKCkgewogICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IDAgJiYgdGhpcy5sb3cgPT09IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuZXF6ID0gTG9uZ1Byb3RvdHlwZS5pc1plcm87CiAgICAgIExvbmdQcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uIGlzTmVnYXRpdmUoKSB7CiAgICAgICAgcmV0dXJuICF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA8IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uIGlzUG9zaXRpdmUoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgfHwgdGhpcy5oaWdoID49IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCgpIHsKICAgICAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDE7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuKCkgewogICAgICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHsKICAgICAgICBpZiAoIWlzTG9uZyhvdGhlcikpCiAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7CiAgICAgICAgaWYgKHRoaXMudW5zaWduZWQgIT09IG90aGVyLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA+Pj4gMzEgPT09IDEgJiYgb3RoZXIuaGlnaCA+Pj4gMzEgPT09IDEpCiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gb3RoZXIuaGlnaCAmJiB0aGlzLmxvdyA9PT0gb3RoZXIubG93OwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmVxID0gTG9uZ1Byb3RvdHlwZS5lcXVhbHM7CiAgICAgIExvbmdQcm90b3R5cGUubm90RXF1YWxzID0gZnVuY3Rpb24gbm90RXF1YWxzKG90aGVyKSB7CiAgICAgICAgcmV0dXJuICF0aGlzLmVxKG90aGVyKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5uZXEgPSBMb25nUHJvdG90eXBlLm5vdEVxdWFsczsKICAgICAgTG9uZ1Byb3RvdHlwZS5uZSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzOwogICAgICBMb25nUHJvdG90eXBlLmxlc3NUaGFuID0gZnVuY3Rpb24gbGVzc1RoYW4ob3RoZXIpIHsKICAgICAgICByZXR1cm4gdGhpcy5jb21wKG90aGVyKSA8IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUubHQgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuOwogICAgICBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uIGxlc3NUaGFuT3JFcXVhbChvdGhlcikgewogICAgICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpIDw9IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUubHRlID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWw7CiAgICAgIExvbmdQcm90b3R5cGUubGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDsKICAgICAgTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbiA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuKG90aGVyKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuY29tcChvdGhlcikgPiAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmd0ID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbjsKICAgICAgTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBncmVhdGVyVGhhbk9yRXF1YWwob3RoZXIpIHsKICAgICAgICByZXR1cm4gdGhpcy5jb21wKG90aGVyKSA+PSAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmd0ZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsOwogICAgICBMb25nUHJvdG90eXBlLmdlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7CiAgICAgIExvbmdQcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUob3RoZXIpIHsKICAgICAgICBpZiAoIWlzTG9uZyhvdGhlcikpCiAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7CiAgICAgICAgaWYgKHRoaXMuZXEob3RoZXIpKQogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgdmFyIHRoaXNOZWcgPSB0aGlzLmlzTmVnYXRpdmUoKSwgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7CiAgICAgICAgaWYgKHRoaXNOZWcgJiYgIW90aGVyTmVnKQogICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgIGlmICghdGhpc05lZyAmJiBvdGhlck5lZykKICAgICAgICAgIHJldHVybiAxOwogICAgICAgIGlmICghdGhpcy51bnNpZ25lZCkKICAgICAgICAgIHJldHVybiB0aGlzLnN1YihvdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxOwogICAgICAgIHJldHVybiBvdGhlci5oaWdoID4+PiAwID4gdGhpcy5oaWdoID4+PiAwIHx8IG90aGVyLmhpZ2ggPT09IHRoaXMuaGlnaCAmJiBvdGhlci5sb3cgPj4+IDAgPiB0aGlzLmxvdyA+Pj4gMCA/IC0xIDogMTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5jb21wID0gTG9uZ1Byb3RvdHlwZS5jb21wYXJlOwogICAgICBMb25nUHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uIG5lZ2F0ZSgpIHsKICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5lcShNSU5fVkFMVUUpKQogICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTsKICAgICAgICByZXR1cm4gdGhpcy5ub3QoKS5hZGQoT05FKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5uZWcgPSBMb25nUHJvdG90eXBlLm5lZ2F0ZTsKICAgICAgTG9uZ1Byb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoYWRkZW5kKSB7CiAgICAgICAgaWYgKCFpc0xvbmcoYWRkZW5kKSkKICAgICAgICAgIGFkZGVuZCA9IGZyb21WYWx1ZShhZGRlbmQpOwogICAgICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2OwogICAgICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiA2NTUzNTsKICAgICAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2OwogICAgICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDY1NTM1OwogICAgICAgIHZhciBiNDggPSBhZGRlbmQuaGlnaCA+Pj4gMTY7CiAgICAgICAgdmFyIGIzMiA9IGFkZGVuZC5oaWdoICYgNjU1MzU7CiAgICAgICAgdmFyIGIxNiA9IGFkZGVuZC5sb3cgPj4+IDE2OwogICAgICAgIHZhciBiMDAgPSBhZGRlbmQubG93ICYgNjU1MzU7CiAgICAgICAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7CiAgICAgICAgYzAwICs9IGEwMCArIGIwMDsKICAgICAgICBjMTYgKz0gYzAwID4+PiAxNjsKICAgICAgICBjMDAgJj0gNjU1MzU7CiAgICAgICAgYzE2ICs9IGExNiArIGIxNjsKICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjsKICAgICAgICBjMTYgJj0gNjU1MzU7CiAgICAgICAgYzMyICs9IGEzMiArIGIzMjsKICAgICAgICBjNDggKz0gYzMyID4+PiAxNjsKICAgICAgICBjMzIgJj0gNjU1MzU7CiAgICAgICAgYzQ4ICs9IGE0OCArIGI0ODsKICAgICAgICBjNDggJj0gNjU1MzU7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGMxNiA8PCAxNiB8IGMwMCwgYzQ4IDw8IDE2IHwgYzMyLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KHN1YnRyYWhlbmQpIHsKICAgICAgICBpZiAoIWlzTG9uZyhzdWJ0cmFoZW5kKSkKICAgICAgICAgIHN1YnRyYWhlbmQgPSBmcm9tVmFsdWUoc3VidHJhaGVuZCk7CiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHN1YnRyYWhlbmQubmVnKCkpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLnN1YiA9IExvbmdQcm90b3R5cGUuc3VidHJhY3Q7CiAgICAgIExvbmdQcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShtdWx0aXBsaWVyKSB7CiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpCiAgICAgICAgICByZXR1cm4gWkVSTzsKICAgICAgICBpZiAoIWlzTG9uZyhtdWx0aXBsaWVyKSkKICAgICAgICAgIG11bHRpcGxpZXIgPSBmcm9tVmFsdWUobXVsdGlwbGllcik7CiAgICAgICAgaWYgKHdhc20pIHsKICAgICAgICAgIHZhciBsb3cgPSB3YXNtLm11bCh0aGlzLmxvdywgdGhpcy5oaWdoLCBtdWx0aXBsaWVyLmxvdywgbXVsdGlwbGllci5oaWdoKTsKICAgICAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgfQogICAgICAgIGlmIChtdWx0aXBsaWVyLmlzWmVybygpKQogICAgICAgICAgcmV0dXJuIFpFUk87CiAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkKICAgICAgICAgIHJldHVybiBtdWx0aXBsaWVyLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPOwogICAgICAgIGlmIChtdWx0aXBsaWVyLmVxKE1JTl9WQUxVRSkpCiAgICAgICAgICByZXR1cm4gdGhpcy5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTzsKICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsKICAgICAgICAgIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSkKICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIubmVnKCkpOwogICAgICAgICAgZWxzZQogICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllcikubmVnKCk7CiAgICAgICAgfSBlbHNlIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSkKICAgICAgICAgIHJldHVybiB0aGlzLm11bChtdWx0aXBsaWVyLm5lZygpKS5uZWcoKTsKICAgICAgICBpZiAodGhpcy5sdChUV09fUFdSXzI0KSAmJiBtdWx0aXBsaWVyLmx0KFRXT19QV1JfMjQpKQogICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcy50b051bWJlcigpICogbXVsdGlwbGllci50b051bWJlcigpLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjsKICAgICAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgNjU1MzU7CiAgICAgICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjsKICAgICAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiA2NTUzNTsKICAgICAgICB2YXIgYjQ4ID0gbXVsdGlwbGllci5oaWdoID4+PiAxNjsKICAgICAgICB2YXIgYjMyID0gbXVsdGlwbGllci5oaWdoICYgNjU1MzU7CiAgICAgICAgdmFyIGIxNiA9IG11bHRpcGxpZXIubG93ID4+PiAxNjsKICAgICAgICB2YXIgYjAwID0gbXVsdGlwbGllci5sb3cgJiA2NTUzNTsKICAgICAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDsKICAgICAgICBjMDAgKz0gYTAwICogYjAwOwogICAgICAgIGMxNiArPSBjMDAgPj4+IDE2OwogICAgICAgIGMwMCAmPSA2NTUzNTsKICAgICAgICBjMTYgKz0gYTE2ICogYjAwOwogICAgICAgIGMzMiArPSBjMTYgPj4+IDE2OwogICAgICAgIGMxNiAmPSA2NTUzNTsKICAgICAgICBjMTYgKz0gYTAwICogYjE2OwogICAgICAgIGMzMiArPSBjMTYgPj4+IDE2OwogICAgICAgIGMxNiAmPSA2NTUzNTsKICAgICAgICBjMzIgKz0gYTMyICogYjAwOwogICAgICAgIGM0OCArPSBjMzIgPj4+IDE2OwogICAgICAgIGMzMiAmPSA2NTUzNTsKICAgICAgICBjMzIgKz0gYTE2ICogYjE2OwogICAgICAgIGM0OCArPSBjMzIgPj4+IDE2OwogICAgICAgIGMzMiAmPSA2NTUzNTsKICAgICAgICBjMzIgKz0gYTAwICogYjMyOwogICAgICAgIGM0OCArPSBjMzIgPj4+IDE2OwogICAgICAgIGMzMiAmPSA2NTUzNTsKICAgICAgICBjNDggKz0gYTQ4ICogYjAwICsgYTMyICogYjE2ICsgYTE2ICogYjMyICsgYTAwICogYjQ4OwogICAgICAgIGM0OCAmPSA2NTUzNTsKICAgICAgICByZXR1cm4gZnJvbUJpdHMoYzE2IDw8IDE2IHwgYzAwLCBjNDggPDwgMTYgfCBjMzIsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLm11bCA9IExvbmdQcm90b3R5cGUubXVsdGlwbHk7CiAgICAgIExvbmdQcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gZGl2aWRlKGRpdmlzb3IpIHsKICAgICAgICBpZiAoIWlzTG9uZyhkaXZpc29yKSkKICAgICAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7CiAgICAgICAgaWYgKGRpdmlzb3IuaXNaZXJvKCkpCiAgICAgICAgICB0aHJvdyBFcnJvcigiZGl2aXNpb24gYnkgemVybyIpOwogICAgICAgIGlmICh3YXNtKSB7CiAgICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoID09PSAtMjE0NzQ4MzY0OCAmJiBkaXZpc29yLmxvdyA9PT0gLTEgJiYgZGl2aXNvci5oaWdoID09PSAtMSkgewogICAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc20uZGl2X3UgOiB3YXNtLmRpdl9zKSh0aGlzLmxvdywgdGhpcy5oaWdoLCBkaXZpc29yLmxvdywgZGl2aXNvci5oaWdoKTsKICAgICAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgfQogICAgICAgIGlmICh0aGlzLmlzWmVybygpKQogICAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87CiAgICAgICAgdmFyIGFwcHJveCwgcmVtLCByZXM7CiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKSB7CiAgICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7CiAgICAgICAgICAgIGlmIChkaXZpc29yLmVxKE9ORSkgfHwgZGl2aXNvci5lcShORUdfT05FKSkKICAgICAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFOwogICAgICAgICAgICBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpCiAgICAgICAgICAgICAgcmV0dXJuIE9ORTsKICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgdmFyIGhhbGZUaGlzID0gdGhpcy5zaHIoMSk7CiAgICAgICAgICAgICAgYXBwcm94ID0gaGFsZlRoaXMuZGl2KGRpdmlzb3IpLnNobCgxKTsKICAgICAgICAgICAgICBpZiAoYXBwcm94LmVxKFpFUk8pKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gZGl2aXNvci5pc05lZ2F0aXZlKCkgPyBPTkUgOiBORUdfT05FOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICByZW0gPSB0aGlzLnN1YihkaXZpc29yLm11bChhcHByb3gpKTsKICAgICAgICAgICAgICAgIHJlcyA9IGFwcHJveC5hZGQocmVtLmRpdihkaXZpc29yKSk7CiAgICAgICAgICAgICAgICByZXR1cm4gcmVzOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpCiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPOwogICAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7CiAgICAgICAgICAgIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSkKICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvci5uZWcoKSk7CiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yKS5uZWcoKTsKICAgICAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpCiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpdihkaXZpc29yLm5lZygpKS5uZWcoKTsKICAgICAgICAgIHJlcyA9IFpFUk87CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGlmICghZGl2aXNvci51bnNpZ25lZCkKICAgICAgICAgICAgZGl2aXNvciA9IGRpdmlzb3IudG9VbnNpZ25lZCgpOwogICAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcykpCiAgICAgICAgICAgIHJldHVybiBVWkVSTzsKICAgICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMuc2hydSgxKSkpCiAgICAgICAgICAgIHJldHVybiBVT05FOwogICAgICAgICAgcmVzID0gVVpFUk87CiAgICAgICAgfQogICAgICAgIHJlbSA9IHRoaXM7CiAgICAgICAgd2hpbGUgKHJlbS5ndGUoZGl2aXNvcikpIHsKICAgICAgICAgIGFwcHJveCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IocmVtLnRvTnVtYmVyKCkgLyBkaXZpc29yLnRvTnVtYmVyKCkpKTsKICAgICAgICAgIHZhciBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMiksIGRlbHRhID0gbG9nMiA8PSA0OCA/IDEgOiBwb3dfZGJsKDIsIGxvZzIgLSA0OCksIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94KSwgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTsKICAgICAgICAgIHdoaWxlIChhcHByb3hSZW0uaXNOZWdhdGl2ZSgpIHx8IGFwcHJveFJlbS5ndChyZW0pKSB7CiAgICAgICAgICAgIGFwcHJveCAtPSBkZWx0YTsKICAgICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gsIHRoaXMudW5zaWduZWQpOwogICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSkKICAgICAgICAgICAgYXBwcm94UmVzID0gT05FOwogICAgICAgICAgcmVzID0gcmVzLmFkZChhcHByb3hSZXMpOwogICAgICAgICAgcmVtID0gcmVtLnN1YihhcHByb3hSZW0pOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmVzOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmRpdiA9IExvbmdQcm90b3R5cGUuZGl2aWRlOwogICAgICBMb25nUHJvdG90eXBlLm1vZHVsbyA9IGZ1bmN0aW9uIG1vZHVsbyhkaXZpc29yKSB7CiAgICAgICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpCiAgICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpOwogICAgICAgIGlmICh3YXNtKSB7CiAgICAgICAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtLnJlbV91IDogd2FzbS5yZW1fcykodGhpcy5sb3csIHRoaXMuaGlnaCwgZGl2aXNvci5sb3csIGRpdmlzb3IuaGlnaCk7CiAgICAgICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpcy5zdWIodGhpcy5kaXYoZGl2aXNvcikubXVsKGRpdmlzb3IpKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5tb2QgPSBMb25nUHJvdG90eXBlLm1vZHVsbzsKICAgICAgTG9uZ1Byb3RvdHlwZS5yZW0gPSBMb25nUHJvdG90eXBlLm1vZHVsbzsKICAgICAgTG9uZ1Byb3RvdHlwZS5ub3QgPSBmdW5jdGlvbiBub3QoKSB7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzKH50aGlzLmxvdywgfnRoaXMuaGlnaCwgdGhpcy51bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kKG90aGVyKSB7CiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKQogICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpOwogICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyAmIG90aGVyLmxvdywgdGhpcy5oaWdoICYgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvcihvdGhlcikgewogICAgICAgIGlmICghaXNMb25nKG90aGVyKSkKICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTsKICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgfCBvdGhlci5sb3csIHRoaXMuaGlnaCB8IG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvcihvdGhlcikgewogICAgICAgIGlmICghaXNMb25nKG90aGVyKSkKICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTsKICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgXiBvdGhlci5sb3csIHRoaXMuaGlnaCBeIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLnNoaWZ0TGVmdCA9IGZ1bmN0aW9uIHNoaWZ0TGVmdChudW1CaXRzKSB7CiAgICAgICAgaWYgKGlzTG9uZyhudW1CaXRzKSkKICAgICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7CiAgICAgICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMikKICAgICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA8PCBudW1CaXRzLCB0aGlzLmhpZ2ggPDwgbnVtQml0cyB8IHRoaXMubG93ID4+PiAzMiAtIG51bUJpdHMsIHRoaXMudW5zaWduZWQpOwogICAgICAgIGVsc2UKICAgICAgICAgIHJldHVybiBmcm9tQml0cygwLCB0aGlzLmxvdyA8PCBudW1CaXRzIC0gMzIsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLnNobCA9IExvbmdQcm90b3R5cGUuc2hpZnRMZWZ0OwogICAgICBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0KG51bUJpdHMpIHsKICAgICAgICBpZiAoaXNMb25nKG51bUJpdHMpKQogICAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTsKICAgICAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKQogICAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93ID4+PiBudW1CaXRzIHwgdGhpcy5oaWdoIDw8IDMyIC0gbnVtQml0cywgdGhpcy5oaWdoID4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpOwogICAgICAgIGVsc2UKICAgICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2ggPj4gbnVtQml0cyAtIDMyLCB0aGlzLmhpZ2ggPj0gMCA/IDAgOiAtMSwgdGhpcy51bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuc2hyID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0OwogICAgICBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHRVbnNpZ25lZChudW1CaXRzKSB7CiAgICAgICAgaWYgKGlzTG9uZyhudW1CaXRzKSkKICAgICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7CiAgICAgICAgbnVtQml0cyAmPSA2MzsKICAgICAgICBpZiAobnVtQml0cyA9PT0gMCkKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIGVsc2UgewogICAgICAgICAgdmFyIGhpZ2ggPSB0aGlzLmhpZ2g7CiAgICAgICAgICBpZiAobnVtQml0cyA8IDMyKSB7CiAgICAgICAgICAgIHZhciBsb3cgPSB0aGlzLmxvdzsKICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdyA+Pj4gbnVtQml0cyB8IGhpZ2ggPDwgMzIgLSBudW1CaXRzLCBoaWdoID4+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICAgIH0gZWxzZSBpZiAobnVtQml0cyA9PT0gMzIpCiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhoaWdoLCAwLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGhpZ2ggPj4+IG51bUJpdHMgLSAzMiwgMCwgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgfQogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLnNocnUgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDsKICAgICAgTG9uZ1Byb3RvdHlwZS5zaHJfdSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkOwogICAgICBMb25nUHJvdG90eXBlLnRvU2lnbmVkID0gZnVuY3Rpb24gdG9TaWduZWQoKSB7CiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIGZhbHNlKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS50b1Vuc2lnbmVkID0gZnVuY3Rpb24gdG9VbnNpZ25lZCgpIHsKICAgICAgICBpZiAodGhpcy51bnNpZ25lZCkKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCB0cnVlKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24gdG9CeXRlcyhsZSkgewogICAgICAgIHJldHVybiBsZSA/IHRoaXMudG9CeXRlc0xFKCkgOiB0aGlzLnRvQnl0ZXNCRSgpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLnRvQnl0ZXNMRSA9IGZ1bmN0aW9uIHRvQnl0ZXNMRSgpIHsKICAgICAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsIGxvID0gdGhpcy5sb3c7CiAgICAgICAgcmV0dXJuIFsKICAgICAgICAgIGxvICYgMjU1LAogICAgICAgICAgbG8gPj4+IDggJiAyNTUsCiAgICAgICAgICBsbyA+Pj4gMTYgJiAyNTUsCiAgICAgICAgICBsbyA+Pj4gMjQsCiAgICAgICAgICBoaSAmIDI1NSwKICAgICAgICAgIGhpID4+PiA4ICYgMjU1LAogICAgICAgICAgaGkgPj4+IDE2ICYgMjU1LAogICAgICAgICAgaGkgPj4+IDI0CiAgICAgICAgXTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS50b0J5dGVzQkUgPSBmdW5jdGlvbiB0b0J5dGVzQkUoKSB7CiAgICAgICAgdmFyIGhpID0gdGhpcy5oaWdoLCBsbyA9IHRoaXMubG93OwogICAgICAgIHJldHVybiBbCiAgICAgICAgICBoaSA+Pj4gMjQsCiAgICAgICAgICBoaSA+Pj4gMTYgJiAyNTUsCiAgICAgICAgICBoaSA+Pj4gOCAmIDI1NSwKICAgICAgICAgIGhpICYgMjU1LAogICAgICAgICAgbG8gPj4+IDI0LAogICAgICAgICAgbG8gPj4+IDE2ICYgMjU1LAogICAgICAgICAgbG8gPj4+IDggJiAyNTUsCiAgICAgICAgICBsbyAmIDI1NQogICAgICAgIF07CiAgICAgIH07CiAgICAgIExvbmcuZnJvbUJ5dGVzID0gZnVuY3Rpb24gZnJvbUJ5dGVzKGJ5dGVzLCB1bnNpZ25lZCwgbGUpIHsKICAgICAgICByZXR1cm4gbGUgPyBMb25nLmZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkgOiBMb25nLmZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmcuZnJvbUJ5dGVzTEUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIHsKICAgICAgICByZXR1cm4gbmV3IExvbmcoYnl0ZXNbMF0gfCBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMl0gPDwgMTYgfCBieXRlc1szXSA8PCAyNCwgYnl0ZXNbNF0gfCBieXRlc1s1XSA8PCA4IHwgYnl0ZXNbNl0gPDwgMTYgfCBieXRlc1s3XSA8PCAyNCwgdW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nLmZyb21CeXRlc0JFID0gZnVuY3Rpb24gZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKSB7CiAgICAgICAgcmV0dXJuIG5ldyBMb25nKGJ5dGVzWzRdIDw8IDI0IHwgYnl0ZXNbNV0gPDwgMTYgfCBieXRlc1s2XSA8PCA4IHwgYnl0ZXNbN10sIGJ5dGVzWzBdIDw8IDI0IHwgYnl0ZXNbMV0gPDwgMTYgfCBieXRlc1syXSA8PCA4IHwgYnl0ZXNbM10sIHVuc2lnbmVkKTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9hcnJheS92aXJ0dWFsL2NvbmNhdC5qcwogIHZhciByZXF1aXJlX2NvbmNhdCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvYXJyYXkvdmlydHVhbC9jb25jYXQuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHJlcXVpcmVfZXNfYXJyYXlfY29uY2F0KCk7CiAgICAgIHZhciBlbnRyeVZpcnR1YWwgPSByZXF1aXJlX2VudHJ5X3ZpcnR1YWwoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBlbnRyeVZpcnR1YWwoIkFycmF5IikuY29uY2F0OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2luc3RhbmNlL2NvbmNhdC5qcwogIHZhciByZXF1aXJlX2NvbmNhdDIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2luc3RhbmNlL2NvbmNhdC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGNvbmNhdCA9IHJlcXVpcmVfY29uY2F0KCk7CiAgICAgIHZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCkgewogICAgICAgIHZhciBvd24gPSBpdC5jb25jYXQ7CiAgICAgICAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSB8fCBpdCBpbnN0YW5jZW9mIEFycmF5ICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUuY29uY2F0ID8gY29uY2F0IDogb3duOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9pbnN0YW5jZS9jb25jYXQuanMKICB2YXIgcmVxdWlyZV9jb25jYXQzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvaW5zdGFuY2UvY29uY2F0LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgcGFyZW50ID0gcmVxdWlyZV9jb25jYXQyKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGFyZW50OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9pbnN0YW5jZS9jb25jYXQuanMKICB2YXIgcmVxdWlyZV9jb25jYXQ0ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvaW5zdGFuY2UvY29uY2F0LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVfY29uY2F0MygpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmFtL2Rpc3QvdmlydHVhbE9mZnNldC5qcwogIHZhciByZXF1aXJlX3ZpcnR1YWxPZmZzZXQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGdtb2QvYmFtL2Rpc3QvdmlydHVhbE9mZnNldC5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlX2ludGVyb3BSZXF1aXJlRGVmYXVsdCgpOwogICAgICB2YXIgX09iamVjdCRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmVfZGVmaW5lX3Byb3BlcnR5MygpOwogICAgICBfT2JqZWN0JGRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgewogICAgICAgIHZhbHVlOiB0cnVlCiAgICAgIH0pOwogICAgICBleHBvcnRzLmZyb21CeXRlcyA9IGZyb21CeXRlczsKICAgICAgZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwOwogICAgICB2YXIgX2NvbmNhdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9jb25jYXQ0KCkpOwogICAgICB2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9jbGFzc0NhbGxDaGVjaygpKTsKICAgICAgdmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfY3JlYXRlQ2xhc3MoKSk7CiAgICAgIHZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2RlZmluZVByb3BlcnR5KCkpOwogICAgICB2YXIgVmlydHVhbE9mZnNldCA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHsKICAgICAgICBmdW5jdGlvbiBWaXJ0dWFsT2Zmc2V0MihibG9ja1Bvc2l0aW9uLCBkYXRhUG9zaXRpb24pIHsKICAgICAgICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFZpcnR1YWxPZmZzZXQyKTsKICAgICAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsICJibG9ja1Bvc2l0aW9uIiwgdm9pZCAwKTsKICAgICAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsICJkYXRhUG9zaXRpb24iLCB2b2lkIDApOwogICAgICAgICAgdGhpcy5ibG9ja1Bvc2l0aW9uID0gYmxvY2tQb3NpdGlvbjsKICAgICAgICAgIHRoaXMuZGF0YVBvc2l0aW9uID0gZGF0YVBvc2l0aW9uOwogICAgICAgIH0KICAgICAgICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShWaXJ0dWFsT2Zmc2V0MiwgW3sKICAgICAgICAgIGtleTogInRvU3RyaW5nIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHsKICAgICAgICAgICAgdmFyIF9jb250ZXh0OwogICAgICAgICAgICByZXR1cm4gKDAsIF9jb25jYXQuZGVmYXVsdCkoX2NvbnRleHQgPSAiIi5jb25jYXQodGhpcy5ibG9ja1Bvc2l0aW9uLCAiOiIpKS5jYWxsKF9jb250ZXh0LCB0aGlzLmRhdGFQb3NpdGlvbik7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiY29tcGFyZVRvIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlVG8oYikgewogICAgICAgICAgICByZXR1cm4gdGhpcy5ibG9ja1Bvc2l0aW9uIC0gYi5ibG9ja1Bvc2l0aW9uIHx8IHRoaXMuZGF0YVBvc2l0aW9uIC0gYi5kYXRhUG9zaXRpb247CiAgICAgICAgICB9CiAgICAgICAgfV0sIFt7CiAgICAgICAgICBrZXk6ICJtaW4iLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1pbigpIHsKICAgICAgICAgICAgdmFyIG1pbjI7CiAgICAgICAgICAgIHZhciBpID0gMDsKICAgICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7CiAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTsKICAgICAgICAgICAgfQogICAgICAgICAgICBmb3IgKDsgIW1pbjI7IGkgKz0gMSkgewogICAgICAgICAgICAgIG1pbjIgPSBhcmdzW2ldOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgICAgIGlmIChtaW4yLmNvbXBhcmVUbyhhcmdzW2ldKSA+IDApIHsKICAgICAgICAgICAgICAgIG1pbjIgPSBhcmdzW2ldOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gbWluMjsKICAgICAgICAgIH0KICAgICAgICB9XSk7CiAgICAgICAgcmV0dXJuIFZpcnR1YWxPZmZzZXQyOwogICAgICB9KCk7CiAgICAgIGV4cG9ydHMuZGVmYXVsdCA9IFZpcnR1YWxPZmZzZXQ7CiAgICAgIGZ1bmN0aW9uIGZyb21CeXRlcyhieXRlcykgewogICAgICAgIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IDA7CiAgICAgICAgdmFyIGJpZ2VuZGlhbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDogZmFsc2U7CiAgICAgICAgaWYgKGJpZ2VuZGlhbikgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJiaWctZW5kaWFuIHZpcnR1YWwgZmlsZSBvZmZzZXRzIG5vdCBpbXBsZW1lbnRlZCIpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbmV3IFZpcnR1YWxPZmZzZXQoYnl0ZXNbb2Zmc2V0ICsgN10gKiAxMDk5NTExNjI3Nzc2ICsgYnl0ZXNbb2Zmc2V0ICsgNl0gKiA0Mjk0OTY3Mjk2ICsgYnl0ZXNbb2Zmc2V0ICsgNV0gKiAxNjc3NzIxNiArIGJ5dGVzW29mZnNldCArIDRdICogNjU1MzYgKyBieXRlc1tvZmZzZXQgKyAzXSAqIDI1NiArIGJ5dGVzW29mZnNldCArIDJdLCBieXRlc1tvZmZzZXQgKyAxXSA8PCA4IHwgYnl0ZXNbb2Zmc2V0XSk7CiAgICAgIH0KICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL2JhbS9kaXN0L2NodW5rLmpzCiAgdmFyIHJlcXVpcmVfY2h1bmsgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGdtb2QvYmFtL2Rpc3QvY2h1bmsuanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoKTsKICAgICAgdmFyIF9PYmplY3QkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlX2RlZmluZV9wcm9wZXJ0eTMoKTsKICAgICAgX09iamVjdCRkZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAiX19lc01vZHVsZSIsIHsKICAgICAgICB2YWx1ZTogdHJ1ZQogICAgICB9KTsKICAgICAgZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwOwogICAgICB2YXIgX2NvbmNhdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9jb25jYXQ0KCkpOwogICAgICB2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9jbGFzc0NhbGxDaGVjaygpKTsKICAgICAgdmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfY3JlYXRlQ2xhc3MoKSk7CiAgICAgIHZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2RlZmluZVByb3BlcnR5KCkpOwogICAgICB2YXIgQ2h1bmsgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7CiAgICAgICAgZnVuY3Rpb24gQ2h1bmsyKG1pbnYsIG1heHYsIGJpbikgewogICAgICAgICAgdmFyIGZldGNoZWRTaXplID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbM10gOiB2b2lkIDA7CiAgICAgICAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBDaHVuazIpOwogICAgICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgIm1pbnYiLCB2b2lkIDApOwogICAgICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgIm1heHYiLCB2b2lkIDApOwogICAgICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgImJpbiIsIHZvaWQgMCk7CiAgICAgICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCAiX2ZldGNoZWRTaXplIiwgdm9pZCAwKTsKICAgICAgICAgIHRoaXMubWludiA9IG1pbnY7CiAgICAgICAgICB0aGlzLm1heHYgPSBtYXh2OwogICAgICAgICAgdGhpcy5iaW4gPSBiaW47CiAgICAgICAgICB0aGlzLl9mZXRjaGVkU2l6ZSA9IGZldGNoZWRTaXplOwogICAgICAgIH0KICAgICAgICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShDaHVuazIsIFt7CiAgICAgICAgICBrZXk6ICJ0b1VuaXF1ZVN0cmluZyIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9VbmlxdWVTdHJpbmcoKSB7CiAgICAgICAgICAgIHZhciBfY29udGV4dCwgX2NvbnRleHQyLCBfY29udGV4dDM7CiAgICAgICAgICAgIHJldHVybiAoMCwgX2NvbmNhdC5kZWZhdWx0KShfY29udGV4dCA9ICgwLCBfY29uY2F0LmRlZmF1bHQpKF9jb250ZXh0MiA9ICgwLCBfY29uY2F0LmRlZmF1bHQpKF9jb250ZXh0MyA9ICIiLmNvbmNhdCh0aGlzLm1pbnYsICIuLiIpKS5jYWxsKF9jb250ZXh0MywgdGhpcy5tYXh2LCAiIChiaW4gIikpLmNhbGwoX2NvbnRleHQyLCB0aGlzLmJpbiwgIiwgZmV0Y2hlZFNpemUgIikpLmNhbGwoX2NvbnRleHQsIHRoaXMuZmV0Y2hlZFNpemUoKSwgIikiKTsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJ0b1N0cmluZyIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvVW5pcXVlU3RyaW5nKCk7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiY29tcGFyZVRvIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlVG8oYikgewogICAgICAgICAgICByZXR1cm4gdGhpcy5taW52LmNvbXBhcmVUbyhiLm1pbnYpIHx8IHRoaXMubWF4di5jb21wYXJlVG8oYi5tYXh2KSB8fCB0aGlzLmJpbiAtIGIuYmluOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogImZldGNoZWRTaXplIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmZXRjaGVkU2l6ZSgpIHsKICAgICAgICAgICAgaWYgKHRoaXMuX2ZldGNoZWRTaXplICE9PSB2b2lkIDApIHsKICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2hlZFNpemU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF4di5ibG9ja1Bvc2l0aW9uICsgKDEgPDwgMTYpIC0gdGhpcy5taW52LmJsb2NrUG9zaXRpb247CiAgICAgICAgICB9CiAgICAgICAgfV0pOwogICAgICAgIHJldHVybiBDaHVuazI7CiAgICAgIH0oKTsKICAgICAgZXhwb3J0cy5kZWZhdWx0ID0gQ2h1bms7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qcwogIHZhciByZXF1aXJlX2ludGVyb3BSZXF1aXJlRGVmYXVsdDIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7CiAgICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsKICAgICAgICAgICJkZWZhdWx0Ijogb2JqCiAgICAgICAgfTsKICAgICAgfQogICAgICBtb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQ7CiAgICAgIG1vZHVsZS5leHBvcnRzWyJkZWZhdWx0Il0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcwogIHZhciByZXF1aXJlX3R5cGVvZjIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7CiAgICAgICAgIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mIjsKICAgICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gImZ1bmN0aW9uIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAic3ltYm9sIikgewogICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZjIob2JqMikgewogICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9iajI7CiAgICAgICAgICB9OwogICAgICAgICAgbW9kdWxlLmV4cG9ydHNbImRlZmF1bHQiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZjIob2JqMikgewogICAgICAgICAgICByZXR1cm4gb2JqMiAmJiB0eXBlb2YgU3ltYm9sID09PSAiZnVuY3Rpb24iICYmIG9iajIuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmoyICE9PSBTeW1ib2wucHJvdG90eXBlID8gInN5bWJvbCIgOiB0eXBlb2Ygb2JqMjsKICAgICAgICAgIH07CiAgICAgICAgICBtb2R1bGUuZXhwb3J0c1siZGVmYXVsdCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gX3R5cGVvZihvYmopOwogICAgICB9CiAgICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZjsKICAgICAgbW9kdWxlLmV4cG9ydHNbImRlZmF1bHQiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMKICB2YXIgcmVxdWlyZV9jbGFzc0NhbGxDaGVjazIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgewogICAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24iKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgbW9kdWxlLmV4cG9ydHMgPSBfY2xhc3NDYWxsQ2hlY2s7CiAgICAgIG1vZHVsZS5leHBvcnRzWyJkZWZhdWx0Il0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzCiAgdmFyIHJlcXVpcmVfY3JlYXRlQ2xhc3MyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOwogICAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOwogICAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOwogICAgICAgICAgaWYgKCJ2YWx1ZSIgaW4gZGVzY3JpcHRvcikKICAgICAgICAgICAgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsKICAgICAgICBpZiAocHJvdG9Qcm9wcykKICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7CiAgICAgICAgaWYgKHN0YXRpY1Byb3BzKQogICAgICAgICAgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsKICAgICAgICByZXR1cm4gQ29uc3RydWN0b3I7CiAgICAgIH0KICAgICAgbW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3M7CiAgICAgIG1vZHVsZS5leHBvcnRzWyJkZWZhdWx0Il0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzCiAgdmFyIHJlcXVpcmVfZGVmaW5lUHJvcGVydHkyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsKICAgICAgICBpZiAoa2V5IGluIG9iaikgewogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7CiAgICAgICAgICAgIHZhbHVlLAogICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG9iajsKICAgICAgfQogICAgICBtb2R1bGUuZXhwb3J0cyA9IF9kZWZpbmVQcm9wZXJ0eTsKICAgICAgbW9kdWxlLmV4cG9ydHNbImRlZmF1bHQiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2Fib3J0Y29udHJvbGxlci1wb2x5ZmlsbC9kaXN0L2Nqcy1wb255ZmlsbC5qcwogIHZhciByZXF1aXJlX2Nqc19wb255ZmlsbCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9hYm9ydGNvbnRyb2xsZXItcG9seWZpbGwvZGlzdC9janMtcG9ueWZpbGwuanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsKICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uIik7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOwogICAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOwogICAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOwogICAgICAgICAgaWYgKCJ2YWx1ZSIgaW4gZGVzY3JpcHRvcikKICAgICAgICAgICAgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsKICAgICAgICBpZiAocHJvdG9Qcm9wcykKICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7CiAgICAgICAgaWYgKHN0YXRpY1Byb3BzKQogICAgICAgICAgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsKICAgICAgICByZXR1cm4gQ29uc3RydWN0b3I7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7CiAgICAgICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAiZnVuY3Rpb24iICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uIik7CiAgICAgICAgfQogICAgICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgewogICAgICAgICAgY29uc3RydWN0b3I6IHsKICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgICAgaWYgKHN1cGVyQ2xhc3MpCiAgICAgICAgICBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7CiAgICAgICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mMihvMikgewogICAgICAgICAgcmV0dXJuIG8yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YobzIpOwogICAgICAgIH07CiAgICAgICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgewogICAgICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YyKG8yLCBwMikgewogICAgICAgICAgbzIuX19wcm90b19fID0gcDI7CiAgICAgICAgICByZXR1cm4gbzI7CiAgICAgICAgfTsKICAgICAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7CiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAidW5kZWZpbmVkIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpCiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pCiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gImZ1bmN0aW9uIikKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIHRyeSB7CiAgICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkgewogICAgICAgICAgfSkpOwogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYyKSB7CiAgICAgICAgaWYgKHNlbGYyID09PSB2b2lkIDApIHsKICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcigidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkIik7CiAgICAgICAgfQogICAgICAgIHJldHVybiBzZWxmMjsKICAgICAgfQogICAgICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmMiwgY2FsbCkgewogICAgICAgIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gIm9iamVjdCIgfHwgdHlwZW9mIGNhbGwgPT09ICJmdW5jdGlvbiIpKSB7CiAgICAgICAgICByZXR1cm4gY2FsbDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZjIpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7CiAgICAgICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgewogICAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7CiAgICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgewogICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOwogICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOwogICAgICAgIH07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgewogICAgICAgIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7CiAgICAgICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsKICAgICAgICAgIGlmIChvYmplY3QgPT09IG51bGwpCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2JqZWN0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsKICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09ICJ1bmRlZmluZWQiICYmIFJlZmxlY3QuZ2V0KSB7CiAgICAgICAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0Mih0YXJnZXQyLCBwcm9wZXJ0eTIsIHJlY2VpdmVyMikgewogICAgICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldDIsIHByb3BlcnR5Mik7CiAgICAgICAgICAgIGlmICghYmFzZSkKICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eTIpOwogICAgICAgICAgICBpZiAoZGVzYy5nZXQpIHsKICAgICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcjIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBkZXNjLnZhbHVlOwogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsKICAgICAgfQogICAgICB2YXIgRW1pdHRlciA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHsKICAgICAgICBmdW5jdGlvbiBFbWl0dGVyMigpIHsKICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbWl0dGVyMik7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgImxpc3RlbmVycyIsIHsKICAgICAgICAgICAgdmFsdWU6IHt9LAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgX2NyZWF0ZUNsYXNzKEVtaXR0ZXIyLCBbewogICAgICAgICAga2V5OiAiYWRkRXZlbnRMaXN0ZW5lciIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaywgb3B0aW9ucykgewogICAgICAgICAgICBpZiAoISh0eXBlIGluIHRoaXMubGlzdGVuZXJzKSkgewogICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gW107CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaCh7CiAgICAgICAgICAgICAgY2FsbGJhY2ssCiAgICAgICAgICAgICAgb3B0aW9ucwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJyZW1vdmVFdmVudExpc3RlbmVyIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKSB7CiAgICAgICAgICAgIGlmICghKHR5cGUgaW4gdGhpcy5saXN0ZW5lcnMpKSB7CiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBzdGFjayA9IHRoaXMubGlzdGVuZXJzW3R5cGVdOwogICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0YWNrLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICAgIGlmIChzdGFja1tpXS5jYWxsYmFjayA9PT0gY2FsbGJhY2spIHsKICAgICAgICAgICAgICAgIHN0YWNrLnNwbGljZShpLCAxKTsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJkaXNwYXRjaEV2ZW50IiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7CiAgICAgICAgICAgIGlmICghKGV2ZW50LnR5cGUgaW4gdGhpcy5saXN0ZW5lcnMpKSB7CiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBzdGFjayA9IHRoaXMubGlzdGVuZXJzW2V2ZW50LnR5cGVdOwogICAgICAgICAgICB2YXIgc3RhY2tUb0NhbGwgPSBzdGFjay5zbGljZSgpOwogICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0YWNrVG9DYWxsLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHN0YWNrVG9DYWxsW2ldOwogICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjay5jYWxsKHRoaXMsIGV2ZW50KTsKICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgICB0aHJvdyBlOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChsaXN0ZW5lci5vcHRpb25zICYmIGxpc3RlbmVyLm9wdGlvbnMub25jZSkgewogICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LnR5cGUsIGxpc3RlbmVyLmNhbGxiYWNrKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkOwogICAgICAgICAgfQogICAgICAgIH1dKTsKICAgICAgICByZXR1cm4gRW1pdHRlcjI7CiAgICAgIH0oKTsKICAgICAgdmFyIEFib3J0U2lnbmFsID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKF9FbWl0dGVyKSB7CiAgICAgICAgX2luaGVyaXRzKEFib3J0U2lnbmFsMiwgX0VtaXR0ZXIpOwogICAgICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQWJvcnRTaWduYWwyKTsKICAgICAgICBmdW5jdGlvbiBBYm9ydFNpZ25hbDIoKSB7CiAgICAgICAgICB2YXIgX3RoaXM7CiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJvcnRTaWduYWwyKTsKICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7CiAgICAgICAgICBpZiAoIV90aGlzLmxpc3RlbmVycykgewogICAgICAgICAgICBFbWl0dGVyLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpOwogICAgICAgICAgfQogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCAiYWJvcnRlZCIsIHsKICAgICAgICAgICAgdmFsdWU6IGZhbHNlLAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgIm9uYWJvcnQiLCB7CiAgICAgICAgICAgIHZhbHVlOiBudWxsLAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICAgIHJldHVybiBfdGhpczsKICAgICAgICB9CiAgICAgICAgX2NyZWF0ZUNsYXNzKEFib3J0U2lnbmFsMiwgW3sKICAgICAgICAgIGtleTogInRvU3RyaW5nIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHsKICAgICAgICAgICAgcmV0dXJuICJbb2JqZWN0IEFib3J0U2lnbmFsXSI7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiZGlzcGF0Y2hFdmVudCIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChldmVudCkgewogICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gImFib3J0IikgewogICAgICAgICAgICAgIHRoaXMuYWJvcnRlZCA9IHRydWU7CiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uYWJvcnQgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgICAgICAgIHRoaXMub25hYm9ydC5jYWxsKHRoaXMsIGV2ZW50KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoQWJvcnRTaWduYWwyLnByb3RvdHlwZSksICJkaXNwYXRjaEV2ZW50IiwgdGhpcykuY2FsbCh0aGlzLCBldmVudCk7CiAgICAgICAgICB9CiAgICAgICAgfV0pOwogICAgICAgIHJldHVybiBBYm9ydFNpZ25hbDI7CiAgICAgIH0oRW1pdHRlcik7CiAgICAgIHZhciBBYm9ydENvbnRyb2xsZXIgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7CiAgICAgICAgZnVuY3Rpb24gQWJvcnRDb250cm9sbGVyMigpIHsKICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBYm9ydENvbnRyb2xsZXIyKTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAic2lnbmFsIiwgewogICAgICAgICAgICB2YWx1ZTogbmV3IEFib3J0U2lnbmFsKCksCiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLAogICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICBfY3JlYXRlQ2xhc3MoQWJvcnRDb250cm9sbGVyMiwgW3sKICAgICAgICAgIGtleTogImFib3J0IiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhYm9ydCgpIHsKICAgICAgICAgICAgdmFyIGV2ZW50OwogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIGV2ZW50ID0gbmV3IEV2ZW50KCJhYm9ydCIpOwogICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gInVuZGVmaW5lZCIpIHsKICAgICAgICAgICAgICAgIGlmICghZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHsKICAgICAgICAgICAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCgpOwogICAgICAgICAgICAgICAgICBldmVudC50eXBlID0gImFib3J0IjsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoIkV2ZW50Iik7CiAgICAgICAgICAgICAgICAgIGV2ZW50LmluaXRFdmVudCgiYWJvcnQiLCBmYWxzZSwgZmFsc2UpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBldmVudCA9IHsKICAgICAgICAgICAgICAgICAgdHlwZTogImFib3J0IiwKICAgICAgICAgICAgICAgICAgYnViYmxlczogZmFsc2UsCiAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6IGZhbHNlCiAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLnNpZ25hbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJ0b1N0cmluZyIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7CiAgICAgICAgICAgIHJldHVybiAiW29iamVjdCBBYm9ydENvbnRyb2xsZXJdIjsKICAgICAgICAgIH0KICAgICAgICB9XSk7CiAgICAgICAgcmV0dXJuIEFib3J0Q29udHJvbGxlcjI7CiAgICAgIH0oKTsKICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICJ1bmRlZmluZWQiICYmIFN5bWJvbC50b1N0cmluZ1RhZykgewogICAgICAgIEFib3J0Q29udHJvbGxlci5wcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9ICJBYm9ydENvbnRyb2xsZXIiOwogICAgICAgIEFib3J0U2lnbmFsLnByb3RvdHlwZVtTeW1ib2wudG9TdHJpbmdUYWddID0gIkFib3J0U2lnbmFsIjsKICAgICAgfQogICAgICBmdW5jdGlvbiBwb2x5ZmlsbE5lZWRlZChzZWxmMikgewogICAgICAgIGlmIChzZWxmMi5fX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMKSB7CiAgICAgICAgICBjb25zb2xlLmxvZygiX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTD10cnVlIGlzIHNldCwgd2lsbCBmb3JjZSBpbnN0YWxsIHBvbHlmaWxsIik7CiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHR5cGVvZiBzZWxmMi5SZXF1ZXN0ID09PSAiZnVuY3Rpb24iICYmICFzZWxmMi5SZXF1ZXN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgic2lnbmFsIikgfHwgIXNlbGYyLkFib3J0Q29udHJvbGxlcjsKICAgICAgfQogICAgICBmdW5jdGlvbiBhYm9ydGFibGVGZXRjaERlY29yYXRvcihwYXRjaFRhcmdldHMpIHsKICAgICAgICBpZiAodHlwZW9mIHBhdGNoVGFyZ2V0cyA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgcGF0Y2hUYXJnZXRzID0gewogICAgICAgICAgICBmZXRjaDogcGF0Y2hUYXJnZXRzCiAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgICB2YXIgX3BhdGNoVGFyZ2V0cyA9IHBhdGNoVGFyZ2V0cywgZmV0Y2gyID0gX3BhdGNoVGFyZ2V0cy5mZXRjaCwgX3BhdGNoVGFyZ2V0cyRSZXF1ZXN0ID0gX3BhdGNoVGFyZ2V0cy5SZXF1ZXN0LCBOYXRpdmVSZXF1ZXN0ID0gX3BhdGNoVGFyZ2V0cyRSZXF1ZXN0ID09PSB2b2lkIDAgPyBmZXRjaDIuUmVxdWVzdCA6IF9wYXRjaFRhcmdldHMkUmVxdWVzdCwgTmF0aXZlQWJvcnRDb250cm9sbGVyID0gX3BhdGNoVGFyZ2V0cy5BYm9ydENvbnRyb2xsZXIsIF9wYXRjaFRhcmdldHMkX19GT1JDRSA9IF9wYXRjaFRhcmdldHMuX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTCwgX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTCA9IF9wYXRjaFRhcmdldHMkX19GT1JDRSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcGF0Y2hUYXJnZXRzJF9fRk9SQ0U7CiAgICAgICAgaWYgKCFwb2x5ZmlsbE5lZWRlZCh7CiAgICAgICAgICBmZXRjaDogZmV0Y2gyLAogICAgICAgICAgUmVxdWVzdDogTmF0aXZlUmVxdWVzdCwKICAgICAgICAgIEFib3J0Q29udHJvbGxlcjogTmF0aXZlQWJvcnRDb250cm9sbGVyLAogICAgICAgICAgX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTAogICAgICAgIH0pKSB7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICBmZXRjaDogZmV0Y2gyLAogICAgICAgICAgICBSZXF1ZXN0CiAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgICB2YXIgUmVxdWVzdCA9IE5hdGl2ZVJlcXVlc3Q7CiAgICAgICAgaWYgKFJlcXVlc3QgJiYgIVJlcXVlc3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KCJzaWduYWwiKSB8fCBfX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMKSB7CiAgICAgICAgICBSZXF1ZXN0ID0gZnVuY3Rpb24gUmVxdWVzdDIoaW5wdXQsIGluaXQyKSB7CiAgICAgICAgICAgIHZhciBzaWduYWw7CiAgICAgICAgICAgIGlmIChpbml0MiAmJiBpbml0Mi5zaWduYWwpIHsKICAgICAgICAgICAgICBzaWduYWwgPSBpbml0Mi5zaWduYWw7CiAgICAgICAgICAgICAgZGVsZXRlIGluaXQyLnNpZ25hbDsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBOYXRpdmVSZXF1ZXN0KGlucHV0LCBpbml0Mik7CiAgICAgICAgICAgIGlmIChzaWduYWwpIHsKICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWVzdCwgInNpZ25hbCIsIHsKICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSwKICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLAogICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgICAgICAgICAgICAgdmFsdWU6IHNpZ25hbAogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0OwogICAgICAgICAgfTsKICAgICAgICAgIFJlcXVlc3QucHJvdG90eXBlID0gTmF0aXZlUmVxdWVzdC5wcm90b3R5cGU7CiAgICAgICAgfQogICAgICAgIHZhciByZWFsRmV0Y2ggPSBmZXRjaDI7CiAgICAgICAgdmFyIGFib3J0YWJsZUZldGNoID0gZnVuY3Rpb24gYWJvcnRhYmxlRmV0Y2gyKGlucHV0LCBpbml0MikgewogICAgICAgICAgdmFyIHNpZ25hbCA9IFJlcXVlc3QgJiYgUmVxdWVzdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihpbnB1dCkgPyBpbnB1dC5zaWduYWwgOiBpbml0MiA/IGluaXQyLnNpZ25hbCA6IHZvaWQgMDsKICAgICAgICAgIGlmIChzaWduYWwpIHsKICAgICAgICAgICAgdmFyIGFib3J0RXJyb3I7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgYWJvcnRFcnJvciA9IG5ldyBET01FeGNlcHRpb24oIkFib3J0ZWQiLCAiQWJvcnRFcnJvciIpOwogICAgICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgICAgICBhYm9ydEVycm9yID0gbmV3IEVycm9yKCJBYm9ydGVkIik7CiAgICAgICAgICAgICAgYWJvcnRFcnJvci5uYW1lID0gIkFib3J0RXJyb3IiOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgewogICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChhYm9ydEVycm9yKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgY2FuY2VsbGF0aW9uID0gbmV3IFByb21pc2UoZnVuY3Rpb24oXywgcmVqZWN0KSB7CiAgICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoImFib3J0IiwgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGFib3J0RXJyb3IpOwogICAgICAgICAgICAgIH0sIHsKICAgICAgICAgICAgICAgIG9uY2U6IHRydWUKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIGlmIChpbml0MiAmJiBpbml0Mi5zaWduYWwpIHsKICAgICAgICAgICAgICBkZWxldGUgaW5pdDIuc2lnbmFsOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW2NhbmNlbGxhdGlvbiwgcmVhbEZldGNoKGlucHV0LCBpbml0MildKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiByZWFsRmV0Y2goaW5wdXQsIGluaXQyKTsKICAgICAgICB9OwogICAgICAgIHJldHVybiB7CiAgICAgICAgICBmZXRjaDogYWJvcnRhYmxlRmV0Y2gsCiAgICAgICAgICBSZXF1ZXN0CiAgICAgICAgfTsKICAgICAgfQogICAgICBleHBvcnRzLkFib3J0Q29udHJvbGxlciA9IEFib3J0Q29udHJvbGxlcjsKICAgICAgZXhwb3J0cy5BYm9ydFNpZ25hbCA9IEFib3J0U2lnbmFsOwogICAgICBleHBvcnRzLmFib3J0YWJsZUZldGNoID0gYWJvcnRhYmxlRmV0Y2hEZWNvcmF0b3I7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9kaXN0L2Fib3J0Y29udHJvbGxlci1wb255ZmlsbC5qcwogIHZhciByZXF1aXJlX2Fib3J0Y29udHJvbGxlcl9wb255ZmlsbCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9kaXN0L2Fib3J0Y29udHJvbGxlci1wb255ZmlsbC5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZXhwb3J0cy5BYm9ydFNpZ25hbCA9IGV4cG9ydHMuQWJvcnRDb250cm9sbGVyID0gdm9pZCAwOwogICAgICB2YXIgX2Nqc1BvbnlmaWxsID0gcmVxdWlyZV9janNfcG9ueWZpbGwoKTsKICAgICAgdmFyIGdldEdsb2JhbCA9IGZ1bmN0aW9uIGdldEdsb2JhbDIoKSB7CiAgICAgICAgaWYgKHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIikgewogICAgICAgICAgcmV0dXJuIHNlbGY7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAidW5kZWZpbmVkIikgewogICAgICAgICAgcmV0dXJuIHdpbmRvdzsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgICByZXR1cm4gZ2xvYmFsOwogICAgICAgIH0KICAgICAgICB0aHJvdyBuZXcgRXJyb3IoInVuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdCIpOwogICAgICB9OwogICAgICB2YXIgQWJvcnRDb250cm9sbGVyID0gdHlwZW9mIGdldEdsb2JhbCgpLkFib3J0Q29udHJvbGxlciA9PT0gInVuZGVmaW5lZCIgPyBfY2pzUG9ueWZpbGwuQWJvcnRDb250cm9sbGVyIDogZ2V0R2xvYmFsKCkuQWJvcnRDb250cm9sbGVyOwogICAgICBleHBvcnRzLkFib3J0Q29udHJvbGxlciA9IEFib3J0Q29udHJvbGxlcjsKICAgICAgdmFyIEFib3J0U2lnbmFsID0gdHlwZW9mIGdldEdsb2JhbCgpLkFib3J0Q29udHJvbGxlciA9PT0gInVuZGVmaW5lZCIgPyBfY2pzUG9ueWZpbGwuQWJvcnRTaWduYWwgOiBnZXRHbG9iYWwoKS5BYm9ydFNpZ25hbDsKICAgICAgZXhwb3J0cy5BYm9ydFNpZ25hbCA9IEFib3J0U2lnbmFsOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZGlzdC9BZ2dyZWdhdGVBYm9ydENvbnRyb2xsZXIuanMKICB2YXIgcmVxdWlyZV9BZ2dyZWdhdGVBYm9ydENvbnRyb2xsZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZGlzdC9BZ2dyZWdhdGVBYm9ydENvbnRyb2xsZXIuanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZV9pbnRlcm9wUmVxdWlyZURlZmF1bHQyKCk7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDsKICAgICAgdmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfY3JlYXRlQ2xhc3MyKCkpOwogICAgICB2YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9kZWZpbmVQcm9wZXJ0eTIoKSk7CiAgICAgIHZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2NsYXNzQ2FsbENoZWNrMigpKTsKICAgICAgdmFyIF9hYm9ydGNvbnRyb2xsZXJQb255ZmlsbCA9IHJlcXVpcmVfYWJvcnRjb250cm9sbGVyX3BvbnlmaWxsKCk7CiAgICAgIHZhciBOdWxsU2lnbmFsID0gZnVuY3Rpb24gTnVsbFNpZ25hbDIoKSB7CiAgICAgICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgTnVsbFNpZ25hbDIpOwogICAgICB9OwogICAgICB2YXIgQWdncmVnYXRlQWJvcnRDb250cm9sbGVyID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkgewogICAgICAgIGZ1bmN0aW9uIEFnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlcjIoKSB7CiAgICAgICAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBBZ2dyZWdhdGVBYm9ydENvbnRyb2xsZXIyKTsKICAgICAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsICJzaWduYWxzIiwgbmV3IFNldCgpKTsKICAgICAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsICJhYm9ydENvbnRyb2xsZXIiLCBuZXcgX2Fib3J0Y29udHJvbGxlclBvbnlmaWxsLkFib3J0Q29udHJvbGxlcigpKTsKICAgICAgICB9CiAgICAgICAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoQWdncmVnYXRlQWJvcnRDb250cm9sbGVyMiwgW3sKICAgICAgICAgIGtleTogImFkZFNpZ25hbCIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkU2lnbmFsKCkgewogICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzOwogICAgICAgICAgICB2YXIgc2lnbmFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiBuZXcgTnVsbFNpZ25hbCgpOwogICAgICAgICAgICBpZiAodGhpcy5zaWduYWwuYWJvcnRlZCkgewogICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiY2Fubm90IGFkZCBhIHNpZ25hbCwgYWxyZWFkeSBhYm9ydGVkISIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuc2lnbmFscy5hZGQoc2lnbmFsKTsKICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7CiAgICAgICAgICAgICAgdGhpcy5oYW5kbGVBYm9ydGVkKHNpZ25hbCk7CiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoImFib3J0IiwgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVBYm9ydGVkKHNpZ25hbCk7CiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LCB7IGtleTogImhhbmRsZUFib3J0ZWQiLCB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQWJvcnRlZChzaWduYWwpIHsKICAgICAgICAgIHRoaXMuc2lnbmFscy5kZWxldGUoc2lnbmFsKTsKICAgICAgICAgIGlmICh0aGlzLnNpZ25hbHMuc2l6ZSA9PT0gMCkgewogICAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlci5hYm9ydCgpOwogICAgICAgICAgfQogICAgICAgIH0gfSwgeyBrZXk6ICJhYm9ydCIsIHZhbHVlOiBmdW5jdGlvbiBhYm9ydCgpIHsKICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KCk7CiAgICAgICAgfSB9LCB7IGtleTogInNpZ25hbCIsIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgcmV0dXJuIHRoaXMuYWJvcnRDb250cm9sbGVyLnNpZ25hbDsKICAgICAgICB9IH1dKTsKICAgICAgICByZXR1cm4gQWdncmVnYXRlQWJvcnRDb250cm9sbGVyMjsKICAgICAgfSgpOwogICAgICBleHBvcnRzLmRlZmF1bHQgPSBBZ2dyZWdhdGVBYm9ydENvbnRyb2xsZXI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9kaXN0L0FnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyLmpzCiAgdmFyIHJlcXVpcmVfQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZGlzdC9BZ2dyZWdhdGVTdGF0dXNSZXBvcnRlci5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlX2ludGVyb3BSZXF1aXJlRGVmYXVsdDIoKTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwOwogICAgICB2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9jbGFzc0NhbGxDaGVjazIoKSk7CiAgICAgIHZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2NyZWF0ZUNsYXNzMigpKTsKICAgICAgdmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfZGVmaW5lUHJvcGVydHkyKCkpOwogICAgICB2YXIgQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXIgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7CiAgICAgICAgZnVuY3Rpb24gQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXIyKCkgewogICAgICAgICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXIyKTsKICAgICAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsICJjYWxsYmFja3MiLCBuZXcgU2V0KCkpOwogICAgICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgImN1cnJlbnRNZXNzYWdlIiwgdm9pZCAwKTsKICAgICAgICB9CiAgICAgICAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXIyLCBbeyBrZXk6ICJhZGRDYWxsYmFjayIsIHZhbHVlOiBmdW5jdGlvbiBhZGRDYWxsYmFjaygpIHsKICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDogZnVuY3Rpb24oKSB7CiAgICAgICAgICB9OwogICAgICAgICAgdGhpcy5jYWxsYmFja3MuYWRkKGNhbGxiYWNrKTsKICAgICAgICAgIGNhbGxiYWNrKHRoaXMuY3VycmVudE1lc3NhZ2UpOwogICAgICAgIH0gfSwgeyBrZXk6ICJjYWxsYmFjayIsIHZhbHVlOiBmdW5jdGlvbiBjYWxsYmFjayhtZXNzYWdlKSB7CiAgICAgICAgICB0aGlzLmN1cnJlbnRNZXNzYWdlID0gbWVzc2FnZTsKICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24oZWx0KSB7CiAgICAgICAgICAgIGVsdChtZXNzYWdlKTsKICAgICAgICAgIH0pOwogICAgICAgIH0gfV0pOwogICAgICAgIHJldHVybiBBZ2dyZWdhdGVTdGF0dXNSZXBvcnRlcjI7CiAgICAgIH0oKTsKICAgICAgZXhwb3J0cy5kZWZhdWx0ID0gQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9kaXN0L0Fib3J0YWJsZVByb21pc2VDYWNoZS5qcwogIHZhciByZXF1aXJlX0Fib3J0YWJsZVByb21pc2VDYWNoZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9kaXN0L0Fib3J0YWJsZVByb21pc2VDYWNoZS5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlX2ludGVyb3BSZXF1aXJlRGVmYXVsdDIoKTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwOwogICAgICB2YXIgX3R5cGVvZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfdHlwZW9mMigpKTsKICAgICAgdmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfY2xhc3NDYWxsQ2hlY2syKCkpOwogICAgICB2YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9jcmVhdGVDbGFzczIoKSk7CiAgICAgIHZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2RlZmluZVByb3BlcnR5MigpKTsKICAgICAgdmFyIF9hYm9ydGNvbnRyb2xsZXJQb255ZmlsbCA9IHJlcXVpcmVfYWJvcnRjb250cm9sbGVyX3BvbnlmaWxsKCk7CiAgICAgIHZhciBfQWdncmVnYXRlQWJvcnRDb250cm9sbGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX0FnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlcigpKTsKICAgICAgdmFyIF9BZ2dyZWdhdGVTdGF0dXNSZXBvcnRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9BZ2dyZWdhdGVTdGF0dXNSZXBvcnRlcigpKTsKICAgICAgdmFyIEFib3J0YWJsZVByb21pc2VDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHsKICAgICAgICBmdW5jdGlvbiBBYm9ydGFibGVQcm9taXNlQ2FjaGUyKF9yZWYpIHsKICAgICAgICAgIHZhciBmaWxsID0gX3JlZi5maWxsLCBjYWNoZSA9IF9yZWYuY2FjaGU7CiAgICAgICAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBBYm9ydGFibGVQcm9taXNlQ2FjaGUyKTsKICAgICAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsICJjYWNoZSIsIHZvaWQgMCk7CiAgICAgICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCAiZmlsbENhbGxiYWNrIiwgdm9pZCAwKTsKICAgICAgICAgIGlmICh0eXBlb2YgZmlsbCAhPT0gImZ1bmN0aW9uIikKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigibXVzdCBwYXNzIGEgZmlsbCBmdW5jdGlvbiIpOwogICAgICAgICAgaWYgKCgwLCBfdHlwZW9mMi5kZWZhdWx0KShjYWNoZSkgIT09ICJvYmplY3QiKQogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJtdXN0IHBhc3MgYSBjYWNoZSBvYmplY3QiKTsKICAgICAgICAgIGlmICh0eXBlb2YgY2FjaGUuZ2V0ICE9PSAiZnVuY3Rpb24iIHx8IHR5cGVvZiBjYWNoZS5zZXQgIT09ICJmdW5jdGlvbiIgfHwgdHlwZW9mIGNhY2hlLmRlbGV0ZSAhPT0gImZ1bmN0aW9uIikKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiY2FjaGUgbXVzdCBpbXBsZW1lbnQgZ2V0KGtleSksIHNldChrZXksIHZhbCksIGFuZCBhbmQgZGVsZXRlKGtleSkiKTsKICAgICAgICAgIHRoaXMuY2FjaGUgPSBjYWNoZTsKICAgICAgICAgIHRoaXMuZmlsbENhbGxiYWNrID0gZmlsbDsKICAgICAgICB9CiAgICAgICAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoQWJvcnRhYmxlUHJvbWlzZUNhY2hlMiwgW3sga2V5OiAiZXZpY3QiLCB2YWx1ZTogZnVuY3Rpb24gZXZpY3Qoa2V5LCBlbnRyeSkgewogICAgICAgICAgaWYgKHRoaXMuY2FjaGUuZ2V0KGtleSkgPT09IGVudHJ5KQogICAgICAgICAgICB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpOwogICAgICAgIH0gfSwgeyBrZXk6ICJmaWxsIiwgdmFsdWU6IGZ1bmN0aW9uIGZpbGwoa2V5LCBkYXRhLCBzaWduYWwsIHN0YXR1c0NhbGxiYWNrKSB7CiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzOwogICAgICAgICAgdmFyIGFib3J0ZXIgPSBuZXcgX0FnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlci5kZWZhdWx0KCk7CiAgICAgICAgICB2YXIgc3RhdHVzUmVwb3J0ZXIgPSBuZXcgX0FnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyLmRlZmF1bHQoKTsKICAgICAgICAgIHN0YXR1c1JlcG9ydGVyLmFkZENhbGxiYWNrKHN0YXR1c0NhbGxiYWNrKTsKICAgICAgICAgIHZhciBuZXdFbnRyeSA9IHsKICAgICAgICAgICAgYWJvcnRlciwKICAgICAgICAgICAgcHJvbWlzZTogdGhpcy5maWxsQ2FsbGJhY2soZGF0YSwgYWJvcnRlci5zaWduYWwsIGZ1bmN0aW9uKG1lc3NhZ2UpIHsKICAgICAgICAgICAgICBzdGF0dXNSZXBvcnRlci5jYWxsYmFjayhtZXNzYWdlKTsKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIHNldHRsZWQ6IGZhbHNlLAogICAgICAgICAgICBzdGF0dXNSZXBvcnRlciwKICAgICAgICAgICAgZ2V0IGFib3J0ZWQoKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWJvcnRlci5zaWduYWwuYWJvcnRlZDsKICAgICAgICAgICAgfQogICAgICAgICAgfTsKICAgICAgICAgIG5ld0VudHJ5LmFib3J0ZXIuYWRkU2lnbmFsKHNpZ25hbCk7CiAgICAgICAgICBuZXdFbnRyeS5hYm9ydGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCJhYm9ydCIsIGZ1bmN0aW9uKCkgewogICAgICAgICAgICBpZiAoIW5ld0VudHJ5LnNldHRsZWQpIHsKICAgICAgICAgICAgICBfdGhpcy5ldmljdChrZXksIG5ld0VudHJ5KTsKICAgICAgICAgICAgfQogICAgICAgICAgfSk7CiAgICAgICAgICBuZXdFbnRyeS5wcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIG5ld0VudHJ5LnNldHRsZWQgPSB0cnVlOwogICAgICAgICAgfSwgZnVuY3Rpb24oZXhjZXB0aW9uKSB7CiAgICAgICAgICAgIG5ld0VudHJ5LnNldHRsZWQgPSB0cnVlOwogICAgICAgICAgICBfdGhpcy5ldmljdChrZXksIG5ld0VudHJ5KTsKICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGUpIHsKICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTsKICAgICAgICAgICAgdGhyb3cgZTsKICAgICAgICAgIH0pOwogICAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCBuZXdFbnRyeSk7CiAgICAgICAgfSB9LCB7CiAgICAgICAgICBrZXk6ICJoYXMiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyhrZXkpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuaGFzKGtleSk7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiZ2V0IiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoa2V5LCBkYXRhLCBzaWduYWwsIHN0YXR1c0NhbGxiYWNrKSB7CiAgICAgICAgICAgIGlmICghc2lnbmFsICYmIGRhdGEgaW5zdGFuY2VvZiBfYWJvcnRjb250cm9sbGVyUG9ueWZpbGwuQWJvcnRTaWduYWwpCiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigic2Vjb25kIGdldCBhcmd1bWVudCBhcHBlYXJzIHRvIGJlIGFuIEFib3J0U2lnbmFsLCBwZXJoYXBzIHlvdSBtZWFudCB0byBwYXNzIGBudWxsYCBmb3IgdGhlIGZpbGwgZGF0YT8iKTsKICAgICAgICAgICAgdmFyIGNhY2hlRW50cnkgPSB0aGlzLmNhY2hlLmdldChrZXkpOwogICAgICAgICAgICBpZiAoY2FjaGVFbnRyeSkgewogICAgICAgICAgICAgIGlmIChjYWNoZUVudHJ5LmFib3J0ZWQgJiYgIWNhY2hlRW50cnkuc2V0dGxlZCkgewogICAgICAgICAgICAgICAgdGhpcy5ldmljdChrZXksIGNhY2hlRW50cnkpOwogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSwgZGF0YSwgc2lnbmFsLCBzdGF0dXNDYWxsYmFjayk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChjYWNoZUVudHJ5LnNldHRsZWQpIHsKICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZUVudHJ5LnByb21pc2U7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGNhY2hlRW50cnkuYWJvcnRlci5hZGRTaWduYWwoc2lnbmFsKTsKICAgICAgICAgICAgICBjYWNoZUVudHJ5LnN0YXR1c1JlcG9ydGVyLmFkZENhbGxiYWNrKHN0YXR1c0NhbGxiYWNrKTsKICAgICAgICAgICAgICByZXR1cm4gQWJvcnRhYmxlUHJvbWlzZUNhY2hlMi5jaGVja1NpbmdsZVByb21pc2UoY2FjaGVFbnRyeS5wcm9taXNlLCBzaWduYWwpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuZmlsbChrZXksIGRhdGEsIHNpZ25hbCwgc3RhdHVzQ2FsbGJhY2spOwogICAgICAgICAgICByZXR1cm4gQWJvcnRhYmxlUHJvbWlzZUNhY2hlMi5jaGVja1NpbmdsZVByb21pc2UodGhpcy5jYWNoZS5nZXQoa2V5KS5wcm9taXNlLCBzaWduYWwpOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogImRlbGV0ZSIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZShrZXkpIHsKICAgICAgICAgICAgdmFyIGNhY2hlZEVudHJ5ID0gdGhpcy5jYWNoZS5nZXQoa2V5KTsKICAgICAgICAgICAgaWYgKGNhY2hlZEVudHJ5KSB7CiAgICAgICAgICAgICAgaWYgKCFjYWNoZWRFbnRyeS5zZXR0bGVkKQogICAgICAgICAgICAgICAgY2FjaGVkRW50cnkuYWJvcnRlci5hYm9ydCgpOwogICAgICAgICAgICAgIHRoaXMuY2FjaGUuZGVsZXRlKGtleSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LCB7IGtleTogImNsZWFyIiwgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkgewogICAgICAgICAgdmFyIGtleUl0ZXIgPSB0aGlzLmNhY2hlLmtleXMoKTsKICAgICAgICAgIHZhciBkZWxldGVDb3VudCA9IDA7CiAgICAgICAgICBmb3IgKHZhciByZXN1bHQgPSBrZXlJdGVyLm5leHQoKTsgIXJlc3VsdC5kb25lOyByZXN1bHQgPSBrZXlJdGVyLm5leHQoKSkgewogICAgICAgICAgICB0aGlzLmRlbGV0ZShyZXN1bHQudmFsdWUpOwogICAgICAgICAgICBkZWxldGVDb3VudCArPSAxOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGRlbGV0ZUNvdW50OwogICAgICAgIH0gfV0sIFt7IGtleTogImlzQWJvcnRFeGNlcHRpb24iLCB2YWx1ZTogZnVuY3Rpb24gaXNBYm9ydEV4Y2VwdGlvbihleGNlcHRpb24pIHsKICAgICAgICAgIHJldHVybiBleGNlcHRpb24ubmFtZSA9PT0gIkFib3J0RXJyb3IiIHx8IGV4Y2VwdGlvbi5jb2RlID09PSAiRVJSX0FCT1JURUQiIHx8IGV4Y2VwdGlvbi5tZXNzYWdlID09PSAiQWJvcnRFcnJvcjogYWJvcnRlZCIgfHwgZXhjZXB0aW9uLm1lc3NhZ2UgPT09ICJFcnJvcjogYWJvcnRlZCI7CiAgICAgICAgfSB9LCB7IGtleTogImNoZWNrU2luZ2xlUHJvbWlzZSIsIHZhbHVlOiBmdW5jdGlvbiBjaGVja1NpbmdsZVByb21pc2UocHJvbWlzZSwgc2lnbmFsKSB7CiAgICAgICAgICBmdW5jdGlvbiBjaGVja0ZvclNpbmdsZUFib3J0KCkgewogICAgICAgICAgICBpZiAoc2lnbmFsICYmIHNpZ25hbC5hYm9ydGVkKQogICAgICAgICAgICAgIHRocm93IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCJhYm9ydGVkIiksIHsgY29kZTogIkVSUl9BQk9SVEVEIiB9KTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7CiAgICAgICAgICAgIGNoZWNrRm9yU2luZ2xlQWJvcnQoKTsKICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7CiAgICAgICAgICAgIGNoZWNrRm9yU2luZ2xlQWJvcnQoKTsKICAgICAgICAgICAgdGhyb3cgZXJyb3I7CiAgICAgICAgICB9KTsKICAgICAgICB9IH1dKTsKICAgICAgICByZXR1cm4gQWJvcnRhYmxlUHJvbWlzZUNhY2hlMjsKICAgICAgfSgpOwogICAgICBleHBvcnRzLmRlZmF1bHQgPSBBYm9ydGFibGVQcm9taXNlQ2FjaGU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9kaXN0L2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfZGlzdCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9kaXN0L2luZGV4LmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmVfaW50ZXJvcFJlcXVpcmVEZWZhdWx0MigpOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICBleHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7CiAgICAgIHZhciBfQWJvcnRhYmxlUHJvbWlzZUNhY2hlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX0Fib3J0YWJsZVByb21pc2VDYWNoZSgpKTsKICAgICAgdmFyIF9kZWZhdWx0ID0gX0Fib3J0YWJsZVByb21pc2VDYWNoZS5kZWZhdWx0OwogICAgICBleHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL2JhbS9ub2RlX21vZHVsZXMvcXVpY2stbHJ1L2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfcXVpY2tfbHJ1ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BnbW9kL2JhbS9ub2RlX21vZHVsZXMvcXVpY2stbHJ1L2luZGV4LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBRdWlja0xSVTIgPSBjbGFzcyB7CiAgICAgICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7CiAgICAgICAgICBpZiAoIShvcHRpb25zLm1heFNpemUgJiYgb3B0aW9ucy5tYXhTaXplID4gMCkpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiYG1heFNpemVgIG11c3QgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDAiKTsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXMubWF4U2l6ZSA9IG9wdGlvbnMubWF4U2l6ZTsKICAgICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7CiAgICAgICAgICB0aGlzLm9sZENhY2hlID0gbmV3IE1hcCgpOwogICAgICAgICAgdGhpcy5fc2l6ZSA9IDA7CiAgICAgICAgfQogICAgICAgIF9zZXQoa2V5LCB2YWx1ZSkgewogICAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCB2YWx1ZSk7CiAgICAgICAgICB0aGlzLl9zaXplKys7CiAgICAgICAgICBpZiAodGhpcy5fc2l6ZSA+PSB0aGlzLm1heFNpemUpIHsKICAgICAgICAgICAgdGhpcy5fc2l6ZSA9IDA7CiAgICAgICAgICAgIHRoaXMub2xkQ2FjaGUgPSB0aGlzLmNhY2hlOwogICAgICAgICAgICB0aGlzLmNhY2hlID0gbmV3IE1hcCgpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBnZXQoa2V5KSB7CiAgICAgICAgICBpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5nZXQoa2V5KTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0aGlzLm9sZENhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5vbGRDYWNoZS5nZXQoa2V5KTsKICAgICAgICAgICAgdGhpcy5fc2V0KGtleSwgdmFsdWUpOwogICAgICAgICAgICByZXR1cm4gdmFsdWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHNldChrZXksIHZhbHVlKSB7CiAgICAgICAgICBpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIHZhbHVlKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRoaXMuX3NldChrZXksIHZhbHVlKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIH0KICAgICAgICBoYXMoa2V5KSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5oYXMoa2V5KSB8fCB0aGlzLm9sZENhY2hlLmhhcyhrZXkpOwogICAgICAgIH0KICAgICAgICBwZWVrKGtleSkgewogICAgICAgICAgaWYgKHRoaXMuY2FjaGUuaGFzKGtleSkpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGtleSk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodGhpcy5vbGRDYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5vbGRDYWNoZS5nZXQoa2V5KTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZGVsZXRlKGtleSkgewogICAgICAgICAgY29uc3QgZGVsZXRlZCA9IHRoaXMuY2FjaGUuZGVsZXRlKGtleSk7CiAgICAgICAgICBpZiAoZGVsZXRlZCkgewogICAgICAgICAgICB0aGlzLl9zaXplLS07CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdGhpcy5vbGRDYWNoZS5kZWxldGUoa2V5KSB8fCBkZWxldGVkOwogICAgICAgIH0KICAgICAgICBjbGVhcigpIHsKICAgICAgICAgIHRoaXMuY2FjaGUuY2xlYXIoKTsKICAgICAgICAgIHRoaXMub2xkQ2FjaGUuY2xlYXIoKTsKICAgICAgICAgIHRoaXMuX3NpemUgPSAwOwogICAgICAgIH0KICAgICAgICAqa2V5cygpIHsKICAgICAgICAgIGZvciAoY29uc3QgW2tleV0gb2YgdGhpcykgewogICAgICAgICAgICB5aWVsZCBrZXk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgICp2YWx1ZXMoKSB7CiAgICAgICAgICBmb3IgKGNvbnN0IFssIHZhbHVlXSBvZiB0aGlzKSB7CiAgICAgICAgICAgIHlpZWxkIHZhbHVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7CiAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5jYWNoZSkgewogICAgICAgICAgICB5aWVsZCBpdGVtOwogICAgICAgICAgfQogICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMub2xkQ2FjaGUpIHsKICAgICAgICAgICAgY29uc3QgW2tleV0gPSBpdGVtOwogICAgICAgICAgICBpZiAoIXRoaXMuY2FjaGUuaGFzKGtleSkpIHsKICAgICAgICAgICAgICB5aWVsZCBpdGVtOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGdldCBzaXplKCkgewogICAgICAgICAgbGV0IG9sZENhY2hlU2l6ZSA9IDA7CiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLm9sZENhY2hlLmtleXMoKSkgewogICAgICAgICAgICBpZiAoIXRoaXMuY2FjaGUuaGFzKGtleSkpIHsKICAgICAgICAgICAgICBvbGRDYWNoZVNpemUrKzsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRoaXMuX3NpemUgKyBvbGRDYWNoZVNpemU7CiAgICAgICAgfQogICAgICB9OwogICAgICBtb2R1bGUuZXhwb3J0cyA9IFF1aWNrTFJVMjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL2JhbS9kaXN0L2luZGV4RmlsZS5qcwogIHZhciByZXF1aXJlX2luZGV4RmlsZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AZ21vZC9iYW0vZGlzdC9pbmRleEZpbGUuanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoKTsKICAgICAgdmFyIF9PYmplY3QkZGVmaW5lUHJvcGVydHkyID0gcmVxdWlyZV9kZWZpbmVfcHJvcGVydHkzKCk7CiAgICAgIF9PYmplY3QkZGVmaW5lUHJvcGVydHkyKGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgewogICAgICAgIHZhbHVlOiB0cnVlCiAgICAgIH0pOwogICAgICBleHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7CiAgICAgIHZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2RlZmluZV9wcm9wZXJ0eTMoKSk7CiAgICAgIHZhciBfZGVmaW5lUHJvcGVydGllcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9kZWZpbmVfcHJvcGVydGllczMoKSk7CiAgICAgIHZhciBfZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9nZXRfb3duX3Byb3BlcnR5X2Rlc2NyaXB0b3JzMygpKTsKICAgICAgdmFyIF9mb3JFYWNoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2Zvcl9lYWNoNCgpKTsKICAgICAgdmFyIF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfZ2V0X293bl9wcm9wZXJ0eV9kZXNjcmlwdG9yMygpKTsKICAgICAgdmFyIF9maWx0ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfZmlsdGVyNCgpKTsKICAgICAgdmFyIF9nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfZ2V0X293bl9wcm9wZXJ0eV9zeW1ib2xzMygpKTsKICAgICAgdmFyIF9rZXlzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2tleXMzKCkpOwogICAgICB2YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3JlZ2VuZXJhdG9yKCkpOwogICAgICB2YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2FzeW5jVG9HZW5lcmF0b3IoKSk7CiAgICAgIHZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2NsYXNzQ2FsbENoZWNrKCkpOwogICAgICB2YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9jcmVhdGVDbGFzcygpKTsKICAgICAgdmFyIF9kZWZpbmVQcm9wZXJ0eTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfZGVmaW5lUHJvcGVydHkoKSk7CiAgICAgIHZhciBfYWJvcnRhYmxlUHJvbWlzZUNhY2hlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2Rpc3QoKSk7CiAgICAgIHZhciBfcXVpY2tMcnUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfcXVpY2tfbHJ1KCkpOwogICAgICBmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsKICAgICAgICB2YXIga2V5cyA9ICgwLCBfa2V5cy5kZWZhdWx0KShvYmplY3QpOwogICAgICAgIGlmIChfZ2V0T3duUHJvcGVydHlTeW1ib2xzLmRlZmF1bHQpIHsKICAgICAgICAgIHZhciBzeW1ib2xzID0gKDAsIF9nZXRPd25Qcm9wZXJ0eVN5bWJvbHMuZGVmYXVsdCkob2JqZWN0KTsKICAgICAgICAgIGlmIChlbnVtZXJhYmxlT25seSkKICAgICAgICAgICAgc3ltYm9scyA9ICgwLCBfZmlsdGVyLmRlZmF1bHQpKHN5bWJvbHMpLmNhbGwoc3ltYm9scywgZnVuY3Rpb24oc3ltKSB7CiAgICAgICAgICAgICAgcmV0dXJuICgwLCBfZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmRlZmF1bHQpKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOwogICAgICAgICAgICB9KTsKICAgICAgICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGtleXM7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsKICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgewogICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307CiAgICAgICAgICBpZiAoaSAlIDIpIHsKICAgICAgICAgICAgdmFyIF9jb250ZXh0MzsKICAgICAgICAgICAgKDAsIF9mb3JFYWNoLmRlZmF1bHQpKF9jb250ZXh0MyA9IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpKS5jYWxsKF9jb250ZXh0MywgZnVuY3Rpb24oa2V5KSB7CiAgICAgICAgICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTMuZGVmYXVsdCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9IGVsc2UgaWYgKF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzLmRlZmF1bHQpIHsKICAgICAgICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0aWVzLmRlZmF1bHQpKHRhcmdldCwgKDAsIF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzLmRlZmF1bHQpKHNvdXJjZSkpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdmFyIF9jb250ZXh0NDsKICAgICAgICAgICAgKDAsIF9mb3JFYWNoLmRlZmF1bHQpKF9jb250ZXh0NCA9IG93bktleXMoT2JqZWN0KHNvdXJjZSkpKS5jYWxsKF9jb250ZXh0NCwgZnVuY3Rpb24oa2V5KSB7CiAgICAgICAgICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBrZXksICgwLCBfZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmRlZmF1bHQpKHNvdXJjZSwga2V5KSk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gdGFyZ2V0OwogICAgICB9CiAgICAgIHZhciBJbmRleEZpbGUgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7CiAgICAgICAgZnVuY3Rpb24gSW5kZXhGaWxlMihfcmVmKSB7CiAgICAgICAgICB2YXIgZmlsZWhhbmRsZSA9IF9yZWYuZmlsZWhhbmRsZSwgX3JlZiRyZW5hbWVSZWZTZXEgPSBfcmVmLnJlbmFtZVJlZlNlcSwgcmVuYW1lUmVmU2VxID0gX3JlZiRyZW5hbWVSZWZTZXEgPT09IHZvaWQgMCA/IGZ1bmN0aW9uKG4pIHsKICAgICAgICAgICAgcmV0dXJuIG47CiAgICAgICAgICB9IDogX3JlZiRyZW5hbWVSZWZTZXE7CiAgICAgICAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBJbmRleEZpbGUyKTsKICAgICAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkzLmRlZmF1bHQpKHRoaXMsICJmaWxlaGFuZGxlIiwgdm9pZCAwKTsKICAgICAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkzLmRlZmF1bHQpKHRoaXMsICJyZW5hbWVSZWZTZXEiLCB2b2lkIDApOwogICAgICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTMuZGVmYXVsdCkodGhpcywgIl9wYXJzZUNhY2hlIiwgdm9pZCAwKTsKICAgICAgICAgIHRoaXMuZmlsZWhhbmRsZSA9IGZpbGVoYW5kbGU7CiAgICAgICAgICB0aGlzLnJlbmFtZVJlZlNlcSA9IHJlbmFtZVJlZlNlcTsKICAgICAgICB9CiAgICAgICAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoSW5kZXhGaWxlMiwgW3sKICAgICAgICAgIGtleTogIl9maW5kRmlyc3REYXRhIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZEZpcnN0RGF0YShkYXRhLCB2aXJ0dWFsT2Zmc2V0KSB7CiAgICAgICAgICAgIHZhciBjdXJyZW50RmRsID0gZGF0YS5maXJzdERhdGFMaW5lOwogICAgICAgICAgICBpZiAoY3VycmVudEZkbCkgewogICAgICAgICAgICAgIGRhdGEuZmlyc3REYXRhTGluZSA9IGN1cnJlbnRGZGwuY29tcGFyZVRvKHZpcnR1YWxPZmZzZXQpID4gMCA/IHZpcnR1YWxPZmZzZXQgOiBjdXJyZW50RmRsOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGRhdGEuZmlyc3REYXRhTGluZSA9IHZpcnR1YWxPZmZzZXQ7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJwYXJzZSIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciBfcGFyc2UyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KSgvKiBAX19QVVJFX18gKi8gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkgewogICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7CiAgICAgICAgICAgICAgdmFyIG9wdHMsIF9hcmdzID0gYXJndW1lbnRzOwogICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7CiAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgICAgb3B0cyA9IF9hcmdzLmxlbmd0aCA+IDAgJiYgX2FyZ3NbMF0gIT09IHZvaWQgMCA/IF9hcmdzWzBdIDoge307CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3BhcnNlQ2FjaGUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VDYWNoZSA9IG5ldyBfYWJvcnRhYmxlUHJvbWlzZUNhY2hlLmRlZmF1bHQoewogICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiBuZXcgX3F1aWNrTHJ1LmRlZmF1bHQoewogICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4U2l6ZTogMQogICAgICAgICAgICAgICAgICAgICAgICAgIH0pLAogICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGZ1bmN0aW9uIGZpbGwob3B0czIsIHNpZ25hbCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9wYXJzZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdHMyKSwge30sIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoInJldHVybiIsIHRoaXMuX3BhcnNlQ2FjaGUuZ2V0KCJpbmRleCIsIG9wdHMsIG9wdHMuc2lnbmFsKSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOgogICAgICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7CiAgICAgICAgICAgIH0pKTsKICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2UoKSB7CiAgICAgICAgICAgICAgcmV0dXJuIF9wYXJzZTIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gcGFyc2U7CiAgICAgICAgICB9KCkKICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJoYXNSZWZTZXEiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgX2hhc1JlZlNlcSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoc2VxSWQpIHsKICAgICAgICAgICAgICB2YXIgb3B0cywgX2FyZ3MyID0gYXJndW1lbnRzOwogICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHsKICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkgewogICAgICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgICAgIG9wdHMgPSBfYXJnczIubGVuZ3RoID4gMSAmJiBfYXJnczJbMV0gIT09IHZvaWQgMCA/IF9hcmdzMlsxXSA6IHt9OwogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzOwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2Uob3B0cyk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOgogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLnQxID0gc2VxSWQ7CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDIuc2VudC5pbmRpY2VzW19jb250ZXh0Mi50MV07CiAgICAgICAgICAgICAgICAgICAgICBpZiAoX2NvbnRleHQyLnQwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNzsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIudDAgPSB7fTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDc6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdCgicmV0dXJuIiwgISFfY29udGV4dDIudDAuYmluSW5kZXgpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgODoKICAgICAgICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7CiAgICAgICAgICAgIH0pKTsKICAgICAgICAgICAgZnVuY3Rpb24gaGFzUmVmU2VxKF94KSB7CiAgICAgICAgICAgICAgcmV0dXJuIF9oYXNSZWZTZXEuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gaGFzUmVmU2VxOwogICAgICAgICAgfSgpCiAgICAgICAgfV0pOwogICAgICAgIHJldHVybiBJbmRleEZpbGUyOwogICAgICB9KCk7CiAgICAgIGV4cG9ydHMuZGVmYXVsdCA9IEluZGV4RmlsZTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvYXJyYXktc29ydC5qcwogIHZhciByZXF1aXJlX2FycmF5X3NvcnQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9hcnJheS1zb3J0LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yOwogICAgICB2YXIgbWVyZ2VTb3J0ID0gZnVuY3Rpb24oYXJyYXksIGNvbXBhcmVmbikgewogICAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7CiAgICAgICAgdmFyIG1pZGRsZSA9IGZsb29yKGxlbmd0aCAvIDIpOwogICAgICAgIHJldHVybiBsZW5ndGggPCA4ID8gaW5zZXJ0aW9uU29ydChhcnJheSwgY29tcGFyZWZuKSA6IG1lcmdlKG1lcmdlU29ydChhcnJheS5zbGljZSgwLCBtaWRkbGUpLCBjb21wYXJlZm4pLCBtZXJnZVNvcnQoYXJyYXkuc2xpY2UobWlkZGxlKSwgY29tcGFyZWZuKSwgY29tcGFyZWZuKTsKICAgICAgfTsKICAgICAgdmFyIGluc2VydGlvblNvcnQgPSBmdW5jdGlvbihhcnJheSwgY29tcGFyZWZuKSB7CiAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsKICAgICAgICB2YXIgaSA9IDE7CiAgICAgICAgdmFyIGVsZW1lbnQsIGo7CiAgICAgICAgd2hpbGUgKGkgPCBsZW5ndGgpIHsKICAgICAgICAgIGogPSBpOwogICAgICAgICAgZWxlbWVudCA9IGFycmF5W2ldOwogICAgICAgICAgd2hpbGUgKGogJiYgY29tcGFyZWZuKGFycmF5W2ogLSAxXSwgZWxlbWVudCkgPiAwKSB7CiAgICAgICAgICAgIGFycmF5W2pdID0gYXJyYXlbLS1qXTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChqICE9PSBpKyspCiAgICAgICAgICAgIGFycmF5W2pdID0gZWxlbWVudDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGFycmF5OwogICAgICB9OwogICAgICB2YXIgbWVyZ2UgPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgY29tcGFyZWZuKSB7CiAgICAgICAgdmFyIGxsZW5ndGggPSBsZWZ0Lmxlbmd0aDsKICAgICAgICB2YXIgcmxlbmd0aCA9IHJpZ2h0Lmxlbmd0aDsKICAgICAgICB2YXIgbGluZGV4ID0gMDsKICAgICAgICB2YXIgcmluZGV4ID0gMDsKICAgICAgICB2YXIgcmVzdWx0ID0gW107CiAgICAgICAgd2hpbGUgKGxpbmRleCA8IGxsZW5ndGggfHwgcmluZGV4IDwgcmxlbmd0aCkgewogICAgICAgICAgaWYgKGxpbmRleCA8IGxsZW5ndGggJiYgcmluZGV4IDwgcmxlbmd0aCkgewogICAgICAgICAgICByZXN1bHQucHVzaChjb21wYXJlZm4obGVmdFtsaW5kZXhdLCByaWdodFtyaW5kZXhdKSA8PSAwID8gbGVmdFtsaW5kZXgrK10gOiByaWdodFtyaW5kZXgrK10pOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmVzdWx0LnB1c2gobGluZGV4IDwgbGxlbmd0aCA/IGxlZnRbbGluZGV4KytdIDogcmlnaHRbcmluZGV4KytdKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgfTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBtZXJnZVNvcnQ7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2VuZ2luZS1mZi12ZXJzaW9uLmpzCiAgdmFyIHJlcXVpcmVfZW5naW5lX2ZmX3ZlcnNpb24gPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9lbmdpbmUtZmYtdmVyc2lvbi5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHVzZXJBZ2VudCA9IHJlcXVpcmVfZW5naW5lX3VzZXJfYWdlbnQoKTsKICAgICAgdmFyIGZpcmVmb3ggPSB1c2VyQWdlbnQubWF0Y2goL2ZpcmVmb3hcLyhcZCspL2kpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9ICEhZmlyZWZveCAmJiArZmlyZWZveFsxXTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZW5naW5lLWlzLWllLW9yLWVkZ2UuanMKICB2YXIgcmVxdWlyZV9lbmdpbmVfaXNfaWVfb3JfZWRnZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2VuZ2luZS1pcy1pZS1vci1lZGdlLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgVUEgPSByZXF1aXJlX2VuZ2luZV91c2VyX2FnZW50KCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gL01TSUV8VHJpZGVudC8udGVzdChVQSk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2VuZ2luZS13ZWJraXQtdmVyc2lvbi5qcwogIHZhciByZXF1aXJlX2VuZ2luZV93ZWJraXRfdmVyc2lvbiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2VuZ2luZS13ZWJraXQtdmVyc2lvbi5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHVzZXJBZ2VudCA9IHJlcXVpcmVfZW5naW5lX3VzZXJfYWdlbnQoKTsKICAgICAgdmFyIHdlYmtpdCA9IHVzZXJBZ2VudC5tYXRjaCgvQXBwbGVXZWJLaXRcLyhcZCspXC4vKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSAhIXdlYmtpdCAmJiArd2Via2l0WzFdOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuYXJyYXkuc29ydC5qcwogIHZhciByZXF1aXJlX2VzX2FycmF5X3NvcnQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuYXJyYXkuc29ydC5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgJCA9IHJlcXVpcmVfZXhwb3J0KCk7CiAgICAgIHZhciBhQ2FsbGFibGUgPSByZXF1aXJlX2FfY2FsbGFibGUoKTsKICAgICAgdmFyIHRvT2JqZWN0ID0gcmVxdWlyZV90b19vYmplY3QoKTsKICAgICAgdmFyIHRvTGVuZ3RoID0gcmVxdWlyZV90b19sZW5ndGgoKTsKICAgICAgdmFyIHRvU3RyaW5nID0gcmVxdWlyZV90b19zdHJpbmcoKTsKICAgICAgdmFyIGZhaWxzID0gcmVxdWlyZV9mYWlscygpOwogICAgICB2YXIgaW50ZXJuYWxTb3J0ID0gcmVxdWlyZV9hcnJheV9zb3J0KCk7CiAgICAgIHZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gcmVxdWlyZV9hcnJheV9tZXRob2RfaXNfc3RyaWN0KCk7CiAgICAgIHZhciBGRiA9IHJlcXVpcmVfZW5naW5lX2ZmX3ZlcnNpb24oKTsKICAgICAgdmFyIElFX09SX0VER0UgPSByZXF1aXJlX2VuZ2luZV9pc19pZV9vcl9lZGdlKCk7CiAgICAgIHZhciBWOCA9IHJlcXVpcmVfZW5naW5lX3Y4X3ZlcnNpb24oKTsKICAgICAgdmFyIFdFQktJVCA9IHJlcXVpcmVfZW5naW5lX3dlYmtpdF92ZXJzaW9uKCk7CiAgICAgIHZhciB0ZXN0ID0gW107CiAgICAgIHZhciBuYXRpdmVTb3J0ID0gdGVzdC5zb3J0OwogICAgICB2YXIgRkFJTFNfT05fVU5ERUZJTkVEID0gZmFpbHMoZnVuY3Rpb24oKSB7CiAgICAgICAgdGVzdC5zb3J0KHZvaWQgMCk7CiAgICAgIH0pOwogICAgICB2YXIgRkFJTFNfT05fTlVMTCA9IGZhaWxzKGZ1bmN0aW9uKCkgewogICAgICAgIHRlc3Quc29ydChudWxsKTsKICAgICAgfSk7CiAgICAgIHZhciBTVFJJQ1RfTUVUSE9EID0gYXJyYXlNZXRob2RJc1N0cmljdCgic29ydCIpOwogICAgICB2YXIgU1RBQkxFX1NPUlQgPSAhZmFpbHMoZnVuY3Rpb24oKSB7CiAgICAgICAgaWYgKFY4KQogICAgICAgICAgcmV0dXJuIFY4IDwgNzA7CiAgICAgICAgaWYgKEZGICYmIEZGID4gMykKICAgICAgICAgIHJldHVybjsKICAgICAgICBpZiAoSUVfT1JfRURHRSkKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIGlmIChXRUJLSVQpCiAgICAgICAgICByZXR1cm4gV0VCS0lUIDwgNjAzOwogICAgICAgIHZhciByZXN1bHQgPSAiIjsKICAgICAgICB2YXIgY29kZSwgY2hyLCB2YWx1ZSwgaW5kZXg7CiAgICAgICAgZm9yIChjb2RlID0gNjU7IGNvZGUgPCA3NjsgY29kZSsrKSB7CiAgICAgICAgICBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpOwogICAgICAgICAgc3dpdGNoIChjb2RlKSB7CiAgICAgICAgICAgIGNhc2UgNjY6CiAgICAgICAgICAgIGNhc2UgNjk6CiAgICAgICAgICAgIGNhc2UgNzA6CiAgICAgICAgICAgIGNhc2UgNzI6CiAgICAgICAgICAgICAgdmFsdWUgPSAzOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlIDY4OgogICAgICAgICAgICBjYXNlIDcxOgogICAgICAgICAgICAgIHZhbHVlID0gNDsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICB2YWx1ZSA9IDI7CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCA0NzsgaW5kZXgrKykgewogICAgICAgICAgICB0ZXN0LnB1c2goeyBrOiBjaHIgKyBpbmRleCwgdjogdmFsdWUgfSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHRlc3Quc29ydChmdW5jdGlvbihhLCBiKSB7CiAgICAgICAgICByZXR1cm4gYi52IC0gYS52OwogICAgICAgIH0pOwogICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHRlc3QubGVuZ3RoOyBpbmRleCsrKSB7CiAgICAgICAgICBjaHIgPSB0ZXN0W2luZGV4XS5rLmNoYXJBdCgwKTsKICAgICAgICAgIGlmIChyZXN1bHQuY2hhckF0KHJlc3VsdC5sZW5ndGggLSAxKSAhPT0gY2hyKQogICAgICAgICAgICByZXN1bHQgKz0gY2hyOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmVzdWx0ICE9PSAiREdCRUZIQUNJSksiOwogICAgICB9KTsKICAgICAgdmFyIEZPUkNFRCA9IEZBSUxTX09OX1VOREVGSU5FRCB8fCAhRkFJTFNfT05fTlVMTCB8fCAhU1RSSUNUX01FVEhPRCB8fCAhU1RBQkxFX1NPUlQ7CiAgICAgIHZhciBnZXRTb3J0Q29tcGFyZSA9IGZ1bmN0aW9uKGNvbXBhcmVmbikgewogICAgICAgIHJldHVybiBmdW5jdGlvbih4LCB5KSB7CiAgICAgICAgICBpZiAoeSA9PT0gdm9pZCAwKQogICAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgICBpZiAoeCA9PT0gdm9pZCAwKQogICAgICAgICAgICByZXR1cm4gMTsKICAgICAgICAgIGlmIChjb21wYXJlZm4gIT09IHZvaWQgMCkKICAgICAgICAgICAgcmV0dXJuICtjb21wYXJlZm4oeCwgeSkgfHwgMDsKICAgICAgICAgIHJldHVybiB0b1N0cmluZyh4KSA+IHRvU3RyaW5nKHkpID8gMSA6IC0xOwogICAgICAgIH07CiAgICAgIH07CiAgICAgICQoeyB0YXJnZXQ6ICJBcnJheSIsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7CiAgICAgICAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pIHsKICAgICAgICAgIGlmIChjb21wYXJlZm4gIT09IHZvaWQgMCkKICAgICAgICAgICAgYUNhbGxhYmxlKGNvbXBhcmVmbik7CiAgICAgICAgICB2YXIgYXJyYXkgPSB0b09iamVjdCh0aGlzKTsKICAgICAgICAgIGlmIChTVEFCTEVfU09SVCkKICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVmbiA9PT0gdm9pZCAwID8gbmF0aXZlU29ydC5jYWxsKGFycmF5KSA6IG5hdGl2ZVNvcnQuY2FsbChhcnJheSwgY29tcGFyZWZuKTsKICAgICAgICAgIHZhciBpdGVtcyA9IFtdOwogICAgICAgICAgdmFyIGFycmF5TGVuZ3RoID0gdG9MZW5ndGgoYXJyYXkubGVuZ3RoKTsKICAgICAgICAgIHZhciBpdGVtc0xlbmd0aCwgaW5kZXg7CiAgICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBhcnJheUxlbmd0aDsgaW5kZXgrKykgewogICAgICAgICAgICBpZiAoaW5kZXggaW4gYXJyYXkpCiAgICAgICAgICAgICAgaXRlbXMucHVzaChhcnJheVtpbmRleF0pOwogICAgICAgICAgfQogICAgICAgICAgaXRlbXMgPSBpbnRlcm5hbFNvcnQoaXRlbXMsIGdldFNvcnRDb21wYXJlKGNvbXBhcmVmbikpOwogICAgICAgICAgaXRlbXNMZW5ndGggPSBpdGVtcy5sZW5ndGg7CiAgICAgICAgICBpbmRleCA9IDA7CiAgICAgICAgICB3aGlsZSAoaW5kZXggPCBpdGVtc0xlbmd0aCkKICAgICAgICAgICAgYXJyYXlbaW5kZXhdID0gaXRlbXNbaW5kZXgrK107CiAgICAgICAgICB3aGlsZSAoaW5kZXggPCBhcnJheUxlbmd0aCkKICAgICAgICAgICAgZGVsZXRlIGFycmF5W2luZGV4KytdOwogICAgICAgICAgcmV0dXJuIGFycmF5OwogICAgICAgIH0KICAgICAgfSk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvYXJyYXkvdmlydHVhbC9zb3J0LmpzCiAgdmFyIHJlcXVpcmVfc29ydCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvYXJyYXkvdmlydHVhbC9zb3J0LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICByZXF1aXJlX2VzX2FycmF5X3NvcnQoKTsKICAgICAgdmFyIGVudHJ5VmlydHVhbCA9IHJlcXVpcmVfZW50cnlfdmlydHVhbCgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGVudHJ5VmlydHVhbCgiQXJyYXkiKS5zb3J0OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2luc3RhbmNlL3NvcnQuanMKICB2YXIgcmVxdWlyZV9zb3J0MiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvaW5zdGFuY2Uvc29ydC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHNvcnQgPSByZXF1aXJlX3NvcnQoKTsKICAgICAgdmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KSB7CiAgICAgICAgdmFyIG93biA9IGl0LnNvcnQ7CiAgICAgICAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSB8fCBpdCBpbnN0YW5jZW9mIEFycmF5ICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUuc29ydCA/IHNvcnQgOiBvd247CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL2luc3RhbmNlL3NvcnQuanMKICB2YXIgcmVxdWlyZV9zb3J0MyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL2luc3RhbmNlL3NvcnQuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBwYXJlbnQgPSByZXF1aXJlX3NvcnQyKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGFyZW50OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9pbnN0YW5jZS9zb3J0LmpzCiAgdmFyIHJlcXVpcmVfc29ydDQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9pbnN0YW5jZS9zb3J0LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVfc29ydDMoKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLm51bWJlci5taW4tc2FmZS1pbnRlZ2VyLmpzCiAgdmFyIHJlcXVpcmVfZXNfbnVtYmVyX21pbl9zYWZlX2ludGVnZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMubnVtYmVyLm1pbi1zYWZlLWludGVnZXIuanMiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciAkID0gcmVxdWlyZV9leHBvcnQoKTsKICAgICAgJCh7IHRhcmdldDogIk51bWJlciIsIHN0YXQ6IHRydWUgfSwgewogICAgICAgIE1JTl9TQUZFX0lOVEVHRVI6IC05MDA3MTk5MjU0NzQwOTkxCiAgICAgIH0pOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL251bWJlci9taW4tc2FmZS1pbnRlZ2VyLmpzCiAgdmFyIHJlcXVpcmVfbWluX3NhZmVfaW50ZWdlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvbnVtYmVyL21pbi1zYWZlLWludGVnZXIuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHJlcXVpcmVfZXNfbnVtYmVyX21pbl9zYWZlX2ludGVnZXIoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSAtOTAwNzE5OTI1NDc0MDk5MTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvbnVtYmVyL21pbi1zYWZlLWludGVnZXIuanMKICB2YXIgcmVxdWlyZV9taW5fc2FmZV9pbnRlZ2VyMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL251bWJlci9taW4tc2FmZS1pbnRlZ2VyLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgcGFyZW50ID0gcmVxdWlyZV9taW5fc2FmZV9pbnRlZ2VyKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGFyZW50OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9udW1iZXIvbWluLXNhZmUtaW50ZWdlci5qcwogIHZhciByZXF1aXJlX21pbl9zYWZlX2ludGVnZXIzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvbnVtYmVyL21pbi1zYWZlLWludGVnZXIuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZV9taW5fc2FmZV9pbnRlZ2VyMigpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMubnVtYmVyLm1heC1zYWZlLWludGVnZXIuanMKICB2YXIgcmVxdWlyZV9lc19udW1iZXJfbWF4X3NhZmVfaW50ZWdlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5udW1iZXIubWF4LXNhZmUtaW50ZWdlci5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyICQgPSByZXF1aXJlX2V4cG9ydCgpOwogICAgICAkKHsgdGFyZ2V0OiAiTnVtYmVyIiwgc3RhdDogdHJ1ZSB9LCB7CiAgICAgICAgTUFYX1NBRkVfSU5URUdFUjogOTAwNzE5OTI1NDc0MDk5MQogICAgICB9KTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9udW1iZXIvbWF4LXNhZmUtaW50ZWdlci5qcwogIHZhciByZXF1aXJlX21heF9zYWZlX2ludGVnZXIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL251bWJlci9tYXgtc2FmZS1pbnRlZ2VyLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICByZXF1aXJlX2VzX251bWJlcl9tYXhfc2FmZV9pbnRlZ2VyKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gOTAwNzE5OTI1NDc0MDk5MTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvbnVtYmVyL21heC1zYWZlLWludGVnZXIuanMKICB2YXIgcmVxdWlyZV9tYXhfc2FmZV9pbnRlZ2VyMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL251bWJlci9tYXgtc2FmZS1pbnRlZ2VyLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgcGFyZW50ID0gcmVxdWlyZV9tYXhfc2FmZV9pbnRlZ2VyKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGFyZW50OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9udW1iZXIvbWF4LXNhZmUtaW50ZWdlci5qcwogIHZhciByZXF1aXJlX21heF9zYWZlX2ludGVnZXIzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvbnVtYmVyL21heC1zYWZlLWludGVnZXIuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZV9tYXhfc2FmZV9pbnRlZ2VyMigpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvd2ViLnRpbWVycy5qcwogIHZhciByZXF1aXJlX3dlYl90aW1lcnMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvd2ViLnRpbWVycy5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyICQgPSByZXF1aXJlX2V4cG9ydCgpOwogICAgICB2YXIgZ2xvYmFsMiA9IHJlcXVpcmVfZ2xvYmFsKCk7CiAgICAgIHZhciBpc0NhbGxhYmxlID0gcmVxdWlyZV9pc19jYWxsYWJsZSgpOwogICAgICB2YXIgdXNlckFnZW50ID0gcmVxdWlyZV9lbmdpbmVfdXNlcl9hZ2VudCgpOwogICAgICB2YXIgc2xpY2UgPSBbXS5zbGljZTsKICAgICAgdmFyIE1TSUUgPSAvTVNJRSAuXC4vLnRlc3QodXNlckFnZW50KTsKICAgICAgdmFyIHdyYXAgPSBmdW5jdGlvbihzY2hlZHVsZXIpIHsKICAgICAgICByZXR1cm4gZnVuY3Rpb24oaGFuZGxlciwgdGltZW91dCkgewogICAgICAgICAgdmFyIGJvdW5kQXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyOwogICAgICAgICAgdmFyIGFyZ3MgPSBib3VuZEFyZ3MgPyBzbGljZS5jYWxsKGFyZ3VtZW50cywgMikgOiB2b2lkIDA7CiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyKGJvdW5kQXJncyA/IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAoaXNDYWxsYWJsZShoYW5kbGVyKSA/IGhhbmRsZXIgOiBGdW5jdGlvbihoYW5kbGVyKSkuYXBwbHkodGhpcywgYXJncyk7CiAgICAgICAgICB9IDogaGFuZGxlciwgdGltZW91dCk7CiAgICAgICAgfTsKICAgICAgfTsKICAgICAgJCh7IGdsb2JhbDogdHJ1ZSwgYmluZDogdHJ1ZSwgZm9yY2VkOiBNU0lFIH0sIHsKICAgICAgICBzZXRUaW1lb3V0OiB3cmFwKGdsb2JhbDIuc2V0VGltZW91dCksCiAgICAgICAgc2V0SW50ZXJ2YWw6IHdyYXAoZ2xvYmFsMi5zZXRJbnRlcnZhbCkKICAgICAgfSk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL3NldC10aW1lb3V0LmpzCiAgdmFyIHJlcXVpcmVfc2V0X3RpbWVvdXQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9zZXQtdGltZW91dC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgcmVxdWlyZV93ZWJfdGltZXJzKCk7CiAgICAgIHZhciBwYXRoID0gcmVxdWlyZV9wYXRoKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGF0aC5zZXRUaW1lb3V0OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9zZXQtdGltZW91dC5qcwogIHZhciByZXF1aXJlX3NldF90aW1lb3V0MiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL3NldC10aW1lb3V0LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVfc2V0X3RpbWVvdXQoKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvcHJvbWlzZS5qcwogIHZhciByZXF1aXJlX3Byb21pc2U1ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvcHJvbWlzZS5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlX3Byb21pc2UyKCk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC9iYW0vZGlzdC91dGlsLmpzCiAgdmFyIHJlcXVpcmVfdXRpbCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AZ21vZC9iYW0vZGlzdC91dGlsLmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmVfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KCk7CiAgICAgIHZhciBfT2JqZWN0JGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZV9kZWZpbmVfcHJvcGVydHkzKCk7CiAgICAgIF9PYmplY3QkZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgIl9fZXNNb2R1bGUiLCB7CiAgICAgICAgdmFsdWU6IHRydWUKICAgICAgfSk7CiAgICAgIGV4cG9ydHMudGltZW91dCA9IHRpbWVvdXQ7CiAgICAgIGV4cG9ydHMubG9uZ1RvTnVtYmVyID0gbG9uZ1RvTnVtYmVyOwogICAgICBleHBvcnRzLmNoZWNrQWJvcnRTaWduYWwgPSBjaGVja0Fib3J0U2lnbmFsOwogICAgICBleHBvcnRzLmFib3J0QnJlYWtQb2ludCA9IGFib3J0QnJlYWtQb2ludDsKICAgICAgZXhwb3J0cy5jYW5NZXJnZUJsb2NrcyA9IGNhbk1lcmdlQmxvY2tzOwogICAgICBleHBvcnRzLm1ha2VPcHRzID0gbWFrZU9wdHM7CiAgICAgIGV4cG9ydHMub3B0aW1pemVDaHVua3MgPSBvcHRpbWl6ZUNodW5rczsKICAgICAgdmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9yZWdlbmVyYXRvcigpKTsKICAgICAgdmFyIF9mb3JFYWNoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2Zvcl9lYWNoNCgpKTsKICAgICAgdmFyIF9zb3J0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3NvcnQ0KCkpOwogICAgICB2YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2FzeW5jVG9HZW5lcmF0b3IoKSk7CiAgICAgIHZhciBfbWluU2FmZUludGVnZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfbWluX3NhZmVfaW50ZWdlcjMoKSk7CiAgICAgIHZhciBfbWF4U2FmZUludGVnZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfbWF4X3NhZmVfaW50ZWdlcjMoKSk7CiAgICAgIHZhciBfc2V0VGltZW91dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfc2V0X3RpbWVvdXQyKCkpOwogICAgICB2YXIgX3Byb21pc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfcHJvbWlzZTUoKSk7CiAgICAgIGZ1bmN0aW9uIHRpbWVvdXQobXMpIHsKICAgICAgICByZXR1cm4gbmV3IF9wcm9taXNlLmRlZmF1bHQoZnVuY3Rpb24ocmVzb2x2ZSkgewogICAgICAgICAgcmV0dXJuICgwLCBfc2V0VGltZW91dDIuZGVmYXVsdCkocmVzb2x2ZSwgbXMpOwogICAgICAgIH0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGxvbmdUb051bWJlcihsb25nKSB7CiAgICAgICAgaWYgKGxvbmcuZ3JlYXRlclRoYW4oX21heFNhZmVJbnRlZ2VyLmRlZmF1bHQpIHx8IGxvbmcubGVzc1RoYW4oX21pblNhZmVJbnRlZ2VyLmRlZmF1bHQpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImludGVnZXIgb3ZlcmZsb3ciKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGxvbmcudG9OdW1iZXIoKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBjaGVja0Fib3J0U2lnbmFsKHNpZ25hbCkgewogICAgICAgIGlmICghc2lnbmFsKSB7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgewogICAgICAgICAgaWYgKHR5cGVvZiBET01FeGNlcHRpb24gIT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oImFib3J0ZWQiLCAiQWJvcnRFcnJvciIpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoImFib3J0ZWQiKTsKICAgICAgICAgICAgZS5jb2RlID0gIkVSUl9BQk9SVEVEIjsKICAgICAgICAgICAgdGhyb3cgZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYWJvcnRCcmVha1BvaW50KF94KSB7CiAgICAgICAgcmV0dXJuIF9hYm9ydEJyZWFrUG9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfYWJvcnRCcmVha1BvaW50KCkgewogICAgICAgIF9hYm9ydEJyZWFrUG9pbnQgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKC8qIEBfX1BVUkVfXyAqLyBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoc2lnbmFsKSB7CiAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkgewogICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHsKICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7CiAgICAgICAgICAgICAgICAgIHJldHVybiBfcHJvbWlzZS5kZWZhdWx0LnJlc29sdmUoKTsKICAgICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgICAgY2hlY2tBYm9ydFNpZ25hbChzaWduYWwpOwogICAgICAgICAgICAgICAgY2FzZSAzOgogICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0sIF9jYWxsZWUpOwogICAgICAgIH0pKTsKICAgICAgICByZXR1cm4gX2Fib3J0QnJlYWtQb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNhbk1lcmdlQmxvY2tzKGNodW5rMSwgY2h1bmsyKSB7CiAgICAgICAgcmV0dXJuIGNodW5rMi5taW52LmJsb2NrUG9zaXRpb24gLSBjaHVuazEubWF4di5ibG9ja1Bvc2l0aW9uIDwgNjVlMyAmJiBjaHVuazIubWF4di5ibG9ja1Bvc2l0aW9uIC0gY2h1bmsxLm1pbnYuYmxvY2tQb3NpdGlvbiA8IDVlNjsKICAgICAgfQogICAgICBmdW5jdGlvbiBtYWtlT3B0cygpIHsKICAgICAgICB2YXIgb2JqID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiB7fTsKICAgICAgICByZXR1cm4gImFib3J0ZWQiIGluIG9iaiA/IHsKICAgICAgICAgIHNpZ25hbDogb2JqCiAgICAgICAgfSA6IG9iajsKICAgICAgfQogICAgICBmdW5jdGlvbiBvcHRpbWl6ZUNodW5rcyhjaHVua3MsIGxvd2VzdCkgewogICAgICAgIHZhciBtZXJnZWRDaHVua3MgPSBbXTsKICAgICAgICB2YXIgbGFzdENodW5rID0gbnVsbDsKICAgICAgICBpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIGNodW5rczsKICAgICAgICB9CiAgICAgICAgKDAsIF9zb3J0LmRlZmF1bHQpKGNodW5rcykuY2FsbChjaHVua3MsIGZ1bmN0aW9uKGMwLCBjMSkgewogICAgICAgICAgdmFyIGRpZiA9IGMwLm1pbnYuYmxvY2tQb3NpdGlvbiAtIGMxLm1pbnYuYmxvY2tQb3NpdGlvbjsKICAgICAgICAgIGlmIChkaWYgIT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIGRpZjsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJldHVybiBjMC5taW52LmRhdGFQb3NpdGlvbiAtIGMxLm1pbnYuZGF0YVBvc2l0aW9uOwogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICAgICgwLCBfZm9yRWFjaC5kZWZhdWx0KShjaHVua3MpLmNhbGwoY2h1bmtzLCBmdW5jdGlvbihjaHVuaykgewogICAgICAgICAgaWYgKCFsb3dlc3QgfHwgY2h1bmsubWF4di5jb21wYXJlVG8obG93ZXN0KSA+IDApIHsKICAgICAgICAgICAgaWYgKGxhc3RDaHVuayA9PT0gbnVsbCkgewogICAgICAgICAgICAgIG1lcmdlZENodW5rcy5wdXNoKGNodW5rKTsKICAgICAgICAgICAgICBsYXN0Q2h1bmsgPSBjaHVuazsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBpZiAoY2FuTWVyZ2VCbG9ja3MobGFzdENodW5rLCBjaHVuaykpIHsKICAgICAgICAgICAgICAgIGlmIChjaHVuay5tYXh2LmNvbXBhcmVUbyhsYXN0Q2h1bmsubWF4dikgPiAwKSB7CiAgICAgICAgICAgICAgICAgIGxhc3RDaHVuay5tYXh2ID0gY2h1bmsubWF4djsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgbWVyZ2VkQ2h1bmtzLnB1c2goY2h1bmspOwogICAgICAgICAgICAgICAgbGFzdENodW5rID0gY2h1bms7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgICAgcmV0dXJuIG1lcmdlZENodW5rczsKICAgICAgfQogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmFtL2Rpc3QvYmFpLmpzCiAgdmFyIHJlcXVpcmVfYmFpID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BnbW9kL2JhbS9kaXN0L2JhaS5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlX2ludGVyb3BSZXF1aXJlRGVmYXVsdCgpOwogICAgICB2YXIgX09iamVjdCRkZWZpbmVQcm9wZXJ0eTIgPSByZXF1aXJlX2RlZmluZV9wcm9wZXJ0eTMoKTsKICAgICAgX09iamVjdCRkZWZpbmVQcm9wZXJ0eTIoZXhwb3J0cywgIl9fZXNNb2R1bGUiLCB7CiAgICAgICAgdmFsdWU6IHRydWUKICAgICAgfSk7CiAgICAgIGV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDsKICAgICAgdmFyIF9nZXRJdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfZ2V0X2l0ZXJhdG9yNSgpKTsKICAgICAgdmFyIF9pc0FycmF5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2lzX2FycmF5NCgpKTsKICAgICAgdmFyIF9nZXRJdGVyYXRvck1ldGhvZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfZ2V0X2l0ZXJhdG9yX21ldGhvZDUoKSk7CiAgICAgIHZhciBfc3ltYm9sID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3N5bWJvbDMoKSk7CiAgICAgIHZhciBfZnJvbSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9mcm9tMygpKTsKICAgICAgdmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfZGVmaW5lX3Byb3BlcnR5MygpKTsKICAgICAgdmFyIF9kZWZpbmVQcm9wZXJ0aWVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2RlZmluZV9wcm9wZXJ0aWVzMygpKTsKICAgICAgdmFyIF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2dldF9vd25fcHJvcGVydHlfZGVzY3JpcHRvcnMzKCkpOwogICAgICB2YXIgX2ZvckVhY2ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfZm9yX2VhY2g0KCkpOwogICAgICB2YXIgX2dldE93blByb3BlcnR5RGVzY3JpcHRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9nZXRfb3duX3Byb3BlcnR5X2Rlc2NyaXB0b3IzKCkpOwogICAgICB2YXIgX2ZpbHRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9maWx0ZXI0KCkpOwogICAgICB2YXIgX2dldE93blByb3BlcnR5U3ltYm9scyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9nZXRfb3duX3Byb3BlcnR5X3N5bWJvbHMzKCkpOwogICAgICB2YXIgX2tleXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfa2V5czMoKSk7CiAgICAgIHZhciBfY29uc3RydWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2NvbnN0cnVjdDMoKSk7CiAgICAgIHZhciBfc2xpY2VkVG9BcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfc2xpY2VkVG9BcnJheSgpKTsKICAgICAgdmFyIF9kZWZpbmVQcm9wZXJ0eTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfZGVmaW5lUHJvcGVydHkoKSk7CiAgICAgIHZhciBfbWFwID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX21hcDQoKSk7CiAgICAgIHZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfcmVnZW5lcmF0b3IoKSk7CiAgICAgIHZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfYXN5bmNUb0dlbmVyYXRvcigpKTsKICAgICAgdmFyIF9zbGljZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9zbGljZTYoKSk7CiAgICAgIHZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2NsYXNzQ2FsbENoZWNrKCkpOwogICAgICB2YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9jcmVhdGVDbGFzcygpKTsKICAgICAgdmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfaW5oZXJpdHMoKSk7CiAgICAgIHZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybigpKTsKICAgICAgdmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfZ2V0UHJvdG90eXBlT2YoKSk7CiAgICAgIHZhciBfbG9uZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9sb25nKCkpOwogICAgICB2YXIgX3ZpcnR1YWxPZmZzZXQgPSByZXF1aXJlX3ZpcnR1YWxPZmZzZXQoKTsKICAgICAgdmFyIF9jaHVuayA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9jaHVuaygpKTsKICAgICAgdmFyIF9pbmRleEZpbGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfaW5kZXhGaWxlKCkpOwogICAgICB2YXIgX3V0aWwgPSByZXF1aXJlX3V0aWwoKTsKICAgICAgZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsKICAgICAgICB2YXIgaXQ7CiAgICAgICAgaWYgKHR5cGVvZiBfc3ltYm9sLmRlZmF1bHQgPT09ICJ1bmRlZmluZWQiIHx8ICgwLCBfZ2V0SXRlcmF0b3JNZXRob2QyLmRlZmF1bHQpKG8pID09IG51bGwpIHsKICAgICAgICAgIGlmICgoMCwgX2lzQXJyYXkuZGVmYXVsdCkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gIm51bWJlciIpIHsKICAgICAgICAgICAgaWYgKGl0KQogICAgICAgICAgICAgIG8gPSBpdDsKICAgICAgICAgICAgdmFyIGkgPSAwOwogICAgICAgICAgICB2YXIgRiA9IGZ1bmN0aW9uIEYyKCkgewogICAgICAgICAgICB9OwogICAgICAgICAgICByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgewogICAgICAgICAgICAgIGlmIChpID49IG8ubGVuZ3RoKQogICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OwogICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07CiAgICAgICAgICAgIH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsKICAgICAgICAgICAgICB0aHJvdyBfZTsKICAgICAgICAgICAgfSwgZjogRiB9OwogICAgICAgICAgfQogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLiIpOwogICAgICAgIH0KICAgICAgICB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7CiAgICAgICAgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsKICAgICAgICAgIGl0ID0gKDAsIF9nZXRJdGVyYXRvcjIuZGVmYXVsdCkobyk7CiAgICAgICAgfSwgbjogZnVuY3Rpb24gbigpIHsKICAgICAgICAgIHZhciBzdGVwID0gaXQubmV4dCgpOwogICAgICAgICAgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsKICAgICAgICAgIHJldHVybiBzdGVwOwogICAgICAgIH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7CiAgICAgICAgICBkaWRFcnIgPSB0cnVlOwogICAgICAgICAgZXJyID0gX2UyOwogICAgICAgIH0sIGY6IGZ1bmN0aW9uIGYoKSB7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpCiAgICAgICAgICAgICAgaXQucmV0dXJuKCk7CiAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICBpZiAoZGlkRXJyKQogICAgICAgICAgICAgIHRocm93IGVycjsKICAgICAgICAgIH0KICAgICAgICB9IH07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgewogICAgICAgIHZhciBfY29udGV4dDc7CiAgICAgICAgaWYgKCFvKQogICAgICAgICAgcmV0dXJuOwogICAgICAgIGlmICh0eXBlb2YgbyA9PT0gInN0cmluZyIpCiAgICAgICAgICByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsKICAgICAgICB2YXIgbiA9ICgwLCBfc2xpY2UuZGVmYXVsdCkoX2NvbnRleHQ3ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pKS5jYWxsKF9jb250ZXh0NywgOCwgLTEpOwogICAgICAgIGlmIChuID09PSAiT2JqZWN0IiAmJiBvLmNvbnN0cnVjdG9yKQogICAgICAgICAgbiA9IG8uY29uc3RydWN0b3IubmFtZTsKICAgICAgICBpZiAobiA9PT0gIk1hcCIgfHwgbiA9PT0gIlNldCIpCiAgICAgICAgICByZXR1cm4gKDAsIF9mcm9tLmRlZmF1bHQpKG8pOwogICAgICAgIGlmIChuID09PSAiQXJndW1lbnRzIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkKICAgICAgICAgIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7CiAgICAgICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpCiAgICAgICAgICBsZW4gPSBhcnIubGVuZ3RoOwogICAgICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgewogICAgICAgICAgYXJyMltpXSA9IGFycltpXTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGFycjI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7CiAgICAgICAgdmFyIGtleXMgPSAoMCwgX2tleXMuZGVmYXVsdCkob2JqZWN0KTsKICAgICAgICBpZiAoX2dldE93blByb3BlcnR5U3ltYm9scy5kZWZhdWx0KSB7CiAgICAgICAgICB2YXIgc3ltYm9scyA9ICgwLCBfZ2V0T3duUHJvcGVydHlTeW1ib2xzLmRlZmF1bHQpKG9iamVjdCk7CiAgICAgICAgICBpZiAoZW51bWVyYWJsZU9ubHkpCiAgICAgICAgICAgIHN5bWJvbHMgPSAoMCwgX2ZpbHRlci5kZWZhdWx0KShzeW1ib2xzKS5jYWxsKHN5bWJvbHMsIGZ1bmN0aW9uKHN5bSkgewogICAgICAgICAgICAgIHJldHVybiAoMCwgX2dldE93blByb3BlcnR5RGVzY3JpcHRvci5kZWZhdWx0KShvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBrZXlzOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7CiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OwogICAgICAgICAgaWYgKGkgJSAyKSB7CiAgICAgICAgICAgIHZhciBfY29udGV4dDU7CiAgICAgICAgICAgICgwLCBfZm9yRWFjaC5kZWZhdWx0KShfY29udGV4dDUgPSBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKSkuY2FsbChfY29udGV4dDUsIGZ1bmN0aW9uKGtleSkgewogICAgICAgICAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkzLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSBlbHNlIGlmIChfZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycy5kZWZhdWx0KSB7CiAgICAgICAgICAgICgwLCBfZGVmaW5lUHJvcGVydGllcy5kZWZhdWx0KSh0YXJnZXQsICgwLCBfZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycy5kZWZhdWx0KShzb3VyY2UpKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHZhciBfY29udGV4dDY7CiAgICAgICAgICAgICgwLCBfZm9yRWFjaC5kZWZhdWx0KShfY29udGV4dDYgPSBvd25LZXlzKE9iamVjdChzb3VyY2UpKSkuY2FsbChfY29udGV4dDYsIGZ1bmN0aW9uKGtleSkgewogICAgICAgICAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCAoMCwgX2dldE93blByb3BlcnR5RGVzY3JpcHRvci5kZWZhdWx0KShzb3VyY2UsIGtleSkpOwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRhcmdldDsKICAgICAgfQogICAgICBmdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgewogICAgICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOwogICAgICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsKICAgICAgICAgIHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKERlcml2ZWQpLCByZXN1bHQ7CiAgICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgewogICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkodGhpcykuY29uc3RydWN0b3I7CiAgICAgICAgICAgIHJlc3VsdCA9ICgwLCBfY29uc3RydWN0LmRlZmF1bHQpKFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgcmVzdWx0KTsKICAgICAgICB9OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7CiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAidW5kZWZpbmVkIiB8fCAhX2NvbnN0cnVjdC5kZWZhdWx0KQogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIGlmIChfY29uc3RydWN0LmRlZmF1bHQuc2hhbSkKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICBpZiAodHlwZW9mIFByb3h5ID09PSAiZnVuY3Rpb24iKQogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoKDAsIF9jb25zdHJ1Y3QuZGVmYXVsdCkoRGF0ZSwgW10sIGZ1bmN0aW9uKCkgewogICAgICAgICAgfSkpOwogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgfQogICAgICB2YXIgQkFJX01BR0lDID0gMjE1NzgwNTA7CiAgICAgIGZ1bmN0aW9uIHJvdW5kRG93bihuLCBtdWx0aXBsZSkgewogICAgICAgIHJldHVybiBuIC0gbiAlIG11bHRpcGxlOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHJvdW5kVXAobiwgbXVsdGlwbGUpIHsKICAgICAgICByZXR1cm4gbiAtIG4gJSBtdWx0aXBsZSArIG11bHRpcGxlOwogICAgICB9CiAgICAgIHZhciBCQUkgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oX0luZGV4RmlsZSkgewogICAgICAgICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEJBSTIsIF9JbmRleEZpbGUpOwogICAgICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQkFJMik7CiAgICAgICAgZnVuY3Rpb24gQkFJMigpIHsKICAgICAgICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEJBSTIpOwogICAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgIH0KICAgICAgICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShCQUkyLCBbewogICAgICAgICAga2V5OiAicGFyc2VQc2V1ZG9CaW4iLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlUHNldWRvQmluKGJ5dGVzLCBvZmZzZXQpIHsKICAgICAgICAgICAgdmFyIGxpbmVDb3VudCA9ICgwLCBfdXRpbC5sb25nVG9OdW1iZXIpKF9sb25nLmRlZmF1bHQuZnJvbUJ5dGVzTEUoKDAsIF9zbGljZS5kZWZhdWx0KShBcnJheS5wcm90b3R5cGUpLmNhbGwoYnl0ZXMsIG9mZnNldCArIDE2LCBvZmZzZXQgKyAyNCksIHRydWUpKTsKICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICBsaW5lQ291bnQKICAgICAgICAgICAgfTsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJsaW5lQ291bnQiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgX2xpbmVDb3VudCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShyZWZJZCkgewogICAgICAgICAgICAgIHZhciBvcHRzLCBwcm9tLCBpbmRleCwgcmV0LCBfYXJncyA9IGFyZ3VtZW50czsKICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkgewogICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkgewogICAgICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgICAgIG9wdHMgPSBfYXJncy5sZW5ndGggPiAxICYmIF9hcmdzWzFdICE9PSB2b2lkIDAgPyBfYXJnc1sxXSA6IHt9OwogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZShvcHRzKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgICAgICAgICBwcm9tID0gX2NvbnRleHQuc2VudDsKICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcHJvbS5pbmRpY2VzW3JlZklkXTsKICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNzsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCJyZXR1cm4iLCAtMSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OgogICAgICAgICAgICAgICAgICAgICAgcmV0ID0gaW5kZXguc3RhdHMgfHwge307CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCJyZXR1cm4iLCByZXQubGluZUNvdW50ID09PSB2b2lkIDAgPyAtMSA6IHJldC5saW5lQ291bnQpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgOToKICAgICAgICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpOwogICAgICAgICAgICB9KSk7CiAgICAgICAgICAgIGZ1bmN0aW9uIGxpbmVDb3VudChfeCkgewogICAgICAgICAgICAgIHJldHVybiBfbGluZUNvdW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGxpbmVDb3VudDsKICAgICAgICAgIH0oKQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogIl9wYXJzZSIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciBfcGFyc2UyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KSgvKiBAX19QVVJFX18gKi8gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHsKICAgICAgICAgICAgICB2YXIgb3B0cywgZGF0YSwgYnl0ZXMsIGRlcHRoLCBiaW5MaW1pdCwgY3Vyck9mZnNldCwgaSwgYmluQ291bnQsIHN0YXRzLCBiaW5JbmRleCwgaiwgYmluLCBjaHVua0NvdW50LCBjaHVua3MsIGssIHUsIHYsIGxpbmVhckNvdW50LCBsaW5lYXJJbmRleCwgX2ssIF9hcmdzMiA9IGFyZ3VtZW50czsKICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7CiAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHsKICAgICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgICBvcHRzID0gX2FyZ3MyLmxlbmd0aCA+IDAgJiYgX2FyZ3MyWzBdICE9PSB2b2lkIDAgPyBfYXJnczJbMF0gOiB7fTsKICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGJhaTogdHJ1ZSwKICAgICAgICAgICAgICAgICAgICAgICAgbWF4QmxvY2tTaXplOiAxIDw8IDE2CiAgICAgICAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0OwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsZWhhbmRsZS5yZWFkRmlsZShvcHRzKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6CiAgICAgICAgICAgICAgICAgICAgICBieXRlcyA9IF9jb250ZXh0Mi5zZW50OwogICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYnl0ZXMucmVhZFVJbnQzMkxFKDApICE9PSBCQUlfTUFHSUMpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNzsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIk5vdCBhIEJBSSBmaWxlIik7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OgogICAgICAgICAgICAgICAgICAgICAgZGF0YS5yZWZDb3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKDQpOwogICAgICAgICAgICAgICAgICAgICAgZGVwdGggPSA1OwogICAgICAgICAgICAgICAgICAgICAgYmluTGltaXQgPSAoKDEgPDwgKGRlcHRoICsgMSkgKiAzKSAtIDEpIC8gNzsKICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaW5kaWNlcyA9IG5ldyBBcnJheShkYXRhLnJlZkNvdW50KTsKICAgICAgICAgICAgICAgICAgICAgIGN1cnJPZmZzZXQgPSA4OwogICAgICAgICAgICAgICAgICAgICAgaSA9IDA7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzoKICAgICAgICAgICAgICAgICAgICAgIGlmICghKGkgPCBkYXRhLnJlZkNvdW50KSkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDUwOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTY7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF91dGlsLmFib3J0QnJlYWtQb2ludCkob3B0cy5zaWduYWwpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6CiAgICAgICAgICAgICAgICAgICAgICBiaW5Db3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKGN1cnJPZmZzZXQpOwogICAgICAgICAgICAgICAgICAgICAgc3RhdHMgPSB2b2lkIDA7CiAgICAgICAgICAgICAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDQ7CiAgICAgICAgICAgICAgICAgICAgICBiaW5JbmRleCA9IHt9OwogICAgICAgICAgICAgICAgICAgICAgaiA9IDA7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMToKICAgICAgICAgICAgICAgICAgICAgIGlmICghKGogPCBiaW5Db3VudCkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0MjsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBiaW4gPSBieXRlcy5yZWFkVUludDMyTEUoY3Vyck9mZnNldCk7CiAgICAgICAgICAgICAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDQ7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIShiaW4gPT09IGJpbkxpbWl0ICsgMSkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzMDsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDQ7CiAgICAgICAgICAgICAgICAgICAgICBzdGF0cyA9IHRoaXMucGFyc2VQc2V1ZG9CaW4oYnl0ZXMsIGN1cnJPZmZzZXQpOwogICAgICAgICAgICAgICAgICAgICAgY3Vyck9mZnNldCArPSAzMjsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMzk7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICBjYXNlIDMwOgogICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYmluID4gYmluTGltaXQgKyAxKSkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDM0OwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiYmFpIGluZGV4IGNvbnRhaW5zIHRvbyBtYW55IGJpbnMsIHBsZWFzZSB1c2UgQ1NJIik7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAzNDoKICAgICAgICAgICAgICAgICAgICAgIGNodW5rQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICAgICAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gNDsKICAgICAgICAgICAgICAgICAgICAgIGNodW5rcyA9IG5ldyBBcnJheShjaHVua0NvdW50KTsKICAgICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBjaHVua0NvdW50OyBrICs9IDEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdSA9ICgwLCBfdmlydHVhbE9mZnNldC5mcm9tQnl0ZXMpKGJ5dGVzLCBjdXJyT2Zmc2V0KTsKICAgICAgICAgICAgICAgICAgICAgICAgdiA9ICgwLCBfdmlydHVhbE9mZnNldC5mcm9tQnl0ZXMpKGJ5dGVzLCBjdXJyT2Zmc2V0ICsgOCk7CiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gMTY7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmRGaXJzdERhdGEoZGF0YSwgdSk7CiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rc1trXSA9IG5ldyBfY2h1bmsuZGVmYXVsdCh1LCB2LCBiaW4pOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgYmluSW5kZXhbYmluXSA9IGNodW5rczsKICAgICAgICAgICAgICAgICAgICBjYXNlIDM5OgogICAgICAgICAgICAgICAgICAgICAgaiArPSAxOwogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyMTsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIGNhc2UgNDI6CiAgICAgICAgICAgICAgICAgICAgICBsaW5lYXJDb3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKGN1cnJPZmZzZXQpOwogICAgICAgICAgICAgICAgICAgICAgY3Vyck9mZnNldCArPSA0OwogICAgICAgICAgICAgICAgICAgICAgbGluZWFySW5kZXggPSBuZXcgQXJyYXkobGluZWFyQ291bnQpOwogICAgICAgICAgICAgICAgICAgICAgZm9yIChfayA9IDA7IF9rIDwgbGluZWFyQ291bnQ7IF9rICs9IDEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgbGluZWFySW5kZXhbX2tdID0gKDAsIF92aXJ0dWFsT2Zmc2V0LmZyb21CeXRlcykoYnl0ZXMsIGN1cnJPZmZzZXQpOwogICAgICAgICAgICAgICAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDg7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmRGaXJzdERhdGEoZGF0YSwgbGluZWFySW5kZXhbX2tdKTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaW5kaWNlc1tpXSA9IHsKICAgICAgICAgICAgICAgICAgICAgICAgYmluSW5kZXgsCiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVhckluZGV4LAogICAgICAgICAgICAgICAgICAgICAgICBzdGF0cwogICAgICAgICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDQ3OgogICAgICAgICAgICAgICAgICAgICAgaSArPSAxOwogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMzsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIGNhc2UgNTA6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdCgicmV0dXJuIiwgZGF0YSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA1MToKICAgICAgICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7CiAgICAgICAgICAgIH0pKTsKICAgICAgICAgICAgZnVuY3Rpb24gX3BhcnNlKCkgewogICAgICAgICAgICAgIHJldHVybiBfcGFyc2UyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIF9wYXJzZTsKICAgICAgICAgIH0oKQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogImluZGV4Q292IiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgdmFyIF9pbmRleENvdiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoc2VxSWQsIHN0YXJ0LCBlbmQpIHsKICAgICAgICAgICAgICB2YXIgb3B0cywgdiwgcmFuZ2UsIGluZGV4RGF0YSwgc2VxSWR4LCBfc2VxSWR4JGxpbmVhckluZGV4LCBsaW5lYXJJbmRleCwgc3RhdHMsIGUsIHMsIGRlcHRocywgdG90YWxTaXplLCBjdXJyZW50UG9zLCBpLCBqLCBfYXJnczMgPSBhcmd1bWVudHM7CiAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0MykgewogICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgICAgb3B0cyA9IF9hcmdzMy5sZW5ndGggPiAzICYmIF9hcmdzM1szXSAhPT0gdm9pZCAwID8gX2FyZ3MzWzNdIDoge307CiAgICAgICAgICAgICAgICAgICAgICB2ID0gMTYzODQ7CiAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHN0YXJ0ICE9PSB2b2lkIDA7CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDU7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZShvcHRzKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDU6CiAgICAgICAgICAgICAgICAgICAgICBpbmRleERhdGEgPSBfY29udGV4dDMuc2VudDsKICAgICAgICAgICAgICAgICAgICAgIHNlcUlkeCA9IGluZGV4RGF0YS5pbmRpY2VzW3NlcUlkXTsKICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXFJZHgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA5OwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KCJyZXR1cm4iLCBbXSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OgogICAgICAgICAgICAgICAgICAgICAgX3NlcUlkeCRsaW5lYXJJbmRleCA9IHNlcUlkeC5saW5lYXJJbmRleCwgbGluZWFySW5kZXggPSBfc2VxSWR4JGxpbmVhckluZGV4ID09PSB2b2lkIDAgPyBbXSA6IF9zZXFJZHgkbGluZWFySW5kZXgsIHN0YXRzID0gc2VxSWR4LnN0YXRzOwogICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVhckluZGV4Lmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDEyOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KCJyZXR1cm4iLCBbXSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjoKICAgICAgICAgICAgICAgICAgICAgIGUgPSBlbmQgIT09IHZvaWQgMCA/IHJvdW5kVXAoZW5kLCB2KSA6IChsaW5lYXJJbmRleC5sZW5ndGggLSAxKSAqIHY7CiAgICAgICAgICAgICAgICAgICAgICBzID0gc3RhcnQgIT09IHZvaWQgMCA/IHJvdW5kRG93bihzdGFydCwgdikgOiAwOwogICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRocyA9IG5ldyBBcnJheSgoZSAtIHMpIC8gdik7CiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBkZXB0aHMgPSBuZXcgQXJyYXkobGluZWFySW5kZXgubGVuZ3RoIC0gMSk7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB0b3RhbFNpemUgPSBsaW5lYXJJbmRleFtsaW5lYXJJbmRleC5sZW5ndGggLSAxXS5ibG9ja1Bvc2l0aW9uOwogICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZSA+IChsaW5lYXJJbmRleC5sZW5ndGggLSAxKSAqIHYpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTg7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJxdWVyeSBvdXRzaWRlIG9mIHJhbmdlIG9mIGxpbmVhciBpbmRleCIpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTg6CiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9zID0gbGluZWFySW5kZXhbcyAvIHZdLmJsb2NrUG9zaXRpb247CiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBzIC8gdiwgaiA9IDA7IGkgPCBlIC8gdjsgaSsrLCBqKyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGhzW2pdID0gewogICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JlOiBsaW5lYXJJbmRleFtpICsgMV0uYmxvY2tQb3NpdGlvbiAtIGN1cnJlbnRQb3MsCiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGkgKiB2LAogICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogaSAqIHYgKyB2CiAgICAgICAgICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MgPSBsaW5lYXJJbmRleFtpICsgMV0uYmxvY2tQb3NpdGlvbjsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KCJyZXR1cm4iLCAoMCwgX21hcC5kZWZhdWx0KShkZXB0aHMpLmNhbGwoZGVwdGhzLCBmdW5jdGlvbihkKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGQpLCB7fSwgewogICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JlOiBkLnNjb3JlICogc3RhdHMubGluZUNvdW50IC8gdG90YWxTaXplCiAgICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgICAgfSkpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMjE6CiAgICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSwgX2NhbGxlZTMsIHRoaXMpOwogICAgICAgICAgICB9KSk7CiAgICAgICAgICAgIGZ1bmN0aW9uIGluZGV4Q292KF94MiwgX3gzLCBfeDQpIHsKICAgICAgICAgICAgICByZXR1cm4gX2luZGV4Q292LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGluZGV4Q292OwogICAgICAgICAgfSgpCiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAicmVnMmJpbnMiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlZzJiaW5zKGJlZywgZW5kKSB7CiAgICAgICAgICAgIGVuZCAtPSAxOwogICAgICAgICAgICByZXR1cm4gW1swLCAwXSwgWzEgKyAoYmVnID4+IDI2KSwgMSArIChlbmQgPj4gMjYpXSwgWzkgKyAoYmVnID4+IDIzKSwgOSArIChlbmQgPj4gMjMpXSwgWzczICsgKGJlZyA+PiAyMCksIDczICsgKGVuZCA+PiAyMCldLCBbNTg1ICsgKGJlZyA+PiAxNyksIDU4NSArIChlbmQgPj4gMTcpXSwgWzQ2ODEgKyAoYmVnID4+IDE0KSwgNDY4MSArIChlbmQgPj4gMTQpXV07CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiYmxvY2tzRm9yUmFuZ2UiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgX2Jsb2Nrc0ZvclJhbmdlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KSgvKiBAX19QVVJFX18gKi8gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlNChyZWZJZCwgbWluLCBtYXgpIHsKICAgICAgICAgICAgICB2YXIgb3B0cywgaW5kZXhEYXRhLCBiYSwgb3ZlcmxhcHBpbmdCaW5zLCBjaHVua3MsIF9pdGVyYXRvciwgX3N0ZXAsIF9zdGVwJHZhbHVlLCBzdGFydCwgZW5kLCBiaW4sIGJpbkNodW5rcywgYywgbmludHYsIGxvd2VzdCwgbWluTGluLCBtYXhMaW4sIGksIHZwLCBfYXJnczQgPSBhcmd1bWVudHM7CiAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkgewogICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgICAgb3B0cyA9IF9hcmdzNC5sZW5ndGggPiAzICYmIF9hcmdzNFszXSAhPT0gdm9pZCAwID8gX2FyZ3M0WzNdIDoge307CiAgICAgICAgICAgICAgICAgICAgICBpZiAobWluIDwgMCkgewogICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSAwOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA0OwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2Uob3B0cyk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OgogICAgICAgICAgICAgICAgICAgICAgaW5kZXhEYXRhID0gX2NvbnRleHQ0LnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXhEYXRhKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNzsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdCgicmV0dXJuIiwgW10pOwogICAgICAgICAgICAgICAgICAgIGNhc2UgNzoKICAgICAgICAgICAgICAgICAgICAgIGJhID0gaW5kZXhEYXRhLmluZGljZXNbcmVmSWRdOwogICAgICAgICAgICAgICAgICAgICAgaWYgKGJhKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTA7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoInJldHVybiIsIFtdKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOgogICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHBpbmdCaW5zID0gdGhpcy5yZWcyYmlucyhtaW4sIG1heCk7CiAgICAgICAgICAgICAgICAgICAgICBjaHVua3MgPSBbXTsKICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG92ZXJsYXBwaW5nQmlucyk7CiAgICAgICAgICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOyApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBfc3RlcCR2YWx1ZSA9ICgwLCBfc2xpY2VkVG9BcnJheTIuZGVmYXVsdCkoX3N0ZXAudmFsdWUsIDIpLCBzdGFydCA9IF9zdGVwJHZhbHVlWzBdLCBlbmQgPSBfc3RlcCR2YWx1ZVsxXTsKICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGJpbiA9IHN0YXJ0OyBiaW4gPD0gZW5kOyBiaW4rKykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhLmJpbkluZGV4W2Jpbl0pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluQ2h1bmtzID0gYmEuYmluSW5kZXhbYmluXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjID0gMDsgYyA8IGJpbkNodW5rcy5sZW5ndGg7ICsrYykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKG5ldyBfY2h1bmsuZGVmYXVsdChiaW5DaHVua3NbY10ubWludiwgYmluQ2h1bmtzW2NdLm1heHYsIGJpbikpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTsKICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvci5mKCk7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBuaW50diA9IGJhLmxpbmVhckluZGV4Lmxlbmd0aDsKICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdCA9IG51bGw7CiAgICAgICAgICAgICAgICAgICAgICBtaW5MaW4gPSBNYXRoLm1pbihtaW4gPj4gMTQsIG5pbnR2IC0gMSk7CiAgICAgICAgICAgICAgICAgICAgICBtYXhMaW4gPSBNYXRoLm1pbihtYXggPj4gMTQsIG5pbnR2IC0gMSk7CiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBtaW5MaW47IGkgPD0gbWF4TGluOyArK2kpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdnAgPSBiYS5saW5lYXJJbmRleFtpXTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb3dlc3QgfHwgdnAuY29tcGFyZVRvKGxvd2VzdCkgPCAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3QgPSB2cDsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KCJyZXR1cm4iLCAoMCwgX3V0aWwub3B0aW1pemVDaHVua3MpKGNodW5rcywgbG93ZXN0KSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMDoKICAgICAgICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9LCBfY2FsbGVlNCwgdGhpcyk7CiAgICAgICAgICAgIH0pKTsKICAgICAgICAgICAgZnVuY3Rpb24gYmxvY2tzRm9yUmFuZ2UoX3g1LCBfeDYsIF94NykgewogICAgICAgICAgICAgIHJldHVybiBfYmxvY2tzRm9yUmFuZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gYmxvY2tzRm9yUmFuZ2U7CiAgICAgICAgICB9KCkKICAgICAgICB9XSk7CiAgICAgICAgcmV0dXJuIEJBSTI7CiAgICAgIH0oX2luZGV4RmlsZS5kZWZhdWx0KTsKICAgICAgZXhwb3J0cy5kZWZhdWx0ID0gQkFJOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9mcmVlemluZy5qcwogIHZhciByZXF1aXJlX2ZyZWV6aW5nID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZnJlZXppbmcuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBmYWlscyA9IHJlcXVpcmVfZmFpbHMoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24oKSB7CiAgICAgICAgcmV0dXJuIE9iamVjdC5pc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7CiAgICAgIH0pOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pbnRlcm5hbC1tZXRhZGF0YS5qcwogIHZhciByZXF1aXJlX2ludGVybmFsX21ldGFkYXRhID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciAkID0gcmVxdWlyZV9leHBvcnQoKTsKICAgICAgdmFyIGhpZGRlbktleXMgPSByZXF1aXJlX2hpZGRlbl9rZXlzKCk7CiAgICAgIHZhciBpc09iamVjdCA9IHJlcXVpcmVfaXNfb2JqZWN0KCk7CiAgICAgIHZhciBoYXMgPSByZXF1aXJlX2hhcygpOwogICAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlX29iamVjdF9kZWZpbmVfcHJvcGVydHkoKS5mOwogICAgICB2YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSA9IHJlcXVpcmVfb2JqZWN0X2dldF9vd25fcHJvcGVydHlfbmFtZXMoKTsKICAgICAgdmFyIGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbE1vZHVsZSA9IHJlcXVpcmVfb2JqZWN0X2dldF9vd25fcHJvcGVydHlfbmFtZXNfZXh0ZXJuYWwoKTsKICAgICAgdmFyIHVpZCA9IHJlcXVpcmVfdWlkKCk7CiAgICAgIHZhciBGUkVFWklORyA9IHJlcXVpcmVfZnJlZXppbmcoKTsKICAgICAgdmFyIFJFUVVJUkVEID0gZmFsc2U7CiAgICAgIHZhciBNRVRBREFUQSA9IHVpZCgibWV0YSIpOwogICAgICB2YXIgaWQgPSAwOwogICAgICB2YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfTsKICAgICAgdmFyIHNldE1ldGFkYXRhID0gZnVuY3Rpb24oaXQpIHsKICAgICAgICBkZWZpbmVQcm9wZXJ0eShpdCwgTUVUQURBVEEsIHsgdmFsdWU6IHsKICAgICAgICAgIG9iamVjdElEOiAiTyIgKyBpZCsrLAogICAgICAgICAgd2Vha0RhdGE6IHt9CiAgICAgICAgfSB9KTsKICAgICAgfTsKICAgICAgdmFyIGZhc3RLZXkgPSBmdW5jdGlvbihpdCwgY3JlYXRlKSB7CiAgICAgICAgaWYgKCFpc09iamVjdChpdCkpCiAgICAgICAgICByZXR1cm4gdHlwZW9mIGl0ID09ICJzeW1ib2wiID8gaXQgOiAodHlwZW9mIGl0ID09ICJzdHJpbmciID8gIlMiIDogIlAiKSArIGl0OwogICAgICAgIGlmICghaGFzKGl0LCBNRVRBREFUQSkpIHsKICAgICAgICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkKICAgICAgICAgICAgcmV0dXJuICJGIjsKICAgICAgICAgIGlmICghY3JlYXRlKQogICAgICAgICAgICByZXR1cm4gIkUiOwogICAgICAgICAgc2V0TWV0YWRhdGEoaXQpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gaXRbTUVUQURBVEFdLm9iamVjdElEOwogICAgICB9OwogICAgICB2YXIgZ2V0V2Vha0RhdGEgPSBmdW5jdGlvbihpdCwgY3JlYXRlKSB7CiAgICAgICAgaWYgKCFoYXMoaXQsIE1FVEFEQVRBKSkgewogICAgICAgICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKQogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIGlmICghY3JlYXRlKQogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICBzZXRNZXRhZGF0YShpdCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBpdFtNRVRBREFUQV0ud2Vha0RhdGE7CiAgICAgIH07CiAgICAgIHZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uKGl0KSB7CiAgICAgICAgaWYgKEZSRUVaSU5HICYmIFJFUVVJUkVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQURBVEEpKQogICAgICAgICAgc2V0TWV0YWRhdGEoaXQpOwogICAgICAgIHJldHVybiBpdDsKICAgICAgfTsKICAgICAgdmFyIGVuYWJsZSA9IGZ1bmN0aW9uKCkgewogICAgICAgIG1ldGEuZW5hYmxlID0gZnVuY3Rpb24oKSB7CiAgICAgICAgfTsKICAgICAgICBSRVFVSVJFRCA9IHRydWU7CiAgICAgICAgdmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmY7CiAgICAgICAgdmFyIHNwbGljZSA9IFtdLnNwbGljZTsKICAgICAgICB2YXIgdGVzdCA9IHt9OwogICAgICAgIHRlc3RbTUVUQURBVEFdID0gMTsKICAgICAgICBpZiAoZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0KS5sZW5ndGgpIHsKICAgICAgICAgIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZiA9IGZ1bmN0aW9uKGl0KSB7CiAgICAgICAgICAgIHZhciByZXN1bHQgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KTsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykgewogICAgICAgICAgICAgIGlmIChyZXN1bHRbaV0gPT09IE1FVEFEQVRBKSB7CiAgICAgICAgICAgICAgICBzcGxpY2UuY2FsbChyZXN1bHQsIGksIDEpOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgICB9OwogICAgICAgICAgJCh7IHRhcmdldDogIk9iamVjdCIsIHN0YXQ6IHRydWUsIGZvcmNlZDogdHJ1ZSB9LCB7CiAgICAgICAgICAgIGdldE93blByb3BlcnR5TmFtZXM6IGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbE1vZHVsZS5mCiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIHZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7CiAgICAgICAgZW5hYmxlLAogICAgICAgIGZhc3RLZXksCiAgICAgICAgZ2V0V2Vha0RhdGEsCiAgICAgICAgb25GcmVlemUKICAgICAgfTsKICAgICAgaGlkZGVuS2V5c1tNRVRBREFUQV0gPSB0cnVlOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9jb2xsZWN0aW9uLmpzCiAgdmFyIHJlcXVpcmVfY29sbGVjdGlvbiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2NvbGxlY3Rpb24uanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyICQgPSByZXF1aXJlX2V4cG9ydCgpOwogICAgICB2YXIgZ2xvYmFsMiA9IHJlcXVpcmVfZ2xvYmFsKCk7CiAgICAgIHZhciBJbnRlcm5hbE1ldGFkYXRhTW9kdWxlID0gcmVxdWlyZV9pbnRlcm5hbF9tZXRhZGF0YSgpOwogICAgICB2YXIgZmFpbHMgPSByZXF1aXJlX2ZhaWxzKCk7CiAgICAgIHZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlX2NyZWF0ZV9ub25fZW51bWVyYWJsZV9wcm9wZXJ0eSgpOwogICAgICB2YXIgaXRlcmF0ZSA9IHJlcXVpcmVfaXRlcmF0ZSgpOwogICAgICB2YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmVfYW5faW5zdGFuY2UoKTsKICAgICAgdmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlX2lzX2NhbGxhYmxlKCk7CiAgICAgIHZhciBpc09iamVjdCA9IHJlcXVpcmVfaXNfb2JqZWN0KCk7CiAgICAgIHZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmVfc2V0X3RvX3N0cmluZ190YWcoKTsKICAgICAgdmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZV9vYmplY3RfZGVmaW5lX3Byb3BlcnR5KCkuZjsKICAgICAgdmFyIGZvckVhY2ggPSByZXF1aXJlX2FycmF5X2l0ZXJhdGlvbigpLmZvckVhY2g7CiAgICAgIHZhciBERVNDUklQVE9SUyA9IHJlcXVpcmVfZGVzY3JpcHRvcnMoKTsKICAgICAgdmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlX2ludGVybmFsX3N0YXRlKCk7CiAgICAgIHZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7CiAgICAgIHZhciBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3I7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ09OU1RSVUNUT1JfTkFNRSwgd3JhcHBlciwgY29tbW9uKSB7CiAgICAgICAgdmFyIElTX01BUCA9IENPTlNUUlVDVE9SX05BTUUuaW5kZXhPZigiTWFwIikgIT09IC0xOwogICAgICAgIHZhciBJU19XRUFLID0gQ09OU1RSVUNUT1JfTkFNRS5pbmRleE9mKCJXZWFrIikgIT09IC0xOwogICAgICAgIHZhciBBRERFUiA9IElTX01BUCA/ICJzZXQiIDogImFkZCI7CiAgICAgICAgdmFyIE5hdGl2ZUNvbnN0cnVjdG9yID0gZ2xvYmFsMltDT05TVFJVQ1RPUl9OQU1FXTsKICAgICAgICB2YXIgTmF0aXZlUHJvdG90eXBlID0gTmF0aXZlQ29uc3RydWN0b3IgJiYgTmF0aXZlQ29uc3RydWN0b3IucHJvdG90eXBlOwogICAgICAgIHZhciBleHBvcnRlZCA9IHt9OwogICAgICAgIHZhciBDb25zdHJ1Y3RvcjsKICAgICAgICBpZiAoIURFU0NSSVBUT1JTIHx8ICFpc0NhbGxhYmxlKE5hdGl2ZUNvbnN0cnVjdG9yKSB8fCAhKElTX1dFQUsgfHwgTmF0aXZlUHJvdG90eXBlLmZvckVhY2ggJiYgIWZhaWxzKGZ1bmN0aW9uKCkgewogICAgICAgICAgbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCkuZW50cmllcygpLm5leHQoKTsKICAgICAgICB9KSkpIHsKICAgICAgICAgIENvbnN0cnVjdG9yID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCwgQURERVIpOwogICAgICAgICAgSW50ZXJuYWxNZXRhZGF0YU1vZHVsZS5lbmFibGUoKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgQ29uc3RydWN0b3IgPSB3cmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgaXRlcmFibGUpIHsKICAgICAgICAgICAgc2V0SW50ZXJuYWxTdGF0ZShhbkluc3RhbmNlKHRhcmdldCwgQ29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUpLCB7CiAgICAgICAgICAgICAgdHlwZTogQ09OU1RSVUNUT1JfTkFNRSwKICAgICAgICAgICAgICBjb2xsZWN0aW9uOiBuZXcgTmF0aXZlQ29uc3RydWN0b3IoKQogICAgICAgICAgICB9KTsKICAgICAgICAgICAgaWYgKGl0ZXJhYmxlICE9IHZvaWQgMCkKICAgICAgICAgICAgICBpdGVyYXRlKGl0ZXJhYmxlLCB0YXJnZXRbQURERVJdLCB7IHRoYXQ6IHRhcmdldCwgQVNfRU5UUklFUzogSVNfTUFQIH0pOwogICAgICAgICAgfSk7CiAgICAgICAgICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IoQ09OU1RSVUNUT1JfTkFNRSk7CiAgICAgICAgICBmb3JFYWNoKFsiYWRkIiwgImNsZWFyIiwgImRlbGV0ZSIsICJmb3JFYWNoIiwgImdldCIsICJoYXMiLCAic2V0IiwgImtleXMiLCAidmFsdWVzIiwgImVudHJpZXMiXSwgZnVuY3Rpb24oS0VZKSB7CiAgICAgICAgICAgIHZhciBJU19BRERFUiA9IEtFWSA9PSAiYWRkIiB8fCBLRVkgPT0gInNldCI7CiAgICAgICAgICAgIGlmIChLRVkgaW4gTmF0aXZlUHJvdG90eXBlICYmICEoSVNfV0VBSyAmJiBLRVkgPT0gImNsZWFyIikpIHsKICAgICAgICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29uc3RydWN0b3IucHJvdG90eXBlLCBLRVksIGZ1bmN0aW9uKGEsIGIpIHsKICAgICAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5jb2xsZWN0aW9uOwogICAgICAgICAgICAgICAgaWYgKCFJU19BRERFUiAmJiBJU19XRUFLICYmICFpc09iamVjdChhKSkKICAgICAgICAgICAgICAgICAgcmV0dXJuIEtFWSA9PSAiZ2V0IiA/IHZvaWQgMCA6IGZhbHNlOwogICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNvbGxlY3Rpb25bS0VZXShhID09PSAwID8gMCA6IGEsIGIpOwogICAgICAgICAgICAgICAgcmV0dXJuIElTX0FEREVSID8gdGhpcyA6IHJlc3VsdDsKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfQogICAgICAgICAgfSk7CiAgICAgICAgICBJU19XRUFLIHx8IGRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLnByb3RvdHlwZSwgInNpemUiLCB7CiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5jb2xsZWN0aW9uLnNpemU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSwgZmFsc2UsIHRydWUpOwogICAgICAgIGV4cG9ydGVkW0NPTlNUUlVDVE9SX05BTUVdID0gQ29uc3RydWN0b3I7CiAgICAgICAgJCh7IGdsb2JhbDogdHJ1ZSwgZm9yY2VkOiB0cnVlIH0sIGV4cG9ydGVkKTsKICAgICAgICBpZiAoIUlTX1dFQUspCiAgICAgICAgICBjb21tb24uc2V0U3Ryb25nKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVApOwogICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvY29sbGVjdGlvbi13ZWFrLmpzCiAgdmFyIHJlcXVpcmVfY29sbGVjdGlvbl93ZWFrID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvY29sbGVjdGlvbi13ZWFrLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciByZWRlZmluZUFsbCA9IHJlcXVpcmVfcmVkZWZpbmVfYWxsKCk7CiAgICAgIHZhciBnZXRXZWFrRGF0YSA9IHJlcXVpcmVfaW50ZXJuYWxfbWV0YWRhdGEoKS5nZXRXZWFrRGF0YTsKICAgICAgdmFyIGFuT2JqZWN0ID0gcmVxdWlyZV9hbl9vYmplY3QoKTsKICAgICAgdmFyIGlzT2JqZWN0ID0gcmVxdWlyZV9pc19vYmplY3QoKTsKICAgICAgdmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlX2FuX2luc3RhbmNlKCk7CiAgICAgIHZhciBpdGVyYXRlID0gcmVxdWlyZV9pdGVyYXRlKCk7CiAgICAgIHZhciBBcnJheUl0ZXJhdGlvbk1vZHVsZSA9IHJlcXVpcmVfYXJyYXlfaXRlcmF0aW9uKCk7CiAgICAgIHZhciAkaGFzID0gcmVxdWlyZV9oYXMoKTsKICAgICAgdmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlX2ludGVybmFsX3N0YXRlKCk7CiAgICAgIHZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7CiAgICAgIHZhciBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3I7CiAgICAgIHZhciBmaW5kID0gQXJyYXlJdGVyYXRpb25Nb2R1bGUuZmluZDsKICAgICAgdmFyIGZpbmRJbmRleCA9IEFycmF5SXRlcmF0aW9uTW9kdWxlLmZpbmRJbmRleDsKICAgICAgdmFyIGlkID0gMDsKICAgICAgdmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbihzdG9yZSkgewogICAgICAgIHJldHVybiBzdG9yZS5mcm96ZW4gfHwgKHN0b3JlLmZyb3plbiA9IG5ldyBVbmNhdWdodEZyb3plblN0b3JlKCkpOwogICAgICB9OwogICAgICB2YXIgVW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uKCkgewogICAgICAgIHRoaXMuZW50cmllcyA9IFtdOwogICAgICB9OwogICAgICB2YXIgZmluZFVuY2F1Z2h0RnJvemVuID0gZnVuY3Rpb24oc3RvcmUsIGtleSkgewogICAgICAgIHJldHVybiBmaW5kKHN0b3JlLmVudHJpZXMsIGZ1bmN0aW9uKGl0KSB7CiAgICAgICAgICByZXR1cm4gaXRbMF0gPT09IGtleTsKICAgICAgICB9KTsKICAgICAgfTsKICAgICAgVW5jYXVnaHRGcm96ZW5TdG9yZS5wcm90b3R5cGUgPSB7CiAgICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHsKICAgICAgICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpOwogICAgICAgICAgaWYgKGVudHJ5KQogICAgICAgICAgICByZXR1cm4gZW50cnlbMV07CiAgICAgICAgfSwKICAgICAgICBoYXM6IGZ1bmN0aW9uKGtleSkgewogICAgICAgICAgcmV0dXJuICEhZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7CiAgICAgICAgfSwKICAgICAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHsKICAgICAgICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpOwogICAgICAgICAgaWYgKGVudHJ5KQogICAgICAgICAgICBlbnRyeVsxXSA9IHZhbHVlOwogICAgICAgICAgZWxzZQogICAgICAgICAgICB0aGlzLmVudHJpZXMucHVzaChba2V5LCB2YWx1ZV0pOwogICAgICAgIH0sCiAgICAgICAgImRlbGV0ZSI6IGZ1bmN0aW9uKGtleSkgewogICAgICAgICAgdmFyIGluZGV4ID0gZmluZEluZGV4KHRoaXMuZW50cmllcywgZnVuY3Rpb24oaXQpIHsKICAgICAgICAgICAgcmV0dXJuIGl0WzBdID09PSBrZXk7CiAgICAgICAgICB9KTsKICAgICAgICAgIGlmICh+aW5kZXgpCiAgICAgICAgICAgIHRoaXMuZW50cmllcy5zcGxpY2UoaW5kZXgsIDEpOwogICAgICAgICAgcmV0dXJuICEhfmluZGV4OwogICAgICAgIH0KICAgICAgfTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSB7CiAgICAgICAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uKHdyYXBwZXIsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCwgQURERVIpIHsKICAgICAgICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBpdGVyYWJsZSkgewogICAgICAgICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIENPTlNUUlVDVE9SX05BTUUpOwogICAgICAgICAgICBzZXRJbnRlcm5hbFN0YXRlKHRoYXQsIHsKICAgICAgICAgICAgICB0eXBlOiBDT05TVFJVQ1RPUl9OQU1FLAogICAgICAgICAgICAgIGlkOiBpZCsrLAogICAgICAgICAgICAgIGZyb3plbjogdm9pZCAwCiAgICAgICAgICAgIH0pOwogICAgICAgICAgICBpZiAoaXRlcmFibGUgIT0gdm9pZCAwKQogICAgICAgICAgICAgIGl0ZXJhdGUoaXRlcmFibGUsIHRoYXRbQURERVJdLCB7IHRoYXQsIEFTX0VOVFJJRVM6IElTX01BUCB9KTsKICAgICAgICAgIH0pOwogICAgICAgICAgdmFyIGdldEludGVybmFsU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yKENPTlNUUlVDVE9SX05BTUUpOwogICAgICAgICAgdmFyIGRlZmluZSA9IGZ1bmN0aW9uKHRoYXQsIGtleSwgdmFsdWUpIHsKICAgICAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTsKICAgICAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrRGF0YShhbk9iamVjdChrZXkpLCB0cnVlKTsKICAgICAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpCiAgICAgICAgICAgICAgdW5jYXVnaHRGcm96ZW5TdG9yZShzdGF0ZSkuc2V0KGtleSwgdmFsdWUpOwogICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgZGF0YVtzdGF0ZS5pZF0gPSB2YWx1ZTsKICAgICAgICAgICAgcmV0dXJuIHRoYXQ7CiAgICAgICAgICB9OwogICAgICAgICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHsKICAgICAgICAgICAgImRlbGV0ZSI6IGZ1bmN0aW9uKGtleSkgewogICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7CiAgICAgICAgICAgICAgaWYgKCFpc09iamVjdChrZXkpKQogICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoa2V5KTsKICAgICAgICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkKICAgICAgICAgICAgICAgIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHN0YXRlKVsiZGVsZXRlIl0oa2V5KTsKICAgICAgICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHN0YXRlLmlkKSAmJiBkZWxldGUgZGF0YVtzdGF0ZS5pZF07CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkgewogICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7CiAgICAgICAgICAgICAgaWYgKCFpc09iamVjdChrZXkpKQogICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoa2V5KTsKICAgICAgICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkKICAgICAgICAgICAgICAgIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHN0YXRlKS5oYXMoa2V5KTsKICAgICAgICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHN0YXRlLmlkKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSk7CiAgICAgICAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwgSVNfTUFQID8gewogICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHsKICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpOwogICAgICAgICAgICAgIGlmIChpc09iamVjdChrZXkpKSB7CiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWtEYXRhKGtleSk7CiAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkKICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUoc3RhdGUpLmdldChrZXkpOwogICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhW3N0YXRlLmlkXSA6IHZvaWQgMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHsKICAgICAgICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIGtleSwgdmFsdWUpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IDogewogICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkgewogICAgICAgICAgICAgIHJldHVybiBkZWZpbmUodGhpcywgdmFsdWUsIHRydWUpOwogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICAgIHJldHVybiBDOwogICAgICAgIH0KICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLndlYWstbWFwLmpzCiAgdmFyIHJlcXVpcmVfZXNfd2Vha19tYXAgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMud2Vhay1tYXAuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIGdsb2JhbDIgPSByZXF1aXJlX2dsb2JhbCgpOwogICAgICB2YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlX3JlZGVmaW5lX2FsbCgpOwogICAgICB2YXIgSW50ZXJuYWxNZXRhZGF0YU1vZHVsZSA9IHJlcXVpcmVfaW50ZXJuYWxfbWV0YWRhdGEoKTsKICAgICAgdmFyIGNvbGxlY3Rpb24gPSByZXF1aXJlX2NvbGxlY3Rpb24oKTsKICAgICAgdmFyIGNvbGxlY3Rpb25XZWFrID0gcmVxdWlyZV9jb2xsZWN0aW9uX3dlYWsoKTsKICAgICAgdmFyIGlzT2JqZWN0ID0gcmVxdWlyZV9pc19vYmplY3QoKTsKICAgICAgdmFyIGVuZm9yY2VJdGVybmFsU3RhdGUgPSByZXF1aXJlX2ludGVybmFsX3N0YXRlKCkuZW5mb3JjZTsKICAgICAgdmFyIE5BVElWRV9XRUFLX01BUCA9IHJlcXVpcmVfbmF0aXZlX3dlYWtfbWFwKCk7CiAgICAgIHZhciBJU19JRTExID0gIWdsb2JhbDIuQWN0aXZlWE9iamVjdCAmJiAiQWN0aXZlWE9iamVjdCIgaW4gZ2xvYmFsMjsKICAgICAgdmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7CiAgICAgIHZhciBJbnRlcm5hbFdlYWtNYXA7CiAgICAgIHZhciB3cmFwcGVyID0gZnVuY3Rpb24oaW5pdDIpIHsKICAgICAgICByZXR1cm4gZnVuY3Rpb24gV2Vha01hcCgpIHsKICAgICAgICAgIHJldHVybiBpbml0Mih0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdm9pZCAwKTsKICAgICAgICB9OwogICAgICB9OwogICAgICB2YXIgJFdlYWtNYXAgPSBtb2R1bGUuZXhwb3J0cyA9IGNvbGxlY3Rpb24oIldlYWtNYXAiLCB3cmFwcGVyLCBjb2xsZWN0aW9uV2Vhayk7CiAgICAgIGlmIChOQVRJVkVfV0VBS19NQVAgJiYgSVNfSUUxMSkgewogICAgICAgIEludGVybmFsV2Vha01hcCA9IGNvbGxlY3Rpb25XZWFrLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsICJXZWFrTWFwIiwgdHJ1ZSk7CiAgICAgICAgSW50ZXJuYWxNZXRhZGF0YU1vZHVsZS5lbmFibGUoKTsKICAgICAgICBXZWFrTWFwUHJvdG90eXBlID0gJFdlYWtNYXAucHJvdG90eXBlOwogICAgICAgIG5hdGl2ZURlbGV0ZSA9IFdlYWtNYXBQcm90b3R5cGVbImRlbGV0ZSJdOwogICAgICAgIG5hdGl2ZUhhcyA9IFdlYWtNYXBQcm90b3R5cGUuaGFzOwogICAgICAgIG5hdGl2ZUdldCA9IFdlYWtNYXBQcm90b3R5cGUuZ2V0OwogICAgICAgIG5hdGl2ZVNldCA9IFdlYWtNYXBQcm90b3R5cGUuc2V0OwogICAgICAgIHJlZGVmaW5lQWxsKFdlYWtNYXBQcm90b3R5cGUsIHsKICAgICAgICAgICJkZWxldGUiOiBmdW5jdGlvbihrZXkpIHsKICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGtleSkgJiYgIWlzRXh0ZW5zaWJsZShrZXkpKSB7CiAgICAgICAgICAgICAgdmFyIHN0YXRlID0gZW5mb3JjZUl0ZXJuYWxTdGF0ZSh0aGlzKTsKICAgICAgICAgICAgICBpZiAoIXN0YXRlLmZyb3plbikKICAgICAgICAgICAgICAgIHN0YXRlLmZyb3plbiA9IG5ldyBJbnRlcm5hbFdlYWtNYXAoKTsKICAgICAgICAgICAgICByZXR1cm4gbmF0aXZlRGVsZXRlLmNhbGwodGhpcywga2V5KSB8fCBzdGF0ZS5mcm96ZW5bImRlbGV0ZSJdKGtleSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZURlbGV0ZS5jYWxsKHRoaXMsIGtleSk7CiAgICAgICAgICB9LAogICAgICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7CiAgICAgICAgICAgIGlmIChpc09iamVjdChrZXkpICYmICFpc0V4dGVuc2libGUoa2V5KSkgewogICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGVuZm9yY2VJdGVybmFsU3RhdGUodGhpcyk7CiAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5mcm96ZW4pCiAgICAgICAgICAgICAgICBzdGF0ZS5mcm96ZW4gPSBuZXcgSW50ZXJuYWxXZWFrTWFwKCk7CiAgICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZUhhcy5jYWxsKHRoaXMsIGtleSkgfHwgc3RhdGUuZnJvemVuLmhhcyhrZXkpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBuYXRpdmVIYXMuY2FsbCh0aGlzLCBrZXkpOwogICAgICAgICAgfSwKICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkgewogICAgICAgICAgICBpZiAoaXNPYmplY3Qoa2V5KSAmJiAhaXNFeHRlbnNpYmxlKGtleSkpIHsKICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBlbmZvcmNlSXRlcm5hbFN0YXRlKHRoaXMpOwogICAgICAgICAgICAgIGlmICghc3RhdGUuZnJvemVuKQogICAgICAgICAgICAgICAgc3RhdGUuZnJvemVuID0gbmV3IEludGVybmFsV2Vha01hcCgpOwogICAgICAgICAgICAgIHJldHVybiBuYXRpdmVIYXMuY2FsbCh0aGlzLCBrZXkpID8gbmF0aXZlR2V0LmNhbGwodGhpcywga2V5KSA6IHN0YXRlLmZyb3plbi5nZXQoa2V5KTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gbmF0aXZlR2V0LmNhbGwodGhpcywga2V5KTsKICAgICAgICAgIH0sCiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7CiAgICAgICAgICAgIGlmIChpc09iamVjdChrZXkpICYmICFpc0V4dGVuc2libGUoa2V5KSkgewogICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGVuZm9yY2VJdGVybmFsU3RhdGUodGhpcyk7CiAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5mcm96ZW4pCiAgICAgICAgICAgICAgICBzdGF0ZS5mcm96ZW4gPSBuZXcgSW50ZXJuYWxXZWFrTWFwKCk7CiAgICAgICAgICAgICAgbmF0aXZlSGFzLmNhbGwodGhpcywga2V5KSA/IG5hdGl2ZVNldC5jYWxsKHRoaXMsIGtleSwgdmFsdWUpIDogc3RhdGUuZnJvemVuLnNldChrZXksIHZhbHVlKTsKICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgbmF0aXZlU2V0LmNhbGwodGhpcywga2V5LCB2YWx1ZSk7CiAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICB9CiAgICAgIHZhciBXZWFrTWFwUHJvdG90eXBlOwogICAgICB2YXIgbmF0aXZlRGVsZXRlOwogICAgICB2YXIgbmF0aXZlSGFzOwogICAgICB2YXIgbmF0aXZlR2V0OwogICAgICB2YXIgbmF0aXZlU2V0OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL3dlYWstbWFwL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfd2Vha19tYXAgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL3dlYWstbWFwL2luZGV4LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICByZXF1aXJlX2VzX2FycmF5X2l0ZXJhdG9yKCk7CiAgICAgIHJlcXVpcmVfZXNfb2JqZWN0X3RvX3N0cmluZygpOwogICAgICByZXF1aXJlX2VzX3dlYWtfbWFwKCk7CiAgICAgIHZhciBwYXRoID0gcmVxdWlyZV9wYXRoKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGF0aC5XZWFrTWFwOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS93ZWFrLW1hcC9pbmRleC5qcwogIHZhciByZXF1aXJlX3dlYWtfbWFwMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL3dlYWstbWFwL2luZGV4LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgcGFyZW50ID0gcmVxdWlyZV93ZWFrX21hcCgpOwogICAgICByZXF1aXJlX3dlYl9kb21fY29sbGVjdGlvbnNfaXRlcmF0b3IoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL21hcC1lbXBsYWNlLmpzCiAgdmFyIHJlcXVpcmVfbWFwX2VtcGxhY2UgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9tYXAtZW1wbGFjZS5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgYW5PYmplY3QgPSByZXF1aXJlX2FuX29iamVjdCgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVtcGxhY2Uoa2V5LCBoYW5kbGVyKSB7CiAgICAgICAgdmFyIG1hcCA9IGFuT2JqZWN0KHRoaXMpOwogICAgICAgIHZhciB2YWx1ZSA9IG1hcC5oYXMoa2V5KSAmJiAidXBkYXRlIiBpbiBoYW5kbGVyID8gaGFuZGxlci51cGRhdGUobWFwLmdldChrZXkpLCBrZXksIG1hcCkgOiBoYW5kbGVyLmluc2VydChrZXksIG1hcCk7CiAgICAgICAgbWFwLnNldChrZXksIHZhbHVlKTsKICAgICAgICByZXR1cm4gdmFsdWU7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lc25leHQud2Vhay1tYXAuZW1wbGFjZS5qcwogIHZhciByZXF1aXJlX2VzbmV4dF93ZWFrX21hcF9lbXBsYWNlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzbmV4dC53ZWFrLW1hcC5lbXBsYWNlLmpzIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciAkID0gcmVxdWlyZV9leHBvcnQoKTsKICAgICAgdmFyIElTX1BVUkUgPSByZXF1aXJlX2lzX3B1cmUoKTsKICAgICAgdmFyICRlbXBsYWNlID0gcmVxdWlyZV9tYXBfZW1wbGFjZSgpOwogICAgICAkKHsgdGFyZ2V0OiAiV2Vha01hcCIsIHByb3RvOiB0cnVlLCByZWFsOiB0cnVlLCBmb3JjZWQ6IElTX1BVUkUgfSwgewogICAgICAgIGVtcGxhY2U6ICRlbXBsYWNlCiAgICAgIH0pOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9jb2xsZWN0aW9uLWZyb20uanMKICB2YXIgcmVxdWlyZV9jb2xsZWN0aW9uX2Zyb20gPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9jb2xsZWN0aW9uLWZyb20uanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIGFDYWxsYWJsZSA9IHJlcXVpcmVfYV9jYWxsYWJsZSgpOwogICAgICB2YXIgYUNvbnN0cnVjdG9yID0gcmVxdWlyZV9hX2NvbnN0cnVjdG9yKCk7CiAgICAgIHZhciBiaW5kID0gcmVxdWlyZV9mdW5jdGlvbl9iaW5kX2NvbnRleHQoKTsKICAgICAgdmFyIGl0ZXJhdGUgPSByZXF1aXJlX2l0ZXJhdGUoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmcm9tKHNvdXJjZSkgewogICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOwogICAgICAgIHZhciBtYXBGbiA9IGxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB2b2lkIDA7CiAgICAgICAgdmFyIG1hcHBpbmcsIGFycmF5LCBuLCBib3VuZEZ1bmN0aW9uOwogICAgICAgIGFDb25zdHJ1Y3Rvcih0aGlzKTsKICAgICAgICBtYXBwaW5nID0gbWFwRm4gIT09IHZvaWQgMDsKICAgICAgICBpZiAobWFwcGluZykKICAgICAgICAgIGFDYWxsYWJsZShtYXBGbik7CiAgICAgICAgaWYgKHNvdXJjZSA9PSB2b2lkIDApCiAgICAgICAgICByZXR1cm4gbmV3IHRoaXMoKTsKICAgICAgICBhcnJheSA9IFtdOwogICAgICAgIGlmIChtYXBwaW5nKSB7CiAgICAgICAgICBuID0gMDsKICAgICAgICAgIGJvdW5kRnVuY3Rpb24gPSBiaW5kKG1hcEZuLCBsZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdm9pZCAwLCAyKTsKICAgICAgICAgIGl0ZXJhdGUoc291cmNlLCBmdW5jdGlvbihuZXh0SXRlbSkgewogICAgICAgICAgICBhcnJheS5wdXNoKGJvdW5kRnVuY3Rpb24obmV4dEl0ZW0sIG4rKykpOwogICAgICAgICAgfSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGl0ZXJhdGUoc291cmNlLCBhcnJheS5wdXNoLCB7IHRoYXQ6IGFycmF5IH0pOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbmV3IHRoaXMoYXJyYXkpOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXNuZXh0LndlYWstbWFwLmZyb20uanMKICB2YXIgcmVxdWlyZV9lc25leHRfd2Vha19tYXBfZnJvbSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lc25leHQud2Vhay1tYXAuZnJvbS5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyICQgPSByZXF1aXJlX2V4cG9ydCgpOwogICAgICB2YXIgZnJvbSA9IHJlcXVpcmVfY29sbGVjdGlvbl9mcm9tKCk7CiAgICAgICQoeyB0YXJnZXQ6ICJXZWFrTWFwIiwgc3RhdDogdHJ1ZSB9LCB7CiAgICAgICAgZnJvbQogICAgICB9KTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvY29sbGVjdGlvbi1vZi5qcwogIHZhciByZXF1aXJlX2NvbGxlY3Rpb25fb2YgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9jb2xsZWN0aW9uLW9mLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gb2YoKSB7CiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7CiAgICAgICAgdmFyIEEgPSBuZXcgQXJyYXkobGVuZ3RoKTsKICAgICAgICB3aGlsZSAobGVuZ3RoLS0pCiAgICAgICAgICBBW2xlbmd0aF0gPSBhcmd1bWVudHNbbGVuZ3RoXTsKICAgICAgICByZXR1cm4gbmV3IHRoaXMoQSk7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lc25leHQud2Vhay1tYXAub2YuanMKICB2YXIgcmVxdWlyZV9lc25leHRfd2Vha19tYXBfb2YgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXNuZXh0LndlYWstbWFwLm9mLmpzIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgJCA9IHJlcXVpcmVfZXhwb3J0KCk7CiAgICAgIHZhciBvZiA9IHJlcXVpcmVfY29sbGVjdGlvbl9vZigpOwogICAgICAkKHsgdGFyZ2V0OiAiV2Vha01hcCIsIHN0YXQ6IHRydWUgfSwgewogICAgICAgIG9mCiAgICAgIH0pOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9jb2xsZWN0aW9uLWRlbGV0ZS1hbGwuanMKICB2YXIgcmVxdWlyZV9jb2xsZWN0aW9uX2RlbGV0ZV9hbGwgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9jb2xsZWN0aW9uLWRlbGV0ZS1hbGwuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIGFDYWxsYWJsZSA9IHJlcXVpcmVfYV9jYWxsYWJsZSgpOwogICAgICB2YXIgYW5PYmplY3QgPSByZXF1aXJlX2FuX29iamVjdCgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkgewogICAgICAgIHZhciBjb2xsZWN0aW9uID0gYW5PYmplY3QodGhpcyk7CiAgICAgICAgdmFyIHJlbW92ZXIgPSBhQ2FsbGFibGUoY29sbGVjdGlvblsiZGVsZXRlIl0pOwogICAgICAgIHZhciBhbGxEZWxldGVkID0gdHJ1ZTsKICAgICAgICB2YXIgd2FzRGVsZXRlZDsKICAgICAgICBmb3IgKHZhciBrID0gMCwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7CiAgICAgICAgICB3YXNEZWxldGVkID0gcmVtb3Zlci5jYWxsKGNvbGxlY3Rpb24sIGFyZ3VtZW50c1trXSk7CiAgICAgICAgICBhbGxEZWxldGVkID0gYWxsRGVsZXRlZCAmJiB3YXNEZWxldGVkOwogICAgICAgIH0KICAgICAgICByZXR1cm4gISFhbGxEZWxldGVkOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXNuZXh0LndlYWstbWFwLmRlbGV0ZS1hbGwuanMKICB2YXIgcmVxdWlyZV9lc25leHRfd2Vha19tYXBfZGVsZXRlX2FsbCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lc25leHQud2Vhay1tYXAuZGVsZXRlLWFsbC5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgJCA9IHJlcXVpcmVfZXhwb3J0KCk7CiAgICAgIHZhciBJU19QVVJFID0gcmVxdWlyZV9pc19wdXJlKCk7CiAgICAgIHZhciBjb2xsZWN0aW9uRGVsZXRlQWxsID0gcmVxdWlyZV9jb2xsZWN0aW9uX2RlbGV0ZV9hbGwoKTsKICAgICAgJCh7IHRhcmdldDogIldlYWtNYXAiLCBwcm90bzogdHJ1ZSwgcmVhbDogdHJ1ZSwgZm9yY2VkOiBJU19QVVJFIH0sIHsKICAgICAgICBkZWxldGVBbGw6IGZ1bmN0aW9uIGRlbGV0ZUFsbCgpIHsKICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uRGVsZXRlQWxsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgfQogICAgICB9KTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvbWFwLXVwc2VydC5qcwogIHZhciByZXF1aXJlX21hcF91cHNlcnQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9tYXAtdXBzZXJ0LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBpc0NhbGxhYmxlID0gcmVxdWlyZV9pc19jYWxsYWJsZSgpOwogICAgICB2YXIgYW5PYmplY3QgPSByZXF1aXJlX2FuX29iamVjdCgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHVwc2VydChrZXksIHVwZGF0ZUZuKSB7CiAgICAgICAgdmFyIG1hcCA9IGFuT2JqZWN0KHRoaXMpOwogICAgICAgIHZhciBpbnNlcnRGbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdm9pZCAwOwogICAgICAgIHZhciB2YWx1ZTsKICAgICAgICBpZiAoIWlzQ2FsbGFibGUodXBkYXRlRm4pICYmICFpc0NhbGxhYmxlKGluc2VydEZuKSkgewogICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCJBdCBsZWFzdCBvbmUgY2FsbGJhY2sgcmVxdWlyZWQiKTsKICAgICAgICB9CiAgICAgICAgaWYgKG1hcC5oYXMoa2V5KSkgewogICAgICAgICAgdmFsdWUgPSBtYXAuZ2V0KGtleSk7CiAgICAgICAgICBpZiAoaXNDYWxsYWJsZSh1cGRhdGVGbikpIHsKICAgICAgICAgICAgdmFsdWUgPSB1cGRhdGVGbih2YWx1ZSk7CiAgICAgICAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIGlmIChpc0NhbGxhYmxlKGluc2VydEZuKSkgewogICAgICAgICAgdmFsdWUgPSBpbnNlcnRGbigpOwogICAgICAgICAgbWFwLnNldChrZXksIHZhbHVlKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHZhbHVlOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXNuZXh0LndlYWstbWFwLnVwc2VydC5qcwogIHZhciByZXF1aXJlX2VzbmV4dF93ZWFrX21hcF91cHNlcnQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXNuZXh0LndlYWstbWFwLnVwc2VydC5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgJCA9IHJlcXVpcmVfZXhwb3J0KCk7CiAgICAgIHZhciBJU19QVVJFID0gcmVxdWlyZV9pc19wdXJlKCk7CiAgICAgIHZhciAkdXBzZXJ0ID0gcmVxdWlyZV9tYXBfdXBzZXJ0KCk7CiAgICAgICQoeyB0YXJnZXQ6ICJXZWFrTWFwIiwgcHJvdG86IHRydWUsIHJlYWw6IHRydWUsIGZvcmNlZDogSVNfUFVSRSB9LCB7CiAgICAgICAgdXBzZXJ0OiAkdXBzZXJ0CiAgICAgIH0pOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ZlYXR1cmVzL3dlYWstbWFwL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfd2Vha19tYXAzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9mZWF0dXJlcy93ZWFrLW1hcC9pbmRleC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHBhcmVudCA9IHJlcXVpcmVfd2Vha19tYXAyKCk7CiAgICAgIHJlcXVpcmVfZXNfc3RyaW5nX2l0ZXJhdG9yKCk7CiAgICAgIHJlcXVpcmVfZXNuZXh0X3dlYWtfbWFwX2VtcGxhY2UoKTsKICAgICAgcmVxdWlyZV9lc25leHRfd2Vha19tYXBfZnJvbSgpOwogICAgICByZXF1aXJlX2VzbmV4dF93ZWFrX21hcF9vZigpOwogICAgICByZXF1aXJlX2VzbmV4dF93ZWFrX21hcF9kZWxldGVfYWxsKCk7CiAgICAgIHJlcXVpcmVfZXNuZXh0X3dlYWtfbWFwX3Vwc2VydCgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcmVudDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy93ZWFrLW1hcC5qcwogIHZhciByZXF1aXJlX3dlYWtfbWFwNCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMvd2Vhay1tYXAuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZV93ZWFrX21hcDMoKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9mZWF0dXJlcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzCiAgdmFyIHJlcXVpcmVfZ2V0X293bl9wcm9wZXJ0eV9kZXNjcmlwdG9yNCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZmVhdHVyZXMvb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHBhcmVudCA9IHJlcXVpcmVfZ2V0X293bl9wcm9wZXJ0eV9kZXNjcmlwdG9yMigpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcmVudDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzCiAgdmFyIHJlcXVpcmVfZ2V0X293bl9wcm9wZXJ0eV9kZXNjcmlwdG9yNSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMvb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlX2dldF9vd25fcHJvcGVydHlfZGVzY3JpcHRvcjQoKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkLmpzCiAgdmFyIHJlcXVpcmVfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVXaWxkY2FyZC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIF90eXBlb2YgPSByZXF1aXJlX3R5cGVvZigpWyJkZWZhdWx0Il07CiAgICAgIHZhciBfV2Vha01hcCA9IHJlcXVpcmVfd2Vha19tYXA0KCk7CiAgICAgIHZhciBfT2JqZWN0JGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZV9kZWZpbmVfcHJvcGVydHk1KCk7CiAgICAgIHZhciBfT2JqZWN0JGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmVfZ2V0X293bl9wcm9wZXJ0eV9kZXNjcmlwdG9yNSgpOwogICAgICBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsKICAgICAgICBpZiAodHlwZW9mIF9XZWFrTWFwICE9PSAiZnVuY3Rpb24iKQogICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IF9XZWFrTWFwKCk7CiAgICAgICAgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgX1dlYWtNYXAoKTsKICAgICAgICByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZTIobm9kZUludGVyb3AyKSB7CiAgICAgICAgICByZXR1cm4gbm9kZUludGVyb3AyID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOwogICAgICAgIH0pKG5vZGVJbnRlcm9wKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7CiAgICAgICAgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsKICAgICAgICAgIHJldHVybiBvYmo7CiAgICAgICAgfQogICAgICAgIGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSAib2JqZWN0IiAmJiB0eXBlb2Ygb2JqICE9PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICAiZGVmYXVsdCI6IG9iagogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsKICAgICAgICBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsKICAgICAgICAgIHJldHVybiBjYWNoZS5nZXQob2JqKTsKICAgICAgICB9CiAgICAgICAgdmFyIG5ld09iaiA9IHt9OwogICAgICAgIHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBfT2JqZWN0JGRlZmluZVByb3BlcnR5ICYmIF9PYmplY3QkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOwogICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHsKICAgICAgICAgIGlmIChrZXkgIT09ICJkZWZhdWx0IiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7CiAgICAgICAgICAgIHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gX09iamVjdCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsKICAgICAgICAgICAgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgewogICAgICAgICAgICAgIF9PYmplY3QkZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgbmV3T2JqWyJkZWZhdWx0Il0gPSBvYmo7CiAgICAgICAgaWYgKGNhY2hlKSB7CiAgICAgICAgICBjYWNoZS5zZXQob2JqLCBuZXdPYmopOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbmV3T2JqOwogICAgICB9CiAgICAgIG1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQ7CiAgICAgIG1vZHVsZS5leHBvcnRzWyJkZWZhdWx0Il0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL29iamVjdC1hc3NpZ24uanMKICB2YXIgcmVxdWlyZV9vYmplY3RfYXNzaWduID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvb2JqZWN0LWFzc2lnbi5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlX2Rlc2NyaXB0b3JzKCk7CiAgICAgIHZhciBmYWlscyA9IHJlcXVpcmVfZmFpbHMoKTsKICAgICAgdmFyIG9iamVjdEtleXMgPSByZXF1aXJlX29iamVjdF9rZXlzKCk7CiAgICAgIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSByZXF1aXJlX29iamVjdF9nZXRfb3duX3Byb3BlcnR5X3N5bWJvbHMoKTsKICAgICAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gcmVxdWlyZV9vYmplY3RfcHJvcGVydHlfaXNfZW51bWVyYWJsZSgpOwogICAgICB2YXIgdG9PYmplY3QgPSByZXF1aXJlX3RvX29iamVjdCgpOwogICAgICB2YXIgSW5kZXhlZE9iamVjdCA9IHJlcXVpcmVfaW5kZXhlZF9vYmplY3QoKTsKICAgICAgdmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduOwogICAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgZmFpbHMoZnVuY3Rpb24oKSB7CiAgICAgICAgaWYgKERFU0NSSVBUT1JTICYmICRhc3NpZ24oeyBiOiAxIH0sICRhc3NpZ24oZGVmaW5lUHJvcGVydHkoe30sICJhIiwgewogICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMsICJiIiwgewogICAgICAgICAgICAgIHZhbHVlOiAzLAogICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlCiAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgIH0pLCB7IGI6IDIgfSkpLmIgIT09IDEpCiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB2YXIgQSA9IHt9OwogICAgICAgIHZhciBCID0ge307CiAgICAgICAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpOwogICAgICAgIHZhciBhbHBoYWJldCA9ICJhYmNkZWZnaGlqa2xtbm9wcXJzdCI7CiAgICAgICAgQVtzeW1ib2xdID0gNzsKICAgICAgICBhbHBoYWJldC5zcGxpdCgiIikuZm9yRWFjaChmdW5jdGlvbihjaHIpIHsKICAgICAgICAgIEJbY2hyXSA9IGNocjsKICAgICAgICB9KTsKICAgICAgICByZXR1cm4gJGFzc2lnbih7fSwgQSlbc3ltYm9sXSAhPSA3IHx8IG9iamVjdEtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oIiIpICE9IGFscGhhYmV0OwogICAgICB9KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgewogICAgICAgIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTsKICAgICAgICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsKICAgICAgICB2YXIgaW5kZXggPSAxOwogICAgICAgIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjsKICAgICAgICB2YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mOwogICAgICAgIHdoaWxlIChhcmd1bWVudHNMZW5ndGggPiBpbmRleCkgewogICAgICAgICAgdmFyIFMgPSBJbmRleGVkT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7CiAgICAgICAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5U3ltYm9scyA/IG9iamVjdEtleXMoUykuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhTKSkgOiBvYmplY3RLZXlzKFMpOwogICAgICAgICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoOwogICAgICAgICAgdmFyIGogPSAwOwogICAgICAgICAgdmFyIGtleTsKICAgICAgICAgIHdoaWxlIChsZW5ndGggPiBqKSB7CiAgICAgICAgICAgIGtleSA9IGtleXNbaisrXTsKICAgICAgICAgICAgaWYgKCFERVNDUklQVE9SUyB8fCBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKFMsIGtleSkpCiAgICAgICAgICAgICAgVFtrZXldID0gU1trZXldOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gVDsKICAgICAgfSA6ICRhc3NpZ247CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5vYmplY3QuYXNzaWduLmpzCiAgdmFyIHJlcXVpcmVfZXNfb2JqZWN0X2Fzc2lnbiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5vYmplY3QuYXNzaWduLmpzIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgJCA9IHJlcXVpcmVfZXhwb3J0KCk7CiAgICAgIHZhciBhc3NpZ24gPSByZXF1aXJlX29iamVjdF9hc3NpZ24oKTsKICAgICAgJCh7IHRhcmdldDogIk9iamVjdCIsIHN0YXQ6IHRydWUsIGZvcmNlZDogT2JqZWN0LmFzc2lnbiAhPT0gYXNzaWduIH0sIHsKICAgICAgICBhc3NpZ24KICAgICAgfSk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvb2JqZWN0L2Fzc2lnbi5qcwogIHZhciByZXF1aXJlX2Fzc2lnbiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvb2JqZWN0L2Fzc2lnbi5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgcmVxdWlyZV9lc19vYmplY3RfYXNzaWduKCk7CiAgICAgIHZhciBwYXRoID0gcmVxdWlyZV9wYXRoKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGF0aC5PYmplY3QuYXNzaWduOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9vYmplY3QvYXNzaWduLmpzCiAgdmFyIHJlcXVpcmVfYXNzaWduMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL29iamVjdC9hc3NpZ24uanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBwYXJlbnQgPSByZXF1aXJlX2Fzc2lnbigpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcmVudDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvb2JqZWN0L2Fzc2lnbi5qcwogIHZhciByZXF1aXJlX2Fzc2lnbjMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9vYmplY3QvYXNzaWduLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVfYXNzaWduMigpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhIb2xlcy5qcwogIHZhciByZXF1aXJlX2FycmF5V2l0aEhvbGVzMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aEhvbGVzLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7CiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkKICAgICAgICAgIHJldHVybiBhcnI7CiAgICAgIH0KICAgICAgbW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRoSG9sZXM7CiAgICAgIG1vZHVsZS5leHBvcnRzWyJkZWZhdWx0Il0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzCiAgdmFyIHJlcXVpcmVfaXRlcmFibGVUb0FycmF5TGltaXQyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5TGltaXQuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsKICAgICAgICB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSAidW5kZWZpbmVkIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbIkBAaXRlcmF0b3IiXTsKICAgICAgICBpZiAoX2kgPT0gbnVsbCkKICAgICAgICAgIHJldHVybjsKICAgICAgICB2YXIgX2FyciA9IFtdOwogICAgICAgIHZhciBfbiA9IHRydWU7CiAgICAgICAgdmFyIF9kID0gZmFsc2U7CiAgICAgICAgdmFyIF9zLCBfZTsKICAgICAgICB0cnkgewogICAgICAgICAgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgewogICAgICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpOwogICAgICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgIF9kID0gdHJ1ZTsKICAgICAgICAgIF9lID0gZXJyOwogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBpZiAoIV9uICYmIF9pWyJyZXR1cm4iXSAhPSBudWxsKQogICAgICAgICAgICAgIF9pWyJyZXR1cm4iXSgpOwogICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgaWYgKF9kKQogICAgICAgICAgICAgIHRocm93IF9lOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gX2FycjsKICAgICAgfQogICAgICBtb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdDsKICAgICAgbW9kdWxlLmV4cG9ydHNbImRlZmF1bHQiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlMaWtlVG9BcnJheS5qcwogIHZhciByZXF1aXJlX2FycmF5TGlrZVRvQXJyYXkyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlMaWtlVG9BcnJheS5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsKICAgICAgICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkKICAgICAgICAgIGxlbiA9IGFyci5sZW5ndGg7CiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgICBhcnIyW2ldID0gYXJyW2ldOwogICAgICAgIH0KICAgICAgICByZXR1cm4gYXJyMjsKICAgICAgfQogICAgICBtb2R1bGUuZXhwb3J0cyA9IF9hcnJheUxpa2VUb0FycmF5OwogICAgICBtb2R1bGUuZXhwb3J0c1siZGVmYXVsdCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcwogIHZhciByZXF1aXJlX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5MiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmVfYXJyYXlMaWtlVG9BcnJheTIoKTsKICAgICAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgewogICAgICAgIGlmICghbykKICAgICAgICAgIHJldHVybjsKICAgICAgICBpZiAodHlwZW9mIG8gPT09ICJzdHJpbmciKQogICAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsKICAgICAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7CiAgICAgICAgaWYgKG4gPT09ICJPYmplY3QiICYmIG8uY29uc3RydWN0b3IpCiAgICAgICAgICBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOwogICAgICAgIGlmIChuID09PSAiTWFwIiB8fCBuID09PSAiU2V0IikKICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKG8pOwogICAgICAgIGlmIChuID09PSAiQXJndW1lbnRzIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkKICAgICAgICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7CiAgICAgIH0KICAgICAgbW9kdWxlLmV4cG9ydHMgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXk7CiAgICAgIG1vZHVsZS5leHBvcnRzWyJkZWZhdWx0Il0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlUmVzdC5qcwogIHZhciByZXF1aXJlX25vbkl0ZXJhYmxlUmVzdDIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVJlc3QuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC4iKTsKICAgICAgfQogICAgICBtb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVJlc3Q7CiAgICAgIG1vZHVsZS5leHBvcnRzWyJkZWZhdWx0Il0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanMKICB2YXIgcmVxdWlyZV9zbGljZWRUb0FycmF5MiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBhcnJheVdpdGhIb2xlcyA9IHJlcXVpcmVfYXJyYXlXaXRoSG9sZXMyKCk7CiAgICAgIHZhciBpdGVyYWJsZVRvQXJyYXlMaW1pdCA9IHJlcXVpcmVfaXRlcmFibGVUb0FycmF5TGltaXQyKCk7CiAgICAgIHZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmVfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkyKCk7CiAgICAgIHZhciBub25JdGVyYWJsZVJlc3QgPSByZXF1aXJlX25vbkl0ZXJhYmxlUmVzdDIoKTsKICAgICAgZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7CiAgICAgICAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpOwogICAgICB9CiAgICAgIG1vZHVsZS5leHBvcnRzID0gX3NsaWNlZFRvQXJyYXk7CiAgICAgIG1vZHVsZS5leHBvcnRzWyJkZWZhdWx0Il0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcwogIHZhciByZXF1aXJlX3JlZ2VuZXJhdG9yMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlX3J1bnRpbWUoKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcwogIHZhciByZXF1aXJlX2FzeW5jVG9HZW5lcmF0b3IyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykgewogICAgICAgIHRyeSB7CiAgICAgICAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7CiAgICAgICAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOwogICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgICByZWplY3QoZXJyb3IpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBpZiAoaW5mby5kb25lKSB7CiAgICAgICAgICByZXNvbHZlKHZhbHVlKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgewogICAgICAgIHJldHVybiBmdW5jdGlvbigpIHsKICAgICAgICAgIHZhciBzZWxmMiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7CiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7CiAgICAgICAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmMiwgYXJncyk7CiAgICAgICAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7CiAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCAibmV4dCIsIHZhbHVlKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7CiAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCAidGhyb3ciLCBlcnIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIF9uZXh0KHZvaWQgMCk7CiAgICAgICAgICB9KTsKICAgICAgICB9OwogICAgICB9CiAgICAgIG1vZHVsZS5leHBvcnRzID0gX2FzeW5jVG9HZW5lcmF0b3I7CiAgICAgIG1vZHVsZS5leHBvcnRzWyJkZWZhdWx0Il0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9jb21tb24uanMKICB2YXIgcmVxdWlyZV9jb21tb24yID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL2NvbW1vbi5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIFRZUEVEX09LID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICJ1bmRlZmluZWQiICYmIHR5cGVvZiBVaW50MTZBcnJheSAhPT0gInVuZGVmaW5lZCIgJiYgdHlwZW9mIEludDMyQXJyYXkgIT09ICJ1bmRlZmluZWQiOwogICAgICBmdW5jdGlvbiBfaGFzKG9iaiwga2V5KSB7CiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7CiAgICAgIH0KICAgICAgZXhwb3J0cy5hc3NpZ24gPSBmdW5jdGlvbihvYmopIHsKICAgICAgICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7CiAgICAgICAgd2hpbGUgKHNvdXJjZXMubGVuZ3RoKSB7CiAgICAgICAgICB2YXIgc291cmNlID0gc291cmNlcy5zaGlmdCgpOwogICAgICAgICAgaWYgKCFzb3VyY2UpIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gIm9iamVjdCIpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAibXVzdCBiZSBub24tb2JqZWN0Iik7CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKHZhciBwIGluIHNvdXJjZSkgewogICAgICAgICAgICBpZiAoX2hhcyhzb3VyY2UsIHApKSB7CiAgICAgICAgICAgICAgb2JqW3BdID0gc291cmNlW3BdOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBvYmo7CiAgICAgIH07CiAgICAgIGV4cG9ydHMuc2hyaW5rQnVmID0gZnVuY3Rpb24oYnVmLCBzaXplKSB7CiAgICAgICAgaWYgKGJ1Zi5sZW5ndGggPT09IHNpemUpIHsKICAgICAgICAgIHJldHVybiBidWY7CiAgICAgICAgfQogICAgICAgIGlmIChidWYuc3ViYXJyYXkpIHsKICAgICAgICAgIHJldHVybiBidWYuc3ViYXJyYXkoMCwgc2l6ZSk7CiAgICAgICAgfQogICAgICAgIGJ1Zi5sZW5ndGggPSBzaXplOwogICAgICAgIHJldHVybiBidWY7CiAgICAgIH07CiAgICAgIHZhciBmblR5cGVkID0gewogICAgICAgIGFycmF5U2V0OiBmdW5jdGlvbihkZXN0LCBzcmMsIHNyY19vZmZzLCBsZW4sIGRlc3Rfb2ZmcykgewogICAgICAgICAgaWYgKHNyYy5zdWJhcnJheSAmJiBkZXN0LnN1YmFycmF5KSB7CiAgICAgICAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNfb2Zmcywgc3JjX29mZnMgKyBsZW4pLCBkZXN0X29mZnMpOwogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTsKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uKGNodW5rcykgewogICAgICAgICAgdmFyIGksIGwsIGxlbiwgcG9zLCBjaHVuaywgcmVzdWx0OwogICAgICAgICAgbGVuID0gMDsKICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgICAgIGxlbiArPSBjaHVua3NbaV0ubGVuZ3RoOwogICAgICAgICAgfQogICAgICAgICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuKTsKICAgICAgICAgIHBvcyA9IDA7CiAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICBjaHVuayA9IGNodW5rc1tpXTsKICAgICAgICAgICAgcmVzdWx0LnNldChjaHVuaywgcG9zKTsKICAgICAgICAgICAgcG9zICs9IGNodW5rLmxlbmd0aDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgfQogICAgICB9OwogICAgICB2YXIgZm5VbnR5cGVkID0gewogICAgICAgIGFycmF5U2V0OiBmdW5jdGlvbihkZXN0LCBzcmMsIHNyY19vZmZzLCBsZW4sIGRlc3Rfb2ZmcykgewogICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgewogICAgICAgICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbihjaHVua3MpIHsKICAgICAgICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIGNodW5rcyk7CiAgICAgICAgfQogICAgICB9OwogICAgICBleHBvcnRzLnNldFR5cGVkID0gZnVuY3Rpb24ob24pIHsKICAgICAgICBpZiAob24pIHsKICAgICAgICAgIGV4cG9ydHMuQnVmOCA9IFVpbnQ4QXJyYXk7CiAgICAgICAgICBleHBvcnRzLkJ1ZjE2ID0gVWludDE2QXJyYXk7CiAgICAgICAgICBleHBvcnRzLkJ1ZjMyID0gSW50MzJBcnJheTsKICAgICAgICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVHlwZWQpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBleHBvcnRzLkJ1ZjggPSBBcnJheTsKICAgICAgICAgIGV4cG9ydHMuQnVmMTYgPSBBcnJheTsKICAgICAgICAgIGV4cG9ydHMuQnVmMzIgPSBBcnJheTsKICAgICAgICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVW50eXBlZCk7CiAgICAgICAgfQogICAgICB9OwogICAgICBleHBvcnRzLnNldFR5cGVkKFRZUEVEX09LKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMKICB2YXIgcmVxdWlyZV90cmVlcyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3RyZWVzLmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgdXRpbHMgPSByZXF1aXJlX2NvbW1vbjIoKTsKICAgICAgdmFyIFpfRklYRUQgPSA0OwogICAgICB2YXIgWl9CSU5BUlkgPSAwOwogICAgICB2YXIgWl9URVhUID0gMTsKICAgICAgdmFyIFpfVU5LTk9XTiA9IDI7CiAgICAgIGZ1bmN0aW9uIHplcm8oYnVmKSB7CiAgICAgICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7CiAgICAgICAgd2hpbGUgKC0tbGVuID49IDApIHsKICAgICAgICAgIGJ1ZltsZW5dID0gMDsKICAgICAgICB9CiAgICAgIH0KICAgICAgdmFyIFNUT1JFRF9CTE9DSyA9IDA7CiAgICAgIHZhciBTVEFUSUNfVFJFRVMgPSAxOwogICAgICB2YXIgRFlOX1RSRUVTID0gMjsKICAgICAgdmFyIE1JTl9NQVRDSCA9IDM7CiAgICAgIHZhciBNQVhfTUFUQ0ggPSAyNTg7CiAgICAgIHZhciBMRU5HVEhfQ09ERVMgPSAyOTsKICAgICAgdmFyIExJVEVSQUxTID0gMjU2OwogICAgICB2YXIgTF9DT0RFUyA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUzsKICAgICAgdmFyIERfQ09ERVMgPSAzMDsKICAgICAgdmFyIEJMX0NPREVTID0gMTk7CiAgICAgIHZhciBIRUFQX1NJWkUgPSAyICogTF9DT0RFUyArIDE7CiAgICAgIHZhciBNQVhfQklUUyA9IDE1OwogICAgICB2YXIgQnVmX3NpemUgPSAxNjsKICAgICAgdmFyIE1BWF9CTF9CSVRTID0gNzsKICAgICAgdmFyIEVORF9CTE9DSyA9IDI1NjsKICAgICAgdmFyIFJFUF8zXzYgPSAxNjsKICAgICAgdmFyIFJFUFpfM18xMCA9IDE3OwogICAgICB2YXIgUkVQWl8xMV8xMzggPSAxODsKICAgICAgdmFyIGV4dHJhX2xiaXRzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDEsIDEsIDEsIDEsIDIsIDIsIDIsIDIsIDMsIDMsIDMsIDMsIDQsIDQsIDQsIDQsIDUsIDUsIDUsIDUsIDBdOwogICAgICB2YXIgZXh0cmFfZGJpdHMgPSBbMCwgMCwgMCwgMCwgMSwgMSwgMiwgMiwgMywgMywgNCwgNCwgNSwgNSwgNiwgNiwgNywgNywgOCwgOCwgOSwgOSwgMTAsIDEwLCAxMSwgMTEsIDEyLCAxMiwgMTMsIDEzXTsKICAgICAgdmFyIGV4dHJhX2JsYml0cyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAyLCAzLCA3XTsKICAgICAgdmFyIGJsX29yZGVyID0gWzE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTVdOwogICAgICB2YXIgRElTVF9DT0RFX0xFTiA9IDUxMjsKICAgICAgdmFyIHN0YXRpY19sdHJlZSA9IG5ldyBBcnJheSgoTF9DT0RFUyArIDIpICogMik7CiAgICAgIHplcm8oc3RhdGljX2x0cmVlKTsKICAgICAgdmFyIHN0YXRpY19kdHJlZSA9IG5ldyBBcnJheShEX0NPREVTICogMik7CiAgICAgIHplcm8oc3RhdGljX2R0cmVlKTsKICAgICAgdmFyIF9kaXN0X2NvZGUgPSBuZXcgQXJyYXkoRElTVF9DT0RFX0xFTik7CiAgICAgIHplcm8oX2Rpc3RfY29kZSk7CiAgICAgIHZhciBfbGVuZ3RoX2NvZGUgPSBuZXcgQXJyYXkoTUFYX01BVENIIC0gTUlOX01BVENIICsgMSk7CiAgICAgIHplcm8oX2xlbmd0aF9jb2RlKTsKICAgICAgdmFyIGJhc2VfbGVuZ3RoID0gbmV3IEFycmF5KExFTkdUSF9DT0RFUyk7CiAgICAgIHplcm8oYmFzZV9sZW5ndGgpOwogICAgICB2YXIgYmFzZV9kaXN0ID0gbmV3IEFycmF5KERfQ09ERVMpOwogICAgICB6ZXJvKGJhc2VfZGlzdCk7CiAgICAgIGZ1bmN0aW9uIFN0YXRpY1RyZWVEZXNjKHN0YXRpY190cmVlLCBleHRyYV9iaXRzLCBleHRyYV9iYXNlLCBlbGVtcywgbWF4X2xlbmd0aCkgewogICAgICAgIHRoaXMuc3RhdGljX3RyZWUgPSBzdGF0aWNfdHJlZTsKICAgICAgICB0aGlzLmV4dHJhX2JpdHMgPSBleHRyYV9iaXRzOwogICAgICAgIHRoaXMuZXh0cmFfYmFzZSA9IGV4dHJhX2Jhc2U7CiAgICAgICAgdGhpcy5lbGVtcyA9IGVsZW1zOwogICAgICAgIHRoaXMubWF4X2xlbmd0aCA9IG1heF9sZW5ndGg7CiAgICAgICAgdGhpcy5oYXNfc3RyZWUgPSBzdGF0aWNfdHJlZSAmJiBzdGF0aWNfdHJlZS5sZW5ndGg7CiAgICAgIH0KICAgICAgdmFyIHN0YXRpY19sX2Rlc2M7CiAgICAgIHZhciBzdGF0aWNfZF9kZXNjOwogICAgICB2YXIgc3RhdGljX2JsX2Rlc2M7CiAgICAgIGZ1bmN0aW9uIFRyZWVEZXNjKGR5bl90cmVlLCBzdGF0X2Rlc2MpIHsKICAgICAgICB0aGlzLmR5bl90cmVlID0gZHluX3RyZWU7CiAgICAgICAgdGhpcy5tYXhfY29kZSA9IDA7CiAgICAgICAgdGhpcy5zdGF0X2Rlc2MgPSBzdGF0X2Rlc2M7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZF9jb2RlKGRpc3QpIHsKICAgICAgICByZXR1cm4gZGlzdCA8IDI1NiA/IF9kaXN0X2NvZGVbZGlzdF0gOiBfZGlzdF9jb2RlWzI1NiArIChkaXN0ID4+PiA3KV07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcHV0X3Nob3J0KHMsIHcpIHsKICAgICAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHcgJiAyNTU7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSB3ID4+PiA4ICYgMjU1OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHNlbmRfYml0cyhzLCB2YWx1ZSwgbGVuZ3RoKSB7CiAgICAgICAgaWYgKHMuYmlfdmFsaWQgPiBCdWZfc2l6ZSAtIGxlbmd0aCkgewogICAgICAgICAgcy5iaV9idWYgfD0gdmFsdWUgPDwgcy5iaV92YWxpZCAmIDY1NTM1OwogICAgICAgICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTsKICAgICAgICAgIHMuYmlfYnVmID0gdmFsdWUgPj4gQnVmX3NpemUgLSBzLmJpX3ZhbGlkOwogICAgICAgICAgcy5iaV92YWxpZCArPSBsZW5ndGggLSBCdWZfc2l6ZTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcy5iaV9idWYgfD0gdmFsdWUgPDwgcy5iaV92YWxpZCAmIDY1NTM1OwogICAgICAgICAgcy5iaV92YWxpZCArPSBsZW5ndGg7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIHNlbmRfY29kZShzLCBjLCB0cmVlKSB7CiAgICAgICAgc2VuZF9iaXRzKHMsIHRyZWVbYyAqIDJdLCB0cmVlW2MgKiAyICsgMV0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJpX3JldmVyc2UoY29kZSwgbGVuKSB7CiAgICAgICAgdmFyIHJlcyA9IDA7CiAgICAgICAgZG8gewogICAgICAgICAgcmVzIHw9IGNvZGUgJiAxOwogICAgICAgICAgY29kZSA+Pj49IDE7CiAgICAgICAgICByZXMgPDw9IDE7CiAgICAgICAgfSB3aGlsZSAoLS1sZW4gPiAwKTsKICAgICAgICByZXR1cm4gcmVzID4+PiAxOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJpX2ZsdXNoKHMpIHsKICAgICAgICBpZiAocy5iaV92YWxpZCA9PT0gMTYpIHsKICAgICAgICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7CiAgICAgICAgICBzLmJpX2J1ZiA9IDA7CiAgICAgICAgICBzLmJpX3ZhbGlkID0gMDsKICAgICAgICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPj0gOCkgewogICAgICAgICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZiAmIDI1NTsKICAgICAgICAgIHMuYmlfYnVmID4+PSA4OwogICAgICAgICAgcy5iaV92YWxpZCAtPSA4OwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBnZW5fYml0bGVuKHMsIGRlc2MpIHsKICAgICAgICB2YXIgdHJlZSA9IGRlc2MuZHluX3RyZWU7CiAgICAgICAgdmFyIG1heF9jb2RlID0gZGVzYy5tYXhfY29kZTsKICAgICAgICB2YXIgc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTsKICAgICAgICB2YXIgaGFzX3N0cmVlID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlOwogICAgICAgIHZhciBleHRyYSA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2JpdHM7CiAgICAgICAgdmFyIGJhc2UgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iYXNlOwogICAgICAgIHZhciBtYXhfbGVuZ3RoID0gZGVzYy5zdGF0X2Rlc2MubWF4X2xlbmd0aDsKICAgICAgICB2YXIgaDsKICAgICAgICB2YXIgbiwgbTsKICAgICAgICB2YXIgYml0czsKICAgICAgICB2YXIgeGJpdHM7CiAgICAgICAgdmFyIGY7CiAgICAgICAgdmFyIG92ZXJmbG93ID0gMDsKICAgICAgICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHsKICAgICAgICAgIHMuYmxfY291bnRbYml0c10gPSAwOwogICAgICAgIH0KICAgICAgICB0cmVlW3MuaGVhcFtzLmhlYXBfbWF4XSAqIDIgKyAxXSA9IDA7CiAgICAgICAgZm9yIChoID0gcy5oZWFwX21heCArIDE7IGggPCBIRUFQX1NJWkU7IGgrKykgewogICAgICAgICAgbiA9IHMuaGVhcFtoXTsKICAgICAgICAgIGJpdHMgPSB0cmVlW3RyZWVbbiAqIDIgKyAxXSAqIDIgKyAxXSArIDE7CiAgICAgICAgICBpZiAoYml0cyA+IG1heF9sZW5ndGgpIHsKICAgICAgICAgICAgYml0cyA9IG1heF9sZW5ndGg7CiAgICAgICAgICAgIG92ZXJmbG93Kys7CiAgICAgICAgICB9CiAgICAgICAgICB0cmVlW24gKiAyICsgMV0gPSBiaXRzOwogICAgICAgICAgaWYgKG4gPiBtYXhfY29kZSkgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIHMuYmxfY291bnRbYml0c10rKzsKICAgICAgICAgIHhiaXRzID0gMDsKICAgICAgICAgIGlmIChuID49IGJhc2UpIHsKICAgICAgICAgICAgeGJpdHMgPSBleHRyYVtuIC0gYmFzZV07CiAgICAgICAgICB9CiAgICAgICAgICBmID0gdHJlZVtuICogMl07CiAgICAgICAgICBzLm9wdF9sZW4gKz0gZiAqIChiaXRzICsgeGJpdHMpOwogICAgICAgICAgaWYgKGhhc19zdHJlZSkgewogICAgICAgICAgICBzLnN0YXRpY19sZW4gKz0gZiAqIChzdHJlZVtuICogMiArIDFdICsgeGJpdHMpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAob3ZlcmZsb3cgPT09IDApIHsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgZG8gewogICAgICAgICAgYml0cyA9IG1heF9sZW5ndGggLSAxOwogICAgICAgICAgd2hpbGUgKHMuYmxfY291bnRbYml0c10gPT09IDApIHsKICAgICAgICAgICAgYml0cy0tOwogICAgICAgICAgfQogICAgICAgICAgcy5ibF9jb3VudFtiaXRzXS0tOwogICAgICAgICAgcy5ibF9jb3VudFtiaXRzICsgMV0gKz0gMjsKICAgICAgICAgIHMuYmxfY291bnRbbWF4X2xlbmd0aF0tLTsKICAgICAgICAgIG92ZXJmbG93IC09IDI7CiAgICAgICAgfSB3aGlsZSAob3ZlcmZsb3cgPiAwKTsKICAgICAgICBmb3IgKGJpdHMgPSBtYXhfbGVuZ3RoOyBiaXRzICE9PSAwOyBiaXRzLS0pIHsKICAgICAgICAgIG4gPSBzLmJsX2NvdW50W2JpdHNdOwogICAgICAgICAgd2hpbGUgKG4gIT09IDApIHsKICAgICAgICAgICAgbSA9IHMuaGVhcFstLWhdOwogICAgICAgICAgICBpZiAobSA+IG1heF9jb2RlKSB7CiAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHRyZWVbbSAqIDIgKyAxXSAhPT0gYml0cykgewogICAgICAgICAgICAgIHMub3B0X2xlbiArPSAoYml0cyAtIHRyZWVbbSAqIDIgKyAxXSkgKiB0cmVlW20gKiAyXTsKICAgICAgICAgICAgICB0cmVlW20gKiAyICsgMV0gPSBiaXRzOwogICAgICAgICAgICB9CiAgICAgICAgICAgIG4tLTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBibF9jb3VudCkgewogICAgICAgIHZhciBuZXh0X2NvZGUgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTsKICAgICAgICB2YXIgY29kZSA9IDA7CiAgICAgICAgdmFyIGJpdHM7CiAgICAgICAgdmFyIG47CiAgICAgICAgZm9yIChiaXRzID0gMTsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7CiAgICAgICAgICBuZXh0X2NvZGVbYml0c10gPSBjb2RlID0gY29kZSArIGJsX2NvdW50W2JpdHMgLSAxXSA8PCAxOwogICAgICAgIH0KICAgICAgICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHsKICAgICAgICAgIHZhciBsZW4gPSB0cmVlW24gKiAyICsgMV07CiAgICAgICAgICBpZiAobGVuID09PSAwKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgdHJlZVtuICogMl0gPSBiaV9yZXZlcnNlKG5leHRfY29kZVtsZW5dKyssIGxlbik7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIHRyX3N0YXRpY19pbml0KCkgewogICAgICAgIHZhciBuOwogICAgICAgIHZhciBiaXRzOwogICAgICAgIHZhciBsZW5ndGg7CiAgICAgICAgdmFyIGNvZGU7CiAgICAgICAgdmFyIGRpc3Q7CiAgICAgICAgdmFyIGJsX2NvdW50ID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7CiAgICAgICAgbGVuZ3RoID0gMDsKICAgICAgICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgTEVOR1RIX0NPREVTIC0gMTsgY29kZSsrKSB7CiAgICAgICAgICBiYXNlX2xlbmd0aFtjb2RlXSA9IGxlbmd0aDsKICAgICAgICAgIGZvciAobiA9IDA7IG4gPCAxIDw8IGV4dHJhX2xiaXRzW2NvZGVdOyBuKyspIHsKICAgICAgICAgICAgX2xlbmd0aF9jb2RlW2xlbmd0aCsrXSA9IGNvZGU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIF9sZW5ndGhfY29kZVtsZW5ndGggLSAxXSA9IGNvZGU7CiAgICAgICAgZGlzdCA9IDA7CiAgICAgICAgZm9yIChjb2RlID0gMDsgY29kZSA8IDE2OyBjb2RlKyspIHsKICAgICAgICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3Q7CiAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgMSA8PCBleHRyYV9kYml0c1tjb2RlXTsgbisrKSB7CiAgICAgICAgICAgIF9kaXN0X2NvZGVbZGlzdCsrXSA9IGNvZGU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGRpc3QgPj49IDc7CiAgICAgICAgZm9yICg7IGNvZGUgPCBEX0NPREVTOyBjb2RlKyspIHsKICAgICAgICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3QgPDwgNzsKICAgICAgICAgIGZvciAobiA9IDA7IG4gPCAxIDw8IGV4dHJhX2RiaXRzW2NvZGVdIC0gNzsgbisrKSB7CiAgICAgICAgICAgIF9kaXN0X2NvZGVbMjU2ICsgZGlzdCsrXSA9IGNvZGU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykgewogICAgICAgICAgYmxfY291bnRbYml0c10gPSAwOwogICAgICAgIH0KICAgICAgICBuID0gMDsKICAgICAgICB3aGlsZSAobiA8PSAxNDMpIHsKICAgICAgICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdID0gODsKICAgICAgICAgIG4rKzsKICAgICAgICAgIGJsX2NvdW50WzhdKys7CiAgICAgICAgfQogICAgICAgIHdoaWxlIChuIDw9IDI1NSkgewogICAgICAgICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0gPSA5OwogICAgICAgICAgbisrOwogICAgICAgICAgYmxfY291bnRbOV0rKzsKICAgICAgICB9CiAgICAgICAgd2hpbGUgKG4gPD0gMjc5KSB7CiAgICAgICAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXSA9IDc7CiAgICAgICAgICBuKys7CiAgICAgICAgICBibF9jb3VudFs3XSsrOwogICAgICAgIH0KICAgICAgICB3aGlsZSAobiA8PSAyODcpIHsKICAgICAgICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdID0gODsKICAgICAgICAgIG4rKzsKICAgICAgICAgIGJsX2NvdW50WzhdKys7CiAgICAgICAgfQogICAgICAgIGdlbl9jb2RlcyhzdGF0aWNfbHRyZWUsIExfQ09ERVMgKyAxLCBibF9jb3VudCk7CiAgICAgICAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7IG4rKykgewogICAgICAgICAgc3RhdGljX2R0cmVlW24gKiAyICsgMV0gPSA1OwogICAgICAgICAgc3RhdGljX2R0cmVlW24gKiAyXSA9IGJpX3JldmVyc2UobiwgNSk7CiAgICAgICAgfQogICAgICAgIHN0YXRpY19sX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2x0cmVlLCBleHRyYV9sYml0cywgTElURVJBTFMgKyAxLCBMX0NPREVTLCBNQVhfQklUUyk7CiAgICAgICAgc3RhdGljX2RfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfZHRyZWUsIGV4dHJhX2RiaXRzLCAwLCBEX0NPREVTLCBNQVhfQklUUyk7CiAgICAgICAgc3RhdGljX2JsX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2MobmV3IEFycmF5KDApLCBleHRyYV9ibGJpdHMsIDAsIEJMX0NPREVTLCBNQVhfQkxfQklUUyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5pdF9ibG9jayhzKSB7CiAgICAgICAgdmFyIG47CiAgICAgICAgZm9yIChuID0gMDsgbiA8IExfQ09ERVM7IG4rKykgewogICAgICAgICAgcy5keW5fbHRyZWVbbiAqIDJdID0gMDsKICAgICAgICB9CiAgICAgICAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7IG4rKykgewogICAgICAgICAgcy5keW5fZHRyZWVbbiAqIDJdID0gMDsKICAgICAgICB9CiAgICAgICAgZm9yIChuID0gMDsgbiA8IEJMX0NPREVTOyBuKyspIHsKICAgICAgICAgIHMuYmxfdHJlZVtuICogMl0gPSAwOwogICAgICAgIH0KICAgICAgICBzLmR5bl9sdHJlZVtFTkRfQkxPQ0sgKiAyXSA9IDE7CiAgICAgICAgcy5vcHRfbGVuID0gcy5zdGF0aWNfbGVuID0gMDsKICAgICAgICBzLmxhc3RfbGl0ID0gcy5tYXRjaGVzID0gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBiaV93aW5kdXAocykgewogICAgICAgIGlmIChzLmJpX3ZhbGlkID4gOCkgewogICAgICAgICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTsKICAgICAgICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPiAwKSB7CiAgICAgICAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmOwogICAgICAgIH0KICAgICAgICBzLmJpX2J1ZiA9IDA7CiAgICAgICAgcy5iaV92YWxpZCA9IDA7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gY29weV9ibG9jayhzLCBidWYsIGxlbiwgaGVhZGVyKSB7CiAgICAgICAgYmlfd2luZHVwKHMpOwogICAgICAgIGlmIChoZWFkZXIpIHsKICAgICAgICAgIHB1dF9zaG9ydChzLCBsZW4pOwogICAgICAgICAgcHV0X3Nob3J0KHMsIH5sZW4pOwogICAgICAgIH0KICAgICAgICB1dGlscy5hcnJheVNldChzLnBlbmRpbmdfYnVmLCBzLndpbmRvdywgYnVmLCBsZW4sIHMucGVuZGluZyk7CiAgICAgICAgcy5wZW5kaW5nICs9IGxlbjsKICAgICAgfQogICAgICBmdW5jdGlvbiBzbWFsbGVyKHRyZWUsIG4sIG0sIGRlcHRoKSB7CiAgICAgICAgdmFyIF9uMiA9IG4gKiAyOwogICAgICAgIHZhciBfbTIgPSBtICogMjsKICAgICAgICByZXR1cm4gdHJlZVtfbjJdIDwgdHJlZVtfbTJdIHx8IHRyZWVbX24yXSA9PT0gdHJlZVtfbTJdICYmIGRlcHRoW25dIDw9IGRlcHRoW21dOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBxZG93bmhlYXAocywgdHJlZSwgaykgewogICAgICAgIHZhciB2ID0gcy5oZWFwW2tdOwogICAgICAgIHZhciBqID0gayA8PCAxOwogICAgICAgIHdoaWxlIChqIDw9IHMuaGVhcF9sZW4pIHsKICAgICAgICAgIGlmIChqIDwgcy5oZWFwX2xlbiAmJiBzbWFsbGVyKHRyZWUsIHMuaGVhcFtqICsgMV0sIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHsKICAgICAgICAgICAgaisrOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHNtYWxsZXIodHJlZSwgdiwgcy5oZWFwW2pdLCBzLmRlcHRoKSkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIHMuaGVhcFtrXSA9IHMuaGVhcFtqXTsKICAgICAgICAgIGsgPSBqOwogICAgICAgICAgaiA8PD0gMTsKICAgICAgICB9CiAgICAgICAgcy5oZWFwW2tdID0gdjsKICAgICAgfQogICAgICBmdW5jdGlvbiBjb21wcmVzc19ibG9jayhzLCBsdHJlZSwgZHRyZWUpIHsKICAgICAgICB2YXIgZGlzdDsKICAgICAgICB2YXIgbGM7CiAgICAgICAgdmFyIGx4ID0gMDsKICAgICAgICB2YXIgY29kZTsKICAgICAgICB2YXIgZXh0cmE7CiAgICAgICAgaWYgKHMubGFzdF9saXQgIT09IDApIHsKICAgICAgICAgIGRvIHsKICAgICAgICAgICAgZGlzdCA9IHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMl0gPDwgOCB8IHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMiArIDFdOwogICAgICAgICAgICBsYyA9IHMucGVuZGluZ19idWZbcy5sX2J1ZiArIGx4XTsKICAgICAgICAgICAgbHgrKzsKICAgICAgICAgICAgaWYgKGRpc3QgPT09IDApIHsKICAgICAgICAgICAgICBzZW5kX2NvZGUocywgbGMsIGx0cmVlKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBjb2RlID0gX2xlbmd0aF9jb2RlW2xjXTsKICAgICAgICAgICAgICBzZW5kX2NvZGUocywgY29kZSArIExJVEVSQUxTICsgMSwgbHRyZWUpOwogICAgICAgICAgICAgIGV4dHJhID0gZXh0cmFfbGJpdHNbY29kZV07CiAgICAgICAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7CiAgICAgICAgICAgICAgICBsYyAtPSBiYXNlX2xlbmd0aFtjb2RlXTsKICAgICAgICAgICAgICAgIHNlbmRfYml0cyhzLCBsYywgZXh0cmEpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBkaXN0LS07CiAgICAgICAgICAgICAgY29kZSA9IGRfY29kZShkaXN0KTsKICAgICAgICAgICAgICBzZW5kX2NvZGUocywgY29kZSwgZHRyZWUpOwogICAgICAgICAgICAgIGV4dHJhID0gZXh0cmFfZGJpdHNbY29kZV07CiAgICAgICAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7CiAgICAgICAgICAgICAgICBkaXN0IC09IGJhc2VfZGlzdFtjb2RlXTsKICAgICAgICAgICAgICAgIHNlbmRfYml0cyhzLCBkaXN0LCBleHRyYSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9IHdoaWxlIChseCA8IHMubGFzdF9saXQpOwogICAgICAgIH0KICAgICAgICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBsdHJlZSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYnVpbGRfdHJlZShzLCBkZXNjKSB7CiAgICAgICAgdmFyIHRyZWUgPSBkZXNjLmR5bl90cmVlOwogICAgICAgIHZhciBzdHJlZSA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlOwogICAgICAgIHZhciBoYXNfc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7CiAgICAgICAgdmFyIGVsZW1zID0gZGVzYy5zdGF0X2Rlc2MuZWxlbXM7CiAgICAgICAgdmFyIG4sIG07CiAgICAgICAgdmFyIG1heF9jb2RlID0gLTE7CiAgICAgICAgdmFyIG5vZGU7CiAgICAgICAgcy5oZWFwX2xlbiA9IDA7CiAgICAgICAgcy5oZWFwX21heCA9IEhFQVBfU0laRTsKICAgICAgICBmb3IgKG4gPSAwOyBuIDwgZWxlbXM7IG4rKykgewogICAgICAgICAgaWYgKHRyZWVbbiAqIDJdICE9PSAwKSB7CiAgICAgICAgICAgIHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPSBuOwogICAgICAgICAgICBzLmRlcHRoW25dID0gMDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRyZWVbbiAqIDIgKyAxXSA9IDA7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHdoaWxlIChzLmhlYXBfbGVuIDwgMikgewogICAgICAgICAgbm9kZSA9IHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDA7CiAgICAgICAgICB0cmVlW25vZGUgKiAyXSA9IDE7CiAgICAgICAgICBzLmRlcHRoW25vZGVdID0gMDsKICAgICAgICAgIHMub3B0X2xlbi0tOwogICAgICAgICAgaWYgKGhhc19zdHJlZSkgewogICAgICAgICAgICBzLnN0YXRpY19sZW4gLT0gc3RyZWVbbm9kZSAqIDIgKyAxXTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZGVzYy5tYXhfY29kZSA9IG1heF9jb2RlOwogICAgICAgIGZvciAobiA9IHMuaGVhcF9sZW4gPj4gMTsgbiA+PSAxOyBuLS0pIHsKICAgICAgICAgIHBxZG93bmhlYXAocywgdHJlZSwgbik7CiAgICAgICAgfQogICAgICAgIG5vZGUgPSBlbGVtczsKICAgICAgICBkbyB7CiAgICAgICAgICBuID0gcy5oZWFwWzFdOwogICAgICAgICAgcy5oZWFwWzFdID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07CiAgICAgICAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEpOwogICAgICAgICAgbSA9IHMuaGVhcFsxXTsKICAgICAgICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbjsKICAgICAgICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTsKICAgICAgICAgIHRyZWVbbm9kZSAqIDJdID0gdHJlZVtuICogMl0gKyB0cmVlW20gKiAyXTsKICAgICAgICAgIHMuZGVwdGhbbm9kZV0gPSAocy5kZXB0aFtuXSA+PSBzLmRlcHRoW21dID8gcy5kZXB0aFtuXSA6IHMuZGVwdGhbbV0pICsgMTsKICAgICAgICAgIHRyZWVbbiAqIDIgKyAxXSA9IHRyZWVbbSAqIDIgKyAxXSA9IG5vZGU7CiAgICAgICAgICBzLmhlYXBbMV0gPSBub2RlKys7CiAgICAgICAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEpOwogICAgICAgIH0gd2hpbGUgKHMuaGVhcF9sZW4gPj0gMik7CiAgICAgICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBzLmhlYXBbMV07CiAgICAgICAgZ2VuX2JpdGxlbihzLCBkZXNjKTsKICAgICAgICBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIHMuYmxfY291bnQpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHNjYW5fdHJlZShzLCB0cmVlLCBtYXhfY29kZSkgewogICAgICAgIHZhciBuOwogICAgICAgIHZhciBwcmV2bGVuID0gLTE7CiAgICAgICAgdmFyIGN1cmxlbjsKICAgICAgICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXTsKICAgICAgICB2YXIgY291bnQgPSAwOwogICAgICAgIHZhciBtYXhfY291bnQgPSA3OwogICAgICAgIHZhciBtaW5fY291bnQgPSA0OwogICAgICAgIGlmIChuZXh0bGVuID09PSAwKSB7CiAgICAgICAgICBtYXhfY291bnQgPSAxMzg7CiAgICAgICAgICBtaW5fY291bnQgPSAzOwogICAgICAgIH0KICAgICAgICB0cmVlWyhtYXhfY29kZSArIDEpICogMiArIDFdID0gNjU1MzU7CiAgICAgICAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7CiAgICAgICAgICBjdXJsZW4gPSBuZXh0bGVuOwogICAgICAgICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXTsKICAgICAgICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHsKICAgICAgICAgICAgcy5ibF90cmVlW2N1cmxlbiAqIDJdICs9IGNvdW50OwogICAgICAgICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHsKICAgICAgICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikgewogICAgICAgICAgICAgIHMuYmxfdHJlZVtjdXJsZW4gKiAyXSsrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHMuYmxfdHJlZVtSRVBfM182ICogMl0rKzsKICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHsKICAgICAgICAgICAgcy5ibF90cmVlW1JFUFpfM18xMCAqIDJdKys7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzLmJsX3RyZWVbUkVQWl8xMV8xMzggKiAyXSsrOwogICAgICAgICAgfQogICAgICAgICAgY291bnQgPSAwOwogICAgICAgICAgcHJldmxlbiA9IGN1cmxlbjsKICAgICAgICAgIGlmIChuZXh0bGVuID09PSAwKSB7CiAgICAgICAgICAgIG1heF9jb3VudCA9IDEzODsKICAgICAgICAgICAgbWluX2NvdW50ID0gMzsKICAgICAgICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7CiAgICAgICAgICAgIG1heF9jb3VudCA9IDY7CiAgICAgICAgICAgIG1pbl9jb3VudCA9IDM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBtYXhfY291bnQgPSA3OwogICAgICAgICAgICBtaW5fY291bnQgPSA0OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBzZW5kX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpIHsKICAgICAgICB2YXIgbjsKICAgICAgICB2YXIgcHJldmxlbiA9IC0xOwogICAgICAgIHZhciBjdXJsZW47CiAgICAgICAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV07CiAgICAgICAgdmFyIGNvdW50ID0gMDsKICAgICAgICB2YXIgbWF4X2NvdW50ID0gNzsKICAgICAgICB2YXIgbWluX2NvdW50ID0gNDsKICAgICAgICBpZiAobmV4dGxlbiA9PT0gMCkgewogICAgICAgICAgbWF4X2NvdW50ID0gMTM4OwogICAgICAgICAgbWluX2NvdW50ID0gMzsKICAgICAgICB9CiAgICAgICAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7CiAgICAgICAgICBjdXJsZW4gPSBuZXh0bGVuOwogICAgICAgICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXTsKICAgICAgICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHsKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7CiAgICAgICAgICAgIH0gd2hpbGUgKC0tY291bnQgIT09IDApOwogICAgICAgICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHsKICAgICAgICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikgewogICAgICAgICAgICAgIHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7CiAgICAgICAgICAgICAgY291bnQtLTsKICAgICAgICAgICAgfQogICAgICAgICAgICBzZW5kX2NvZGUocywgUkVQXzNfNiwgcy5ibF90cmVlKTsKICAgICAgICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMik7CiAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7CiAgICAgICAgICAgIHNlbmRfY29kZShzLCBSRVBaXzNfMTAsIHMuYmxfdHJlZSk7CiAgICAgICAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDMpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfMTFfMTM4LCBzLmJsX3RyZWUpOwogICAgICAgICAgICBzZW5kX2JpdHMocywgY291bnQgLSAxMSwgNyk7CiAgICAgICAgICB9CiAgICAgICAgICBjb3VudCA9IDA7CiAgICAgICAgICBwcmV2bGVuID0gY3VybGVuOwogICAgICAgICAgaWYgKG5leHRsZW4gPT09IDApIHsKICAgICAgICAgICAgbWF4X2NvdW50ID0gMTM4OwogICAgICAgICAgICBtaW5fY291bnQgPSAzOwogICAgICAgICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHsKICAgICAgICAgICAgbWF4X2NvdW50ID0gNjsKICAgICAgICAgICAgbWluX2NvdW50ID0gMzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIG1heF9jb3VudCA9IDc7CiAgICAgICAgICAgIG1pbl9jb3VudCA9IDQ7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJ1aWxkX2JsX3RyZWUocykgewogICAgICAgIHZhciBtYXhfYmxpbmRleDsKICAgICAgICBzY2FuX3RyZWUocywgcy5keW5fbHRyZWUsIHMubF9kZXNjLm1heF9jb2RlKTsKICAgICAgICBzY2FuX3RyZWUocywgcy5keW5fZHRyZWUsIHMuZF9kZXNjLm1heF9jb2RlKTsKICAgICAgICBidWlsZF90cmVlKHMsIHMuYmxfZGVzYyk7CiAgICAgICAgZm9yIChtYXhfYmxpbmRleCA9IEJMX0NPREVTIC0gMTsgbWF4X2JsaW5kZXggPj0gMzsgbWF4X2JsaW5kZXgtLSkgewogICAgICAgICAgaWYgKHMuYmxfdHJlZVtibF9vcmRlclttYXhfYmxpbmRleF0gKiAyICsgMV0gIT09IDApIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHMub3B0X2xlbiArPSAzICogKG1heF9ibGluZGV4ICsgMSkgKyA1ICsgNSArIDQ7CiAgICAgICAgcmV0dXJuIG1heF9ibGluZGV4OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHNlbmRfYWxsX3RyZWVzKHMsIGxjb2RlcywgZGNvZGVzLCBibGNvZGVzKSB7CiAgICAgICAgdmFyIHJhbms7CiAgICAgICAgc2VuZF9iaXRzKHMsIGxjb2RlcyAtIDI1NywgNSk7CiAgICAgICAgc2VuZF9iaXRzKHMsIGRjb2RlcyAtIDEsIDUpOwogICAgICAgIHNlbmRfYml0cyhzLCBibGNvZGVzIC0gNCwgNCk7CiAgICAgICAgZm9yIChyYW5rID0gMDsgcmFuayA8IGJsY29kZXM7IHJhbmsrKykgewogICAgICAgICAgc2VuZF9iaXRzKHMsIHMuYmxfdHJlZVtibF9vcmRlcltyYW5rXSAqIDIgKyAxXSwgMyk7CiAgICAgICAgfQogICAgICAgIHNlbmRfdHJlZShzLCBzLmR5bl9sdHJlZSwgbGNvZGVzIC0gMSk7CiAgICAgICAgc2VuZF90cmVlKHMsIHMuZHluX2R0cmVlLCBkY29kZXMgLSAxKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZXRlY3RfZGF0YV90eXBlKHMpIHsKICAgICAgICB2YXIgYmxhY2tfbWFzayA9IDQwOTM2MjQ0NDc7CiAgICAgICAgdmFyIG47CiAgICAgICAgZm9yIChuID0gMDsgbiA8PSAzMTsgbisrLCBibGFja19tYXNrID4+Pj0gMSkgewogICAgICAgICAgaWYgKGJsYWNrX21hc2sgJiAxICYmIHMuZHluX2x0cmVlW24gKiAyXSAhPT0gMCkgewogICAgICAgICAgICByZXR1cm4gWl9CSU5BUlk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChzLmR5bl9sdHJlZVs5ICogMl0gIT09IDAgfHwgcy5keW5fbHRyZWVbMTAgKiAyXSAhPT0gMCB8fCBzLmR5bl9sdHJlZVsxMyAqIDJdICE9PSAwKSB7CiAgICAgICAgICByZXR1cm4gWl9URVhUOwogICAgICAgIH0KICAgICAgICBmb3IgKG4gPSAzMjsgbiA8IExJVEVSQUxTOyBuKyspIHsKICAgICAgICAgIGlmIChzLmR5bl9sdHJlZVtuICogMl0gIT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIFpfVEVYVDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIFpfQklOQVJZOwogICAgICB9CiAgICAgIHZhciBzdGF0aWNfaW5pdF9kb25lID0gZmFsc2U7CiAgICAgIGZ1bmN0aW9uIF90cl9pbml0KHMpIHsKICAgICAgICBpZiAoIXN0YXRpY19pbml0X2RvbmUpIHsKICAgICAgICAgIHRyX3N0YXRpY19pbml0KCk7CiAgICAgICAgICBzdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTsKICAgICAgICB9CiAgICAgICAgcy5sX2Rlc2MgPSBuZXcgVHJlZURlc2Mocy5keW5fbHRyZWUsIHN0YXRpY19sX2Rlc2MpOwogICAgICAgIHMuZF9kZXNjID0gbmV3IFRyZWVEZXNjKHMuZHluX2R0cmVlLCBzdGF0aWNfZF9kZXNjKTsKICAgICAgICBzLmJsX2Rlc2MgPSBuZXcgVHJlZURlc2Mocy5ibF90cmVlLCBzdGF0aWNfYmxfZGVzYyk7CiAgICAgICAgcy5iaV9idWYgPSAwOwogICAgICAgIHMuYmlfdmFsaWQgPSAwOwogICAgICAgIGluaXRfYmxvY2socyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpIHsKICAgICAgICBzZW5kX2JpdHMocywgKFNUT1JFRF9CTE9DSyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsKICAgICAgICBjb3B5X2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgdHJ1ZSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3RyX2FsaWduKHMpIHsKICAgICAgICBzZW5kX2JpdHMocywgU1RBVElDX1RSRUVTIDw8IDEsIDMpOwogICAgICAgIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIHN0YXRpY19sdHJlZSk7CiAgICAgICAgYmlfZmx1c2gocyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3RyX2ZsdXNoX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCkgewogICAgICAgIHZhciBvcHRfbGVuYiwgc3RhdGljX2xlbmI7CiAgICAgICAgdmFyIG1heF9ibGluZGV4ID0gMDsKICAgICAgICBpZiAocy5sZXZlbCA+IDApIHsKICAgICAgICAgIGlmIChzLnN0cm0uZGF0YV90eXBlID09PSBaX1VOS05PV04pIHsKICAgICAgICAgICAgcy5zdHJtLmRhdGFfdHlwZSA9IGRldGVjdF9kYXRhX3R5cGUocyk7CiAgICAgICAgICB9CiAgICAgICAgICBidWlsZF90cmVlKHMsIHMubF9kZXNjKTsKICAgICAgICAgIGJ1aWxkX3RyZWUocywgcy5kX2Rlc2MpOwogICAgICAgICAgbWF4X2JsaW5kZXggPSBidWlsZF9ibF90cmVlKHMpOwogICAgICAgICAgb3B0X2xlbmIgPSBzLm9wdF9sZW4gKyAzICsgNyA+Pj4gMzsKICAgICAgICAgIHN0YXRpY19sZW5iID0gcy5zdGF0aWNfbGVuICsgMyArIDcgPj4+IDM7CiAgICAgICAgICBpZiAoc3RhdGljX2xlbmIgPD0gb3B0X2xlbmIpIHsKICAgICAgICAgICAgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYjsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYiA9IHN0b3JlZF9sZW4gKyA1OwogICAgICAgIH0KICAgICAgICBpZiAoc3RvcmVkX2xlbiArIDQgPD0gb3B0X2xlbmIgJiYgYnVmICE9PSAtMSkgewogICAgICAgICAgX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpOwogICAgICAgIH0gZWxzZSBpZiAocy5zdHJhdGVneSA9PT0gWl9GSVhFRCB8fCBzdGF0aWNfbGVuYiA9PT0gb3B0X2xlbmIpIHsKICAgICAgICAgIHNlbmRfYml0cyhzLCAoU1RBVElDX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOwogICAgICAgICAgY29tcHJlc3NfYmxvY2socywgc3RhdGljX2x0cmVlLCBzdGF0aWNfZHRyZWUpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBzZW5kX2JpdHMocywgKERZTl9UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsKICAgICAgICAgIHNlbmRfYWxsX3RyZWVzKHMsIHMubF9kZXNjLm1heF9jb2RlICsgMSwgcy5kX2Rlc2MubWF4X2NvZGUgKyAxLCBtYXhfYmxpbmRleCArIDEpOwogICAgICAgICAgY29tcHJlc3NfYmxvY2socywgcy5keW5fbHRyZWUsIHMuZHluX2R0cmVlKTsKICAgICAgICB9CiAgICAgICAgaW5pdF9ibG9jayhzKTsKICAgICAgICBpZiAobGFzdCkgewogICAgICAgICAgYmlfd2luZHVwKHMpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBfdHJfdGFsbHkocywgZGlzdCwgbGMpIHsKICAgICAgICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMl0gPSBkaXN0ID4+PiA4ICYgMjU1OwogICAgICAgIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyICsgMV0gPSBkaXN0ICYgMjU1OwogICAgICAgIHMucGVuZGluZ19idWZbcy5sX2J1ZiArIHMubGFzdF9saXRdID0gbGMgJiAyNTU7CiAgICAgICAgcy5sYXN0X2xpdCsrOwogICAgICAgIGlmIChkaXN0ID09PSAwKSB7CiAgICAgICAgICBzLmR5bl9sdHJlZVtsYyAqIDJdKys7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHMubWF0Y2hlcysrOwogICAgICAgICAgZGlzdC0tOwogICAgICAgICAgcy5keW5fbHRyZWVbKF9sZW5ndGhfY29kZVtsY10gKyBMSVRFUkFMUyArIDEpICogMl0rKzsKICAgICAgICAgIHMuZHluX2R0cmVlW2RfY29kZShkaXN0KSAqIDJdKys7CiAgICAgICAgfQogICAgICAgIHJldHVybiBzLmxhc3RfbGl0ID09PSBzLmxpdF9idWZzaXplIC0gMTsKICAgICAgfQogICAgICBleHBvcnRzLl90cl9pbml0ID0gX3RyX2luaXQ7CiAgICAgIGV4cG9ydHMuX3RyX3N0b3JlZF9ibG9jayA9IF90cl9zdG9yZWRfYmxvY2s7CiAgICAgIGV4cG9ydHMuX3RyX2ZsdXNoX2Jsb2NrID0gX3RyX2ZsdXNoX2Jsb2NrOwogICAgICBleHBvcnRzLl90cl90YWxseSA9IF90cl90YWxseTsKICAgICAgZXhwb3J0cy5fdHJfYWxpZ24gPSBfdHJfYWxpZ247CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2FkbGVyMzIuanMKICB2YXIgcmVxdWlyZV9hZGxlcjMyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvYWRsZXIzMi5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBmdW5jdGlvbiBhZGxlcjMyKGFkbGVyLCBidWYsIGxlbiwgcG9zKSB7CiAgICAgICAgdmFyIHMxID0gYWRsZXIgJiA2NTUzNSB8IDAsIHMyID0gYWRsZXIgPj4+IDE2ICYgNjU1MzUgfCAwLCBuID0gMDsKICAgICAgICB3aGlsZSAobGVuICE9PSAwKSB7CiAgICAgICAgICBuID0gbGVuID4gMmUzID8gMmUzIDogbGVuOwogICAgICAgICAgbGVuIC09IG47CiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIHMxID0gczEgKyBidWZbcG9zKytdIHwgMDsKICAgICAgICAgICAgczIgPSBzMiArIHMxIHwgMDsKICAgICAgICAgIH0gd2hpbGUgKC0tbik7CiAgICAgICAgICBzMSAlPSA2NTUyMTsKICAgICAgICAgIHMyICU9IDY1NTIxOwogICAgICAgIH0KICAgICAgICByZXR1cm4gczEgfCBzMiA8PCAxNiB8IDA7CiAgICAgIH0KICAgICAgbW9kdWxlLmV4cG9ydHMgPSBhZGxlcjMyOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jcmMzMi5qcwogIHZhciByZXF1aXJlX2NyYzMyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgZnVuY3Rpb24gbWFrZVRhYmxlKCkgewogICAgICAgIHZhciBjLCB0YWJsZSA9IFtdOwogICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgMjU2OyBuKyspIHsKICAgICAgICAgIGMgPSBuOwogICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHsKICAgICAgICAgICAgYyA9IGMgJiAxID8gMzk4ODI5MjM4NCBeIGMgPj4+IDEgOiBjID4+PiAxOwogICAgICAgICAgfQogICAgICAgICAgdGFibGVbbl0gPSBjOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGFibGU7CiAgICAgIH0KICAgICAgdmFyIGNyY1RhYmxlID0gbWFrZVRhYmxlKCk7CiAgICAgIGZ1bmN0aW9uIGNyYzMyKGNyYywgYnVmLCBsZW4sIHBvcykgewogICAgICAgIHZhciB0ID0gY3JjVGFibGUsIGVuZCA9IHBvcyArIGxlbjsKICAgICAgICBjcmMgXj0gLTE7CiAgICAgICAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrKSB7CiAgICAgICAgICBjcmMgPSBjcmMgPj4+IDggXiB0WyhjcmMgXiBidWZbaV0pICYgMjU1XTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGNyYyBeIC0xOwogICAgICB9CiAgICAgIG1vZHVsZS5leHBvcnRzID0gY3JjMzI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL21lc3NhZ2VzLmpzCiAgdmFyIHJlcXVpcmVfbWVzc2FnZXMyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvbWVzc2FnZXMuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSB7CiAgICAgICAgMjogIm5lZWQgZGljdGlvbmFyeSIsCiAgICAgICAgMTogInN0cmVhbSBlbmQiLAogICAgICAgIDA6ICIiLAogICAgICAgICItMSI6ICJmaWxlIGVycm9yIiwKICAgICAgICAiLTIiOiAic3RyZWFtIGVycm9yIiwKICAgICAgICAiLTMiOiAiZGF0YSBlcnJvciIsCiAgICAgICAgIi00IjogImluc3VmZmljaWVudCBtZW1vcnkiLAogICAgICAgICItNSI6ICJidWZmZXIgZXJyb3IiLAogICAgICAgICItNiI6ICJpbmNvbXBhdGlibGUgdmVyc2lvbiIKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZGVmbGF0ZS5qcwogIHZhciByZXF1aXJlX2RlZmxhdGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9kZWZsYXRlLmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgdXRpbHMgPSByZXF1aXJlX2NvbW1vbjIoKTsKICAgICAgdmFyIHRyZWVzID0gcmVxdWlyZV90cmVlcygpOwogICAgICB2YXIgYWRsZXIzMiA9IHJlcXVpcmVfYWRsZXIzMigpOwogICAgICB2YXIgY3JjMzIgPSByZXF1aXJlX2NyYzMyKCk7CiAgICAgIHZhciBtc2cgPSByZXF1aXJlX21lc3NhZ2VzMigpOwogICAgICB2YXIgWl9OT19GTFVTSCA9IDA7CiAgICAgIHZhciBaX1BBUlRJQUxfRkxVU0ggPSAxOwogICAgICB2YXIgWl9GVUxMX0ZMVVNIID0gMzsKICAgICAgdmFyIFpfRklOSVNIID0gNDsKICAgICAgdmFyIFpfQkxPQ0sgPSA1OwogICAgICB2YXIgWl9PSyA9IDA7CiAgICAgIHZhciBaX1NUUkVBTV9FTkQgPSAxOwogICAgICB2YXIgWl9TVFJFQU1fRVJST1IgPSAtMjsKICAgICAgdmFyIFpfREFUQV9FUlJPUiA9IC0zOwogICAgICB2YXIgWl9CVUZfRVJST1IgPSAtNTsKICAgICAgdmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xOwogICAgICB2YXIgWl9GSUxURVJFRCA9IDE7CiAgICAgIHZhciBaX0hVRkZNQU5fT05MWSA9IDI7CiAgICAgIHZhciBaX1JMRSA9IDM7CiAgICAgIHZhciBaX0ZJWEVEID0gNDsKICAgICAgdmFyIFpfREVGQVVMVF9TVFJBVEVHWSA9IDA7CiAgICAgIHZhciBaX1VOS05PV04gPSAyOwogICAgICB2YXIgWl9ERUZMQVRFRCA9IDg7CiAgICAgIHZhciBNQVhfTUVNX0xFVkVMID0gOTsKICAgICAgdmFyIE1BWF9XQklUUyA9IDE1OwogICAgICB2YXIgREVGX01FTV9MRVZFTCA9IDg7CiAgICAgIHZhciBMRU5HVEhfQ09ERVMgPSAyOTsKICAgICAgdmFyIExJVEVSQUxTID0gMjU2OwogICAgICB2YXIgTF9DT0RFUyA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUzsKICAgICAgdmFyIERfQ09ERVMgPSAzMDsKICAgICAgdmFyIEJMX0NPREVTID0gMTk7CiAgICAgIHZhciBIRUFQX1NJWkUgPSAyICogTF9DT0RFUyArIDE7CiAgICAgIHZhciBNQVhfQklUUyA9IDE1OwogICAgICB2YXIgTUlOX01BVENIID0gMzsKICAgICAgdmFyIE1BWF9NQVRDSCA9IDI1ODsKICAgICAgdmFyIE1JTl9MT09LQUhFQUQgPSBNQVhfTUFUQ0ggKyBNSU5fTUFUQ0ggKyAxOwogICAgICB2YXIgUFJFU0VUX0RJQ1QgPSAzMjsKICAgICAgdmFyIElOSVRfU1RBVEUgPSA0MjsKICAgICAgdmFyIEVYVFJBX1NUQVRFID0gNjk7CiAgICAgIHZhciBOQU1FX1NUQVRFID0gNzM7CiAgICAgIHZhciBDT01NRU5UX1NUQVRFID0gOTE7CiAgICAgIHZhciBIQ1JDX1NUQVRFID0gMTAzOwogICAgICB2YXIgQlVTWV9TVEFURSA9IDExMzsKICAgICAgdmFyIEZJTklTSF9TVEFURSA9IDY2NjsKICAgICAgdmFyIEJTX05FRURfTU9SRSA9IDE7CiAgICAgIHZhciBCU19CTE9DS19ET05FID0gMjsKICAgICAgdmFyIEJTX0ZJTklTSF9TVEFSVEVEID0gMzsKICAgICAgdmFyIEJTX0ZJTklTSF9ET05FID0gNDsKICAgICAgdmFyIE9TX0NPREUgPSAzOwogICAgICBmdW5jdGlvbiBlcnIoc3RybSwgZXJyb3JDb2RlKSB7CiAgICAgICAgc3RybS5tc2cgPSBtc2dbZXJyb3JDb2RlXTsKICAgICAgICByZXR1cm4gZXJyb3JDb2RlOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHJhbmsoZikgewogICAgICAgIHJldHVybiAoZiA8PCAxKSAtIChmID4gNCA/IDkgOiAwKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB6ZXJvKGJ1ZikgewogICAgICAgIHZhciBsZW4gPSBidWYubGVuZ3RoOwogICAgICAgIHdoaWxlICgtLWxlbiA+PSAwKSB7CiAgICAgICAgICBidWZbbGVuXSA9IDA7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZsdXNoX3BlbmRpbmcoc3RybSkgewogICAgICAgIHZhciBzID0gc3RybS5zdGF0ZTsKICAgICAgICB2YXIgbGVuID0gcy5wZW5kaW5nOwogICAgICAgIGlmIChsZW4gPiBzdHJtLmF2YWlsX291dCkgewogICAgICAgICAgbGVuID0gc3RybS5hdmFpbF9vdXQ7CiAgICAgICAgfQogICAgICAgIGlmIChsZW4gPT09IDApIHsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHMucGVuZGluZ19idWYsIHMucGVuZGluZ19vdXQsIGxlbiwgc3RybS5uZXh0X291dCk7CiAgICAgICAgc3RybS5uZXh0X291dCArPSBsZW47CiAgICAgICAgcy5wZW5kaW5nX291dCArPSBsZW47CiAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gbGVuOwogICAgICAgIHN0cm0uYXZhaWxfb3V0IC09IGxlbjsKICAgICAgICBzLnBlbmRpbmcgLT0gbGVuOwogICAgICAgIGlmIChzLnBlbmRpbmcgPT09IDApIHsKICAgICAgICAgIHMucGVuZGluZ19vdXQgPSAwOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBmbHVzaF9ibG9ja19vbmx5KHMsIGxhc3QpIHsKICAgICAgICB0cmVlcy5fdHJfZmx1c2hfYmxvY2socywgcy5ibG9ja19zdGFydCA+PSAwID8gcy5ibG9ja19zdGFydCA6IC0xLCBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCwgbGFzdCk7CiAgICAgICAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgZmx1c2hfcGVuZGluZyhzLnN0cm0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHB1dF9ieXRlKHMsIGIpIHsKICAgICAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcHV0U2hvcnRNU0IocywgYikgewogICAgICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYiA+Pj4gOCAmIDI1NTsKICAgICAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGIgJiAyNTU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcmVhZF9idWYoc3RybSwgYnVmLCBzdGFydCwgc2l6ZSkgewogICAgICAgIHZhciBsZW4gPSBzdHJtLmF2YWlsX2luOwogICAgICAgIGlmIChsZW4gPiBzaXplKSB7CiAgICAgICAgICBsZW4gPSBzaXplOwogICAgICAgIH0KICAgICAgICBpZiAobGVuID09PSAwKSB7CiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB9CiAgICAgICAgc3RybS5hdmFpbF9pbiAtPSBsZW47CiAgICAgICAgdXRpbHMuYXJyYXlTZXQoYnVmLCBzdHJtLmlucHV0LCBzdHJtLm5leHRfaW4sIGxlbiwgc3RhcnQpOwogICAgICAgIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDEpIHsKICAgICAgICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7CiAgICAgICAgfSBlbHNlIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDIpIHsKICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpOwogICAgICAgIH0KICAgICAgICBzdHJtLm5leHRfaW4gKz0gbGVuOwogICAgICAgIHN0cm0udG90YWxfaW4gKz0gbGVuOwogICAgICAgIHJldHVybiBsZW47CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbG9uZ2VzdF9tYXRjaChzLCBjdXJfbWF0Y2gpIHsKICAgICAgICB2YXIgY2hhaW5fbGVuZ3RoID0gcy5tYXhfY2hhaW5fbGVuZ3RoOwogICAgICAgIHZhciBzY2FuID0gcy5zdHJzdGFydDsKICAgICAgICB2YXIgbWF0Y2g7CiAgICAgICAgdmFyIGxlbjsKICAgICAgICB2YXIgYmVzdF9sZW4gPSBzLnByZXZfbGVuZ3RoOwogICAgICAgIHZhciBuaWNlX21hdGNoID0gcy5uaWNlX21hdGNoOwogICAgICAgIHZhciBsaW1pdCA9IHMuc3Ryc3RhcnQgPiBzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQgPyBzLnN0cnN0YXJ0IC0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwOwogICAgICAgIHZhciBfd2luID0gcy53aW5kb3c7CiAgICAgICAgdmFyIHdtYXNrID0gcy53X21hc2s7CiAgICAgICAgdmFyIHByZXYgPSBzLnByZXY7CiAgICAgICAgdmFyIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7CiAgICAgICAgdmFyIHNjYW5fZW5kMSA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07CiAgICAgICAgdmFyIHNjYW5fZW5kID0gX3dpbltzY2FuICsgYmVzdF9sZW5dOwogICAgICAgIGlmIChzLnByZXZfbGVuZ3RoID49IHMuZ29vZF9tYXRjaCkgewogICAgICAgICAgY2hhaW5fbGVuZ3RoID4+PSAyOwogICAgICAgIH0KICAgICAgICBpZiAobmljZV9tYXRjaCA+IHMubG9va2FoZWFkKSB7CiAgICAgICAgICBuaWNlX21hdGNoID0gcy5sb29rYWhlYWQ7CiAgICAgICAgfQogICAgICAgIGRvIHsKICAgICAgICAgIG1hdGNoID0gY3VyX21hdGNoOwogICAgICAgICAgaWYgKF93aW5bbWF0Y2ggKyBiZXN0X2xlbl0gIT09IHNjYW5fZW5kIHx8IF93aW5bbWF0Y2ggKyBiZXN0X2xlbiAtIDFdICE9PSBzY2FuX2VuZDEgfHwgX3dpblttYXRjaF0gIT09IF93aW5bc2Nhbl0gfHwgX3dpblsrK21hdGNoXSAhPT0gX3dpbltzY2FuICsgMV0pIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgICBzY2FuICs9IDI7CiAgICAgICAgICBtYXRjaCsrOwogICAgICAgICAgZG8gewogICAgICAgICAgfSB3aGlsZSAoX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBzY2FuIDwgc3RyZW5kKTsKICAgICAgICAgIGxlbiA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTsKICAgICAgICAgIHNjYW4gPSBzdHJlbmQgLSBNQVhfTUFUQ0g7CiAgICAgICAgICBpZiAobGVuID4gYmVzdF9sZW4pIHsKICAgICAgICAgICAgcy5tYXRjaF9zdGFydCA9IGN1cl9tYXRjaDsKICAgICAgICAgICAgYmVzdF9sZW4gPSBsZW47CiAgICAgICAgICAgIGlmIChsZW4gPj0gbmljZV9tYXRjaCkgewogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHNjYW5fZW5kMSA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07CiAgICAgICAgICAgIHNjYW5fZW5kID0gX3dpbltzY2FuICsgYmVzdF9sZW5dOwogICAgICAgICAgfQogICAgICAgIH0gd2hpbGUgKChjdXJfbWF0Y2ggPSBwcmV2W2N1cl9tYXRjaCAmIHdtYXNrXSkgPiBsaW1pdCAmJiAtLWNoYWluX2xlbmd0aCAhPT0gMCk7CiAgICAgICAgaWYgKGJlc3RfbGVuIDw9IHMubG9va2FoZWFkKSB7CiAgICAgICAgICByZXR1cm4gYmVzdF9sZW47CiAgICAgICAgfQogICAgICAgIHJldHVybiBzLmxvb2thaGVhZDsKICAgICAgfQogICAgICBmdW5jdGlvbiBmaWxsX3dpbmRvdyhzKSB7CiAgICAgICAgdmFyIF93X3NpemUgPSBzLndfc2l6ZTsKICAgICAgICB2YXIgcCwgbiwgbSwgbW9yZSwgc3RyOwogICAgICAgIGRvIHsKICAgICAgICAgIG1vcmUgPSBzLndpbmRvd19zaXplIC0gcy5sb29rYWhlYWQgLSBzLnN0cnN0YXJ0OwogICAgICAgICAgaWYgKHMuc3Ryc3RhcnQgPj0gX3dfc2l6ZSArIChfd19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHsKICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQocy53aW5kb3csIHMud2luZG93LCBfd19zaXplLCBfd19zaXplLCAwKTsKICAgICAgICAgICAgcy5tYXRjaF9zdGFydCAtPSBfd19zaXplOwogICAgICAgICAgICBzLnN0cnN0YXJ0IC09IF93X3NpemU7CiAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgLT0gX3dfc2l6ZTsKICAgICAgICAgICAgbiA9IHMuaGFzaF9zaXplOwogICAgICAgICAgICBwID0gbjsKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIG0gPSBzLmhlYWRbLS1wXTsKICAgICAgICAgICAgICBzLmhlYWRbcF0gPSBtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDA7CiAgICAgICAgICAgIH0gd2hpbGUgKC0tbik7CiAgICAgICAgICAgIG4gPSBfd19zaXplOwogICAgICAgICAgICBwID0gbjsKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIG0gPSBzLnByZXZbLS1wXTsKICAgICAgICAgICAgICBzLnByZXZbcF0gPSBtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDA7CiAgICAgICAgICAgIH0gd2hpbGUgKC0tbik7CiAgICAgICAgICAgIG1vcmUgKz0gX3dfc2l6ZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfaW4gPT09IDApIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBuID0gcmVhZF9idWYocy5zdHJtLCBzLndpbmRvdywgcy5zdHJzdGFydCArIHMubG9va2FoZWFkLCBtb3JlKTsKICAgICAgICAgIHMubG9va2FoZWFkICs9IG47CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICAgICAgc3RyID0gcy5zdHJzdGFydCAtIHMuaW5zZXJ0OwogICAgICAgICAgICBzLmluc19oID0gcy53aW5kb3dbc3RyXTsKICAgICAgICAgICAgcy5pbnNfaCA9IChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCBeIHMud2luZG93W3N0ciArIDFdKSAmIHMuaGFzaF9tYXNrOwogICAgICAgICAgICB3aGlsZSAocy5pbnNlcnQpIHsKICAgICAgICAgICAgICBzLmluc19oID0gKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0IF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTsKICAgICAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7CiAgICAgICAgICAgICAgc3RyKys7CiAgICAgICAgICAgICAgcy5pbnNlcnQtLTsKICAgICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA8IE1JTl9NQVRDSCkgewogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSB3aGlsZSAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIHMuc3RybS5hdmFpbF9pbiAhPT0gMCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZV9zdG9yZWQocywgZmx1c2gpIHsKICAgICAgICB2YXIgbWF4X2Jsb2NrX3NpemUgPSA2NTUzNTsKICAgICAgICBpZiAobWF4X2Jsb2NrX3NpemUgPiBzLnBlbmRpbmdfYnVmX3NpemUgLSA1KSB7CiAgICAgICAgICBtYXhfYmxvY2tfc2l6ZSA9IHMucGVuZGluZ19idWZfc2l6ZSAtIDU7CiAgICAgICAgfQogICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgaWYgKHMubG9va2FoZWFkIDw9IDEpIHsKICAgICAgICAgICAgZmlsbF93aW5kb3cocyk7CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7CiAgICAgICAgICBzLmxvb2thaGVhZCA9IDA7CiAgICAgICAgICB2YXIgbWF4X3N0YXJ0ID0gcy5ibG9ja19zdGFydCArIG1heF9ibG9ja19zaXplOwogICAgICAgICAgaWYgKHMuc3Ryc3RhcnQgPT09IDAgfHwgcy5zdHJzdGFydCA+PSBtYXhfc3RhcnQpIHsKICAgICAgICAgICAgcy5sb29rYWhlYWQgPSBzLnN0cnN0YXJ0IC0gbWF4X3N0YXJ0OwogICAgICAgICAgICBzLnN0cnN0YXJ0ID0gbWF4X3N0YXJ0OwogICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQgPj0gcy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB7CiAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcy5pbnNlcnQgPSAwOwogICAgICAgIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7CiAgICAgICAgfQogICAgICAgIGlmIChzLnN0cnN0YXJ0ID4gcy5ibG9ja19zdGFydCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVfZmFzdChzLCBmbHVzaCkgewogICAgICAgIHZhciBoYXNoX2hlYWQ7CiAgICAgICAgdmFyIGJmbHVzaDsKICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHsKICAgICAgICAgICAgZmlsbF93aW5kb3cocyk7CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBoYXNoX2hlYWQgPSAwOwogICAgICAgICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkgewogICAgICAgICAgICBzLmluc19oID0gKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0IF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrOwogICAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTsKICAgICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChoYXNoX2hlYWQgIT09IDAgJiYgcy5zdHJzdGFydCAtIGhhc2hfaGVhZCA8PSBzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHsKICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7CiAgICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpOwogICAgICAgICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDsKICAgICAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IHMubWF4X2xhenlfbWF0Y2ggJiYgcy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7CiAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGgtLTsKICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICAgICAgICBzLmluc19oID0gKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0IF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrOwogICAgICAgICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07CiAgICAgICAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0OwogICAgICAgICAgICAgIH0gd2hpbGUgKC0tcy5tYXRjaF9sZW5ndGggIT09IDApOwogICAgICAgICAgICAgIHMuc3Ryc3RhcnQrKzsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoOwogICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDsKICAgICAgICAgICAgICBzLmluc19oID0gcy53aW5kb3dbcy5zdHJzdGFydF07CiAgICAgICAgICAgICAgcy5pbnNfaCA9IChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTsKICAgICAgICAgICAgcy5sb29rYWhlYWQtLTsKICAgICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGJmbHVzaCkgewogICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSCAtIDEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMTsKICAgICAgICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FOwogICAgICAgIH0KICAgICAgICBpZiAocy5sYXN0X2xpdCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gQlNfQkxPQ0tfRE9ORTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlX3Nsb3cocywgZmx1c2gpIHsKICAgICAgICB2YXIgaGFzaF9oZWFkOwogICAgICAgIHZhciBiZmx1c2g7CiAgICAgICAgdmFyIG1heF9pbnNlcnQ7CiAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7CiAgICAgICAgICAgIGZpbGxfd2luZG93KHMpOwogICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaGFzaF9oZWFkID0gMDsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICAgICAgcy5pbnNfaCA9IChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07CiAgICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgICB9CiAgICAgICAgICBzLnByZXZfbGVuZ3RoID0gcy5tYXRjaF9sZW5ndGg7CiAgICAgICAgICBzLnByZXZfbWF0Y2ggPSBzLm1hdGNoX3N0YXJ0OwogICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxOwogICAgICAgICAgaWYgKGhhc2hfaGVhZCAhPT0gMCAmJiBzLnByZXZfbGVuZ3RoIDwgcy5tYXhfbGF6eV9tYXRjaCAmJiBzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkIDw9IHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgewogICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTsKICAgICAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IDUgJiYgKHMuc3RyYXRlZ3kgPT09IFpfRklMVEVSRUQgfHwgcy5tYXRjaF9sZW5ndGggPT09IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCA+IDQwOTYpKSB7CiAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBNSU5fTUFUQ0ggJiYgcy5tYXRjaF9sZW5ndGggPD0gcy5wcmV2X2xlbmd0aCkgewogICAgICAgICAgICBtYXhfaW5zZXJ0ID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkIC0gTUlOX01BVENIOwogICAgICAgICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gpOwogICAgICAgICAgICBzLmxvb2thaGVhZCAtPSBzLnByZXZfbGVuZ3RoIC0gMTsKICAgICAgICAgICAgcy5wcmV2X2xlbmd0aCAtPSAyOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgaWYgKCsrcy5zdHJzdGFydCA8PSBtYXhfaW5zZXJ0KSB7CiAgICAgICAgICAgICAgICBzLmluc19oID0gKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0IF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrOwogICAgICAgICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07CiAgICAgICAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSB3aGlsZSAoLS1zLnByZXZfbGVuZ3RoICE9PSAwKTsKICAgICAgICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwOwogICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgICAgIHMuc3Ryc3RhcnQrKzsKICAgICAgICAgICAgaWYgKGJmbHVzaCkgewogICAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkgewogICAgICAgICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTsKICAgICAgICAgICAgaWYgKGJmbHVzaCkgewogICAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHMuc3Ryc3RhcnQrKzsKICAgICAgICAgICAgcy5sb29rYWhlYWQtLTsKICAgICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDE7CiAgICAgICAgICAgIHMuc3Ryc3RhcnQrKzsKICAgICAgICAgICAgcy5sb29rYWhlYWQtLTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7CiAgICAgICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTsKICAgICAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDsKICAgICAgICB9CiAgICAgICAgcy5pbnNlcnQgPSBzLnN0cnN0YXJ0IDwgTUlOX01BVENIIC0gMSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxOwogICAgICAgIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7CiAgICAgICAgfQogICAgICAgIGlmIChzLmxhc3RfbGl0KSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBCU19CTE9DS19ET05FOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVfcmxlKHMsIGZsdXNoKSB7CiAgICAgICAgdmFyIGJmbHVzaDsKICAgICAgICB2YXIgcHJldjsKICAgICAgICB2YXIgc2Nhbiwgc3RyZW5kOwogICAgICAgIHZhciBfd2luID0gcy53aW5kb3c7CiAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIKSB7CiAgICAgICAgICAgIGZpbGxfd2luZG93KHMpOwogICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwOwogICAgICAgICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0ID4gMCkgewogICAgICAgICAgICBzY2FuID0gcy5zdHJzdGFydCAtIDE7CiAgICAgICAgICAgIHByZXYgPSBfd2luW3NjYW5dOwogICAgICAgICAgICBpZiAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0pIHsKICAgICAgICAgICAgICBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIOwogICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICB9IHdoaWxlIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHNjYW4gPCBzdHJlbmQpOwogICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pOwogICAgICAgICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+IHMubG9va2FoZWFkKSB7CiAgICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IHMubG9va2FoZWFkOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkgewogICAgICAgICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpOwogICAgICAgICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDsKICAgICAgICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDsKICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTsKICAgICAgICAgICAgcy5sb29rYWhlYWQtLTsKICAgICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGJmbHVzaCkgewogICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHMuaW5zZXJ0ID0gMDsKICAgICAgICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FOwogICAgICAgIH0KICAgICAgICBpZiAocy5sYXN0X2xpdCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gQlNfQkxPQ0tfRE9ORTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIHsKICAgICAgICB2YXIgYmZsdXNoOwogICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7CiAgICAgICAgICAgIGZpbGxfd2luZG93KHMpOwogICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsKICAgICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfTk9fRkxVU0gpIHsKICAgICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7CiAgICAgICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pOwogICAgICAgICAgcy5sb29rYWhlYWQtLTsKICAgICAgICAgIHMuc3Ryc3RhcnQrKzsKICAgICAgICAgIGlmIChiZmx1c2gpIHsKICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzLmluc2VydCA9IDA7CiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTsKICAgICAgICB9CiAgICAgICAgaWYgKHMubGFzdF9saXQpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gQ29uZmlnKGdvb2RfbGVuZ3RoLCBtYXhfbGF6eSwgbmljZV9sZW5ndGgsIG1heF9jaGFpbiwgZnVuYykgewogICAgICAgIHRoaXMuZ29vZF9sZW5ndGggPSBnb29kX2xlbmd0aDsKICAgICAgICB0aGlzLm1heF9sYXp5ID0gbWF4X2xhenk7CiAgICAgICAgdGhpcy5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoOwogICAgICAgIHRoaXMubWF4X2NoYWluID0gbWF4X2NoYWluOwogICAgICAgIHRoaXMuZnVuYyA9IGZ1bmM7CiAgICAgIH0KICAgICAgdmFyIGNvbmZpZ3VyYXRpb25fdGFibGU7CiAgICAgIGNvbmZpZ3VyYXRpb25fdGFibGUgPSBbCiAgICAgICAgbmV3IENvbmZpZygwLCAwLCAwLCAwLCBkZWZsYXRlX3N0b3JlZCksCiAgICAgICAgbmV3IENvbmZpZyg0LCA0LCA4LCA0LCBkZWZsYXRlX2Zhc3QpLAogICAgICAgIG5ldyBDb25maWcoNCwgNSwgMTYsIDgsIGRlZmxhdGVfZmFzdCksCiAgICAgICAgbmV3IENvbmZpZyg0LCA2LCAzMiwgMzIsIGRlZmxhdGVfZmFzdCksCiAgICAgICAgbmV3IENvbmZpZyg0LCA0LCAxNiwgMTYsIGRlZmxhdGVfc2xvdyksCiAgICAgICAgbmV3IENvbmZpZyg4LCAxNiwgMzIsIDMyLCBkZWZsYXRlX3Nsb3cpLAogICAgICAgIG5ldyBDb25maWcoOCwgMTYsIDEyOCwgMTI4LCBkZWZsYXRlX3Nsb3cpLAogICAgICAgIG5ldyBDb25maWcoOCwgMzIsIDEyOCwgMjU2LCBkZWZsYXRlX3Nsb3cpLAogICAgICAgIG5ldyBDb25maWcoMzIsIDEyOCwgMjU4LCAxMDI0LCBkZWZsYXRlX3Nsb3cpLAogICAgICAgIG5ldyBDb25maWcoMzIsIDI1OCwgMjU4LCA0MDk2LCBkZWZsYXRlX3Nsb3cpCiAgICAgIF07CiAgICAgIGZ1bmN0aW9uIGxtX2luaXQocykgewogICAgICAgIHMud2luZG93X3NpemUgPSAyICogcy53X3NpemU7CiAgICAgICAgemVybyhzLmhlYWQpOwogICAgICAgIHMubWF4X2xhenlfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9sYXp5OwogICAgICAgIHMuZ29vZF9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZ29vZF9sZW5ndGg7CiAgICAgICAgcy5uaWNlX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5uaWNlX2xlbmd0aDsKICAgICAgICBzLm1heF9jaGFpbl9sZW5ndGggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9jaGFpbjsKICAgICAgICBzLnN0cnN0YXJ0ID0gMDsKICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gMDsKICAgICAgICBzLmxvb2thaGVhZCA9IDA7CiAgICAgICAgcy5pbnNlcnQgPSAwOwogICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwOwogICAgICAgIHMuaW5zX2ggPSAwOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIERlZmxhdGVTdGF0ZSgpIHsKICAgICAgICB0aGlzLnN0cm0gPSBudWxsOwogICAgICAgIHRoaXMuc3RhdHVzID0gMDsKICAgICAgICB0aGlzLnBlbmRpbmdfYnVmID0gbnVsbDsKICAgICAgICB0aGlzLnBlbmRpbmdfYnVmX3NpemUgPSAwOwogICAgICAgIHRoaXMucGVuZGluZ19vdXQgPSAwOwogICAgICAgIHRoaXMucGVuZGluZyA9IDA7CiAgICAgICAgdGhpcy53cmFwID0gMDsKICAgICAgICB0aGlzLmd6aGVhZCA9IG51bGw7CiAgICAgICAgdGhpcy5nemluZGV4ID0gMDsKICAgICAgICB0aGlzLm1ldGhvZCA9IFpfREVGTEFURUQ7CiAgICAgICAgdGhpcy5sYXN0X2ZsdXNoID0gLTE7CiAgICAgICAgdGhpcy53X3NpemUgPSAwOwogICAgICAgIHRoaXMud19iaXRzID0gMDsKICAgICAgICB0aGlzLndfbWFzayA9IDA7CiAgICAgICAgdGhpcy53aW5kb3cgPSBudWxsOwogICAgICAgIHRoaXMud2luZG93X3NpemUgPSAwOwogICAgICAgIHRoaXMucHJldiA9IG51bGw7CiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDsKICAgICAgICB0aGlzLmluc19oID0gMDsKICAgICAgICB0aGlzLmhhc2hfc2l6ZSA9IDA7CiAgICAgICAgdGhpcy5oYXNoX2JpdHMgPSAwOwogICAgICAgIHRoaXMuaGFzaF9tYXNrID0gMDsKICAgICAgICB0aGlzLmhhc2hfc2hpZnQgPSAwOwogICAgICAgIHRoaXMuYmxvY2tfc3RhcnQgPSAwOwogICAgICAgIHRoaXMubWF0Y2hfbGVuZ3RoID0gMDsKICAgICAgICB0aGlzLnByZXZfbWF0Y2ggPSAwOwogICAgICAgIHRoaXMubWF0Y2hfYXZhaWxhYmxlID0gMDsKICAgICAgICB0aGlzLnN0cnN0YXJ0ID0gMDsKICAgICAgICB0aGlzLm1hdGNoX3N0YXJ0ID0gMDsKICAgICAgICB0aGlzLmxvb2thaGVhZCA9IDA7CiAgICAgICAgdGhpcy5wcmV2X2xlbmd0aCA9IDA7CiAgICAgICAgdGhpcy5tYXhfY2hhaW5fbGVuZ3RoID0gMDsKICAgICAgICB0aGlzLm1heF9sYXp5X21hdGNoID0gMDsKICAgICAgICB0aGlzLmxldmVsID0gMDsKICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gMDsKICAgICAgICB0aGlzLmdvb2RfbWF0Y2ggPSAwOwogICAgICAgIHRoaXMubmljZV9tYXRjaCA9IDA7CiAgICAgICAgdGhpcy5keW5fbHRyZWUgPSBuZXcgdXRpbHMuQnVmMTYoSEVBUF9TSVpFICogMik7CiAgICAgICAgdGhpcy5keW5fZHRyZWUgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBEX0NPREVTICsgMSkgKiAyKTsKICAgICAgICB0aGlzLmJsX3RyZWUgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBCTF9DT0RFUyArIDEpICogMik7CiAgICAgICAgemVybyh0aGlzLmR5bl9sdHJlZSk7CiAgICAgICAgemVybyh0aGlzLmR5bl9kdHJlZSk7CiAgICAgICAgemVybyh0aGlzLmJsX3RyZWUpOwogICAgICAgIHRoaXMubF9kZXNjID0gbnVsbDsKICAgICAgICB0aGlzLmRfZGVzYyA9IG51bGw7CiAgICAgICAgdGhpcy5ibF9kZXNjID0gbnVsbDsKICAgICAgICB0aGlzLmJsX2NvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWF9CSVRTICsgMSk7CiAgICAgICAgdGhpcy5oZWFwID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7CiAgICAgICAgemVybyh0aGlzLmhlYXApOwogICAgICAgIHRoaXMuaGVhcF9sZW4gPSAwOwogICAgICAgIHRoaXMuaGVhcF9tYXggPSAwOwogICAgICAgIHRoaXMuZGVwdGggPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsKICAgICAgICB6ZXJvKHRoaXMuZGVwdGgpOwogICAgICAgIHRoaXMubF9idWYgPSAwOwogICAgICAgIHRoaXMubGl0X2J1ZnNpemUgPSAwOwogICAgICAgIHRoaXMubGFzdF9saXQgPSAwOwogICAgICAgIHRoaXMuZF9idWYgPSAwOwogICAgICAgIHRoaXMub3B0X2xlbiA9IDA7CiAgICAgICAgdGhpcy5zdGF0aWNfbGVuID0gMDsKICAgICAgICB0aGlzLm1hdGNoZXMgPSAwOwogICAgICAgIHRoaXMuaW5zZXJ0ID0gMDsKICAgICAgICB0aGlzLmJpX2J1ZiA9IDA7CiAgICAgICAgdGhpcy5iaV92YWxpZCA9IDA7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKSB7CiAgICAgICAgdmFyIHM7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTsKICAgICAgICB9CiAgICAgICAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gMDsKICAgICAgICBzdHJtLmRhdGFfdHlwZSA9IFpfVU5LTk9XTjsKICAgICAgICBzID0gc3RybS5zdGF0ZTsKICAgICAgICBzLnBlbmRpbmcgPSAwOwogICAgICAgIHMucGVuZGluZ19vdXQgPSAwOwogICAgICAgIGlmIChzLndyYXAgPCAwKSB7CiAgICAgICAgICBzLndyYXAgPSAtcy53cmFwOwogICAgICAgIH0KICAgICAgICBzLnN0YXR1cyA9IHMud3JhcCA/IElOSVRfU1RBVEUgOiBCVVNZX1NUQVRFOwogICAgICAgIHN0cm0uYWRsZXIgPSBzLndyYXAgPT09IDIgPyAwIDogMTsKICAgICAgICBzLmxhc3RfZmx1c2ggPSBaX05PX0ZMVVNIOwogICAgICAgIHRyZWVzLl90cl9pbml0KHMpOwogICAgICAgIHJldHVybiBaX09LOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVSZXNldChzdHJtKSB7CiAgICAgICAgdmFyIHJldCA9IGRlZmxhdGVSZXNldEtlZXAoc3RybSk7CiAgICAgICAgaWYgKHJldCA9PT0gWl9PSykgewogICAgICAgICAgbG1faW5pdChzdHJtLnN0YXRlKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJldDsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlU2V0SGVhZGVyKHN0cm0sIGhlYWQpIHsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgaWYgKHN0cm0uc3RhdGUud3JhcCAhPT0gMikgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdHJtLnN0YXRlLmd6aGVhZCA9IGhlYWQ7CiAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBtZXRob2QsIHdpbmRvd0JpdHMsIG1lbUxldmVsLCBzdHJhdGVneSkgewogICAgICAgIGlmICghc3RybSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICB2YXIgd3JhcCA9IDE7CiAgICAgICAgaWYgKGxldmVsID09PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04pIHsKICAgICAgICAgIGxldmVsID0gNjsKICAgICAgICB9CiAgICAgICAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7CiAgICAgICAgICB3cmFwID0gMDsKICAgICAgICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0czsKICAgICAgICB9IGVsc2UgaWYgKHdpbmRvd0JpdHMgPiAxNSkgewogICAgICAgICAgd3JhcCA9IDI7CiAgICAgICAgICB3aW5kb3dCaXRzIC09IDE2OwogICAgICAgIH0KICAgICAgICBpZiAobWVtTGV2ZWwgPCAxIHx8IG1lbUxldmVsID4gTUFYX01FTV9MRVZFTCB8fCBtZXRob2QgIT09IFpfREVGTEFURUQgfHwgd2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1IHx8IGxldmVsIDwgMCB8fCBsZXZlbCA+IDkgfHwgc3RyYXRlZ3kgPCAwIHx8IHN0cmF0ZWd5ID4gWl9GSVhFRCkgewogICAgICAgICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7CiAgICAgICAgfQogICAgICAgIGlmICh3aW5kb3dCaXRzID09PSA4KSB7CiAgICAgICAgICB3aW5kb3dCaXRzID0gOTsKICAgICAgICB9CiAgICAgICAgdmFyIHMgPSBuZXcgRGVmbGF0ZVN0YXRlKCk7CiAgICAgICAgc3RybS5zdGF0ZSA9IHM7CiAgICAgICAgcy5zdHJtID0gc3RybTsKICAgICAgICBzLndyYXAgPSB3cmFwOwogICAgICAgIHMuZ3poZWFkID0gbnVsbDsKICAgICAgICBzLndfYml0cyA9IHdpbmRvd0JpdHM7CiAgICAgICAgcy53X3NpemUgPSAxIDw8IHMud19iaXRzOwogICAgICAgIHMud19tYXNrID0gcy53X3NpemUgLSAxOwogICAgICAgIHMuaGFzaF9iaXRzID0gbWVtTGV2ZWwgKyA3OwogICAgICAgIHMuaGFzaF9zaXplID0gMSA8PCBzLmhhc2hfYml0czsKICAgICAgICBzLmhhc2hfbWFzayA9IHMuaGFzaF9zaXplIC0gMTsKICAgICAgICBzLmhhc2hfc2hpZnQgPSB+figocy5oYXNoX2JpdHMgKyBNSU5fTUFUQ0ggLSAxKSAvIE1JTl9NQVRDSCk7CiAgICAgICAgcy53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSAqIDIpOwogICAgICAgIHMuaGVhZCA9IG5ldyB1dGlscy5CdWYxNihzLmhhc2hfc2l6ZSk7CiAgICAgICAgcy5wcmV2ID0gbmV3IHV0aWxzLkJ1ZjE2KHMud19zaXplKTsKICAgICAgICBzLmxpdF9idWZzaXplID0gMSA8PCBtZW1MZXZlbCArIDY7CiAgICAgICAgcy5wZW5kaW5nX2J1Zl9zaXplID0gcy5saXRfYnVmc2l6ZSAqIDQ7CiAgICAgICAgcy5wZW5kaW5nX2J1ZiA9IG5ldyB1dGlscy5CdWY4KHMucGVuZGluZ19idWZfc2l6ZSk7CiAgICAgICAgcy5kX2J1ZiA9IDEgKiBzLmxpdF9idWZzaXplOwogICAgICAgIHMubF9idWYgPSAoMSArIDIpICogcy5saXRfYnVmc2l6ZTsKICAgICAgICBzLmxldmVsID0gbGV2ZWw7CiAgICAgICAgcy5zdHJhdGVneSA9IHN0cmF0ZWd5OwogICAgICAgIHMubWV0aG9kID0gbWV0aG9kOwogICAgICAgIHJldHVybiBkZWZsYXRlUmVzZXQoc3RybSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZUluaXQoc3RybSwgbGV2ZWwpIHsKICAgICAgICByZXR1cm4gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBaX0RFRkxBVEVELCBNQVhfV0JJVFMsIERFRl9NRU1fTEVWRUwsIFpfREVGQVVMVF9TVFJBVEVHWSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZShzdHJtLCBmbHVzaCkgewogICAgICAgIHZhciBvbGRfZmx1c2gsIHM7CiAgICAgICAgdmFyIGJlZywgdmFsOwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fCBmbHVzaCA+IFpfQkxPQ0sgfHwgZmx1c2ggPCAwKSB7CiAgICAgICAgICByZXR1cm4gc3RybSA/IGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUikgOiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgcyA9IHN0cm0uc3RhdGU7CiAgICAgICAgaWYgKCFzdHJtLm91dHB1dCB8fCAhc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwIHx8IHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgZmx1c2ggIT09IFpfRklOSVNIKSB7CiAgICAgICAgICByZXR1cm4gZXJyKHN0cm0sIHN0cm0uYXZhaWxfb3V0ID09PSAwID8gWl9CVUZfRVJST1IgOiBaX1NUUkVBTV9FUlJPUik7CiAgICAgICAgfQogICAgICAgIHMuc3RybSA9IHN0cm07CiAgICAgICAgb2xkX2ZsdXNoID0gcy5sYXN0X2ZsdXNoOwogICAgICAgIHMubGFzdF9mbHVzaCA9IGZsdXNoOwogICAgICAgIGlmIChzLnN0YXR1cyA9PT0gSU5JVF9TVEFURSkgewogICAgICAgICAgaWYgKHMud3JhcCA9PT0gMikgewogICAgICAgICAgICBzdHJtLmFkbGVyID0gMDsKICAgICAgICAgICAgcHV0X2J5dGUocywgMzEpOwogICAgICAgICAgICBwdXRfYnl0ZShzLCAxMzkpOwogICAgICAgICAgICBwdXRfYnl0ZShzLCA4KTsKICAgICAgICAgICAgaWYgKCFzLmd6aGVhZCkgewogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIDApOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIDApOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIDApOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIDApOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIDApOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDogcy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/IDQgOiAwKTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBPU19DT0RFKTsKICAgICAgICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRleHQgPyAxIDogMCkgKyAocy5nemhlYWQuaGNyYyA/IDIgOiAwKSArICghcy5nemhlYWQuZXh0cmEgPyAwIDogNCkgKyAoIXMuZ3poZWFkLm5hbWUgPyAwIDogOCkgKyAoIXMuZ3poZWFkLmNvbW1lbnQgPyAwIDogMTYpKTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lICYgMjU1KTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lID4+IDggJiAyNTUpOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgPj4gMTYgJiAyNTUpOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgPj4gMjQgJiAyNTUpOwogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDogcy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/IDQgOiAwKTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5vcyAmIDI1NSk7CiAgICAgICAgICAgICAgaWYgKHMuZ3poZWFkLmV4dHJhICYmIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkgewogICAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMjU1KTsKICAgICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCA+PiA4ICYgMjU1KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMpIHsKICAgICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcsIDApOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBzLmd6aW5kZXggPSAwOwogICAgICAgICAgICAgIHMuc3RhdHVzID0gRVhUUkFfU1RBVEU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHZhciBoZWFkZXIgPSBaX0RFRkxBVEVEICsgKHMud19iaXRzIC0gOCA8PCA0KSA8PCA4OwogICAgICAgICAgICB2YXIgbGV2ZWxfZmxhZ3MgPSAtMTsKICAgICAgICAgICAgaWYgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIpIHsKICAgICAgICAgICAgICBsZXZlbF9mbGFncyA9IDA7CiAgICAgICAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA8IDYpIHsKICAgICAgICAgICAgICBsZXZlbF9mbGFncyA9IDE7CiAgICAgICAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA9PT0gNikgewogICAgICAgICAgICAgIGxldmVsX2ZsYWdzID0gMjsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBsZXZlbF9mbGFncyA9IDM7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaGVhZGVyIHw9IGxldmVsX2ZsYWdzIDw8IDY7CiAgICAgICAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7CiAgICAgICAgICAgICAgaGVhZGVyIHw9IFBSRVNFVF9ESUNUOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGhlYWRlciArPSAzMSAtIGhlYWRlciAlIDMxOwogICAgICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7CiAgICAgICAgICAgIHB1dFNob3J0TVNCKHMsIGhlYWRlcik7CiAgICAgICAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7CiAgICAgICAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpOwogICAgICAgICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiA2NTUzNSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgc3RybS5hZGxlciA9IDE7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChzLnN0YXR1cyA9PT0gRVhUUkFfU1RBVEUpIHsKICAgICAgICAgIGlmIChzLmd6aGVhZC5leHRyYSkgewogICAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7CiAgICAgICAgICAgIHdoaWxlIChzLmd6aW5kZXggPCAocy5nemhlYWQuZXh0cmEubGVuZ3RoICYgNjU1MzUpKSB7CiAgICAgICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHsKICAgICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7CiAgICAgICAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7CiAgICAgICAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhW3MuZ3ppbmRleF0gJiAyNTUpOwogICAgICAgICAgICAgIHMuZ3ppbmRleCsrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykgewogICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMuZ3ppbmRleCA9PT0gcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7CiAgICAgICAgICAgICAgcy5nemluZGV4ID0gMDsKICAgICAgICAgICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHMuc3RhdHVzID09PSBOQU1FX1NUQVRFKSB7CiAgICAgICAgICBpZiAocy5nemhlYWQubmFtZSkgewogICAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykgewogICAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTsKICAgICAgICAgICAgICAgIGJlZyA9IHMucGVuZGluZzsKICAgICAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgICAgICB2YWwgPSAxOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLm5hbWUubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5uYW1lLmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMjU1OwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB2YWwgPSAwOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBwdXRfYnl0ZShzLCB2YWwpOwogICAgICAgICAgICB9IHdoaWxlICh2YWwgIT09IDApOwogICAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHsKICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh2YWwgPT09IDApIHsKICAgICAgICAgICAgICBzLmd6aW5kZXggPSAwOwogICAgICAgICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocy5zdGF0dXMgPT09IENPTU1FTlRfU1RBVEUpIHsKICAgICAgICAgIGlmIChzLmd6aGVhZC5jb21tZW50KSB7CiAgICAgICAgICAgIGJlZyA9IHMucGVuZGluZzsKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pOwogICAgICAgICAgICAgICAgYmVnID0gcy5wZW5kaW5nOwogICAgICAgICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgICAgIHZhbCA9IDE7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQuY29tbWVudC5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLmNvbW1lbnQuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAyNTU7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHZhbCA9IDA7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7CiAgICAgICAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7CiAgICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykgewogICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHZhbCA9PT0gMCkgewogICAgICAgICAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocy5zdGF0dXMgPT09IEhDUkNfU1RBVEUpIHsKICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7CiAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgKyAyID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocy5wZW5kaW5nICsgMiA8PSBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMjU1KTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyID4+IDggJiAyNTUpOwogICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSAwOwogICAgICAgICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocy5wZW5kaW5nICE9PSAwKSB7CiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pOwogICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHMubGFzdF9mbHVzaCA9IC0xOwogICAgICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgcmFuayhmbHVzaCkgPD0gcmFuayhvbGRfZmx1c2gpICYmIGZsdXNoICE9PSBaX0ZJTklTSCkgewogICAgICAgICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7CiAgICAgICAgfQogICAgICAgIGlmIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHsKICAgICAgICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpOwogICAgICAgIH0KICAgICAgICBpZiAoc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLmxvb2thaGVhZCAhPT0gMCB8fCBmbHVzaCAhPT0gWl9OT19GTFVTSCAmJiBzLnN0YXR1cyAhPT0gRklOSVNIX1NUQVRFKSB7CiAgICAgICAgICB2YXIgYnN0YXRlID0gcy5zdHJhdGVneSA9PT0gWl9IVUZGTUFOX09OTFkgPyBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIDogcy5zdHJhdGVneSA9PT0gWl9STEUgPyBkZWZsYXRlX3JsZShzLCBmbHVzaCkgOiBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmZ1bmMocywgZmx1c2gpOwogICAgICAgICAgaWYgKGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfRE9ORSkgewogICAgICAgICAgICBzLnN0YXR1cyA9IEZJTklTSF9TVEFURTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChic3RhdGUgPT09IEJTX05FRURfTU9SRSB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEKSB7CiAgICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHMubGFzdF9mbHVzaCA9IC0xOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBaX09LOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGJzdGF0ZSA9PT0gQlNfQkxPQ0tfRE9ORSkgewogICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfUEFSVElBTF9GTFVTSCkgewogICAgICAgICAgICAgIHRyZWVzLl90cl9hbGlnbihzKTsKICAgICAgICAgICAgfSBlbHNlIGlmIChmbHVzaCAhPT0gWl9CTE9DSykgewogICAgICAgICAgICAgIHRyZWVzLl90cl9zdG9yZWRfYmxvY2socywgMCwgMCwgZmFsc2UpOwogICAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9GVUxMX0ZMVVNIKSB7CiAgICAgICAgICAgICAgICB6ZXJvKHMuaGVhZCk7CiAgICAgICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsKICAgICAgICAgICAgICAgICAgcy5zdHJzdGFydCA9IDA7CiAgICAgICAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwOwogICAgICAgICAgICAgICAgICBzLmluc2VydCA9IDA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7CiAgICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHMubGFzdF9mbHVzaCA9IC0xOwogICAgICAgICAgICAgIHJldHVybiBaX09LOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChmbHVzaCAhPT0gWl9GSU5JU0gpIHsKICAgICAgICAgIHJldHVybiBaX09LOwogICAgICAgIH0KICAgICAgICBpZiAocy53cmFwIDw9IDApIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FTkQ7CiAgICAgICAgfQogICAgICAgIGlmIChzLndyYXAgPT09IDIpIHsKICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAyNTUpOwogICAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciA+PiA4ICYgMjU1KTsKICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgPj4gMTYgJiAyNTUpOwogICAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciA+PiAyNCAmIDI1NSk7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luICYgMjU1KTsKICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gPj4gOCAmIDI1NSk7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luID4+IDE2ICYgMjU1KTsKICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gPj4gMjQgJiAyNTUpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7CiAgICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgNjU1MzUpOwogICAgICAgIH0KICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pOwogICAgICAgIGlmIChzLndyYXAgPiAwKSB7CiAgICAgICAgICBzLndyYXAgPSAtcy53cmFwOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcy5wZW5kaW5nICE9PSAwID8gWl9PSyA6IFpfU1RSRUFNX0VORDsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlRW5kKHN0cm0pIHsKICAgICAgICB2YXIgc3RhdHVzOwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0dXMgPSBzdHJtLnN0YXRlLnN0YXR1czsKICAgICAgICBpZiAoc3RhdHVzICE9PSBJTklUX1NUQVRFICYmIHN0YXR1cyAhPT0gRVhUUkFfU1RBVEUgJiYgc3RhdHVzICE9PSBOQU1FX1NUQVRFICYmIHN0YXR1cyAhPT0gQ09NTUVOVF9TVEFURSAmJiBzdGF0dXMgIT09IEhDUkNfU1RBVEUgJiYgc3RhdHVzICE9PSBCVVNZX1NUQVRFICYmIHN0YXR1cyAhPT0gRklOSVNIX1NUQVRFKSB7CiAgICAgICAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTsKICAgICAgICB9CiAgICAgICAgc3RybS5zdGF0ZSA9IG51bGw7CiAgICAgICAgcmV0dXJuIHN0YXR1cyA9PT0gQlVTWV9TVEFURSA/IGVycihzdHJtLCBaX0RBVEFfRVJST1IpIDogWl9PSzsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7CiAgICAgICAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDsKICAgICAgICB2YXIgczsKICAgICAgICB2YXIgc3RyLCBuOwogICAgICAgIHZhciB3cmFwOwogICAgICAgIHZhciBhdmFpbDsKICAgICAgICB2YXIgbmV4dDsKICAgICAgICB2YXIgaW5wdXQ7CiAgICAgICAgdmFyIHRtcERpY3Q7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHMgPSBzdHJtLnN0YXRlOwogICAgICAgIHdyYXAgPSBzLndyYXA7CiAgICAgICAgaWYgKHdyYXAgPT09IDIgfHwgd3JhcCA9PT0gMSAmJiBzLnN0YXR1cyAhPT0gSU5JVF9TVEFURSB8fCBzLmxvb2thaGVhZCkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBpZiAod3JhcCA9PT0gMSkgewogICAgICAgICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7CiAgICAgICAgfQogICAgICAgIHMud3JhcCA9IDA7CiAgICAgICAgaWYgKGRpY3RMZW5ndGggPj0gcy53X3NpemUpIHsKICAgICAgICAgIGlmICh3cmFwID09PSAwKSB7CiAgICAgICAgICAgIHplcm8ocy5oZWFkKTsKICAgICAgICAgICAgcy5zdHJzdGFydCA9IDA7CiAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwOwogICAgICAgICAgICBzLmluc2VydCA9IDA7CiAgICAgICAgICB9CiAgICAgICAgICB0bXBEaWN0ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUpOwogICAgICAgICAgdXRpbHMuYXJyYXlTZXQodG1wRGljdCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCAtIHMud19zaXplLCBzLndfc2l6ZSwgMCk7CiAgICAgICAgICBkaWN0aW9uYXJ5ID0gdG1wRGljdDsKICAgICAgICAgIGRpY3RMZW5ndGggPSBzLndfc2l6ZTsKICAgICAgICB9CiAgICAgICAgYXZhaWwgPSBzdHJtLmF2YWlsX2luOwogICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47CiAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0OwogICAgICAgIHN0cm0uYXZhaWxfaW4gPSBkaWN0TGVuZ3RoOwogICAgICAgIHN0cm0ubmV4dF9pbiA9IDA7CiAgICAgICAgc3RybS5pbnB1dCA9IGRpY3Rpb25hcnk7CiAgICAgICAgZmlsbF93aW5kb3cocyk7CiAgICAgICAgd2hpbGUgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkgewogICAgICAgICAgc3RyID0gcy5zdHJzdGFydDsKICAgICAgICAgIG4gPSBzLmxvb2thaGVhZCAtIChNSU5fTUFUQ0ggLSAxKTsKICAgICAgICAgIGRvIHsKICAgICAgICAgICAgcy5pbnNfaCA9IChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrOwogICAgICAgICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdOwogICAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7CiAgICAgICAgICAgIHN0cisrOwogICAgICAgICAgfSB3aGlsZSAoLS1uKTsKICAgICAgICAgIHMuc3Ryc3RhcnQgPSBzdHI7CiAgICAgICAgICBzLmxvb2thaGVhZCA9IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICB9CiAgICAgICAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDsKICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDsKICAgICAgICBzLmluc2VydCA9IHMubG9va2FoZWFkOwogICAgICAgIHMubG9va2FoZWFkID0gMDsKICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxOwogICAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDsKICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0OwogICAgICAgIHN0cm0uaW5wdXQgPSBpbnB1dDsKICAgICAgICBzdHJtLmF2YWlsX2luID0gYXZhaWw7CiAgICAgICAgcy53cmFwID0gd3JhcDsKICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgfQogICAgICBleHBvcnRzLmRlZmxhdGVJbml0ID0gZGVmbGF0ZUluaXQ7CiAgICAgIGV4cG9ydHMuZGVmbGF0ZUluaXQyID0gZGVmbGF0ZUluaXQyOwogICAgICBleHBvcnRzLmRlZmxhdGVSZXNldCA9IGRlZmxhdGVSZXNldDsKICAgICAgZXhwb3J0cy5kZWZsYXRlUmVzZXRLZWVwID0gZGVmbGF0ZVJlc2V0S2VlcDsKICAgICAgZXhwb3J0cy5kZWZsYXRlU2V0SGVhZGVyID0gZGVmbGF0ZVNldEhlYWRlcjsKICAgICAgZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTsKICAgICAgZXhwb3J0cy5kZWZsYXRlRW5kID0gZGVmbGF0ZUVuZDsKICAgICAgZXhwb3J0cy5kZWZsYXRlU2V0RGljdGlvbmFyeSA9IGRlZmxhdGVTZXREaWN0aW9uYXJ5OwogICAgICBleHBvcnRzLmRlZmxhdGVJbmZvID0gInBha28gZGVmbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCkiOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvc3RyaW5ncy5qcwogIHZhciByZXF1aXJlX3N0cmluZ3MgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvc3RyaW5ncy5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZV9jb21tb24yKCk7CiAgICAgIHZhciBTVFJfQVBQTFlfT0sgPSB0cnVlOwogICAgICB2YXIgU1RSX0FQUExZX1VJQV9PSyA9IHRydWU7CiAgICAgIHRyeSB7CiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBbMF0pOwogICAgICB9IGNhdGNoIChfXykgewogICAgICAgIFNUUl9BUFBMWV9PSyA9IGZhbHNlOwogICAgICB9CiAgICAgIHRyeSB7CiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7CiAgICAgIH0gY2F0Y2ggKF9fKSB7CiAgICAgICAgU1RSX0FQUExZX1VJQV9PSyA9IGZhbHNlOwogICAgICB9CiAgICAgIHZhciBfdXRmOGxlbiA9IG5ldyB1dGlscy5CdWY4KDI1Nik7CiAgICAgIGZvciAocSA9IDA7IHEgPCAyNTY7IHErKykgewogICAgICAgIF91dGY4bGVuW3FdID0gcSA+PSAyNTIgPyA2IDogcSA+PSAyNDggPyA1IDogcSA+PSAyNDAgPyA0IDogcSA+PSAyMjQgPyAzIDogcSA+PSAxOTIgPyAyIDogMTsKICAgICAgfQogICAgICB2YXIgcTsKICAgICAgX3V0ZjhsZW5bMjU0XSA9IF91dGY4bGVuWzI1NF0gPSAxOwogICAgICBleHBvcnRzLnN0cmluZzJidWYgPSBmdW5jdGlvbihzdHIpIHsKICAgICAgICB2YXIgYnVmLCBjLCBjMiwgbV9wb3MsIGksIHN0cl9sZW4gPSBzdHIubGVuZ3RoLCBidWZfbGVuID0gMDsKICAgICAgICBmb3IgKG1fcG9zID0gMDsgbV9wb3MgPCBzdHJfbGVuOyBtX3BvcysrKSB7CiAgICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpOwogICAgICAgICAgaWYgKChjICYgNjQ1MTIpID09PSA1NTI5NiAmJiBtX3BvcyArIDEgPCBzdHJfbGVuKSB7CiAgICAgICAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTsKICAgICAgICAgICAgaWYgKChjMiAmIDY0NTEyKSA9PT0gNTYzMjApIHsKICAgICAgICAgICAgICBjID0gNjU1MzYgKyAoYyAtIDU1Mjk2IDw8IDEwKSArIChjMiAtIDU2MzIwKTsKICAgICAgICAgICAgICBtX3BvcysrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBidWZfbGVuICs9IGMgPCAxMjggPyAxIDogYyA8IDIwNDggPyAyIDogYyA8IDY1NTM2ID8gMyA6IDQ7CiAgICAgICAgfQogICAgICAgIGJ1ZiA9IG5ldyB1dGlscy5CdWY4KGJ1Zl9sZW4pOwogICAgICAgIGZvciAoaSA9IDAsIG1fcG9zID0gMDsgaSA8IGJ1Zl9sZW47IG1fcG9zKyspIHsKICAgICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7CiAgICAgICAgICBpZiAoKGMgJiA2NDUxMikgPT09IDU1Mjk2ICYmIG1fcG9zICsgMSA8IHN0cl9sZW4pIHsKICAgICAgICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpOwogICAgICAgICAgICBpZiAoKGMyICYgNjQ1MTIpID09PSA1NjMyMCkgewogICAgICAgICAgICAgIGMgPSA2NTUzNiArIChjIC0gNTUyOTYgPDwgMTApICsgKGMyIC0gNTYzMjApOwogICAgICAgICAgICAgIG1fcG9zKys7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChjIDwgMTI4KSB7CiAgICAgICAgICAgIGJ1ZltpKytdID0gYzsKICAgICAgICAgIH0gZWxzZSBpZiAoYyA8IDIwNDgpIHsKICAgICAgICAgICAgYnVmW2krK10gPSAxOTIgfCBjID4+PiA2OwogICAgICAgICAgICBidWZbaSsrXSA9IDEyOCB8IGMgJiA2MzsKICAgICAgICAgIH0gZWxzZSBpZiAoYyA8IDY1NTM2KSB7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMjI0IHwgYyA+Pj4gMTI7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMTI4IHwgYyA+Pj4gNiAmIDYzOwogICAgICAgICAgICBidWZbaSsrXSA9IDEyOCB8IGMgJiA2MzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMjQwIHwgYyA+Pj4gMTg7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMTI4IHwgYyA+Pj4gMTIgJiA2MzsKICAgICAgICAgICAgYnVmW2krK10gPSAxMjggfCBjID4+PiA2ICYgNjM7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMTI4IHwgYyAmIDYzOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gYnVmOwogICAgICB9OwogICAgICBmdW5jdGlvbiBidWYyYmluc3RyaW5nKGJ1ZiwgbGVuKSB7CiAgICAgICAgaWYgKGxlbiA8IDY1NTM0KSB7CiAgICAgICAgICBpZiAoYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9VSUFfT0sgfHwgIWJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfT0spIHsKICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdXRpbHMuc2hyaW5rQnVmKGJ1ZiwgbGVuKSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHZhciByZXN1bHQgPSAiIjsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICB9CiAgICAgIGV4cG9ydHMuYnVmMmJpbnN0cmluZyA9IGZ1bmN0aW9uKGJ1ZikgewogICAgICAgIHJldHVybiBidWYyYmluc3RyaW5nKGJ1ZiwgYnVmLmxlbmd0aCk7CiAgICAgIH07CiAgICAgIGV4cG9ydHMuYmluc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uKHN0cikgewogICAgICAgIHZhciBidWYgPSBuZXcgdXRpbHMuQnVmOChzdHIubGVuZ3RoKTsKICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgICBidWZbaV0gPSBzdHIuY2hhckNvZGVBdChpKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfTsKICAgICAgZXhwb3J0cy5idWYyc3RyaW5nID0gZnVuY3Rpb24oYnVmLCBtYXgpIHsKICAgICAgICB2YXIgaSwgb3V0LCBjLCBjX2xlbjsKICAgICAgICB2YXIgbGVuID0gbWF4IHx8IGJ1Zi5sZW5ndGg7CiAgICAgICAgdmFyIHV0ZjE2YnVmID0gbmV3IEFycmF5KGxlbiAqIDIpOwogICAgICAgIGZvciAob3V0ID0gMCwgaSA9IDA7IGkgPCBsZW47ICkgewogICAgICAgICAgYyA9IGJ1ZltpKytdOwogICAgICAgICAgaWYgKGMgPCAxMjgpIHsKICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gYzsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgICBjX2xlbiA9IF91dGY4bGVuW2NdOwogICAgICAgICAgaWYgKGNfbGVuID4gNCkgewogICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSA2NTUzMzsKICAgICAgICAgICAgaSArPSBjX2xlbiAtIDE7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgYyAmPSBjX2xlbiA9PT0gMiA/IDMxIDogY19sZW4gPT09IDMgPyAxNSA6IDc7CiAgICAgICAgICB3aGlsZSAoY19sZW4gPiAxICYmIGkgPCBsZW4pIHsKICAgICAgICAgICAgYyA9IGMgPDwgNiB8IGJ1ZltpKytdICYgNjM7CiAgICAgICAgICAgIGNfbGVuLS07CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoY19sZW4gPiAxKSB7CiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDY1NTMzOwogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChjIDwgNjU1MzYpIHsKICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gYzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGMgLT0gNjU1MzY7CiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDU1Mjk2IHwgYyA+PiAxMCAmIDEwMjM7CiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDU2MzIwIHwgYyAmIDEwMjM7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBidWYyYmluc3RyaW5nKHV0ZjE2YnVmLCBvdXQpOwogICAgICB9OwogICAgICBleHBvcnRzLnV0Zjhib3JkZXIgPSBmdW5jdGlvbihidWYsIG1heCkgewogICAgICAgIHZhciBwb3M7CiAgICAgICAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7CiAgICAgICAgaWYgKG1heCA+IGJ1Zi5sZW5ndGgpIHsKICAgICAgICAgIG1heCA9IGJ1Zi5sZW5ndGg7CiAgICAgICAgfQogICAgICAgIHBvcyA9IG1heCAtIDE7CiAgICAgICAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDE5MikgPT09IDEyOCkgewogICAgICAgICAgcG9zLS07CiAgICAgICAgfQogICAgICAgIGlmIChwb3MgPCAwKSB7CiAgICAgICAgICByZXR1cm4gbWF4OwogICAgICAgIH0KICAgICAgICBpZiAocG9zID09PSAwKSB7CiAgICAgICAgICByZXR1cm4gbWF4OwogICAgICAgIH0KICAgICAgICByZXR1cm4gcG9zICsgX3V0ZjhsZW5bYnVmW3Bvc11dID4gbWF4ID8gcG9zIDogbWF4OwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi96c3RyZWFtLmpzCiAgdmFyIHJlcXVpcmVfenN0cmVhbSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3pzdHJlYW0uanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgZnVuY3Rpb24gWlN0cmVhbSgpIHsKICAgICAgICB0aGlzLmlucHV0ID0gbnVsbDsKICAgICAgICB0aGlzLm5leHRfaW4gPSAwOwogICAgICAgIHRoaXMuYXZhaWxfaW4gPSAwOwogICAgICAgIHRoaXMudG90YWxfaW4gPSAwOwogICAgICAgIHRoaXMub3V0cHV0ID0gbnVsbDsKICAgICAgICB0aGlzLm5leHRfb3V0ID0gMDsKICAgICAgICB0aGlzLmF2YWlsX291dCA9IDA7CiAgICAgICAgdGhpcy50b3RhbF9vdXQgPSAwOwogICAgICAgIHRoaXMubXNnID0gIiI7CiAgICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7CiAgICAgICAgdGhpcy5kYXRhX3R5cGUgPSAyOwogICAgICAgIHRoaXMuYWRsZXIgPSAwOwogICAgICB9CiAgICAgIG1vZHVsZS5leHBvcnRzID0gWlN0cmVhbTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL2RlZmxhdGUuanMKICB2YXIgcmVxdWlyZV9kZWZsYXRlMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi9kZWZsYXRlLmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgemxpYl9kZWZsYXRlID0gcmVxdWlyZV9kZWZsYXRlKCk7CiAgICAgIHZhciB1dGlscyA9IHJlcXVpcmVfY29tbW9uMigpOwogICAgICB2YXIgc3RyaW5ncyA9IHJlcXVpcmVfc3RyaW5ncygpOwogICAgICB2YXIgbXNnID0gcmVxdWlyZV9tZXNzYWdlczIoKTsKICAgICAgdmFyIFpTdHJlYW0gPSByZXF1aXJlX3pzdHJlYW0oKTsKICAgICAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzsKICAgICAgdmFyIFpfTk9fRkxVU0ggPSAwOwogICAgICB2YXIgWl9GSU5JU0ggPSA0OwogICAgICB2YXIgWl9PSyA9IDA7CiAgICAgIHZhciBaX1NUUkVBTV9FTkQgPSAxOwogICAgICB2YXIgWl9TWU5DX0ZMVVNIID0gMjsKICAgICAgdmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xOwogICAgICB2YXIgWl9ERUZBVUxUX1NUUkFURUdZID0gMDsKICAgICAgdmFyIFpfREVGTEFURUQgPSA4OwogICAgICBmdW5jdGlvbiBEZWZsYXRlKG9wdGlvbnMpIHsKICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVmbGF0ZSkpCiAgICAgICAgICByZXR1cm4gbmV3IERlZmxhdGUob3B0aW9ucyk7CiAgICAgICAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHsKICAgICAgICAgIGxldmVsOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04sCiAgICAgICAgICBtZXRob2Q6IFpfREVGTEFURUQsCiAgICAgICAgICBjaHVua1NpemU6IDE2Mzg0LAogICAgICAgICAgd2luZG93Qml0czogMTUsCiAgICAgICAgICBtZW1MZXZlbDogOCwKICAgICAgICAgIHN0cmF0ZWd5OiBaX0RFRkFVTFRfU1RSQVRFR1ksCiAgICAgICAgICB0bzogIiIKICAgICAgICB9LCBvcHRpb25zIHx8IHt9KTsKICAgICAgICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zOwogICAgICAgIGlmIChvcHQucmF3ICYmIG9wdC53aW5kb3dCaXRzID4gMCkgewogICAgICAgICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7CiAgICAgICAgfSBlbHNlIGlmIChvcHQuZ3ppcCAmJiBvcHQud2luZG93Qml0cyA+IDAgJiYgb3B0LndpbmRvd0JpdHMgPCAxNikgewogICAgICAgICAgb3B0LndpbmRvd0JpdHMgKz0gMTY7CiAgICAgICAgfQogICAgICAgIHRoaXMuZXJyID0gMDsKICAgICAgICB0aGlzLm1zZyA9ICIiOwogICAgICAgIHRoaXMuZW5kZWQgPSBmYWxzZTsKICAgICAgICB0aGlzLmNodW5rcyA9IFtdOwogICAgICAgIHRoaXMuc3RybSA9IG5ldyBaU3RyZWFtKCk7CiAgICAgICAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7CiAgICAgICAgdmFyIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlSW5pdDIodGhpcy5zdHJtLCBvcHQubGV2ZWwsIG9wdC5tZXRob2QsIG9wdC53aW5kb3dCaXRzLCBvcHQubWVtTGV2ZWwsIG9wdC5zdHJhdGVneSk7CiAgICAgICAgaWYgKHN0YXR1cyAhPT0gWl9PSykgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTsKICAgICAgICB9CiAgICAgICAgaWYgKG9wdC5oZWFkZXIpIHsKICAgICAgICAgIHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0SGVhZGVyKHRoaXMuc3RybSwgb3B0LmhlYWRlcik7CiAgICAgICAgfQogICAgICAgIGlmIChvcHQuZGljdGlvbmFyeSkgewogICAgICAgICAgdmFyIGRpY3Q7CiAgICAgICAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAic3RyaW5nIikgewogICAgICAgICAgICBkaWN0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTsKICAgICAgICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICJbb2JqZWN0IEFycmF5QnVmZmVyXSIpIHsKICAgICAgICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGRpY3QgPSBvcHQuZGljdGlvbmFyeTsKICAgICAgICAgIH0KICAgICAgICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpOwogICAgICAgICAgaWYgKHN0YXR1cyAhPT0gWl9PSykgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5fZGljdF9zZXQgPSB0cnVlOwogICAgICAgIH0KICAgICAgfQogICAgICBEZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oZGF0YSwgbW9kZSkgewogICAgICAgIHZhciBzdHJtID0gdGhpcy5zdHJtOwogICAgICAgIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplOwogICAgICAgIHZhciBzdGF0dXMsIF9tb2RlOwogICAgICAgIGlmICh0aGlzLmVuZGVkKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIF9tb2RlID0gbW9kZSA9PT0gfn5tb2RlID8gbW9kZSA6IG1vZGUgPT09IHRydWUgPyBaX0ZJTklTSCA6IFpfTk9fRkxVU0g7CiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAic3RyaW5nIikgewogICAgICAgICAgc3RybS5pbnB1dCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihkYXRhKTsKICAgICAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICJbb2JqZWN0IEFycmF5QnVmZmVyXSIpIHsKICAgICAgICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgc3RybS5pbnB1dCA9IGRhdGE7CiAgICAgICAgfQogICAgICAgIHN0cm0ubmV4dF9pbiA9IDA7CiAgICAgICAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoOwogICAgICAgIGRvIHsKICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7CiAgICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSAwOwogICAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTsKICAgICAgICAgIH0KICAgICAgICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlKHN0cm0sIF9tb2RlKTsKICAgICAgICAgIGlmIChzdGF0dXMgIT09IFpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IFpfT0spIHsKICAgICAgICAgICAgdGhpcy5vbkVuZChzdGF0dXMpOwogICAgICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBaX0ZJTklTSCB8fCBfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIKSkgewogICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAic3RyaW5nIikgewogICAgICAgICAgICAgIHRoaXMub25EYXRhKHN0cmluZ3MuYnVmMmJpbnN0cmluZyh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgdGhpcy5vbkRhdGEodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gWl9TVFJFQU1fRU5EKTsKICAgICAgICBpZiAoX21vZGUgPT09IFpfRklOSVNIKSB7CiAgICAgICAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZUVuZCh0aGlzLnN0cm0pOwogICAgICAgICAgdGhpcy5vbkVuZChzdGF0dXMpOwogICAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7CiAgICAgICAgICByZXR1cm4gc3RhdHVzID09PSBaX09LOwogICAgICAgIH0KICAgICAgICBpZiAoX21vZGUgPT09IFpfU1lOQ19GTFVTSCkgewogICAgICAgICAgdGhpcy5vbkVuZChaX09LKTsKICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gMDsKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfTsKICAgICAgRGVmbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oY2h1bmspIHsKICAgICAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTsKICAgICAgfTsKICAgICAgRGVmbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbihzdGF0dXMpIHsKICAgICAgICBpZiAoc3RhdHVzID09PSBaX09LKSB7CiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAic3RyaW5nIikgewogICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oIiIpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTsKICAgICAgICB0aGlzLmVyciA9IHN0YXR1czsKICAgICAgICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHsKICAgICAgICB2YXIgZGVmbGF0b3IgPSBuZXcgRGVmbGF0ZShvcHRpb25zKTsKICAgICAgICBkZWZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTsKICAgICAgICBpZiAoZGVmbGF0b3IuZXJyKSB7CiAgICAgICAgICB0aHJvdyBkZWZsYXRvci5tc2cgfHwgbXNnW2RlZmxhdG9yLmVycl07CiAgICAgICAgfQogICAgICAgIHJldHVybiBkZWZsYXRvci5yZXN1bHQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykgewogICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwogICAgICAgIG9wdGlvbnMucmF3ID0gdHJ1ZTsKICAgICAgICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZ3ppcChpbnB1dCwgb3B0aW9ucykgewogICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwogICAgICAgIG9wdGlvbnMuZ3ppcCA9IHRydWU7CiAgICAgICAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpOwogICAgICB9CiAgICAgIGV4cG9ydHMuRGVmbGF0ZSA9IERlZmxhdGU7CiAgICAgIGV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7CiAgICAgIGV4cG9ydHMuZGVmbGF0ZVJhdyA9IGRlZmxhdGVSYXc7CiAgICAgIGV4cG9ydHMuZ3ppcCA9IGd6aXA7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmZhc3QuanMKICB2YXIgcmVxdWlyZV9pbmZmYXN0ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mZmFzdC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgQkFEID0gMzA7CiAgICAgIHZhciBUWVBFID0gMTI7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV9mYXN0KHN0cm0sIHN0YXJ0KSB7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIHZhciBfaW47CiAgICAgICAgdmFyIGxhc3Q7CiAgICAgICAgdmFyIF9vdXQ7CiAgICAgICAgdmFyIGJlZzsKICAgICAgICB2YXIgZW5kOwogICAgICAgIHZhciBkbWF4OwogICAgICAgIHZhciB3c2l6ZTsKICAgICAgICB2YXIgd2hhdmU7CiAgICAgICAgdmFyIHduZXh0OwogICAgICAgIHZhciBzX3dpbmRvdzsKICAgICAgICB2YXIgaG9sZDsKICAgICAgICB2YXIgYml0czsKICAgICAgICB2YXIgbGNvZGU7CiAgICAgICAgdmFyIGRjb2RlOwogICAgICAgIHZhciBsbWFzazsKICAgICAgICB2YXIgZG1hc2s7CiAgICAgICAgdmFyIGhlcmU7CiAgICAgICAgdmFyIG9wOwogICAgICAgIHZhciBsZW47CiAgICAgICAgdmFyIGRpc3Q7CiAgICAgICAgdmFyIGZyb207CiAgICAgICAgdmFyIGZyb21fc291cmNlOwogICAgICAgIHZhciBpbnB1dCwgb3V0cHV0OwogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBfaW4gPSBzdHJtLm5leHRfaW47CiAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0OwogICAgICAgIGxhc3QgPSBfaW4gKyAoc3RybS5hdmFpbF9pbiAtIDUpOwogICAgICAgIF9vdXQgPSBzdHJtLm5leHRfb3V0OwogICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0OwogICAgICAgIGJlZyA9IF9vdXQgLSAoc3RhcnQgLSBzdHJtLmF2YWlsX291dCk7CiAgICAgICAgZW5kID0gX291dCArIChzdHJtLmF2YWlsX291dCAtIDI1Nyk7CiAgICAgICAgZG1heCA9IHN0YXRlLmRtYXg7CiAgICAgICAgd3NpemUgPSBzdGF0ZS53c2l6ZTsKICAgICAgICB3aGF2ZSA9IHN0YXRlLndoYXZlOwogICAgICAgIHduZXh0ID0gc3RhdGUud25leHQ7CiAgICAgICAgc193aW5kb3cgPSBzdGF0ZS53aW5kb3c7CiAgICAgICAgaG9sZCA9IHN0YXRlLmhvbGQ7CiAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7CiAgICAgICAgbGNvZGUgPSBzdGF0ZS5sZW5jb2RlOwogICAgICAgIGRjb2RlID0gc3RhdGUuZGlzdGNvZGU7CiAgICAgICAgbG1hc2sgPSAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDE7CiAgICAgICAgZG1hc2sgPSAoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxOwogICAgICAgIHRvcDoKICAgICAgICAgIGRvIHsKICAgICAgICAgICAgaWYgKGJpdHMgPCAxNSkgewogICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICB9CiAgICAgICAgICAgIGhlcmUgPSBsY29kZVtob2xkICYgbG1hc2tdOwogICAgICAgICAgICBkb2xlbjoKICAgICAgICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gb3A7CiAgICAgICAgICAgICAgICBiaXRzIC09IG9wOwogICAgICAgICAgICAgICAgb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgIGlmIChvcCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3AgJiAxNikgewogICAgICAgICAgICAgICAgICBsZW4gPSBoZXJlICYgNjU1MzU7CiAgICAgICAgICAgICAgICAgIG9wICY9IDE1OwogICAgICAgICAgICAgICAgICBpZiAob3ApIHsKICAgICAgICAgICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7CiAgICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBsZW4gKz0gaG9sZCAmICgxIDw8IG9wKSAtIDE7CiAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IG9wOwogICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gb3A7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGJpdHMgPCAxNSkgewogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhlcmUgPSBkY29kZVtob2xkICYgZG1hc2tdOwogICAgICAgICAgICAgICAgICBkb2Rpc3Q6CiAgICAgICAgICAgICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgICAgICAgICAgICBvcCA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IG9wOwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSBvcDsKICAgICAgICAgICAgICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMTYgJiAyNTU7CiAgICAgICAgICAgICAgICAgICAgICBpZiAob3AgJiAxNikgewogICAgICAgICAgICAgICAgICAgICAgICBkaXN0ID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICAgICAgICBvcCAmPSAxNTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3QgKz0gaG9sZCAmICgxIDw8IG9wKSAtIDE7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXN0ID4gZG1heCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrIjsKICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gX291dCAtIGJlZzsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3QgPiBvcCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gZGlzdCAtIG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCA+IHdoYXZlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBzX3dpbmRvdzsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod25leHQgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod25leHQgPCBvcCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSArIHduZXh0IC0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSB3bmV4dDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGxlbiA+IDIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiAtPSAzOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsKICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gLT0gMzsKICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGhlcmUgPSBkY29kZVsoaGVyZSAmIDY1NTM1KSArIChob2xkICYgKDEgPDwgb3ApIC0gMSldOwogICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7CiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlIGNvZGUiOwogICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhayB0b3A7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgewogICAgICAgICAgICAgICAgICBoZXJlID0gbGNvZGVbKGhlcmUgJiA2NTUzNSkgKyAoaG9sZCAmICgxIDw8IG9wKSAtIDEpXTsKICAgICAgICAgICAgICAgICAgY29udGludWUgZG9sZW47CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wICYgMzIpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7CiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0gd2hpbGUgKF9pbiA8IGxhc3QgJiYgX291dCA8IGVuZCk7CiAgICAgICAgbGVuID0gYml0cyA+PiAzOwogICAgICAgIF9pbiAtPSBsZW47CiAgICAgICAgYml0cyAtPSBsZW4gPDwgMzsKICAgICAgICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTsKICAgICAgICBzdHJtLm5leHRfaW4gPSBfaW47CiAgICAgICAgc3RybS5uZXh0X291dCA9IF9vdXQ7CiAgICAgICAgc3RybS5hdmFpbF9pbiA9IF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KTsKICAgICAgICBzdHJtLmF2YWlsX291dCA9IF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCk7CiAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7CiAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7CiAgICAgICAgcmV0dXJuOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZ0cmVlcy5qcwogIHZhciByZXF1aXJlX2luZnRyZWVzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mdHJlZXMuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZV9jb21tb24yKCk7CiAgICAgIHZhciBNQVhCSVRTID0gMTU7CiAgICAgIHZhciBFTk9VR0hfTEVOUyA9IDg1MjsKICAgICAgdmFyIEVOT1VHSF9ESVNUUyA9IDU5MjsKICAgICAgdmFyIENPREVTID0gMDsKICAgICAgdmFyIExFTlMgPSAxOwogICAgICB2YXIgRElTVFMgPSAyOwogICAgICB2YXIgbGJhc2UgPSBbCiAgICAgICAgMywKICAgICAgICA0LAogICAgICAgIDUsCiAgICAgICAgNiwKICAgICAgICA3LAogICAgICAgIDgsCiAgICAgICAgOSwKICAgICAgICAxMCwKICAgICAgICAxMSwKICAgICAgICAxMywKICAgICAgICAxNSwKICAgICAgICAxNywKICAgICAgICAxOSwKICAgICAgICAyMywKICAgICAgICAyNywKICAgICAgICAzMSwKICAgICAgICAzNSwKICAgICAgICA0MywKICAgICAgICA1MSwKICAgICAgICA1OSwKICAgICAgICA2NywKICAgICAgICA4MywKICAgICAgICA5OSwKICAgICAgICAxMTUsCiAgICAgICAgMTMxLAogICAgICAgIDE2MywKICAgICAgICAxOTUsCiAgICAgICAgMjI3LAogICAgICAgIDI1OCwKICAgICAgICAwLAogICAgICAgIDAKICAgICAgXTsKICAgICAgdmFyIGxleHQgPSBbCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTcsCiAgICAgICAgMTcsCiAgICAgICAgMTcsCiAgICAgICAgMTcsCiAgICAgICAgMTgsCiAgICAgICAgMTgsCiAgICAgICAgMTgsCiAgICAgICAgMTgsCiAgICAgICAgMTksCiAgICAgICAgMTksCiAgICAgICAgMTksCiAgICAgICAgMTksCiAgICAgICAgMjAsCiAgICAgICAgMjAsCiAgICAgICAgMjAsCiAgICAgICAgMjAsCiAgICAgICAgMjEsCiAgICAgICAgMjEsCiAgICAgICAgMjEsCiAgICAgICAgMjEsCiAgICAgICAgMTYsCiAgICAgICAgNzIsCiAgICAgICAgNzgKICAgICAgXTsKICAgICAgdmFyIGRiYXNlID0gWwogICAgICAgIDEsCiAgICAgICAgMiwKICAgICAgICAzLAogICAgICAgIDQsCiAgICAgICAgNSwKICAgICAgICA3LAogICAgICAgIDksCiAgICAgICAgMTMsCiAgICAgICAgMTcsCiAgICAgICAgMjUsCiAgICAgICAgMzMsCiAgICAgICAgNDksCiAgICAgICAgNjUsCiAgICAgICAgOTcsCiAgICAgICAgMTI5LAogICAgICAgIDE5MywKICAgICAgICAyNTcsCiAgICAgICAgMzg1LAogICAgICAgIDUxMywKICAgICAgICA3NjksCiAgICAgICAgMTAyNSwKICAgICAgICAxNTM3LAogICAgICAgIDIwNDksCiAgICAgICAgMzA3MywKICAgICAgICA0MDk3LAogICAgICAgIDYxNDUsCiAgICAgICAgODE5MywKICAgICAgICAxMjI4OSwKICAgICAgICAxNjM4NSwKICAgICAgICAyNDU3NywKICAgICAgICAwLAogICAgICAgIDAKICAgICAgXTsKICAgICAgdmFyIGRleHQgPSBbCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTYsCiAgICAgICAgMTcsCiAgICAgICAgMTcsCiAgICAgICAgMTgsCiAgICAgICAgMTgsCiAgICAgICAgMTksCiAgICAgICAgMTksCiAgICAgICAgMjAsCiAgICAgICAgMjAsCiAgICAgICAgMjEsCiAgICAgICAgMjEsCiAgICAgICAgMjIsCiAgICAgICAgMjIsCiAgICAgICAgMjMsCiAgICAgICAgMjMsCiAgICAgICAgMjQsCiAgICAgICAgMjQsCiAgICAgICAgMjUsCiAgICAgICAgMjUsCiAgICAgICAgMjYsCiAgICAgICAgMjYsCiAgICAgICAgMjcsCiAgICAgICAgMjcsCiAgICAgICAgMjgsCiAgICAgICAgMjgsCiAgICAgICAgMjksCiAgICAgICAgMjksCiAgICAgICAgNjQsCiAgICAgICAgNjQKICAgICAgXTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX3RhYmxlKHR5cGUsIGxlbnMsIGxlbnNfaW5kZXgsIGNvZGVzLCB0YWJsZSwgdGFibGVfaW5kZXgsIHdvcmssIG9wdHMpIHsKICAgICAgICB2YXIgYml0cyA9IG9wdHMuYml0czsKICAgICAgICB2YXIgbGVuID0gMDsKICAgICAgICB2YXIgc3ltID0gMDsKICAgICAgICB2YXIgbWluID0gMCwgbWF4ID0gMDsKICAgICAgICB2YXIgcm9vdCA9IDA7CiAgICAgICAgdmFyIGN1cnIgPSAwOwogICAgICAgIHZhciBkcm9wID0gMDsKICAgICAgICB2YXIgbGVmdCA9IDA7CiAgICAgICAgdmFyIHVzZWQgPSAwOwogICAgICAgIHZhciBodWZmID0gMDsKICAgICAgICB2YXIgaW5jcjsKICAgICAgICB2YXIgZmlsbDsKICAgICAgICB2YXIgbG93OwogICAgICAgIHZhciBtYXNrOwogICAgICAgIHZhciBuZXh0OwogICAgICAgIHZhciBiYXNlID0gbnVsbDsKICAgICAgICB2YXIgYmFzZV9pbmRleCA9IDA7CiAgICAgICAgdmFyIGVuZDsKICAgICAgICB2YXIgY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOwogICAgICAgIHZhciBvZmZzID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsKICAgICAgICB2YXIgZXh0cmEgPSBudWxsOwogICAgICAgIHZhciBleHRyYV9pbmRleCA9IDA7CiAgICAgICAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7CiAgICAgICAgZm9yIChsZW4gPSAwOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHsKICAgICAgICAgIGNvdW50W2xlbl0gPSAwOwogICAgICAgIH0KICAgICAgICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykgewogICAgICAgICAgY291bnRbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rKzsKICAgICAgICB9CiAgICAgICAgcm9vdCA9IGJpdHM7CiAgICAgICAgZm9yIChtYXggPSBNQVhCSVRTOyBtYXggPj0gMTsgbWF4LS0pIHsKICAgICAgICAgIGlmIChjb3VudFttYXhdICE9PSAwKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocm9vdCA+IG1heCkgewogICAgICAgICAgcm9vdCA9IG1heDsKICAgICAgICB9CiAgICAgICAgaWYgKG1heCA9PT0gMCkgewogICAgICAgICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAxIDw8IDI0IHwgNjQgPDwgMTYgfCAwOwogICAgICAgICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAxIDw8IDI0IHwgNjQgPDwgMTYgfCAwOwogICAgICAgICAgb3B0cy5iaXRzID0gMTsKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0KICAgICAgICBmb3IgKG1pbiA9IDE7IG1pbiA8IG1heDsgbWluKyspIHsKICAgICAgICAgIGlmIChjb3VudFttaW5dICE9PSAwKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocm9vdCA8IG1pbikgewogICAgICAgICAgcm9vdCA9IG1pbjsKICAgICAgICB9CiAgICAgICAgbGVmdCA9IDE7CiAgICAgICAgZm9yIChsZW4gPSAxOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHsKICAgICAgICAgIGxlZnQgPDw9IDE7CiAgICAgICAgICBsZWZ0IC09IGNvdW50W2xlbl07CiAgICAgICAgICBpZiAobGVmdCA8IDApIHsKICAgICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAobGVmdCA+IDAgJiYgKHR5cGUgPT09IENPREVTIHx8IG1heCAhPT0gMSkpIHsKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICB9CiAgICAgICAgb2Zmc1sxXSA9IDA7CiAgICAgICAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykgewogICAgICAgICAgb2Zmc1tsZW4gKyAxXSA9IG9mZnNbbGVuXSArIGNvdW50W2xlbl07CiAgICAgICAgfQogICAgICAgIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7CiAgICAgICAgICBpZiAobGVuc1tsZW5zX2luZGV4ICsgc3ltXSAhPT0gMCkgewogICAgICAgICAgICB3b3JrW29mZnNbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rK10gPSBzeW07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlID09PSBDT0RFUykgewogICAgICAgICAgYmFzZSA9IGV4dHJhID0gd29yazsKICAgICAgICAgIGVuZCA9IDE5OwogICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gTEVOUykgewogICAgICAgICAgYmFzZSA9IGxiYXNlOwogICAgICAgICAgYmFzZV9pbmRleCAtPSAyNTc7CiAgICAgICAgICBleHRyYSA9IGxleHQ7CiAgICAgICAgICBleHRyYV9pbmRleCAtPSAyNTc7CiAgICAgICAgICBlbmQgPSAyNTY7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGJhc2UgPSBkYmFzZTsKICAgICAgICAgIGV4dHJhID0gZGV4dDsKICAgICAgICAgIGVuZCA9IC0xOwogICAgICAgIH0KICAgICAgICBodWZmID0gMDsKICAgICAgICBzeW0gPSAwOwogICAgICAgIGxlbiA9IG1pbjsKICAgICAgICBuZXh0ID0gdGFibGVfaW5kZXg7CiAgICAgICAgY3VyciA9IHJvb3Q7CiAgICAgICAgZHJvcCA9IDA7CiAgICAgICAgbG93ID0gLTE7CiAgICAgICAgdXNlZCA9IDEgPDwgcm9vdDsKICAgICAgICBtYXNrID0gdXNlZCAtIDE7CiAgICAgICAgaWYgKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TIHx8IHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpIHsKICAgICAgICAgIHJldHVybiAxOwogICAgICAgIH0KICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIGhlcmVfYml0cyA9IGxlbiAtIGRyb3A7CiAgICAgICAgICBpZiAod29ya1tzeW1dIDwgZW5kKSB7CiAgICAgICAgICAgIGhlcmVfb3AgPSAwOwogICAgICAgICAgICBoZXJlX3ZhbCA9IHdvcmtbc3ltXTsKICAgICAgICAgIH0gZWxzZSBpZiAod29ya1tzeW1dID4gZW5kKSB7CiAgICAgICAgICAgIGhlcmVfb3AgPSBleHRyYVtleHRyYV9pbmRleCArIHdvcmtbc3ltXV07CiAgICAgICAgICAgIGhlcmVfdmFsID0gYmFzZVtiYXNlX2luZGV4ICsgd29ya1tzeW1dXTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGhlcmVfb3AgPSAzMiArIDY0OwogICAgICAgICAgICBoZXJlX3ZhbCA9IDA7CiAgICAgICAgICB9CiAgICAgICAgICBpbmNyID0gMSA8PCBsZW4gLSBkcm9wOwogICAgICAgICAgZmlsbCA9IDEgPDwgY3VycjsKICAgICAgICAgIG1pbiA9IGZpbGw7CiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIGZpbGwgLT0gaW5jcjsKICAgICAgICAgICAgdGFibGVbbmV4dCArIChodWZmID4+IGRyb3ApICsgZmlsbF0gPSBoZXJlX2JpdHMgPDwgMjQgfCBoZXJlX29wIDw8IDE2IHwgaGVyZV92YWwgfCAwOwogICAgICAgICAgfSB3aGlsZSAoZmlsbCAhPT0gMCk7CiAgICAgICAgICBpbmNyID0gMSA8PCBsZW4gLSAxOwogICAgICAgICAgd2hpbGUgKGh1ZmYgJiBpbmNyKSB7CiAgICAgICAgICAgIGluY3IgPj49IDE7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoaW5jciAhPT0gMCkgewogICAgICAgICAgICBodWZmICY9IGluY3IgLSAxOwogICAgICAgICAgICBodWZmICs9IGluY3I7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBodWZmID0gMDsKICAgICAgICAgIH0KICAgICAgICAgIHN5bSsrOwogICAgICAgICAgaWYgKC0tY291bnRbbGVuXSA9PT0gMCkgewogICAgICAgICAgICBpZiAobGVuID09PSBtYXgpIHsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgICBsZW4gPSBsZW5zW2xlbnNfaW5kZXggKyB3b3JrW3N5bV1dOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGxlbiA+IHJvb3QgJiYgKGh1ZmYgJiBtYXNrKSAhPT0gbG93KSB7CiAgICAgICAgICAgIGlmIChkcm9wID09PSAwKSB7CiAgICAgICAgICAgICAgZHJvcCA9IHJvb3Q7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgbmV4dCArPSBtaW47CiAgICAgICAgICAgIGN1cnIgPSBsZW4gLSBkcm9wOwogICAgICAgICAgICBsZWZ0ID0gMSA8PCBjdXJyOwogICAgICAgICAgICB3aGlsZSAoY3VyciArIGRyb3AgPCBtYXgpIHsKICAgICAgICAgICAgICBsZWZ0IC09IGNvdW50W2N1cnIgKyBkcm9wXTsKICAgICAgICAgICAgICBpZiAobGVmdCA8PSAwKSB7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgY3VycisrOwogICAgICAgICAgICAgIGxlZnQgPDw9IDE7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdXNlZCArPSAxIDw8IGN1cnI7CiAgICAgICAgICAgIGlmICh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUyB8fCB0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSB7CiAgICAgICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgbG93ID0gaHVmZiAmIG1hc2s7CiAgICAgICAgICAgIHRhYmxlW2xvd10gPSByb290IDw8IDI0IHwgY3VyciA8PCAxNiB8IG5leHQgLSB0YWJsZV9pbmRleCB8IDA7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChodWZmICE9PSAwKSB7CiAgICAgICAgICB0YWJsZVtuZXh0ICsgaHVmZl0gPSBsZW4gLSBkcm9wIDw8IDI0IHwgNjQgPDwgMTYgfCAwOwogICAgICAgIH0KICAgICAgICBvcHRzLmJpdHMgPSByb290OwogICAgICAgIHJldHVybiAwOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZsYXRlLmpzCiAgdmFyIHJlcXVpcmVfaW5mbGF0ZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmxhdGUuanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciB1dGlscyA9IHJlcXVpcmVfY29tbW9uMigpOwogICAgICB2YXIgYWRsZXIzMiA9IHJlcXVpcmVfYWRsZXIzMigpOwogICAgICB2YXIgY3JjMzIgPSByZXF1aXJlX2NyYzMyKCk7CiAgICAgIHZhciBpbmZsYXRlX2Zhc3QgPSByZXF1aXJlX2luZmZhc3QoKTsKICAgICAgdmFyIGluZmxhdGVfdGFibGUgPSByZXF1aXJlX2luZnRyZWVzKCk7CiAgICAgIHZhciBDT0RFUyA9IDA7CiAgICAgIHZhciBMRU5TID0gMTsKICAgICAgdmFyIERJU1RTID0gMjsKICAgICAgdmFyIFpfRklOSVNIID0gNDsKICAgICAgdmFyIFpfQkxPQ0sgPSA1OwogICAgICB2YXIgWl9UUkVFUyA9IDY7CiAgICAgIHZhciBaX09LID0gMDsKICAgICAgdmFyIFpfU1RSRUFNX0VORCA9IDE7CiAgICAgIHZhciBaX05FRURfRElDVCA9IDI7CiAgICAgIHZhciBaX1NUUkVBTV9FUlJPUiA9IC0yOwogICAgICB2YXIgWl9EQVRBX0VSUk9SID0gLTM7CiAgICAgIHZhciBaX01FTV9FUlJPUiA9IC00OwogICAgICB2YXIgWl9CVUZfRVJST1IgPSAtNTsKICAgICAgdmFyIFpfREVGTEFURUQgPSA4OwogICAgICB2YXIgSEVBRCA9IDE7CiAgICAgIHZhciBGTEFHUyA9IDI7CiAgICAgIHZhciBUSU1FID0gMzsKICAgICAgdmFyIE9TID0gNDsKICAgICAgdmFyIEVYTEVOID0gNTsKICAgICAgdmFyIEVYVFJBID0gNjsKICAgICAgdmFyIE5BTUUgPSA3OwogICAgICB2YXIgQ09NTUVOVCA9IDg7CiAgICAgIHZhciBIQ1JDID0gOTsKICAgICAgdmFyIERJQ1RJRCA9IDEwOwogICAgICB2YXIgRElDVCA9IDExOwogICAgICB2YXIgVFlQRSA9IDEyOwogICAgICB2YXIgVFlQRURPID0gMTM7CiAgICAgIHZhciBTVE9SRUQgPSAxNDsKICAgICAgdmFyIENPUFlfID0gMTU7CiAgICAgIHZhciBDT1BZID0gMTY7CiAgICAgIHZhciBUQUJMRSA9IDE3OwogICAgICB2YXIgTEVOTEVOUyA9IDE4OwogICAgICB2YXIgQ09ERUxFTlMgPSAxOTsKICAgICAgdmFyIExFTl8gPSAyMDsKICAgICAgdmFyIExFTiA9IDIxOwogICAgICB2YXIgTEVORVhUID0gMjI7CiAgICAgIHZhciBESVNUID0gMjM7CiAgICAgIHZhciBESVNURVhUID0gMjQ7CiAgICAgIHZhciBNQVRDSCA9IDI1OwogICAgICB2YXIgTElUID0gMjY7CiAgICAgIHZhciBDSEVDSyA9IDI3OwogICAgICB2YXIgTEVOR1RIID0gMjg7CiAgICAgIHZhciBET05FID0gMjk7CiAgICAgIHZhciBCQUQgPSAzMDsKICAgICAgdmFyIE1FTSA9IDMxOwogICAgICB2YXIgU1lOQyA9IDMyOwogICAgICB2YXIgRU5PVUdIX0xFTlMgPSA4NTI7CiAgICAgIHZhciBFTk9VR0hfRElTVFMgPSA1OTI7CiAgICAgIHZhciBNQVhfV0JJVFMgPSAxNTsKICAgICAgdmFyIERFRl9XQklUUyA9IE1BWF9XQklUUzsKICAgICAgZnVuY3Rpb24genN3YXAzMihxKSB7CiAgICAgICAgcmV0dXJuIChxID4+PiAyNCAmIDI1NSkgKyAocSA+Pj4gOCAmIDY1MjgwKSArICgocSAmIDY1MjgwKSA8PCA4KSArICgocSAmIDI1NSkgPDwgMjQpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIEluZmxhdGVTdGF0ZSgpIHsKICAgICAgICB0aGlzLm1vZGUgPSAwOwogICAgICAgIHRoaXMubGFzdCA9IGZhbHNlOwogICAgICAgIHRoaXMud3JhcCA9IDA7CiAgICAgICAgdGhpcy5oYXZlZGljdCA9IGZhbHNlOwogICAgICAgIHRoaXMuZmxhZ3MgPSAwOwogICAgICAgIHRoaXMuZG1heCA9IDA7CiAgICAgICAgdGhpcy5jaGVjayA9IDA7CiAgICAgICAgdGhpcy50b3RhbCA9IDA7CiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDsKICAgICAgICB0aGlzLndiaXRzID0gMDsKICAgICAgICB0aGlzLndzaXplID0gMDsKICAgICAgICB0aGlzLndoYXZlID0gMDsKICAgICAgICB0aGlzLnduZXh0ID0gMDsKICAgICAgICB0aGlzLndpbmRvdyA9IG51bGw7CiAgICAgICAgdGhpcy5ob2xkID0gMDsKICAgICAgICB0aGlzLmJpdHMgPSAwOwogICAgICAgIHRoaXMubGVuZ3RoID0gMDsKICAgICAgICB0aGlzLm9mZnNldCA9IDA7CiAgICAgICAgdGhpcy5leHRyYSA9IDA7CiAgICAgICAgdGhpcy5sZW5jb2RlID0gbnVsbDsKICAgICAgICB0aGlzLmRpc3Rjb2RlID0gbnVsbDsKICAgICAgICB0aGlzLmxlbmJpdHMgPSAwOwogICAgICAgIHRoaXMuZGlzdGJpdHMgPSAwOwogICAgICAgIHRoaXMubmNvZGUgPSAwOwogICAgICAgIHRoaXMubmxlbiA9IDA7CiAgICAgICAgdGhpcy5uZGlzdCA9IDA7CiAgICAgICAgdGhpcy5oYXZlID0gMDsKICAgICAgICB0aGlzLm5leHQgPSBudWxsOwogICAgICAgIHRoaXMubGVucyA9IG5ldyB1dGlscy5CdWYxNigzMjApOwogICAgICAgIHRoaXMud29yayA9IG5ldyB1dGlscy5CdWYxNigyODgpOwogICAgICAgIHRoaXMubGVuZHluID0gbnVsbDsKICAgICAgICB0aGlzLmRpc3RkeW4gPSBudWxsOwogICAgICAgIHRoaXMuc2FuZSA9IDA7CiAgICAgICAgdGhpcy5iYWNrID0gMDsKICAgICAgICB0aGlzLndhcyA9IDA7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKSB7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAgICAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gc3RhdGUudG90YWwgPSAwOwogICAgICAgIHN0cm0ubXNnID0gIiI7CiAgICAgICAgaWYgKHN0YXRlLndyYXApIHsKICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS53cmFwICYgMTsKICAgICAgICB9CiAgICAgICAgc3RhdGUubW9kZSA9IEhFQUQ7CiAgICAgICAgc3RhdGUubGFzdCA9IDA7CiAgICAgICAgc3RhdGUuaGF2ZWRpY3QgPSAwOwogICAgICAgIHN0YXRlLmRtYXggPSAzMjc2ODsKICAgICAgICBzdGF0ZS5oZWFkID0gbnVsbDsKICAgICAgICBzdGF0ZS5ob2xkID0gMDsKICAgICAgICBzdGF0ZS5iaXRzID0gMDsKICAgICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9MRU5TKTsKICAgICAgICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0RJU1RTKTsKICAgICAgICBzdGF0ZS5zYW5lID0gMTsKICAgICAgICBzdGF0ZS5iYWNrID0gLTE7CiAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZVJlc2V0KHN0cm0pIHsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBzdGF0ZS53c2l6ZSA9IDA7CiAgICAgICAgc3RhdGUud2hhdmUgPSAwOwogICAgICAgIHN0YXRlLnduZXh0ID0gMDsKICAgICAgICByZXR1cm4gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpIHsKICAgICAgICB2YXIgd3JhcDsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBpZiAod2luZG93Qml0cyA8IDApIHsKICAgICAgICAgIHdyYXAgPSAwOwogICAgICAgICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB3cmFwID0gKHdpbmRvd0JpdHMgPj4gNCkgKyAxOwogICAgICAgICAgaWYgKHdpbmRvd0JpdHMgPCA0OCkgewogICAgICAgICAgICB3aW5kb3dCaXRzICY9IDE1OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAod2luZG93Qml0cyAmJiAod2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1KSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhdGUud2luZG93ICE9PSBudWxsICYmIHN0YXRlLndiaXRzICE9PSB3aW5kb3dCaXRzKSB7CiAgICAgICAgICBzdGF0ZS53aW5kb3cgPSBudWxsOwogICAgICAgIH0KICAgICAgICBzdGF0ZS53cmFwID0gd3JhcDsKICAgICAgICBzdGF0ZS53Yml0cyA9IHdpbmRvd0JpdHM7CiAgICAgICAgcmV0dXJuIGluZmxhdGVSZXNldChzdHJtKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlSW5pdDIoc3RybSwgd2luZG93Qml0cykgewogICAgICAgIHZhciByZXQ7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIGlmICghc3RybSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZSA9IG5ldyBJbmZsYXRlU3RhdGUoKTsKICAgICAgICBzdHJtLnN0YXRlID0gc3RhdGU7CiAgICAgICAgc3RhdGUud2luZG93ID0gbnVsbDsKICAgICAgICByZXQgPSBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpOwogICAgICAgIGlmIChyZXQgIT09IFpfT0spIHsKICAgICAgICAgIHN0cm0uc3RhdGUgPSBudWxsOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVJbml0KHN0cm0pIHsKICAgICAgICByZXR1cm4gaW5mbGF0ZUluaXQyKHN0cm0sIERFRl9XQklUUyk7CiAgICAgIH0KICAgICAgdmFyIHZpcmdpbiA9IHRydWU7CiAgICAgIHZhciBsZW5maXg7CiAgICAgIHZhciBkaXN0Zml4OwogICAgICBmdW5jdGlvbiBmaXhlZHRhYmxlcyhzdGF0ZSkgewogICAgICAgIGlmICh2aXJnaW4pIHsKICAgICAgICAgIHZhciBzeW07CiAgICAgICAgICBsZW5maXggPSBuZXcgdXRpbHMuQnVmMzIoNTEyKTsKICAgICAgICAgIGRpc3RmaXggPSBuZXcgdXRpbHMuQnVmMzIoMzIpOwogICAgICAgICAgc3ltID0gMDsKICAgICAgICAgIHdoaWxlIChzeW0gPCAxNDQpIHsKICAgICAgICAgICAgc3RhdGUubGVuc1tzeW0rK10gPSA4OwogICAgICAgICAgfQogICAgICAgICAgd2hpbGUgKHN5bSA8IDI1NikgewogICAgICAgICAgICBzdGF0ZS5sZW5zW3N5bSsrXSA9IDk7CiAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoc3ltIDwgMjgwKSB7CiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3ltKytdID0gNzsKICAgICAgICAgIH0KICAgICAgICAgIHdoaWxlIChzeW0gPCAyODgpIHsKICAgICAgICAgICAgc3RhdGUubGVuc1tzeW0rK10gPSA4OwogICAgICAgICAgfQogICAgICAgICAgaW5mbGF0ZV90YWJsZShMRU5TLCBzdGF0ZS5sZW5zLCAwLCAyODgsIGxlbmZpeCwgMCwgc3RhdGUud29yaywgeyBiaXRzOiA5IH0pOwogICAgICAgICAgc3ltID0gMDsKICAgICAgICAgIHdoaWxlIChzeW0gPCAzMikgewogICAgICAgICAgICBzdGF0ZS5sZW5zW3N5bSsrXSA9IDU7CiAgICAgICAgICB9CiAgICAgICAgICBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCAwLCAzMiwgZGlzdGZpeCwgMCwgc3RhdGUud29yaywgeyBiaXRzOiA1IH0pOwogICAgICAgICAgdmlyZ2luID0gZmFsc2U7CiAgICAgICAgfQogICAgICAgIHN0YXRlLmxlbmNvZGUgPSBsZW5maXg7CiAgICAgICAgc3RhdGUubGVuYml0cyA9IDk7CiAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBkaXN0Zml4OwogICAgICAgIHN0YXRlLmRpc3RiaXRzID0gNTsKICAgICAgfQogICAgICBmdW5jdGlvbiB1cGRhdGV3aW5kb3coc3RybSwgc3JjLCBlbmQsIGNvcHkpIHsKICAgICAgICB2YXIgZGlzdDsKICAgICAgICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmIChzdGF0ZS53aW5kb3cgPT09IG51bGwpIHsKICAgICAgICAgIHN0YXRlLndzaXplID0gMSA8PCBzdGF0ZS53Yml0czsKICAgICAgICAgIHN0YXRlLnduZXh0ID0gMDsKICAgICAgICAgIHN0YXRlLndoYXZlID0gMDsKICAgICAgICAgIHN0YXRlLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHN0YXRlLndzaXplKTsKICAgICAgICB9CiAgICAgICAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHsKICAgICAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBzdGF0ZS53c2l6ZSwgc3RhdGUud3NpemUsIDApOwogICAgICAgICAgc3RhdGUud25leHQgPSAwOwogICAgICAgICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgZGlzdCA9IHN0YXRlLndzaXplIC0gc3RhdGUud25leHQ7CiAgICAgICAgICBpZiAoZGlzdCA+IGNvcHkpIHsKICAgICAgICAgICAgZGlzdCA9IGNvcHk7CiAgICAgICAgICB9CiAgICAgICAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgZGlzdCwgc3RhdGUud25leHQpOwogICAgICAgICAgY29weSAtPSBkaXN0OwogICAgICAgICAgaWYgKGNvcHkpIHsKICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGNvcHksIDApOwogICAgICAgICAgICBzdGF0ZS53bmV4dCA9IGNvcHk7CiAgICAgICAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzdGF0ZS53bmV4dCArPSBkaXN0OwogICAgICAgICAgICBpZiAoc3RhdGUud25leHQgPT09IHN0YXRlLndzaXplKSB7CiAgICAgICAgICAgICAgc3RhdGUud25leHQgPSAwOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzdGF0ZS53aGF2ZSA8IHN0YXRlLndzaXplKSB7CiAgICAgICAgICAgICAgc3RhdGUud2hhdmUgKz0gZGlzdDsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlKHN0cm0sIGZsdXNoKSB7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIHZhciBpbnB1dCwgb3V0cHV0OwogICAgICAgIHZhciBuZXh0OwogICAgICAgIHZhciBwdXQ7CiAgICAgICAgdmFyIGhhdmUsIGxlZnQ7CiAgICAgICAgdmFyIGhvbGQ7CiAgICAgICAgdmFyIGJpdHM7CiAgICAgICAgdmFyIF9pbiwgX291dDsKICAgICAgICB2YXIgY29weTsKICAgICAgICB2YXIgZnJvbTsKICAgICAgICB2YXIgZnJvbV9zb3VyY2U7CiAgICAgICAgdmFyIGhlcmUgPSAwOwogICAgICAgIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsOwogICAgICAgIHZhciBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOwogICAgICAgIHZhciBsZW47CiAgICAgICAgdmFyIHJldDsKICAgICAgICB2YXIgaGJ1ZiA9IG5ldyB1dGlscy5CdWY4KDQpOwogICAgICAgIHZhciBvcHRzOwogICAgICAgIHZhciBuOwogICAgICAgIHZhciBvcmRlciA9IFsxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1XTsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHwgIXN0cm0ub3V0cHV0IHx8ICFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7CiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRURPOwogICAgICAgIH0KICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0OwogICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0OwogICAgICAgIGxlZnQgPSBzdHJtLmF2YWlsX291dDsKICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luOwogICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDsKICAgICAgICBoYXZlID0gc3RybS5hdmFpbF9pbjsKICAgICAgICBob2xkID0gc3RhdGUuaG9sZDsKICAgICAgICBiaXRzID0gc3RhdGUuYml0czsKICAgICAgICBfaW4gPSBoYXZlOwogICAgICAgIF9vdXQgPSBsZWZ0OwogICAgICAgIHJldCA9IFpfT0s7CiAgICAgICAgaW5mX2xlYXZlOgogICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUubW9kZSkgewogICAgICAgICAgICAgIGNhc2UgSEVBRDoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS53cmFwID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUud3JhcCAmIDIgJiYgaG9sZCA9PT0gMzU2MTUpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSAwOwogICAgICAgICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGJ1ZlsxXSA9IGhvbGQgPj4+IDggJiAyNTU7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApOwogICAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBGTEFHUzsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5mbGFncyA9IDA7CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSBmYWxzZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmICghKHN0YXRlLndyYXAgJiAxKSB8fCAoKChob2xkICYgMjU1KSA8PCA4KSArIChob2xkID4+IDgpKSAlIDMxKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImluY29ycmVjdCBoZWFkZXIgY2hlY2siOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmICgoaG9sZCAmIDE1KSAhPT0gWl9ERUZMQVRFRCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJ1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaG9sZCA+Pj49IDQ7CiAgICAgICAgICAgICAgICBiaXRzIC09IDQ7CiAgICAgICAgICAgICAgICBsZW4gPSAoaG9sZCAmIDE1KSArIDg7CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUud2JpdHMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgc3RhdGUud2JpdHMgPSBsZW47CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlbiA+IHN0YXRlLndiaXRzKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgd2luZG93IHNpemUiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmRtYXggPSAxIDw8IGxlbjsKICAgICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDE7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gaG9sZCAmIDUxMiA/IERJQ1RJRCA6IFRZUEU7CiAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSBGTEFHUzoKICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuZmxhZ3MgPSBob2xkOwogICAgICAgICAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDI1NSkgIT09IFpfREVGTEFURUQpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAidW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDU3MzQ0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gInVua25vd24gaGVhZGVyIGZsYWdzIHNldCI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC50ZXh0ID0gaG9sZCA+PiA4ICYgMTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGJ1ZlsxXSA9IGhvbGQgPj4+IDggJiAyNTU7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUSU1FOwogICAgICAgICAgICAgIGNhc2UgVElNRToKICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC50aW1lID0gaG9sZDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGJ1ZlsxXSA9IGhvbGQgPj4+IDggJiAyNTU7CiAgICAgICAgICAgICAgICAgIGhidWZbMl0gPSBob2xkID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGJ1ZlszXSA9IGhvbGQgPj4+IDI0ICYgMjU1OwogICAgICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCA0LCAwKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gT1M7CiAgICAgICAgICAgICAgY2FzZSBPUzoKICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC54ZmxhZ3MgPSBob2xkICYgMjU1OwogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLm9zID0gaG9sZCA+PiA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMjU1OwogICAgICAgICAgICAgICAgICBoYnVmWzFdID0gaG9sZCA+Pj4gOCAmIDI1NTsKICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEVYTEVOOwogICAgICAgICAgICAgIGNhc2UgRVhMRU46CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAxMDI0KSB7CiAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQ7CiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9sZW4gPSBob2xkOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMjU1OwogICAgICAgICAgICAgICAgICAgIGhidWZbMV0gPSBob2xkID4+PiA4ICYgMjU1OwogICAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbnVsbDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBFWFRSQTsKICAgICAgICAgICAgICBjYXNlIEVYVFJBOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMTAyNCkgewogICAgICAgICAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsKICAgICAgICAgICAgICAgICAgICBjb3B5ID0gaGF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoY29weSkgewogICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5oZWFkLmV4dHJhX2xlbiAtIHN0YXRlLmxlbmd0aDsKICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUuaGVhZC5leHRyYSkgewogICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbmV3IEFycmF5KHN0YXRlLmhlYWQuZXh0cmFfbGVuKTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLmhlYWQuZXh0cmEsIGlucHV0LCBuZXh0LCBjb3B5LCBsZW4pOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA1MTIpIHsKICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZSAtPSBjb3B5OwogICAgICAgICAgICAgICAgICAgIG5leHQgKz0gY29weTsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IE5BTUU7CiAgICAgICAgICAgICAgY2FzZSBOQU1FOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMjA0OCkgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBjb3B5ID0gMDsKICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdOwogICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJiBzdGF0ZS5sZW5ndGggPCA2NTUzNikgewogICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5uYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7CiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlIC09IGNvcHk7CiAgICAgICAgICAgICAgICAgIG5leHQgKz0gY29weTsKICAgICAgICAgICAgICAgICAgaWYgKGxlbikgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSA9IG51bGw7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IENPTU1FTlQ7CiAgICAgICAgICAgICAgY2FzZSBDT01NRU5UOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNDA5NikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBjb3B5ID0gMDsKICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdOwogICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJiBzdGF0ZS5sZW5ndGggPCA2NTUzNikgewogICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7CiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlIC09IGNvcHk7CiAgICAgICAgICAgICAgICAgIG5leHQgKz0gY29weTsKICAgICAgICAgICAgICAgICAgaWYgKGxlbikgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCA9IG51bGw7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gSENSQzsKICAgICAgICAgICAgICBjYXNlIEhDUkM6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA1MTIpIHsKICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikgewogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDY1NTM1KSkgewogICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImhlYWRlciBjcmMgbWlzbWF0Y2giOwogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5oY3JjID0gc3RhdGUuZmxhZ3MgPj4gOSAmIDE7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IHRydWU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIERJQ1RJRDoKICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0genN3YXAzMihob2xkKTsKICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gRElDVDsKICAgICAgICAgICAgICBjYXNlIERJQ1Q6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZWRpY3QgPT09IDApIHsKICAgICAgICAgICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDsKICAgICAgICAgICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0OwogICAgICAgICAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0OwogICAgICAgICAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTsKICAgICAgICAgICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzOwogICAgICAgICAgICAgICAgICByZXR1cm4gWl9ORUVEX0RJQ1Q7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7CiAgICAgICAgICAgICAgY2FzZSBUWVBFOgogICAgICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX0JMT0NLIHx8IGZsdXNoID09PSBaX1RSRUVTKSB7CiAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBjYXNlIFRZUEVETzoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5sYXN0KSB7CiAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNzsKICAgICAgICAgICAgICAgICAgYml0cyAtPSBiaXRzICYgNzsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IENIRUNLOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMykgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5sYXN0ID0gaG9sZCAmIDE7CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gMTsKICAgICAgICAgICAgICAgIGJpdHMgLT0gMTsKICAgICAgICAgICAgICAgIHN3aXRjaCAoaG9sZCAmIDMpIHsKICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBTVE9SRUQ7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgICAgICAgICBmaXhlZHRhYmxlcyhzdGF0ZSk7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTl87CiAgICAgICAgICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gMjsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gMjsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVEFCTEU7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIGNhc2UgMzoKICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGJsb2NrIHR5cGUiOwogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gMjsKICAgICAgICAgICAgICAgIGJpdHMgLT0gMjsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgU1RPUkVEOgogICAgICAgICAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3OwogICAgICAgICAgICAgICAgYml0cyAtPSBiaXRzICYgNzsKICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKChob2xkICYgNjU1MzUpICE9PSAoaG9sZCA+Pj4gMTYgXiA2NTUzNSkpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3RocyI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZCAmIDY1NTM1OwogICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZXzsKICAgICAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgewogICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgY2FzZSBDT1BZXzoKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZOwogICAgICAgICAgICAgIGNhc2UgQ09QWToKICAgICAgICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICBpZiAoY29weSkgewogICAgICAgICAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsKICAgICAgICAgICAgICAgICAgICBjb3B5ID0gaGF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsKICAgICAgICAgICAgICAgICAgICBjb3B5ID0gbGVmdDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoY29weSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB1dGlscy5hcnJheVNldChvdXRwdXQsIGlucHV0LCBuZXh0LCBjb3B5LCBwdXQpOwogICAgICAgICAgICAgICAgICBoYXZlIC09IGNvcHk7CiAgICAgICAgICAgICAgICAgIG5leHQgKz0gY29weTsKICAgICAgICAgICAgICAgICAgbGVmdCAtPSBjb3B5OwogICAgICAgICAgICAgICAgICBwdXQgKz0gY29weTsKICAgICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIFRBQkxFOgogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNCkgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5ubGVuID0gKGhvbGQgJiAzMSkgKyAyNTc7CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gNTsKICAgICAgICAgICAgICAgIGJpdHMgLT0gNTsKICAgICAgICAgICAgICAgIHN0YXRlLm5kaXN0ID0gKGhvbGQgJiAzMSkgKyAxOwogICAgICAgICAgICAgICAgaG9sZCA+Pj49IDU7CiAgICAgICAgICAgICAgICBiaXRzIC09IDU7CiAgICAgICAgICAgICAgICBzdGF0ZS5uY29kZSA9IChob2xkICYgMTUpICsgNDsKICAgICAgICAgICAgICAgIGhvbGQgPj4+PSA0OwogICAgICAgICAgICAgICAgYml0cyAtPSA0OwogICAgICAgICAgICAgICAgaWYgKHN0YXRlLm5sZW4gPiAyODYgfHwgc3RhdGUubmRpc3QgPiAzMCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJ0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuaGF2ZSA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOTEVOUzsKICAgICAgICAgICAgICBjYXNlIExFTkxFTlM6CiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5jb2RlKSB7CiAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMykgewogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IGhvbGQgJiA3OwogICAgICAgICAgICAgICAgICBob2xkID4+Pj0gMzsKICAgICAgICAgICAgICAgICAgYml0cyAtPSAzOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCAxOSkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gMDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW47CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5iaXRzID0gNzsKICAgICAgICAgICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTsKICAgICAgICAgICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoQ09ERVMsIHN0YXRlLmxlbnMsIDAsIDE5LCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTsKICAgICAgICAgICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7CiAgICAgICAgICAgICAgICBpZiAocmV0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgY29kZSBsZW5ndGhzIHNldCI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuaGF2ZSA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQ09ERUxFTlM7CiAgICAgICAgICAgICAgY2FzZSBDT0RFTEVOUzoKICAgICAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7CiAgICAgICAgICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDFdOwogICAgICAgICAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICAgIGhlcmVfb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7CiAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBoZXJlX3ZhbDsKICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGVyZV92YWwgPT09IDE2KSB7CiAgICAgICAgICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMjsKICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0IjsKICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUgLSAxXTsKICAgICAgICAgICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAzKTsKICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSAyOwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSAyOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7CiAgICAgICAgICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMzsKICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgICAgICBsZW4gPSAwOwogICAgICAgICAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDcpOwogICAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IDM7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IDM7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyA3OwogICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IDA7CiAgICAgICAgICAgICAgICAgICAgICBjb3B5ID0gMTEgKyAoaG9sZCAmIDEyNyk7CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gNzsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gNzsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgKyBjb3B5ID4gc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7CiAgICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0IjsKICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNvcHktLSkgewogICAgICAgICAgICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gbGVuOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IEJBRCkgewogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5sZW5zWzI1Nl0gPT09IDApIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5iaXRzID0gOTsKICAgICAgICAgICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTsKICAgICAgICAgICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoTEVOUywgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzOwogICAgICAgICAgICAgICAgaWYgKHJldCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RocyBzZXQiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmRpc3RiaXRzID0gNjsKICAgICAgICAgICAgICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5bjsKICAgICAgICAgICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmRpc3RiaXRzIH07CiAgICAgICAgICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCBzdGF0ZS5ubGVuLCBzdGF0ZS5uZGlzdCwgc3RhdGUuZGlzdGNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpOwogICAgICAgICAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSBvcHRzLmJpdHM7CiAgICAgICAgICAgICAgICBpZiAocmV0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgZGlzdGFuY2VzIHNldCI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTl87CiAgICAgICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsKICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGNhc2UgTEVOXzoKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU47CiAgICAgICAgICAgICAgY2FzZSBMRU46CiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA+PSA2ICYmIGxlZnQgPj0gMjU4KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7CiAgICAgICAgICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDsKICAgICAgICAgICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDsKICAgICAgICAgICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkOwogICAgICAgICAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0czsKICAgICAgICAgICAgICAgICAgaW5mbGF0ZV9mYXN0KHN0cm0sIF9vdXQpOwogICAgICAgICAgICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0OwogICAgICAgICAgICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDsKICAgICAgICAgICAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0OwogICAgICAgICAgICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luOwogICAgICAgICAgICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7CiAgICAgICAgICAgICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luOwogICAgICAgICAgICAgICAgICBob2xkID0gc3RhdGUuaG9sZDsKICAgICAgICAgICAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7CiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUuYmFjayA9IC0xOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuYmFjayA9IDA7CiAgICAgICAgICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMV07CiAgICAgICAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICBoZXJlX29wID0gaGVyZSA+Pj4gMTYgJiAyNTU7CiAgICAgICAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoaGVyZV9vcCAmJiAoaGVyZV9vcCAmIDI0MCkgPT09IDApIHsKICAgICAgICAgICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDsKICAgICAgICAgICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDsKICAgICAgICAgICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbbGFzdF92YWwgKyAoKGhvbGQgJiAoMSA8PCBsYXN0X2JpdHMgKyBsYXN0X29wKSAtIDEpID4+IGxhc3RfYml0cyldOwogICAgICAgICAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICAgIGhlcmVfb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgICBpZiAobGFzdF9iaXRzICsgaGVyZV9iaXRzIDw9IGJpdHMpIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzOwogICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0czsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoID0gaGVyZV92YWw7CiAgICAgICAgICAgICAgICBpZiAoaGVyZV9vcCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTElUOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChoZXJlX29wICYgMzIpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuYmFjayA9IC0xOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuZXh0cmEgPSBoZXJlX29wICYgMTU7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVORVhUOwogICAgICAgICAgICAgIGNhc2UgTEVORVhUOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7CiAgICAgICAgICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gaG9sZCAmICgxIDw8IHN0YXRlLmV4dHJhKSAtIDE7CiAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLndhcyA9IHN0YXRlLmxlbmd0aDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBESVNUOwogICAgICAgICAgICAgIGNhc2UgRElTVDoKICAgICAgICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbaG9sZCAmICgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDFdOwogICAgICAgICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDsKICAgICAgICAgICAgICAgICAgaGVyZV9vcCA9IGhlcmUgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgaWYgKGhlcmVfYml0cyA8PSBiaXRzKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKChoZXJlX29wICYgMjQwKSA9PT0gMCkgewogICAgICAgICAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wOwogICAgICAgICAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsOwogICAgICAgICAgICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgICAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbbGFzdF92YWwgKyAoKGhvbGQgJiAoMSA8PCBsYXN0X2JpdHMgKyBsYXN0X29wKSAtIDEpID4+IGxhc3RfYml0cyldOwogICAgICAgICAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICAgIGhlcmVfb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgICAgICBpZiAobGFzdF9iaXRzICsgaGVyZV9iaXRzIDw9IGJpdHMpIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzOwogICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0czsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlIGNvZGUiOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm9mZnNldCA9IGhlcmVfdmFsOwogICAgICAgICAgICAgICAgc3RhdGUuZXh0cmEgPSBoZXJlX29wICYgMTU7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDsKICAgICAgICAgICAgICBjYXNlIERJU1RFWFQ6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHsKICAgICAgICAgICAgICAgICAgbiA9IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHN0YXRlLm9mZnNldCArPSBob2xkICYgKDEgPDwgc3RhdGUuZXh0cmEpIC0gMTsKICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IHN0YXRlLmRtYXgpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2siOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBNQVRDSDsKICAgICAgICAgICAgICBjYXNlIE1BVENIOgogICAgICAgICAgICAgICAgaWYgKGxlZnQgPT09IDApIHsKICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgY29weSA9IF9vdXQgLSBsZWZ0OwogICAgICAgICAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IGNvcHkpIHsKICAgICAgICAgICAgICAgICAgY29weSA9IHN0YXRlLm9mZnNldCAtIGNvcHk7CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud2hhdmUpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkgewogICAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2siOwogICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLnduZXh0KSB7CiAgICAgICAgICAgICAgICAgICAgY29weSAtPSBzdGF0ZS53bmV4dDsKICAgICAgICAgICAgICAgICAgICBmcm9tID0gc3RhdGUud3NpemUgLSBjb3B5OwogICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53bmV4dCAtIGNvcHk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gc3RhdGUud2luZG93OwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7CiAgICAgICAgICAgICAgICAgIGZyb20gPSBwdXQgLSBzdGF0ZS5vZmZzZXQ7CiAgICAgICAgICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsKICAgICAgICAgICAgICAgICAgY29weSA9IGxlZnQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBsZWZ0IC09IGNvcHk7CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTsKICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107CiAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWNvcHkpOwogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSBMSVQ6CiAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBvdXRwdXRbcHV0KytdID0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICAgICAgbGVmdC0tOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTjsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgQ0hFQ0s6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUud3JhcCkgewogICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgIGhvbGQgfD0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBfb3V0IC09IGxlZnQ7CiAgICAgICAgICAgICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7CiAgICAgICAgICAgICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7CiAgICAgICAgICAgICAgICAgIGlmIChfb3V0KSB7CiAgICAgICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgX291dCA9IGxlZnQ7CiAgICAgICAgICAgICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgPyBob2xkIDogenN3YXAzMihob2xkKSkgIT09IHN0YXRlLmNoZWNrKSB7CiAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW5jb3JyZWN0IGRhdGEgY2hlY2siOwogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTkdUSDsKICAgICAgICAgICAgICBjYXNlIExFTkdUSDoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS53cmFwICYmIHN0YXRlLmZsYWdzKSB7CiAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUudG90YWwgJiA0Mjk0OTY3Mjk1KSkgewogICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImluY29ycmVjdCBsZW5ndGggY2hlY2siOwogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IERPTkU7CiAgICAgICAgICAgICAgY2FzZSBET05FOgogICAgICAgICAgICAgICAgcmV0ID0gWl9TVFJFQU1fRU5EOwogICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgIGNhc2UgQkFEOgogICAgICAgICAgICAgICAgcmV0ID0gWl9EQVRBX0VSUk9SOwogICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgIGNhc2UgTUVNOgogICAgICAgICAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SOwogICAgICAgICAgICAgIGNhc2UgU1lOQzoKICAgICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDsKICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7CiAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDsKICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTsKICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDsKICAgICAgICBzdGF0ZS5iaXRzID0gYml0czsKICAgICAgICBpZiAoc3RhdGUud3NpemUgfHwgX291dCAhPT0gc3RybS5hdmFpbF9vdXQgJiYgc3RhdGUubW9kZSA8IEJBRCAmJiAoc3RhdGUubW9kZSA8IENIRUNLIHx8IGZsdXNoICE9PSBaX0ZJTklTSCkpIHsKICAgICAgICAgIGlmICh1cGRhdGV3aW5kb3coc3RybSwgc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQsIF9vdXQgLSBzdHJtLmF2YWlsX291dCkpIHsKICAgICAgICAgICAgc3RhdGUubW9kZSA9IE1FTTsKICAgICAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBfaW4gLT0gc3RybS5hdmFpbF9pbjsKICAgICAgICBfb3V0IC09IHN0cm0uYXZhaWxfb3V0OwogICAgICAgIHN0cm0udG90YWxfaW4gKz0gX2luOwogICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7CiAgICAgICAgc3RhdGUudG90YWwgKz0gX291dDsKICAgICAgICBpZiAoc3RhdGUud3JhcCAmJiBfb3V0KSB7CiAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSBzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpOwogICAgICAgIH0KICAgICAgICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgKyAoc3RhdGUubW9kZSA9PT0gVFlQRSA/IDEyOCA6IDApICsgKHN0YXRlLm1vZGUgPT09IExFTl8gfHwgc3RhdGUubW9kZSA9PT0gQ09QWV8gPyAyNTYgOiAwKTsKICAgICAgICBpZiAoKF9pbiA9PT0gMCAmJiBfb3V0ID09PSAwIHx8IGZsdXNoID09PSBaX0ZJTklTSCkgJiYgcmV0ID09PSBaX09LKSB7CiAgICAgICAgICByZXQgPSBaX0JVRl9FUlJPUjsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJldDsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlRW5kKHN0cm0pIHsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBpZiAoc3RhdGUud2luZG93KSB7CiAgICAgICAgICBzdGF0ZS53aW5kb3cgPSBudWxsOwogICAgICAgIH0KICAgICAgICBzdHJtLnN0YXRlID0gbnVsbDsKICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlR2V0SGVhZGVyKHN0cm0sIGhlYWQpIHsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBpZiAoKHN0YXRlLndyYXAgJiAyKSA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZS5oZWFkID0gaGVhZDsKICAgICAgICBoZWFkLmRvbmUgPSBmYWxzZTsKICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7CiAgICAgICAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgdmFyIGRpY3RpZDsKICAgICAgICB2YXIgcmV0OwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAgICAgaWYgKHN0YXRlLndyYXAgIT09IDAgJiYgc3RhdGUubW9kZSAhPT0gRElDVCkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gRElDVCkgewogICAgICAgICAgZGljdGlkID0gMTsKICAgICAgICAgIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTsKICAgICAgICAgIGlmIChkaWN0aWQgIT09IHN0YXRlLmNoZWNrKSB7CiAgICAgICAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldCA9IHVwZGF0ZXdpbmRvdyhzdHJtLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCBkaWN0TGVuZ3RoKTsKICAgICAgICBpZiAocmV0KSB7CiAgICAgICAgICBzdGF0ZS5tb2RlID0gTUVNOwogICAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZS5oYXZlZGljdCA9IDE7CiAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgIH0KICAgICAgZXhwb3J0cy5pbmZsYXRlUmVzZXQgPSBpbmZsYXRlUmVzZXQ7CiAgICAgIGV4cG9ydHMuaW5mbGF0ZVJlc2V0MiA9IGluZmxhdGVSZXNldDI7CiAgICAgIGV4cG9ydHMuaW5mbGF0ZVJlc2V0S2VlcCA9IGluZmxhdGVSZXNldEtlZXA7CiAgICAgIGV4cG9ydHMuaW5mbGF0ZUluaXQgPSBpbmZsYXRlSW5pdDsKICAgICAgZXhwb3J0cy5pbmZsYXRlSW5pdDIgPSBpbmZsYXRlSW5pdDI7CiAgICAgIGV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7CiAgICAgIGV4cG9ydHMuaW5mbGF0ZUVuZCA9IGluZmxhdGVFbmQ7CiAgICAgIGV4cG9ydHMuaW5mbGF0ZUdldEhlYWRlciA9IGluZmxhdGVHZXRIZWFkZXI7CiAgICAgIGV4cG9ydHMuaW5mbGF0ZVNldERpY3Rpb25hcnkgPSBpbmZsYXRlU2V0RGljdGlvbmFyeTsKICAgICAgZXhwb3J0cy5pbmZsYXRlSW5mbyA9ICJwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpIjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY29uc3RhbnRzLmpzCiAgdmFyIHJlcXVpcmVfY29uc3RhbnRzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY29uc3RhbnRzLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gewogICAgICAgIFpfTk9fRkxVU0g6IDAsCiAgICAgICAgWl9QQVJUSUFMX0ZMVVNIOiAxLAogICAgICAgIFpfU1lOQ19GTFVTSDogMiwKICAgICAgICBaX0ZVTExfRkxVU0g6IDMsCiAgICAgICAgWl9GSU5JU0g6IDQsCiAgICAgICAgWl9CTE9DSzogNSwKICAgICAgICBaX1RSRUVTOiA2LAogICAgICAgIFpfT0s6IDAsCiAgICAgICAgWl9TVFJFQU1fRU5EOiAxLAogICAgICAgIFpfTkVFRF9ESUNUOiAyLAogICAgICAgIFpfRVJSTk86IC0xLAogICAgICAgIFpfU1RSRUFNX0VSUk9SOiAtMiwKICAgICAgICBaX0RBVEFfRVJST1I6IC0zLAogICAgICAgIFpfQlVGX0VSUk9SOiAtNSwKICAgICAgICBaX05PX0NPTVBSRVNTSU9OOiAwLAogICAgICAgIFpfQkVTVF9TUEVFRDogMSwKICAgICAgICBaX0JFU1RfQ09NUFJFU1NJT046IDksCiAgICAgICAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAtMSwKICAgICAgICBaX0ZJTFRFUkVEOiAxLAogICAgICAgIFpfSFVGRk1BTl9PTkxZOiAyLAogICAgICAgIFpfUkxFOiAzLAogICAgICAgIFpfRklYRUQ6IDQsCiAgICAgICAgWl9ERUZBVUxUX1NUUkFURUdZOiAwLAogICAgICAgIFpfQklOQVJZOiAwLAogICAgICAgIFpfVEVYVDogMSwKICAgICAgICBaX1VOS05PV046IDIsCiAgICAgICAgWl9ERUZMQVRFRDogOAogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9nemhlYWRlci5qcwogIHZhciByZXF1aXJlX2d6aGVhZGVyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZ3poZWFkZXIuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgZnVuY3Rpb24gR1poZWFkZXIoKSB7CiAgICAgICAgdGhpcy50ZXh0ID0gMDsKICAgICAgICB0aGlzLnRpbWUgPSAwOwogICAgICAgIHRoaXMueGZsYWdzID0gMDsKICAgICAgICB0aGlzLm9zID0gMDsKICAgICAgICB0aGlzLmV4dHJhID0gbnVsbDsKICAgICAgICB0aGlzLmV4dHJhX2xlbiA9IDA7CiAgICAgICAgdGhpcy5uYW1lID0gIiI7CiAgICAgICAgdGhpcy5jb21tZW50ID0gIiI7CiAgICAgICAgdGhpcy5oY3JjID0gMDsKICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTsKICAgICAgfQogICAgICBtb2R1bGUuZXhwb3J0cyA9IEdaaGVhZGVyOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvaW5mbGF0ZS5qcwogIHZhciByZXF1aXJlX2luZmxhdGUyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL2luZmxhdGUuanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciB6bGliX2luZmxhdGUgPSByZXF1aXJlX2luZmxhdGUoKTsKICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZV9jb21tb24yKCk7CiAgICAgIHZhciBzdHJpbmdzID0gcmVxdWlyZV9zdHJpbmdzKCk7CiAgICAgIHZhciBjID0gcmVxdWlyZV9jb25zdGFudHMoKTsKICAgICAgdmFyIG1zZyA9IHJlcXVpcmVfbWVzc2FnZXMyKCk7CiAgICAgIHZhciBaU3RyZWFtID0gcmVxdWlyZV96c3RyZWFtKCk7CiAgICAgIHZhciBHWmhlYWRlciA9IHJlcXVpcmVfZ3poZWFkZXIoKTsKICAgICAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzsKICAgICAgZnVuY3Rpb24gSW5mbGF0ZShvcHRpb25zKSB7CiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEluZmxhdGUpKQogICAgICAgICAgcmV0dXJuIG5ldyBJbmZsYXRlKG9wdGlvbnMpOwogICAgICAgIHRoaXMub3B0aW9ucyA9IHV0aWxzLmFzc2lnbih7CiAgICAgICAgICBjaHVua1NpemU6IDE2Mzg0LAogICAgICAgICAgd2luZG93Qml0czogMCwKICAgICAgICAgIHRvOiAiIgogICAgICAgIH0sIG9wdGlvbnMgfHwge30pOwogICAgICAgIHZhciBvcHQgPSB0aGlzLm9wdGlvbnM7CiAgICAgICAgaWYgKG9wdC5yYXcgJiYgb3B0LndpbmRvd0JpdHMgPj0gMCAmJiBvcHQud2luZG93Qml0cyA8IDE2KSB7CiAgICAgICAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0czsKICAgICAgICAgIGlmIChvcHQud2luZG93Qml0cyA9PT0gMCkgewogICAgICAgICAgICBvcHQud2luZG93Qml0cyA9IC0xNTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKG9wdC53aW5kb3dCaXRzID49IDAgJiYgb3B0LndpbmRvd0JpdHMgPCAxNiAmJiAhKG9wdGlvbnMgJiYgb3B0aW9ucy53aW5kb3dCaXRzKSkgewogICAgICAgICAgb3B0LndpbmRvd0JpdHMgKz0gMzI7CiAgICAgICAgfQogICAgICAgIGlmIChvcHQud2luZG93Qml0cyA+IDE1ICYmIG9wdC53aW5kb3dCaXRzIDwgNDgpIHsKICAgICAgICAgIGlmICgob3B0LndpbmRvd0JpdHMgJiAxNSkgPT09IDApIHsKICAgICAgICAgICAgb3B0LndpbmRvd0JpdHMgfD0gMTU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHRoaXMuZXJyID0gMDsKICAgICAgICB0aGlzLm1zZyA9ICIiOwogICAgICAgIHRoaXMuZW5kZWQgPSBmYWxzZTsKICAgICAgICB0aGlzLmNodW5rcyA9IFtdOwogICAgICAgIHRoaXMuc3RybSA9IG5ldyBaU3RyZWFtKCk7CiAgICAgICAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7CiAgICAgICAgdmFyIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlSW5pdDIodGhpcy5zdHJtLCBvcHQud2luZG93Qml0cyk7CiAgICAgICAgaWYgKHN0YXR1cyAhPT0gYy5aX09LKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pOwogICAgICAgIH0KICAgICAgICB0aGlzLmhlYWRlciA9IG5ldyBHWmhlYWRlcigpOwogICAgICAgIHpsaWJfaW5mbGF0ZS5pbmZsYXRlR2V0SGVhZGVyKHRoaXMuc3RybSwgdGhpcy5oZWFkZXIpOwogICAgICAgIGlmIChvcHQuZGljdGlvbmFyeSkgewogICAgICAgICAgaWYgKHR5cGVvZiBvcHQuZGljdGlvbmFyeSA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgb3B0LmRpY3Rpb25hcnkgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpOwogICAgICAgICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gIltvYmplY3QgQXJyYXlCdWZmZXJdIikgewogICAgICAgICAgICBvcHQuZGljdGlvbmFyeSA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChvcHQucmF3KSB7CiAgICAgICAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIG9wdC5kaWN0aW9uYXJ5KTsKICAgICAgICAgICAgaWYgKHN0YXR1cyAhPT0gYy5aX09LKSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBJbmZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oZGF0YSwgbW9kZSkgewogICAgICAgIHZhciBzdHJtID0gdGhpcy5zdHJtOwogICAgICAgIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplOwogICAgICAgIHZhciBkaWN0aW9uYXJ5ID0gdGhpcy5vcHRpb25zLmRpY3Rpb25hcnk7CiAgICAgICAgdmFyIHN0YXR1cywgX21vZGU7CiAgICAgICAgdmFyIG5leHRfb3V0X3V0ZjgsIHRhaWwsIHV0ZjhzdHI7CiAgICAgICAgdmFyIGFsbG93QnVmRXJyb3IgPSBmYWxzZTsKICAgICAgICBpZiAodGhpcy5lbmRlZCkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgICBfbW9kZSA9IG1vZGUgPT09IH5+bW9kZSA/IG1vZGUgOiBtb2RlID09PSB0cnVlID8gYy5aX0ZJTklTSCA6IGMuWl9OT19GTFVTSDsKICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5iaW5zdHJpbmcyYnVmKGRhdGEpOwogICAgICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gIltvYmplY3QgQXJyYXlCdWZmZXJdIikgewogICAgICAgICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBzdHJtLmlucHV0ID0gZGF0YTsKICAgICAgICB9CiAgICAgICAgc3RybS5uZXh0X2luID0gMDsKICAgICAgICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7CiAgICAgICAgZG8gewogICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IHV0aWxzLkJ1ZjgoY2h1bmtTaXplKTsKICAgICAgICAgICAgc3RybS5uZXh0X291dCA9IDA7CiAgICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplOwogICAgICAgICAgfQogICAgICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGUoc3RybSwgYy5aX05PX0ZMVVNIKTsKICAgICAgICAgIGlmIChzdGF0dXMgPT09IGMuWl9ORUVEX0RJQ1QgJiYgZGljdGlvbmFyeSkgewogICAgICAgICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0aW9uYXJ5KTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdGF0dXMgPT09IGMuWl9CVUZfRVJST1IgJiYgYWxsb3dCdWZFcnJvciA9PT0gdHJ1ZSkgewogICAgICAgICAgICBzdGF0dXMgPSBjLlpfT0s7CiAgICAgICAgICAgIGFsbG93QnVmRXJyb3IgPSBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdGF0dXMgIT09IGMuWl9TVFJFQU1fRU5EICYmIHN0YXR1cyAhPT0gYy5aX09LKSB7CiAgICAgICAgICAgIHRoaXMub25FbmQoc3RhdHVzKTsKICAgICAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdHJtLm5leHRfb3V0KSB7CiAgICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCBzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EIHx8IHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBjLlpfRklOSVNIIHx8IF9tb2RlID09PSBjLlpfU1lOQ19GTFVTSCkpIHsKICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAic3RyaW5nIikgewogICAgICAgICAgICAgICAgbmV4dF9vdXRfdXRmOCA9IHN0cmluZ3MudXRmOGJvcmRlcihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCk7CiAgICAgICAgICAgICAgICB0YWlsID0gc3RybS5uZXh0X291dCAtIG5leHRfb3V0X3V0Zjg7CiAgICAgICAgICAgICAgICB1dGY4c3RyID0gc3RyaW5ncy5idWYyc3RyaW5nKHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4KTsKICAgICAgICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSB0YWlsOwogICAgICAgICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemUgLSB0YWlsOwogICAgICAgICAgICAgICAgaWYgKHRhaWwpIHsKICAgICAgICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4LCB0YWlsLCAwKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHRoaXMub25EYXRhKHV0ZjhzdHIpOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIGFsbG93QnVmRXJyb3IgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBjLlpfU1RSRUFNX0VORCk7CiAgICAgICAgaWYgKHN0YXR1cyA9PT0gYy5aX1NUUkVBTV9FTkQpIHsKICAgICAgICAgIF9tb2RlID0gYy5aX0ZJTklTSDsKICAgICAgICB9CiAgICAgICAgaWYgKF9tb2RlID09PSBjLlpfRklOSVNIKSB7CiAgICAgICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pOwogICAgICAgICAgdGhpcy5vbkVuZChzdGF0dXMpOwogICAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7CiAgICAgICAgICByZXR1cm4gc3RhdHVzID09PSBjLlpfT0s7CiAgICAgICAgfQogICAgICAgIGlmIChfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpIHsKICAgICAgICAgIHRoaXMub25FbmQoYy5aX09LKTsKICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gMDsKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfTsKICAgICAgSW5mbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oY2h1bmspIHsKICAgICAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTsKICAgICAgfTsKICAgICAgSW5mbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbihzdGF0dXMpIHsKICAgICAgICBpZiAoc3RhdHVzID09PSBjLlpfT0spIHsKICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbigiIik7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHV0aWxzLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB0aGlzLmNodW5rcyA9IFtdOwogICAgICAgIHRoaXMuZXJyID0gc3RhdHVzOwogICAgICAgIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZzsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucykgewogICAgICAgIHZhciBpbmZsYXRvciA9IG5ldyBJbmZsYXRlKG9wdGlvbnMpOwogICAgICAgIGluZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpOwogICAgICAgIGlmIChpbmZsYXRvci5lcnIpIHsKICAgICAgICAgIHRocm93IGluZmxhdG9yLm1zZyB8fCBtc2dbaW5mbGF0b3IuZXJyXTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGluZmxhdG9yLnJlc3VsdDsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7CiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307CiAgICAgICAgb3B0aW9ucy5yYXcgPSB0cnVlOwogICAgICAgIHJldHVybiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKTsKICAgICAgfQogICAgICBleHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlOwogICAgICBleHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlOwogICAgICBleHBvcnRzLmluZmxhdGVSYXcgPSBpbmZsYXRlUmF3OwogICAgICBleHBvcnRzLnVuZ3ppcCA9IGluZmxhdGU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfcGFrbyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2luZGV4LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBhc3NpZ24gPSByZXF1aXJlX2NvbW1vbjIoKS5hc3NpZ247CiAgICAgIHZhciBkZWZsYXRlID0gcmVxdWlyZV9kZWZsYXRlMigpOwogICAgICB2YXIgaW5mbGF0ZSA9IHJlcXVpcmVfaW5mbGF0ZTIoKTsKICAgICAgdmFyIGNvbnN0YW50cyA9IHJlcXVpcmVfY29uc3RhbnRzKCk7CiAgICAgIHZhciBwYWtvID0ge307CiAgICAgIGFzc2lnbihwYWtvLCBkZWZsYXRlLCBpbmZsYXRlLCBjb25zdGFudHMpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHBha287CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvZGlzdC91bnppcC1wYWtvLmpzCiAgdmFyIHJlcXVpcmVfdW56aXBfcGFrbyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvZGlzdC91bnppcC1wYWtvLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZV9pbnRlcm9wUmVxdWlyZURlZmF1bHQyKCk7CiAgICAgIHZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfcmVnZW5lcmF0b3IyKCkpOwogICAgICB2YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2FzeW5jVG9HZW5lcmF0b3IyKCkpOwogICAgICB2YXIgX3JlcXVpcmUgPSByZXF1aXJlX3Bha28oKTsKICAgICAgdmFyIFpfU1lOQ19GTFVTSCA9IF9yZXF1aXJlLlpfU1lOQ19GTFVTSDsKICAgICAgdmFyIEluZmxhdGUgPSBfcmVxdWlyZS5JbmZsYXRlOwogICAgICBmdW5jdGlvbiB1bnppcChfeCkgewogICAgICAgIHJldHVybiBfdW56aXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfdW56aXAoKSB7CiAgICAgICAgX3VuemlwID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KSgvKiBAX19QVVJFX18gKi8gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKGlucHV0RGF0YSkgewogICAgICAgICAgdmFyIHN0cm0sIHBvcywgaSwgY2h1bmtzLCBpbmZsYXRvciwgcmVtYWluaW5nSW5wdXQsIF9pbmZsYXRvciwgcmVzdWx0OwogICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHsKICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7CiAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAwOwogICAgICAgICAgICAgICAgICBwb3MgPSAwOwogICAgICAgICAgICAgICAgICBpID0gMDsKICAgICAgICAgICAgICAgICAgY2h1bmtzID0gW107CiAgICAgICAgICAgICAgICBjYXNlIDQ6CiAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ0lucHV0ID0gaW5wdXREYXRhLnNsaWNlKHBvcyk7CiAgICAgICAgICAgICAgICAgIGluZmxhdG9yID0gbmV3IEluZmxhdGUoKTsKICAgICAgICAgICAgICAgICAgX2luZmxhdG9yID0gaW5mbGF0b3I7CiAgICAgICAgICAgICAgICAgIHN0cm0gPSBfaW5mbGF0b3Iuc3RybTsKICAgICAgICAgICAgICAgICAgaW5mbGF0b3IucHVzaChyZW1haW5pbmdJbnB1dCwgWl9TWU5DX0ZMVVNIKTsKICAgICAgICAgICAgICAgICAgaWYgKCFpbmZsYXRvci5lcnIpIHsKICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGluZmxhdG9yLm1zZyk7CiAgICAgICAgICAgICAgICBjYXNlIDExOgogICAgICAgICAgICAgICAgICBwb3MgKz0gc3RybS5uZXh0X2luOwogICAgICAgICAgICAgICAgICBjaHVua3NbaV0gPSBpbXBvcnRfYnVmZmVyLkJ1ZmZlci5mcm9tKGluZmxhdG9yLnJlc3VsdCk7CiAgICAgICAgICAgICAgICAgIGkgKz0gMTsKICAgICAgICAgICAgICAgIGNhc2UgMTQ6CiAgICAgICAgICAgICAgICAgIGlmIChzdHJtLmF2YWlsX2luKSB7CiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGNhc2UgMTU6CiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGltcG9ydF9idWZmZXIuQnVmZmVyLmNvbmNhdChjaHVua3MpOwogICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCJyZXR1cm4iLCByZXN1bHQpOwogICAgICAgICAgICAgICAgY2FzZSAxOToKICAgICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE5OwogICAgICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0WyJjYXRjaCJdKDApOwogICAgICAgICAgICAgICAgICBpZiAoIV9jb250ZXh0LnQwLm1lc3NhZ2UubWF0Y2goL2luY29ycmVjdCBoZWFkZXIgY2hlY2svKSkgewogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMzsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoInByb2JsZW0gZGVjb21wcmVzc2luZyBibG9jazogaW5jb3JyZWN0IGd6aXAgaGVhZGVyIGNoZWNrIik7CiAgICAgICAgICAgICAgICBjYXNlIDIzOgogICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMCwgMTldXSk7CiAgICAgICAgfSkpOwogICAgICAgIHJldHVybiBfdW56aXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB1bnppcENodW5rKF94MikgewogICAgICAgIHJldHVybiBfdW56aXBDaHVuay5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF91bnppcENodW5rKCkgewogICAgICAgIF91bnppcENodW5rID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KSgvKiBAX19QVVJFX18gKi8gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMihpbnB1dERhdGEpIHsKICAgICAgICAgIHZhciBzdHJtLCBjcG9zLCBkcG9zLCBibG9ja3MsIGNwb3NpdGlvbnMsIGRwb3NpdGlvbnMsIHJlbWFpbmluZ0lucHV0LCBpbmZsYXRvciwgX2J1ZmZlciwgYnVmZmVyOwogICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0MikgewogICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkgewogICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDA7CiAgICAgICAgICAgICAgICAgIGNwb3MgPSAwOwogICAgICAgICAgICAgICAgICBkcG9zID0gMDsKICAgICAgICAgICAgICAgICAgYmxvY2tzID0gW107CiAgICAgICAgICAgICAgICAgIGNwb3NpdGlvbnMgPSBbXTsKICAgICAgICAgICAgICAgICAgZHBvc2l0aW9ucyA9IFtdOwogICAgICAgICAgICAgICAgY2FzZSA2OgogICAgICAgICAgICAgICAgICByZW1haW5pbmdJbnB1dCA9IGlucHV0RGF0YS5zbGljZShjcG9zKTsKICAgICAgICAgICAgICAgICAgaW5mbGF0b3IgPSBuZXcgSW5mbGF0ZSgpOwogICAgICAgICAgICAgICAgICBzdHJtID0gaW5mbGF0b3Iuc3RybTsKICAgICAgICAgICAgICAgICAgaW5mbGF0b3IucHVzaChyZW1haW5pbmdJbnB1dCwgWl9TWU5DX0ZMVVNIKTsKICAgICAgICAgICAgICAgICAgaWYgKCFpbmZsYXRvci5lcnIpIHsKICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEyOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpbmZsYXRvci5tc2cpOwogICAgICAgICAgICAgICAgY2FzZSAxMjoKICAgICAgICAgICAgICAgICAgX2J1ZmZlciA9IGltcG9ydF9idWZmZXIuQnVmZmVyLmZyb20oaW5mbGF0b3IucmVzdWx0KTsKICAgICAgICAgICAgICAgICAgYmxvY2tzLnB1c2goX2J1ZmZlcik7CiAgICAgICAgICAgICAgICAgIGNwb3NpdGlvbnMucHVzaChjcG9zKTsKICAgICAgICAgICAgICAgICAgZHBvc2l0aW9ucy5wdXNoKGRwb3MpOwogICAgICAgICAgICAgICAgICBjcG9zICs9IHN0cm0ubmV4dF9pbjsKICAgICAgICAgICAgICAgICAgZHBvcyArPSBfYnVmZmVyLmxlbmd0aDsKICAgICAgICAgICAgICAgIGNhc2UgMTg6CiAgICAgICAgICAgICAgICAgIGlmIChzdHJtLmF2YWlsX2luKSB7CiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA2OwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBjYXNlIDE5OgogICAgICAgICAgICAgICAgICBidWZmZXIgPSBpbXBvcnRfYnVmZmVyLkJ1ZmZlci5jb25jYXQoYmxvY2tzKTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoInJldHVybiIsIHsgYnVmZmVyLCBjcG9zaXRpb25zLCBkcG9zaXRpb25zIH0pOwogICAgICAgICAgICAgICAgY2FzZSAyMzoKICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAyMzsKICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyWyJjYXRjaCJdKDApOwogICAgICAgICAgICAgICAgICBpZiAoIV9jb250ZXh0Mi50MC5tZXNzYWdlLm1hdGNoKC9pbmNvcnJlY3QgaGVhZGVyIGNoZWNrLykpIHsKICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI3OwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigicHJvYmxlbSBkZWNvbXByZXNzaW5nIGJsb2NrOiBpbmNvcnJlY3QgZ3ppcCBoZWFkZXIgY2hlY2siKTsKICAgICAgICAgICAgICAgIGNhc2UgMjc6CiAgICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0sIF9jYWxsZWUyLCBudWxsLCBbWzAsIDIzXV0pOwogICAgICAgIH0pKTsKICAgICAgICByZXR1cm4gX3VuemlwQ2h1bmsuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB1bnppcENodW5rU2xpY2UoX3gzLCBfeDQpIHsKICAgICAgICByZXR1cm4gX3VuemlwQ2h1bmtTbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF91bnppcENodW5rU2xpY2UoKSB7CiAgICAgICAgX3VuemlwQ2h1bmtTbGljZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoaW5wdXREYXRhLCBjaHVuaykgewogICAgICAgICAgdmFyIHN0cm0sIGNwb3MsIGRwb3MsIGRlY29tcHJlc3NlZEJsb2NrcywgY3Bvc2l0aW9ucywgZHBvc2l0aW9ucywgcmVtYWluaW5nSW5wdXQsIGluZmxhdG9yLCBfYnVmZmVyMiwgbGVuLCBvcmlnQ3BvcywgYnVmZmVyOwogICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0MykgewogICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkgewogICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDA7CiAgICAgICAgICAgICAgICAgIGNwb3MgPSBjaHVuay5taW52LmJsb2NrUG9zaXRpb247CiAgICAgICAgICAgICAgICAgIGRwb3MgPSBjaHVuay5taW52LmRhdGFQb3NpdGlvbjsKICAgICAgICAgICAgICAgICAgZGVjb21wcmVzc2VkQmxvY2tzID0gW107CiAgICAgICAgICAgICAgICAgIGNwb3NpdGlvbnMgPSBbXTsKICAgICAgICAgICAgICAgICAgZHBvc2l0aW9ucyA9IFtdOwogICAgICAgICAgICAgICAgY2FzZSA2OgogICAgICAgICAgICAgICAgICByZW1haW5pbmdJbnB1dCA9IGlucHV0RGF0YS5zbGljZShjcG9zIC0gY2h1bmsubWludi5ibG9ja1Bvc2l0aW9uKTsKICAgICAgICAgICAgICAgICAgaW5mbGF0b3IgPSBuZXcgSW5mbGF0ZSgpOwogICAgICAgICAgICAgICAgICBzdHJtID0gaW5mbGF0b3Iuc3RybTsKICAgICAgICAgICAgICAgICAgaW5mbGF0b3IucHVzaChyZW1haW5pbmdJbnB1dCwgWl9TWU5DX0ZMVVNIKTsKICAgICAgICAgICAgICAgICAgaWYgKCFpbmZsYXRvci5lcnIpIHsKICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDEyOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpbmZsYXRvci5tc2cpOwogICAgICAgICAgICAgICAgY2FzZSAxMjoKICAgICAgICAgICAgICAgICAgX2J1ZmZlcjIgPSBpbXBvcnRfYnVmZmVyLkJ1ZmZlci5mcm9tKGluZmxhdG9yLnJlc3VsdCk7CiAgICAgICAgICAgICAgICAgIGRlY29tcHJlc3NlZEJsb2Nrcy5wdXNoKF9idWZmZXIyKTsKICAgICAgICAgICAgICAgICAgbGVuID0gX2J1ZmZlcjIubGVuZ3RoOwogICAgICAgICAgICAgICAgICBjcG9zaXRpb25zLnB1c2goY3Bvcyk7CiAgICAgICAgICAgICAgICAgIGRwb3NpdGlvbnMucHVzaChkcG9zKTsKICAgICAgICAgICAgICAgICAgaWYgKGRlY29tcHJlc3NlZEJsb2Nrcy5sZW5ndGggPT09IDEgJiYgY2h1bmsubWludi5kYXRhUG9zaXRpb24pIHsKICAgICAgICAgICAgICAgICAgICBkZWNvbXByZXNzZWRCbG9ja3NbMF0gPSBkZWNvbXByZXNzZWRCbG9ja3NbMF0uc2xpY2UoY2h1bmsubWludi5kYXRhUG9zaXRpb24pOwogICAgICAgICAgICAgICAgICAgIGxlbiA9IGRlY29tcHJlc3NlZEJsb2Nrc1swXS5sZW5ndGg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgb3JpZ0Nwb3MgPSBjcG9zOwogICAgICAgICAgICAgICAgICBjcG9zICs9IHN0cm0ubmV4dF9pbjsKICAgICAgICAgICAgICAgICAgZHBvcyArPSBsZW47CiAgICAgICAgICAgICAgICAgIGlmICghKG9yaWdDcG9zID49IGNodW5rLm1heHYuYmxvY2tQb3NpdGlvbikpIHsKICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI2OwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGRlY29tcHJlc3NlZEJsb2Nrc1tkZWNvbXByZXNzZWRCbG9ja3MubGVuZ3RoIC0gMV0gPSBkZWNvbXByZXNzZWRCbG9ja3NbZGVjb21wcmVzc2VkQmxvY2tzLmxlbmd0aCAtIDFdLnNsaWNlKDAsIGNodW5rLm1heHYuYmxvY2tQb3NpdGlvbiA9PT0gY2h1bmsubWludi5ibG9ja1Bvc2l0aW9uID8gY2h1bmsubWF4di5kYXRhUG9zaXRpb24gLSBjaHVuay5taW52LmRhdGFQb3NpdGlvbiArIDEgOiBjaHVuay5tYXh2LmRhdGFQb3NpdGlvbiArIDEpOwogICAgICAgICAgICAgICAgICBjcG9zaXRpb25zLnB1c2goY3Bvcyk7CiAgICAgICAgICAgICAgICAgIGRwb3NpdGlvbnMucHVzaChkcG9zKTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoImJyZWFrIiwgMjcpOwogICAgICAgICAgICAgICAgY2FzZSAyNjoKICAgICAgICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfaW4pIHsKICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDY7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGNhc2UgMjc6CiAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGltcG9ydF9idWZmZXIuQnVmZmVyLmNvbmNhdChkZWNvbXByZXNzZWRCbG9ja3MpOwogICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdCgicmV0dXJuIiwgeyBidWZmZXIsIGNwb3NpdGlvbnMsIGRwb3NpdGlvbnMgfSk7CiAgICAgICAgICAgICAgICBjYXNlIDMxOgogICAgICAgICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDMxOwogICAgICAgICAgICAgICAgICBfY29udGV4dDMudDAgPSBfY29udGV4dDNbImNhdGNoIl0oMCk7CiAgICAgICAgICAgICAgICAgIGlmICghX2NvbnRleHQzLnQwLm1lc3NhZ2UubWF0Y2goL2luY29ycmVjdCBoZWFkZXIgY2hlY2svKSkgewogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMzU7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJwcm9ibGVtIGRlY29tcHJlc3NpbmcgYmxvY2s6IGluY29ycmVjdCBnemlwIGhlYWRlciBjaGVjayIpOwogICAgICAgICAgICAgICAgY2FzZSAzNToKICAgICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQzLnQwOwogICAgICAgICAgICAgICAgY2FzZSAzNjoKICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfSwgX2NhbGxlZTMsIG51bGwsIFtbMCwgMzFdXSk7CiAgICAgICAgfSkpOwogICAgICAgIHJldHVybiBfdW56aXBDaHVua1NsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgIH0KICAgICAgbW9kdWxlLmV4cG9ydHMgPSB7CiAgICAgICAgdW56aXAsCiAgICAgICAgdW56aXBDaHVuaywKICAgICAgICB1bnppcENodW5rU2xpY2UsCiAgICAgICAgcGFrb1VuemlwOiB1bnppcCwKICAgICAgICBub2RlVW56aXA6IGZ1bmN0aW9uIG5vZGVVbnppcCgpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcigibm9kZVVuemlwIG5vdCBpbXBsZW1lbnRlZC4iKTsKICAgICAgICB9CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIChkaXNhYmxlZCk6bm9kZV9tb2R1bGVzL0BnbW9kL2JnemYtZmlsZWhhbmRsZS9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfbGliID0gX19jb21tb25KUyh7CiAgICAiKGRpc2FibGVkKTpub2RlX21vZHVsZXMvQGdtb2QvYmd6Zi1maWxlaGFuZGxlL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvaW5kZXguanMiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvZGlzdC9sb2NhbEZpbGUuanMKICB2YXIgcmVxdWlyZV9sb2NhbEZpbGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGdtb2QvYmd6Zi1maWxlaGFuZGxlL2Rpc3QvbG9jYWxGaWxlLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZV9pbnRlcm9wUmVxdWlyZURlZmF1bHQyKCk7CiAgICAgIHZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfcmVnZW5lcmF0b3IyKCkpOwogICAgICB2YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2FzeW5jVG9HZW5lcmF0b3IyKCkpOwogICAgICB2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9jbGFzc0NhbGxDaGVjazIoKSk7CiAgICAgIHZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2NyZWF0ZUNsYXNzMigpKTsKICAgICAgdmFyIGZzID0gcmVxdWlyZV9saWIoKTsKICAgICAgdmFyIExvY2FsRmlsZSA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHsKICAgICAgICBmdW5jdGlvbiBMb2NhbEZpbGUyKHBhdGgpIHsKICAgICAgICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIExvY2FsRmlsZTIpOwogICAgICAgICAgdGhpcy5mZFByb21pc2UgPSBmcy5vcGVuKHBhdGgsICJyIik7CiAgICAgICAgICB0aGlzLnBhdGggPSBwYXRoOwogICAgICAgIH0KICAgICAgICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShMb2NhbEZpbGUyLCBbeyBrZXk6ICJyZWFkIiwgdmFsdWU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgdmFyIF9yZWFkID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KSgvKiBAX19QVVJFX18gKi8gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKGJ1Ziwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7CiAgICAgICAgICAgIHZhciBmZCwgcmV0OwogICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkgewogICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7CiAgICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZFByb21pc2U7CiAgICAgICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgICAgICBmZCA9IF9jb250ZXh0LnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZzLnJlYWQoZmQsIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTsKICAgICAgICAgICAgICAgICAgY2FzZSA1OgogICAgICAgICAgICAgICAgICAgIHJldCA9IF9jb250ZXh0LnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgicmV0dXJuIiwgcmV0KTsKICAgICAgICAgICAgICAgICAgY2FzZSA3OgogICAgICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTsKICAgICAgICAgIH0pKTsKICAgICAgICAgIGZ1bmN0aW9uIHJlYWQoX3gsIF94MiwgX3gzLCBfeDQpIHsKICAgICAgICAgICAgcmV0dXJuIF9yZWFkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gcmVhZDsKICAgICAgICB9KCkgfSwgeyBrZXk6ICJzdGF0IiwgdmFsdWU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgdmFyIF9zdGF0ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KSgvKiBAX19QVVJFX18gKi8gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHsKICAgICAgICAgICAgdmFyIGZkOwogICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7CiAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkgewogICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyOwogICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZkUHJvbWlzZTsKICAgICAgICAgICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICAgICAgICAgIGZkID0gX2NvbnRleHQyLnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoInJldHVybiIsIGZzLmZzdGF0KGZkKSk7CiAgICAgICAgICAgICAgICAgIGNhc2UgNDoKICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTsKICAgICAgICAgIH0pKTsKICAgICAgICAgIGZ1bmN0aW9uIHN0YXQoKSB7CiAgICAgICAgICAgIHJldHVybiBfc3RhdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHN0YXQ7CiAgICAgICAgfSgpIH1dKTsKICAgICAgICByZXR1cm4gTG9jYWxGaWxlMjsKICAgICAgfSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IExvY2FsRmlsZTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL2JnemYtZmlsZWhhbmRsZS9kaXN0L2d6aUluZGV4LmpzCiAgdmFyIHJlcXVpcmVfZ3ppSW5kZXggPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGdtb2QvYmd6Zi1maWxlaGFuZGxlL2Rpc3QvZ3ppSW5kZXguanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlX2ludGVyb3BSZXF1aXJlRGVmYXVsdDIoKTsKICAgICAgdmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9yZWdlbmVyYXRvcjIoKSk7CiAgICAgIHZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfYXN5bmNUb0dlbmVyYXRvcjIoKSk7CiAgICAgIHZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2NsYXNzQ2FsbENoZWNrMigpKTsKICAgICAgdmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfY3JlYXRlQ2xhc3MyKCkpOwogICAgICB2YXIgTG9uZyA9IHJlcXVpcmVfbG9uZygpOwogICAgICB2YXIgTG9jYWxGaWxlID0gcmVxdWlyZV9sb2NhbEZpbGUoKTsKICAgICAgdmFyIFVOQ09NUFJFU1NFRF9QT1NJVElPTiA9IDE7CiAgICAgIHZhciBHemlJbmRleCA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHsKICAgICAgICBmdW5jdGlvbiBHemlJbmRleDIoX3JlZikgewogICAgICAgICAgdmFyIGZpbGVoYW5kbGUgPSBfcmVmLmZpbGVoYW5kbGUsIHBhdGggPSBfcmVmLnBhdGg7CiAgICAgICAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBHemlJbmRleDIpOwogICAgICAgICAgaWYgKGZpbGVoYW5kbGUpCiAgICAgICAgICAgIHRoaXMuZmlsZWhhbmRsZSA9IGZpbGVoYW5kbGU7CiAgICAgICAgICBlbHNlIGlmIChwYXRoKQogICAgICAgICAgICB0aGlzLmZpbGVoYW5kbGUgPSBuZXcgTG9jYWxGaWxlKHBhdGgpOwogICAgICAgICAgZWxzZQogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJlaXRoZXIgZmlsZWhhbmRsZSBvciBwYXRoIG11c3QgYmUgZGVmaW5lZCIpOwogICAgICAgIH0KICAgICAgICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShHemlJbmRleDIsIFt7IGtleTogIl9yZWFkTG9uZ1dpdGhPdmVyZmxvdyIsIHZhbHVlOiBmdW5jdGlvbiBfcmVhZExvbmdXaXRoT3ZlcmZsb3coYnVmKSB7CiAgICAgICAgICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiAwOwogICAgICAgICAgdmFyIHVuc2lnbmVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiB0cnVlOwogICAgICAgICAgdmFyIGxvbmcgPSBMb25nLmZyb21CeXRlc0xFKGJ1Zi5zbGljZShvZmZzZXQsIG9mZnNldCArIDgpLCB1bnNpZ25lZCk7CiAgICAgICAgICBpZiAobG9uZy5ncmVhdGVyVGhhbihOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikgfHwgbG9uZy5sZXNzVGhhbihOdW1iZXIuTUlOX1NBRkVfSU5URUdFUikpCiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImludGVnZXIgb3ZlcmZsb3ciKTsKICAgICAgICAgIHJldHVybiBsb25nLnRvTnVtYmVyKCk7CiAgICAgICAgfSB9LCB7IGtleTogIl9nZXRJbmRleCIsIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SW5kZXgoKSB7CiAgICAgICAgICBpZiAoIXRoaXMuaW5kZXgpCiAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLl9yZWFkSW5kZXgoKTsKICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4OwogICAgICAgIH0gfSwgewogICAgICAgICAga2V5OiAiX3JlYWRJbmRleCIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciBfcmVhZEluZGV4MiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHsKICAgICAgICAgICAgICB2YXIgYnVmLCBudW1FbnRyaWVzLCBlbnRyaWVzLCBidWZTaXplLCBlbnRyeU51bWJlciwgY29tcHJlc3NlZFBvc2l0aW9uLCB1bmNvbXByZXNzZWRQb3NpdGlvbjsKICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkgewogICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkgewogICAgICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgICAgIGJ1ZiA9IGltcG9ydF9idWZmZXIuQnVmZmVyLmFsbG9jVW5zYWZlKDgpOwogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlaGFuZGxlLnJlYWQoYnVmLCAwLCA4LCAwKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgICAgICAgICBudW1FbnRyaWVzID0gdGhpcy5fcmVhZExvbmdXaXRoT3ZlcmZsb3coYnVmLCAwLCB0cnVlKTsKICAgICAgICAgICAgICAgICAgICAgIGlmIChudW1FbnRyaWVzKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2OwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoInJldHVybiIsIFtbMCwgMF1dKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDY6CiAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzID0gbmV3IEFycmF5KG51bUVudHJpZXMgKyAxKTsKICAgICAgICAgICAgICAgICAgICAgIGVudHJpZXNbMF0gPSBbMCwgMF07CiAgICAgICAgICAgICAgICAgICAgICBidWZTaXplID0gOCAqIDIgKiBudW1FbnRyaWVzOwogICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYnVmU2l6ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiaW50ZWdlciBvdmVyZmxvdyIpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6CiAgICAgICAgICAgICAgICAgICAgICBidWYgPSBpbXBvcnRfYnVmZmVyLkJ1ZmZlci5hbGxvY1Vuc2FmZShidWZTaXplKTsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNDsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGVoYW5kbGUucmVhZChidWYsIDAsIGJ1ZlNpemUsIDgpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6CiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGVudHJ5TnVtYmVyID0gMDsgZW50cnlOdW1iZXIgPCBudW1FbnRyaWVzOyBlbnRyeU51bWJlciArPSAxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXByZXNzZWRQb3NpdGlvbiA9IHRoaXMuX3JlYWRMb25nV2l0aE92ZXJmbG93KGJ1ZiwgZW50cnlOdW1iZXIgKiAxNik7CiAgICAgICAgICAgICAgICAgICAgICAgIHVuY29tcHJlc3NlZFBvc2l0aW9uID0gdGhpcy5fcmVhZExvbmdXaXRoT3ZlcmZsb3coYnVmLCBlbnRyeU51bWJlciAqIDE2ICsgOCk7CiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJpZXNbZW50cnlOdW1iZXIgKyAxXSA9IFtjb21wcmVzc2VkUG9zaXRpb24sIHVuY29tcHJlc3NlZFBvc2l0aW9uXTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoInJldHVybiIsIGVudHJpZXMpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6CiAgICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTsKICAgICAgICAgICAgfSkpOwogICAgICAgICAgICBmdW5jdGlvbiBfcmVhZEluZGV4KCkgewogICAgICAgICAgICAgIHJldHVybiBfcmVhZEluZGV4Mi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBfcmVhZEluZGV4OwogICAgICAgICAgfSgpCiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiZ2V0TGFzdEJsb2NrIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgdmFyIF9nZXRMYXN0QmxvY2sgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKC8qIEBfX1BVUkVfXyAqLyBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkgewogICAgICAgICAgICAgIHZhciBlbnRyaWVzOwogICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHsKICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkgewogICAgICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRJbmRleCgpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgICAgICAgIGVudHJpZXMgPSBfY29udGV4dDIuc2VudDsKICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDU7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoInJldHVybiIsIHZvaWQgMCk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoInJldHVybiIsIGVudHJpZXNbZW50cmllcy5sZW5ndGggLSAxXSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OgogICAgICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTsKICAgICAgICAgICAgfSkpOwogICAgICAgICAgICBmdW5jdGlvbiBnZXRMYXN0QmxvY2soKSB7CiAgICAgICAgICAgICAgcmV0dXJuIF9nZXRMYXN0QmxvY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gZ2V0TGFzdEJsb2NrOwogICAgICAgICAgfSgpCiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiZ2V0UmVsZXZhbnRCbG9ja3NGb3JSZWFkIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgdmFyIF9nZXRSZWxldmFudEJsb2Nrc0ZvclJlYWQgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKC8qIEBfX1BVUkVfXyAqLyBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGxlbmd0aCwgcG9zaXRpb24pIHsKICAgICAgICAgICAgICB2YXIgZW5kUG9zaXRpb24sIGVudHJpZXMsIHJlbGV2YW50LCBjb21wYXJlLCBsb3dlckJvdW5kLCB1cHBlckJvdW5kLCBzZWFyY2hQb3NpdGlvbiwgY29tcGFyaXNvbiwgaTsKICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7CiAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHsKICAgICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgICBlbmRQb3NpdGlvbiA9IHBvc2l0aW9uICsgbGVuZ3RoOwogICAgICAgICAgICAgICAgICAgICAgaWYgKCEobGVuZ3RoID09PSAwKSkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDM7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoInJldHVybiIsIFtdKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDU7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SW5kZXgoKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDU6CiAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzID0gX2NvbnRleHQzLnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgICByZWxldmFudCA9IFtdOwogICAgICAgICAgICAgICAgICAgICAgY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUyKGVudHJ5LCBuZXh0RW50cnkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVuY29tcHJlc3NlZFBvc2l0aW9uID0gZW50cnlbVU5DT01QUkVTU0VEX1BPU0lUSU9OXTsKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRVbmNvbXByZXNzZWRQb3NpdGlvbiA9IG5leHRFbnRyeSA/IG5leHRFbnRyeVtVTkNPTVBSRVNTRURfUE9TSVRJT05dIDogSW5maW5pdHk7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmNvbXByZXNzZWRQb3NpdGlvbiA8PSBwb3NpdGlvbiAmJiBuZXh0VW5jb21wcmVzc2VkUG9zaXRpb24gPiBwb3NpdGlvbikgewogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmNvbXByZXNzZWRQb3NpdGlvbiA8IHBvc2l0aW9uKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxOwogICAgICAgICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgICAgICAgIGxvd2VyQm91bmQgPSAwOwogICAgICAgICAgICAgICAgICAgICAgdXBwZXJCb3VuZCA9IGVudHJpZXMubGVuZ3RoIC0gMTsKICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFBvc2l0aW9uID0gTWF0aC5mbG9vcihlbnRyaWVzLmxlbmd0aCAvIDIpOwogICAgICAgICAgICAgICAgICAgICAgY29tcGFyaXNvbiA9IGNvbXBhcmUoZW50cmllc1tzZWFyY2hQb3NpdGlvbl0sIGVudHJpZXNbc2VhcmNoUG9zaXRpb24gKyAxXSk7CiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyaXNvbiAhPT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyaXNvbiA+IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckJvdW5kID0gc2VhcmNoUG9zaXRpb24gLSAxOwogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbXBhcmlzb24gPCAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJCb3VuZCA9IHNlYXJjaFBvc2l0aW9uICsgMTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hQb3NpdGlvbiA9IE1hdGguY2VpbCgodXBwZXJCb3VuZCAtIGxvd2VyQm91bmQpIC8gMikgKyBsb3dlckJvdW5kOwogICAgICAgICAgICAgICAgICAgICAgICBjb21wYXJpc29uID0gY29tcGFyZShlbnRyaWVzW3NlYXJjaFBvc2l0aW9uXSwgZW50cmllc1tzZWFyY2hQb3NpdGlvbiArIDFdKTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHJlbGV2YW50LnB1c2goZW50cmllc1tzZWFyY2hQb3NpdGlvbl0pOwogICAgICAgICAgICAgICAgICAgICAgaSA9IHNlYXJjaFBvc2l0aW9uICsgMTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OgogICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaSA8IGVudHJpZXMubGVuZ3RoKSkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDIyOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHJlbGV2YW50LnB1c2goZW50cmllc1tpXSk7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIShlbnRyaWVzW2ldW1VOQ09NUFJFU1NFRF9QT1NJVElPTl0gPj0gZW5kUG9zaXRpb24pKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTk7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoImJyZWFrIiwgMjIpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTk6CiAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE1OwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMjoKICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWxldmFudFtyZWxldmFudC5sZW5ndGggLSAxXVtVTkNPTVBSRVNTRURfUE9TSVRJT05dIDwgZW5kUG9zaXRpb24pIHsKICAgICAgICAgICAgICAgICAgICAgICAgcmVsZXZhbnQucHVzaChbXSk7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdCgicmV0dXJuIiwgcmVsZXZhbnQpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMjQ6CiAgICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSwgX2NhbGxlZTMsIHRoaXMpOwogICAgICAgICAgICB9KSk7CiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFJlbGV2YW50QmxvY2tzRm9yUmVhZChfeCwgX3gyKSB7CiAgICAgICAgICAgICAgcmV0dXJuIF9nZXRSZWxldmFudEJsb2Nrc0ZvclJlYWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gZ2V0UmVsZXZhbnRCbG9ja3NGb3JSZWFkOwogICAgICAgICAgfSgpCiAgICAgICAgfV0pOwogICAgICAgIHJldHVybiBHemlJbmRleDI7CiAgICAgIH0oKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBHemlJbmRleDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL2JnemYtZmlsZWhhbmRsZS9kaXN0L2JnekZpbGVoYW5kbGUuanMKICB2YXIgcmVxdWlyZV9iZ3pGaWxlaGFuZGxlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BnbW9kL2JnemYtZmlsZWhhbmRsZS9kaXN0L2JnekZpbGVoYW5kbGUuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlX2ludGVyb3BSZXF1aXJlRGVmYXVsdDIoKTsKICAgICAgdmFyIF9zbGljZWRUb0FycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9zbGljZWRUb0FycmF5MigpKTsKICAgICAgdmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9yZWdlbmVyYXRvcjIoKSk7CiAgICAgIHZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfYXN5bmNUb0dlbmVyYXRvcjIoKSk7CiAgICAgIHZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2NsYXNzQ2FsbENoZWNrMigpKTsKICAgICAgdmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfY3JlYXRlQ2xhc3MyKCkpOwogICAgICB2YXIgX3JlcXVpcmUgPSByZXF1aXJlX3VuemlwX3Bha28oKTsKICAgICAgdmFyIHVuemlwID0gX3JlcXVpcmUudW56aXA7CiAgICAgIHZhciBMb2NhbEZpbGUgPSByZXF1aXJlX2xvY2FsRmlsZSgpOwogICAgICB2YXIgR3ppSW5kZXggPSByZXF1aXJlX2d6aUluZGV4KCk7CiAgICAgIHZhciBCZ3pGaWxlaGFuZGxlID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkgewogICAgICAgIGZ1bmN0aW9uIEJnekZpbGVoYW5kbGUyKF9yZWYpIHsKICAgICAgICAgIHZhciBmaWxlaGFuZGxlID0gX3JlZi5maWxlaGFuZGxlLCBwYXRoID0gX3JlZi5wYXRoLCBnemlGaWxlaGFuZGxlID0gX3JlZi5nemlGaWxlaGFuZGxlLCBnemlQYXRoID0gX3JlZi5nemlQYXRoOwogICAgICAgICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgQmd6RmlsZWhhbmRsZTIpOwogICAgICAgICAgaWYgKGZpbGVoYW5kbGUpCiAgICAgICAgICAgIHRoaXMuZmlsZWhhbmRsZSA9IGZpbGVoYW5kbGU7CiAgICAgICAgICBlbHNlIGlmIChwYXRoKQogICAgICAgICAgICB0aGlzLmZpbGVoYW5kbGUgPSBuZXcgTG9jYWxGaWxlKHBhdGgpOwogICAgICAgICAgZWxzZQogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJlaXRoZXIgZmlsZWhhbmRsZSBvciBwYXRoIG11c3QgYmUgZGVmaW5lZCIpOwogICAgICAgICAgaWYgKCFnemlGaWxlaGFuZGxlICYmICFnemlQYXRoICYmICFwYXRoKQogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJlaXRoZXIgZ3ppRmlsZWhhbmRsZSBvciBnemlQYXRoIG11c3QgYmUgZGVmaW5lZCIpOwogICAgICAgICAgdGhpcy5nemkgPSBuZXcgR3ppSW5kZXgoewogICAgICAgICAgICBmaWxlaGFuZGxlOiBnemlGaWxlaGFuZGxlLAogICAgICAgICAgICBwYXRoOiAhZ3ppRmlsZWhhbmRsZSAmJiAhZ3ppUGF0aCAmJiBwYXRoID8gZ3ppUGF0aCA6ICIiLmNvbmNhdChwYXRoLCAiLmd6aSIpCiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoQmd6RmlsZWhhbmRsZTIsIFt7IGtleTogInN0YXQiLCB2YWx1ZTogZnVuY3Rpb24oKSB7CiAgICAgICAgICB2YXIgX3N0YXQgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKC8qIEBfX1BVUkVfXyAqLyBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7CiAgICAgICAgICAgIHZhciBjb21wcmVzc2VkU3RhdDsKICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHsKICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkgewogICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsZWhhbmRsZS5zdGF0KCk7CiAgICAgICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgICAgICBjb21wcmVzc2VkU3RhdCA9IF9jb250ZXh0LnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBPYmplY3Q7CiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQudDEgPSBjb21wcmVzc2VkU3RhdDsKICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNzsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRVbmNvbXByZXNzZWRGaWxlU2l6ZSgpOwogICAgICAgICAgICAgICAgICBjYXNlIDc6CiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQudDIgPSBfY29udGV4dC5zZW50OwogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnQzID0gdm9pZCAwOwogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnQ0ID0gdm9pZCAwOwogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnQ1ID0geyBzaXplOiBfY29udGV4dC50MiwgYmxvY2tzOiBfY29udGV4dC50MywgYmxrc2l6ZTogX2NvbnRleHQudDQgfTsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCJyZXR1cm4iLCBfY29udGV4dC50MC5hc3NpZ24uY2FsbChfY29udGV4dC50MCwgX2NvbnRleHQudDEsIF9jb250ZXh0LnQ1KSk7CiAgICAgICAgICAgICAgICAgIGNhc2UgMTI6CiAgICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpOwogICAgICAgICAgfSkpOwogICAgICAgICAgZnVuY3Rpb24gc3RhdCgpIHsKICAgICAgICAgICAgcmV0dXJuIF9zdGF0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gc3RhdDsKICAgICAgICB9KCkgfSwgeyBrZXk6ICJnZXRVbmNvbXByZXNzZWRGaWxlU2l6ZSIsIHZhbHVlOiBmdW5jdGlvbigpIHsKICAgICAgICAgIHZhciBfZ2V0VW5jb21wcmVzc2VkRmlsZVNpemUgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKC8qIEBfX1BVUkVfXyAqLyBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkgewogICAgICAgICAgICB2YXIgX3JlZjIsIF9yZWYzLCB1bmNvbXByZXNzZWRQb3NpdGlvbiwgX3JlZjQsIHNpemUsIGJ1ZiwgX3JlZjUsIGJ5dGVzUmVhZCwgbGFzdEJsb2NrVW5jb21wcmVzc2VkU2l6ZTsKICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0MikgewogICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHsKICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nemkuZ2V0TGFzdEJsb2NrKCk7CiAgICAgICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9jb250ZXh0Mi5zZW50OwogICAgICAgICAgICAgICAgICAgIF9yZWYzID0gKDAsIF9zbGljZWRUb0FycmF5Mi5kZWZhdWx0KShfcmVmMiwgMik7CiAgICAgICAgICAgICAgICAgICAgdW5jb21wcmVzc2VkUG9zaXRpb24gPSBfcmVmM1sxXTsKICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDc7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsZWhhbmRsZS5zdGF0KCk7CiAgICAgICAgICAgICAgICAgIGNhc2UgNzoKICAgICAgICAgICAgICAgICAgICBfcmVmNCA9IF9jb250ZXh0Mi5zZW50OwogICAgICAgICAgICAgICAgICAgIHNpemUgPSBfcmVmNC5zaXplOwogICAgICAgICAgICAgICAgICAgIGJ1ZiA9IGltcG9ydF9idWZmZXIuQnVmZmVyLmFsbG9jVW5zYWZlKDQpOwogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTI7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsZWhhbmRsZS5yZWFkKGJ1ZiwgMCwgNCwgc2l6ZSAtIDI4IC0gNCk7CiAgICAgICAgICAgICAgICAgIGNhc2UgMTI6CiAgICAgICAgICAgICAgICAgICAgX3JlZjUgPSBfY29udGV4dDIuc2VudDsKICAgICAgICAgICAgICAgICAgICBieXRlc1JlYWQgPSBfcmVmNS5ieXRlc1JlYWQ7CiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYnl0ZXNSZWFkICE9PSA0KSkgewogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNjsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoInJlYWQgZXJyb3IiKTsKICAgICAgICAgICAgICAgICAgY2FzZSAxNjoKICAgICAgICAgICAgICAgICAgICBsYXN0QmxvY2tVbmNvbXByZXNzZWRTaXplID0gYnVmLnJlYWRVSW50MzJMRSgwKTsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdCgicmV0dXJuIiwgdW5jb21wcmVzc2VkUG9zaXRpb24gKyBsYXN0QmxvY2tVbmNvbXByZXNzZWRTaXplKTsKICAgICAgICAgICAgICAgICAgY2FzZSAxODoKICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTsKICAgICAgICAgIH0pKTsKICAgICAgICAgIGZ1bmN0aW9uIGdldFVuY29tcHJlc3NlZEZpbGVTaXplKCkgewogICAgICAgICAgICByZXR1cm4gX2dldFVuY29tcHJlc3NlZEZpbGVTaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZ2V0VW5jb21wcmVzc2VkRmlsZVNpemU7CiAgICAgICAgfSgpIH0sIHsga2V5OiAiX3JlYWRBbmRVbmNvbXByZXNzQmxvY2siLCB2YWx1ZTogZnVuY3Rpb24oKSB7CiAgICAgICAgICB2YXIgX3JlYWRBbmRVbmNvbXByZXNzQmxvY2syID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KSgvKiBAX19QVVJFX18gKi8gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhibG9ja0J1ZmZlciwgX3JlZjYsIF9yZWY3KSB7CiAgICAgICAgICAgIHZhciBfcmVmOCwgY29tcHJlc3NlZFBvc2l0aW9uLCBfcmVmOSwgbmV4dENvbXByZXNzZWRQb3NpdGlvbiwgbmV4dCwgYmxvY2tDb21wcmVzc2VkTGVuZ3RoLCB1bnppcHBlZEJ1ZmZlcjsKICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0MykgewogICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHsKICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgIF9yZWY4ID0gKDAsIF9zbGljZWRUb0FycmF5Mi5kZWZhdWx0KShfcmVmNiwgMSksIGNvbXByZXNzZWRQb3NpdGlvbiA9IF9yZWY4WzBdOwogICAgICAgICAgICAgICAgICAgIF9yZWY5ID0gKDAsIF9zbGljZWRUb0FycmF5Mi5kZWZhdWx0KShfcmVmNywgMSksIG5leHRDb21wcmVzc2VkUG9zaXRpb24gPSBfcmVmOVswXTsKICAgICAgICAgICAgICAgICAgICBuZXh0ID0gbmV4dENvbXByZXNzZWRQb3NpdGlvbjsKICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCkgewogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA3OwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNjsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlaGFuZGxlLnN0YXQoKTsKICAgICAgICAgICAgICAgICAgY2FzZSA2OgogICAgICAgICAgICAgICAgICAgIG5leHQgPSBfY29udGV4dDMuc2VudC5zaXplOwogICAgICAgICAgICAgICAgICBjYXNlIDc6CiAgICAgICAgICAgICAgICAgICAgYmxvY2tDb21wcmVzc2VkTGVuZ3RoID0gbmV4dCAtIGNvbXByZXNzZWRQb3NpdGlvbjsKICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDEwOwogICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGVoYW5kbGUucmVhZChibG9ja0J1ZmZlciwgMCwgYmxvY2tDb21wcmVzc2VkTGVuZ3RoLCBjb21wcmVzc2VkUG9zaXRpb24pOwogICAgICAgICAgICAgICAgICBjYXNlIDEwOgogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTI7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuemlwKGJsb2NrQnVmZmVyLnNsaWNlKDAsIGJsb2NrQ29tcHJlc3NlZExlbmd0aCkpOwogICAgICAgICAgICAgICAgICBjYXNlIDEyOgogICAgICAgICAgICAgICAgICAgIHVuemlwcGVkQnVmZmVyID0gX2NvbnRleHQzLnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoInJldHVybiIsIHVuemlwcGVkQnVmZmVyKTsKICAgICAgICAgICAgICAgICAgY2FzZSAxNDoKICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTsKICAgICAgICAgIH0pKTsKICAgICAgICAgIGZ1bmN0aW9uIF9yZWFkQW5kVW5jb21wcmVzc0Jsb2NrKF94LCBfeDIsIF94MykgewogICAgICAgICAgICByZXR1cm4gX3JlYWRBbmRVbmNvbXByZXNzQmxvY2syLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gX3JlYWRBbmRVbmNvbXByZXNzQmxvY2s7CiAgICAgICAgfSgpIH0sIHsga2V5OiAicmVhZCIsIHZhbHVlOiBmdW5jdGlvbigpIHsKICAgICAgICAgIHZhciBfcmVhZCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoYnVmLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHsKICAgICAgICAgICAgdmFyIGJsb2NrUG9zaXRpb25zLCBibG9ja0J1ZmZlciwgZGVzdGluYXRpb25PZmZzZXQsIGJ5dGVzUmVhZCwgYmxvY2tOdW0sIHVuY29tcHJlc3NlZEJ1ZmZlciwgX2Jsb2NrUG9zaXRpb25zJGJsb2NrLCB1bmNvbXByZXNzZWRQb3NpdGlvbiwgc291cmNlT2Zmc2V0LCBzb3VyY2VFbmQ7CiAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHsKICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7CiAgICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDI7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3ppLmdldFJlbGV2YW50QmxvY2tzRm9yUmVhZChsZW5ndGgsIHBvc2l0aW9uKTsKICAgICAgICAgICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICAgICAgICAgIGJsb2NrUG9zaXRpb25zID0gX2NvbnRleHQ0LnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgYmxvY2tCdWZmZXIgPSBpbXBvcnRfYnVmZmVyLkJ1ZmZlci5hbGxvY1Vuc2FmZSgzMjc2OCAqIDIpOwogICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uT2Zmc2V0ID0gb2Zmc2V0OwogICAgICAgICAgICAgICAgICAgIGJ5dGVzUmVhZCA9IDA7CiAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW0gPSAwOwogICAgICAgICAgICAgICAgICBjYXNlIDc6CiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYmxvY2tOdW0gPCBibG9ja1Bvc2l0aW9ucy5sZW5ndGggLSAxKSkgewogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxODsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDEwOwogICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkQW5kVW5jb21wcmVzc0Jsb2NrKGJsb2NrQnVmZmVyLCBibG9ja1Bvc2l0aW9uc1tibG9ja051bV0sIGJsb2NrUG9zaXRpb25zW2Jsb2NrTnVtICsgMV0pOwogICAgICAgICAgICAgICAgICBjYXNlIDEwOgogICAgICAgICAgICAgICAgICAgIHVuY29tcHJlc3NlZEJ1ZmZlciA9IF9jb250ZXh0NC5zZW50OwogICAgICAgICAgICAgICAgICAgIF9ibG9ja1Bvc2l0aW9ucyRibG9jayA9ICgwLCBfc2xpY2VkVG9BcnJheTIuZGVmYXVsdCkoYmxvY2tQb3NpdGlvbnNbYmxvY2tOdW1dLCAyKSwgdW5jb21wcmVzc2VkUG9zaXRpb24gPSBfYmxvY2tQb3NpdGlvbnMkYmxvY2tbMV07CiAgICAgICAgICAgICAgICAgICAgc291cmNlT2Zmc2V0ID0gdW5jb21wcmVzc2VkUG9zaXRpb24gPj0gcG9zaXRpb24gPyAwIDogcG9zaXRpb24gLSB1bmNvbXByZXNzZWRQb3NpdGlvbjsKICAgICAgICAgICAgICAgICAgICBzb3VyY2VFbmQgPSBNYXRoLm1pbihwb3NpdGlvbiArIGxlbmd0aCwgdW5jb21wcmVzc2VkUG9zaXRpb24gKyB1bmNvbXByZXNzZWRCdWZmZXIubGVuZ3RoKSAtIHVuY29tcHJlc3NlZFBvc2l0aW9uOwogICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VPZmZzZXQgPj0gMCAmJiBzb3VyY2VPZmZzZXQgPCB1bmNvbXByZXNzZWRCdWZmZXIubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICB1bmNvbXByZXNzZWRCdWZmZXIuY29weShidWYsIGRlc3RpbmF0aW9uT2Zmc2V0LCBzb3VyY2VPZmZzZXQsIHNvdXJjZUVuZCk7CiAgICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbk9mZnNldCArPSBzb3VyY2VFbmQgLSBzb3VyY2VPZmZzZXQ7CiAgICAgICAgICAgICAgICAgICAgICBieXRlc1JlYWQgKz0gc291cmNlRW5kIC0gc291cmNlT2Zmc2V0OwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgY2FzZSAxNToKICAgICAgICAgICAgICAgICAgICBibG9ja051bSArPSAxOwogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNzsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgY2FzZSAxODoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdCgicmV0dXJuIiwgeyBieXRlc1JlYWQsIGJ1ZmZlcjogYnVmIH0pOwogICAgICAgICAgICAgICAgICBjYXNlIDE5OgogICAgICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwgX2NhbGxlZTQsIHRoaXMpOwogICAgICAgICAgfSkpOwogICAgICAgICAgZnVuY3Rpb24gcmVhZChfeDQsIF94NSwgX3g2LCBfeDcpIHsKICAgICAgICAgICAgcmV0dXJuIF9yZWFkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gcmVhZDsKICAgICAgICB9KCkgfV0pOwogICAgICAgIHJldHVybiBCZ3pGaWxlaGFuZGxlMjsKICAgICAgfSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IEJnekZpbGVoYW5kbGU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvZGlzdC9pbmRleC5qcwogIHZhciByZXF1aXJlX2Rpc3QyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BnbW9kL2JnemYtZmlsZWhhbmRsZS9kaXN0L2luZGV4LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBCZ3pmRmlsZWhhbmRsZSA9IHJlcXVpcmVfYmd6RmlsZWhhbmRsZSgpOwogICAgICB2YXIgX3JlcXVpcmUgPSByZXF1aXJlX3VuemlwX3Bha28oKTsKICAgICAgdmFyIHVuemlwID0gX3JlcXVpcmUudW56aXA7CiAgICAgIHZhciB1bnppcENodW5rID0gX3JlcXVpcmUudW56aXBDaHVuazsKICAgICAgdmFyIHVuemlwQ2h1bmtTbGljZSA9IF9yZXF1aXJlLnVuemlwQ2h1bmtTbGljZTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSB7IEJnemZGaWxlaGFuZGxlLCB1bnppcCwgdW56aXBDaHVuaywgdW56aXBDaHVua1NsaWNlIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC9iYW0vZGlzdC9jc2kuanMKICB2YXIgcmVxdWlyZV9jc2kgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGdtb2QvYmFtL2Rpc3QvY3NpLmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSByZXF1aXJlX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoKTsKICAgICAgdmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlX2ludGVyb3BSZXF1aXJlRGVmYXVsdCgpOwogICAgICB2YXIgX09iamVjdCRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmVfZGVmaW5lX3Byb3BlcnR5MygpOwogICAgICBfT2JqZWN0JGRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgewogICAgICAgIHZhbHVlOiB0cnVlCiAgICAgIH0pOwogICAgICBleHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7CiAgICAgIHZhciBfZ2V0SXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2dldF9pdGVyYXRvcjUoKSk7CiAgICAgIHZhciBfaXNBcnJheSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9pc19hcnJheTQoKSk7CiAgICAgIHZhciBfZ2V0SXRlcmF0b3JNZXRob2QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2dldF9pdGVyYXRvcl9tZXRob2Q1KCkpOwogICAgICB2YXIgX3N5bWJvbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9zeW1ib2wzKCkpOwogICAgICB2YXIgX2Zyb20gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfZnJvbTMoKSk7CiAgICAgIHZhciBfY29uc3RydWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2NvbnN0cnVjdDMoKSk7CiAgICAgIHZhciBfY29uY2F0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2NvbmNhdDQoKSk7CiAgICAgIHZhciBfc2xpY2VkVG9BcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfc2xpY2VkVG9BcnJheSgpKTsKICAgICAgdmFyIF9zbGljZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9zbGljZTYoKSk7CiAgICAgIHZhciBfYXNzaWduID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2Fzc2lnbjMoKSk7CiAgICAgIHZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfcmVnZW5lcmF0b3IoKSk7CiAgICAgIHZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfYXN5bmNUb0dlbmVyYXRvcigpKTsKICAgICAgdmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfY2xhc3NDYWxsQ2hlY2soKSk7CiAgICAgIHZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2NyZWF0ZUNsYXNzKCkpOwogICAgICB2YXIgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfYXNzZXJ0VGhpc0luaXRpYWxpemVkKCkpOwogICAgICB2YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9pbmhlcml0cygpKTsKICAgICAgdmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKCkpOwogICAgICB2YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9nZXRQcm90b3R5cGVPZigpKTsKICAgICAgdmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfZGVmaW5lUHJvcGVydHkoKSk7CiAgICAgIHZhciBfbG9uZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9sb25nKCkpOwogICAgICB2YXIgX2JnemZGaWxlaGFuZGxlID0gcmVxdWlyZV9kaXN0MigpOwogICAgICB2YXIgX3ZpcnR1YWxPZmZzZXQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlX3ZpcnR1YWxPZmZzZXQoKSk7CiAgICAgIHZhciBfY2h1bmsgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfY2h1bmsoKSk7CiAgICAgIHZhciBfdXRpbCA9IHJlcXVpcmVfdXRpbCgpOwogICAgICB2YXIgX2luZGV4RmlsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9pbmRleEZpbGUoKSk7CiAgICAgIGZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7CiAgICAgICAgdmFyIGl0OwogICAgICAgIGlmICh0eXBlb2YgX3N5bWJvbC5kZWZhdWx0ID09PSAidW5kZWZpbmVkIiB8fCAoMCwgX2dldEl0ZXJhdG9yTWV0aG9kMi5kZWZhdWx0KShvKSA9PSBudWxsKSB7CiAgICAgICAgICBpZiAoKDAsIF9pc0FycmF5LmRlZmF1bHQpKG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09ICJudW1iZXIiKSB7CiAgICAgICAgICAgIGlmIChpdCkKICAgICAgICAgICAgICBvID0gaXQ7CiAgICAgICAgICAgIHZhciBpID0gMDsKICAgICAgICAgICAgdmFyIEYgPSBmdW5jdGlvbiBGMigpIHsKICAgICAgICAgICAgfTsKICAgICAgICAgICAgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsKICAgICAgICAgICAgICBpZiAoaSA+PSBvLmxlbmd0aCkKICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUgfTsKICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OwogICAgICAgICAgICB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7CiAgICAgICAgICAgICAgdGhyb3cgX2U7CiAgICAgICAgICAgIH0sIGY6IEYgfTsKICAgICAgICAgIH0KICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC4iKTsKICAgICAgICB9CiAgICAgICAgdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOwogICAgICAgIHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7CiAgICAgICAgICBpdCA9ICgwLCBfZ2V0SXRlcmF0b3IyLmRlZmF1bHQpKG8pOwogICAgICAgIH0sIG46IGZ1bmN0aW9uIG4oKSB7CiAgICAgICAgICB2YXIgc3RlcCA9IGl0Lm5leHQoKTsKICAgICAgICAgIG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7CiAgICAgICAgICByZXR1cm4gc3RlcDsKICAgICAgICB9LCBlOiBmdW5jdGlvbiBlKF9lMikgewogICAgICAgICAgZGlkRXJyID0gdHJ1ZTsKICAgICAgICAgIGVyciA9IF9lMjsKICAgICAgICB9LCBmOiBmdW5jdGlvbiBmKCkgewogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKQogICAgICAgICAgICAgIGl0LnJldHVybigpOwogICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgaWYgKGRpZEVycikKICAgICAgICAgICAgICB0aHJvdyBlcnI7CiAgICAgICAgICB9CiAgICAgICAgfSB9OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsKICAgICAgICB2YXIgX2NvbnRleHQ4OwogICAgICAgIGlmICghbykKICAgICAgICAgIHJldHVybjsKICAgICAgICBpZiAodHlwZW9mIG8gPT09ICJzdHJpbmciKQogICAgICAgICAgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7CiAgICAgICAgdmFyIG4gPSAoMCwgX3NsaWNlLmRlZmF1bHQpKF9jb250ZXh0OCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSkuY2FsbChfY29udGV4dDgsIDgsIC0xKTsKICAgICAgICBpZiAobiA9PT0gIk9iamVjdCIgJiYgby5jb25zdHJ1Y3RvcikKICAgICAgICAgIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7CiAgICAgICAgaWYgKG4gPT09ICJNYXAiIHx8IG4gPT09ICJTZXQiKQogICAgICAgICAgcmV0dXJuICgwLCBfZnJvbS5kZWZhdWx0KShvKTsKICAgICAgICBpZiAobiA9PT0gIkFyZ3VtZW50cyIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpCiAgICAgICAgICByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgewogICAgICAgIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKQogICAgICAgICAgbGVuID0gYXJyLmxlbmd0aDsKICAgICAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsKICAgICAgICAgIGFycjJbaV0gPSBhcnJbaV07CiAgICAgICAgfQogICAgICAgIHJldHVybiBhcnIyOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7CiAgICAgICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgewogICAgICAgICAgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoRGVyaXZlZCksIHJlc3VsdDsKICAgICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7CiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KSh0aGlzKS5jb25zdHJ1Y3RvcjsKICAgICAgICAgICAgcmVzdWx0ID0gKDAsIF9jb25zdHJ1Y3QuZGVmYXVsdCkoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCByZXN1bHQpOwogICAgICAgIH07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsKICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICJ1bmRlZmluZWQiIHx8ICFfY29uc3RydWN0LmRlZmF1bHQpCiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgaWYgKF9jb25zdHJ1Y3QuZGVmYXVsdC5zaGFtKQogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIGlmICh0eXBlb2YgUHJveHkgPT09ICJmdW5jdGlvbiIpCiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB0cnkgewogICAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCgoMCwgX2NvbnN0cnVjdC5kZWZhdWx0KShEYXRlLCBbXSwgZnVuY3Rpb24oKSB7CiAgICAgICAgICB9KSk7CiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICB9CiAgICAgIHZhciBDU0kxX01BR0lDID0gMjE1ODI2NTk7CiAgICAgIHZhciBDU0kyX01BR0lDID0gMzgzNTk4NzU7CiAgICAgIGZ1bmN0aW9uIGxzaGlmdChudW0sIGJpdHMpIHsKICAgICAgICByZXR1cm4gbnVtICogTWF0aC5wb3coMiwgYml0cyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcnNoaWZ0KG51bSwgYml0cykgewogICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bSAvIE1hdGgucG93KDIsIGJpdHMpKTsKICAgICAgfQogICAgICB2YXIgQ1NJID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKF9JbmRleEZpbGUpIHsKICAgICAgICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShDU0kyLCBfSW5kZXhGaWxlKTsKICAgICAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKENTSTIpOwogICAgICAgIGZ1bmN0aW9uIENTSTIoYXJncykgewogICAgICAgICAgdmFyIF90aGlzOwogICAgICAgICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgQ1NJMik7CiAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGFyZ3MpOwogICAgICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzKSwgIm1heEJpbk51bWJlciIsIHZvaWQgMCk7CiAgICAgICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXMpLCAiZGVwdGgiLCB2b2lkIDApOwogICAgICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzKSwgIm1pblNoaWZ0Iiwgdm9pZCAwKTsKICAgICAgICAgIF90aGlzLm1heEJpbk51bWJlciA9IDA7CiAgICAgICAgICBfdGhpcy5kZXB0aCA9IDA7CiAgICAgICAgICBfdGhpcy5taW5TaGlmdCA9IDA7CiAgICAgICAgICByZXR1cm4gX3RoaXM7CiAgICAgICAgfQogICAgICAgICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKENTSTIsIFt7CiAgICAgICAgICBrZXk6ICJsaW5lQ291bnQiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgX2xpbmVDb3VudCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShyZWZJZCkgewogICAgICAgICAgICAgIHZhciBpbmRleERhdGEsIGlkeCwgc3RhdHM7CiAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHsKICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHsKICAgICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlKCk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICAgICAgICAgICAgaW5kZXhEYXRhID0gX2NvbnRleHQuc2VudDsKICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleERhdGEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgicmV0dXJuIiwgLTEpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgNToKICAgICAgICAgICAgICAgICAgICAgIGlkeCA9IGluZGV4RGF0YS5pbmRpY2VzW3JlZklkXTsKICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDg7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgicmV0dXJuIiwgLTEpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgODoKICAgICAgICAgICAgICAgICAgICAgIHN0YXRzID0gaW5kZXhEYXRhLmluZGljZXNbcmVmSWRdLnN0YXRzOwogICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0cykgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgicmV0dXJuIiwgc3RhdHMubGluZUNvdW50KTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDExOgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgicmV0dXJuIiwgLTEpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6CiAgICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTsKICAgICAgICAgICAgfSkpOwogICAgICAgICAgICBmdW5jdGlvbiBsaW5lQ291bnQoX3gpIHsKICAgICAgICAgICAgICByZXR1cm4gX2xpbmVDb3VudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBsaW5lQ291bnQ7CiAgICAgICAgICB9KCkKICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJpbmRleENvdiIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciBfaW5kZXhDb3YgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKC8qIEBfX1BVUkVfXyAqLyBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkgewogICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHsKICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkgewogICAgICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KCJyZXR1cm4iLCBbXSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0sIF9jYWxsZWUyKTsKICAgICAgICAgICAgfSkpOwogICAgICAgICAgICBmdW5jdGlvbiBpbmRleENvdigpIHsKICAgICAgICAgICAgICByZXR1cm4gX2luZGV4Q292LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGluZGV4Q292OwogICAgICAgICAgfSgpCiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAicGFyc2VBdXhEYXRhIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUF1eERhdGEoYnl0ZXMsIG9mZnNldCwgYXV4TGVuZ3RoKSB7CiAgICAgICAgICAgIGlmIChhdXhMZW5ndGggPCAzMCkgewogICAgICAgICAgICAgIHJldHVybiB7fTsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgZGF0YSA9IHt9OwogICAgICAgICAgICBkYXRhLmZvcm1hdEZsYWdzID0gYnl0ZXMucmVhZEludDMyTEUob2Zmc2V0KTsKICAgICAgICAgICAgZGF0YS5jb29yZGluYXRlVHlwZSA9IGRhdGEuZm9ybWF0RmxhZ3MgJiA2NTUzNiA/ICJ6ZXJvLWJhc2VkLWhhbGYtb3BlbiIgOiAiMS1iYXNlZC1jbG9zZWQiOwogICAgICAgICAgICBkYXRhLmZvcm1hdCA9IHsKICAgICAgICAgICAgICAwOiAiZ2VuZXJpYyIsCiAgICAgICAgICAgICAgMTogIlNBTSIsCiAgICAgICAgICAgICAgMjogIlZDRiIKICAgICAgICAgICAgfVtkYXRhLmZvcm1hdEZsYWdzICYgMTVdOwogICAgICAgICAgICBpZiAoIWRhdGEuZm9ybWF0KSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJpbnZhbGlkIFRhYml4IHByZXNldCBmb3JtYXQgZmxhZ3MgIi5jb25jYXQoZGF0YS5mb3JtYXRGbGFncykpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGRhdGEuY29sdW1uTnVtYmVycyA9IHsKICAgICAgICAgICAgICByZWY6IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDQpLAogICAgICAgICAgICAgIHN0YXJ0OiBieXRlcy5yZWFkSW50MzJMRShvZmZzZXQgKyA4KSwKICAgICAgICAgICAgICBlbmQ6IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDEyKQogICAgICAgICAgICB9OwogICAgICAgICAgICBkYXRhLm1ldGFWYWx1ZSA9IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDE2KTsKICAgICAgICAgICAgZGF0YS5tZXRhQ2hhciA9IGRhdGEubWV0YVZhbHVlID8gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhLm1ldGFWYWx1ZSkgOiAiIjsKICAgICAgICAgICAgZGF0YS5za2lwTGluZXMgPSBieXRlcy5yZWFkSW50MzJMRShvZmZzZXQgKyAyMCk7CiAgICAgICAgICAgIHZhciBuYW1lU2VjdGlvbkxlbmd0aCA9IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDI0KTsKICAgICAgICAgICAgKDAsIF9hc3NpZ24uZGVmYXVsdCkoZGF0YSwgdGhpcy5fcGFyc2VOYW1lQnl0ZXMoKDAsIF9zbGljZS5kZWZhdWx0KShieXRlcykuY2FsbChieXRlcywgb2Zmc2V0ICsgMjgsIG9mZnNldCArIDI4ICsgbmFtZVNlY3Rpb25MZW5ndGgpKSk7CiAgICAgICAgICAgIHJldHVybiBkYXRhOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogIl9wYXJzZU5hbWVCeXRlcyIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3BhcnNlTmFtZUJ5dGVzKG5hbWVzQnl0ZXMpIHsKICAgICAgICAgICAgdmFyIGN1cnJSZWZJZCA9IDA7CiAgICAgICAgICAgIHZhciBjdXJyTmFtZVN0YXJ0ID0gMDsKICAgICAgICAgICAgdmFyIHJlZklkVG9OYW1lID0gW107CiAgICAgICAgICAgIHZhciByZWZOYW1lVG9JZCA9IHt9OwogICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzQnl0ZXMubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICAgICAgICBpZiAoIW5hbWVzQnl0ZXNbaV0pIHsKICAgICAgICAgICAgICAgIGlmIChjdXJyTmFtZVN0YXJ0IDwgaSkgewogICAgICAgICAgICAgICAgICB2YXIgcmVmTmFtZSA9IG5hbWVzQnl0ZXMudG9TdHJpbmcoInV0ZjgiLCBjdXJyTmFtZVN0YXJ0LCBpKTsKICAgICAgICAgICAgICAgICAgcmVmTmFtZSA9IHRoaXMucmVuYW1lUmVmU2VxKHJlZk5hbWUpOwogICAgICAgICAgICAgICAgICByZWZJZFRvTmFtZVtjdXJyUmVmSWRdID0gcmVmTmFtZTsKICAgICAgICAgICAgICAgICAgcmVmTmFtZVRvSWRbcmVmTmFtZV0gPSBjdXJyUmVmSWQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBjdXJyTmFtZVN0YXJ0ID0gaSArIDE7CiAgICAgICAgICAgICAgICBjdXJyUmVmSWQgKz0gMTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICByZWZOYW1lVG9JZCwKICAgICAgICAgICAgICByZWZJZFRvTmFtZQogICAgICAgICAgICB9OwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogIl9wYXJzZSIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciBfcGFyc2UyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KSgvKiBAX19QVVJFX18gKi8gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhvcHRzKSB7CiAgICAgICAgICAgICAgdmFyIGRhdGEsIGJ1ZmZlciwgYnl0ZXMsIGF1eExlbmd0aCwgY3Vyck9mZnNldCwgaSwgYmluQ291bnQsIGJpbkluZGV4LCBzdGF0cywgaiwgYmluLCBsb2Zmc2V0LCBjaHVua0NvdW50LCBjaHVua3MsIGssIHUsIHY7CiAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0MykgewogICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHsKICAgICAgICAgICAgICAgICAgICAgICAgY3NpOiB0cnVlLAogICAgICAgICAgICAgICAgICAgICAgICBtYXhCbG9ja1NpemU6IDEgPDwgMTYKICAgICAgICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDM7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlaGFuZGxlLnJlYWRGaWxlKG9wdHMpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMzoKICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IF9jb250ZXh0My5zZW50OwogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA2OwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfYmd6ZkZpbGVoYW5kbGUudW56aXApKGJ1ZmZlcik7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OgogICAgICAgICAgICAgICAgICAgICAgYnl0ZXMgPSBfY29udGV4dDMuc2VudDsKICAgICAgICAgICAgICAgICAgICAgIGlmICghKGJ5dGVzLnJlYWRVSW50MzJMRSgwKSA9PT0gQ1NJMV9NQUdJQykpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMTsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBkYXRhLmNzaVZlcnNpb24gPSAxOwogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxNjsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIShieXRlcy5yZWFkVUludDMyTEUoMCkgPT09IENTSTJfTUFHSUMpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTU7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgZGF0YS5jc2lWZXJzaW9uID0gMjsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTY7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OgogICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJOb3QgYSBDU0kgZmlsZSIpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6CiAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pblNoaWZ0ID0gYnl0ZXMucmVhZEludDMyTEUoNCk7CiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlcHRoID0gYnl0ZXMucmVhZEludDMyTEUoOCk7CiAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1heEJpbk51bWJlciA9ICgoMSA8PCAodGhpcy5kZXB0aCArIDEpICogMykgLSAxKSAvIDc7CiAgICAgICAgICAgICAgICAgICAgICBhdXhMZW5ndGggPSBieXRlcy5yZWFkSW50MzJMRSgxMik7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoYXV4TGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfYXNzaWduLmRlZmF1bHQpKGRhdGEsIHRoaXMucGFyc2VBdXhEYXRhKGJ5dGVzLCAxNiwgYXV4TGVuZ3RoKSk7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJlZkNvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoMTYgKyBhdXhMZW5ndGgpOwogICAgICAgICAgICAgICAgICAgICAgZGF0YS5pbmRpY2VzID0gbmV3IEFycmF5KGRhdGEucmVmQ291bnQpOwogICAgICAgICAgICAgICAgICAgICAgY3Vyck9mZnNldCA9IDE2ICsgYXV4TGVuZ3RoICsgNDsKICAgICAgICAgICAgICAgICAgICAgIGkgPSAwOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMjU6CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpIDwgZGF0YS5yZWZDb3VudCkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzNzsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI4OwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfdXRpbC5hYm9ydEJyZWFrUG9pbnQpKG9wdHMuc2lnbmFsKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDI4OgogICAgICAgICAgICAgICAgICAgICAgYmluQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICAgICAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gNDsKICAgICAgICAgICAgICAgICAgICAgIGJpbkluZGV4ID0ge307CiAgICAgICAgICAgICAgICAgICAgICBzdGF0cyA9IHZvaWQgMDsKICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBiaW5Db3VudDsgaiArPSAxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGJpbiA9IGJ5dGVzLnJlYWRVSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpbiA+IHRoaXMubWF4QmluTnVtYmVyKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHMgPSB0aGlzLnBhcnNlUHNldWRvQmluKGJ5dGVzLCBjdXJyT2Zmc2V0ICsgNCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyck9mZnNldCArPSA0ICsgOCArIDQgKyAxNiArIDE2OwogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgIGxvZmZzZXQgPSAoMCwgX3ZpcnR1YWxPZmZzZXQuZnJvbUJ5dGVzKShieXRlcywgY3Vyck9mZnNldCArIDQpOwogICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmRGaXJzdERhdGEoZGF0YSwgbG9mZnNldCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtDb3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKGN1cnJPZmZzZXQgKyAxMik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyck9mZnNldCArPSAxNjsKICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua3MgPSBuZXcgQXJyYXkoY2h1bmtDb3VudCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGNodW5rQ291bnQ7IGsgKz0gMSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9ICgwLCBfdmlydHVhbE9mZnNldC5mcm9tQnl0ZXMpKGJ5dGVzLCBjdXJyT2Zmc2V0KTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSAoMCwgX3ZpcnR1YWxPZmZzZXQuZnJvbUJ5dGVzKShieXRlcywgY3Vyck9mZnNldCArIDgpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyck9mZnNldCArPSAxNjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rc1trXSA9IG5ldyBfY2h1bmsuZGVmYXVsdCh1LCB2LCBiaW4pOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5JbmRleFtiaW5dID0gY2h1bmtzOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBkYXRhLmluZGljZXNbaV0gPSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGJpbkluZGV4LAogICAgICAgICAgICAgICAgICAgICAgICBzdGF0cwogICAgICAgICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDM0OgogICAgICAgICAgICAgICAgICAgICAgaSArPSAxOwogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAyNTsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMzc6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdCgicmV0dXJuIiwgZGF0YSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAzODoKICAgICAgICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9LCBfY2FsbGVlMywgdGhpcyk7CiAgICAgICAgICAgIH0pKTsKICAgICAgICAgICAgZnVuY3Rpb24gX3BhcnNlKF94MikgewogICAgICAgICAgICAgIHJldHVybiBfcGFyc2UyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIF9wYXJzZTsKICAgICAgICAgIH0oKQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogInBhcnNlUHNldWRvQmluIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVBzZXVkb0JpbihieXRlcywgb2Zmc2V0KSB7CiAgICAgICAgICAgIHZhciBsaW5lQ291bnQgPSAoMCwgX3V0aWwubG9uZ1RvTnVtYmVyKShfbG9uZy5kZWZhdWx0LmZyb21CeXRlc0xFKCgwLCBfc2xpY2UuZGVmYXVsdCkoQXJyYXkucHJvdG90eXBlKS5jYWxsKGJ5dGVzLCBvZmZzZXQgKyAyOCwgb2Zmc2V0ICsgMzYpLCB0cnVlKSk7CiAgICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgbGluZUNvdW50CiAgICAgICAgICAgIH07CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiYmxvY2tzRm9yUmFuZ2UiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgX2Jsb2Nrc0ZvclJhbmdlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KSgvKiBAX19QVVJFX18gKi8gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlNChyZWZJZCwgbWluLCBtYXgpIHsKICAgICAgICAgICAgICB2YXIgb3B0cywgaW5kZXhEYXRhLCBiYSwgb3ZlcmxhcHBpbmdCaW5zLCBjaHVua3MsIF9pdGVyYXRvciwgX3N0ZXAsIF9zdGVwJHZhbHVlLCBzdGFydCwgZW5kLCBiaW4sIGJpbkNodW5rcywgYywgX2FyZ3M0ID0gYXJndW1lbnRzOwogICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHsKICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkgewogICAgICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgICAgIG9wdHMgPSBfYXJnczQubGVuZ3RoID4gMyAmJiBfYXJnczRbM10gIT09IHZvaWQgMCA/IF9hcmdzNFszXSA6IHt9OwogICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbiA8IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgbWluID0gMDsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNDsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlKG9wdHMpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgNDoKICAgICAgICAgICAgICAgICAgICAgIGluZGV4RGF0YSA9IF9jb250ZXh0NC5zZW50OwogICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4RGF0YSkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDc7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoInJldHVybiIsIFtdKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDc6CiAgICAgICAgICAgICAgICAgICAgICBiYSA9IGluZGV4RGF0YS5pbmRpY2VzW3JlZklkXTsKICAgICAgICAgICAgICAgICAgICAgIGlmIChiYSkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDEwOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KCJyZXR1cm4iLCBbXSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDoKICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBwaW5nQmlucyA9IHRoaXMucmVnMmJpbnMobWluLCBtYXgpOwogICAgICAgICAgICAgICAgICAgICAgY2h1bmtzID0gW107CiAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvdmVybGFwcGluZ0JpbnMpOwogICAgICAgICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTsgKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0ZXAkdmFsdWUgPSAoMCwgX3NsaWNlZFRvQXJyYXkyLmRlZmF1bHQpKF9zdGVwLnZhbHVlLCAyKSwgc3RhcnQgPSBfc3RlcCR2YWx1ZVswXSwgZW5kID0gX3N0ZXAkdmFsdWVbMV07CiAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChiaW4gPSBzdGFydDsgYmluIDw9IGVuZDsgYmluKyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYS5iaW5JbmRleFtiaW5dKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbkNodW5rcyA9IGJhLmJpbkluZGV4W2Jpbl07CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoYyA9IDA7IGMgPCBiaW5DaHVua3MubGVuZ3RoOyArK2MpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaChuZXcgX2NodW5rLmRlZmF1bHQoYmluQ2h1bmtzW2NdLm1pbnYsIGJpbkNodW5rc1tjXS5tYXh2LCBiaW4pKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7CiAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IuZigpOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoInJldHVybiIsICgwLCBfdXRpbC5vcHRpbWl6ZUNodW5rcykoY2h1bmtzLCBuZXcgX3ZpcnR1YWxPZmZzZXQuZGVmYXVsdCgwLCAwKSkpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6CiAgICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSwgX2NhbGxlZTQsIHRoaXMpOwogICAgICAgICAgICB9KSk7CiAgICAgICAgICAgIGZ1bmN0aW9uIGJsb2Nrc0ZvclJhbmdlKF94MywgX3g0LCBfeDUpIHsKICAgICAgICAgICAgICByZXR1cm4gX2Jsb2Nrc0ZvclJhbmdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGJsb2Nrc0ZvclJhbmdlOwogICAgICAgICAgfSgpCiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAicmVnMmJpbnMiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlZzJiaW5zKGJlZywgZW5kKSB7CiAgICAgICAgICAgIGJlZyAtPSAxOwogICAgICAgICAgICBpZiAoYmVnIDwgMSkgewogICAgICAgICAgICAgIGJlZyA9IDE7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGVuZCA+IE1hdGgucG93KDIsIDUwKSkgewogICAgICAgICAgICAgIGVuZCA9IE1hdGgucG93KDIsIDM0KTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbmQgLT0gMTsKICAgICAgICAgICAgdmFyIGwgPSAwOwogICAgICAgICAgICB2YXIgdCA9IDA7CiAgICAgICAgICAgIHZhciBzID0gdGhpcy5taW5TaGlmdCArIHRoaXMuZGVwdGggKiAzOwogICAgICAgICAgICB2YXIgYmlucyA9IFtdOwogICAgICAgICAgICBmb3IgKDsgbCA8PSB0aGlzLmRlcHRoOyBzIC09IDMsIHQgKz0gbHNoaWZ0KDEsIGwgKiAzKSwgbCArPSAxKSB7CiAgICAgICAgICAgICAgdmFyIGIgPSB0ICsgcnNoaWZ0KGJlZywgcyk7CiAgICAgICAgICAgICAgdmFyIGUgPSB0ICsgcnNoaWZ0KGVuZCwgcyk7CiAgICAgICAgICAgICAgaWYgKGUgLSBiICsgYmlucy5sZW5ndGggPiB0aGlzLm1heEJpbk51bWJlcikgewogICAgICAgICAgICAgICAgdmFyIF9jb250ZXh0NSwgX2NvbnRleHQ2LCBfY29udGV4dDc7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKDAsIF9jb25jYXQuZGVmYXVsdCkoX2NvbnRleHQ1ID0gKDAsIF9jb25jYXQuZGVmYXVsdCkoX2NvbnRleHQ2ID0gKDAsIF9jb25jYXQuZGVmYXVsdCkoX2NvbnRleHQ3ID0gInF1ZXJ5ICIuY29uY2F0KGJlZywgIi0iKSkuY2FsbChfY29udGV4dDcsIGVuZCwgIiBpcyB0b28gbGFyZ2UgZm9yIGN1cnJlbnQgYmlubmluZyBzY2hlbWUgKHNoaWZ0ICIpKS5jYWxsKF9jb250ZXh0NiwgdGhpcy5taW5TaGlmdCwgIiwgZGVwdGggIikpLmNhbGwoX2NvbnRleHQ1LCB0aGlzLmRlcHRoLCAiKSwgdHJ5IGEgc21hbGxlciBxdWVyeSBvciBhIGNvYXJzZXIgaW5kZXggYmlubmluZyBzY2hlbWUiKSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGJpbnMucHVzaChbYiwgZV0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBiaW5zOwogICAgICAgICAgfQogICAgICAgIH1dKTsKICAgICAgICByZXR1cm4gQ1NJMjsKICAgICAgfShfaW5kZXhGaWxlLmRlZmF1bHQpOwogICAgICBleHBvcnRzLmRlZmF1bHQgPSBDU0k7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5kYXRlLm5vdy5qcwogIHZhciByZXF1aXJlX2VzX2RhdGVfbm93ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLmRhdGUubm93LmpzIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgJCA9IHJlcXVpcmVfZXhwb3J0KCk7CiAgICAgICQoeyB0YXJnZXQ6ICJEYXRlIiwgc3RhdDogdHJ1ZSB9LCB7CiAgICAgICAgbm93OiBmdW5jdGlvbiBub3coKSB7CiAgICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7CiAgICAgICAgfQogICAgICB9KTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9kYXRlL25vdy5qcwogIHZhciByZXF1aXJlX25vdyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvZGF0ZS9ub3cuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHJlcXVpcmVfZXNfZGF0ZV9ub3coKTsKICAgICAgdmFyIHBhdGggPSByZXF1aXJlX3BhdGgoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBwYXRoLkRhdGUubm93OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9kYXRlL25vdy5qcwogIHZhciByZXF1aXJlX25vdzIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9kYXRlL25vdy5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHBhcmVudCA9IHJlcXVpcmVfbm93KCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGFyZW50OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9kYXRlL25vdy5qcwogIHZhciByZXF1aXJlX25vdzMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9kYXRlL25vdy5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlX25vdzIoKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvYXJyYXktcmVkdWNlLmpzCiAgdmFyIHJlcXVpcmVfYXJyYXlfcmVkdWNlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvYXJyYXktcmVkdWNlLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgYUNhbGxhYmxlID0gcmVxdWlyZV9hX2NhbGxhYmxlKCk7CiAgICAgIHZhciB0b09iamVjdCA9IHJlcXVpcmVfdG9fb2JqZWN0KCk7CiAgICAgIHZhciBJbmRleGVkT2JqZWN0ID0gcmVxdWlyZV9pbmRleGVkX29iamVjdCgpOwogICAgICB2YXIgdG9MZW5ndGggPSByZXF1aXJlX3RvX2xlbmd0aCgpOwogICAgICB2YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24oSVNfUklHSFQpIHsKICAgICAgICByZXR1cm4gZnVuY3Rpb24odGhhdCwgY2FsbGJhY2tmbiwgYXJndW1lbnRzTGVuZ3RoLCBtZW1vKSB7CiAgICAgICAgICBhQ2FsbGFibGUoY2FsbGJhY2tmbik7CiAgICAgICAgICB2YXIgTyA9IHRvT2JqZWN0KHRoYXQpOwogICAgICAgICAgdmFyIHNlbGYyID0gSW5kZXhlZE9iamVjdChPKTsKICAgICAgICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7CiAgICAgICAgICB2YXIgaW5kZXggPSBJU19SSUdIVCA/IGxlbmd0aCAtIDEgOiAwOwogICAgICAgICAgdmFyIGkgPSBJU19SSUdIVCA/IC0xIDogMTsKICAgICAgICAgIGlmIChhcmd1bWVudHNMZW5ndGggPCAyKQogICAgICAgICAgICB3aGlsZSAodHJ1ZSkgewogICAgICAgICAgICAgIGlmIChpbmRleCBpbiBzZWxmMikgewogICAgICAgICAgICAgICAgbWVtbyA9IHNlbGYyW2luZGV4XTsKICAgICAgICAgICAgICAgIGluZGV4ICs9IGk7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaW5kZXggKz0gaTsKICAgICAgICAgICAgICBpZiAoSVNfUklHSFQgPyBpbmRleCA8IDAgOiBsZW5ndGggPD0gaW5kZXgpIHsKICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcigiUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZSIpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgZm9yICg7IElTX1JJR0hUID8gaW5kZXggPj0gMCA6IGxlbmd0aCA+IGluZGV4OyBpbmRleCArPSBpKQogICAgICAgICAgICBpZiAoaW5kZXggaW4gc2VsZjIpIHsKICAgICAgICAgICAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmMltpbmRleF0sIGluZGV4LCBPKTsKICAgICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIG1lbW87CiAgICAgICAgfTsKICAgICAgfTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSB7CiAgICAgICAgbGVmdDogY3JlYXRlTWV0aG9kKGZhbHNlKSwKICAgICAgICByaWdodDogY3JlYXRlTWV0aG9kKHRydWUpCiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5hcnJheS5yZWR1Y2UuanMKICB2YXIgcmVxdWlyZV9lc19hcnJheV9yZWR1Y2UgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuYXJyYXkucmVkdWNlLmpzIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciAkID0gcmVxdWlyZV9leHBvcnQoKTsKICAgICAgdmFyICRyZWR1Y2UgPSByZXF1aXJlX2FycmF5X3JlZHVjZSgpLmxlZnQ7CiAgICAgIHZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gcmVxdWlyZV9hcnJheV9tZXRob2RfaXNfc3RyaWN0KCk7CiAgICAgIHZhciBDSFJPTUVfVkVSU0lPTiA9IHJlcXVpcmVfZW5naW5lX3Y4X3ZlcnNpb24oKTsKICAgICAgdmFyIElTX05PREUgPSByZXF1aXJlX2VuZ2luZV9pc19ub2RlKCk7CiAgICAgIHZhciBTVFJJQ1RfTUVUSE9EID0gYXJyYXlNZXRob2RJc1N0cmljdCgicmVkdWNlIik7CiAgICAgIHZhciBDSFJPTUVfQlVHID0gIUlTX05PREUgJiYgQ0hST01FX1ZFUlNJT04gPiA3OSAmJiBDSFJPTUVfVkVSU0lPTiA8IDgzOwogICAgICAkKHsgdGFyZ2V0OiAiQXJyYXkiLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhU1RSSUNUX01FVEhPRCB8fCBDSFJPTUVfQlVHIH0sIHsKICAgICAgICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuKSB7CiAgICAgICAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMCk7CiAgICAgICAgfQogICAgICB9KTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9hcnJheS92aXJ0dWFsL3JlZHVjZS5qcwogIHZhciByZXF1aXJlX3JlZHVjZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvYXJyYXkvdmlydHVhbC9yZWR1Y2UuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHJlcXVpcmVfZXNfYXJyYXlfcmVkdWNlKCk7CiAgICAgIHZhciBlbnRyeVZpcnR1YWwgPSByZXF1aXJlX2VudHJ5X3ZpcnR1YWwoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBlbnRyeVZpcnR1YWwoIkFycmF5IikucmVkdWNlOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2luc3RhbmNlL3JlZHVjZS5qcwogIHZhciByZXF1aXJlX3JlZHVjZTIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2luc3RhbmNlL3JlZHVjZS5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHJlZHVjZSA9IHJlcXVpcmVfcmVkdWNlKCk7CiAgICAgIHZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCkgewogICAgICAgIHZhciBvd24gPSBpdC5yZWR1Y2U7CiAgICAgICAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSB8fCBpdCBpbnN0YW5jZW9mIEFycmF5ICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUucmVkdWNlID8gcmVkdWNlIDogb3duOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9pbnN0YW5jZS9yZWR1Y2UuanMKICB2YXIgcmVxdWlyZV9yZWR1Y2UzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvaW5zdGFuY2UvcmVkdWNlLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgcGFyZW50ID0gcmVxdWlyZV9yZWR1Y2UyKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGFyZW50OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9pbnN0YW5jZS9yZWR1Y2UuanMKICB2YXIgcmVxdWlyZV9yZWR1Y2U0ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvaW5zdGFuY2UvcmVkdWNlLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVfcmVkdWNlMygpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuZnVuY3Rpb24uYmluZC5qcwogIHZhciByZXF1aXJlX2VzX2Z1bmN0aW9uX2JpbmQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuZnVuY3Rpb24uYmluZC5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyICQgPSByZXF1aXJlX2V4cG9ydCgpOwogICAgICB2YXIgYmluZCA9IHJlcXVpcmVfZnVuY3Rpb25fYmluZCgpOwogICAgICAkKHsgdGFyZ2V0OiAiRnVuY3Rpb24iLCBwcm90bzogdHJ1ZSB9LCB7CiAgICAgICAgYmluZAogICAgICB9KTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9mdW5jdGlvbi92aXJ0dWFsL2JpbmQuanMKICB2YXIgcmVxdWlyZV9iaW5kID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9mdW5jdGlvbi92aXJ0dWFsL2JpbmQuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHJlcXVpcmVfZXNfZnVuY3Rpb25fYmluZCgpOwogICAgICB2YXIgZW50cnlWaXJ0dWFsID0gcmVxdWlyZV9lbnRyeV92aXJ0dWFsKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZW50cnlWaXJ0dWFsKCJGdW5jdGlvbiIpLmJpbmQ7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvaW5zdGFuY2UvYmluZC5qcwogIHZhciByZXF1aXJlX2JpbmQyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9pbnN0YW5jZS9iaW5kLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgYmluZCA9IHJlcXVpcmVfYmluZCgpOwogICAgICB2YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpIHsKICAgICAgICB2YXIgb3duID0gaXQuYmluZDsKICAgICAgICByZXR1cm4gaXQgPT09IEZ1bmN0aW9uUHJvdG90eXBlIHx8IGl0IGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgb3duID09PSBGdW5jdGlvblByb3RvdHlwZS5iaW5kID8gYmluZCA6IG93bjsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvaW5zdGFuY2UvYmluZC5qcwogIHZhciByZXF1aXJlX2JpbmQzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvaW5zdGFuY2UvYmluZC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHBhcmVudCA9IHJlcXVpcmVfYmluZDIoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL2luc3RhbmNlL2JpbmQuanMKICB2YXIgcmVxdWlyZV9iaW5kNCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL2luc3RhbmNlL2JpbmQuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZV9iaW5kMygpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL3N5bWJvbC9hc3luYy1pdGVyYXRvci5qcwogIHZhciByZXF1aXJlX2FzeW5jX2l0ZXJhdG9yID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9zeW1ib2wvYXN5bmMtaXRlcmF0b3IuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHJlcXVpcmVfZXNfc3ltYm9sX2FzeW5jX2l0ZXJhdG9yKCk7CiAgICAgIHZhciBXcmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlID0gcmVxdWlyZV93ZWxsX2tub3duX3N5bWJvbF93cmFwcGVkKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gV3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZS5mKCJhc3luY0l0ZXJhdG9yIik7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL3N5bWJvbC9hc3luYy1pdGVyYXRvci5qcwogIHZhciByZXF1aXJlX2FzeW5jX2l0ZXJhdG9yMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL3N5bWJvbC9hc3luYy1pdGVyYXRvci5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHBhcmVudCA9IHJlcXVpcmVfYXN5bmNfaXRlcmF0b3IoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZmVhdHVyZXMvc3ltYm9sL2FzeW5jLWl0ZXJhdG9yLmpzCiAgdmFyIHJlcXVpcmVfYXN5bmNfaXRlcmF0b3IzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9mZWF0dXJlcy9zeW1ib2wvYXN5bmMtaXRlcmF0b3IuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBwYXJlbnQgPSByZXF1aXJlX2FzeW5jX2l0ZXJhdG9yMigpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcmVudDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy9zeW1ib2wvYXN5bmMtaXRlcmF0b3IuanMKICB2YXIgcmVxdWlyZV9hc3luY19pdGVyYXRvcjQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzL3N5bWJvbC9hc3luYy1pdGVyYXRvci5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlX2FzeW5jX2l0ZXJhdG9yMygpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9oZWxwZXJzL0F3YWl0VmFsdWUuanMKICB2YXIgcmVxdWlyZV9Bd2FpdFZhbHVlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvaGVscGVycy9Bd2FpdFZhbHVlLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBmdW5jdGlvbiBfQXdhaXRWYWx1ZSh2YWx1ZSkgewogICAgICAgIHRoaXMud3JhcHBlZCA9IHZhbHVlOwogICAgICB9CiAgICAgIG1vZHVsZS5leHBvcnRzID0gX0F3YWl0VmFsdWU7CiAgICAgIG1vZHVsZS5leHBvcnRzWyJkZWZhdWx0Il0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvQXN5bmNHZW5lcmF0b3IuanMKICB2YXIgcmVxdWlyZV9Bc3luY0dlbmVyYXRvciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvQXN5bmNHZW5lcmF0b3IuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBfUHJvbWlzZSA9IHJlcXVpcmVfcHJvbWlzZTQoKTsKICAgICAgdmFyIF9TeW1ib2wgPSByZXF1aXJlX3N5bWJvbDUoKTsKICAgICAgdmFyIF9TeW1ib2wkYXN5bmNJdGVyYXRvciA9IHJlcXVpcmVfYXN5bmNfaXRlcmF0b3I0KCk7CiAgICAgIHZhciBBd2FpdFZhbHVlID0gcmVxdWlyZV9Bd2FpdFZhbHVlKCk7CiAgICAgIGZ1bmN0aW9uIEFzeW5jR2VuZXJhdG9yKGdlbikgewogICAgICAgIHZhciBmcm9udCwgYmFjazsKICAgICAgICBmdW5jdGlvbiBzZW5kKGtleSwgYXJnKSB7CiAgICAgICAgICByZXR1cm4gbmV3IF9Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkgewogICAgICAgICAgICB2YXIgcmVxdWVzdCA9IHsKICAgICAgICAgICAgICBrZXksCiAgICAgICAgICAgICAgYXJnLAogICAgICAgICAgICAgIHJlc29sdmUsCiAgICAgICAgICAgICAgcmVqZWN0LAogICAgICAgICAgICAgIG5leHQ6IG51bGwKICAgICAgICAgICAgfTsKICAgICAgICAgICAgaWYgKGJhY2spIHsKICAgICAgICAgICAgICBiYWNrID0gYmFjay5uZXh0ID0gcmVxdWVzdDsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBmcm9udCA9IGJhY2sgPSByZXF1ZXN0OwogICAgICAgICAgICAgIHJlc3VtZShrZXksIGFyZyk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiByZXN1bWUoa2V5LCBhcmcpIHsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHZhciByZXN1bHQgPSBnZW5ba2V5XShhcmcpOwogICAgICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7CiAgICAgICAgICAgIHZhciB3cmFwcGVkQXdhaXQgPSB2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0VmFsdWU7CiAgICAgICAgICAgIF9Qcm9taXNlLnJlc29sdmUod3JhcHBlZEF3YWl0ID8gdmFsdWUud3JhcHBlZCA6IHZhbHVlKS50aGVuKGZ1bmN0aW9uKGFyZzIpIHsKICAgICAgICAgICAgICBpZiAod3JhcHBlZEF3YWl0KSB7CiAgICAgICAgICAgICAgICByZXN1bWUoa2V5ID09PSAicmV0dXJuIiA/ICJyZXR1cm4iIDogIm5leHQiLCBhcmcyKTsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgc2V0dGxlKHJlc3VsdC5kb25lID8gInJldHVybiIgOiAibm9ybWFsIiwgYXJnMik7CiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikgewogICAgICAgICAgICAgIHJlc3VtZSgidGhyb3ciLCBlcnIpOwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgICBzZXR0bGUoInRocm93IiwgZXJyKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKHR5cGUsIHZhbHVlKSB7CiAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHsKICAgICAgICAgICAgY2FzZSAicmV0dXJuIjoKICAgICAgICAgICAgICBmcm9udC5yZXNvbHZlKHsKICAgICAgICAgICAgICAgIHZhbHVlLAogICAgICAgICAgICAgICAgZG9uZTogdHJ1ZQogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlICJ0aHJvdyI6CiAgICAgICAgICAgICAgZnJvbnQucmVqZWN0KHZhbHVlKTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICBmcm9udC5yZXNvbHZlKHsKICAgICAgICAgICAgICAgIHZhbHVlLAogICAgICAgICAgICAgICAgZG9uZTogZmFsc2UKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIGZyb250ID0gZnJvbnQubmV4dDsKICAgICAgICAgIGlmIChmcm9udCkgewogICAgICAgICAgICByZXN1bWUoZnJvbnQua2V5LCBmcm9udC5hcmcpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgYmFjayA9IG51bGw7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHRoaXMuX2ludm9rZSA9IHNlbmQ7CiAgICAgICAgaWYgKHR5cGVvZiBnZW5bInJldHVybiJdICE9PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICB0aGlzWyJyZXR1cm4iXSA9IHZvaWQgMDsKICAgICAgICB9CiAgICAgIH0KICAgICAgQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlW3R5cGVvZiBfU3ltYm9sID09PSAiZnVuY3Rpb24iICYmIF9TeW1ib2wkYXN5bmNJdGVyYXRvciB8fCAiQEBhc3luY0l0ZXJhdG9yIl0gPSBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfTsKICAgICAgQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbihhcmcpIHsKICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKCJuZXh0IiwgYXJnKTsKICAgICAgfTsKICAgICAgQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlWyJ0aHJvdyJdID0gZnVuY3Rpb24oYXJnKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZSgidGhyb3ciLCBhcmcpOwogICAgICB9OwogICAgICBBc3luY0dlbmVyYXRvci5wcm90b3R5cGVbInJldHVybiJdID0gZnVuY3Rpb24oYXJnKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZSgicmV0dXJuIiwgYXJnKTsKICAgICAgfTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBBc3luY0dlbmVyYXRvcjsKICAgICAgbW9kdWxlLmV4cG9ydHNbImRlZmF1bHQiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvaGVscGVycy93cmFwQXN5bmNHZW5lcmF0b3IuanMKICB2YXIgcmVxdWlyZV93cmFwQXN5bmNHZW5lcmF0b3IgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9oZWxwZXJzL3dyYXBBc3luY0dlbmVyYXRvci5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIEFzeW5jR2VuZXJhdG9yID0gcmVxdWlyZV9Bc3luY0dlbmVyYXRvcigpOwogICAgICBmdW5jdGlvbiBfd3JhcEFzeW5jR2VuZXJhdG9yKGZuKSB7CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgewogICAgICAgICAgcmV0dXJuIG5ldyBBc3luY0dlbmVyYXRvcihmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTsKICAgICAgICB9OwogICAgICB9CiAgICAgIG1vZHVsZS5leHBvcnRzID0gX3dyYXBBc3luY0dlbmVyYXRvcjsKICAgICAgbW9kdWxlLmV4cG9ydHNbImRlZmF1bHQiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvaGVscGVycy9hd2FpdEFzeW5jR2VuZXJhdG9yLmpzCiAgdmFyIHJlcXVpcmVfYXdhaXRBc3luY0dlbmVyYXRvciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvYXdhaXRBc3luY0dlbmVyYXRvci5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIEF3YWl0VmFsdWUgPSByZXF1aXJlX0F3YWl0VmFsdWUoKTsKICAgICAgZnVuY3Rpb24gX2F3YWl0QXN5bmNHZW5lcmF0b3IodmFsdWUpIHsKICAgICAgICByZXR1cm4gbmV3IEF3YWl0VmFsdWUodmFsdWUpOwogICAgICB9CiAgICAgIG1vZHVsZS5leHBvcnRzID0gX2F3YWl0QXN5bmNHZW5lcmF0b3I7CiAgICAgIG1vZHVsZS5leHBvcnRzWyJkZWZhdWx0Il0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvYXN5bmNHZW5lcmF0b3JEZWxlZ2F0ZS5qcwogIHZhciByZXF1aXJlX2FzeW5jR2VuZXJhdG9yRGVsZWdhdGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9oZWxwZXJzL2FzeW5jR2VuZXJhdG9yRGVsZWdhdGUuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBfUHJvbWlzZSA9IHJlcXVpcmVfcHJvbWlzZTQoKTsKICAgICAgdmFyIF9TeW1ib2wgPSByZXF1aXJlX3N5bWJvbDUoKTsKICAgICAgdmFyIF9TeW1ib2wkaXRlcmF0b3IgPSByZXF1aXJlX2l0ZXJhdG9yNCgpOwogICAgICBmdW5jdGlvbiBfYXN5bmNHZW5lcmF0b3JEZWxlZ2F0ZShpbm5lciwgYXdhaXRXcmFwKSB7CiAgICAgICAgdmFyIGl0ZXIgPSB7fSwgd2FpdGluZyA9IGZhbHNlOwogICAgICAgIGZ1bmN0aW9uIHB1bXAoa2V5LCB2YWx1ZSkgewogICAgICAgICAgd2FpdGluZyA9IHRydWU7CiAgICAgICAgICB2YWx1ZSA9IG5ldyBfUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7CiAgICAgICAgICAgIHJlc29sdmUoaW5uZXJba2V5XSh2YWx1ZSkpOwogICAgICAgICAgfSk7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICBkb25lOiBmYWxzZSwKICAgICAgICAgICAgdmFsdWU6IGF3YWl0V3JhcCh2YWx1ZSkKICAgICAgICAgIH07CiAgICAgICAgfQogICAgICAgIDsKICAgICAgICBpdGVyW3R5cGVvZiBfU3ltYm9sICE9PSAidW5kZWZpbmVkIiAmJiBfU3ltYm9sJGl0ZXJhdG9yIHx8ICJAQGl0ZXJhdG9yIl0gPSBmdW5jdGlvbigpIHsKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIH07CiAgICAgICAgaXRlci5uZXh0ID0gZnVuY3Rpb24odmFsdWUpIHsKICAgICAgICAgIGlmICh3YWl0aW5nKSB7CiAgICAgICAgICAgIHdhaXRpbmcgPSBmYWxzZTsKICAgICAgICAgICAgcmV0dXJuIHZhbHVlOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHB1bXAoIm5leHQiLCB2YWx1ZSk7CiAgICAgICAgfTsKICAgICAgICBpZiAodHlwZW9mIGlubmVyWyJ0aHJvdyJdID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICBpdGVyWyJ0aHJvdyJdID0gZnVuY3Rpb24odmFsdWUpIHsKICAgICAgICAgICAgaWYgKHdhaXRpbmcpIHsKICAgICAgICAgICAgICB3YWl0aW5nID0gZmFsc2U7CiAgICAgICAgICAgICAgdGhyb3cgdmFsdWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHB1bXAoInRocm93IiwgdmFsdWUpOwogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiBpbm5lclsicmV0dXJuIl0gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIGl0ZXJbInJldHVybiJdID0gZnVuY3Rpb24odmFsdWUpIHsKICAgICAgICAgICAgaWYgKHdhaXRpbmcpIHsKICAgICAgICAgICAgICB3YWl0aW5nID0gZmFsc2U7CiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBwdW1wKCJyZXR1cm4iLCB2YWx1ZSk7CiAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgICByZXR1cm4gaXRlcjsKICAgICAgfQogICAgICBtb2R1bGUuZXhwb3J0cyA9IF9hc3luY0dlbmVyYXRvckRlbGVnYXRlOwogICAgICBtb2R1bGUuZXhwb3J0c1siZGVmYXVsdCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9oZWxwZXJzL2FzeW5jSXRlcmF0b3IuanMKICB2YXIgcmVxdWlyZV9hc3luY0l0ZXJhdG9yID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvaGVscGVycy9hc3luY0l0ZXJhdG9yLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgX1N5bWJvbCA9IHJlcXVpcmVfc3ltYm9sNSgpOwogICAgICB2YXIgX1N5bWJvbCRhc3luY0l0ZXJhdG9yID0gcmVxdWlyZV9hc3luY19pdGVyYXRvcjQoKTsKICAgICAgdmFyIF9TeW1ib2wkaXRlcmF0b3IgPSByZXF1aXJlX2l0ZXJhdG9yNCgpOwogICAgICB2YXIgX2dldEl0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZV9nZXRfaXRlcmF0b3JfbWV0aG9kNSgpOwogICAgICBmdW5jdGlvbiBfYXN5bmNJdGVyYXRvcihpdGVyYWJsZSkgewogICAgICAgIHZhciBtZXRob2Q7CiAgICAgICAgaWYgKHR5cGVvZiBfU3ltYm9sICE9PSAidW5kZWZpbmVkIikgewogICAgICAgICAgaWYgKF9TeW1ib2wkYXN5bmNJdGVyYXRvcikKICAgICAgICAgICAgbWV0aG9kID0gaXRlcmFibGVbX1N5bWJvbCRhc3luY0l0ZXJhdG9yXTsKICAgICAgICAgIGlmIChtZXRob2QgPT0gbnVsbCAmJiBfU3ltYm9sJGl0ZXJhdG9yKQogICAgICAgICAgICBtZXRob2QgPSBfZ2V0SXRlcmF0b3JNZXRob2QoaXRlcmFibGUpOwogICAgICAgIH0KICAgICAgICBpZiAobWV0aG9kID09IG51bGwpCiAgICAgICAgICBtZXRob2QgPSBpdGVyYWJsZVsiQEBhc3luY0l0ZXJhdG9yIl07CiAgICAgICAgaWYgKG1ldGhvZCA9PSBudWxsKQogICAgICAgICAgbWV0aG9kID0gaXRlcmFibGVbIkBAaXRlcmF0b3IiXTsKICAgICAgICBpZiAobWV0aG9kID09IG51bGwpCiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJPYmplY3QgaXMgbm90IGFzeW5jIGl0ZXJhYmxlIik7CiAgICAgICAgcmV0dXJuIG1ldGhvZC5jYWxsKGl0ZXJhYmxlKTsKICAgICAgfQogICAgICBtb2R1bGUuZXhwb3J0cyA9IF9hc3luY0l0ZXJhdG9yOwogICAgICBtb2R1bGUuZXhwb3J0c1siZGVmYXVsdCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvYnVmZmVyLWNyYzMyL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfYnVmZmVyX2NyYzMyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2J1ZmZlci1jcmMzMi9pbmRleC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIEJ1ZmZlcjMgPSByZXF1aXJlX2J1ZmZlcigpLkJ1ZmZlcjsKICAgICAgdmFyIENSQ19UQUJMRSA9IFsKICAgICAgICAwLAogICAgICAgIDE5OTY5NTk4OTQsCiAgICAgICAgMzk5MzkxOTc4OCwKICAgICAgICAyNTY3NTI0Nzk0LAogICAgICAgIDEyNDYzNDEzNywKICAgICAgICAxODg2MDU3NjE1LAogICAgICAgIDM5MTU2MjE2ODUsCiAgICAgICAgMjY1NzM5MjAzNSwKICAgICAgICAyNDkyNjgyNzQsCiAgICAgICAgMjA0NDUwODMyNCwKICAgICAgICAzNzcyMTE1MjMwLAogICAgICAgIDI1NDcxNzc4NjQsCiAgICAgICAgMTYyOTQxOTk1LAogICAgICAgIDIxMjU1NjEwMjEsCiAgICAgICAgMzg4NzYwNzA0NywKICAgICAgICAyNDI4NDQ0MDQ5LAogICAgICAgIDQ5ODUzNjU0OCwKICAgICAgICAxNzg5OTI3NjY2LAogICAgICAgIDQwODkwMTY2NDgsCiAgICAgICAgMjIyNzA2MTIxNCwKICAgICAgICA0NTA1NDg4NjEsCiAgICAgICAgMTg0MzI1ODYwMywKICAgICAgICA0MTA3NTgwNzUzLAogICAgICAgIDIyMTE2Nzc2MzksCiAgICAgICAgMzI1ODgzOTkwLAogICAgICAgIDE2ODQ3NzcxNTIsCiAgICAgICAgNDI1MTEyMjA0MiwKICAgICAgICAyMzIxOTI2NjM2LAogICAgICAgIDMzNTYzMzQ4NywKICAgICAgICAxNjYxMzY1NDY1LAogICAgICAgIDQxOTUzMDI3NTUsCiAgICAgICAgMjM2NjExNTMxNywKICAgICAgICA5OTcwNzMwOTYsCiAgICAgICAgMTI4MTk1Mzg4NiwKICAgICAgICAzNTc5ODU1MzMyLAogICAgICAgIDI3MjQ2ODgyNDIsCiAgICAgICAgMTAwNjg4ODE0NSwKICAgICAgICAxMjU4NjA3Njg3LAogICAgICAgIDM1MjQxMDE2MjksCiAgICAgICAgMjc2ODk0MjQ0MywKICAgICAgICA5MDEwOTc3MjIsCiAgICAgICAgMTExOTAwMDY4NCwKICAgICAgICAzNjg2NTE3MjA2LAogICAgICAgIDI4OTgwNjU3MjgsCiAgICAgICAgODUzMDQ0NDUxLAogICAgICAgIDExNzIyNjYxMDEsCiAgICAgICAgMzcwNTAxNTc1OSwKICAgICAgICAyODgyNjE2NjY1LAogICAgICAgIDY1MTc2Nzk4MCwKICAgICAgICAxMzczNTAzNTQ2LAogICAgICAgIDMzNjk1NTQzMDQsCiAgICAgICAgMzIxODEwNDU5OCwKICAgICAgICA1NjU1MDcyNTMsCiAgICAgICAgMTQ1NDYyMTczMSwKICAgICAgICAzNDg1MTExNzA1LAogICAgICAgIDMwOTk0MzYzMDMsCiAgICAgICAgNjcxMjY2OTc0LAogICAgICAgIDE1OTQxOTgwMjQsCiAgICAgICAgMzMyMjczMDkzMCwKICAgICAgICAyOTcwMzQ3ODEyLAogICAgICAgIDc5NTgzNTUyNywKICAgICAgICAxNDgzMjMwMjI1LAogICAgICAgIDMyNDQzNjcyNzUsCiAgICAgICAgMzA2MDE0OTU2NSwKICAgICAgICAxOTk0MTQ2MTkyLAogICAgICAgIDMxMTU4NTM0LAogICAgICAgIDI1NjM5MDc3NzIsCiAgICAgICAgNDAyMzcxNzkzMCwKICAgICAgICAxOTA3NDU5NDY1LAogICAgICAgIDExMjYzNzIxNSwKICAgICAgICAyNjgwMTUzMjUzLAogICAgICAgIDM5MDQ0MjcwNTksCiAgICAgICAgMjAxMzc3NjI5MCwKICAgICAgICAyNTE3MjIwMzYsCiAgICAgICAgMjUxNzIxNTM3NCwKICAgICAgICAzNzc1ODMwMDQwLAogICAgICAgIDIxMzc2NTY3NjMsCiAgICAgICAgMTQxMzc2ODEzLAogICAgICAgIDI0MzkyNzc3MTksCiAgICAgICAgMzg2NTI3MTI5NywKICAgICAgICAxODAyMTk1NDQ0LAogICAgICAgIDQ3Njg2NDg2NiwKICAgICAgICAyMjM4MDAxMzY4LAogICAgICAgIDQwNjY1MDg4NzgsCiAgICAgICAgMTgxMjM3MDkyNSwKICAgICAgICA0NTMwOTI3MzEsCiAgICAgICAgMjE4MTYyNTAyNSwKICAgICAgICA0MTExNDUxMjIzLAogICAgICAgIDE3MDYwODg5MDIsCiAgICAgICAgMzE0MDQyNzA0LAogICAgICAgIDIzNDQ1MzIyMDIsCiAgICAgICAgNDI0MDAxNzUzMiwKICAgICAgICAxNjU4NjU4MjcxLAogICAgICAgIDM2NjYxOTk3NywKICAgICAgICAyMzYyNjcwMzIzLAogICAgICAgIDQyMjQ5OTQ0MDUsCiAgICAgICAgMTMwMzUzNTk2MCwKICAgICAgICA5ODQ5NjE0ODYsCiAgICAgICAgMjc0NzAwNzA5MiwKICAgICAgICAzNTY5MDM3NTM4LAogICAgICAgIDEyNTYxNzA4MTcsCiAgICAgICAgMTAzNzYwNDMxMSwKICAgICAgICAyNzY1MjEwNzMzLAogICAgICAgIDM1NTQwNzk5OTUsCiAgICAgICAgMTEzMTAxNDUwNiwKICAgICAgICA4Nzk2Nzk5OTYsCiAgICAgICAgMjkwOTI0MzQ2MiwKICAgICAgICAzNjYzNzcxODU2LAogICAgICAgIDExNDExMjQ0NjcsCiAgICAgICAgODU1ODQyMjc3LAogICAgICAgIDI4NTI4MDE2MzEsCiAgICAgICAgMzcwODY0ODY0OSwKICAgICAgICAxMzQyNTMzOTQ4LAogICAgICAgIDY1NDQ1OTMwNiwKICAgICAgICAzMTg4Mzk2MDQ4LAogICAgICAgIDMzNzMwMTUxNzQsCiAgICAgICAgMTQ2NjQ3OTkwOSwKICAgICAgICA1NDQxNzk2MzUsCiAgICAgICAgMzExMDUyMzkxMywKICAgICAgICAzNDYyNTIyMDE1LAogICAgICAgIDE1OTE2NzEwNTQsCiAgICAgICAgNzAyMTM4Nzc2LAogICAgICAgIDI5NjY0NjA0NTAsCiAgICAgICAgMzM1Mjc5OTQxMiwKICAgICAgICAxNTA0OTE4ODA3LAogICAgICAgIDc4MzU1MTg3MywKICAgICAgICAzMDgyNjQwNDQzLAogICAgICAgIDMyMzM0NDI5ODksCiAgICAgICAgMzk4ODI5MjM4NCwKICAgICAgICAyNTk2MjU0NjQ2LAogICAgICAgIDYyMzE3MDY4LAogICAgICAgIDE5NTc4MTA4NDIsCiAgICAgICAgMzkzOTg0NTk0NSwKICAgICAgICAyNjQ3ODE2MTExLAogICAgICAgIDgxNDcwOTk3LAogICAgICAgIDE5NDM4MDM1MjMsCiAgICAgICAgMzgxNDkxODkzMCwKICAgICAgICAyNDg5NTk2ODA0LAogICAgICAgIDIyNTI3NDQzMCwKICAgICAgICAyMDUzNzkwMzc2LAogICAgICAgIDM4MjYxNzU3NTUsCiAgICAgICAgMjQ2NjkwNjAxMywKICAgICAgICAxNjc4MTY3NDMsCiAgICAgICAgMjA5NzY1MTM3NywKICAgICAgICA0MDI3NTUyNTgwLAogICAgICAgIDIyNjU0OTAzODYsCiAgICAgICAgNTAzNDQ0MDcyLAogICAgICAgIDE3NjIwNTA4MTQsCiAgICAgICAgNDE1MDQxNzI0NSwKICAgICAgICAyMTU0MTI5MzU1LAogICAgICAgIDQyNjUyMjIyNSwKICAgICAgICAxODUyNTA3ODc5LAogICAgICAgIDQyNzUzMTM1MjYsCiAgICAgICAgMjMxMjMxNzkyMCwKICAgICAgICAyODI3NTM2MjYsCiAgICAgICAgMTc0MjU1NTg1MiwKICAgICAgICA0MTg5NzA4MTQzLAogICAgICAgIDIzOTQ4Nzc5NDUsCiAgICAgICAgMzk3OTE3NzYzLAogICAgICAgIDE2MjIxODM2MzcsCiAgICAgICAgMzYwNDM5MDg4OCwKICAgICAgICAyNzE0ODY2NTU4LAogICAgICAgIDk1MzcyOTczMiwKICAgICAgICAxMzQwMDc2NjI2LAogICAgICAgIDM1MTg3MTk5ODUsCiAgICAgICAgMjc5NzM2MDk5OSwKICAgICAgICAxMDY4ODI4MzgxLAogICAgICAgIDEyMTk2Mzg4NTksCiAgICAgICAgMzYyNDc0MTg1MCwKICAgICAgICAyOTM2Njc1MTQ4LAogICAgICAgIDkwNjE4NTQ2MiwKICAgICAgICAxMDkwODEyNTEyLAogICAgICAgIDM3NDc2NzIwMDMsCiAgICAgICAgMjgyNTM3OTY2OSwKICAgICAgICA4MjkzMjkxMzUsCiAgICAgICAgMTE4MTMzNTE2MSwKICAgICAgICAzNDEyMTc3ODA0LAogICAgICAgIDMxNjA4MzQ4NDIsCiAgICAgICAgNjI4MDg1NDA4LAogICAgICAgIDEzODI2MDUzNjYsCiAgICAgICAgMzQyMzM2OTEwOSwKICAgICAgICAzMTM4MDc4NDY3LAogICAgICAgIDU3MDU2MjIzMywKICAgICAgICAxNDI2NDAwODE1LAogICAgICAgIDMzMTczMTY1NDIsCiAgICAgICAgMjk5ODczMzYwOCwKICAgICAgICA3MzMyMzk5NTQsCiAgICAgICAgMTU1NTI2MTk1NiwKICAgICAgICAzMjY4OTM1NTkxLAogICAgICAgIDMwNTAzNjA2MjUsCiAgICAgICAgNzUyNDU5NDAzLAogICAgICAgIDE1NDEzMjAyMjEsCiAgICAgICAgMjYwNzA3MTkyMCwKICAgICAgICAzOTY1OTczMDMwLAogICAgICAgIDE5Njk5MjI5NzIsCiAgICAgICAgNDA3MzU0OTgsCiAgICAgICAgMjYxNzgzNzIyNSwKICAgICAgICAzOTQzNTc3MTUxLAogICAgICAgIDE5MTMwODc4NzcsCiAgICAgICAgODM5MDgzNzEsCiAgICAgICAgMjUxMjM0MTYzNCwKICAgICAgICAzODAzNzQwNjkyLAogICAgICAgIDIwNzUyMDg2MjIsCiAgICAgICAgMjEzMjYxMTEyLAogICAgICAgIDI0NjMyNzI2MDMsCiAgICAgICAgMzg1NTk5MDI4NSwKICAgICAgICAyMDk0ODU0MDcxLAogICAgICAgIDE5ODk1ODg4MSwKICAgICAgICAyMjYyMDI5MDEyLAogICAgICAgIDQwNTcyNjA2MTAsCiAgICAgICAgMTc1OTM1OTk5MiwKICAgICAgICA1MzQ0MTQxOTAsCiAgICAgICAgMjE3NjcxODU0MSwKICAgICAgICA0MTM5MzI5MTE1LAogICAgICAgIDE4NzM4MzYwMDEsCiAgICAgICAgNDE0NjY0NTY3LAogICAgICAgIDIyODIyNDg5MzQsCiAgICAgICAgNDI3OTIwMDM2OCwKICAgICAgICAxNzExNjg0NTU0LAogICAgICAgIDI4NTI4MTExNiwKICAgICAgICAyNDA1ODAxNzI3LAogICAgICAgIDQxNjcyMTY3NDUsCiAgICAgICAgMTYzNDQ2Nzc5NSwKICAgICAgICAzNzYyMjk3MDEsCiAgICAgICAgMjY4NTA2Nzg5NiwKICAgICAgICAzNjA4MDA3NDA2LAogICAgICAgIDEzMDg5MTg2MTIsCiAgICAgICAgOTU2NTQzOTM4LAogICAgICAgIDI4MDg1NTUxMDUsCiAgICAgICAgMzQ5NTk1ODI2MywKICAgICAgICAxMjMxNjM2MzAxLAogICAgICAgIDEwNDc0MjcwMzUsCiAgICAgICAgMjkzMjk1OTgxOCwKICAgICAgICAzNjU0NzAzODM2LAogICAgICAgIDEwODgzNTkyNzAsCiAgICAgICAgOTM2OTE4ZTMsCiAgICAgICAgMjg0NzcxNDg5OSwKICAgICAgICAzNzM2ODM3ODI5LAogICAgICAgIDEyMDI5MDA4NjMsCiAgICAgICAgODE3MjMzODk3LAogICAgICAgIDMxODMzNDIxMDgsCiAgICAgICAgMzQwMTIzNzEzMCwKICAgICAgICAxNDA0Mjc3NTUyLAogICAgICAgIDYxNTgxODE1MCwKICAgICAgICAzMTM0MjA3NDkzLAogICAgICAgIDM0NTM0MjEyMDMsCiAgICAgICAgMTQyMzg1NzQ0OSwKICAgICAgICA2MDE0NTA0MzEsCiAgICAgICAgMzAwOTgzNzYxNCwKICAgICAgICAzMjk0NzEwNDU2LAogICAgICAgIDE1NjcxMDM3NDYsCiAgICAgICAgNzExOTI4NzI0LAogICAgICAgIDMwMjA2Njg0NzEsCiAgICAgICAgMzI3MjM4MDA2NSwKICAgICAgICAxNTEwMzM0MjM1LAogICAgICAgIDc1NTE2NzExNwogICAgICBdOwogICAgICBpZiAodHlwZW9mIEludDMyQXJyYXkgIT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgQ1JDX1RBQkxFID0gbmV3IEludDMyQXJyYXkoQ1JDX1RBQkxFKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBlbnN1cmVCdWZmZXIoaW5wdXQpIHsKICAgICAgICBpZiAoQnVmZmVyMy5pc0J1ZmZlcihpbnB1dCkpIHsKICAgICAgICAgIHJldHVybiBpbnB1dDsKICAgICAgICB9CiAgICAgICAgdmFyIGhhc05ld0J1ZmZlckFQSSA9IHR5cGVvZiBCdWZmZXIzLmFsbG9jID09PSAiZnVuY3Rpb24iICYmIHR5cGVvZiBCdWZmZXIzLmZyb20gPT09ICJmdW5jdGlvbiI7CiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gIm51bWJlciIpIHsKICAgICAgICAgIHJldHVybiBoYXNOZXdCdWZmZXJBUEkgPyBCdWZmZXIzLmFsbG9jKGlucHV0KSA6IG5ldyBCdWZmZXIzKGlucHV0KTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgIHJldHVybiBoYXNOZXdCdWZmZXJBUEkgPyBCdWZmZXIzLmZyb20oaW5wdXQpIDogbmV3IEJ1ZmZlcjMoaW5wdXQpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImlucHV0IG11c3QgYmUgYnVmZmVyLCBudW1iZXIsIG9yIHN0cmluZywgcmVjZWl2ZWQgIiArIHR5cGVvZiBpbnB1dCk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJ1ZmZlcml6ZUludChudW0pIHsKICAgICAgICB2YXIgdG1wID0gZW5zdXJlQnVmZmVyKDQpOwogICAgICAgIHRtcC53cml0ZUludDMyQkUobnVtLCAwKTsKICAgICAgICByZXR1cm4gdG1wOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9jcmMzMihidWYsIHByZXZpb3VzKSB7CiAgICAgICAgYnVmID0gZW5zdXJlQnVmZmVyKGJ1Zik7CiAgICAgICAgaWYgKEJ1ZmZlcjMuaXNCdWZmZXIocHJldmlvdXMpKSB7CiAgICAgICAgICBwcmV2aW91cyA9IHByZXZpb3VzLnJlYWRVSW50MzJCRSgwKTsKICAgICAgICB9CiAgICAgICAgdmFyIGNyYyA9IH5+cHJldmlvdXMgXiAtMTsKICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGJ1Zi5sZW5ndGg7IG4rKykgewogICAgICAgICAgY3JjID0gQ1JDX1RBQkxFWyhjcmMgXiBidWZbbl0pICYgMjU1XSBeIGNyYyA+Pj4gODsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGNyYyBeIC0xOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNyYzMyKCkgewogICAgICAgIHJldHVybiBidWZmZXJpemVJbnQoX2NyYzMyLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpOwogICAgICB9CiAgICAgIGNyYzMyLnNpZ25lZCA9IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiBfY3JjMzIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsKICAgICAgfTsKICAgICAgY3JjMzIudW5zaWduZWQgPSBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gX2NyYzMyLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgPj4+IDA7CiAgICAgIH07CiAgICAgIG1vZHVsZS5leHBvcnRzID0gY3JjMzI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9vYmplY3QuZW50cmllcy1wb255ZmlsbC9lbnRyaWVzLmpzCiAgdmFyIHJlcXVpcmVfZW50cmllcyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9vYmplY3QuZW50cmllcy1wb255ZmlsbC9lbnRyaWVzLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBoYXMgPSBmdW5jdGlvbihvYmosIHByb3ApIHsKICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7CiAgICAgIH07CiAgICAgIHZhciBpc0VudW1lcmFibGUgPSBmdW5jdGlvbihvYmosIHByb3ApIHsKICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwgcHJvcCk7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGVudHJpZXMob2JqKSB7CiAgICAgICAgaWYgKG9iaiA9PSBudWxsKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QiKTsKICAgICAgICB9CiAgICAgICAgdmFyIHBhaXJzID0gW107CiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikgewogICAgICAgICAgaWYgKGhhcyhvYmosIGtleSkgJiYgaXNFbnVtZXJhYmxlKG9iaiwga2V5KSkgewogICAgICAgICAgICBwYWlycy5wdXNoKFtrZXksIG9ialtrZXldXSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBwYWlyczsKICAgICAgfQogICAgICBtb2R1bGUuZXhwb3J0cyA9IGVudHJpZXM7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9vYmplY3QuZW50cmllcy1wb255ZmlsbC9pbmRleC5qcwogIHZhciByZXF1aXJlX29iamVjdCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9vYmplY3QuZW50cmllcy1wb255ZmlsbC9pbmRleC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgT2JqZWN0LmVudHJpZXMgPT09ICJmdW5jdGlvbiIgPyBPYmplY3QuZW50cmllcyA6IHJlcXVpcmVfZW50cmllcygpOwogICAgfQogIH0pOwoKICAvLyAoZGlzYWJsZWQpOm5vZGVfbW9kdWxlcy9nZW5lcmljLWZpbGVoYW5kbGUvZGlzdC9sb2NhbEZpbGUKICB2YXIgcmVxdWlyZV9sb2NhbEZpbGUyID0gX19jb21tb25KUyh7CiAgICAiKGRpc2FibGVkKTpub2RlX21vZHVsZXMvZ2VuZXJpYy1maWxlaGFuZGxlL2Rpc3QvbG9jYWxGaWxlIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgfQogIH0pOwoKICAvLyAoZGlzYWJsZWQpOm5vZGVfbW9kdWxlcy9maWxlLXVyaS10by1wYXRoL2Rpc3Qvc3JjL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfc3JjID0gX19jb21tb25KUyh7CiAgICAiKGRpc2FibGVkKTpub2RlX21vZHVsZXMvZmlsZS11cmktdG8tcGF0aC9kaXN0L3NyYy9pbmRleC5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2dlbmVyaWMtZmlsZWhhbmRsZS9kaXN0L3JlbW90ZUZpbGUuanMKICB2YXIgcmVxdWlyZV9yZW1vdGVGaWxlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2dlbmVyaWMtZmlsZWhhbmRsZS9kaXN0L3JlbW90ZUZpbGUuanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZV9pbnRlcm9wUmVxdWlyZURlZmF1bHQyKCk7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAiX19lc01vZHVsZSIsIHsKICAgICAgICB2YWx1ZTogdHJ1ZQogICAgICB9KTsKICAgICAgZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwOwogICAgICB2YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3JlZ2VuZXJhdG9yMigpKTsKICAgICAgdmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9hc3luY1RvR2VuZXJhdG9yMigpKTsKICAgICAgdmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfY2xhc3NDYWxsQ2hlY2syKCkpOwogICAgICB2YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9jcmVhdGVDbGFzczIoKSk7CiAgICAgIHZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2RlZmluZVByb3BlcnR5MigpKTsKICAgICAgdmFyIF9maWxlVXJpVG9QYXRoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3NyYygpKTsKICAgICAgdmFyIF8gPSByZXF1aXJlX2Rpc3QzKCk7CiAgICAgIGZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgewogICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsKICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgewogICAgICAgICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7CiAgICAgICAgICBpZiAoZW51bWVyYWJsZU9ubHkpCiAgICAgICAgICAgIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbihzeW0pIHsKICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBrZXlzOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7CiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OwogICAgICAgICAgaWYgKGkgJSAyKSB7CiAgICAgICAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7CiAgICAgICAgICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7CiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkgewogICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRhcmdldDsKICAgICAgfQogICAgICB2YXIgbXlHbG9iYWwgPSB0eXBlb2Ygd2luZG93ICE9PSAidW5kZWZpbmVkIiA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiA/IHNlbGYgOiB7CiAgICAgICAgZmV0Y2g6IHZvaWQgMAogICAgICB9OwogICAgICB2YXIgUmVtb3RlRmlsZTIgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7CiAgICAgICAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoUmVtb3RlRmlsZTMsIFt7CiAgICAgICAgICBrZXk6ICJnZXRCdWZmZXJGcm9tUmVzcG9uc2UiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgX2dldEJ1ZmZlckZyb21SZXNwb25zZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShyZXNwb25zZSkgewogICAgICAgICAgICAgIHZhciByZXNwOwogICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7CiAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHlwZW9mIHJlc3BvbnNlLmJ1ZmZlciA9PT0gImZ1bmN0aW9uIikpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgicmV0dXJuIiwgcmVzcG9uc2UuYnVmZmVyKCkpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgNDoKICAgICAgICAgICAgICAgICAgICAgIGlmICghKHR5cGVvZiByZXNwb25zZS5hcnJheUJ1ZmZlciA9PT0gImZ1bmN0aW9uIikpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3OwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OgogICAgICAgICAgICAgICAgICAgICAgcmVzcCA9IF9jb250ZXh0LnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCJyZXR1cm4iLCBpbXBvcnRfYnVmZmVyLkJ1ZmZlci5mcm9tKHJlc3ApKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDExOgogICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiaW52YWxpZCBIVFRQIHJlc3BvbnNlIG9iamVjdCwgaGFzIG5vIGJ1ZmZlciBtZXRob2QsIGFuZCBubyBhcnJheUJ1ZmZlciBtZXRob2QiKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOgogICAgICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSwgX2NhbGxlZSk7CiAgICAgICAgICAgIH0pKTsKICAgICAgICAgICAgZnVuY3Rpb24gZ2V0QnVmZmVyRnJvbVJlc3BvbnNlKF94KSB7CiAgICAgICAgICAgICAgcmV0dXJuIF9nZXRCdWZmZXJGcm9tUmVzcG9uc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gZ2V0QnVmZmVyRnJvbVJlc3BvbnNlOwogICAgICAgICAgfSgpCiAgICAgICAgfV0pOwogICAgICAgIGZ1bmN0aW9uIFJlbW90ZUZpbGUzKHNvdXJjZSkgewogICAgICAgICAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IHt9OwogICAgICAgICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgUmVtb3RlRmlsZTMpOwogICAgICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgInVybCIsIHZvaWQgMCk7CiAgICAgICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCAiX3N0YXQiLCB2b2lkIDApOwogICAgICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgImZldGNoSW1wbGVtZW50YXRpb24iLCB2b2lkIDApOwogICAgICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgImJhc2VPdmVycmlkZXMiLCB7fSk7CiAgICAgICAgICB0aGlzLnVybCA9IHNvdXJjZTsKICAgICAgICAgIGlmIChzb3VyY2Uuc3RhcnRzV2l0aCgiZmlsZTovLyIpKSB7CiAgICAgICAgICAgIHZhciBwYXRoID0gKDAsIF9maWxlVXJpVG9QYXRoLmRlZmF1bHQpKHNvdXJjZSk7CiAgICAgICAgICAgIGlmICghcGF0aCkgewogICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImludmFsaWQgZmlsZSB1cmwiKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgbG9jYWxGaWxlID0gbmV3IF8uTG9jYWxGaWxlKHBhdGgpOwogICAgICAgICAgICB0aGlzLnJlYWQgPSBsb2NhbEZpbGUucmVhZC5iaW5kKGxvY2FsRmlsZSk7CiAgICAgICAgICAgIHRoaXMucmVhZEZpbGUgPSBsb2NhbEZpbGUucmVhZEZpbGUuYmluZChsb2NhbEZpbGUpOwogICAgICAgICAgICB0aGlzLnN0YXQgPSBsb2NhbEZpbGUuc3RhdC5iaW5kKGxvY2FsRmlsZSk7CiAgICAgICAgICAgIHRoaXMuZmV0Y2hJbXBsZW1lbnRhdGlvbiA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB9OwogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgZmV0Y2gyID0gb3B0cy5mZXRjaCB8fCBteUdsb2JhbC5mZXRjaCAmJiBteUdsb2JhbC5mZXRjaC5iaW5kKG15R2xvYmFsKTsKICAgICAgICAgIGlmICghZmV0Y2gyKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIm5vIGZldGNoIGZ1bmN0aW9uIHN1cHBsaWVkLCBhbmQgbm9uZSBmb3VuZCBpbiBnbG9iYWwgZW52aXJvbm1lbnQiKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChvcHRzLm92ZXJyaWRlcykgewogICAgICAgICAgICB0aGlzLmJhc2VPdmVycmlkZXMgPSBvcHRzLm92ZXJyaWRlczsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXMuZmV0Y2hJbXBsZW1lbnRhdGlvbiA9IGZldGNoMjsKICAgICAgICB9CiAgICAgICAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoUmVtb3RlRmlsZTMsIFt7CiAgICAgICAgICBrZXk6ICJmZXRjaCIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciBfZmV0Y2ggPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKC8qIEBfX1BVUkVfXyAqLyBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGlucHV0LCBpbml0MikgewogICAgICAgICAgICAgIHZhciByZXNwb25zZTsKICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7CiAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHsKICAgICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDA7CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDM7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEltcGxlbWVudGF0aW9uKGlucHV0LCBpbml0Mik7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOgogICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfY29udGV4dDIuc2VudDsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTY7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICBjYXNlIDY6CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDY7CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbImNhdGNoIl0oMCk7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfY29udGV4dDIudDAubWVzc2FnZSA9PT0gIkZhaWxlZCB0byBmZXRjaCIpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTU7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCJnZW5lcmljLWZpbGVoYW5kbGU6IHJlZmV0Y2hpbmcgIi5jb25jYXQoaW5wdXQsICIgdG8gYXR0ZW1wdCB0byB3b3JrIGFyb3VuZCBjaHJvbWUgQ09SUyBoZWFkZXIgY2FjaGluZyBidWciKSk7CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEyOwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hJbXBsZW1lbnRhdGlvbihpbnB1dCwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBpbml0MiksIHt9LCB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiAicmVsb2FkIgogICAgICAgICAgICAgICAgICAgICAgfSkpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6CiAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0Mi5zZW50OwogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNjsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6CiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDIudDA7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNjoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KCJyZXR1cm4iLCByZXNwb25zZSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNzoKICAgICAgICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcywgW1swLCA2XV0pOwogICAgICAgICAgICB9KSk7CiAgICAgICAgICAgIGZ1bmN0aW9uIGZldGNoMihfeDIsIF94MykgewogICAgICAgICAgICAgIHJldHVybiBfZmV0Y2guYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gZmV0Y2gyOwogICAgICAgICAgfSgpCiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAicmVhZCIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciBfcmVhZCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoYnVmZmVyKSB7CiAgICAgICAgICAgICAgdmFyIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgb3B0cywgX29wdHMkaGVhZGVycywgaGVhZGVycywgc2lnbmFsLCBfb3B0cyRvdmVycmlkZXMsIG92ZXJyaWRlcywgYXJncywgcmVzcG9uc2UsIHJlc3BvbnNlRGF0YSwgYnl0ZXNDb3BpZWQsIHJlcywgc2l6ZU1hdGNoLCBfYXJnczMgPSBhcmd1bWVudHM7CiAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0MykgewogICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gX2FyZ3MzLmxlbmd0aCA+IDEgJiYgX2FyZ3MzWzFdICE9PSB2b2lkIDAgPyBfYXJnczNbMV0gOiAwOwogICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gX2FyZ3MzLmxlbmd0aCA+IDIgPyBfYXJnczNbMl0gOiB2b2lkIDA7CiAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IF9hcmdzMy5sZW5ndGggPiAzICYmIF9hcmdzM1szXSAhPT0gdm9pZCAwID8gX2FyZ3MzWzNdIDogMDsKICAgICAgICAgICAgICAgICAgICAgIG9wdHMgPSBfYXJnczMubGVuZ3RoID4gNCAmJiBfYXJnczNbNF0gIT09IHZvaWQgMCA/IF9hcmdzM1s0XSA6IHt9OwogICAgICAgICAgICAgICAgICAgICAgX29wdHMkaGVhZGVycyA9IG9wdHMuaGVhZGVycywgaGVhZGVycyA9IF9vcHRzJGhlYWRlcnMgPT09IHZvaWQgMCA/IHt9IDogX29wdHMkaGVhZGVycywgc2lnbmFsID0gb3B0cy5zaWduYWwsIF9vcHRzJG92ZXJyaWRlcyA9IG9wdHMub3ZlcnJpZGVzLCBvdmVycmlkZXMgPSBfb3B0cyRvdmVycmlkZXMgPT09IHZvaWQgMCA/IHt9IDogX29wdHMkb3ZlcnJpZGVzOwogICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA8IEluZmluaXR5KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnMucmFuZ2UgPSAiYnl0ZXM9Ii5jb25jYXQocG9zaXRpb24sICItIikuY29uY2F0KHBvc2l0aW9uICsgbGVuZ3RoKTsKICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID09PSBJbmZpbml0eSAmJiBwb3NpdGlvbiAhPT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLnJhbmdlID0gImJ5dGVzPSIuY29uY2F0KHBvc2l0aW9uLCAiLSIpOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgYXJncyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLmJhc2VPdmVycmlkZXMpLCBvdmVycmlkZXMpLCB7fSwgewogICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaGVhZGVycyksIG92ZXJyaWRlcy5oZWFkZXJzKSwgdGhpcy5iYXNlT3ZlcnJpZGVzLmhlYWRlcnMpLAogICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICJHRVQiLAogICAgICAgICAgICAgICAgICAgICAgICByZWRpcmVjdDogImZvbGxvdyIsCiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6ICJjb3JzIiwKICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsCiAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gOTsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKHRoaXMudXJsLCBhcmdzKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDk6CiAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0My5zZW50OwogICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTI7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJIVFRQICIuY29uY2F0KHJlc3BvbnNlLnN0YXR1cywgIiAiKS5jb25jYXQocmVzcG9uc2Uuc3RhdHVzVGV4dCkpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZXNwb25zZS5zdGF0dXMgPT09IDIwMCAmJiBwb3NpdGlvbiA9PT0gMCB8fCByZXNwb25zZS5zdGF0dXMgPT09IDIwNikpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAyMTsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE1OwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyRnJvbVJlc3BvbnNlKHJlc3BvbnNlKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OgogICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VEYXRhID0gX2NvbnRleHQzLnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgICBieXRlc0NvcGllZCA9IHJlc3BvbnNlRGF0YS5jb3B5KGJ1ZmZlciwgb2Zmc2V0LCAwLCBNYXRoLm1pbihsZW5ndGgsIHJlc3BvbnNlRGF0YS5sZW5ndGgpKTsKICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCJjb250ZW50LXJhbmdlIik7CiAgICAgICAgICAgICAgICAgICAgICBzaXplTWF0Y2ggPSAvXC8oXGQrKSQvLmV4ZWMocmVzIHx8ICIiKTsKICAgICAgICAgICAgICAgICAgICAgIGlmIChzaXplTWF0Y2ggJiYgc2l6ZU1hdGNoWzFdKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXQgPSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogcGFyc2VJbnQoc2l6ZU1hdGNoWzFdLCAxMCkKICAgICAgICAgICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KCJyZXR1cm4iLCB7CiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzUmVhZDogYnl0ZXNDb3BpZWQsCiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcgogICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMToKICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDIzOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiJHt0aGlzLnVybH0gZmV0Y2ggcmV0dXJuZWQgc3RhdHVzIDIwMCwgZXhwZWN0ZWQgMjA2Iik7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzoKICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiSFRUUCAiLmNvbmNhdChyZXNwb25zZS5zdGF0dXMsICIgZmV0Y2hpbmcgIikuY29uY2F0KHRoaXMudXJsKSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAyNDoKICAgICAgICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9LCBfY2FsbGVlMywgdGhpcyk7CiAgICAgICAgICAgIH0pKTsKICAgICAgICAgICAgZnVuY3Rpb24gcmVhZChfeDQpIHsKICAgICAgICAgICAgICByZXR1cm4gX3JlYWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gcmVhZDsKICAgICAgICAgIH0oKQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogInJlYWRGaWxlIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgdmFyIF9yZWFkRmlsZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoKSB7CiAgICAgICAgICAgICAgdmFyIG9wdGlvbnMsIGVuY29kaW5nLCBvcHRzLCBfb3B0cywgX29wdHMkaGVhZGVyczIsIGhlYWRlcnMsIHNpZ25hbCwgX29wdHMkb3ZlcnJpZGVzMiwgb3ZlcnJpZGVzLCBhcmdzLCByZXNwb25zZSwgX2FyZ3M0ID0gYXJndW1lbnRzOwogICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHsKICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkgewogICAgICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBfYXJnczQubGVuZ3RoID4gMCAmJiBfYXJnczRbMF0gIT09IHZvaWQgMCA/IF9hcmdzNFswXSA6IHt9OwogICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAic3RyaW5nIikgewogICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZyA9IG9wdGlvbnM7CiAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMgPSB7fTsKICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZzsKICAgICAgICAgICAgICAgICAgICAgICAgb3B0cyA9IG9wdGlvbnM7CiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRzLmVuY29kaW5nOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgX29wdHMgPSBvcHRzLCBfb3B0cyRoZWFkZXJzMiA9IF9vcHRzLmhlYWRlcnMsIGhlYWRlcnMgPSBfb3B0cyRoZWFkZXJzMiA9PT0gdm9pZCAwID8ge30gOiBfb3B0cyRoZWFkZXJzMiwgc2lnbmFsID0gX29wdHMuc2lnbmFsLCBfb3B0cyRvdmVycmlkZXMyID0gX29wdHMub3ZlcnJpZGVzLCBvdmVycmlkZXMgPSBfb3B0cyRvdmVycmlkZXMyID09PSB2b2lkIDAgPyB7fSA6IF9vcHRzJG92ZXJyaWRlczI7CiAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHsKICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVycywKICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAiR0VUIiwKICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3Q6ICJmb2xsb3ciLAogICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiAiY29ycyIsCiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbAogICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5iYXNlT3ZlcnJpZGVzKSwgb3ZlcnJpZGVzKTsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNjsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKHRoaXMudXJsLCBhcmdzKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDY6CiAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0NC5zZW50OwogICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gOTsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImdlbmVyaWMtZmlsZWhhbmRsZSBmYWlsZWQgdG8gZmV0Y2giKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDk6CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxMTsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBFcnJvcigiSFRUUCAiLmNvbmNhdChyZXNwb25zZS5zdGF0dXMsICIgZmV0Y2hpbmcgIikuY29uY2F0KHRoaXMudXJsKSksIHsKICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMKICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIShlbmNvZGluZyA9PT0gInV0ZjgiKSkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDEzOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KCJyZXR1cm4iLCByZXNwb25zZS50ZXh0KCkpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVuY29kaW5nKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTU7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJ1bnN1cHBvcnRlZCBlbmNvZGluZzogIi5jb25jYXQoZW5jb2RpbmcpKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoInJldHVybiIsIHRoaXMuZ2V0QnVmZmVyRnJvbVJlc3BvbnNlKHJlc3BvbnNlKSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNjoKICAgICAgICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9LCBfY2FsbGVlNCwgdGhpcyk7CiAgICAgICAgICAgIH0pKTsKICAgICAgICAgICAgZnVuY3Rpb24gcmVhZEZpbGUoKSB7CiAgICAgICAgICAgICAgcmV0dXJuIF9yZWFkRmlsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiByZWFkRmlsZTsKICAgICAgICAgIH0oKQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogInN0YXQiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgX3N0YXQgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKC8qIEBfX1BVUkVfXyAqLyBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KCkgewogICAgICAgICAgICAgIHZhciBidWY7CiAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkgewogICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA2OwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGJ1ZiA9IGltcG9ydF9idWZmZXIuQnVmZmVyLmFsbG9jVW5zYWZlKDEwKTsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNDsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWQoYnVmLCAwLCAxMCwgMCk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OgogICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA2OwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigidW5hYmxlIHRvIGRldGVybWluZSBzaXplIG9mIGZpbGUgYXQgIi5jb25jYXQodGhpcy51cmwpKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDY6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdCgicmV0dXJuIiwgdGhpcy5fc3RhdCk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OgogICAgICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0sIF9jYWxsZWU1LCB0aGlzKTsKICAgICAgICAgICAgfSkpOwogICAgICAgICAgICBmdW5jdGlvbiBzdGF0KCkgewogICAgICAgICAgICAgIHJldHVybiBfc3RhdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBzdGF0OwogICAgICAgICAgfSgpCiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiY2xvc2UiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgX2Nsb3NlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KSgvKiBAX19QVVJFX18gKi8gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlNigpIHsKICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7CiAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHsKICAgICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdCgicmV0dXJuIik7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0sIF9jYWxsZWU2KTsKICAgICAgICAgICAgfSkpOwogICAgICAgICAgICBmdW5jdGlvbiBjbG9zZSgpIHsKICAgICAgICAgICAgICByZXR1cm4gX2Nsb3NlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGNsb3NlOwogICAgICAgICAgfSgpCiAgICAgICAgfV0pOwogICAgICAgIHJldHVybiBSZW1vdGVGaWxlMzsKICAgICAgfSgpOwogICAgICBleHBvcnRzLmRlZmF1bHQgPSBSZW1vdGVGaWxlMjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2dlbmVyaWMtZmlsZWhhbmRsZS9kaXN0L2Jsb2JGaWxlLmpzCiAgdmFyIHJlcXVpcmVfYmxvYkZpbGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvZ2VuZXJpYy1maWxlaGFuZGxlL2Rpc3QvYmxvYkZpbGUuanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZV9pbnRlcm9wUmVxdWlyZURlZmF1bHQyKCk7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAiX19lc01vZHVsZSIsIHsKICAgICAgICB2YWx1ZTogdHJ1ZQogICAgICB9KTsKICAgICAgZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwOwogICAgICB2YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3JlZ2VuZXJhdG9yMigpKTsKICAgICAgdmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9hc3luY1RvR2VuZXJhdG9yMigpKTsKICAgICAgdmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfY2xhc3NDYWxsQ2hlY2syKCkpOwogICAgICB2YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9jcmVhdGVDbGFzczIoKSk7CiAgICAgIHZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2RlZmluZVByb3BlcnR5MigpKTsKICAgICAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHsKICAgICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7CiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkgewogICAgICAgICAgZmlsZVJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIGZpbGVSZWFkZXIuYWJvcnQoKTsKICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcigicHJvYmxlbSByZWFkaW5nIGJsb2IiKSk7CiAgICAgICAgICB9OwogICAgICAgICAgZmlsZVJlYWRlci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoImJsb2IgcmVhZGluZyB3YXMgYWJvcnRlZCIpKTsKICAgICAgICAgIH07CiAgICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICBpZiAoZmlsZVJlYWRlci5yZXN1bHQgJiYgdHlwZW9mIGZpbGVSZWFkZXIucmVzdWx0ICE9PSAic3RyaW5nIikgewogICAgICAgICAgICAgIHJlc29sdmUoZmlsZVJlYWRlci5yZXN1bHQpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoInVua25vd24gZXJyb3IgcmVhZGluZyBibG9iIikpOwogICAgICAgICAgICB9CiAgICAgICAgICB9OwogICAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTsKICAgICAgICB9KTsKICAgICAgfQogICAgICBmdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7CiAgICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpOwogICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHsKICAgICAgICAgIGZpbGVSZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICBmaWxlUmVhZGVyLmFib3J0KCk7CiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoInByb2JsZW0gcmVhZGluZyBibG9iIikpOwogICAgICAgICAgfTsKICAgICAgICAgIGZpbGVSZWFkZXIub25hYm9ydCA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCJibG9iIHJlYWRpbmcgd2FzIGFib3J0ZWQiKSk7CiAgICAgICAgICB9OwogICAgICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgaWYgKGZpbGVSZWFkZXIucmVzdWx0ICYmIHR5cGVvZiBmaWxlUmVhZGVyLnJlc3VsdCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgICByZXNvbHZlKGZpbGVSZWFkZXIucmVzdWx0KTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCJ1bmtub3duIGVycm9yIHJlYWRpbmcgYmxvYiIpKTsKICAgICAgICAgICAgfQogICAgICAgICAgfTsKICAgICAgICAgIGZpbGVSZWFkZXIucmVhZEFzVGV4dChibG9iKTsKICAgICAgICB9KTsKICAgICAgfQogICAgICB2YXIgQmxvYkZpbGUgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7CiAgICAgICAgZnVuY3Rpb24gQmxvYkZpbGUyKGJsb2IpIHsKICAgICAgICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEJsb2JGaWxlMik7CiAgICAgICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCAiYmxvYiIsIHZvaWQgMCk7CiAgICAgICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCAic2l6ZSIsIHZvaWQgMCk7CiAgICAgICAgICB0aGlzLmJsb2IgPSBibG9iOwogICAgICAgICAgdGhpcy5zaXplID0gYmxvYi5zaXplOwogICAgICAgIH0KICAgICAgICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShCbG9iRmlsZTIsIFt7CiAgICAgICAgICBrZXk6ICJyZWFkIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgdmFyIF9yZWFkID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KSgvKiBAX19QVVJFX18gKi8gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKGJ1ZmZlcikgewogICAgICAgICAgICAgIHZhciBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIHN0YXJ0LCBlbmQsIHJlc3VsdCwgcmVzdWx0QnVmZmVyLCBieXRlc0NvcGllZCwgX2FyZ3MgPSBhcmd1bWVudHM7CiAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHsKICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHsKICAgICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBfYXJncy5sZW5ndGggPiAxICYmIF9hcmdzWzFdICE9PSB2b2lkIDAgPyBfYXJnc1sxXSA6IDA7CiAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBfYXJncy5sZW5ndGggPiAyID8gX2FyZ3NbMl0gOiB2b2lkIDA7CiAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IF9hcmdzLmxlbmd0aCA+IDMgJiYgX2FyZ3NbM10gIT09IHZvaWQgMCA/IF9hcmdzWzNdIDogMDsKICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgicmV0dXJuIiwgewogICAgICAgICAgICAgICAgICAgICAgICBieXRlc1JlYWQ6IDAsCiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcgogICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OgogICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBwb3NpdGlvbjsKICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHN0YXJ0ICsgbGVuZ3RoOwogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZEJsb2JBc0FycmF5QnVmZmVyKHRoaXMuYmxvYi5zbGljZShzdGFydCwgZW5kKSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OgogICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQuc2VudDsKICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdEJ1ZmZlciA9IGltcG9ydF9idWZmZXIuQnVmZmVyLmZyb20ocmVzdWx0KTsKICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzQ29waWVkID0gcmVzdWx0QnVmZmVyLmNvcHkoYnVmZmVyLCBvZmZzZXQpOwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgicmV0dXJuIiwgewogICAgICAgICAgICAgICAgICAgICAgICBieXRlc1JlYWQ6IGJ5dGVzQ29waWVkLAogICAgICAgICAgICAgICAgICAgICAgICBidWZmZXI6IHJlc3VsdEJ1ZmZlcgogICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzoKICAgICAgICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpOwogICAgICAgICAgICB9KSk7CiAgICAgICAgICAgIGZ1bmN0aW9uIHJlYWQoX3gpIHsKICAgICAgICAgICAgICByZXR1cm4gX3JlYWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gcmVhZDsKICAgICAgICAgIH0oKQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogInJlYWRGaWxlIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgdmFyIF9yZWFkRmlsZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIob3B0aW9ucykgewogICAgICAgICAgICAgIHZhciBlbmNvZGluZywgcmVzdWx0OwogICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHsKICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkgewogICAgICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RpbmcgPSBvcHRpb25zOwogICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RpbmcgPSBvcHRpb25zICYmIG9wdGlvbnMuZW5jb2Rpbmc7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIShlbmNvZGluZyA9PT0gInV0ZjgiKSkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDM7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoInJldHVybiIsIHJlYWRCbG9iQXNUZXh0KHRoaXMuYmxvYikpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMzoKICAgICAgICAgICAgICAgICAgICAgIGlmICghZW5jb2RpbmcpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA1OwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigidW5zdXBwb3J0ZWQgZW5jb2Rpbmc6ICIuY29uY2F0KGVuY29kaW5nKSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OgogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA3OwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcih0aGlzLmJsb2IpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgNzoKICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0Mi5zZW50OwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoInJldHVybiIsIGltcG9ydF9idWZmZXIuQnVmZmVyLmZyb20ocmVzdWx0KSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OgogICAgICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTsKICAgICAgICAgICAgfSkpOwogICAgICAgICAgICBmdW5jdGlvbiByZWFkRmlsZShfeDIpIHsKICAgICAgICAgICAgICByZXR1cm4gX3JlYWRGaWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHJlYWRGaWxlOwogICAgICAgICAgfSgpCiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAic3RhdCIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciBfc3RhdCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoKSB7CiAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0MykgewogICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoInJldHVybiIsIHsKICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogdGhpcy5zaXplCiAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDE6CiAgICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSwgX2NhbGxlZTMsIHRoaXMpOwogICAgICAgICAgICB9KSk7CiAgICAgICAgICAgIGZ1bmN0aW9uIHN0YXQoKSB7CiAgICAgICAgICAgICAgcmV0dXJuIF9zdGF0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHN0YXQ7CiAgICAgICAgICB9KCkKICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJjbG9zZSIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciBfY2xvc2UgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKC8qIEBfX1BVUkVfXyAqLyBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KCkgewogICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHsKICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkgewogICAgICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KCJyZXR1cm4iKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDE6CiAgICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSwgX2NhbGxlZTQpOwogICAgICAgICAgICB9KSk7CiAgICAgICAgICAgIGZ1bmN0aW9uIGNsb3NlKCkgewogICAgICAgICAgICAgIHJldHVybiBfY2xvc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gY2xvc2U7CiAgICAgICAgICB9KCkKICAgICAgICB9XSk7CiAgICAgICAgcmV0dXJuIEJsb2JGaWxlMjsKICAgICAgfSgpOwogICAgICBleHBvcnRzLmRlZmF1bHQgPSBCbG9iRmlsZTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2dlbmVyaWMtZmlsZWhhbmRsZS9kaXN0L2ZpbGVoYW5kbGUuanMKICB2YXIgcmVxdWlyZV9maWxlaGFuZGxlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2dlbmVyaWMtZmlsZWhhbmRsZS9kaXN0L2ZpbGVoYW5kbGUuanMiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2dlbmVyaWMtZmlsZWhhbmRsZS9kaXN0L2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfZGlzdDMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvZ2VuZXJpYy1maWxlaGFuZGxlL2Rpc3QvaW5kZXguanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZV9pbnRlcm9wUmVxdWlyZURlZmF1bHQyKCk7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAiX19lc01vZHVsZSIsIHsKICAgICAgICB2YWx1ZTogdHJ1ZQogICAgICB9KTsKICAgICAgdmFyIF9leHBvcnROYW1lcyA9IHsKICAgICAgICBvcGVuOiB0cnVlLAogICAgICAgIGZyb21Vcmw6IHRydWUsCiAgICAgICAgTG9jYWxGaWxlOiB0cnVlLAogICAgICAgIFJlbW90ZUZpbGU6IHRydWUsCiAgICAgICAgQmxvYkZpbGU6IHRydWUKICAgICAgfTsKICAgICAgZXhwb3J0cy5vcGVuID0gb3BlbjsKICAgICAgZXhwb3J0cy5mcm9tVXJsID0gZnJvbVVybDsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJMb2NhbEZpbGUiLCB7CiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgICAgIHJldHVybiBfbG9jYWxGaWxlLmRlZmF1bHQ7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJSZW1vdGVGaWxlIiwgewogICAgICAgIGVudW1lcmFibGU6IHRydWUsCiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICByZXR1cm4gX3JlbW90ZUZpbGUuZGVmYXVsdDsKICAgICAgICB9CiAgICAgIH0pOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgIkJsb2JGaWxlIiwgewogICAgICAgIGVudW1lcmFibGU6IHRydWUsCiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICByZXR1cm4gX2Jsb2JGaWxlLmRlZmF1bHQ7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgdmFyIF9sb2NhbEZpbGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfbG9jYWxGaWxlMigpKTsKICAgICAgdmFyIF9yZW1vdGVGaWxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3JlbW90ZUZpbGUoKSk7CiAgICAgIHZhciBfYmxvYkZpbGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfYmxvYkZpbGUoKSk7CiAgICAgIHZhciBfZmlsZWhhbmRsZSA9IHJlcXVpcmVfZmlsZWhhbmRsZSgpOwogICAgICBPYmplY3Qua2V5cyhfZmlsZWhhbmRsZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHsKICAgICAgICBpZiAoa2V5ID09PSAiZGVmYXVsdCIgfHwga2V5ID09PSAiX19lc01vZHVsZSIpCiAgICAgICAgICByZXR1cm47CiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpCiAgICAgICAgICByZXR1cm47CiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgewogICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgICByZXR1cm4gX2ZpbGVoYW5kbGVba2V5XTsKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgfSk7CiAgICAgIGZ1bmN0aW9uIGZyb21Vcmwoc291cmNlKSB7CiAgICAgICAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IHt9OwogICAgICAgIHJldHVybiBuZXcgX3JlbW90ZUZpbGUuZGVmYXVsdChzb3VyY2UsIG9wdHMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIG9wZW4obWF5YmVVcmwsIG1heWJlUGF0aCwgbWF5YmVGaWxlaGFuZGxlKSB7CiAgICAgICAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1szXSA6IHt9OwogICAgICAgIGlmIChtYXliZUZpbGVoYW5kbGUgIT09IHZvaWQgMCkgewogICAgICAgICAgcmV0dXJuIG1heWJlRmlsZWhhbmRsZTsKICAgICAgICB9CiAgICAgICAgaWYgKG1heWJlVXJsICE9PSB2b2lkIDApIHsKICAgICAgICAgIHJldHVybiBmcm9tVXJsKG1heWJlVXJsLCBvcHRzKTsKICAgICAgICB9CiAgICAgICAgaWYgKG1heWJlUGF0aCAhPT0gdm9pZCAwKSB7CiAgICAgICAgICByZXR1cm4gbmV3IF9sb2NhbEZpbGUuZGVmYXVsdChtYXliZVBhdGgsIG9wdHMpOwogICAgICAgIH0KICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIm5vIHVybCwgcGF0aCwgb3IgZmlsZWhhbmRsZSBwcm92aWRlZCwgY2Fubm90IG9wZW4iKTsKICAgICAgfQogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMucmVnZXhwLmZsYWdzLmpzCiAgdmFyIHJlcXVpcmVfZXNfcmVnZXhwX2ZsYWdzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnJlZ2V4cC5mbGFncy5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzLmpzCiAgdmFyIHJlcXVpcmVfcmVnZXhwX2ZsYWdzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBhbk9iamVjdCA9IHJlcXVpcmVfYW5fb2JqZWN0KCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7CiAgICAgICAgdmFyIHRoYXQgPSBhbk9iamVjdCh0aGlzKTsKICAgICAgICB2YXIgcmVzdWx0ID0gIiI7CiAgICAgICAgaWYgKHRoYXQuZ2xvYmFsKQogICAgICAgICAgcmVzdWx0ICs9ICJnIjsKICAgICAgICBpZiAodGhhdC5pZ25vcmVDYXNlKQogICAgICAgICAgcmVzdWx0ICs9ICJpIjsKICAgICAgICBpZiAodGhhdC5tdWx0aWxpbmUpCiAgICAgICAgICByZXN1bHQgKz0gIm0iOwogICAgICAgIGlmICh0aGF0LmRvdEFsbCkKICAgICAgICAgIHJlc3VsdCArPSAicyI7CiAgICAgICAgaWYgKHRoYXQudW5pY29kZSkKICAgICAgICAgIHJlc3VsdCArPSAidSI7CiAgICAgICAgaWYgKHRoYXQuc3RpY2t5KQogICAgICAgICAgcmVzdWx0ICs9ICJ5IjsKICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL3JlZ2V4cC9mbGFncy5qcwogIHZhciByZXF1aXJlX2ZsYWdzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9yZWdleHAvZmxhZ3MuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHJlcXVpcmVfZXNfcmVnZXhwX2ZsYWdzKCk7CiAgICAgIHZhciBmbGFncyA9IHJlcXVpcmVfcmVnZXhwX2ZsYWdzKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpIHsKICAgICAgICByZXR1cm4gZmxhZ3MuY2FsbChpdCk7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvaW5zdGFuY2UvZmxhZ3MuanMKICB2YXIgcmVxdWlyZV9mbGFnczIgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2luc3RhbmNlL2ZsYWdzLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgZmxhZ3MgPSByZXF1aXJlX2ZsYWdzKCk7CiAgICAgIHZhciBSZWdFeHBQcm90b3R5cGUgPSBSZWdFeHAucHJvdG90eXBlOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KSB7CiAgICAgICAgcmV0dXJuIChpdCA9PT0gUmVnRXhwUHJvdG90eXBlIHx8IGl0IGluc3RhbmNlb2YgUmVnRXhwKSAmJiAhKCJmbGFncyIgaW4gaXQpID8gZmxhZ3MoaXQpIDogaXQuZmxhZ3M7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL2luc3RhbmNlL2ZsYWdzLmpzCiAgdmFyIHJlcXVpcmVfZmxhZ3MzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvaW5zdGFuY2UvZmxhZ3MuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBwYXJlbnQgPSByZXF1aXJlX2ZsYWdzMigpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcmVudDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvaW5zdGFuY2UvZmxhZ3MuanMKICB2YXIgcmVxdWlyZV9mbGFnczQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9pbnN0YW5jZS9mbGFncy5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlX2ZsYWdzMygpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy93aGl0ZXNwYWNlcy5qcwogIHZhciByZXF1aXJlX3doaXRlc3BhY2VzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvd2hpdGVzcGFjZXMuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gIglcblx2XGZcciBceEEwXHUxNjgwXHUyMDAwXHUyMDAxXHUyMDAyXHUyMDAzXHUyMDA0XHUyMDA1XHUyMDA2XHUyMDA3XHUyMDA4XHUyMDA5XHUyMDBBXHUyMDJGXHUyMDVGXHUzMDAwXHUyMDI4XHUyMDI5XHVGRUZGIjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvc3RyaW5nLXRyaW0uanMKICB2YXIgcmVxdWlyZV9zdHJpbmdfdHJpbSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3N0cmluZy10cmltLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmVfcmVxdWlyZV9vYmplY3RfY29lcmNpYmxlKCk7CiAgICAgIHZhciB0b1N0cmluZyA9IHJlcXVpcmVfdG9fc3RyaW5nKCk7CiAgICAgIHZhciB3aGl0ZXNwYWNlcyA9IHJlcXVpcmVfd2hpdGVzcGFjZXMoKTsKICAgICAgdmFyIHdoaXRlc3BhY2UgPSAiWyIgKyB3aGl0ZXNwYWNlcyArICJdIjsKICAgICAgdmFyIGx0cmltID0gUmVnRXhwKCJeIiArIHdoaXRlc3BhY2UgKyB3aGl0ZXNwYWNlICsgIioiKTsKICAgICAgdmFyIHJ0cmltID0gUmVnRXhwKHdoaXRlc3BhY2UgKyB3aGl0ZXNwYWNlICsgIiokIik7CiAgICAgIHZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbihUWVBFKSB7CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzKSB7CiAgICAgICAgICB2YXIgc3RyaW5nID0gdG9TdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSgkdGhpcykpOwogICAgICAgICAgaWYgKFRZUEUgJiAxKQogICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShsdHJpbSwgIiIpOwogICAgICAgICAgaWYgKFRZUEUgJiAyKQogICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShydHJpbSwgIiIpOwogICAgICAgICAgcmV0dXJuIHN0cmluZzsKICAgICAgICB9OwogICAgICB9OwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHsKICAgICAgICBzdGFydDogY3JlYXRlTWV0aG9kKDEpLAogICAgICAgIGVuZDogY3JlYXRlTWV0aG9kKDIpLAogICAgICAgIHRyaW06IGNyZWF0ZU1ldGhvZCgzKQogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9udW1iZXItcGFyc2UtaW50LmpzCiAgdmFyIHJlcXVpcmVfbnVtYmVyX3BhcnNlX2ludCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL251bWJlci1wYXJzZS1pbnQuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBnbG9iYWwyID0gcmVxdWlyZV9nbG9iYWwoKTsKICAgICAgdmFyIGZhaWxzID0gcmVxdWlyZV9mYWlscygpOwogICAgICB2YXIgdG9TdHJpbmcgPSByZXF1aXJlX3RvX3N0cmluZygpOwogICAgICB2YXIgdHJpbSA9IHJlcXVpcmVfc3RyaW5nX3RyaW0oKS50cmltOwogICAgICB2YXIgd2hpdGVzcGFjZXMgPSByZXF1aXJlX3doaXRlc3BhY2VzKCk7CiAgICAgIHZhciAkcGFyc2VJbnQgPSBnbG9iYWwyLnBhcnNlSW50OwogICAgICB2YXIgU3ltYm9sMiA9IGdsb2JhbDIuU3ltYm9sOwogICAgICB2YXIgSVRFUkFUT1IgPSBTeW1ib2wyICYmIFN5bWJvbDIuaXRlcmF0b3I7CiAgICAgIHZhciBoZXggPSAvXlsrLV0/MFtYeF0vOwogICAgICB2YXIgRk9SQ0VEID0gJHBhcnNlSW50KHdoaXRlc3BhY2VzICsgIjA4IikgIT09IDggfHwgJHBhcnNlSW50KHdoaXRlc3BhY2VzICsgIjB4MTYiKSAhPT0gMjIgfHwgSVRFUkFUT1IgJiYgIWZhaWxzKGZ1bmN0aW9uKCkgewogICAgICAgICRwYXJzZUludChPYmplY3QoSVRFUkFUT1IpKTsKICAgICAgfSk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gRk9SQ0VEID8gZnVuY3Rpb24gcGFyc2VJbnQyKHN0cmluZywgcmFkaXgpIHsKICAgICAgICB2YXIgUyA9IHRyaW0odG9TdHJpbmcoc3RyaW5nKSk7CiAgICAgICAgcmV0dXJuICRwYXJzZUludChTLCByYWRpeCA+Pj4gMCB8fCAoaGV4LnRlc3QoUykgPyAxNiA6IDEwKSk7CiAgICAgIH0gOiAkcGFyc2VJbnQ7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5wYXJzZS1pbnQuanMKICB2YXIgcmVxdWlyZV9lc19wYXJzZV9pbnQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMucGFyc2UtaW50LmpzIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgJCA9IHJlcXVpcmVfZXhwb3J0KCk7CiAgICAgIHZhciAkcGFyc2VJbnQgPSByZXF1aXJlX251bWJlcl9wYXJzZV9pbnQoKTsKICAgICAgJCh7IGdsb2JhbDogdHJ1ZSwgZm9yY2VkOiBwYXJzZUludCAhPSAkcGFyc2VJbnQgfSwgewogICAgICAgIHBhcnNlSW50OiAkcGFyc2VJbnQKICAgICAgfSk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvcGFyc2UtaW50LmpzCiAgdmFyIHJlcXVpcmVfcGFyc2VfaW50ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9wYXJzZS1pbnQuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHJlcXVpcmVfZXNfcGFyc2VfaW50KCk7CiAgICAgIHZhciBwYXRoID0gcmVxdWlyZV9wYXRoKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGF0aC5wYXJzZUludDsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvcGFyc2UtaW50LmpzCiAgdmFyIHJlcXVpcmVfcGFyc2VfaW50MiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL3BhcnNlLWludC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHBhcmVudCA9IHJlcXVpcmVfcGFyc2VfaW50KCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGFyZW50OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9wYXJzZS1pbnQuanMKICB2YXIgcmVxdWlyZV9wYXJzZV9pbnQzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvcGFyc2UtaW50LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVfcGFyc2VfaW50MigpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmFtL2Rpc3QvY29uc3RhbnRzLmpzCiAgdmFyIHJlcXVpcmVfY29uc3RhbnRzMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AZ21vZC9iYW0vZGlzdC9jb25zdGFudHMuanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBfT2JqZWN0JGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZV9kZWZpbmVfcHJvcGVydHkzKCk7CiAgICAgIF9PYmplY3QkZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgIl9fZXNNb2R1bGUiLCB7CiAgICAgICAgdmFsdWU6IHRydWUKICAgICAgfSk7CiAgICAgIGV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDsKICAgICAgdmFyIF9kZWZhdWx0ID0gewogICAgICAgIEJBTV9GUEFJUkVEOiAxLAogICAgICAgIEJBTV9GUFJPUEVSX1BBSVI6IDIsCiAgICAgICAgQkFNX0ZVTk1BUDogNCwKICAgICAgICBCQU1fRk1VTk1BUDogOCwKICAgICAgICBCQU1fRlJFVkVSU0U6IDE2LAogICAgICAgIEJBTV9GTVJFVkVSU0U6IDMyLAogICAgICAgIEJBTV9GUkVBRDE6IDY0LAogICAgICAgIEJBTV9GUkVBRDI6IDEyOCwKICAgICAgICBCQU1fRlNFQ09OREFSWTogMjU2LAogICAgICAgIEJBTV9GUUNGQUlMOiA1MTIsCiAgICAgICAgQkFNX0ZEVVA6IDEwMjQsCiAgICAgICAgQkFNX0ZTVVBQTEVNRU5UQVJZOiAyMDQ4CiAgICAgIH07CiAgICAgIGV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmFtL2Rpc3QvcmVjb3JkLmpzCiAgdmFyIHJlcXVpcmVfcmVjb3JkID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BnbW9kL2JhbS9kaXN0L3JlY29yZC5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlX2ludGVyb3BSZXF1aXJlRGVmYXVsdCgpOwogICAgICB2YXIgX09iamVjdCRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmVfZGVmaW5lX3Byb3BlcnR5MygpOwogICAgICBfT2JqZWN0JGRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgewogICAgICAgIHZhbHVlOiB0cnVlCiAgICAgIH0pOwogICAgICBleHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7CiAgICAgIHZhciBfZmxhZ3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2ZsYWdzNCgpKTsKICAgICAgdmFyIF9wYXJzZUludDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfcGFyc2VfaW50MygpKTsKICAgICAgdmFyIF9maWx0ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfZmlsdGVyNCgpKTsKICAgICAgdmFyIF9rZXlzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2tleXMzKCkpOwogICAgICB2YXIgX2ZvckVhY2ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfZm9yX2VhY2g0KCkpOwogICAgICB2YXIgX2NvbmNhdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9jb25jYXQ0KCkpOwogICAgICB2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9jbGFzc0NhbGxDaGVjaygpKTsKICAgICAgdmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfY3JlYXRlQ2xhc3MoKSk7CiAgICAgIHZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2RlZmluZVByb3BlcnR5KCkpOwogICAgICB2YXIgX21hcCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9tYXA0KCkpOwogICAgICB2YXIgX2NvbnN0YW50cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9jb25zdGFudHMyKCkpOwogICAgICB2YXIgX2NvbnRleHQ7CiAgICAgIHZhciBTRVFSRVRfREVDT0RFUiA9ICgwLCBfbWFwLmRlZmF1bHQpKF9jb250ZXh0ID0gIj1BQ01HUlNWVFdZSEtEQk4iLnNwbGl0KCIiKSkuY2FsbChfY29udGV4dCwgZnVuY3Rpb24ocykgewogICAgICAgIHJldHVybiBzLmNoYXJDb2RlQXQoMCk7CiAgICAgIH0pOwogICAgICB2YXIgQ0lHQVJfREVDT0RFUiA9ICJNSUROU0hQPVg/Pz8/Pz8/Ii5zcGxpdCgiIik7CiAgICAgIHZhciBCYW1SZWNvcmQgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7CiAgICAgICAgZnVuY3Rpb24gQmFtUmVjb3JkMihhcmdzKSB7CiAgICAgICAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBCYW1SZWNvcmQyKTsKICAgICAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsICJkYXRhIiwgdm9pZCAwKTsKICAgICAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsICJieXRlcyIsIHZvaWQgMCk7CiAgICAgICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCAiZmxhZ3MiLCB2b2lkIDApOwogICAgICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgIl9pZCIsIHZvaWQgMCk7CiAgICAgICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCAiX3JlZklEIiwgdm9pZCAwKTsKICAgICAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsICJfdGFnT2Zmc2V0Iiwgdm9pZCAwKTsKICAgICAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsICJfdGFnTGlzdCIsIFtdKTsKICAgICAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsICJfYWxsVGFnc1BhcnNlZCIsIGZhbHNlKTsKICAgICAgICAgIHRoaXMuZGF0YSA9IHt9OwogICAgICAgICAgdGhpcy5ieXRlcyA9IHsKICAgICAgICAgICAgc3RhcnQ6IGFyZ3MuYnl0ZXMuc3RhcnQsCiAgICAgICAgICAgIGVuZDogYXJncy5ieXRlcy5lbmQsCiAgICAgICAgICAgIGJ5dGVBcnJheTogYXJncy5ieXRlcy5ieXRlQXJyYXkKICAgICAgICAgIH07CiAgICAgICAgICB0aGlzLl9pZCA9IGFyZ3MuZmlsZU9mZnNldDsKICAgICAgICAgIHZhciBfdGhpcyRieXRlcyA9IHRoaXMuYnl0ZXMsIHN0YXJ0ID0gX3RoaXMkYnl0ZXMuc3RhcnQsIGJ5dGVBcnJheSA9IF90aGlzJGJ5dGVzLmJ5dGVBcnJheTsKICAgICAgICAgIHRoaXMuX3JlZklEID0gYnl0ZUFycmF5LnJlYWRJbnQzMkxFKHN0YXJ0ICsgNCk7CiAgICAgICAgICB0aGlzLmRhdGEuc3RhcnQgPSBieXRlQXJyYXkucmVhZEludDMyTEUoc3RhcnQgKyA4KTsKICAgICAgICAgIHRoaXMuZmxhZ3MgPSAoYnl0ZUFycmF5LnJlYWRJbnQzMkxFKHN0YXJ0ICsgMTYpICYgNDI5NDkwMTc2MCkgPj4gMTY7CiAgICAgICAgfQogICAgICAgICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEJhbVJlY29yZDIsIFt7CiAgICAgICAgICBrZXk6ICJnZXQiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldChmaWVsZCkgewogICAgICAgICAgICBpZiAodGhpc1tmaWVsZF0pIHsKICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhW2ZpZWxkXSkgewogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtmaWVsZF07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHRoaXMuZGF0YVtmaWVsZF0gPSB0aGlzW2ZpZWxkXSgpOwogICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbZmllbGRdOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXQoZmllbGQudG9Mb3dlckNhc2UoKSk7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiZW5kIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbmQoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCgic3RhcnQiKSArICh0aGlzLmdldCgibGVuZ3RoX29uX3JlZiIpIHx8IHRoaXMuZ2V0KCJzZXFfbGVuZ3RoIikgfHwgdm9pZCAwKTsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJzZXFfaWQiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNlcV9pZCgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZklEOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogIl9nZXQiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXQoZmllbGQpIHsKICAgICAgICAgICAgaWYgKGZpZWxkIGluIHRoaXMuZGF0YSkgewogICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbZmllbGRdOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuZGF0YVtmaWVsZF0gPSB0aGlzLl9wYXJzZVRhZyhmaWVsZCk7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbZmllbGRdOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogIl90YWdzIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdGFncygpIHsKICAgICAgICAgICAgdmFyIF9jb250ZXh0MiwgX3RoaXMgPSB0aGlzOwogICAgICAgICAgICB0aGlzLl9wYXJzZUFsbFRhZ3MoKTsKICAgICAgICAgICAgdmFyIHRhZ3MgPSBbInNlcSJdOwogICAgICAgICAgICBpZiAoIXRoaXMuaXNTZWdtZW50VW5tYXBwZWQoKSkgewogICAgICAgICAgICAgIHRhZ3MucHVzaCgic3RhcnQiLCAiZW5kIiwgInN0cmFuZCIsICJzY29yZSIsICJxdWFsIiwgIk1RIiwgIkNJR0FSIiwgImxlbmd0aF9vbl9yZWYiLCAidGVtcGxhdGVfbGVuZ3RoIik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHRoaXMuaXNQYWlyZWQoKSkgewogICAgICAgICAgICAgIHRhZ3MucHVzaCgibmV4dF9zZWdtZW50X3Bvc2l0aW9uIiwgInBhaXJfb3JpZW50YXRpb24iKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB0YWdzID0gKDAsIF9jb25jYXQuZGVmYXVsdCkodGFncykuY2FsbCh0YWdzLCB0aGlzLl90YWdMaXN0IHx8IFtdKTsKICAgICAgICAgICAgKDAsIF9mb3JFYWNoLmRlZmF1bHQpKF9jb250ZXh0MiA9ICgwLCBfa2V5cy5kZWZhdWx0KSh0aGlzLmRhdGEpKS5jYWxsKF9jb250ZXh0MiwgZnVuY3Rpb24oaykgewogICAgICAgICAgICAgIGlmIChrWzBdICE9PSAiXyIgJiYgayAhPT0gIm5leHRfc2VxX2lkIikgewogICAgICAgICAgICAgICAgdGFncy5wdXNoKGspOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIHZhciBzZWVuID0ge307CiAgICAgICAgICAgIHRhZ3MgPSAoMCwgX2ZpbHRlci5kZWZhdWx0KSh0YWdzKS5jYWxsKHRhZ3MsIGZ1bmN0aW9uKHQpIHsKICAgICAgICAgICAgICBpZiAodCBpbiBfdGhpcy5kYXRhICYmIF90aGlzLmRhdGFbdF0gPT09IHZvaWQgMCB8fCB0ID09PSAiQ0ciIHx8IHQgPT09ICJjZyIpIHsKICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgdmFyIGx0ID0gdC50b0xvd2VyQ2FzZSgpOwogICAgICAgICAgICAgIHZhciBzID0gc2VlbltsdF07CiAgICAgICAgICAgICAgc2VlbltsdF0gPSB0cnVlOwogICAgICAgICAgICAgIHJldHVybiAhczsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIHJldHVybiB0YWdzOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogInBhcmVudCIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyZW50KCkgewogICAgICAgICAgICByZXR1cm4gdm9pZCAwOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogImNoaWxkcmVuIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGlsZHJlbigpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KCJzdWJmZWF0dXJlcyIpOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogImlkIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpZCgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lkOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogIm1xIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtcSgpIHsKICAgICAgICAgICAgdmFyIG1xMiA9ICh0aGlzLmdldCgiX2Jpbl9tcV9ubCIpICYgNjUyODApID4+IDg7CiAgICAgICAgICAgIHJldHVybiBtcTIgPT09IDI1NSA/IHZvaWQgMCA6IG1xMjsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJzY29yZSIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2NvcmUoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCgibXEiKTsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJxdWFsIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBxdWFsKCkgewogICAgICAgICAgICB2YXIgX3RoaXMkcXVhbFJhdzsKICAgICAgICAgICAgcmV0dXJuIChfdGhpcyRxdWFsUmF3ID0gdGhpcy5xdWFsUmF3KCkpID09PSBudWxsIHx8IF90aGlzJHF1YWxSYXcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJHF1YWxSYXcuam9pbigiICIpOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogInF1YWxSYXciLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHF1YWxSYXcoKSB7CiAgICAgICAgICAgIGlmICh0aGlzLmlzU2VnbWVudFVubWFwcGVkKCkpIHsKICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBieXRlQXJyYXkgPSB0aGlzLmJ5dGVzLmJ5dGVBcnJheTsKICAgICAgICAgICAgdmFyIHAgPSB0aGlzLmJ5dGVzLnN0YXJ0ICsgMzYgKyB0aGlzLmdldCgiX2xfcmVhZF9uYW1lIikgKyB0aGlzLmdldCgiX25fY2lnYXJfb3AiKSAqIDQgKyB0aGlzLmdldCgiX3NlcV9ieXRlcyIpOwogICAgICAgICAgICB2YXIgbHNlcSA9IHRoaXMuZ2V0KCJzZXFfbGVuZ3RoIik7CiAgICAgICAgICAgIHZhciBxc2VxID0gaW1wb3J0X2J1ZmZlci5CdWZmZXIuYWxsb2NVbnNhZmUobHNlcSk7CiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbHNlcTsgKytqKSB7CiAgICAgICAgICAgICAgcXNlcVtqXSA9IGJ5dGVBcnJheVtwICsgal07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHFzZXE7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAic3RyYW5kIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdHJhbmQoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzUmV2ZXJzZUNvbXBsZW1lbnRlZCgpID8gLTEgOiAxOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogIm11bHRpX3NlZ21lbnRfbmV4dF9zZWdtZW50X3N0cmFuZCIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbXVsdGlfc2VnbWVudF9uZXh0X3NlZ21lbnRfc3RyYW5kKCkgewogICAgICAgICAgICBpZiAodGhpcy5pc01hdGVVbm1hcHBlZCgpKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gdGhpcy5pc01hdGVSZXZlcnNlQ29tcGxlbWVudGVkKCkgPyAtMSA6IDE7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAibmFtZSIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbmFtZSgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KCJfcmVhZF9uYW1lIik7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiX3JlYWRfbmFtZSIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlYWRfbmFtZSgpIHsKICAgICAgICAgICAgdmFyIG5sID0gdGhpcy5nZXQoIl9sX3JlYWRfbmFtZSIpOwogICAgICAgICAgICByZXR1cm4gdGhpcy5ieXRlcy5ieXRlQXJyYXkudG9TdHJpbmcoImFzY2lpIiwgdGhpcy5ieXRlcy5zdGFydCArIDM2LCB0aGlzLmJ5dGVzLnN0YXJ0ICsgMzYgKyBubCAtIDEpOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogIl9wYXJzZVRhZyIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3BhcnNlVGFnKHRhZ05hbWUpIHsKICAgICAgICAgICAgaWYgKHRoaXMuX2FsbFRhZ3NQYXJzZWQpIHsKICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBieXRlQXJyYXkgPSB0aGlzLmJ5dGVzLmJ5dGVBcnJheTsKICAgICAgICAgICAgdmFyIHAgPSB0aGlzLl90YWdPZmZzZXQgfHwgdGhpcy5ieXRlcy5zdGFydCArIDM2ICsgdGhpcy5nZXQoIl9sX3JlYWRfbmFtZSIpICsgdGhpcy5nZXQoIl9uX2NpZ2FyX29wIikgKiA0ICsgdGhpcy5nZXQoIl9zZXFfYnl0ZXMiKSArIHRoaXMuZ2V0KCJzZXFfbGVuZ3RoIik7CiAgICAgICAgICAgIHZhciBibG9ja0VuZCA9IHRoaXMuYnl0ZXMuZW5kOwogICAgICAgICAgICB2YXIgbGNUYWc7CiAgICAgICAgICAgIHdoaWxlIChwIDwgYmxvY2tFbmQgJiYgbGNUYWcgIT09IHRhZ05hbWUpIHsKICAgICAgICAgICAgICB2YXIgdGFnID0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlQXJyYXlbcF0sIGJ5dGVBcnJheVtwICsgMV0pOwogICAgICAgICAgICAgIGxjVGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgICAgICAgdmFyIHR5cGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVBcnJheVtwICsgMl0pOwogICAgICAgICAgICAgIHAgKz0gMzsKICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB2b2lkIDA7CiAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7CiAgICAgICAgICAgICAgICBjYXNlICJBIjoKICAgICAgICAgICAgICAgICAgdmFsdWUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVBcnJheVtwXSk7CiAgICAgICAgICAgICAgICAgIHAgKz0gMTsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICBjYXNlICJpIjoKICAgICAgICAgICAgICAgICAgdmFsdWUgPSBieXRlQXJyYXkucmVhZEludDMyTEUocCk7CiAgICAgICAgICAgICAgICAgIHAgKz0gNDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICBjYXNlICJJIjoKICAgICAgICAgICAgICAgICAgdmFsdWUgPSBieXRlQXJyYXkucmVhZFVJbnQzMkxFKHApOwogICAgICAgICAgICAgICAgICBwICs9IDQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSAiYyI6CiAgICAgICAgICAgICAgICAgIHZhbHVlID0gYnl0ZUFycmF5LnJlYWRJbnQ4KHApOwogICAgICAgICAgICAgICAgICBwICs9IDE7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSAiQyI6CiAgICAgICAgICAgICAgICAgIHZhbHVlID0gYnl0ZUFycmF5LnJlYWRVSW50OChwKTsKICAgICAgICAgICAgICAgICAgcCArPSAxOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIGNhc2UgInMiOgogICAgICAgICAgICAgICAgICB2YWx1ZSA9IGJ5dGVBcnJheS5yZWFkSW50MTZMRShwKTsKICAgICAgICAgICAgICAgICAgcCArPSAyOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIGNhc2UgIlMiOgogICAgICAgICAgICAgICAgICB2YWx1ZSA9IGJ5dGVBcnJheS5yZWFkVUludDE2TEUocCk7CiAgICAgICAgICAgICAgICAgIHAgKz0gMjsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICBjYXNlICJmIjoKICAgICAgICAgICAgICAgICAgdmFsdWUgPSBieXRlQXJyYXkucmVhZEZsb2F0TEUocCk7CiAgICAgICAgICAgICAgICAgIHAgKz0gNDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICBjYXNlICJaIjoKICAgICAgICAgICAgICAgIGNhc2UgIkgiOgogICAgICAgICAgICAgICAgICB2YWx1ZSA9ICIiOwogICAgICAgICAgICAgICAgICB3aGlsZSAocCA8PSBibG9ja0VuZCkgewogICAgICAgICAgICAgICAgICAgIHZhciBjYyA9IGJ5dGVBcnJheVtwKytdOwogICAgICAgICAgICAgICAgICAgIGlmIChjYyA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2MpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIGNhc2UgIkIiOiB7CiAgICAgICAgICAgICAgICAgIHZhbHVlID0gIiI7CiAgICAgICAgICAgICAgICAgIHZhciBfY2MgPSBieXRlQXJyYXlbcCsrXTsKICAgICAgICAgICAgICAgICAgdmFyIEJ0eXBlID0gU3RyaW5nLmZyb21DaGFyQ29kZShfY2MpOwogICAgICAgICAgICAgICAgICB2YXIgbGltaXQgPSBieXRlQXJyYXkucmVhZEludDMyTEUocCk7CiAgICAgICAgICAgICAgICAgIHAgKz0gNDsKICAgICAgICAgICAgICAgICAgaWYgKEJ0eXBlID09PSAiaSIpIHsKICAgICAgICAgICAgICAgICAgICBpZiAodGFnID09PSAiQ0ciKSB7CiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxpbWl0OyBrKyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNpZ29wID0gYnl0ZUFycmF5LnJlYWRJbnQzMkxFKHApOwogICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9wID0gY2lnb3AgPj4gNDsKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wID0gQ0lHQVJfREVDT0RFUltjaWdvcCAmIDE1XTsKICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gbG9wICsgb3A7CiAgICAgICAgICAgICAgICAgICAgICAgIHAgKz0gNDsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IGxpbWl0OyBfaysrKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGJ5dGVBcnJheS5yZWFkSW50MzJMRShwKTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9rICsgMSA8IGxpbWl0KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gIiwiOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIHAgKz0gNDsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKEJ0eXBlID09PSAiSSIpIHsKICAgICAgICAgICAgICAgICAgICBpZiAodGFnID09PSAiQ0ciKSB7CiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfazIgPSAwOyBfazIgPCBsaW1pdDsgX2syKyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jaWdvcCA9IGJ5dGVBcnJheS5yZWFkVUludDMyTEUocCk7CiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfbG9wID0gX2NpZ29wID4+IDQ7CiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfb3AgPSBDSUdBUl9ERUNPREVSW19jaWdvcCAmIDE1XTsKICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gX2xvcCArIF9vcDsKICAgICAgICAgICAgICAgICAgICAgICAgcCArPSA0OwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfazMgPSAwOyBfazMgPCBsaW1pdDsgX2szKyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gYnl0ZUFycmF5LnJlYWRVSW50MzJMRShwKTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9rMyArIDEgPCBsaW1pdCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9ICIsIjsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBwICs9IDQ7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChCdHlwZSA9PT0gInMiKSB7CiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2s0ID0gMDsgX2s0IDwgbGltaXQ7IF9rNCsrKSB7CiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBieXRlQXJyYXkucmVhZEludDE2TEUocCk7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoX2s0ICsgMSA8IGxpbWl0KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9ICIsIjsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHAgKz0gMjsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKEJ0eXBlID09PSAiUyIpIHsKICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfazUgPSAwOyBfazUgPCBsaW1pdDsgX2s1KyspIHsKICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGJ5dGVBcnJheS5yZWFkVUludDE2TEUocCk7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoX2s1ICsgMSA8IGxpbWl0KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9ICIsIjsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHAgKz0gMjsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKEJ0eXBlID09PSAiYyIpIHsKICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfazYgPSAwOyBfazYgPCBsaW1pdDsgX2s2KyspIHsKICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGJ5dGVBcnJheS5yZWFkSW50OChwKTsKICAgICAgICAgICAgICAgICAgICAgIGlmIChfazYgKyAxIDwgbGltaXQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gIiwiOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgcCArPSAxOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoQnR5cGUgPT09ICJDIikgewogICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9rNyA9IDA7IF9rNyA8IGxpbWl0OyBfazcrKykgewogICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gYnl0ZUFycmF5LnJlYWRVSW50OChwKTsKICAgICAgICAgICAgICAgICAgICAgIGlmIChfazcgKyAxIDwgbGltaXQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gIiwiOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgcCArPSAxOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoQnR5cGUgPT09ICJmIikgewogICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9rOCA9IDA7IF9rOCA8IGxpbWl0OyBfazgrKykgewogICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gYnl0ZUFycmF5LnJlYWRGbG9hdExFKHApOwogICAgICAgICAgICAgICAgICAgICAgaWYgKF9rOCArIDEgPCBsaW1pdCkgewogICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSAiLCI7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBwICs9IDQ7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCJVbmtub3duIEJBTSB0YWcgdHlwZSAnIi5jb25jYXQodHlwZSwgIicsIHRhZ3MgbWF5IGJlIGluY29tcGxldGUiKSk7CiAgICAgICAgICAgICAgICAgIHZhbHVlID0gdm9pZCAwOwogICAgICAgICAgICAgICAgICBwID0gYmxvY2tFbmQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHRoaXMuX3RhZ09mZnNldCA9IHA7CiAgICAgICAgICAgICAgdGhpcy5fdGFnTGlzdC5wdXNoKHRhZyk7CiAgICAgICAgICAgICAgaWYgKGxjVGFnID09PSB0YWdOYW1lKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHRoaXMuZGF0YVtsY1RhZ10gPSB2YWx1ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLl9hbGxUYWdzUGFyc2VkID0gdHJ1ZTsKICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJfcGFyc2VBbGxUYWdzIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcGFyc2VBbGxUYWdzKCkgewogICAgICAgICAgICB0aGlzLl9wYXJzZVRhZygiIik7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiX3BhcnNlQ2lnYXIiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJzZUNpZ2FyKGNpZ2FyKSB7CiAgICAgICAgICAgIHZhciBfY29udGV4dDM7CiAgICAgICAgICAgIHJldHVybiAoMCwgX21hcC5kZWZhdWx0KShfY29udGV4dDMgPSBjaWdhci5tYXRjaCgvXGQrXEQvZykpLmNhbGwoX2NvbnRleHQzLCBmdW5jdGlvbihvcCkgewogICAgICAgICAgICAgIHJldHVybiBbb3AubWF0Y2goL1xELylbMF0udG9VcHBlckNhc2UoKSwgKDAsIF9wYXJzZUludDIuZGVmYXVsdCkob3AsIDEwKV07CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogImlzUGFpcmVkIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1BhaXJlZCgpIHsKICAgICAgICAgICAgcmV0dXJuICEhKCgwLCBfZmxhZ3MyLmRlZmF1bHQpKHRoaXMpICYgX2NvbnN0YW50cy5kZWZhdWx0LkJBTV9GUEFJUkVEKTsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJpc1Byb3Blcmx5UGFpcmVkIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1Byb3Blcmx5UGFpcmVkKCkgewogICAgICAgICAgICByZXR1cm4gISEoKDAsIF9mbGFnczIuZGVmYXVsdCkodGhpcykgJiBfY29uc3RhbnRzLmRlZmF1bHQuQkFNX0ZQUk9QRVJfUEFJUik7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiaXNTZWdtZW50VW5tYXBwZWQiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzU2VnbWVudFVubWFwcGVkKCkgewogICAgICAgICAgICByZXR1cm4gISEoKDAsIF9mbGFnczIuZGVmYXVsdCkodGhpcykgJiBfY29uc3RhbnRzLmRlZmF1bHQuQkFNX0ZVTk1BUCk7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiaXNNYXRlVW5tYXBwZWQiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzTWF0ZVVubWFwcGVkKCkgewogICAgICAgICAgICByZXR1cm4gISEoKDAsIF9mbGFnczIuZGVmYXVsdCkodGhpcykgJiBfY29uc3RhbnRzLmRlZmF1bHQuQkFNX0ZNVU5NQVApOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogImlzUmV2ZXJzZUNvbXBsZW1lbnRlZCIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNSZXZlcnNlQ29tcGxlbWVudGVkKCkgewogICAgICAgICAgICByZXR1cm4gISEoKDAsIF9mbGFnczIuZGVmYXVsdCkodGhpcykgJiBfY29uc3RhbnRzLmRlZmF1bHQuQkFNX0ZSRVZFUlNFKTsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJpc01hdGVSZXZlcnNlQ29tcGxlbWVudGVkIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc01hdGVSZXZlcnNlQ29tcGxlbWVudGVkKCkgewogICAgICAgICAgICByZXR1cm4gISEoKDAsIF9mbGFnczIuZGVmYXVsdCkodGhpcykgJiBfY29uc3RhbnRzLmRlZmF1bHQuQkFNX0ZNUkVWRVJTRSk7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiaXNSZWFkMSIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNSZWFkMSgpIHsKICAgICAgICAgICAgcmV0dXJuICEhKCgwLCBfZmxhZ3MyLmRlZmF1bHQpKHRoaXMpICYgX2NvbnN0YW50cy5kZWZhdWx0LkJBTV9GUkVBRDEpOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogImlzUmVhZDIiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzUmVhZDIoKSB7CiAgICAgICAgICAgIHJldHVybiAhISgoMCwgX2ZsYWdzMi5kZWZhdWx0KSh0aGlzKSAmIF9jb25zdGFudHMuZGVmYXVsdC5CQU1fRlJFQUQyKTsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJpc1NlY29uZGFyeSIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNTZWNvbmRhcnkoKSB7CiAgICAgICAgICAgIHJldHVybiAhISgoMCwgX2ZsYWdzMi5kZWZhdWx0KSh0aGlzKSAmIF9jb25zdGFudHMuZGVmYXVsdC5CQU1fRlNFQ09OREFSWSk7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiaXNGYWlsZWRRYyIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNGYWlsZWRRYygpIHsKICAgICAgICAgICAgcmV0dXJuICEhKCgwLCBfZmxhZ3MyLmRlZmF1bHQpKHRoaXMpICYgX2NvbnN0YW50cy5kZWZhdWx0LkJBTV9GUUNGQUlMKTsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJpc0R1cGxpY2F0ZSIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNEdXBsaWNhdGUoKSB7CiAgICAgICAgICAgIHJldHVybiAhISgoMCwgX2ZsYWdzMi5kZWZhdWx0KSh0aGlzKSAmIF9jb25zdGFudHMuZGVmYXVsdC5CQU1fRkRVUCk7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiaXNTdXBwbGVtZW50YXJ5IiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1N1cHBsZW1lbnRhcnkoKSB7CiAgICAgICAgICAgIHJldHVybiAhISgoMCwgX2ZsYWdzMi5kZWZhdWx0KSh0aGlzKSAmIF9jb25zdGFudHMuZGVmYXVsdC5CQU1fRlNVUFBMRU1FTlRBUlkpOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogImNpZ2FyIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaWdhcigpIHsKICAgICAgICAgICAgaWYgKHRoaXMuaXNTZWdtZW50VW5tYXBwZWQoKSkgewogICAgICAgICAgICAgIHJldHVybiB2b2lkIDA7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIF90aGlzJGJ5dGVzMiA9IHRoaXMuYnl0ZXMsIGJ5dGVBcnJheSA9IF90aGlzJGJ5dGVzMi5ieXRlQXJyYXksIHN0YXJ0ID0gX3RoaXMkYnl0ZXMyLnN0YXJ0OwogICAgICAgICAgICB2YXIgbnVtQ2lnYXJPcHMgPSB0aGlzLmdldCgiX25fY2lnYXJfb3AiKTsKICAgICAgICAgICAgdmFyIHAgPSBzdGFydCArIDM2ICsgdGhpcy5nZXQoIl9sX3JlYWRfbmFtZSIpOwogICAgICAgICAgICB2YXIgc2VxTGVuID0gdGhpcy5nZXQoInNlcV9sZW5ndGgiKTsKICAgICAgICAgICAgdmFyIGNpZ2FyMiA9ICIiOwogICAgICAgICAgICB2YXIgbHJlZiA9IDA7CiAgICAgICAgICAgIHZhciBjaWdvcCA9IGJ5dGVBcnJheS5yZWFkSW50MzJMRShwKTsKICAgICAgICAgICAgdmFyIGxvcCA9IGNpZ29wID4+IDQ7CiAgICAgICAgICAgIHZhciBvcCA9IENJR0FSX0RFQ09ERVJbY2lnb3AgJiAxNV07CiAgICAgICAgICAgIGlmIChvcCA9PT0gIlMiICYmIGxvcCA9PT0gc2VxTGVuKSB7CiAgICAgICAgICAgICAgcCArPSA0OwogICAgICAgICAgICAgIGNpZ29wID0gYnl0ZUFycmF5LnJlYWRJbnQzMkxFKHApOwogICAgICAgICAgICAgIGxvcCA9IGNpZ29wID4+IDQ7CiAgICAgICAgICAgICAgb3AgPSBDSUdBUl9ERUNPREVSW2NpZ29wICYgMTVdOwogICAgICAgICAgICAgIGlmIChvcCAhPT0gIk4iKSB7CiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oIkNHIHRhZyB3aXRoIG5vIE4gdGFnIik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHRoaXMuZGF0YS5sZW5ndGhfb25fcmVmID0gbG9wOwogICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCgiQ0ciKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IG51bUNpZ2FyT3BzOyArK2MpIHsKICAgICAgICAgICAgICAgIGNpZ29wID0gYnl0ZUFycmF5LnJlYWRJbnQzMkxFKHApOwogICAgICAgICAgICAgICAgbG9wID0gY2lnb3AgPj4gNDsKICAgICAgICAgICAgICAgIG9wID0gQ0lHQVJfREVDT0RFUltjaWdvcCAmIDE1XTsKICAgICAgICAgICAgICAgIGNpZ2FyMiArPSBsb3AgKyBvcDsKICAgICAgICAgICAgICAgIGlmIChvcCAhPT0gIkgiICYmIG9wICE9PSAiUyIgJiYgb3AgIT09ICJJIikgewogICAgICAgICAgICAgICAgICBscmVmICs9IGxvcDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHAgKz0gNDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgdGhpcy5kYXRhLmxlbmd0aF9vbl9yZWYgPSBscmVmOwogICAgICAgICAgICAgIHJldHVybiBjaWdhcjI7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJfZmxhZ3MiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9mbGFncygpIHsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJsZW5ndGhfb25fcmVmIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsZW5ndGhfb25fcmVmKCkgewogICAgICAgICAgICB0aGlzLmdldCgiY2lnYXIiKTsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGhfb25fcmVmOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogIl9uX2NpZ2FyX29wIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbl9jaWdhcl9vcCgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KCJfZmxhZ19uYyIpICYgNjU1MzU7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiX2xfcmVhZF9uYW1lIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbF9yZWFkX25hbWUoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCgiX2Jpbl9tcV9ubCIpICYgMjU1OwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogIl9zZXFfYnl0ZXMiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXFfYnl0ZXMoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCgic2VxX2xlbmd0aCIpICsgMSA+PiAxOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogImdldFJlYWRCYXNlcyIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVhZEJhc2VzKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5zZXEoKTsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJzZXEiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNlcSgpIHsKICAgICAgICAgICAgdmFyIGJ5dGVBcnJheSA9IHRoaXMuYnl0ZXMuYnl0ZUFycmF5OwogICAgICAgICAgICB2YXIgcCA9IHRoaXMuYnl0ZXMuc3RhcnQgKyAzNiArIHRoaXMuZ2V0KCJfbF9yZWFkX25hbWUiKSArIHRoaXMuZ2V0KCJfbl9jaWdhcl9vcCIpICogNDsKICAgICAgICAgICAgdmFyIHNlcUJ5dGVzID0gdGhpcy5nZXQoIl9zZXFfYnl0ZXMiKTsKICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMuZ2V0KCJzZXFfbGVuZ3RoIik7CiAgICAgICAgICAgIHZhciBidWYgPSAiIjsKICAgICAgICAgICAgdmFyIGkgPSAwOwogICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlcUJ5dGVzOyArK2opIHsKICAgICAgICAgICAgICB2YXIgc2IgPSBieXRlQXJyYXlbcCArIGpdOwogICAgICAgICAgICAgIGJ1ZiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFNFUVJFVF9ERUNPREVSWyhzYiAmIDI0MCkgPj4gNF0pOwogICAgICAgICAgICAgIGkrKzsKICAgICAgICAgICAgICBpZiAoaSA8IGxlbikgewogICAgICAgICAgICAgICAgYnVmICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoU0VRUkVUX0RFQ09ERVJbc2IgJiAxNV0pOwogICAgICAgICAgICAgICAgaSsrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gYnVmOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogImdldFBhaXJPcmllbnRhdGlvbiIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGFpck9yaWVudGF0aW9uKCkgewogICAgICAgICAgICBpZiAoIXRoaXMuaXNTZWdtZW50VW5tYXBwZWQoKSAmJiAhdGhpcy5pc01hdGVVbm1hcHBlZCgpICYmIHRoaXMuX3JlZklEID09PSB0aGlzLl9uZXh0X3JlZmlkKCkpIHsKICAgICAgICAgICAgICB2YXIgczEgPSB0aGlzLmlzUmV2ZXJzZUNvbXBsZW1lbnRlZCgpID8gIlIiIDogIkYiOwogICAgICAgICAgICAgIHZhciBzMiA9IHRoaXMuaXNNYXRlUmV2ZXJzZUNvbXBsZW1lbnRlZCgpID8gIlIiIDogIkYiOwogICAgICAgICAgICAgIHZhciBvMSA9ICIgIjsKICAgICAgICAgICAgICB2YXIgbzIgPSAiICI7CiAgICAgICAgICAgICAgaWYgKHRoaXMuaXNSZWFkMSgpKSB7CiAgICAgICAgICAgICAgICBvMSA9ICIxIjsKICAgICAgICAgICAgICAgIG8yID0gIjIiOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1JlYWQyKCkpIHsKICAgICAgICAgICAgICAgIG8xID0gIjIiOwogICAgICAgICAgICAgICAgbzIgPSAiMSI7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHZhciB0bXAgPSBbXTsKICAgICAgICAgICAgICB2YXIgaXNpemUgPSB0aGlzLnRlbXBsYXRlX2xlbmd0aCgpOwogICAgICAgICAgICAgIGlmIChpc2l6ZSA+IDApIHsKICAgICAgICAgICAgICAgIHRtcFswXSA9IHMxOwogICAgICAgICAgICAgICAgdG1wWzFdID0gbzE7CiAgICAgICAgICAgICAgICB0bXBbMl0gPSBzMjsKICAgICAgICAgICAgICAgIHRtcFszXSA9IG8yOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB0bXBbMl0gPSBzMTsKICAgICAgICAgICAgICAgIHRtcFszXSA9IG8xOwogICAgICAgICAgICAgICAgdG1wWzBdID0gczI7CiAgICAgICAgICAgICAgICB0bXBbMV0gPSBvMjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIHRtcC5qb2luKCIiKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJfYmluX21xX25sIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYmluX21xX25sKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5ieXRlcy5ieXRlQXJyYXkucmVhZEludDMyTEUodGhpcy5ieXRlcy5zdGFydCArIDEyKTsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJfZmxhZ19uYyIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZsYWdfbmMoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ5dGVzLmJ5dGVBcnJheS5yZWFkSW50MzJMRSh0aGlzLmJ5dGVzLnN0YXJ0ICsgMTYpOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogInNlcV9sZW5ndGgiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNlcV9sZW5ndGgoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ5dGVzLmJ5dGVBcnJheS5yZWFkSW50MzJMRSh0aGlzLmJ5dGVzLnN0YXJ0ICsgMjApOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogIl9uZXh0X3JlZmlkIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbmV4dF9yZWZpZCgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXMuYnl0ZUFycmF5LnJlYWRJbnQzMkxFKHRoaXMuYnl0ZXMuc3RhcnQgKyAyNCk7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiX25leHRfcG9zIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbmV4dF9wb3MoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ5dGVzLmJ5dGVBcnJheS5yZWFkSW50MzJMRSh0aGlzLmJ5dGVzLnN0YXJ0ICsgMjgpOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogInRlbXBsYXRlX2xlbmd0aCIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdGVtcGxhdGVfbGVuZ3RoKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5ieXRlcy5ieXRlQXJyYXkucmVhZEludDMyTEUodGhpcy5ieXRlcy5zdGFydCArIDMyKTsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJ0b0pTT04iLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHsKICAgICAgICAgICAgdmFyIF9jb250ZXh0NCwgX3RoaXMyID0gdGhpczsKICAgICAgICAgICAgdmFyIGRhdGEgPSB7fTsKICAgICAgICAgICAgKDAsIF9mb3JFYWNoLmRlZmF1bHQpKF9jb250ZXh0NCA9ICgwLCBfa2V5cy5kZWZhdWx0KSh0aGlzKSkuY2FsbChfY29udGV4dDQsIGZ1bmN0aW9uKGspIHsKICAgICAgICAgICAgICBpZiAoay5jaGFyQXQoMCkgPT09ICJfIiB8fCBrID09PSAiYnl0ZXMiKSB7CiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGRhdGFba10gPSBfdGhpczJba107CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICByZXR1cm4gZGF0YTsKICAgICAgICAgIH0KICAgICAgICB9XSk7CiAgICAgICAgcmV0dXJuIEJhbVJlY29yZDI7CiAgICAgIH0oKTsKICAgICAgZXhwb3J0cy5kZWZhdWx0ID0gQmFtUmVjb3JkOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheS5qcwogIHZhciByZXF1aXJlX2l0ZXJhYmxlVG9BcnJheSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgX1N5bWJvbCA9IHJlcXVpcmVfc3ltYm9sNSgpOwogICAgICB2YXIgX2dldEl0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZV9nZXRfaXRlcmF0b3JfbWV0aG9kNSgpOwogICAgICB2YXIgX0FycmF5JGZyb20gPSByZXF1aXJlX2Zyb201KCk7CiAgICAgIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgewogICAgICAgIGlmICh0eXBlb2YgX1N5bWJvbCAhPT0gInVuZGVmaW5lZCIgJiYgX2dldEl0ZXJhdG9yTWV0aG9kKGl0ZXIpICE9IG51bGwgfHwgaXRlclsiQEBpdGVyYXRvciJdICE9IG51bGwpCiAgICAgICAgICByZXR1cm4gX0FycmF5JGZyb20oaXRlcik7CiAgICAgIH0KICAgICAgbW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5OwogICAgICBtb2R1bGUuZXhwb3J0c1siZGVmYXVsdCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9oZWxwZXJzL3RvQXJyYXkuanMKICB2YXIgcmVxdWlyZV90b0FycmF5ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvaGVscGVycy90b0FycmF5LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgYXJyYXlXaXRoSG9sZXMgPSByZXF1aXJlX2FycmF5V2l0aEhvbGVzKCk7CiAgICAgIHZhciBpdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlX2l0ZXJhYmxlVG9BcnJheSgpOwogICAgICB2YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KCk7CiAgICAgIHZhciBub25JdGVyYWJsZVJlc3QgPSByZXF1aXJlX25vbkl0ZXJhYmxlUmVzdCgpOwogICAgICBmdW5jdGlvbiBfdG9BcnJheShhcnIpIHsKICAgICAgICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpOwogICAgICB9CiAgICAgIG1vZHVsZS5leHBvcnRzID0gX3RvQXJyYXk7CiAgICAgIG1vZHVsZS5leHBvcnRzWyJkZWZhdWx0Il0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC9iYW0vZGlzdC9zYW0uanMKICB2YXIgcmVxdWlyZV9zYW0gPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGdtb2QvYmFtL2Rpc3Qvc2FtLmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmVfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KCk7CiAgICAgIHZhciBfT2JqZWN0JGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZV9kZWZpbmVfcHJvcGVydHkzKCk7CiAgICAgIF9PYmplY3QkZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgIl9fZXNNb2R1bGUiLCB7CiAgICAgICAgdmFsdWU6IHRydWUKICAgICAgfSk7CiAgICAgIGV4cG9ydHMucGFyc2VIZWFkZXJUZXh0ID0gcGFyc2VIZWFkZXJUZXh0OwogICAgICB2YXIgX3NsaWNlZFRvQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3NsaWNlZFRvQXJyYXkoKSk7CiAgICAgIHZhciBfbWFwID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX21hcDQoKSk7CiAgICAgIHZhciBfc2xpY2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfc2xpY2U2KCkpOwogICAgICB2YXIgX3RvQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3RvQXJyYXkoKSk7CiAgICAgIHZhciBfZm9yRWFjaCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9mb3JfZWFjaDQoKSk7CiAgICAgIGZ1bmN0aW9uIHBhcnNlSGVhZGVyVGV4dCh0ZXh0KSB7CiAgICAgICAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCgvXHI/XG4vKTsKICAgICAgICB2YXIgZGF0YSA9IFtdOwogICAgICAgICgwLCBfZm9yRWFjaC5kZWZhdWx0KShsaW5lcykuY2FsbChsaW5lcywgZnVuY3Rpb24obGluZSkgewogICAgICAgICAgdmFyIF9saW5lJHNwbGl0ID0gbGluZS5zcGxpdCgvXHQvKSwgX2xpbmUkc3BsaXQyID0gKDAsIF90b0FycmF5Mi5kZWZhdWx0KShfbGluZSRzcGxpdCksIHRhZyA9IF9saW5lJHNwbGl0MlswXSwgZmllbGRzID0gKDAsIF9zbGljZS5kZWZhdWx0KShfbGluZSRzcGxpdDIpLmNhbGwoX2xpbmUkc3BsaXQyLCAxKTsKICAgICAgICAgIHZhciBwYXJzZWRGaWVsZHMgPSAoMCwgX21hcC5kZWZhdWx0KShmaWVsZHMpLmNhbGwoZmllbGRzLCBmdW5jdGlvbihmKSB7CiAgICAgICAgICAgIHZhciBfZiRzcGxpdCA9IGYuc3BsaXQoIjoiLCAyKSwgX2Ykc3BsaXQyID0gKDAsIF9zbGljZWRUb0FycmF5Mi5kZWZhdWx0KShfZiRzcGxpdCwgMiksIGZpZWxkVGFnID0gX2Ykc3BsaXQyWzBdLCB2YWx1ZSA9IF9mJHNwbGl0MlsxXTsKICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICB0YWc6IGZpZWxkVGFnLAogICAgICAgICAgICAgIHZhbHVlCiAgICAgICAgICAgIH07CiAgICAgICAgICB9KTsKICAgICAgICAgIGlmICh0YWcpIHsKICAgICAgICAgICAgZGF0YS5wdXNoKHsKICAgICAgICAgICAgICB0YWc6IHRhZy5zdWJzdHIoMSksCiAgICAgICAgICAgICAgZGF0YTogcGFyc2VkRmllbGRzCiAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICAgIHJldHVybiBkYXRhOwogICAgICB9CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC9iYW0vZGlzdC9iYW1GaWxlLmpzCiAgdmFyIHJlcXVpcmVfYmFtRmlsZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AZ21vZC9iYW0vZGlzdC9iYW1GaWxlLmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmVfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KCk7CiAgICAgIHZhciBfT2JqZWN0JGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZV9kZWZpbmVfcHJvcGVydHkzKCk7CiAgICAgIF9PYmplY3QkZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgIl9fZXNNb2R1bGUiLCB7CiAgICAgICAgdmFsdWU6IHRydWUKICAgICAgfSk7CiAgICAgIGV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuQkFNX01BR0lDID0gdm9pZCAwOwogICAgICB2YXIgX25vdyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9ub3czKCkpOwogICAgICB2YXIgX3NvcnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfc29ydDQoKSk7CiAgICAgIHZhciBfZmlsdGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2ZpbHRlcjQoKSk7CiAgICAgIHZhciBfc2xpY2VkVG9BcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfc2xpY2VkVG9BcnJheSgpKTsKICAgICAgdmFyIF9mb3JFYWNoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2Zvcl9lYWNoNCgpKTsKICAgICAgdmFyIF9wcm9taXNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3Byb21pc2U1KCkpOwogICAgICB2YXIgX21hcCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9tYXA0KCkpOwogICAgICB2YXIgX3JlZHVjZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9yZWR1Y2U0KCkpOwogICAgICB2YXIgX2NvbmNhdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9jb25jYXQ0KCkpOwogICAgICB2YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3JlZ2VuZXJhdG9yKCkpOwogICAgICB2YXIgX3NsaWNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3NsaWNlNigpKTsKICAgICAgdmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9hc3luY1RvR2VuZXJhdG9yKCkpOwogICAgICB2YXIgX2JpbmQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfYmluZDQoKSk7CiAgICAgIHZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2NsYXNzQ2FsbENoZWNrKCkpOwogICAgICB2YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9jcmVhdGVDbGFzcygpKTsKICAgICAgdmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfZGVmaW5lUHJvcGVydHkoKSk7CiAgICAgIHZhciBfd3JhcEFzeW5jR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV93cmFwQXN5bmNHZW5lcmF0b3IoKSk7CiAgICAgIHZhciBfYXdhaXRBc3luY0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfYXdhaXRBc3luY0dlbmVyYXRvcigpKTsKICAgICAgdmFyIF9hc3luY0dlbmVyYXRvckRlbGVnYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9hc3luY0dlbmVyYXRvckRlbGVnYXRlKCkpOwogICAgICB2YXIgX2FzeW5jSXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2FzeW5jSXRlcmF0b3IoKSk7CiAgICAgIHZhciBfYWJvcnRhYmxlUHJvbWlzZUNhY2hlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2Rpc3QoKSk7CiAgICAgIHZhciBfYmFpID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2JhaSgpKTsKICAgICAgdmFyIF9jc2kgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfY3NpKCkpOwogICAgICB2YXIgX2J1ZmZlckNyYyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9idWZmZXJfY3JjMzIoKSk7CiAgICAgIHZhciBfYmd6ZkZpbGVoYW5kbGUgPSByZXF1aXJlX2Rpc3QyKCk7CiAgICAgIHZhciBfb2JqZWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX29iamVjdCgpKTsKICAgICAgdmFyIF9xdWlja0xydSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9xdWlja19scnUoKSk7CiAgICAgIHZhciBfZ2VuZXJpY0ZpbGVoYW5kbGUgPSByZXF1aXJlX2Rpc3QzKCk7CiAgICAgIHZhciBfcmVjb3JkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3JlY29yZCgpKTsKICAgICAgdmFyIF9zYW0gPSByZXF1aXJlX3NhbSgpOwogICAgICB2YXIgX3V0aWwgPSByZXF1aXJlX3V0aWwoKTsKICAgICAgdmFyIEJBTV9NQUdJQyA9IDIxODQwMTk0OwogICAgICBleHBvcnRzLkJBTV9NQUdJQyA9IEJBTV9NQUdJQzsKICAgICAgdmFyIGJsb2NrTGVuID0gMSA8PCAxNjsKICAgICAgdmFyIEJhbUZpbGUyID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkgewogICAgICAgIGZ1bmN0aW9uIEJhbUZpbGUzKF9yZWYpIHsKICAgICAgICAgIHZhciBfY29udGV4dDsKICAgICAgICAgIHZhciBiYW1GaWxlaGFuZGxlID0gX3JlZi5iYW1GaWxlaGFuZGxlLCBiYW1QYXRoID0gX3JlZi5iYW1QYXRoLCBiYW1VcmwgPSBfcmVmLmJhbVVybCwgYmFpUGF0aCA9IF9yZWYuYmFpUGF0aCwgYmFpRmlsZWhhbmRsZSA9IF9yZWYuYmFpRmlsZWhhbmRsZSwgYmFpVXJsID0gX3JlZi5iYWlVcmwsIGNzaVBhdGggPSBfcmVmLmNzaVBhdGgsIGNzaUZpbGVoYW5kbGUgPSBfcmVmLmNzaUZpbGVoYW5kbGUsIGNzaVVybCA9IF9yZWYuY3NpVXJsLCBjYWNoZVNpemUgPSBfcmVmLmNhY2hlU2l6ZSwgZmV0Y2hTaXplTGltaXQgPSBfcmVmLmZldGNoU2l6ZUxpbWl0LCBjaHVua1NpemVMaW1pdCA9IF9yZWYuY2h1bmtTaXplTGltaXQsIF9yZWYkeWllbGRUaHJlYWRUaW1lID0gX3JlZi55aWVsZFRocmVhZFRpbWUsIHlpZWxkVGhyZWFkVGltZSA9IF9yZWYkeWllbGRUaHJlYWRUaW1lID09PSB2b2lkIDAgPyAxMDAgOiBfcmVmJHlpZWxkVGhyZWFkVGltZSwgX3JlZiRyZW5hbWVSZWZTZXFzID0gX3JlZi5yZW5hbWVSZWZTZXFzLCByZW5hbWVSZWZTZXFzID0gX3JlZiRyZW5hbWVSZWZTZXFzID09PSB2b2lkIDAgPyBmdW5jdGlvbihuKSB7CiAgICAgICAgICAgIHJldHVybiBuOwogICAgICAgICAgfSA6IF9yZWYkcmVuYW1lUmVmU2VxczsKICAgICAgICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEJhbUZpbGUzKTsKICAgICAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsICJyZW5hbWVSZWZTZXEiLCB2b2lkIDApOwogICAgICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgImJhbSIsIHZvaWQgMCk7CiAgICAgICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCAiaW5kZXgiLCB2b2lkIDApOwogICAgICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgImNodW5rU2l6ZUxpbWl0Iiwgdm9pZCAwKTsKICAgICAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsICJmZXRjaFNpemVMaW1pdCIsIHZvaWQgMCk7CiAgICAgICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCAiaGVhZGVyIiwgdm9pZCAwKTsKICAgICAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsICJmZWF0dXJlQ2FjaGUiLCB2b2lkIDApOwogICAgICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgImNoclRvSW5kZXgiLCB2b2lkIDApOwogICAgICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgImluZGV4VG9DaHIiLCB2b2lkIDApOwogICAgICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgInlpZWxkVGhyZWFkVGltZSIsIHZvaWQgMCk7CiAgICAgICAgICB0aGlzLnJlbmFtZVJlZlNlcSA9IHJlbmFtZVJlZlNlcXM7CiAgICAgICAgICBpZiAoYmFtRmlsZWhhbmRsZSkgewogICAgICAgICAgICB0aGlzLmJhbSA9IGJhbUZpbGVoYW5kbGU7CiAgICAgICAgICB9IGVsc2UgaWYgKGJhbVBhdGgpIHsKICAgICAgICAgICAgdGhpcy5iYW0gPSBuZXcgX2dlbmVyaWNGaWxlaGFuZGxlLkxvY2FsRmlsZShiYW1QYXRoKTsKICAgICAgICAgIH0gZWxzZSBpZiAoYmFtVXJsKSB7CiAgICAgICAgICAgIHRoaXMuYmFtID0gbmV3IF9nZW5lcmljRmlsZWhhbmRsZS5SZW1vdGVGaWxlKGJhbVVybCk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoInVuYWJsZSB0byBpbml0aWFsaXplIGJhbSIpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGNzaUZpbGVoYW5kbGUpIHsKICAgICAgICAgICAgdGhpcy5pbmRleCA9IG5ldyBfY3NpLmRlZmF1bHQoewogICAgICAgICAgICAgIGZpbGVoYW5kbGU6IGNzaUZpbGVoYW5kbGUKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9IGVsc2UgaWYgKGNzaVBhdGgpIHsKICAgICAgICAgICAgdGhpcy5pbmRleCA9IG5ldyBfY3NpLmRlZmF1bHQoewogICAgICAgICAgICAgIGZpbGVoYW5kbGU6IG5ldyBfZ2VuZXJpY0ZpbGVoYW5kbGUuTG9jYWxGaWxlKGNzaVBhdGgpCiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSBlbHNlIGlmIChjc2lVcmwpIHsKICAgICAgICAgICAgdGhpcy5pbmRleCA9IG5ldyBfY3NpLmRlZmF1bHQoewogICAgICAgICAgICAgIGZpbGVoYW5kbGU6IG5ldyBfZ2VuZXJpY0ZpbGVoYW5kbGUuUmVtb3RlRmlsZShjc2lVcmwpCiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSBlbHNlIGlmIChiYWlGaWxlaGFuZGxlKSB7CiAgICAgICAgICAgIHRoaXMuaW5kZXggPSBuZXcgX2JhaS5kZWZhdWx0KHsKICAgICAgICAgICAgICBmaWxlaGFuZGxlOiBiYWlGaWxlaGFuZGxlCiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSBlbHNlIGlmIChiYWlQYXRoKSB7CiAgICAgICAgICAgIHRoaXMuaW5kZXggPSBuZXcgX2JhaS5kZWZhdWx0KHsKICAgICAgICAgICAgICBmaWxlaGFuZGxlOiBuZXcgX2dlbmVyaWNGaWxlaGFuZGxlLkxvY2FsRmlsZShiYWlQYXRoKQogICAgICAgICAgICB9KTsKICAgICAgICAgIH0gZWxzZSBpZiAoYmFpVXJsKSB7CiAgICAgICAgICAgIHRoaXMuaW5kZXggPSBuZXcgX2JhaS5kZWZhdWx0KHsKICAgICAgICAgICAgICBmaWxlaGFuZGxlOiBuZXcgX2dlbmVyaWNGaWxlaGFuZGxlLlJlbW90ZUZpbGUoYmFpVXJsKQogICAgICAgICAgICB9KTsKICAgICAgICAgIH0gZWxzZSBpZiAoYmFtUGF0aCkgewogICAgICAgICAgICB0aGlzLmluZGV4ID0gbmV3IF9iYWkuZGVmYXVsdCh7CiAgICAgICAgICAgICAgZmlsZWhhbmRsZTogbmV3IF9nZW5lcmljRmlsZWhhbmRsZS5Mb2NhbEZpbGUoIiIuY29uY2F0KGJhbVBhdGgsICIuYmFpIikpCiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSBlbHNlIGlmIChiYW1VcmwpIHsKICAgICAgICAgICAgdGhpcy5pbmRleCA9IG5ldyBfYmFpLmRlZmF1bHQoewogICAgICAgICAgICAgIGZpbGVoYW5kbGU6IG5ldyBfZ2VuZXJpY0ZpbGVoYW5kbGUuUmVtb3RlRmlsZSgiIi5jb25jYXQoYmFtVXJsLCAiLmJhaSIpKQogICAgICAgICAgICB9KTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigidW5hYmxlIHRvIGluZmVyIGluZGV4IGZvcm1hdCIpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5mZWF0dXJlQ2FjaGUgPSBuZXcgX2Fib3J0YWJsZVByb21pc2VDYWNoZS5kZWZhdWx0KHsKICAgICAgICAgICAgY2FjaGU6IG5ldyBfcXVpY2tMcnUuZGVmYXVsdCh7CiAgICAgICAgICAgICAgbWF4U2l6ZTogY2FjaGVTaXplICE9PSB2b2lkIDAgPyBjYWNoZVNpemUgOiA1MAogICAgICAgICAgICB9KSwKICAgICAgICAgICAgZmlsbDogKDAsIF9iaW5kLmRlZmF1bHQpKF9jb250ZXh0ID0gdGhpcy5fcmVhZENodW5rKS5jYWxsKF9jb250ZXh0LCB0aGlzKQogICAgICAgICAgfSk7CiAgICAgICAgICB0aGlzLmZldGNoU2l6ZUxpbWl0ID0gZmV0Y2hTaXplTGltaXQgfHwgNWU4OwogICAgICAgICAgdGhpcy5jaHVua1NpemVMaW1pdCA9IGNodW5rU2l6ZUxpbWl0IHx8IDNlODsKICAgICAgICAgIHRoaXMueWllbGRUaHJlYWRUaW1lID0geWllbGRUaHJlYWRUaW1lOwogICAgICAgIH0KICAgICAgICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShCYW1GaWxlMywgW3sKICAgICAgICAgIGtleTogImdldEhlYWRlciIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciBfZ2V0SGVhZGVyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KSgvKiBAX19QVVJFX18gKi8gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkgewogICAgICAgICAgICAgIHZhciBvcmlnT3B0cywgb3B0cywgaW5kZXhEYXRhLCByZXQsIGJ1ZmZlciwgcmVzLCBieXRlc1JlYWQsIHVuY2JhLCBoZWFkTGVuLCBfeWllbGQkdGhpcyRfcmVhZFJlZlMsIGNoclRvSW5kZXgsIGluZGV4VG9DaHIsIF9hcmdzID0gYXJndW1lbnRzOwogICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0MikgewogICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgICAgb3JpZ09wdHMgPSBfYXJncy5sZW5ndGggPiAwICYmIF9hcmdzWzBdICE9PSB2b2lkIDAgPyBfYXJnc1swXSA6IHt9OwogICAgICAgICAgICAgICAgICAgICAgb3B0cyA9ICgwLCBfdXRpbC5tYWtlT3B0cykob3JpZ09wdHMpOwogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0OwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXgucGFyc2Uob3B0cyk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OgogICAgICAgICAgICAgICAgICAgICAgaW5kZXhEYXRhID0gX2NvbnRleHQyLnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgICByZXQgPSBpbmRleERhdGEuZmlyc3REYXRhTGluZSA/IGluZGV4RGF0YS5maXJzdERhdGFMaW5lLmJsb2NrUG9zaXRpb24gKyA2NTUzNSA6IHZvaWQgMDsKICAgICAgICAgICAgICAgICAgICAgIGlmICghcmV0KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTc7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA5OwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFtLnJlYWQoaW1wb3J0X2J1ZmZlci5CdWZmZXIuYWxsb2MocmV0ICsgYmxvY2tMZW4pLCAwLCByZXQgKyBibG9ja0xlbiwgMCwgb3B0cyk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OgogICAgICAgICAgICAgICAgICAgICAgcmVzID0gX2NvbnRleHQyLnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgICBieXRlc1JlYWQgPSByZXMuYnl0ZXNSZWFkOwogICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gcmVzLmJ1ZmZlcjsKICAgICAgICAgICAgICAgICAgICAgIGlmIChieXRlc1JlYWQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNDsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkVycm9yIHJlYWRpbmcgaGVhZGVyIik7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDoKICAgICAgICAgICAgICAgICAgICAgIGlmIChieXRlc1JlYWQgPCByZXQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gKDAsIF9zbGljZS5kZWZhdWx0KShidWZmZXIpLmNhbGwoYnVmZmVyLCAwLCBieXRlc1JlYWQpOwogICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gKDAsIF9zbGljZS5kZWZhdWx0KShidWZmZXIpLmNhbGwoYnVmZmVyLCAwLCByZXQpOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyMDsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTc6CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE5OwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFtLnJlYWRGaWxlKG9wdHMpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTk6CiAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBfY29udGV4dDIuc2VudDsKICAgICAgICAgICAgICAgICAgICBjYXNlIDIwOgogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyMjsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX2JnemZGaWxlaGFuZGxlLnVuemlwKShidWZmZXIpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMjI6CiAgICAgICAgICAgICAgICAgICAgICB1bmNiYSA9IF9jb250ZXh0Mi5zZW50OwogICAgICAgICAgICAgICAgICAgICAgaWYgKCEodW5jYmEucmVhZEludDMyTEUoMCkgIT09IEJBTV9NQUdJQykpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyNTsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIk5vdCBhIEJBTSBmaWxlIik7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAyNToKICAgICAgICAgICAgICAgICAgICAgIGhlYWRMZW4gPSB1bmNiYS5yZWFkSW50MzJMRSg0KTsKICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVyID0gdW5jYmEudG9TdHJpbmcoInV0ZjgiLCA4LCA4ICsgaGVhZExlbik7CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI5OwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRSZWZTZXFzKGhlYWRMZW4gKyA4LCA2NTUzNSwgb3B0cyk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOToKICAgICAgICAgICAgICAgICAgICAgIF95aWVsZCR0aGlzJF9yZWFkUmVmUyA9IF9jb250ZXh0Mi5zZW50OwogICAgICAgICAgICAgICAgICAgICAgY2hyVG9JbmRleCA9IF95aWVsZCR0aGlzJF9yZWFkUmVmUy5jaHJUb0luZGV4OwogICAgICAgICAgICAgICAgICAgICAgaW5kZXhUb0NociA9IF95aWVsZCR0aGlzJF9yZWFkUmVmUy5pbmRleFRvQ2hyOwogICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaHJUb0luZGV4ID0gY2hyVG9JbmRleDsKICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhUb0NociA9IGluZGV4VG9DaHI7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdCgicmV0dXJuIiwgKDAsIF9zYW0ucGFyc2VIZWFkZXJUZXh0KSh0aGlzLmhlYWRlcikpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMzU6CiAgICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7CiAgICAgICAgICAgIH0pKTsKICAgICAgICAgICAgZnVuY3Rpb24gZ2V0SGVhZGVyKCkgewogICAgICAgICAgICAgIHJldHVybiBfZ2V0SGVhZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGdldEhlYWRlcjsKICAgICAgICAgIH0oKQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogImdldEhlYWRlclRleHQiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgX2dldEhlYWRlclRleHQgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKC8qIEBfX1BVUkVfXyAqLyBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkgewogICAgICAgICAgICAgIHZhciBvcHRzLCBfYXJnczIgPSBhcmd1bWVudHM7CiAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0MykgewogICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgICAgb3B0cyA9IF9hcmdzMi5sZW5ndGggPiAwICYmIF9hcmdzMlswXSAhPT0gdm9pZCAwID8gX2FyZ3MyWzBdIDoge307CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDM7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRIZWFkZXIob3B0cyk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoInJldHVybiIsIHRoaXMuaGVhZGVyKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6CiAgICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpOwogICAgICAgICAgICB9KSk7CiAgICAgICAgICAgIGZ1bmN0aW9uIGdldEhlYWRlclRleHQoKSB7CiAgICAgICAgICAgICAgcmV0dXJuIF9nZXRIZWFkZXJUZXh0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGdldEhlYWRlclRleHQ7CiAgICAgICAgICB9KCkKICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJfcmVhZFJlZlNlcXMiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgX3JlYWRSZWZTZXFzMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoc3RhcnQsIHJlZlNlcUJ5dGVzKSB7CiAgICAgICAgICAgICAgdmFyIG9wdHMsIHJlcywgYnl0ZXNSZWFkLCBidWZmZXIsIHVuY2JhLCBuUmVmLCBwLCBjaHJUb0luZGV4LCBpbmRleFRvQ2hyLCBpLCBsTmFtZSwgcmVmTmFtZSwgbFJlZiwgX2FyZ3MzID0gYXJndW1lbnRzOwogICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDQpIHsKICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkgewogICAgICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgICAgIG9wdHMgPSBfYXJnczMubGVuZ3RoID4gMiAmJiBfYXJnczNbMl0gIT09IHZvaWQgMCA/IF9hcmdzM1syXSA6IHt9OwogICAgICAgICAgICAgICAgICAgICAgaWYgKCEoc3RhcnQgPiByZWZTZXFCeXRlcykpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAzOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KCJyZXR1cm4iLCB0aGlzLl9yZWFkUmVmU2VxcyhzdGFydCwgcmVmU2VxQnl0ZXMgKiAyLCBvcHRzKSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOgogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA1OwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFtLnJlYWQoaW1wb3J0X2J1ZmZlci5CdWZmZXIuYWxsb2MocmVmU2VxQnl0ZXMgKyBibG9ja0xlbiksIDAsIHJlZlNlcUJ5dGVzLCAwLCBvcHRzKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDU6CiAgICAgICAgICAgICAgICAgICAgICByZXMgPSBfY29udGV4dDQuc2VudDsKICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzUmVhZCA9IHJlcy5ieXRlc1JlYWQ7CiAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSByZXMuYnVmZmVyOwogICAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVzUmVhZCkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDEwOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiRXJyb3IgcmVhZGluZyByZWZzZXFzIGZyb20gaGVhZGVyIik7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDoKICAgICAgICAgICAgICAgICAgICAgIGlmIChieXRlc1JlYWQgPCByZWZTZXFCeXRlcykgewogICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSAoMCwgX3NsaWNlLmRlZmF1bHQpKGJ1ZmZlcikuY2FsbChidWZmZXIsIDAsIGJ5dGVzUmVhZCk7CiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSAoMCwgX3NsaWNlLmRlZmF1bHQpKGJ1ZmZlcikuY2FsbChidWZmZXIsIDAsIHJlZlNlcUJ5dGVzKTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTM7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9iZ3pmRmlsZWhhbmRsZS51bnppcCkoYnVmZmVyKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOgogICAgICAgICAgICAgICAgICAgICAgdW5jYmEgPSBfY29udGV4dDQuc2VudDsKICAgICAgICAgICAgICAgICAgICAgIG5SZWYgPSB1bmNiYS5yZWFkSW50MzJMRShzdGFydCk7CiAgICAgICAgICAgICAgICAgICAgICBwID0gc3RhcnQgKyA0OwogICAgICAgICAgICAgICAgICAgICAgY2hyVG9JbmRleCA9IHt9OwogICAgICAgICAgICAgICAgICAgICAgaW5kZXhUb0NociA9IFtdOwogICAgICAgICAgICAgICAgICAgICAgaSA9IDA7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOToKICAgICAgICAgICAgICAgICAgICAgIGlmICghKGkgPCBuUmVmKSkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDM1OwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMjI7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF91dGlsLmFib3J0QnJlYWtQb2ludCkob3B0cy5zaWduYWwpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMjI6CiAgICAgICAgICAgICAgICAgICAgICBsTmFtZSA9IHVuY2JhLnJlYWRJbnQzMkxFKHApOwogICAgICAgICAgICAgICAgICAgICAgcmVmTmFtZSA9IHVuY2JhLnRvU3RyaW5nKCJ1dGY4IiwgcCArIDQsIHAgKyA0ICsgbE5hbWUgLSAxKTsKICAgICAgICAgICAgICAgICAgICAgIHJlZk5hbWUgPSB0aGlzLnJlbmFtZVJlZlNlcShyZWZOYW1lKTsKICAgICAgICAgICAgICAgICAgICAgIGxSZWYgPSB1bmNiYS5yZWFkSW50MzJMRShwICsgbE5hbWUgKyA0KTsKICAgICAgICAgICAgICAgICAgICAgIGNoclRvSW5kZXhbcmVmTmFtZV0gPSBpOwogICAgICAgICAgICAgICAgICAgICAgaW5kZXhUb0Noci5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgICAgcmVmTmFtZSwKICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiBsUmVmCiAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICAgIHAgPSBwICsgOCArIGxOYW1lOwogICAgICAgICAgICAgICAgICAgICAgaWYgKCEocCA+IHVuY2JhLmxlbmd0aCkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAzMjsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oIkJBTSBoZWFkZXIgaXMgdmVyeSBiaWcuICBSZS1mZXRjaGluZyAiLmNvbmNhdChyZWZTZXFCeXRlcywgIiBieXRlcy4iKSk7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdCgicmV0dXJuIiwgdGhpcy5fcmVhZFJlZlNlcXMoc3RhcnQsIHJlZlNlcUJ5dGVzICogMiwgb3B0cykpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMzI6CiAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDE5OwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAzNToKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KCJyZXR1cm4iLCB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNoclRvSW5kZXgsCiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4VG9DaHIKICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMzY6CiAgICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSwgX2NhbGxlZTMsIHRoaXMpOwogICAgICAgICAgICB9KSk7CiAgICAgICAgICAgIGZ1bmN0aW9uIF9yZWFkUmVmU2VxcyhfeCwgX3gyKSB7CiAgICAgICAgICAgICAgcmV0dXJuIF9yZWFkUmVmU2VxczIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gX3JlYWRSZWZTZXFzOwogICAgICAgICAgfSgpCiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiZ2V0UmVjb3Jkc0ZvclJhbmdlIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgdmFyIF9nZXRSZWNvcmRzRm9yUmFuZ2UgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKC8qIEBfX1BVUkVfXyAqLyBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KGNociwgbWluLCBtYXgpIHsKICAgICAgICAgICAgICB2YXIgb3B0cywgcmVjb3JkcywgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiwgX2RpZEl0ZXJhdG9yRXJyb3IsIF9pdGVyYXRvckVycm9yLCBfaXRlcmF0b3IsIF9zdGVwLCBfdmFsdWUsIGNodW5rLCBfYXJnczQgPSBhcmd1bWVudHM7CiAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NSkgewogICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgICAgb3B0cyA9IF9hcmdzNC5sZW5ndGggPiAzICYmIF9hcmdzNFszXSAhPT0gdm9pZCAwID8gX2FyZ3M0WzNdIDogewogICAgICAgICAgICAgICAgICAgICAgICB2aWV3QXNQYWlyczogZmFsc2UsCiAgICAgICAgICAgICAgICAgICAgICAgIHBhaXJBY3Jvc3NDaHI6IGZhbHNlLAogICAgICAgICAgICAgICAgICAgICAgICBtYXhJbnNlcnRTaXplOiAyZTUKICAgICAgICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICAgICAgICByZWNvcmRzID0gW107CiAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTsKICAgICAgICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDQ7CiAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IgPSAoMCwgX2FzeW5jSXRlcmF0b3IyLmRlZmF1bHQpKHRoaXMuc3RyZWFtUmVjb3Jkc0ZvclJhbmdlKGNociwgbWluLCBtYXgsIG9wdHMpKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDY6CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDg7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2l0ZXJhdG9yLm5leHQoKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDg6CiAgICAgICAgICAgICAgICAgICAgICBfc3RlcCA9IF9jb250ZXh0NS5zZW50OwogICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IF9zdGVwLmRvbmU7CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDEyOwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zdGVwLnZhbHVlOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6CiAgICAgICAgICAgICAgICAgICAgICBfdmFsdWUgPSBfY29udGV4dDUuc2VudDsKICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTk7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgY2h1bmsgPSBfdmFsdWU7CiAgICAgICAgICAgICAgICAgICAgICByZWNvcmRzID0gKDAsIF9jb25jYXQuZGVmYXVsdCkocmVjb3JkcykuY2FsbChyZWNvcmRzLCBjaHVuayk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNjoKICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlOwogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA2OwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOToKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMjU7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICBjYXNlIDIxOgogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSAyMTsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS50MCA9IF9jb250ZXh0NVsiY2F0Y2giXSg0KTsKICAgICAgICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTsKICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gX2NvbnRleHQ1LnQwOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMjU6CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDI1OwogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSAyNjsKICAgICAgICAgICAgICAgICAgICAgIGlmICghKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAzMDsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDMwOwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9pdGVyYXRvci5yZXR1cm4oKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDMwOgogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSAzMDsKICAgICAgICAgICAgICAgICAgICAgIGlmICghX2RpZEl0ZXJhdG9yRXJyb3IpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAzMzsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjsKICAgICAgICAgICAgICAgICAgICBjYXNlIDMzOgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5maW5pc2goMzApOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMzQ6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmZpbmlzaCgyNSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAzNToKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KCJyZXR1cm4iLCByZWNvcmRzKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDM2OgogICAgICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0sIF9jYWxsZWU0LCB0aGlzLCBbWzQsIDIxLCAyNSwgMzVdLCBbMjYsICwgMzAsIDM0XV0pOwogICAgICAgICAgICB9KSk7CiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFJlY29yZHNGb3JSYW5nZShfeDMsIF94NCwgX3g1KSB7CiAgICAgICAgICAgICAgcmV0dXJuIF9nZXRSZWNvcmRzRm9yUmFuZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gZ2V0UmVjb3Jkc0ZvclJhbmdlOwogICAgICAgICAgfSgpCiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAic3RyZWFtUmVjb3Jkc0ZvclJhbmdlIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdHJlYW1SZWNvcmRzRm9yUmFuZ2UoY2hyLCBtaW4sIG1heCkgewogICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzOwogICAgICAgICAgICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzNdIDogewogICAgICAgICAgICAgIHZpZXdBc1BhaXJzOiBmYWxzZSwKICAgICAgICAgICAgICBwYWlyQWNyb3NzQ2hyOiBmYWxzZSwKICAgICAgICAgICAgICBtYXhJbnNlcnRTaXplOiAyZTUKICAgICAgICAgICAgfTsKICAgICAgICAgICAgcmV0dXJuICgwLCBfd3JhcEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KSgvKiBAX19QVVJFX18gKi8gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlNSgpIHsKICAgICAgICAgICAgICB2YXIgX2NvbnRleHQ3OwogICAgICAgICAgICAgIHZhciBjaHJJZCwgY2h1bmtzLCBpLCBzaXplLCBfY29udGV4dDYsIHRvdGFsU2l6ZSwgX2NvbnRleHQ4OwogICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDkpIHsKICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ5LnByZXYgPSBfY29udGV4dDkubmV4dCkgewogICAgICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgICAgIG9wdHMudmlld0FzUGFpcnMgPSBvcHRzLnZpZXdBc1BhaXJzIHx8IGZhbHNlOwogICAgICAgICAgICAgICAgICAgICAgb3B0cy5wYWlyQWNyb3NzQ2hyID0gb3B0cy5wYWlyQWNyb3NzQ2hyIHx8IGZhbHNlOwogICAgICAgICAgICAgICAgICAgICAgb3B0cy5tYXhJbnNlcnRTaXplID0gb3B0cy5tYXhJbnNlcnRTaXplICE9PSB2b2lkIDAgPyBvcHRzLm1heEluc2VydFNpemUgOiAyZTU7CiAgICAgICAgICAgICAgICAgICAgICBjaHJJZCA9IF90aGlzLmNoclRvSW5kZXggJiYgX3RoaXMuY2hyVG9JbmRleFtjaHJdOwogICAgICAgICAgICAgICAgICAgICAgaWYgKGNocklkID49IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSA4OwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGNodW5rcyA9IFtdOwogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAxMzsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIGNhc2UgODoKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMTA7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfdGhpcy5pbmRleC5ibG9ja3NGb3JSYW5nZShjaHJJZCwgbWluIC0gMSwgbWF4LCBvcHRzKSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDoKICAgICAgICAgICAgICAgICAgICAgIGNodW5rcyA9IF9jb250ZXh0OS5zZW50OwogICAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rcykgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDEzOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiRXJyb3IgaW4gaW5kZXggZmV0Y2giKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOgogICAgICAgICAgICAgICAgICAgICAgaSA9IDA7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDoKICAgICAgICAgICAgICAgICAgICAgIGlmICghKGkgPCBjaHVua3MubGVuZ3RoKSkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDIzOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMTc7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KSgoMCwgX3V0aWwuYWJvcnRCcmVha1BvaW50KShvcHRzLnNpZ25hbCkpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTc6CiAgICAgICAgICAgICAgICAgICAgICBzaXplID0gY2h1bmtzW2ldLmZldGNoZWRTaXplKCk7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIShzaXplID4gX3RoaXMuY2h1bmtTaXplTGltaXQpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMjA7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCgwLCBfY29uY2F0LmRlZmF1bHQpKF9jb250ZXh0NiA9ICJUb28gbWFueSBCQU0gZmVhdHVyZXMuIEJBTSBjaHVuayBzaXplICIuY29uY2F0KHNpemUsICIgYnl0ZXMgZXhjZWVkcyBjaHVua1NpemVMaW1pdCBvZiAiKSkuY2FsbChfY29udGV4dDYsIF90aGlzLmNodW5rU2l6ZUxpbWl0KSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMDoKICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMTQ7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICBjYXNlIDIzOgogICAgICAgICAgICAgICAgICAgICAgdG90YWxTaXplID0gKDAsIF9yZWR1Y2UuZGVmYXVsdCkoX2NvbnRleHQ3ID0gKDAsIF9tYXAuZGVmYXVsdCkoY2h1bmtzKS5jYWxsKGNodW5rcywgZnVuY3Rpb24ocykgewogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5mZXRjaGVkU2l6ZSgpOwogICAgICAgICAgICAgICAgICAgICAgfSkpLmNhbGwoX2NvbnRleHQ3LCBmdW5jdGlvbihhLCBiKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhICsgYjsKICAgICAgICAgICAgICAgICAgICAgIH0sIDApOwogICAgICAgICAgICAgICAgICAgICAgaWYgKCEodG90YWxTaXplID4gX3RoaXMuZmV0Y2hTaXplTGltaXQpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMjY7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCgwLCBfY29uY2F0LmRlZmF1bHQpKF9jb250ZXh0OCA9ICJkYXRhIHNpemUgb2YgIi5jb25jYXQodG90YWxTaXplLnRvTG9jYWxlU3RyaW5nKCksICIgYnl0ZXMgZXhjZWVkZWQgZmV0Y2ggc2l6ZSBsaW1pdCBvZiAiKSkuY2FsbChfY29udGV4dDgsIF90aGlzLmZldGNoU2l6ZUxpbWl0LnRvTG9jYWxlU3RyaW5nKCksICIgYnl0ZXMiKSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAyNjoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuZGVsZWdhdGVZaWVsZCgoMCwgX2FzeW5jR2VuZXJhdG9yRGVsZWdhdGUyLmRlZmF1bHQpKCgwLCBfYXN5bmNJdGVyYXRvcjIuZGVmYXVsdCkoX3RoaXMuX2ZldGNoQ2h1bmtGZWF0dXJlcyhjaHVua3MsIGNocklkLCBtaW4sIG1heCwgb3B0cykpLCBfYXdhaXRBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCksICJ0MCIsIDI3KTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDI3OgogICAgICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LnN0b3AoKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0sIF9jYWxsZWU1KTsKICAgICAgICAgICAgfSkpKCk7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiX2ZldGNoQ2h1bmtGZWF0dXJlcyIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZldGNoQ2h1bmtGZWF0dXJlcyhjaHVua3MsIGNocklkLCBtaW4sIG1heCwgb3B0cykgewogICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpczsKICAgICAgICAgICAgcmV0dXJuICgwLCBfd3JhcEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KSgvKiBAX19QVVJFX18gKi8gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlNigpIHsKICAgICAgICAgICAgICB2YXIgZmVhdFByb21pc2VzLCBkb25lLCBpLCBjLCBfeWllbGQkX2F3YWl0QXN5bmNHZW4sIGRhdGEsIGNwb3NpdGlvbnMsIGRwb3NpdGlvbnMsIGNodW5rLCBwcm9taXNlLCBfaTI7CiAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0MTApIHsKICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMC5wcmV2ID0gX2NvbnRleHQxMC5uZXh0KSB7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgICAgZmVhdFByb21pc2VzID0gW107CiAgICAgICAgICAgICAgICAgICAgICBkb25lID0gZmFsc2U7CiAgICAgICAgICAgICAgICAgICAgICBpID0gMDsKICAgICAgICAgICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpIDwgY2h1bmtzLmxlbmd0aCkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gMjE7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgYyA9IGNodW5rc1tpXTsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDc7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfdGhpczIuZmVhdHVyZUNhY2hlLmdldChjLnRvU3RyaW5nKCksIHsKICAgICAgICAgICAgICAgICAgICAgICAgY2h1bms6IGMsCiAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMKICAgICAgICAgICAgICAgICAgICAgIH0sIG9wdHMuc2lnbmFsKSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OgogICAgICAgICAgICAgICAgICAgICAgX3lpZWxkJF9hd2FpdEFzeW5jR2VuID0gX2NvbnRleHQxMC5zZW50OwogICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF95aWVsZCRfYXdhaXRBc3luY0dlbi5kYXRhOwogICAgICAgICAgICAgICAgICAgICAgY3Bvc2l0aW9ucyA9IF95aWVsZCRfYXdhaXRBc3luY0dlbi5jcG9zaXRpb25zOwogICAgICAgICAgICAgICAgICAgICAgZHBvc2l0aW9ucyA9IF95aWVsZCRfYXdhaXRBc3luY0dlbi5kcG9zaXRpb25zOwogICAgICAgICAgICAgICAgICAgICAgY2h1bmsgPSBfeWllbGQkX2F3YWl0QXN5bmNHZW4uY2h1bms7CiAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gX3RoaXMyLnJlYWRCYW1GZWF0dXJlcyhkYXRhLCBjcG9zaXRpb25zLCBkcG9zaXRpb25zLCBjaHVuaykudGhlbihmdW5jdGlvbihyZWNvcmRzKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWNzID0gW107CiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCByZWNvcmRzLmxlbmd0aDsgX2kgKz0gMSkgewogICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlID0gcmVjb3Jkc1tfaV07CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUuc2VxX2lkKCkgPT09IGNocklkKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5nZXQoInN0YXJ0IikgPj0gbWF4KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmVhdHVyZS5nZXQoImVuZCIpID49IG1pbikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNzLnB1c2goZmVhdHVyZSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWNzOwogICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgICBmZWF0UHJvbWlzZXMucHVzaChwcm9taXNlKTsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDE2OwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfYXdhaXRBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkocHJvbWlzZSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNjoKICAgICAgICAgICAgICAgICAgICAgIGlmICghZG9uZSkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAxODsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoImJyZWFrIiwgMjEpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTg6CiAgICAgICAgICAgICAgICAgICAgICBpKys7CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAzOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMToKICAgICAgICAgICAgICAgICAgICAgICgwLCBfdXRpbC5jaGVja0Fib3J0U2lnbmFsKShvcHRzLnNpZ25hbCk7CiAgICAgICAgICAgICAgICAgICAgICBfaTIgPSAwOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMjM6CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfaTIgPCBmZWF0UHJvbWlzZXMubGVuZ3RoKSkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAyOTsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAyNjsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmZWF0UHJvbWlzZXNbX2kyXTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDI2OgogICAgICAgICAgICAgICAgICAgICAgX2kyKys7CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAyMzsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMjk6CiAgICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWwuY2hlY2tBYm9ydFNpZ25hbCkob3B0cy5zaWduYWwpOwogICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRzLnZpZXdBc1BhaXJzKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDMzOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDMzOwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5mZXRjaFBhaXJzKGNocklkLCBmZWF0UHJvbWlzZXMsIG9wdHMpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMzM6CiAgICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLnN0b3AoKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0sIF9jYWxsZWU2KTsKICAgICAgICAgICAgfSkpKCk7CiAgICAgICAgICB9CiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiZmV0Y2hQYWlycyIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciBfZmV0Y2hQYWlycyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEwKGNocklkLCBmZWF0UHJvbWlzZXMsIG9wdHMpIHsKICAgICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcywgX2NvbnRleHQxNCwgX2NvbnRleHQxNTsKICAgICAgICAgICAgICB2YXIgdW5tYXRlZFBhaXJzLCByZWFkSWRzLCBtYXRlUHJvbWlzZXMsIG1hdGVCbG9ja3MsIG1hdGVDaHVua3MsIGksIG1hdGVUb3RhbFNpemUsIF9jb250ZXh0MTYsIG1hdGVGZWF0UHJvbWlzZXMsIG5ld01hdGVGZWF0cywgZmVhdHVyZXNSZXQsIG5ld01hdGVzOwogICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMCQoX2NvbnRleHQxOCkgewogICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDE4LnByZXYgPSBfY29udGV4dDE4Lm5leHQpIHsKICAgICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgICB1bm1hdGVkUGFpcnMgPSB7fTsKICAgICAgICAgICAgICAgICAgICAgIHJlYWRJZHMgPSB7fTsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTgubmV4dCA9IDQ7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3Byb21pc2UuZGVmYXVsdC5hbGwoKDAsIF9tYXAuZGVmYXVsdCkoZmVhdFByb21pc2VzKS5jYWxsKGZlYXRQcm9taXNlcywgLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKC8qIEBfX1BVUkVfXyAqLyBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KGYpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2NvbnRleHQxMTsKICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0LCByZWFkTmFtZXMsIGkyLCBuYW1lLCBpZDsKICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQxMikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDEyLnByZXYgPSBfY29udGV4dDEyLm5leHQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSAyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGY7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gX2NvbnRleHQxMi5zZW50OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZE5hbWVzID0ge307CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkyID0gMDsgaTIgPCByZXQubGVuZ3RoOyBpMisrKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSByZXRbaTJdLm5hbWUoKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSByZXRbaTJdLmlkKCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVhZE5hbWVzW25hbWVdKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZE5hbWVzW25hbWVdID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkTmFtZXNbbmFtZV0rKzsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZElkc1tpZF0gPSAxOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9mb3JFYWNoLmRlZmF1bHQpKF9jb250ZXh0MTEgPSAoMCwgX29iamVjdC5kZWZhdWx0KShyZWFkTmFtZXMpKS5jYWxsKF9jb250ZXh0MTEsIGZ1bmN0aW9uKF9yZWYzKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmNCA9ICgwLCBfc2xpY2VkVG9BcnJheTIuZGVmYXVsdCkoX3JlZjMsIDIpLCBrID0gX3JlZjRbMF0sIHYgPSBfcmVmNFsxXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYgPT09IDEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bm1hdGVkUGFpcnNba10gPSB0cnVlOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLnN0b3AoKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWU3KTsKICAgICAgICAgICAgICAgICAgICAgICAgfSkpOwogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oX3g5KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICAgICAgICB9KCkpKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6CiAgICAgICAgICAgICAgICAgICAgICBtYXRlUHJvbWlzZXMgPSBbXTsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTgubmV4dCA9IDc7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3Byb21pc2UuZGVmYXVsdC5hbGwoKDAsIF9tYXAuZGVmYXVsdCkoZmVhdFByb21pc2VzKS5jYWxsKGZlYXRQcm9taXNlcywgLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjUgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKC8qIEBfX1BVUkVfXyAqLyBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU4KGYpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0LCBpMiwgbmFtZTsKICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlOCQoX2NvbnRleHQxMykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDEzLnByZXYgPSBfY29udGV4dDEzLm5leHQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDEzLm5leHQgPSAyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGY7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gX2NvbnRleHQxMy5zZW50OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpMiA9IDA7IGkyIDwgcmV0Lmxlbmd0aDsgaTIrKykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gcmV0W2kyXS5uYW1lKCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bm1hdGVkUGFpcnNbbmFtZV0gJiYgKG9wdHMucGFpckFjcm9zc0NociB8fCByZXRbaTJdLl9uZXh0X3JlZmlkKCkgPT09IGNocklkICYmIE1hdGguYWJzKHJldFtpMl0uZ2V0KCJzdGFydCIpIC0gcmV0W2kyXS5fbmV4dF9wb3MoKSkgPCAob3B0cy5tYXhJbnNlcnRTaXplIHx8IDJlNSkpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZVByb21pc2VzLnB1c2goX3RoaXMzLmluZGV4LmJsb2Nrc0ZvclJhbmdlKHJldFtpMl0uX25leHRfcmVmaWQoKSwgcmV0W2kyXS5fbmV4dF9wb3MoKSwgcmV0W2kyXS5fbmV4dF9wb3MoKSArIDEsIG9wdHMpKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTMuc3RvcCgpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZTgpOwogICAgICAgICAgICAgICAgICAgICAgICB9KSk7CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihfeDEwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWY1LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICAgICAgICB9KCkpKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDc6CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDE4Lm5leHQgPSA5OwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9taXNlLmRlZmF1bHQuYWxsKG1hdGVQcm9taXNlcyk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OgogICAgICAgICAgICAgICAgICAgICAgbWF0ZUJsb2NrcyA9IF9jb250ZXh0MTguc2VudDsKICAgICAgICAgICAgICAgICAgICAgIG1hdGVDaHVua3MgPSBbXTsKICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtYXRlQmxvY2tzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVDaHVua3MgPSAoMCwgX2NvbmNhdC5kZWZhdWx0KShtYXRlQ2h1bmtzKS5jYWxsKG1hdGVDaHVua3MsIG1hdGVCbG9ja3NbaV0pOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgbWF0ZUNodW5rcyA9ICgwLCBfZmlsdGVyLmRlZmF1bHQpKF9jb250ZXh0MTQgPSAoMCwgX3NvcnQuZGVmYXVsdCkobWF0ZUNodW5rcykuY2FsbChtYXRlQ2h1bmtzKSkuY2FsbChfY29udGV4dDE0LCBmdW5jdGlvbihpdGVtLCBwb3MsIGFyeSkgewogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXBvcyB8fCBpdGVtLnRvU3RyaW5nKCkgIT09IGFyeVtwb3MgLSAxXS50b1N0cmluZygpOwogICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgICBtYXRlVG90YWxTaXplID0gKDAsIF9yZWR1Y2UuZGVmYXVsdCkoX2NvbnRleHQxNSA9ICgwLCBfbWFwLmRlZmF1bHQpKG1hdGVDaHVua3MpLmNhbGwobWF0ZUNodW5rcywgZnVuY3Rpb24ocykgewogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5mZXRjaGVkU2l6ZSgpOwogICAgICAgICAgICAgICAgICAgICAgfSkpLmNhbGwoX2NvbnRleHQxNSwgZnVuY3Rpb24oYSwgYikgewogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSArIGI7CiAgICAgICAgICAgICAgICAgICAgICB9LCAwKTsKICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1hdGVUb3RhbFNpemUgPiB0aGlzLmZldGNoU2l6ZUxpbWl0KSkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDE4Lm5leHQgPSAxNjsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKDAsIF9jb25jYXQuZGVmYXVsdCkoX2NvbnRleHQxNiA9ICJkYXRhIHNpemUgb2YgIi5jb25jYXQobWF0ZVRvdGFsU2l6ZS50b0xvY2FsZVN0cmluZygpLCAiIGJ5dGVzIGV4Y2VlZGVkIGZldGNoIHNpemUgbGltaXQgb2YgIikpLmNhbGwoX2NvbnRleHQxNiwgdGhpcy5mZXRjaFNpemVMaW1pdC50b0xvY2FsZVN0cmluZygpLCAiIGJ5dGVzIikpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6CiAgICAgICAgICAgICAgICAgICAgICBtYXRlRmVhdFByb21pc2VzID0gKDAsIF9tYXAuZGVmYXVsdCkobWF0ZUNodW5rcykuY2FsbChtYXRlQ2h1bmtzLCAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmNiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTkoYykgewogICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfeWllbGQkX3RoaXMzJGZlYXR1cmUsIGRhdGEsIGNwb3NpdGlvbnMsIGRwb3NpdGlvbnMsIGNodW5rLCBmZWF0cywgbWF0ZVJlY3MsIF9pMywgZmVhdHVyZTsKICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlOSQoX2NvbnRleHQxNykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDE3LnByZXYgPSBfY29udGV4dDE3Lm5leHQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDE3Lm5leHQgPSAyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5mZWF0dXJlQ2FjaGUuZ2V0KGMudG9TdHJpbmcoKSwgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuazogYywKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgb3B0cy5zaWduYWwpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF95aWVsZCRfdGhpczMkZmVhdHVyZSA9IF9jb250ZXh0MTcuc2VudDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfeWllbGQkX3RoaXMzJGZlYXR1cmUuZGF0YTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNwb3NpdGlvbnMgPSBfeWllbGQkX3RoaXMzJGZlYXR1cmUuY3Bvc2l0aW9uczsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRwb3NpdGlvbnMgPSBfeWllbGQkX3RoaXMzJGZlYXR1cmUuZHBvc2l0aW9uczsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rID0gX3lpZWxkJF90aGlzMyRmZWF0dXJlLmNodW5rOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxNy5uZXh0ID0gOTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczMucmVhZEJhbUZlYXR1cmVzKGRhdGEsIGNwb3NpdGlvbnMsIGRwb3NpdGlvbnMsIGNodW5rKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0cyA9IF9jb250ZXh0MTcuc2VudDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVSZWNzID0gW107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKF9pMyA9IDA7IF9pMyA8IGZlYXRzLmxlbmd0aDsgX2kzICs9IDEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZSA9IGZlYXRzW19pM107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bm1hdGVkUGFpcnNbZmVhdHVyZS5nZXQoIm5hbWUiKV0gJiYgIXJlYWRJZHNbZmVhdHVyZS5pZCgpXSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVSZWNzLnB1c2goZmVhdHVyZSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE3LmFicnVwdCgicmV0dXJuIiwgbWF0ZVJlY3MpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE3LnN0b3AoKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWU5KTsKICAgICAgICAgICAgICAgICAgICAgICAgfSkpOwogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oX3gxMSkgewogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmNi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgICAgICAgICAgfSgpKTsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTgubmV4dCA9IDE5OwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9taXNlLmRlZmF1bHQuYWxsKG1hdGVGZWF0UHJvbWlzZXMpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTk6CiAgICAgICAgICAgICAgICAgICAgICBuZXdNYXRlRmVhdHMgPSBfY29udGV4dDE4LnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlc1JldCA9IFtdOwogICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld01hdGVGZWF0cy5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgbmV3TWF0ZXMgPSAoMCwgX3JlZHVjZS5kZWZhdWx0KShuZXdNYXRlRmVhdHMpLmNhbGwobmV3TWF0ZUZlYXRzLCBmdW5jdGlvbihyZXN1bHQsIGN1cnJlbnQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9jb25jYXQuZGVmYXVsdCkocmVzdWx0KS5jYWxsKHJlc3VsdCwgY3VycmVudCk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlc1JldCA9ICgwLCBfY29uY2F0LmRlZmF1bHQpKGZlYXR1cmVzUmV0KS5jYWxsKGZlYXR1cmVzUmV0LCBuZXdNYXRlcyk7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxOC5hYnJ1cHQoInJldHVybiIsIGZlYXR1cmVzUmV0KTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDIzOgogICAgICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxOC5zdG9wKCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9LCBfY2FsbGVlMTAsIHRoaXMpOwogICAgICAgICAgICB9KSk7CiAgICAgICAgICAgIGZ1bmN0aW9uIGZldGNoUGFpcnMoX3g2LCBfeDcsIF94OCkgewogICAgICAgICAgICAgIHJldHVybiBfZmV0Y2hQYWlycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBmZXRjaFBhaXJzOwogICAgICAgICAgfSgpCiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiX3JlYWRDaHVuayIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciBfcmVhZENodW5rMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTExKF9yZWY3LCBhYm9ydFNpZ25hbCkgewogICAgICAgICAgICAgIHZhciBjaHVuaywgb3B0cywgYywgYnVmc2l6ZSwgcmVzLCBieXRlc1JlYWQsIGJ1ZmZlciwgX3lpZWxkJHVuemlwQ2h1bmtTbGljLCBkYXRhLCBjcG9zaXRpb25zLCBkcG9zaXRpb25zOwogICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMSQoX2NvbnRleHQxOSkgewogICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDE5LnByZXYgPSBfY29udGV4dDE5Lm5leHQpIHsKICAgICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgICBjaHVuayA9IF9yZWY3LmNodW5rLCBvcHRzID0gX3JlZjcub3B0czsKICAgICAgICAgICAgICAgICAgICAgIGMgPSBjaHVuazsKICAgICAgICAgICAgICAgICAgICAgIGJ1ZnNpemUgPSBjLmZldGNoZWRTaXplKCk7CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDE5Lm5leHQgPSA1OwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFtLnJlYWQoaW1wb3J0X2J1ZmZlci5CdWZmZXIuYWxsb2MoYnVmc2l6ZSksIDAsIGJ1ZnNpemUsIGMubWludi5ibG9ja1Bvc2l0aW9uLCBvcHRzKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDU6CiAgICAgICAgICAgICAgICAgICAgICByZXMgPSBfY29udGV4dDE5LnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgICBieXRlc1JlYWQgPSByZXMuYnl0ZXNSZWFkOwogICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gcmVzLmJ1ZmZlcjsKICAgICAgICAgICAgICAgICAgICAgICgwLCBfdXRpbC5jaGVja0Fib3J0U2lnbmFsKShhYm9ydFNpZ25hbCk7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZXNSZWFkKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTkubmV4dCA9IDExOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE5LmFicnVwdCgicmV0dXJuIiwgW10pOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6CiAgICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZXNSZWFkIDwgYnVmc2l6ZSkgewogICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSAoMCwgX3NsaWNlLmRlZmF1bHQpKGJ1ZmZlcikuY2FsbChidWZmZXIsIDAsIGJ5dGVzUmVhZCk7CiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSAoMCwgX3NsaWNlLmRlZmF1bHQpKGJ1ZmZlcikuY2FsbChidWZmZXIsIDAsIGJ1ZnNpemUpOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxOS5uZXh0ID0gMTQ7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9iZ3pmRmlsZWhhbmRsZS51bnppcENodW5rU2xpY2UpKGJ1ZmZlciwgY2h1bmspOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6CiAgICAgICAgICAgICAgICAgICAgICBfeWllbGQkdW56aXBDaHVua1NsaWMgPSBfY29udGV4dDE5LnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX3lpZWxkJHVuemlwQ2h1bmtTbGljLmJ1ZmZlcjsKICAgICAgICAgICAgICAgICAgICAgIGNwb3NpdGlvbnMgPSBfeWllbGQkdW56aXBDaHVua1NsaWMuY3Bvc2l0aW9uczsKICAgICAgICAgICAgICAgICAgICAgIGRwb3NpdGlvbnMgPSBfeWllbGQkdW56aXBDaHVua1NsaWMuZHBvc2l0aW9uczsKICAgICAgICAgICAgICAgICAgICAgICgwLCBfdXRpbC5jaGVja0Fib3J0U2lnbmFsKShhYm9ydFNpZ25hbCk7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxOS5hYnJ1cHQoInJldHVybiIsIHsKICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSwKICAgICAgICAgICAgICAgICAgICAgICAgY3Bvc2l0aW9ucywKICAgICAgICAgICAgICAgICAgICAgICAgZHBvc2l0aW9ucywKICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsKICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMjA6CiAgICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE5LnN0b3AoKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0sIF9jYWxsZWUxMSwgdGhpcyk7CiAgICAgICAgICAgIH0pKTsKICAgICAgICAgICAgZnVuY3Rpb24gX3JlYWRDaHVuayhfeDEyLCBfeDEzKSB7CiAgICAgICAgICAgICAgcmV0dXJuIF9yZWFkQ2h1bmsyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIF9yZWFkQ2h1bms7CiAgICAgICAgICB9KCkKICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJyZWFkQmFtRmVhdHVyZXMiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgX3JlYWRCYW1GZWF0dXJlcyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEyKGJhLCBjcG9zaXRpb25zLCBkcG9zaXRpb25zLCBjaHVuaykgewogICAgICAgICAgICAgIHZhciBibG9ja1N0YXJ0LCBzaW5rLCBwb3MsIGxhc3QsIGJsb2NrU2l6ZSwgYmxvY2tFbmQsIGZlYXR1cmU7CiAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTEyJChfY29udGV4dDIwKSB7CiAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MjAucHJldiA9IF9jb250ZXh0MjAubmV4dCkgewogICAgICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgICAgIGJsb2NrU3RhcnQgPSAwOwogICAgICAgICAgICAgICAgICAgICAgc2luayA9IFtdOwogICAgICAgICAgICAgICAgICAgICAgcG9zID0gMDsKICAgICAgICAgICAgICAgICAgICAgIGxhc3QgPSArKDAsIF9ub3cuZGVmYXVsdCkoKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIShibG9ja1N0YXJ0ICsgNCA8IGJhLmxlbmd0aCkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyMC5uZXh0ID0gMTg7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgYmxvY2tTaXplID0gYmEucmVhZEludDMyTEUoYmxvY2tTdGFydCk7CiAgICAgICAgICAgICAgICAgICAgICBibG9ja0VuZCA9IGJsb2NrU3RhcnQgKyA0ICsgYmxvY2tTaXplIC0gMTsKICAgICAgICAgICAgICAgICAgICAgIGlmIChkcG9zaXRpb25zKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChibG9ja1N0YXJ0ICsgY2h1bmsubWludi5kYXRhUG9zaXRpb24gPj0gZHBvc2l0aW9uc1twb3MrK10pIHsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBwb3MtLTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGlmICghKGJsb2NrRW5kIDwgYmEubGVuZ3RoKSkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIwLm5leHQgPSAxNTsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlID0gbmV3IF9yZWNvcmQuZGVmYXVsdCh7CiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5OiBiYSwKICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogYmxvY2tTdGFydCwKICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGJsb2NrRW5kCiAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVPZmZzZXQ6IGNwb3NpdGlvbnMgPyBjcG9zaXRpb25zW3Bvc10gKiAoMSA8PCA4KSArIChibG9ja1N0YXJ0IC0gZHBvc2l0aW9uc1twb3NdKSArIGNodW5rLm1pbnYuZGF0YVBvc2l0aW9uICsgMSA6IF9idWZmZXJDcmMuZGVmYXVsdC5zaWduZWQoKDAsIF9zbGljZS5kZWZhdWx0KShiYSkuY2FsbChiYSwgYmxvY2tTdGFydCwgYmxvY2tFbmQpKQogICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgICBzaW5rLnB1c2goZmVhdHVyZSk7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0aGlzLnlpZWxkVGhyZWFkVGltZSAmJiArKDAsIF9ub3cuZGVmYXVsdCkoKSAtIGxhc3QgPiB0aGlzLnlpZWxkVGhyZWFkVGltZSkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyMC5uZXh0ID0gMTU7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyMC5uZXh0ID0gMTQ7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF91dGlsLnRpbWVvdXQpKDEpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6CiAgICAgICAgICAgICAgICAgICAgICBsYXN0ID0gKygwLCBfbm93LmRlZmF1bHQpKCk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNToKICAgICAgICAgICAgICAgICAgICAgIGJsb2NrU3RhcnQgPSBibG9ja0VuZCArIDE7CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIwLm5leHQgPSA0OwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxODoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIwLmFicnVwdCgicmV0dXJuIiwgc2luayk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOToKICAgICAgICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjAuc3RvcCgpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSwgX2NhbGxlZTEyLCB0aGlzKTsKICAgICAgICAgICAgfSkpOwogICAgICAgICAgICBmdW5jdGlvbiByZWFkQmFtRmVhdHVyZXMoX3gxNCwgX3gxNSwgX3gxNiwgX3gxNykgewogICAgICAgICAgICAgIHJldHVybiBfcmVhZEJhbUZlYXR1cmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHJlYWRCYW1GZWF0dXJlczsKICAgICAgICAgIH0oKQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogImhhc1JlZlNlcSIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciBfaGFzUmVmU2VxID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KSgvKiBAX19QVVJFX18gKi8gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMTMoc2VxTmFtZSkgewogICAgICAgICAgICAgIHZhciByZWZJZDsKICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMTMkKF9jb250ZXh0MjEpIHsKICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyMS5wcmV2ID0gX2NvbnRleHQyMS5uZXh0KSB7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgICAgcmVmSWQgPSB0aGlzLmNoclRvSW5kZXggJiYgdGhpcy5jaHJUb0luZGV4W3NlcU5hbWVdOwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjEuYWJydXB0KCJyZXR1cm4iLCB0aGlzLmluZGV4Lmhhc1JlZlNlcShyZWZJZCkpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjEuc3RvcCgpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSwgX2NhbGxlZTEzLCB0aGlzKTsKICAgICAgICAgICAgfSkpOwogICAgICAgICAgICBmdW5jdGlvbiBoYXNSZWZTZXEoX3gxOCkgewogICAgICAgICAgICAgIHJldHVybiBfaGFzUmVmU2VxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGhhc1JlZlNlcTsKICAgICAgICAgIH0oKQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogImxpbmVDb3VudCIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciBfbGluZUNvdW50ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KSgvKiBAX19QVVJFX18gKi8gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMTQoc2VxTmFtZSkgewogICAgICAgICAgICAgIHZhciByZWZJZDsKICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMTQkKF9jb250ZXh0MjIpIHsKICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyMi5wcmV2ID0gX2NvbnRleHQyMi5uZXh0KSB7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgICAgcmVmSWQgPSB0aGlzLmNoclRvSW5kZXggJiYgdGhpcy5jaHJUb0luZGV4W3NlcU5hbWVdOwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjIuYWJydXB0KCJyZXR1cm4iLCB0aGlzLmluZGV4LmxpbmVDb3VudChyZWZJZCkpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjIuc3RvcCgpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSwgX2NhbGxlZTE0LCB0aGlzKTsKICAgICAgICAgICAgfSkpOwogICAgICAgICAgICBmdW5jdGlvbiBsaW5lQ291bnQoX3gxOSkgewogICAgICAgICAgICAgIHJldHVybiBfbGluZUNvdW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGxpbmVDb3VudDsKICAgICAgICAgIH0oKQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogImluZGV4Q292IiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgdmFyIF9pbmRleENvdiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTE1KHNlcU5hbWUsIHN0YXJ0LCBlbmQpIHsKICAgICAgICAgICAgICB2YXIgc2VxSWQ7CiAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTE1JChfY29udGV4dDIzKSB7CiAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MjMucHJldiA9IF9jb250ZXh0MjMubmV4dCkgewogICAgICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjMubmV4dCA9IDI7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleC5wYXJzZSgpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgICAgICAgIHNlcUlkID0gdGhpcy5jaHJUb0luZGV4ICYmIHRoaXMuY2hyVG9JbmRleFtzZXFOYW1lXTsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIzLmFicnVwdCgicmV0dXJuIiwgdGhpcy5pbmRleC5pbmRleENvdihzZXFJZCwgc3RhcnQsIGVuZCkpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgNDoKICAgICAgICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjMuc3RvcCgpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSwgX2NhbGxlZTE1LCB0aGlzKTsKICAgICAgICAgICAgfSkpOwogICAgICAgICAgICBmdW5jdGlvbiBpbmRleENvdihfeDIwLCBfeDIxLCBfeDIyKSB7CiAgICAgICAgICAgICAgcmV0dXJuIF9pbmRleENvdi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBpbmRleENvdjsKICAgICAgICAgIH0oKQogICAgICAgIH1dKTsKICAgICAgICByZXR1cm4gQmFtRmlsZTM7CiAgICAgIH0oKTsKICAgICAgZXhwb3J0cy5kZWZhdWx0ID0gQmFtRmlsZTI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZmVhdHVyZXMvb2JqZWN0L2dldC1vd24tcHJvcGVydHktc3ltYm9scy5qcwogIHZhciByZXF1aXJlX2dldF9vd25fcHJvcGVydHlfc3ltYm9sczQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ZlYXR1cmVzL29iamVjdC9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBwYXJlbnQgPSByZXF1aXJlX2dldF9vd25fcHJvcGVydHlfc3ltYm9sczIoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMvb2JqZWN0L2dldC1vd24tcHJvcGVydHktc3ltYm9scy5qcwogIHZhciByZXF1aXJlX2dldF9vd25fcHJvcGVydHlfc3ltYm9sczUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzL29iamVjdC9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZV9nZXRfb3duX3Byb3BlcnR5X3N5bWJvbHM0KCk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5hcnJheS5pbmRleC1vZi5qcwogIHZhciByZXF1aXJlX2VzX2FycmF5X2luZGV4X29mID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLmFycmF5LmluZGV4LW9mLmpzIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciAkID0gcmVxdWlyZV9leHBvcnQoKTsKICAgICAgdmFyICRpbmRleE9mID0gcmVxdWlyZV9hcnJheV9pbmNsdWRlcygpLmluZGV4T2Y7CiAgICAgIHZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gcmVxdWlyZV9hcnJheV9tZXRob2RfaXNfc3RyaWN0KCk7CiAgICAgIHZhciBuYXRpdmVJbmRleE9mID0gW10uaW5kZXhPZjsKICAgICAgdmFyIE5FR0FUSVZFX1pFUk8gPSAhIW5hdGl2ZUluZGV4T2YgJiYgMSAvIFsxXS5pbmRleE9mKDEsIC0wKSA8IDA7CiAgICAgIHZhciBTVFJJQ1RfTUVUSE9EID0gYXJyYXlNZXRob2RJc1N0cmljdCgiaW5kZXhPZiIpOwogICAgICAkKHsgdGFyZ2V0OiAiQXJyYXkiLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBORUdBVElWRV9aRVJPIHx8ICFTVFJJQ1RfTUVUSE9EIH0sIHsKICAgICAgICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQpIHsKICAgICAgICAgIHJldHVybiBORUdBVElWRV9aRVJPID8gbmF0aXZlSW5kZXhPZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDAgOiAkaW5kZXhPZih0aGlzLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMCk7CiAgICAgICAgfQogICAgICB9KTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9hcnJheS92aXJ0dWFsL2luZGV4LW9mLmpzCiAgdmFyIHJlcXVpcmVfaW5kZXhfb2YgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2FycmF5L3ZpcnR1YWwvaW5kZXgtb2YuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHJlcXVpcmVfZXNfYXJyYXlfaW5kZXhfb2YoKTsKICAgICAgdmFyIGVudHJ5VmlydHVhbCA9IHJlcXVpcmVfZW50cnlfdmlydHVhbCgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGVudHJ5VmlydHVhbCgiQXJyYXkiKS5pbmRleE9mOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2luc3RhbmNlL2luZGV4LW9mLmpzCiAgdmFyIHJlcXVpcmVfaW5kZXhfb2YyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9pbnN0YW5jZS9pbmRleC1vZi5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGluZGV4T2YgPSByZXF1aXJlX2luZGV4X29mKCk7CiAgICAgIHZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCkgewogICAgICAgIHZhciBvd24gPSBpdC5pbmRleE9mOwogICAgICAgIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUgfHwgaXQgaW5zdGFuY2VvZiBBcnJheSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlLmluZGV4T2YgPyBpbmRleE9mIDogb3duOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9pbnN0YW5jZS9pbmRleC1vZi5qcwogIHZhciByZXF1aXJlX2luZGV4X29mMyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL2luc3RhbmNlL2luZGV4LW9mLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgcGFyZW50ID0gcmVxdWlyZV9pbmRleF9vZjIoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZmVhdHVyZXMvaW5zdGFuY2UvaW5kZXgtb2YuanMKICB2YXIgcmVxdWlyZV9pbmRleF9vZjQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ZlYXR1cmVzL2luc3RhbmNlL2luZGV4LW9mLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgcGFyZW50ID0gcmVxdWlyZV9pbmRleF9vZjMoKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMvaW5zdGFuY2UvaW5kZXgtb2YuanMKICB2YXIgcmVxdWlyZV9pbmRleF9vZjUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzL2luc3RhbmNlL2luZGV4LW9mLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVfaW5kZXhfb2Y0KCk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZmVhdHVyZXMvb2JqZWN0L2tleXMuanMKICB2YXIgcmVxdWlyZV9rZXlzNCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZmVhdHVyZXMvb2JqZWN0L2tleXMuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBwYXJlbnQgPSByZXF1aXJlX2tleXMyKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGFyZW50OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzL29iamVjdC9rZXlzLmpzCiAgdmFyIHJlcXVpcmVfa2V5czUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzL29iamVjdC9rZXlzLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVfa2V5czQoKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLmpzCiAgdmFyIHJlcXVpcmVfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIF9PYmplY3Qka2V5cyA9IHJlcXVpcmVfa2V5czUoKTsKICAgICAgdmFyIF9pbmRleE9mSW5zdGFuY2VQcm9wZXJ0eSA9IHJlcXVpcmVfaW5kZXhfb2Y1KCk7CiAgICAgIGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsKICAgICAgICBpZiAoc291cmNlID09IG51bGwpCiAgICAgICAgICByZXR1cm4ge307CiAgICAgICAgdmFyIHRhcmdldCA9IHt9OwogICAgICAgIHZhciBzb3VyY2VLZXlzID0gX09iamVjdCRrZXlzKHNvdXJjZSk7CiAgICAgICAgdmFyIGtleSwgaTsKICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgewogICAgICAgICAga2V5ID0gc291cmNlS2V5c1tpXTsKICAgICAgICAgIGlmIChfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkoZXhjbHVkZWQpLmNhbGwoZXhjbHVkZWQsIGtleSkgPj0gMCkKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGFyZ2V0OwogICAgICB9CiAgICAgIG1vZHVsZS5leHBvcnRzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2U7CiAgICAgIG1vZHVsZS5leHBvcnRzWyJkZWZhdWx0Il0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXMuanMKICB2YXIgcmVxdWlyZV9vYmplY3RXaXRob3V0UHJvcGVydGllcyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXMuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBfT2JqZWN0JGdldE93blByb3BlcnR5U3ltYm9scyA9IHJlcXVpcmVfZ2V0X293bl9wcm9wZXJ0eV9zeW1ib2xzNSgpOwogICAgICB2YXIgX2luZGV4T2ZJbnN0YW5jZVByb3BlcnR5ID0gcmVxdWlyZV9pbmRleF9vZjUoKTsKICAgICAgdmFyIG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgPSByZXF1aXJlX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoKTsKICAgICAgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsKICAgICAgICBpZiAoc291cmNlID09IG51bGwpCiAgICAgICAgICByZXR1cm4ge307CiAgICAgICAgdmFyIHRhcmdldCA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7CiAgICAgICAgdmFyIGtleSwgaTsKICAgICAgICBpZiAoX09iamVjdCRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsKICAgICAgICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gX09iamVjdCRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsKICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07CiAgICAgICAgICAgIGlmIChfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkoZXhjbHVkZWQpLmNhbGwoZXhjbHVkZWQsIGtleSkgPj0gMCkKICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKQogICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gdGFyZ2V0OwogICAgICB9CiAgICAgIG1vZHVsZS5leHBvcnRzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzOwogICAgICBtb2R1bGUuZXhwb3J0c1siZGVmYXVsdCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pcy1yZWdleHAuanMKICB2YXIgcmVxdWlyZV9pc19yZWdleHAgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pcy1yZWdleHAuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBpc09iamVjdCA9IHJlcXVpcmVfaXNfb2JqZWN0KCk7CiAgICAgIHZhciBjbGFzc29mID0gcmVxdWlyZV9jbGFzc29mX3JhdygpOwogICAgICB2YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZV93ZWxsX2tub3duX3N5bWJvbCgpOwogICAgICB2YXIgTUFUQ0ggPSB3ZWxsS25vd25TeW1ib2woIm1hdGNoIik7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpIHsKICAgICAgICB2YXIgaXNSZWdFeHA7CiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiAoKGlzUmVnRXhwID0gaXRbTUFUQ0hdKSAhPT0gdm9pZCAwID8gISFpc1JlZ0V4cCA6IGNsYXNzb2YoaXQpID09ICJSZWdFeHAiKTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvbm90LWEtcmVnZXhwLmpzCiAgdmFyIHJlcXVpcmVfbm90X2FfcmVnZXhwID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvbm90LWEtcmVnZXhwLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgaXNSZWdFeHAgPSByZXF1aXJlX2lzX3JlZ2V4cCgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KSB7CiAgICAgICAgaWYgKGlzUmVnRXhwKGl0KSkgewogICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCJUaGUgbWV0aG9kIGRvZXNuJ3QgYWNjZXB0IHJlZ3VsYXIgZXhwcmVzc2lvbnMiKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGl0OwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9jb3JyZWN0LWlzLXJlZ2V4cC1sb2dpYy5qcwogIHZhciByZXF1aXJlX2NvcnJlY3RfaXNfcmVnZXhwX2xvZ2ljID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvY29ycmVjdC1pcy1yZWdleHAtbG9naWMuanMiKGV4cG9ydHMsIG1vZHVsZSkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlX3dlbGxfa25vd25fc3ltYm9sKCk7CiAgICAgIHZhciBNQVRDSCA9IHdlbGxLbm93blN5bWJvbCgibWF0Y2giKTsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihNRVRIT0RfTkFNRSkgewogICAgICAgIHZhciByZWdleHAgPSAvLi87CiAgICAgICAgdHJ5IHsKICAgICAgICAgICIvLi8iW01FVEhPRF9OQU1FXShyZWdleHApOwogICAgICAgIH0gY2F0Y2ggKGVycm9yMSkgewogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgcmVnZXhwW01BVENIXSA9IGZhbHNlOwogICAgICAgICAgICByZXR1cm4gIi8uLyJbTUVUSE9EX05BTUVdKHJlZ2V4cCk7CiAgICAgICAgICB9IGNhdGNoIChlcnJvcjIpIHsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuc3RyaW5nLnN0YXJ0cy13aXRoLmpzCiAgdmFyIHJlcXVpcmVfZXNfc3RyaW5nX3N0YXJ0c193aXRoID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN0cmluZy5zdGFydHMtd2l0aC5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgJCA9IHJlcXVpcmVfZXhwb3J0KCk7CiAgICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlX29iamVjdF9nZXRfb3duX3Byb3BlcnR5X2Rlc2NyaXB0b3IoKS5mOwogICAgICB2YXIgdG9MZW5ndGggPSByZXF1aXJlX3RvX2xlbmd0aCgpOwogICAgICB2YXIgdG9TdHJpbmcgPSByZXF1aXJlX3RvX3N0cmluZygpOwogICAgICB2YXIgbm90QVJlZ0V4cCA9IHJlcXVpcmVfbm90X2FfcmVnZXhwKCk7CiAgICAgIHZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZV9yZXF1aXJlX29iamVjdF9jb2VyY2libGUoKTsKICAgICAgdmFyIGNvcnJlY3RJc1JlZ0V4cExvZ2ljID0gcmVxdWlyZV9jb3JyZWN0X2lzX3JlZ2V4cF9sb2dpYygpOwogICAgICB2YXIgSVNfUFVSRSA9IHJlcXVpcmVfaXNfcHVyZSgpOwogICAgICB2YXIgJHN0YXJ0c1dpdGggPSAiIi5zdGFydHNXaXRoOwogICAgICB2YXIgbWluID0gTWF0aC5taW47CiAgICAgIHZhciBDT1JSRUNUX0lTX1JFR0VYUF9MT0dJQyA9IGNvcnJlY3RJc1JlZ0V4cExvZ2ljKCJzdGFydHNXaXRoIik7CiAgICAgIHZhciBNRE5fUE9MWUZJTExfQlVHID0gIUlTX1BVUkUgJiYgIUNPUlJFQ1RfSVNfUkVHRVhQX0xPR0lDICYmICEhZnVuY3Rpb24oKSB7CiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoU3RyaW5nLnByb3RvdHlwZSwgInN0YXJ0c1dpdGgiKTsKICAgICAgICByZXR1cm4gZGVzY3JpcHRvciAmJiAhZGVzY3JpcHRvci53cml0YWJsZTsKICAgICAgfSgpOwogICAgICAkKHsgdGFyZ2V0OiAiU3RyaW5nIiwgcHJvdG86IHRydWUsIGZvcmNlZDogIU1ETl9QT0xZRklMTF9CVUcgJiYgIUNPUlJFQ1RfSVNfUkVHRVhQX0xPR0lDIH0sIHsKICAgICAgICBzdGFydHNXaXRoOiBmdW5jdGlvbiBzdGFydHNXaXRoKHNlYXJjaFN0cmluZykgewogICAgICAgICAgdmFyIHRoYXQgPSB0b1N0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpKTsKICAgICAgICAgIG5vdEFSZWdFeHAoc2VhcmNoU3RyaW5nKTsKICAgICAgICAgIHZhciBpbmRleCA9IHRvTGVuZ3RoKG1pbihhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMCwgdGhhdC5sZW5ndGgpKTsKICAgICAgICAgIHZhciBzZWFyY2ggPSB0b1N0cmluZyhzZWFyY2hTdHJpbmcpOwogICAgICAgICAgcmV0dXJuICRzdGFydHNXaXRoID8gJHN0YXJ0c1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGluZGV4KSA6IHRoYXQuc2xpY2UoaW5kZXgsIGluZGV4ICsgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDsKICAgICAgICB9CiAgICAgIH0pOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL3N0cmluZy92aXJ0dWFsL3N0YXJ0cy13aXRoLmpzCiAgdmFyIHJlcXVpcmVfc3RhcnRzX3dpdGggPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL3N0cmluZy92aXJ0dWFsL3N0YXJ0cy13aXRoLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICByZXF1aXJlX2VzX3N0cmluZ19zdGFydHNfd2l0aCgpOwogICAgICB2YXIgZW50cnlWaXJ0dWFsID0gcmVxdWlyZV9lbnRyeV92aXJ0dWFsKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gZW50cnlWaXJ0dWFsKCJTdHJpbmciKS5zdGFydHNXaXRoOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2luc3RhbmNlL3N0YXJ0cy13aXRoLmpzCiAgdmFyIHJlcXVpcmVfc3RhcnRzX3dpdGgyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9pbnN0YW5jZS9zdGFydHMtd2l0aC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHN0YXJ0c1dpdGggPSByZXF1aXJlX3N0YXJ0c193aXRoKCk7CiAgICAgIHZhciBTdHJpbmdQcm90b3R5cGUgPSBTdHJpbmcucHJvdG90eXBlOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KSB7CiAgICAgICAgdmFyIG93biA9IGl0LnN0YXJ0c1dpdGg7CiAgICAgICAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gInN0cmluZyIgfHwgaXQgPT09IFN0cmluZ1Byb3RvdHlwZSB8fCBpdCBpbnN0YW5jZW9mIFN0cmluZyAmJiBvd24gPT09IFN0cmluZ1Byb3RvdHlwZS5zdGFydHNXaXRoID8gc3RhcnRzV2l0aCA6IG93bjsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvaW5zdGFuY2Uvc3RhcnRzLXdpdGguanMKICB2YXIgcmVxdWlyZV9zdGFydHNfd2l0aDMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9pbnN0YW5jZS9zdGFydHMtd2l0aC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIHBhcmVudCA9IHJlcXVpcmVfc3RhcnRzX3dpdGgyKCk7CiAgICAgIG1vZHVsZS5leHBvcnRzID0gcGFyZW50OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9pbnN0YW5jZS9zdGFydHMtd2l0aC5qcwogIHZhciByZXF1aXJlX3N0YXJ0c193aXRoNCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL2luc3RhbmNlL3N0YXJ0cy13aXRoLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVfc3RhcnRzX3dpdGgzKCk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9jcm9zcy1mZXRjaC9kaXN0L2Jyb3dzZXItcG9seWZpbGwuanMKICB2YXIgcmVxdWlyZV9icm93c2VyX3BvbHlmaWxsID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2Nyb3NzLWZldGNoL2Rpc3QvYnJvd3Nlci1wb2x5ZmlsbC5qcyIoZXhwb3J0cykgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIChmdW5jdGlvbihzZWxmMikgewogICAgICAgIHZhciBpcnJlbGV2YW50ID0gZnVuY3Rpb24oZXhwb3J0czIpIHsKICAgICAgICAgIHZhciBzdXBwb3J0ID0gewogICAgICAgICAgICBzZWFyY2hQYXJhbXM6ICJVUkxTZWFyY2hQYXJhbXMiIGluIHNlbGYyLAogICAgICAgICAgICBpdGVyYWJsZTogIlN5bWJvbCIgaW4gc2VsZjIgJiYgIml0ZXJhdG9yIiBpbiBTeW1ib2wsCiAgICAgICAgICAgIGJsb2I6ICJGaWxlUmVhZGVyIiBpbiBzZWxmMiAmJiAiQmxvYiIgaW4gc2VsZjIgJiYgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgIG5ldyBCbG9iKCk7CiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KCksCiAgICAgICAgICAgIGZvcm1EYXRhOiAiRm9ybURhdGEiIGluIHNlbGYyLAogICAgICAgICAgICBhcnJheUJ1ZmZlcjogIkFycmF5QnVmZmVyIiBpbiBzZWxmMgogICAgICAgICAgfTsKICAgICAgICAgIGZ1bmN0aW9uIGlzRGF0YVZpZXcob2JqKSB7CiAgICAgICAgICAgIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7CiAgICAgICAgICAgIHZhciB2aWV3Q2xhc3NlcyA9IFsKICAgICAgICAgICAgICAiW29iamVjdCBJbnQ4QXJyYXldIiwKICAgICAgICAgICAgICAiW29iamVjdCBVaW50OEFycmF5XSIsCiAgICAgICAgICAgICAgIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldIiwKICAgICAgICAgICAgICAiW29iamVjdCBJbnQxNkFycmF5XSIsCiAgICAgICAgICAgICAgIltvYmplY3QgVWludDE2QXJyYXldIiwKICAgICAgICAgICAgICAiW29iamVjdCBJbnQzMkFycmF5XSIsCiAgICAgICAgICAgICAgIltvYmplY3QgVWludDMyQXJyYXldIiwKICAgICAgICAgICAgICAiW29iamVjdCBGbG9hdDMyQXJyYXldIiwKICAgICAgICAgICAgICAiW29iamVjdCBGbG9hdDY0QXJyYXldIgogICAgICAgICAgICBdOwogICAgICAgICAgICB2YXIgaXNBcnJheUJ1ZmZlclZpZXcgPSBBcnJheUJ1ZmZlci5pc1ZpZXcgfHwgZnVuY3Rpb24ob2JqKSB7CiAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiB2aWV3Q2xhc3Nlcy5pbmRleE9mKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopKSA+IC0xOwogICAgICAgICAgICB9OwogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lKSB7CiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gInN0cmluZyIpIHsKICAgICAgICAgICAgICBuYW1lID0gU3RyaW5nKG5hbWUpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICgvW15hLXowLTlcLSMkJSYnKisuXl9gfH5dL2kudGVzdChuYW1lKSkgewogICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lIik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKTsKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7CiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB2YWx1ZTsKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7CiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IHsKICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KCk7CiAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiB2YWx1ZSA9PT0gdm9pZCAwLCB2YWx1ZSB9OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfTsKICAgICAgICAgICAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHsKICAgICAgICAgICAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7CiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHsKICAgICAgICAgICAgdGhpcy5tYXAgPSB7fTsKICAgICAgICAgICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7CiAgICAgICAgICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7CiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSk7CiAgICAgICAgICAgICAgfSwgdGhpcyk7CiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkgewogICAgICAgICAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHsKICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKTsKICAgICAgICAgICAgICB9LCB0aGlzKTsKICAgICAgICAgICAgfSBlbHNlIGlmIChoZWFkZXJzKSB7CiAgICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7CiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCBoZWFkZXJzW25hbWVdKTsKICAgICAgICAgICAgICB9LCB0aGlzKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHsKICAgICAgICAgICAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSk7CiAgICAgICAgICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpOwogICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXTsKICAgICAgICAgICAgdGhpcy5tYXBbbmFtZV0gPSBvbGRWYWx1ZSA/IG9sZFZhbHVlICsgIiwgIiArIHZhbHVlIDogdmFsdWU7CiAgICAgICAgICB9OwogICAgICAgICAgSGVhZGVycy5wcm90b3R5cGVbImRlbGV0ZSJdID0gZnVuY3Rpb24obmFtZSkgewogICAgICAgICAgICBkZWxldGUgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV07CiAgICAgICAgICB9OwogICAgICAgICAgSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkgewogICAgICAgICAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzKG5hbWUpID8gdGhpcy5tYXBbbmFtZV0gOiBudWxsOwogICAgICAgICAgfTsKICAgICAgICAgIEhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKG5hbWUpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpOwogICAgICAgICAgfTsKICAgICAgICAgIEhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7CiAgICAgICAgICAgIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpOwogICAgICAgICAgfTsKICAgICAgICAgIEhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykgewogICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7CiAgICAgICAgICAgICAgaWYgKHRoaXMubWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7CiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMubWFwW25hbWVdLCBuYW1lLCB0aGlzKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH07CiAgICAgICAgICBIZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciBpdGVtcyA9IFtdOwogICAgICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHsKICAgICAgICAgICAgICBpdGVtcy5wdXNoKG5hbWUpOwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKTsKICAgICAgICAgIH07CiAgICAgICAgICBIZWFkZXJzLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgdmFyIGl0ZW1zID0gW107CiAgICAgICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkgewogICAgICAgICAgICAgIGl0ZW1zLnB1c2godmFsdWUpOwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKTsKICAgICAgICAgIH07CiAgICAgICAgICBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciBpdGVtcyA9IFtdOwogICAgICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHsKICAgICAgICAgICAgICBpdGVtcy5wdXNoKFtuYW1lLCB2YWx1ZV0pOwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKTsKICAgICAgICAgIH07CiAgICAgICAgICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkgewogICAgICAgICAgICBIZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllczsKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIGNvbnN1bWVkKGJvZHkpIHsKICAgICAgICAgICAgaWYgKGJvZHkuYm9keVVzZWQpIHsKICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcigiQWxyZWFkeSByZWFkIikpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGJvZHkuYm9keVVzZWQgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gZmlsZVJlYWRlclJlYWR5KHJlYWRlcikgewogICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7CiAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KTsKICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICByZWplY3QocmVhZGVyLmVycm9yKTsKICAgICAgICAgICAgICB9OwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7CiAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpOwogICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpOwogICAgICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7CiAgICAgICAgICAgIHJldHVybiBwcm9taXNlOwogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikgewogICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTsKICAgICAgICAgICAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKTsKICAgICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYik7CiAgICAgICAgICAgIHJldHVybiBwcm9taXNlOwogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gcmVhZEFycmF5QnVmZmVyQXNUZXh0KGJ1ZikgewogICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zik7CiAgICAgICAgICAgIHZhciBjaGFycyA9IG5ldyBBcnJheSh2aWV3Lmxlbmd0aCk7CiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgIGNoYXJzW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZSh2aWV3W2ldKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gY2hhcnMuam9pbigiIik7CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBidWZmZXJDbG9uZShidWYpIHsKICAgICAgICAgICAgaWYgKGJ1Zi5zbGljZSkgewogICAgICAgICAgICAgIHJldHVybiBidWYuc2xpY2UoMCk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnl0ZUxlbmd0aCk7CiAgICAgICAgICAgICAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmKSk7CiAgICAgICAgICAgICAgcmV0dXJuIHZpZXcuYnVmZmVyOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBCb2R5KCkgewogICAgICAgICAgICB0aGlzLmJvZHlVc2VkID0gZmFsc2U7CiAgICAgICAgICAgIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkgewogICAgICAgICAgICAgIHRoaXMuX2JvZHlJbml0ID0gYm9keTsKICAgICAgICAgICAgICBpZiAoIWJvZHkpIHsKICAgICAgICAgICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gIiI7CiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7CiAgICAgICAgICAgICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHk7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7CiAgICAgICAgICAgICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5OwogICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7CiAgICAgICAgICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgc3VwcG9ydC5ibG9iICYmIGlzRGF0YVZpZXcoYm9keSkpIHsKICAgICAgICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkuYnVmZmVyKTsKICAgICAgICAgICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiAoQXJyYXlCdWZmZXIucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkgfHwgaXNBcnJheUJ1ZmZlclZpZXcoYm9keSkpKSB7CiAgICAgICAgICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5KTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJvZHkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoIXRoaXMuaGVhZGVycy5nZXQoImNvbnRlbnQtdHlwZSIpKSB7CiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoImNvbnRlbnQtdHlwZSIsICJ0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgiKTsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSkgewogICAgICAgICAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCJjb250ZW50LXR5cGUiLCB0aGlzLl9ib2R5QmxvYi50eXBlKTsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7CiAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoImNvbnRlbnQtdHlwZSIsICJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCIpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfTsKICAgICAgICAgICAgaWYgKHN1cHBvcnQuYmxvYikgewogICAgICAgICAgICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcyk7CiAgICAgICAgICAgICAgICBpZiAocmVqZWN0ZWQpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGVkOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHsKICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2IiKTsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikgewogICAgICAgICAgICAgICAgICByZXR1cm4gY29uc3VtZWQodGhpcykgfHwgUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcik7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ibG9iKCkudGhlbihyZWFkQmxvYkFzQXJyYXlCdWZmZXIpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcyk7CiAgICAgICAgICAgICAgaWYgKHJlamVjdGVkKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0ZWQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikgewogICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikgewogICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSk7CiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHsKICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0Iik7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfTsKICAgICAgICAgICAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHsKICAgICAgICAgICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpOwogICAgICAgICAgICAgIH07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSk7CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgICAgfQogICAgICAgICAgdmFyIG1ldGhvZHMgPSBbIkRFTEVURSIsICJHRVQiLCAiSEVBRCIsICJPUFRJT05TIiwgIlBPU1QiLCAiUFVUIl07CiAgICAgICAgICBmdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7CiAgICAgICAgICAgIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7CiAgICAgICAgICAgIHJldHVybiBtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSA/IHVwY2FzZWQgOiBtZXRob2Q7CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBSZXF1ZXN0KGlucHV0LCBvcHRpb25zKSB7CiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwogICAgICAgICAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keTsKICAgICAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkgewogICAgICAgICAgICAgIGlmIChpbnB1dC5ib2R5VXNlZCkgewogICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiQWxyZWFkeSByZWFkIik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHRoaXMudXJsID0gaW5wdXQudXJsOwogICAgICAgICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBpbnB1dC5jcmVkZW50aWFsczsKICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykgewogICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5wdXQuaGVhZGVycyk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kOwogICAgICAgICAgICAgIHRoaXMubW9kZSA9IGlucHV0Lm1vZGU7CiAgICAgICAgICAgICAgdGhpcy5zaWduYWwgPSBpbnB1dC5zaWduYWw7CiAgICAgICAgICAgICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7CiAgICAgICAgICAgICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0OwogICAgICAgICAgICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB0aGlzLnVybCA9IFN0cmluZyhpbnB1dCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwgdGhpcy5jcmVkZW50aWFscyB8fCAic2FtZS1vcmlnaW4iOwogICAgICAgICAgICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHsKICAgICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICJHRVQiKTsKICAgICAgICAgICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZSB8fCBudWxsOwogICAgICAgICAgICB0aGlzLnNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsIHx8IHRoaXMuc2lnbmFsOwogICAgICAgICAgICB0aGlzLnJlZmVycmVyID0gbnVsbDsKICAgICAgICAgICAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gIkdFVCIgfHwgdGhpcy5tZXRob2QgPT09ICJIRUFEIikgJiYgYm9keSkgewogICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkJvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzIik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5faW5pdEJvZHkoYm9keSk7CiAgICAgICAgICB9CiAgICAgICAgICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcywgeyBib2R5OiB0aGlzLl9ib2R5SW5pdCB9KTsKICAgICAgICAgIH07CiAgICAgICAgICBmdW5jdGlvbiBkZWNvZGUoYm9keSkgewogICAgICAgICAgICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpOwogICAgICAgICAgICBib2R5LnRyaW0oKS5zcGxpdCgiJiIpLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHsKICAgICAgICAgICAgICBpZiAoYnl0ZXMpIHsKICAgICAgICAgICAgICAgIHZhciBzcGxpdCA9IGJ5dGVzLnNwbGl0KCI9Iik7CiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXCsvZywgIiAiKTsKICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oIj0iKS5yZXBsYWNlKC9cKy9nLCAiICIpOwogICAgICAgICAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICByZXR1cm4gZm9ybTsKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7CiAgICAgICAgICAgIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTsKICAgICAgICAgICAgdmFyIHByZVByb2Nlc3NlZEhlYWRlcnMgPSByYXdIZWFkZXJzLnJlcGxhY2UoL1xyP1xuW1x0IF0rL2csICIgIik7CiAgICAgICAgICAgIHByZVByb2Nlc3NlZEhlYWRlcnMuc3BsaXQoL1xyP1xuLykuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7CiAgICAgICAgICAgICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgiOiIpOwogICAgICAgICAgICAgIHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpLnRyaW0oKTsKICAgICAgICAgICAgICBpZiAoa2V5KSB7CiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJ0cy5qb2luKCI6IikudHJpbSgpOwogICAgICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KTsKICAgICAgICAgICAgcmV0dXJuIGhlYWRlcnM7CiAgICAgICAgICB9CiAgICAgICAgICBCb2R5LmNhbGwoUmVxdWVzdC5wcm90b3R5cGUpOwogICAgICAgICAgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHsKICAgICAgICAgICAgaWYgKCFvcHRpb25zKSB7CiAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9OwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMudHlwZSA9ICJkZWZhdWx0IjsKICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1cyA9PT0gdm9pZCAwID8gMjAwIDogb3B0aW9ucy5zdGF0dXM7CiAgICAgICAgICAgIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDA7CiAgICAgICAgICAgIHRoaXMuc3RhdHVzVGV4dCA9ICJzdGF0dXNUZXh0IiBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXNUZXh0IDogIk9LIjsKICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTsKICAgICAgICAgICAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAiIjsKICAgICAgICAgICAgdGhpcy5faW5pdEJvZHkoYm9keUluaXQpOwogICAgICAgICAgfQogICAgICAgICAgQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSk7CiAgICAgICAgICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwgewogICAgICAgICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsCiAgICAgICAgICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LAogICAgICAgICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksCiAgICAgICAgICAgICAgdXJsOiB0aGlzLnVybAogICAgICAgICAgICB9KTsKICAgICAgICAgIH07CiAgICAgICAgICBSZXNwb25zZS5lcnJvciA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwgeyBzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICIiIH0pOwogICAgICAgICAgICByZXNwb25zZS50eXBlID0gImVycm9yIjsKICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlOwogICAgICAgICAgfTsKICAgICAgICAgIHZhciByZWRpcmVjdFN0YXR1c2VzID0gWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XTsKICAgICAgICAgIFJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHsKICAgICAgICAgICAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkgewogICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJJbnZhbGlkIHN0YXR1cyBjb2RlIik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7IHN0YXR1cywgaGVhZGVyczogeyBsb2NhdGlvbjogdXJsIH0gfSk7CiAgICAgICAgICB9OwogICAgICAgICAgZXhwb3J0czIuRE9NRXhjZXB0aW9uID0gc2VsZjIuRE9NRXhjZXB0aW9uOwogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgbmV3IGV4cG9ydHMyLkRPTUV4Y2VwdGlvbigpOwogICAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICAgIGV4cG9ydHMyLkRPTUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKG1lc3NhZ2UsIG5hbWUpIHsKICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlOwogICAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7CiAgICAgICAgICAgICAgdmFyIGVycm9yID0gRXJyb3IobWVzc2FnZSk7CiAgICAgICAgICAgICAgdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrOwogICAgICAgICAgICB9OwogICAgICAgICAgICBleHBvcnRzMi5ET01FeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpOwogICAgICAgICAgICBleHBvcnRzMi5ET01FeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZXhwb3J0czIuRE9NRXhjZXB0aW9uOwogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gZmV0Y2gyKGlucHV0LCBpbml0MikgewogICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7CiAgICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdDIpOwogICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbCAmJiByZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBleHBvcnRzMi5ET01FeGNlcHRpb24oIkFib3J0ZWQiLCAiQWJvcnRFcnJvciIpKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpOwogICAgICAgICAgICAgIGZ1bmN0aW9uIGFib3J0WGhyKCkgewogICAgICAgICAgICAgICAgeGhyLmFib3J0KCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gewogICAgICAgICAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsCiAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LAogICAgICAgICAgICAgICAgICBoZWFkZXJzOiBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpIHx8ICIiKQogICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgIG9wdGlvbnMudXJsID0gInJlc3BvbnNlVVJMIiBpbiB4aHIgPyB4aHIucmVzcG9uc2VVUkwgOiBvcHRpb25zLmhlYWRlcnMuZ2V0KCJYLVJlcXVlc3QtVVJMIik7CiAgICAgICAgICAgICAgICB2YXIgYm9keSA9ICJyZXNwb25zZSIgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dDsKICAgICAgICAgICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKTsKICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcigiTmV0d29yayByZXF1ZXN0IGZhaWxlZCIpKTsKICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCJOZXR3b3JrIHJlcXVlc3QgZmFpbGVkIikpOwogICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIHJlamVjdChuZXcgZXhwb3J0czIuRE9NRXhjZXB0aW9uKCJBYm9ydGVkIiwgIkFib3J0RXJyb3IiKSk7CiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC51cmwsIHRydWUpOwogICAgICAgICAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAiaW5jbHVkZSIpIHsKICAgICAgICAgICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gIm9taXQiKSB7CiAgICAgICAgICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmICgicmVzcG9uc2VUeXBlIiBpbiB4aHIgJiYgc3VwcG9ydC5ibG9iKSB7CiAgICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gImJsb2IiOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkgewogICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpOwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbCkgewogICAgICAgICAgICAgICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcigiYWJvcnQiLCBhYm9ydFhocik7CiAgICAgICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkgewogICAgICAgICAgICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoImFib3J0IiwgYWJvcnRYaHIpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICJ1bmRlZmluZWQiID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CiAgICAgICAgICBmZXRjaDIucG9seWZpbGwgPSB0cnVlOwogICAgICAgICAgaWYgKCFzZWxmMi5mZXRjaCkgewogICAgICAgICAgICBzZWxmMi5mZXRjaCA9IGZldGNoMjsKICAgICAgICAgICAgc2VsZjIuSGVhZGVycyA9IEhlYWRlcnM7CiAgICAgICAgICAgIHNlbGYyLlJlcXVlc3QgPSBSZXF1ZXN0OwogICAgICAgICAgICBzZWxmMi5SZXNwb25zZSA9IFJlc3BvbnNlOwogICAgICAgICAgfQogICAgICAgICAgZXhwb3J0czIuSGVhZGVycyA9IEhlYWRlcnM7CiAgICAgICAgICBleHBvcnRzMi5SZXF1ZXN0ID0gUmVxdWVzdDsKICAgICAgICAgIGV4cG9ydHMyLlJlc3BvbnNlID0gUmVzcG9uc2U7CiAgICAgICAgICBleHBvcnRzMi5mZXRjaCA9IGZldGNoMjsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICAgICAgcmV0dXJuIGV4cG9ydHMyOwogICAgICAgIH0oe30pOwogICAgICB9KSh0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgPyBzZWxmIDogZXhwb3J0cyk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC9iYW0vZGlzdC9odHNnZXQuanMKICB2YXIgcmVxdWlyZV9odHNnZXQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGdtb2QvYmFtL2Rpc3QvaHRzZ2V0LmpzIihleHBvcnRzKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSByZXF1aXJlX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoKTsKICAgICAgdmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlX2ludGVyb3BSZXF1aXJlRGVmYXVsdCgpOwogICAgICB2YXIgX09iamVjdCRkZWZpbmVQcm9wZXJ0eTIgPSByZXF1aXJlX2RlZmluZV9wcm9wZXJ0eTMoKTsKICAgICAgX09iamVjdCRkZWZpbmVQcm9wZXJ0eTIoZXhwb3J0cywgIl9fZXNNb2R1bGUiLCB7CiAgICAgICAgdmFsdWU6IHRydWUKICAgICAgfSk7CiAgICAgIGV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDsKICAgICAgdmFyIF9vYmplY3RXaXRob3V0UHJvcGVydGllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoKSk7CiAgICAgIHZhciBfc3RhcnRzV2l0aCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9zdGFydHNfd2l0aDQoKSk7CiAgICAgIHZhciBfbWFwID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX21hcDQoKSk7CiAgICAgIHZhciBfcHJvbWlzZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9wcm9taXNlNSgpKTsKICAgICAgdmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfZGVmaW5lX3Byb3BlcnR5MygpKTsKICAgICAgdmFyIF9kZWZpbmVQcm9wZXJ0aWVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2RlZmluZV9wcm9wZXJ0aWVzMygpKTsKICAgICAgdmFyIF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2dldF9vd25fcHJvcGVydHlfZGVzY3JpcHRvcnMzKCkpOwogICAgICB2YXIgX2dldE93blByb3BlcnR5RGVzY3JpcHRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9nZXRfb3duX3Byb3BlcnR5X2Rlc2NyaXB0b3IzKCkpOwogICAgICB2YXIgX2dldE93blByb3BlcnR5U3ltYm9scyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9nZXRfb3duX3Byb3BlcnR5X3N5bWJvbHMzKCkpOwogICAgICB2YXIgX2tleXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfa2V5czMoKSk7CiAgICAgIHZhciBfY29uc3RydWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2NvbnN0cnVjdDMoKSk7CiAgICAgIHZhciBfZm9yRWFjaCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9mb3JfZWFjaDQoKSk7CiAgICAgIHZhciBfZmlsdGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2ZpbHRlcjQoKSk7CiAgICAgIHZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfcmVnZW5lcmF0b3IoKSk7CiAgICAgIHZhciBfc2xpY2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfc2xpY2U2KCkpOwogICAgICB2YXIgX2NvbmNhdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfY29uY2F0NCgpKTsKICAgICAgdmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfY2xhc3NDYWxsQ2hlY2soKSk7CiAgICAgIHZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2NyZWF0ZUNsYXNzKCkpOwogICAgICB2YXIgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfYXNzZXJ0VGhpc0luaXRpYWxpemVkKCkpOwogICAgICB2YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9pbmhlcml0cygpKTsKICAgICAgdmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKCkpOwogICAgICB2YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9nZXRQcm90b3R5cGVPZigpKTsKICAgICAgdmFyIF9kZWZpbmVQcm9wZXJ0eTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfZGVmaW5lUHJvcGVydHkoKSk7CiAgICAgIHZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfYXN5bmNUb0dlbmVyYXRvcigpKTsKICAgICAgdmFyIF93cmFwQXN5bmNHZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3dyYXBBc3luY0dlbmVyYXRvcigpKTsKICAgICAgdmFyIF9hd2FpdEFzeW5jR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9hd2FpdEFzeW5jR2VuZXJhdG9yKCkpOwogICAgICB2YXIgX2FzeW5jSXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2FzeW5jSXRlcmF0b3IoKSk7CiAgICAgIHZhciBfYXN5bmNHZW5lcmF0b3JEZWxlZ2F0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfYXN5bmNHZW5lcmF0b3JEZWxlZ2F0ZSgpKTsKICAgICAgdmFyIF9iYW1GaWxlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZV9iYW1GaWxlKCkpOwogICAgICByZXF1aXJlX2Jyb3dzZXJfcG9seWZpbGwoKTsKICAgICAgdmFyIF9iZ3pmRmlsZWhhbmRsZSA9IHJlcXVpcmVfZGlzdDIoKTsKICAgICAgdmFyIF9zYW0gPSByZXF1aXJlX3NhbSgpOwogICAgICBmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsKICAgICAgICB2YXIga2V5cyA9ICgwLCBfa2V5cy5kZWZhdWx0KShvYmplY3QpOwogICAgICAgIGlmIChfZ2V0T3duUHJvcGVydHlTeW1ib2xzLmRlZmF1bHQpIHsKICAgICAgICAgIHZhciBzeW1ib2xzID0gKDAsIF9nZXRPd25Qcm9wZXJ0eVN5bWJvbHMuZGVmYXVsdCkob2JqZWN0KTsKICAgICAgICAgIGlmIChlbnVtZXJhYmxlT25seSkKICAgICAgICAgICAgc3ltYm9scyA9ICgwLCBfZmlsdGVyLmRlZmF1bHQpKHN5bWJvbHMpLmNhbGwoc3ltYm9scywgZnVuY3Rpb24oc3ltKSB7CiAgICAgICAgICAgICAgcmV0dXJuICgwLCBfZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmRlZmF1bHQpKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOwogICAgICAgICAgICB9KTsKICAgICAgICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGtleXM7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsKICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgewogICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307CiAgICAgICAgICBpZiAoaSAlIDIpIHsKICAgICAgICAgICAgdmFyIF9jb250ZXh0MTM7CiAgICAgICAgICAgICgwLCBfZm9yRWFjaC5kZWZhdWx0KShfY29udGV4dDEzID0gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkpLmNhbGwoX2NvbnRleHQxMywgZnVuY3Rpb24oa2V5KSB7CiAgICAgICAgICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTMuZGVmYXVsdCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9IGVsc2UgaWYgKF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzLmRlZmF1bHQpIHsKICAgICAgICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0aWVzLmRlZmF1bHQpKHRhcmdldCwgKDAsIF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzLmRlZmF1bHQpKHNvdXJjZSkpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdmFyIF9jb250ZXh0MTQ7CiAgICAgICAgICAgICgwLCBfZm9yRWFjaC5kZWZhdWx0KShfY29udGV4dDE0ID0gb3duS2V5cyhPYmplY3Qoc291cmNlKSkpLmNhbGwoX2NvbnRleHQxNCwgZnVuY3Rpb24oa2V5KSB7CiAgICAgICAgICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBrZXksICgwLCBfZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmRlZmF1bHQpKHNvdXJjZSwga2V5KSk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gdGFyZ2V0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7CiAgICAgICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgewogICAgICAgICAgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoRGVyaXZlZCksIHJlc3VsdDsKICAgICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7CiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KSh0aGlzKS5jb25zdHJ1Y3RvcjsKICAgICAgICAgICAgcmVzdWx0ID0gKDAsIF9jb25zdHJ1Y3QuZGVmYXVsdCkoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCByZXN1bHQpOwogICAgICAgIH07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsKICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICJ1bmRlZmluZWQiIHx8ICFfY29uc3RydWN0LmRlZmF1bHQpCiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgaWYgKF9jb25zdHJ1Y3QuZGVmYXVsdC5zaGFtKQogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIGlmICh0eXBlb2YgUHJveHkgPT09ICJmdW5jdGlvbiIpCiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB0cnkgewogICAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCgoMCwgX2NvbnN0cnVjdC5kZWZhdWx0KShEYXRlLCBbXSwgZnVuY3Rpb24oKSB7CiAgICAgICAgICB9KSk7CiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNvbmNhdChfeCwgX3gyKSB7CiAgICAgICAgcmV0dXJuIF9jb25jYXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfY29uY2F0KCkgewogICAgICAgIF9jb25jYXQgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKC8qIEBfX1BVUkVfXyAqLyBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KGFyciwgb3B0cykgewogICAgICAgICAgdmFyIHJlczsKICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDE2KSB7CiAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDE2LnByZXYgPSBfY29udGV4dDE2Lm5leHQpIHsKICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgX2NvbnRleHQxNi5uZXh0ID0gMjsKICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9taXNlLmRlZmF1bHQuYWxsKCgwLCBfbWFwLmRlZmF1bHQpKGFycikuY2FsbChhcnIsIC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoY2h1bmspIHsKICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmwsIGhlYWRlcnMsIHJlZmVyZXIsIHJlc3QsIF9yZXM7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQxNSkgewogICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxNS5wcmV2ID0gX2NvbnRleHQxNS5uZXh0KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IGNodW5rLnVybCwgaGVhZGVycyA9IGNodW5rLmhlYWRlcnM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKDAsIF9zdGFydHNXaXRoLmRlZmF1bHQpKHVybCkuY2FsbCh1cmwsICJkYXRhOiIpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxNS5uZXh0ID0gNTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNS5hYnJ1cHQoInJldHVybiIsIGltcG9ydF9idWZmZXIuQnVmZmVyLmZyb20odXJsLnNwbGl0KCIsIilbMV0sICJiYXNlNjQiKSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZXIgPSBoZWFkZXJzLnJlZmVyZXIsIHJlc3QgPSAoMCwgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzMi5kZWZhdWx0KShoZWFkZXJzLCBbInJlZmVyZXIiXSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTUubmV4dCA9IDg7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaCh1cmwsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0cyksIHt9LCB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBvcHRzLmhlYWRlcnMpLCByZXN0KQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXMgPSBfY29udGV4dDE1LnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfcmVzLm9rKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxNS5uZXh0ID0gMTE7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJGYWlsZWQgdG8gZmV0Y2ggIi5jb25jYXQoX3Jlcy5zdGF0dXNUZXh0KSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDE1LnQwID0gaW1wb3J0X2J1ZmZlci5CdWZmZXI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTUubmV4dCA9IDE0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3Jlcy5hcnJheUJ1ZmZlcigpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxNS50MSA9IF9jb250ZXh0MTUuc2VudDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTUuYWJydXB0KCJyZXR1cm4iLCBfY29udGV4dDE1LnQwLmZyb20uY2FsbChfY29udGV4dDE1LnQwLCBfY29udGV4dDE1LnQxKSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE2OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTUuc3RvcCgpOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZTQpOwogICAgICAgICAgICAgICAgICAgIH0pKTsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oX3g0KSB7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICAgIH0oKSkpOwogICAgICAgICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICAgICAgICByZXMgPSBfY29udGV4dDE2LnNlbnQ7CiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTYudDAgPSAoMCwgX2NvbmNhdDIuZGVmYXVsdCkoaW1wb3J0X2J1ZmZlci5CdWZmZXIpOwogICAgICAgICAgICAgICAgICBfY29udGV4dDE2LnQxID0gaW1wb3J0X2J1ZmZlci5CdWZmZXI7CiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTYubmV4dCA9IDc7CiAgICAgICAgICAgICAgICAgIHJldHVybiBfcHJvbWlzZS5kZWZhdWx0LmFsbCgoMCwgX21hcC5kZWZhdWx0KShyZXMpLmNhbGwocmVzLCBmdW5jdGlvbihlbHQpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9iZ3pmRmlsZWhhbmRsZS51bnppcCkoZWx0KTsKICAgICAgICAgICAgICAgICAgfSkpOwogICAgICAgICAgICAgICAgY2FzZSA3OgogICAgICAgICAgICAgICAgICBfY29udGV4dDE2LnQyID0gX2NvbnRleHQxNi5zZW50OwogICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNi5hYnJ1cHQoInJldHVybiIsIF9jb250ZXh0MTYudDAuY2FsbC5jYWxsKF9jb250ZXh0MTYudDAsIF9jb250ZXh0MTYudDEsIF9jb250ZXh0MTYudDIpKTsKICAgICAgICAgICAgICAgIGNhc2UgOToKICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE2LnN0b3AoKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0sIF9jYWxsZWU1KTsKICAgICAgICB9KSk7CiAgICAgICAgcmV0dXJuIF9jb25jYXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgfQogICAgICB2YXIgSHRzZ2V0RmlsZSA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihfQmFtRmlsZTIpIHsKICAgICAgICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShIdHNnZXRGaWxlMiwgX0JhbUZpbGUyKTsKICAgICAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEh0c2dldEZpbGUyKTsKICAgICAgICBmdW5jdGlvbiBIdHNnZXRGaWxlMihhcmdzKSB7CiAgICAgICAgICB2YXIgX3RoaXMyOwogICAgICAgICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgSHRzZ2V0RmlsZTIpOwogICAgICAgICAgX3RoaXMyID0gX3N1cGVyLmNhbGwodGhpcywgewogICAgICAgICAgICBiYW1GaWxlaGFuZGxlOiAiPyIsCiAgICAgICAgICAgIGJhaUZpbGVoYW5kbGU6ICI/IgogICAgICAgICAgfSk7CiAgICAgICAgICAoMCwgX2RlZmluZVByb3BlcnR5My5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXMyKSwgImJhc2VVcmwiLCB2b2lkIDApOwogICAgICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTMuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzMiksICJ0cmFja0lkIiwgdm9pZCAwKTsKICAgICAgICAgIF90aGlzMi5iYXNlVXJsID0gYXJncy5iYXNlVXJsOwogICAgICAgICAgX3RoaXMyLnRyYWNrSWQgPSBhcmdzLnRyYWNrSWQ7CiAgICAgICAgICByZXR1cm4gX3RoaXMyOwogICAgICAgIH0KICAgICAgICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShIdHNnZXRGaWxlMiwgW3sKICAgICAgICAgIGtleTogInN0cmVhbVJlY29yZHNGb3JSYW5nZSIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3RyZWFtUmVjb3Jkc0ZvclJhbmdlKGNociwgbWluLCBtYXgpIHsKICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpczsKICAgICAgICAgICAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1szXSA6IHsKICAgICAgICAgICAgICB2aWV3QXNQYWlyczogZmFsc2UsCiAgICAgICAgICAgICAgcGFpckFjcm9zc0NocjogZmFsc2UsCiAgICAgICAgICAgICAgbWF4SW5zZXJ0U2l6ZTogMmU1CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIHJldHVybiAoMCwgX3dyYXBBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHsKICAgICAgICAgICAgICB2YXIgX2NvbnRleHQsIF9jb250ZXh0MiwgX2NvbnRleHQzLCBfY29udGV4dDQsIF9jb250ZXh0NTsKICAgICAgICAgICAgICB2YXIgYmFzZSwgdXJsLCBjaHJJZCwgcmVzdWx0LCBkYXRhLCB1bmNiYSwgY2h1bms7CiAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQ4KSB7CiAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OC5wcmV2ID0gX2NvbnRleHQ4Lm5leHQpIHsKICAgICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgICBiYXNlID0gKDAsIF9jb25jYXQyLmRlZmF1bHQpKF9jb250ZXh0ID0gIiIuY29uY2F0KF90aGlzLmJhc2VVcmwsICIvIikpLmNhbGwoX2NvbnRleHQsIF90aGlzLnRyYWNrSWQpOwogICAgICAgICAgICAgICAgICAgICAgdXJsID0gKDAsIF9jb25jYXQyLmRlZmF1bHQpKF9jb250ZXh0MiA9ICgwLCBfY29uY2F0Mi5kZWZhdWx0KShfY29udGV4dDMgPSAoMCwgX2NvbmNhdDIuZGVmYXVsdCkoX2NvbnRleHQ0ID0gIiIuY29uY2F0KGJhc2UsICI/cmVmZXJlbmNlTmFtZT0iKSkuY2FsbChfY29udGV4dDQsIGNociwgIiZzdGFydD0iKSkuY2FsbChfY29udGV4dDMsIG1pbiwgIiZlbmQ9IikpLmNhbGwoX2NvbnRleHQyLCBtYXgsICImZm9ybWF0PUJBTSIpOwogICAgICAgICAgICAgICAgICAgICAgY2hySWQgPSBfdGhpcy5jaHJUb0luZGV4ICYmIF90aGlzLmNoclRvSW5kZXhbY2hyXTsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gNTsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX2F3YWl0QXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKGZldGNoKHVybCwgX29iamVjdFNwcmVhZCh7fSwgb3B0cykpKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDU6CiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDguc2VudDsKICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQub2spIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSA4OwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQuc3RhdHVzVGV4dCk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OgogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAxMDsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX2F3YWl0QXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKHJlc3VsdC5qc29uKCkpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6CiAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2NvbnRleHQ4LnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDEzOwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfYXdhaXRBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoY29uY2F0KCgwLCBfc2xpY2UuZGVmYXVsdCkoX2NvbnRleHQ1ID0gZGF0YS5odHNnZXQudXJscykuY2FsbChfY29udGV4dDUsIDEpLCBvcHRzKSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzoKICAgICAgICAgICAgICAgICAgICAgIHVuY2JhID0gX2NvbnRleHQ4LnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgICBjaHVuayA9IHsKICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiB1bmNiYSwKICAgICAgICAgICAgICAgICAgICAgICAgY2h1bms6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICBtaW52OiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhUG9zaXRpb246IDAKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2NvbnRleHQ2LCBfY29udGV4dDc7CiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfY29uY2F0Mi5kZWZhdWx0KShfY29udGV4dDYgPSAoMCwgX2NvbmNhdDIuZGVmYXVsdCkoX2NvbnRleHQ3ID0gIiIuY29uY2F0KGNociwgIl8iKSkuY2FsbChfY29udGV4dDcsIG1pbiwgIl8iKSkuY2FsbChfY29udGV4dDYsIG1heCk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmRlbGVnYXRlWWllbGQoKDAsIF9hc3luY0dlbmVyYXRvckRlbGVnYXRlMi5kZWZhdWx0KSgoMCwgX2FzeW5jSXRlcmF0b3IyLmRlZmF1bHQpKF90aGlzLl9mZXRjaENodW5rRmVhdHVyZXMoW2NodW5rXSwgY2hySWQsIG1pbiwgbWF4LCBvcHRzKSksIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KSwgInQwIiwgMTYpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6CiAgICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguc3RvcCgpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSwgX2NhbGxlZSk7CiAgICAgICAgICAgIH0pKSgpOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogIl9yZWFkQ2h1bmsiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgX3JlYWRDaHVuazIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKC8qIEBfX1BVUkVfXyAqLyBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHBhcmFtcykgewogICAgICAgICAgICAgIHZhciBjaHVuaywgYnVmZmVyLCBjMjsKICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQ5KSB7CiAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OS5wcmV2ID0gX2NvbnRleHQ5Lm5leHQpIHsKICAgICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgICBjaHVuayA9IHBhcmFtcy5jaHVuazsKICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGNodW5rLmJ1ZmZlciwgYzIgPSBjaHVuay5jaHVuazsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuYWJydXB0KCJyZXR1cm4iLCB7CiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGJ1ZmZlciwKICAgICAgICAgICAgICAgICAgICAgICAgY3Bvc2l0aW9uczogbnVsbCwKICAgICAgICAgICAgICAgICAgICAgICAgZHBvc2l0aW9uczogbnVsbCwKICAgICAgICAgICAgICAgICAgICAgICAgY2h1bms6IGMyCiAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuc3RvcCgpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSwgX2NhbGxlZTIpOwogICAgICAgICAgICB9KSk7CiAgICAgICAgICAgIGZ1bmN0aW9uIF9yZWFkQ2h1bmsoX3gzKSB7CiAgICAgICAgICAgICAgcmV0dXJuIF9yZWFkQ2h1bmsyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIF9yZWFkQ2h1bms7CiAgICAgICAgICB9KCkKICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJnZXRIZWFkZXIiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgX2dldEhlYWRlciA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoKSB7CiAgICAgICAgICAgICAgdmFyIF9jb250ZXh0MTA7CiAgICAgICAgICAgICAgdmFyIG9wdHMsIHVybCwgcmVzdWx0LCBkYXRhLCB1bmNiYSwgaGVhZExlbiwgaGVhZGVyVGV4dCwgc2FtSGVhZGVyLCBpZFRvTmFtZSwgbmFtZVRvSWQsIHNxTGluZXMsIF9hcmdzMyA9IGFyZ3VtZW50czsKICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQxMikgewogICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDEyLnByZXYgPSBfY29udGV4dDEyLm5leHQpIHsKICAgICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgICBvcHRzID0gX2FyZ3MzLmxlbmd0aCA+IDAgJiYgX2FyZ3MzWzBdICE9PSB2b2lkIDAgPyBfYXJnczNbMF0gOiB7fTsKICAgICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfY29uY2F0Mi5kZWZhdWx0KShfY29udGV4dDEwID0gIiIuY29uY2F0KHRoaXMuYmFzZVVybCwgIi8iKSkuY2FsbChfY29udGV4dDEwLCB0aGlzLnRyYWNrSWQsICI/cmVmZXJlbmNlTmFtZT1uYSZjbGFzcz1oZWFkZXIiKTsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDQ7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2godXJsLCBvcHRzKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6CiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDEyLnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lm9rKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDc7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJGYWlsZWQgdG8gZmV0Y2ggIi5jb25jYXQocmVzdWx0LnN0YXR1c1RleHQpKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDc6CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSA5OwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5qc29uKCk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OgogICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0MTIuc2VudDsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDEyOwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNhdChkYXRhLmh0c2dldC51cmxzLCBvcHRzKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOgogICAgICAgICAgICAgICAgICAgICAgdW5jYmEgPSBfY29udGV4dDEyLnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoISh1bmNiYS5yZWFkSW50MzJMRSgwKSAhPT0gX2JhbUZpbGUuQkFNX01BR0lDKSkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSAxNTsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIk5vdCBhIEJBTSBmaWxlIik7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNToKICAgICAgICAgICAgICAgICAgICAgIGhlYWRMZW4gPSB1bmNiYS5yZWFkSW50MzJMRSg0KTsKICAgICAgICAgICAgICAgICAgICAgIGhlYWRlclRleHQgPSB1bmNiYS50b1N0cmluZygidXRmOCIsIDgsIDggKyBoZWFkTGVuKTsKICAgICAgICAgICAgICAgICAgICAgIHNhbUhlYWRlciA9ICgwLCBfc2FtLnBhcnNlSGVhZGVyVGV4dCkoaGVhZGVyVGV4dCk7CiAgICAgICAgICAgICAgICAgICAgICBpZFRvTmFtZSA9IFtdOwogICAgICAgICAgICAgICAgICAgICAgbmFtZVRvSWQgPSB7fTsKICAgICAgICAgICAgICAgICAgICAgIHNxTGluZXMgPSAoMCwgX2ZpbHRlci5kZWZhdWx0KShzYW1IZWFkZXIpLmNhbGwoc2FtSGVhZGVyLCBmdW5jdGlvbihsKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsLnRhZyA9PT0gIlNRIjsKICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgICAgKDAsIF9mb3JFYWNoLmRlZmF1bHQpKHNxTGluZXMpLmNhbGwoc3FMaW5lcywgZnVuY3Rpb24oc3FMaW5lLCByZWZJZCkgewogICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2NvbnRleHQxMTsKICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9mb3JFYWNoLmRlZmF1bHQpKF9jb250ZXh0MTEgPSBzcUxpbmUuZGF0YSkuY2FsbChfY29udGV4dDExLCBmdW5jdGlvbihpdGVtKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udGFnID09PSAiU04iKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVmTmFtZSA9IGl0ZW0udmFsdWU7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lVG9JZFtyZWZOYW1lXSA9IHJlZklkOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRUb05hbWVbcmVmSWRdID0gcmVmTmFtZTsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoclRvSW5kZXggPSBuYW1lVG9JZDsKICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhUb0NociA9IGlkVG9OYW1lOwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuYWJydXB0KCJyZXR1cm4iLCBzYW1IZWFkZXIpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMjU6CiAgICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLnN0b3AoKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTsKICAgICAgICAgICAgfSkpOwogICAgICAgICAgICBmdW5jdGlvbiBnZXRIZWFkZXIoKSB7CiAgICAgICAgICAgICAgcmV0dXJuIF9nZXRIZWFkZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gZ2V0SGVhZGVyOwogICAgICAgICAgfSgpCiAgICAgICAgfV0pOwogICAgICAgIHJldHVybiBIdHNnZXRGaWxlMjsKICAgICAgfShfYmFtRmlsZS5kZWZhdWx0KTsKICAgICAgZXhwb3J0cy5kZWZhdWx0ID0gSHRzZ2V0RmlsZTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL2JhbS9kaXN0L2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfZGlzdDQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGdtb2QvYmFtL2Rpc3QvaW5kZXguanMiKGV4cG9ydHMpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoKTsKICAgICAgdmFyIF9PYmplY3QkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlX2RlZmluZV9wcm9wZXJ0eTMoKTsKICAgICAgX09iamVjdCRkZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAiX19lc01vZHVsZSIsIHsKICAgICAgICB2YWx1ZTogdHJ1ZQogICAgICB9KTsKICAgICAgX09iamVjdCRkZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAiQkFJIiwgewogICAgICAgIGVudW1lcmFibGU6IHRydWUsCiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICByZXR1cm4gX2JhaS5kZWZhdWx0OwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIF9PYmplY3QkZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgIkNTSSIsIHsKICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgcmV0dXJuIF9jc2kuZGVmYXVsdDsKICAgICAgICB9CiAgICAgIH0pOwogICAgICBfT2JqZWN0JGRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJCYW1GaWxlIiwgewogICAgICAgIGVudW1lcmFibGU6IHRydWUsCiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICByZXR1cm4gX2JhbUZpbGUuZGVmYXVsdDsKICAgICAgICB9CiAgICAgIH0pOwogICAgICBfT2JqZWN0JGRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJIdHNnZXRGaWxlIiwgewogICAgICAgIGVudW1lcmFibGU6IHRydWUsCiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICByZXR1cm4gX2h0c2dldC5kZWZhdWx0OwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIF9PYmplY3QkZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgIkJhbVJlY29yZCIsIHsKICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgcmV0dXJuIF9yZWNvcmQuZGVmYXVsdDsKICAgICAgICB9CiAgICAgIH0pOwogICAgICB2YXIgX2JhaSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9iYWkoKSk7CiAgICAgIHZhciBfY3NpID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2NzaSgpKTsKICAgICAgdmFyIF9iYW1GaWxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2JhbUZpbGUoKSk7CiAgICAgIHZhciBfaHRzZ2V0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2h0c2dldCgpKTsKICAgICAgdmFyIF9yZWNvcmQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfcmVjb3JkKCkpOwogICAgfQogIH0pOwoKICAvLyBzcmMvZGF0YS1mZXRjaGVycy9iYW0vYmFtLXdvcmtlci50cz93b3JrZXImaW5saW5lP3dvcmtlcl9maWxlCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvdGhyZWFkcy93b3JrZXIubWpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfd29ya2VyID0gX190b01vZHVsZShyZXF1aXJlX3dvcmtlcigpKTsKICB2YXIgZXhwb3NlID0gaW1wb3J0X3dvcmtlci5kZWZhdWx0LmV4cG9zZTsKICB2YXIgcmVnaXN0ZXJTZXJpYWxpemVyID0gaW1wb3J0X3dvcmtlci5kZWZhdWx0LnJlZ2lzdGVyU2VyaWFsaXplcjsKICB2YXIgVHJhbnNmZXIgPSBpbXBvcnRfd29ya2VyLmRlZmF1bHQuVHJhbnNmZXI7CgogIC8vIHNyYy9kYXRhLWZldGNoZXJzL2JhbS9iYW0td29ya2VyLnRzP3dvcmtlciZpbmxpbmU/d29ya2VyX2ZpbGUKICB2YXIgaW1wb3J0X2JhbSA9IF9fdG9Nb2R1bGUocmVxdWlyZV9kaXN0NCgpKTsKCiAgLy8gbm9kZV9tb2R1bGVzL3F1aWNrLWxydS9pbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgUXVpY2tMUlUgPSBjbGFzcyBleHRlbmRzIE1hcCB7CiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHsKICAgICAgc3VwZXIoKTsKICAgICAgaWYgKCEob3B0aW9ucy5tYXhTaXplICYmIG9wdGlvbnMubWF4U2l6ZSA+IDApKSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiYG1heFNpemVgIG11c3QgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDAiKTsKICAgICAgfQogICAgICBpZiAodHlwZW9mIG9wdGlvbnMubWF4QWdlID09PSAibnVtYmVyIiAmJiBvcHRpb25zLm1heEFnZSA9PT0gMCkgewogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImBtYXhBZ2VgIG11c3QgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDAiKTsKICAgICAgfQogICAgICB0aGlzLm1heFNpemUgPSBvcHRpb25zLm1heFNpemU7CiAgICAgIHRoaXMubWF4QWdlID0gb3B0aW9ucy5tYXhBZ2UgfHwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOwogICAgICB0aGlzLm9uRXZpY3Rpb24gPSBvcHRpb25zLm9uRXZpY3Rpb247CiAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7CiAgICAgIHRoaXMub2xkQ2FjaGUgPSBuZXcgTWFwKCk7CiAgICAgIHRoaXMuX3NpemUgPSAwOwogICAgfQogICAgX2VtaXRFdmljdGlvbnMoY2FjaGUpIHsKICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uRXZpY3Rpb24gIT09ICJmdW5jdGlvbiIpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgZm9yIChjb25zdCBba2V5LCBpdGVtXSBvZiBjYWNoZSkgewogICAgICAgIHRoaXMub25FdmljdGlvbihrZXksIGl0ZW0udmFsdWUpOwogICAgICB9CiAgICB9CiAgICBfZGVsZXRlSWZFeHBpcmVkKGtleSwgaXRlbSkgewogICAgICBpZiAodHlwZW9mIGl0ZW0uZXhwaXJ5ID09PSAibnVtYmVyIiAmJiBpdGVtLmV4cGlyeSA8PSBEYXRlLm5vdygpKSB7CiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uRXZpY3Rpb24gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIHRoaXMub25FdmljdGlvbihrZXksIGl0ZW0udmFsdWUpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpcy5kZWxldGUoa2V5KTsKICAgICAgfQogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CiAgICBfZ2V0T3JEZWxldGVJZkV4cGlyZWQoa2V5LCBpdGVtKSB7CiAgICAgIGNvbnN0IGRlbGV0ZWQgPSB0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCBpdGVtKTsKICAgICAgaWYgKGRlbGV0ZWQgPT09IGZhbHNlKSB7CiAgICAgICAgcmV0dXJuIGl0ZW0udmFsdWU7CiAgICAgIH0KICAgIH0KICAgIF9nZXRJdGVtVmFsdWUoa2V5LCBpdGVtKSB7CiAgICAgIHJldHVybiBpdGVtLmV4cGlyeSA/IHRoaXMuX2dldE9yRGVsZXRlSWZFeHBpcmVkKGtleSwgaXRlbSkgOiBpdGVtLnZhbHVlOwogICAgfQogICAgX3BlZWsoa2V5LCBjYWNoZSkgewogICAgICBjb25zdCBpdGVtID0gY2FjaGUuZ2V0KGtleSk7CiAgICAgIHJldHVybiB0aGlzLl9nZXRJdGVtVmFsdWUoa2V5LCBpdGVtKTsKICAgIH0KICAgIF9zZXQoa2V5LCB2YWx1ZSkgewogICAgICB0aGlzLmNhY2hlLnNldChrZXksIHZhbHVlKTsKICAgICAgdGhpcy5fc2l6ZSsrOwogICAgICBpZiAodGhpcy5fc2l6ZSA+PSB0aGlzLm1heFNpemUpIHsKICAgICAgICB0aGlzLl9zaXplID0gMDsKICAgICAgICB0aGlzLl9lbWl0RXZpY3Rpb25zKHRoaXMub2xkQ2FjaGUpOwogICAgICAgIHRoaXMub2xkQ2FjaGUgPSB0aGlzLmNhY2hlOwogICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7CiAgICAgIH0KICAgIH0KICAgIF9tb3ZlVG9SZWNlbnQoa2V5LCBpdGVtKSB7CiAgICAgIHRoaXMub2xkQ2FjaGUuZGVsZXRlKGtleSk7CiAgICAgIHRoaXMuX3NldChrZXksIGl0ZW0pOwogICAgfQogICAgKl9lbnRyaWVzQXNjZW5kaW5nKCkgewogICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5vbGRDYWNoZSkgewogICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IGl0ZW07CiAgICAgICAgaWYgKCF0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICBjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdmFsdWUpOwogICAgICAgICAgaWYgKGRlbGV0ZWQgPT09IGZhbHNlKSB7CiAgICAgICAgICAgIHlpZWxkIGl0ZW07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLmNhY2hlKSB7CiAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gaXRlbTsKICAgICAgICBjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdmFsdWUpOwogICAgICAgIGlmIChkZWxldGVkID09PSBmYWxzZSkgewogICAgICAgICAgeWllbGQgaXRlbTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIGdldChrZXkpIHsKICAgICAgaWYgKHRoaXMuY2FjaGUuaGFzKGtleSkpIHsKICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5jYWNoZS5nZXQoa2V5KTsKICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SXRlbVZhbHVlKGtleSwgaXRlbSk7CiAgICAgIH0KICAgICAgaWYgKHRoaXMub2xkQ2FjaGUuaGFzKGtleSkpIHsKICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5vbGRDYWNoZS5nZXQoa2V5KTsKICAgICAgICBpZiAodGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgaXRlbSkgPT09IGZhbHNlKSB7CiAgICAgICAgICB0aGlzLl9tb3ZlVG9SZWNlbnQoa2V5LCBpdGVtKTsKICAgICAgICAgIHJldHVybiBpdGVtLnZhbHVlOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgc2V0KGtleSwgdmFsdWUsIHsgbWF4QWdlID0gdGhpcy5tYXhBZ2UgfSA9IHt9KSB7CiAgICAgIGNvbnN0IGV4cGlyeSA9IHR5cGVvZiBtYXhBZ2UgPT09ICJudW1iZXIiICYmIG1heEFnZSAhPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZID8gRGF0ZS5ub3coKSArIG1heEFnZSA6IHZvaWQgMDsKICAgICAgaWYgKHRoaXMuY2FjaGUuaGFzKGtleSkpIHsKICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIHsKICAgICAgICAgIHZhbHVlLAogICAgICAgICAgZXhwaXJ5CiAgICAgICAgfSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5fc2V0KGtleSwgeyB2YWx1ZSwgZXhwaXJ5IH0pOwogICAgICB9CiAgICB9CiAgICBoYXMoa2V5KSB7CiAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgcmV0dXJuICF0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCB0aGlzLmNhY2hlLmdldChrZXkpKTsKICAgICAgfQogICAgICBpZiAodGhpcy5vbGRDYWNoZS5oYXMoa2V5KSkgewogICAgICAgIHJldHVybiAhdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdGhpcy5vbGRDYWNoZS5nZXQoa2V5KSk7CiAgICAgIH0KICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogICAgcGVlayhrZXkpIHsKICAgICAgaWYgKHRoaXMuY2FjaGUuaGFzKGtleSkpIHsKICAgICAgICByZXR1cm4gdGhpcy5fcGVlayhrZXksIHRoaXMuY2FjaGUpOwogICAgICB9CiAgICAgIGlmICh0aGlzLm9sZENhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX3BlZWsoa2V5LCB0aGlzLm9sZENhY2hlKTsKICAgICAgfQogICAgfQogICAgZGVsZXRlKGtleSkgewogICAgICBjb25zdCBkZWxldGVkID0gdGhpcy5jYWNoZS5kZWxldGUoa2V5KTsKICAgICAgaWYgKGRlbGV0ZWQpIHsKICAgICAgICB0aGlzLl9zaXplLS07CiAgICAgIH0KICAgICAgcmV0dXJuIHRoaXMub2xkQ2FjaGUuZGVsZXRlKGtleSkgfHwgZGVsZXRlZDsKICAgIH0KICAgIGNsZWFyKCkgewogICAgICB0aGlzLmNhY2hlLmNsZWFyKCk7CiAgICAgIHRoaXMub2xkQ2FjaGUuY2xlYXIoKTsKICAgICAgdGhpcy5fc2l6ZSA9IDA7CiAgICB9CiAgICByZXNpemUobmV3U2l6ZSkgewogICAgICBpZiAoIShuZXdTaXplICYmIG5ld1NpemUgPiAwKSkgewogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImBtYXhTaXplYCBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwIik7CiAgICAgIH0KICAgICAgY29uc3QgaXRlbXMgPSBbLi4udGhpcy5fZW50cmllc0FzY2VuZGluZygpXTsKICAgICAgY29uc3QgcmVtb3ZlQ291bnQgPSBpdGVtcy5sZW5ndGggLSBuZXdTaXplOwogICAgICBpZiAocmVtb3ZlQ291bnQgPCAwKSB7CiAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBNYXAoaXRlbXMpOwogICAgICAgIHRoaXMub2xkQ2FjaGUgPSBuZXcgTWFwKCk7CiAgICAgICAgdGhpcy5fc2l6ZSA9IGl0ZW1zLmxlbmd0aDsKICAgICAgfSBlbHNlIHsKICAgICAgICBpZiAocmVtb3ZlQ291bnQgPiAwKSB7CiAgICAgICAgICB0aGlzLl9lbWl0RXZpY3Rpb25zKGl0ZW1zLnNsaWNlKDAsIHJlbW92ZUNvdW50KSk7CiAgICAgICAgfQogICAgICAgIHRoaXMub2xkQ2FjaGUgPSBuZXcgTWFwKGl0ZW1zLnNsaWNlKHJlbW92ZUNvdW50KSk7CiAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBNYXAoKTsKICAgICAgICB0aGlzLl9zaXplID0gMDsKICAgICAgfQogICAgICB0aGlzLm1heFNpemUgPSBuZXdTaXplOwogICAgfQogICAgKmtleXMoKSB7CiAgICAgIGZvciAoY29uc3QgW2tleV0gb2YgdGhpcykgewogICAgICAgIHlpZWxkIGtleTsKICAgICAgfQogICAgfQogICAgKnZhbHVlcygpIHsKICAgICAgZm9yIChjb25zdCBbLCB2YWx1ZV0gb2YgdGhpcykgewogICAgICAgIHlpZWxkIHZhbHVlOwogICAgICB9CiAgICB9CiAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7CiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLmNhY2hlKSB7CiAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gaXRlbTsKICAgICAgICBjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdmFsdWUpOwogICAgICAgIGlmIChkZWxldGVkID09PSBmYWxzZSkgewogICAgICAgICAgeWllbGQgW2tleSwgdmFsdWUudmFsdWVdOwogICAgICAgIH0KICAgICAgfQogICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5vbGRDYWNoZSkgewogICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IGl0ZW07CiAgICAgICAgaWYgKCF0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICBjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdmFsdWUpOwogICAgICAgICAgaWYgKGRlbGV0ZWQgPT09IGZhbHNlKSB7CiAgICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlLnZhbHVlXTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgICplbnRyaWVzRGVzY2VuZGluZygpIHsKICAgICAgbGV0IGl0ZW1zID0gWy4uLnRoaXMuY2FjaGVdOwogICAgICBmb3IgKGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsKICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07CiAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gaXRlbTsKICAgICAgICBjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdmFsdWUpOwogICAgICAgIGlmIChkZWxldGVkID09PSBmYWxzZSkgewogICAgICAgICAgeWllbGQgW2tleSwgdmFsdWUudmFsdWVdOwogICAgICAgIH0KICAgICAgfQogICAgICBpdGVtcyA9IFsuLi50aGlzLm9sZENhY2hlXTsKICAgICAgZm9yIChsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7CiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldOwogICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IGl0ZW07CiAgICAgICAgaWYgKCF0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICBjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdmFsdWUpOwogICAgICAgICAgaWYgKGRlbGV0ZWQgPT09IGZhbHNlKSB7CiAgICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlLnZhbHVlXTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgICplbnRyaWVzQXNjZW5kaW5nKCkgewogICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9lbnRyaWVzQXNjZW5kaW5nKCkpIHsKICAgICAgICB5aWVsZCBba2V5LCB2YWx1ZS52YWx1ZV07CiAgICAgIH0KICAgIH0KICAgIGdldCBzaXplKCkgewogICAgICBpZiAoIXRoaXMuX3NpemUpIHsKICAgICAgICByZXR1cm4gdGhpcy5vbGRDYWNoZS5zaXplOwogICAgICB9CiAgICAgIGxldCBvbGRDYWNoZVNpemUgPSAwOwogICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLm9sZENhY2hlLmtleXMoKSkgewogICAgICAgIGlmICghdGhpcy5jYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgb2xkQ2FjaGVTaXplKys7CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLl9zaXplICsgb2xkQ2FjaGVTaXplLCB0aGlzLm1heFNpemUpOwogICAgfQogICAgZW50cmllcygpIHsKICAgICAgcmV0dXJuIHRoaXMuZW50cmllc0FzY2VuZGluZygpOwogICAgfQogICAgZm9yRWFjaChjYWxsYmFja0Z1bmN0aW9uLCB0aGlzQXJndW1lbnQgPSB0aGlzKSB7CiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuZW50cmllc0FzY2VuZGluZygpKSB7CiAgICAgICAgY2FsbGJhY2tGdW5jdGlvbi5jYWxsKHRoaXNBcmd1bWVudCwgdmFsdWUsIGtleSwgdGhpcyk7CiAgICAgIH0KICAgIH0KICAgIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHsKICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFsuLi50aGlzLmVudHJpZXNBc2NlbmRpbmcoKV0pOwogICAgfQogIH07CgogIC8vIHNyYy9kYXRhLWZldGNoZXJzL3V0aWxzLnRzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2luZGV4LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2FzY2VuZGluZy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBhc2NlbmRpbmdfZGVmYXVsdChhLCBiKSB7CiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47CiAgfQoKICAvLyBub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2Jpc2VjdG9yLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIGJpc2VjdG9yX2RlZmF1bHQoZikgewogICAgbGV0IGRlbHRhID0gZjsKICAgIGxldCBjb21wYXJlID0gZjsKICAgIGlmIChmLmxlbmd0aCA9PT0gMSkgewogICAgICBkZWx0YSA9IChkLCB4KSA9PiBmKGQpIC0geDsKICAgICAgY29tcGFyZSA9IGFzY2VuZGluZ0NvbXBhcmF0b3IoZik7CiAgICB9CiAgICBmdW5jdGlvbiBsZWZ0KGEsIHgsIGxvLCBoaSkgewogICAgICBpZiAobG8gPT0gbnVsbCkKICAgICAgICBsbyA9IDA7CiAgICAgIGlmIChoaSA9PSBudWxsKQogICAgICAgIGhpID0gYS5sZW5ndGg7CiAgICAgIHdoaWxlIChsbyA8IGhpKSB7CiAgICAgICAgY29uc3QgbWlkID0gbG8gKyBoaSA+Pj4gMTsKICAgICAgICBpZiAoY29tcGFyZShhW21pZF0sIHgpIDwgMCkKICAgICAgICAgIGxvID0gbWlkICsgMTsKICAgICAgICBlbHNlCiAgICAgICAgICBoaSA9IG1pZDsKICAgICAgfQogICAgICByZXR1cm4gbG87CiAgICB9CiAgICBmdW5jdGlvbiByaWdodChhLCB4LCBsbywgaGkpIHsKICAgICAgaWYgKGxvID09IG51bGwpCiAgICAgICAgbG8gPSAwOwogICAgICBpZiAoaGkgPT0gbnVsbCkKICAgICAgICBoaSA9IGEubGVuZ3RoOwogICAgICB3aGlsZSAobG8gPCBoaSkgewogICAgICAgIGNvbnN0IG1pZCA9IGxvICsgaGkgPj4+IDE7CiAgICAgICAgaWYgKGNvbXBhcmUoYVttaWRdLCB4KSA+IDApCiAgICAgICAgICBoaSA9IG1pZDsKICAgICAgICBlbHNlCiAgICAgICAgICBsbyA9IG1pZCArIDE7CiAgICAgIH0KICAgICAgcmV0dXJuIGxvOwogICAgfQogICAgZnVuY3Rpb24gY2VudGVyKGEsIHgsIGxvLCBoaSkgewogICAgICBpZiAobG8gPT0gbnVsbCkKICAgICAgICBsbyA9IDA7CiAgICAgIGlmIChoaSA9PSBudWxsKQogICAgICAgIGhpID0gYS5sZW5ndGg7CiAgICAgIGNvbnN0IGkgPSBsZWZ0KGEsIHgsIGxvLCBoaSAtIDEpOwogICAgICByZXR1cm4gaSA+IGxvICYmIGRlbHRhKGFbaSAtIDFdLCB4KSA+IC1kZWx0YShhW2ldLCB4KSA/IGkgLSAxIDogaTsKICAgIH0KICAgIHJldHVybiB7IGxlZnQsIGNlbnRlciwgcmlnaHQgfTsKICB9CiAgZnVuY3Rpb24gYXNjZW5kaW5nQ29tcGFyYXRvcihmKSB7CiAgICByZXR1cm4gKGQsIHgpID0+IGFzY2VuZGluZ19kZWZhdWx0KGYoZCksIHgpOwogIH0KCiAgLy8gc3JjL2RhdGEtZmV0Y2hlcnMvdXRpbHMudHMKICB2YXIgaW1wb3J0X2dlbmVyaWNfZmlsZWhhbmRsZSA9IF9fdG9Nb2R1bGUocmVxdWlyZV9kaXN0MygpKTsKICB2YXIgRGF0YVNvdXJjZSA9IGNsYXNzIHsKICAgIGNvbnN0cnVjdG9yKGZpbGUsIGNocm9tU2l6ZXMsIG9wdGlvbnMpIHsKICAgICAgdGhpcy5maWxlID0gZmlsZTsKICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9uczsKICAgICAgdGhpcy5jaHJvbUluZm8gPSBzaXplc1RvQ2hyb21JbmZvKGNocm9tU2l6ZXMpOwogICAgICB0aGlzLnRpbGVzZXRJbmZvID0gdGlsZXNldEluZm9Gcm9tQ2hyb21JbmZvKHRoaXMuY2hyb21JbmZvKTsKICAgIH0KICB9OwogIHZhciBjaHJvbUluZm9CaXNlY3RvciA9IGJpc2VjdG9yX2RlZmF1bHQoKGQpID0+IGQucG9zKS5sZWZ0OwogIHZhciBjaHJUb0FicyA9IChjaHJvbSwgY2hyb21Qb3MsIGNocm9tSW5mbykgPT4gY2hyb21JbmZvLmNoclBvc2l0aW9uc1tjaHJvbV0ucG9zICsgY2hyb21Qb3M7CiAgdmFyIGFic1RvQ2hyID0gKGFic1Bvc2l0aW9uLCBjaHJvbUluZm8pID0+IHsKICAgIGlmICghY2hyb21JbmZvIHx8ICFjaHJvbUluZm8uY3VtUG9zaXRpb25zIHx8ICFjaHJvbUluZm8uY3VtUG9zaXRpb25zLmxlbmd0aCkgewogICAgICByZXR1cm4gbnVsbDsKICAgIH0KICAgIGxldCBpbnNlcnRQb2ludCA9IGNocm9tSW5mb0Jpc2VjdG9yKGNocm9tSW5mby5jdW1Qb3NpdGlvbnMsIGFic1Bvc2l0aW9uKTsKICAgIGNvbnN0IGxhc3RDaHIgPSBjaHJvbUluZm8uY3VtUG9zaXRpb25zW2Nocm9tSW5mby5jdW1Qb3NpdGlvbnMubGVuZ3RoIC0gMV0uY2hyOwogICAgY29uc3QgbGFzdExlbmd0aCA9IGNocm9tSW5mby5jaHJvbUxlbmd0aHNbbGFzdENocl07CiAgICBpbnNlcnRQb2ludCAtPSBpbnNlcnRQb2ludCA+IDAgJiYgMTsKICAgIGxldCBjaHJQb3NpdGlvbiA9IE1hdGguZmxvb3IoYWJzUG9zaXRpb24gLSBjaHJvbUluZm8uY3VtUG9zaXRpb25zW2luc2VydFBvaW50XS5wb3MpOwogICAgbGV0IG9mZnNldCA9IDA7CiAgICBpZiAoY2hyUG9zaXRpb24gPCAwKSB7CiAgICAgIG9mZnNldCA9IGNoclBvc2l0aW9uIC0gMTsKICAgICAgY2hyUG9zaXRpb24gPSAxOwogICAgfQogICAgaWYgKGluc2VydFBvaW50ID09PSBjaHJvbUluZm8uY3VtUG9zaXRpb25zLmxlbmd0aCAtIDEgJiYgY2hyUG9zaXRpb24gPiBsYXN0TGVuZ3RoKSB7CiAgICAgIG9mZnNldCA9IGNoclBvc2l0aW9uIC0gbGFzdExlbmd0aDsKICAgICAgY2hyUG9zaXRpb24gPSBsYXN0TGVuZ3RoOwogICAgfQogICAgcmV0dXJuIFtjaHJvbUluZm8uY3VtUG9zaXRpb25zW2luc2VydFBvaW50XS5jaHIsIGNoclBvc2l0aW9uLCBvZmZzZXQsIGluc2VydFBvaW50XTsKICB9OwogIGZ1bmN0aW9uIHRpbGVzZXRJbmZvRnJvbUNocm9tSW5mbyhjaHJvbUluZm8sIHRpbGVTaXplID0gMTAyNCkgewogICAgcmV0dXJuIHsKICAgICAgdGlsZV9zaXplOiB0aWxlU2l6ZSwKICAgICAgYmluc19wZXJfZGltZW5zaW9uOiB0aWxlU2l6ZSwKICAgICAgbWF4X3pvb206IE1hdGguY2VpbChNYXRoLmxvZyhjaHJvbUluZm8udG90YWxMZW5ndGggLyB0aWxlU2l6ZSkgLyBNYXRoLmxvZygyKSksCiAgICAgIG1heF93aWR0aDogY2hyb21JbmZvLnRvdGFsTGVuZ3RoLAogICAgICBtaW5fcG9zOiBbMF0sCiAgICAgIG1heF9wb3M6IFtjaHJvbUluZm8udG90YWxMZW5ndGhdCiAgICB9OwogIH0KICBmdW5jdGlvbiBzaXplc1RvQ2hyb21JbmZvKHNpemVzKSB7CiAgICBjb25zdCBpbmZvID0gewogICAgICBjdW1Qb3NpdGlvbnM6IFtdLAogICAgICBjaHJvbUxlbmd0aHM6IHt9LAogICAgICBjaHJQb3NpdGlvbnM6IHt9LAogICAgICB0b3RhbExlbmd0aDogMAogICAgfTsKICAgIHNpemVzLmZvckVhY2goKFtjaHIsIGxlbmd0aF0sIGkpID0+IHsKICAgICAgY29uc3QgY2hyUG9zaXRpb24gPSB7IGlkOiBpLCBjaHIsIHBvczogaW5mby50b3RhbExlbmd0aCB9OwogICAgICBpbmZvLmNoclBvc2l0aW9uc1tjaHJdID0gY2hyUG9zaXRpb247CiAgICAgIGluZm8uY2hyb21MZW5ndGhzW2Nocl0gPSBsZW5ndGg7CiAgICAgIGluZm8uY3VtUG9zaXRpb25zLnB1c2goY2hyUG9zaXRpb24pOwogICAgICBpbmZvLnRvdGFsTGVuZ3RoICs9IGxlbmd0aDsKICAgIH0pOwogICAgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGluZm8pLCB7CiAgICAgIGFic1RvQ2hyOiAoYWJzUG9zKSA9PiBpbmZvLmNoclBvc2l0aW9ucyA/IGFic1RvQ2hyKGFic1BvcywgaW5mbykgOiBudWxsLAogICAgICBjaHJUb0FiczogKFtjaHJOYW1lLCBjaHJQb3NdKSA9PiBpbmZvLmNoclBvc2l0aW9ucyA/IGNoclRvQWJzKGNock5hbWUsIGNoclBvcywgaW5mbykgOiBudWxsCiAgICB9KTsKICB9CiAgdmFyIFJlbW90ZUZpbGUgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9nZW5lcmljX2ZpbGVoYW5kbGUuUmVtb3RlRmlsZSB7CiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTsKICAgICAgdGhpcy5yZWFkID0gKF8wLCAuLi5fMSkgPT4gX19hc3luYyh0aGlzLCBbXzAsIC4uLl8xXSwgZnVuY3Rpb24qIChidWZmZXIsIG9mZnNldCA9IDAsIGxlbmd0aCwgcG9zaXRpb24gPSAwLCBvcHRzID0ge30pIHsKICAgICAgICBjb25zdCB7IGhlYWRlcnMgPSB7fSwgc2lnbmFsLCBvdmVycmlkZXMgPSB7fSB9ID0gb3B0czsKICAgICAgICBpZiAobGVuZ3RoIDwgSW5maW5pdHkpIHsKICAgICAgICAgIGhlYWRlcnMucmFuZ2UgPSBgYnl0ZXM9JHtwb3NpdGlvbn0tJHtwb3NpdGlvbiArIGxlbmd0aH1gOwogICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID09PSBJbmZpbml0eSAmJiBwb3NpdGlvbiAhPT0gMCkgewogICAgICAgICAgaGVhZGVycy5yYW5nZSA9IGBieXRlcz0ke3Bvc2l0aW9ufS1gOwogICAgICAgIH0KICAgICAgICBjb25zdCBhcmdzID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5iYXNlT3ZlcnJpZGVzKSwgb3ZlcnJpZGVzKSwgewogICAgICAgICAgaGVhZGVyczogX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGhlYWRlcnMpLCBvdmVycmlkZXMuaGVhZGVycyksIHRoaXMuYmFzZU92ZXJyaWRlcy5oZWFkZXJzKSwKICAgICAgICAgIG1ldGhvZDogIkdFVCIsCiAgICAgICAgICByZWRpcmVjdDogImZvbGxvdyIsCiAgICAgICAgICBtb2RlOiAiY29ycyIsCiAgICAgICAgICBzaWduYWwKICAgICAgICB9KTsKICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZmV0Y2godGhpcy51cmwsIGFyZ3MpOwogICAgICAgIGlmICghcmVzcG9uc2Uub2spIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fSAke3RoaXMudXJsfWApOwogICAgICAgIH0KICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDAgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSAyMDYpIHsKICAgICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHlpZWxkIHRoaXMuZ2V0QnVmZmVyRnJvbVJlc3BvbnNlKHJlc3BvbnNlKTsKICAgICAgICAgIGNvbnN0IGJ5dGVzQ29waWVkID0gcmVzcG9uc2VEYXRhLmNvcHkoYnVmZmVyLCBvZmZzZXQsIDAsIE1hdGgubWluKGxlbmd0aCwgcmVzcG9uc2VEYXRhLmxlbmd0aCkpOwogICAgICAgICAgY29uc3QgcmVzID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoImNvbnRlbnQtcmFuZ2UiKTsKICAgICAgICAgIGNvbnN0IHNpemVNYXRjaCA9IC9cLyhcZCspJC8uZXhlYyhyZXMgfHwgIiIpOwogICAgICAgICAgaWYgKHNpemVNYXRjaCAmJiBzaXplTWF0Y2hbMV0pIHsKICAgICAgICAgICAgdGhpcy5fc3RhdCA9IHsgc2l6ZTogcGFyc2VJbnQoc2l6ZU1hdGNoWzFdLCAxMCkgfTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB7IGJ5dGVzUmVhZDogYnl0ZXNDb3BpZWQsIGJ1ZmZlciB9OwogICAgICAgIH0KICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9IGZldGNoaW5nICR7dGhpcy51cmx9YCk7CiAgICAgIH0pOwogICAgfQogIH07CgogIC8vIHNyYy9kYXRhLWZldGNoZXJzL2JhbS9iYW0td29ya2VyLnRzP3dvcmtlciZpbmxpbmU/d29ya2VyX2ZpbGUKICBmdW5jdGlvbiBwYXJzZU1EKG1kU3RyaW5nLCB1c2VDb3VudHMpIHsKICAgIGxldCBjdXJyUG9zID0gMDsKICAgIGxldCBjdXJyTnVtID0gMDsKICAgIGxldCBkZWxldGlvbkVuY291bnRlcmVkID0gZmFsc2U7CiAgICBsZXQgYmFtU2VxU2hpZnQgPSAwOwogICAgY29uc3Qgc3Vic3RpdHV0aW9ucyA9IFtdOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZFN0cmluZy5sZW5ndGg7IGkrKykgewogICAgICBpZiAobWRTdHJpbmdbaV0ubWF0Y2goL1swLTldL2cpKSB7CiAgICAgICAgY3Vyck51bSA9IGN1cnJOdW0gKiAxMCArICttZFN0cmluZ1tpXTsKICAgICAgICBkZWxldGlvbkVuY291bnRlcmVkID0gZmFsc2U7CiAgICAgIH0gZWxzZSBpZiAobWRTdHJpbmdbaV0gPT09ICJeIikgewogICAgICAgIGRlbGV0aW9uRW5jb3VudGVyZWQgPSB0cnVlOwogICAgICB9IGVsc2UgewogICAgICAgIGN1cnJQb3MgKz0gY3Vyck51bTsKICAgICAgICBpZiAodXNlQ291bnRzKSB7CiAgICAgICAgICBzdWJzdGl0dXRpb25zLnB1c2goewogICAgICAgICAgICBsZW5ndGg6IGN1cnJOdW0sCiAgICAgICAgICAgIHR5cGU6IG1kU3RyaW5nW2ldCiAgICAgICAgICB9KTsKICAgICAgICB9IGVsc2UgaWYgKGRlbGV0aW9uRW5jb3VudGVyZWQpIHsKICAgICAgICAgIGJhbVNlcVNoaWZ0IC09IDE7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHN1YnN0aXR1dGlvbnMucHVzaCh7CiAgICAgICAgICAgIHBvczogY3VyclBvcywKICAgICAgICAgICAgYmFzZTogbWRTdHJpbmdbaV0sCiAgICAgICAgICAgIGxlbmd0aDogMSwKICAgICAgICAgICAgYmFtU2VxU2hpZnQKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICBjdXJyTnVtID0gMDsKICAgICAgICBjdXJyUG9zICs9IDE7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBzdWJzdGl0dXRpb25zOwogIH0KICBmdW5jdGlvbiBnZXRTdWJzdGl0dXRpb25zKHNlZ21lbnQsIHNlcSkgewogICAgbGV0IHN1YnN0aXR1dGlvbnMgPSBbXTsKICAgIGxldCBzb2Z0Q2xpcHBpbmdBdFJlYWRTdGFydCA9IG51bGw7CiAgICBpZiAoc2VnbWVudC5jaWdhcikgewogICAgICBjb25zdCBjaWdhclN1YnMgPSBwYXJzZU1EKHNlZ21lbnQuY2lnYXIsIHRydWUpOwogICAgICBsZXQgY3VyclBvcyA9IDA7CiAgICAgIGZvciAoY29uc3Qgc3ViIG9mIGNpZ2FyU3VicykgewogICAgICAgIGlmIChzdWIudHlwZSA9PT0gIlgiKSB7CiAgICAgICAgICBzdWJzdGl0dXRpb25zLnB1c2goewogICAgICAgICAgICBwb3M6IGN1cnJQb3MsCiAgICAgICAgICAgIGxlbmd0aDogc3ViLmxlbmd0aCwKICAgICAgICAgICAgdHlwZTogIlgiCiAgICAgICAgICB9KTsKICAgICAgICAgIGN1cnJQb3MgKz0gc3ViLmxlbmd0aDsKICAgICAgICB9IGVsc2UgaWYgKHN1Yi50eXBlID09PSAiSSIpIHsKICAgICAgICAgIHN1YnN0aXR1dGlvbnMucHVzaCh7CiAgICAgICAgICAgIHBvczogY3VyclBvcywKICAgICAgICAgICAgbGVuZ3RoOiBzdWIubGVuZ3RoLAogICAgICAgICAgICB0eXBlOiAiSSIKICAgICAgICAgIH0pOwogICAgICAgIH0gZWxzZSBpZiAoc3ViLnR5cGUgPT09ICJEIikgewogICAgICAgICAgc3Vic3RpdHV0aW9ucy5wdXNoKHsKICAgICAgICAgICAgcG9zOiBjdXJyUG9zLAogICAgICAgICAgICBsZW5ndGg6IHN1Yi5sZW5ndGgsCiAgICAgICAgICAgIHR5cGU6ICJEIgogICAgICAgICAgfSk7CiAgICAgICAgICBjdXJyUG9zICs9IHN1Yi5sZW5ndGg7CiAgICAgICAgfSBlbHNlIGlmIChzdWIudHlwZSA9PT0gIk4iKSB7CiAgICAgICAgICBzdWJzdGl0dXRpb25zLnB1c2goewogICAgICAgICAgICBwb3M6IGN1cnJQb3MsCiAgICAgICAgICAgIGxlbmd0aDogc3ViLmxlbmd0aCwKICAgICAgICAgICAgdHlwZTogIk4iCiAgICAgICAgICB9KTsKICAgICAgICAgIGN1cnJQb3MgKz0gc3ViLmxlbmd0aDsKICAgICAgICB9IGVsc2UgaWYgKHN1Yi50eXBlID09PSAiPSIgfHwgc3ViLnR5cGUgPT09ICJNIikgewogICAgICAgICAgY3VyclBvcyArPSBzdWIubGVuZ3RoOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgfQogICAgICB9CiAgICAgIGNvbnN0IGZpcnN0U3ViID0gY2lnYXJTdWJzWzBdOwogICAgICBjb25zdCBsYXN0U3ViID0gY2lnYXJTdWJzW2NpZ2FyU3Vicy5sZW5ndGggLSAxXTsKICAgICAgaWYgKGZpcnN0U3ViLnR5cGUgPT09ICJTIikgewogICAgICAgIHNvZnRDbGlwcGluZ0F0UmVhZFN0YXJ0ID0gZmlyc3RTdWI7CiAgICAgICAgc3Vic3RpdHV0aW9ucy5wdXNoKHsKICAgICAgICAgIHBvczogLWZpcnN0U3ViLmxlbmd0aCwKICAgICAgICAgIHR5cGU6ICJTIiwKICAgICAgICAgIGxlbmd0aDogZmlyc3RTdWIubGVuZ3RoCiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgaWYgKGxhc3RTdWIudHlwZSA9PT0gIlMiKSB7CiAgICAgICAgc3Vic3RpdHV0aW9ucy5wdXNoKHsKICAgICAgICAgIHBvczogc2VnbWVudC5lbmQgLSBzZWdtZW50LnN0YXJ0LAogICAgICAgICAgbGVuZ3RoOiBsYXN0U3ViLmxlbmd0aCwKICAgICAgICAgIHR5cGU6ICJTIgogICAgICAgIH0pOwogICAgICB9CiAgICAgIGlmIChmaXJzdFN1Yi50eXBlID09PSAiSCIpIHsKICAgICAgICBzdWJzdGl0dXRpb25zLnB1c2goewogICAgICAgICAgcG9zOiAtZmlyc3RTdWIubGVuZ3RoLAogICAgICAgICAgdHlwZTogIkgiLAogICAgICAgICAgbGVuZ3RoOiBmaXJzdFN1Yi5sZW5ndGgKICAgICAgICB9KTsKICAgICAgfQogICAgICBpZiAobGFzdFN1Yi50eXBlID09PSAiSCIpIHsKICAgICAgICBzdWJzdGl0dXRpb25zLnB1c2goewogICAgICAgICAgcG9zOiBzZWdtZW50LmVuZCAtIHNlZ21lbnQuc3RhcnQsCiAgICAgICAgICBsZW5ndGg6IGxhc3RTdWIubGVuZ3RoLAogICAgICAgICAgdHlwZTogIkgiCiAgICAgICAgfSk7CiAgICAgIH0KICAgIH0KICAgIGlmIChzZWdtZW50Lm1kKSB7CiAgICAgIGNvbnN0IG1kU3Vic3RpdHV0aW9ucyA9IHBhcnNlTUQoc2VnbWVudC5tZCwgZmFsc2UpOwogICAgICBtZFN1YnN0aXR1dGlvbnMuZm9yRWFjaChmdW5jdGlvbihzdWJzdGl0dXRpb24pIHsKICAgICAgICBsZXQgcG9zU3RhcnQgPSBzdWJzdGl0dXRpb25bInBvcyJdICsgc3Vic3RpdHV0aW9uWyJiYW1TZXFTaGlmdCJdOwogICAgICAgIGxldCBwb3NFbmQgPSBwb3NTdGFydCArIHN1YnN0aXR1dGlvblsibGVuZ3RoIl07CiAgICAgICAgaWYgKHNvZnRDbGlwcGluZ0F0UmVhZFN0YXJ0ICE9PSBudWxsKSB7CiAgICAgICAgICBwb3NTdGFydCArPSBzb2Z0Q2xpcHBpbmdBdFJlYWRTdGFydC5sZW5ndGg7CiAgICAgICAgICBwb3NFbmQgKz0gc29mdENsaXBwaW5nQXRSZWFkU3RhcnQubGVuZ3RoOwogICAgICAgIH0KICAgICAgICBzdWJzdGl0dXRpb25bInZhcmlhbnQiXSA9IHNlcS5zdWJzdHJpbmcocG9zU3RhcnQsIHBvc0VuZCk7CiAgICAgICAgZGVsZXRlIHN1YnN0aXR1dGlvblsiYmFtU2VxU2hpZnQiXTsKICAgICAgfSk7CiAgICAgIHN1YnN0aXR1dGlvbnMgPSBtZFN1YnN0aXR1dGlvbnMuY29uY2F0KHN1YnN0aXR1dGlvbnMpOwogICAgfQogICAgcmV0dXJuIHN1YnN0aXR1dGlvbnM7CiAgfQogIHZhciBiYW1SZWNvcmRUb0pzb24gPSAoYmFtUmVjb3JkLCBjaHJOYW1lLCBjaHJPZmZzZXQpID0+IHsKICAgIGNvbnN0IHNlcSA9IGJhbVJlY29yZC5nZXQoInNlcSIpOwogICAgY29uc3Qgc2VnbWVudCA9IHsKICAgICAgaWQ6IGJhbVJlY29yZC5faWQsCiAgICAgIG5hbWU6IGJhbVJlY29yZC5nZXQoIm5hbWUiKSwKICAgICAgc3RhcnQ6ICtiYW1SZWNvcmQuZGF0YS5zdGFydCArIDEgKyBjaHJPZmZzZXQsCiAgICAgIGVuZDogK2JhbVJlY29yZC5kYXRhLmVuZCArIDEgKyBjaHJPZmZzZXQsCiAgICAgIG1kOiBiYW1SZWNvcmQuZ2V0KCJNRCIpLAogICAgICBjaHJOYW1lLAogICAgICBjaHJPZmZzZXQsCiAgICAgIGNpZ2FyOiBiYW1SZWNvcmQuZ2V0KCJjaWdhciIpLAogICAgICBtYXBxOiBiYW1SZWNvcmQuZ2V0KCJtcSIpLAogICAgICBzdHJhbmQ6IGJhbVJlY29yZC5nZXQoInN0cmFuZCIpID09PSAxID8gIisiIDogIi0iCiAgICB9OwogICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oc2VnbWVudCwgeyBzdWJzdGl0dXRpb25zOiBnZXRTdWJzdGl0dXRpb25zKHNlZ21lbnQsIHNlcSkgfSk7CiAgfTsKICB2YXIgQmFtRmlsZSA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X2JhbS5CYW1GaWxlIHsKICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHsKICAgICAgc3VwZXIoLi4uYXJncyk7CiAgICAgIHRoaXMuaGVhZGVyUHJvbWlzZSA9IHRoaXMuZ2V0SGVhZGVyKCk7CiAgICB9CiAgICBzdGF0aWMgZnJvbVVybCh1cmwsIGluZGV4VXJsKSB7CiAgICAgIHJldHVybiBuZXcgQmFtRmlsZSh7CiAgICAgICAgYmFtRmlsZWhhbmRsZTogbmV3IFJlbW90ZUZpbGUodXJsKSwKICAgICAgICBiYWlGaWxlaGFuZGxlOiBuZXcgUmVtb3RlRmlsZShpbmRleFVybCkKICAgICAgfSk7CiAgICB9CiAgfTsKICB2YXIgZGF0YVNvdXJjZXMgPSBuZXcgTWFwKCk7CiAgdmFyIGJhbUZpbGVDYWNoZSA9IG5ldyBNYXAoKTsKICB2YXIgTUFYX1RJTEVTID0gMjA7CiAgdmFyIHRpbGVWYWx1ZXMgPSBuZXcgUXVpY2tMUlUoeyBtYXhTaXplOiBNQVhfVElMRVMgfSk7CiAgdmFyIGluaXQgPSAoXzAsIF8xLCBfMiwgLi4uXzMpID0+IF9fYXN5bmModm9pZCAwLCBbXzAsIF8xLCBfMiwgLi4uXzNdLCBmdW5jdGlvbiogKHVpZCwgYmFtLCBjaHJvbVNpemVzLCBvcHRpb25zID0ge30pIHsKICAgIGlmICghYmFtRmlsZUNhY2hlLmhhcyhiYW0udXJsKSkgewogICAgICBjb25zdCBiYW1GaWxlMiA9IEJhbUZpbGUuZnJvbVVybChiYW0udXJsLCBiYW0uaW5kZXhVcmwpOwogICAgICB5aWVsZCBiYW1GaWxlMi5nZXRIZWFkZXIoKTsKICAgICAgYmFtRmlsZUNhY2hlLnNldChiYW0udXJsLCBiYW1GaWxlMik7CiAgICB9CiAgICBjb25zdCBiYW1GaWxlID0gYmFtRmlsZUNhY2hlLmdldChiYW0udXJsKTsKICAgIGNvbnN0IGRhdGFTb3VyY2UgPSBuZXcgRGF0YVNvdXJjZShiYW1GaWxlLCBjaHJvbVNpemVzLCBfX3NwcmVhZFZhbHVlcyh7CiAgICAgIGxvYWRNYXRlczogZmFsc2UsCiAgICAgIG1heEluc2VydFNpemU6IDVlMywKICAgICAgZXh0cmFjdEp1bmN0aW9uOiBmYWxzZSwKICAgICAganVuY3Rpb25NaW5Db3ZlcmFnZTogMQogICAgfSwgb3B0aW9ucykpOwogICAgZGF0YVNvdXJjZXMuc2V0KHVpZCwgZGF0YVNvdXJjZSk7CiAgfSk7CiAgdmFyIHRpbGVzZXRJbmZvID0gKHVpZCkgPT4gewogICAgcmV0dXJuIGRhdGFTb3VyY2VzLmdldCh1aWQpLnRpbGVzZXRJbmZvOwogIH07CiAgdmFyIHRpbGUgPSAodWlkLCB6LCB4KSA9PiBfX2FzeW5jKHZvaWQgMCwgbnVsbCwgZnVuY3Rpb24qICgpIHsKICAgIGNvbnN0IE1BWF9USUxFX1dJRFRIID0gMmU1OwogICAgY29uc3QgYmFtID0gZGF0YVNvdXJjZXMuZ2V0KHVpZCk7CiAgICBjb25zdCBpbmZvID0gdGlsZXNldEluZm8odWlkKTsKICAgIGlmICghKCJtYXhfd2lkdGgiIGluIGluZm8pKSB7CiAgICAgIHRocm93IG5ldyBFcnJvcigidGlsZXNldEluZm8gZG9lcyBub3QgaW5jbHVkZSBgbWF4X3dpZHRoYCwgd2hpY2ggaXMgcmVxdWlyZWQgZm9yIHRoZSBHb3NsaW5nIEJhbURhdGFGZXRjaGVyLiIpOwogICAgfQogICAgY29uc3QgdGlsZVdpZHRoID0gK2luZm8ubWF4X3dpZHRoIC8gX19wb3coMiwgK3opOwogICAgY29uc3QgcmVjb3JkUHJvbWlzZXMgPSBbXTsKICAgIGlmICh0aWxlV2lkdGggPiBNQVhfVElMRV9XSURUSCkgewogICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHJlc29sdmUoW10pKTsKICAgIH0KICAgIGxldCBtaW5YID0gaW5mby5taW5fcG9zWzBdICsgeCAqIHRpbGVXaWR0aDsKICAgIGNvbnN0IG1heFggPSBpbmZvLm1pbl9wb3NbMF0gKyAoeCArIDEpICogdGlsZVdpZHRoOwogICAgY29uc3QgeyBjaHJvbUxlbmd0aHMsIGN1bVBvc2l0aW9ucyB9ID0gYmFtLmNocm9tSW5mbzsKICAgIGNvbnN0IG9wdCA9IHsKICAgICAgdmlld0FzUGFpcnM6IGJhbS5vcHRpb25zLmxvYWRNYXRlcwogICAgfTsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VtUG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7CiAgICAgIGNvbnN0IGNocm9tTmFtZSA9IGN1bVBvc2l0aW9uc1tpXS5jaHI7CiAgICAgIGNvbnN0IGNocm9tU3RhcnQgPSBjdW1Qb3NpdGlvbnNbaV0ucG9zOwogICAgICBjb25zdCBjaHJvbUVuZCA9IGN1bVBvc2l0aW9uc1tpXS5wb3MgKyBjaHJvbUxlbmd0aHNbY2hyb21OYW1lXTsKICAgICAgdGlsZVZhbHVlcy5zZXQoYCR7dWlkfS4ke3p9LiR7eH1gLCBbXSk7CiAgICAgIGlmIChjaHJvbVN0YXJ0IDw9IG1pblggJiYgbWluWCA8IGNocm9tRW5kKSB7CiAgICAgICAgaWYgKG1heFggPiBjaHJvbUVuZCkgewogICAgICAgICAgcmVjb3JkUHJvbWlzZXMucHVzaChiYW0uZmlsZS5nZXRSZWNvcmRzRm9yUmFuZ2UoY2hyb21OYW1lLCBtaW5YIC0gY2hyb21TdGFydCwgY2hyb21FbmQgLSBjaHJvbVN0YXJ0LCBvcHQpLnRoZW4oKHJlY29yZHMpID0+IHsKICAgICAgICAgICAgY29uc3QgbWFwcGVkUmVjb3JkcyA9IHJlY29yZHMubWFwKChyZWMpID0+IGJhbVJlY29yZFRvSnNvbihyZWMsIGNocm9tTmFtZSwgY3VtUG9zaXRpb25zW2ldLnBvcykpOwogICAgICAgICAgICB0aWxlVmFsdWVzLnNldChgJHt1aWR9LiR7en0uJHt4fWAsIHRpbGVWYWx1ZXMuZ2V0KGAke3VpZH0uJHt6fS4ke3h9YCkuY29uY2F0KG1hcHBlZFJlY29yZHMpKTsKICAgICAgICAgICAgcmV0dXJuIFtdOwogICAgICAgICAgfSkpOwogICAgICAgICAgbWluWCA9IGNocm9tRW5kOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjb25zdCBzdGFydFBvcyA9IE1hdGguZmxvb3IobWluWCAtIGNocm9tU3RhcnQpOwogICAgICAgICAgY29uc3QgZW5kUG9zID0gTWF0aC5jZWlsKG1heFggLSBjaHJvbVN0YXJ0KTsKICAgICAgICAgIHJlY29yZFByb21pc2VzLnB1c2goYmFtLmZpbGUuZ2V0UmVjb3Jkc0ZvclJhbmdlKGNocm9tTmFtZSwgc3RhcnRQb3MsIGVuZFBvcywgb3B0KS50aGVuKChyZWNvcmRzKSA9PiB7CiAgICAgICAgICAgIGNvbnN0IG1hcHBlZFJlY29yZHMgPSByZWNvcmRzLm1hcCgocmVjKSA9PiBiYW1SZWNvcmRUb0pzb24ocmVjLCBjaHJvbU5hbWUsIGN1bVBvc2l0aW9uc1tpXS5wb3MpKTsKICAgICAgICAgICAgdGlsZVZhbHVlcy5zZXQoYCR7dWlkfS4ke3p9LiR7eH1gLCB0aWxlVmFsdWVzLmdldChgJHt1aWR9LiR7en0uJHt4fWApLmNvbmNhdChtYXBwZWRSZWNvcmRzKSk7CiAgICAgICAgICAgIHJldHVybiBbXTsKICAgICAgICAgIH0pKTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgcmV0dXJuIFByb21pc2UuYWxsKHJlY29yZFByb21pc2VzKS50aGVuKCh2YWx1ZXMpID0+IHsKICAgICAgcmV0dXJuIHZhbHVlcy5mbGF0KCk7CiAgICB9KTsKICB9KTsKICB2YXIgZmV0Y2hUaWxlc0RlYm91bmNlZCA9ICh1aWQsIHRpbGVJZHMpID0+IF9fYXN5bmModm9pZCAwLCBudWxsLCBmdW5jdGlvbiogKCkgewogICAgY29uc3QgdGlsZXMgPSB7fTsKICAgIGNvbnN0IHZhbGlkVGlsZUlkcyA9IFtdOwogICAgY29uc3QgdGlsZVByb21pc2VzID0gW107CiAgICBmb3IgKGNvbnN0IHRpbGVJZCBvZiB0aWxlSWRzKSB7CiAgICAgIGNvbnN0IHBhcnRzID0gdGlsZUlkLnNwbGl0KCIuIik7CiAgICAgIGNvbnN0IHogPSBwYXJzZUludChwYXJ0c1swXSwgMTApOwogICAgICBjb25zdCB4ID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTsKICAgICAgaWYgKE51bWJlci5pc05hTih4KSB8fCBOdW1iZXIuaXNOYU4oeikpIHsKICAgICAgICBjb25zb2xlLndhcm4oIkludmFsaWQgdGlsZSB6b29tIG9yIHBvc2l0aW9uOiIsIHosIHgpOwogICAgICAgIGNvbnRpbnVlOwogICAgICB9CiAgICAgIHZhbGlkVGlsZUlkcy5wdXNoKHRpbGVJZCk7CiAgICAgIHRpbGVQcm9taXNlcy5wdXNoKHRpbGUodWlkLCB6LCB4KSk7CiAgICB9CiAgICByZXR1cm4gUHJvbWlzZS5hbGwodGlsZVByb21pc2VzKS50aGVuKCh2YWx1ZXMpID0+IHsKICAgICAgdmFsdWVzLmZvckVhY2goKGQsIGkpID0+IHsKICAgICAgICBjb25zdCB2YWxpZFRpbGVJZCA9IHZhbGlkVGlsZUlkc1tpXTsKICAgICAgICB0aWxlc1t2YWxpZFRpbGVJZF0gPSBPYmplY3QuYXNzaWduKGQsIHsgdGlsZVBvc2l0aW9uSWQ6IHZhbGlkVGlsZUlkIH0pOwogICAgICB9KTsKICAgICAgcmV0dXJuIHRpbGVzOwogICAgfSk7CiAgfSk7CiAgdmFyIGdldFRhYnVsYXJEYXRhID0gKHVpZCwgdGlsZUlkcykgPT4gewogICAgY29uc3QgeyBvcHRpb25zIH0gPSBkYXRhU291cmNlcy5nZXQodWlkKTsKICAgIGNvbnN0IGFsbFNlZ21lbnRzID0ge307CiAgICBmb3IgKGNvbnN0IHRpbGVJZCBvZiB0aWxlSWRzKSB7CiAgICAgIGNvbnN0IHRpbGVWYWx1ZSA9IHRpbGVWYWx1ZXMuZ2V0KGAke3VpZH0uJHt0aWxlSWR9YCk7CiAgICAgIGlmICghdGlsZVZhbHVlKSB7CiAgICAgICAgY29udGludWU7CiAgICAgIH0KICAgICAgaWYgKCJlcnJvciIgaW4gdGlsZVZhbHVlKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRpbGVWYWx1ZS5lcnJvcik7CiAgICAgIH0KICAgICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHRpbGVWYWx1ZSkgewogICAgICAgIGFsbFNlZ21lbnRzW3NlZ21lbnQuaWRdID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgc2VnbWVudCksIHsKICAgICAgICAgIHN1YnN0aXR1dGlvbnM6IEpTT04uc3RyaW5naWZ5KHNlZ21lbnQuc3Vic3RpdHV0aW9ucykKICAgICAgICB9KTsKICAgICAgfQogICAgfQogICAgY29uc3Qgc2VnbWVudHMgPSBPYmplY3QudmFsdWVzKGFsbFNlZ21lbnRzKTsKICAgIGlmIChvcHRpb25zLmxvYWRNYXRlcykgewogICAgICBmaW5kTWF0ZXMoc2VnbWVudHMsIG9wdGlvbnMubWF4SW5zZXJ0U2l6ZSk7CiAgICB9CiAgICBsZXQgb3V0cHV0OwogICAgaWYgKG9wdGlvbnMuZXh0cmFjdEp1bmN0aW9uKSB7CiAgICAgIG91dHB1dCA9IGZpbmRKdW5jdGlvbnMoc2VnbWVudHMsIG9wdGlvbnMuanVuY3Rpb25NaW5Db3ZlcmFnZSk7CiAgICB9IGVsc2UgewogICAgICBvdXRwdXQgPSBzZWdtZW50czsKICAgIH0KICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShKU09OLnN0cmluZ2lmeShvdXRwdXQpKS5idWZmZXI7CiAgICByZXR1cm4gVHJhbnNmZXIoYnVmZmVyLCBbYnVmZmVyXSk7CiAgfTsKICB2YXIgZ3JvdXBCeSA9ICh4cywga2V5KSA9PiB4cy5yZWR1Y2UoKHJ2LCB4KSA9PiB7CiAgICAocnZbeFtrZXldXSA9IHJ2W3hba2V5XV0gfHwgW10pLnB1c2goeCk7CiAgICByZXR1cm4gcnY7CiAgfSwge30pOwogIHZhciBmaW5kTWF0ZXMgPSAoc2VnbWVudHMsIG1heEluc2VydFNpemUgPSAwKSA9PiB7CiAgICBjb25zdCBzZWdtZW50c0J5UmVhZE5hbWUgPSBncm91cEJ5KHNlZ21lbnRzLCAibmFtZSIpOwogICAgT2JqZWN0LnZhbHVlcyhzZWdtZW50c0J5UmVhZE5hbWUpLmZvckVhY2goKHNlZ21lbnRHcm91cCkgPT4gewogICAgICBpZiAoc2VnbWVudEdyb3VwLmxlbmd0aCA9PT0gMikgewogICAgICAgIGNvbnN0IHJlYWQgPSBzZWdtZW50R3JvdXBbMF07CiAgICAgICAgY29uc3QgbWF0ZSA9IHNlZ21lbnRHcm91cFsxXTsKICAgICAgICByZWFkLm1hdGVJZHMgPSBbbWF0ZS5pZF07CiAgICAgICAgbWF0ZS5tYXRlSWRzID0gW3JlYWQuaWRdOwogICAgICAgIGNvbnN0IFtsLCByXSA9IFtyZWFkLCBtYXRlXS5zb3J0KChhLCBiKSA9PiArYS5zdGFydCAtICtiLnN0YXJ0KTsKICAgICAgICBjb25zdCBpbnNlcnRTaXplID0gTWF0aC5tYXgoMCwgK3Iuc3RhcnQgLSArbC5lbmQpOwogICAgICAgIGNvbnN0IGxhcmdlSW5zZXJ0U2l6ZSA9IGluc2VydFNpemUgPj0gbWF4SW5zZXJ0U2l6ZTsKICAgICAgICBsZXQgc3ZUeXBlOwogICAgICAgIGlmICghbGFyZ2VJbnNlcnRTaXplKSB7CiAgICAgICAgICBzdlR5cGUgPSAibm9ybWFsIHJlYWQiOwogICAgICAgIH0gZWxzZSBpZiAobC5zdHJhbmQgPT09ICIrIiAmJiByLnN0cmFuZCA9PT0gIi0iKSB7CiAgICAgICAgICBzdlR5cGUgPSAiZGVsZXRpb24gKCstKSI7CiAgICAgICAgfSBlbHNlIGlmIChsLnN0cmFuZCA9PT0gIisiICYmIHIuc3RyYW5kID09PSAiKyIpIHsKICAgICAgICAgIHN2VHlwZSA9ICJpbnZlcnNpb24gKCsrKSI7CiAgICAgICAgfSBlbHNlIGlmIChsLnN0cmFuZCA9PT0gIi0iICYmIHIuc3RyYW5kID09PSAiLSIpIHsKICAgICAgICAgIHN2VHlwZSA9ICJpbnZlcnNpb24gKC0tKSI7CiAgICAgICAgfSBlbHNlIGlmIChsLnN0cmFuZCA9PT0gIi0iICYmIHIuc3RyYW5kID09PSAiKyIpIHsKICAgICAgICAgIHN2VHlwZSA9ICJkdXBsaWNhdGlvbiAoLSspIjsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgc3ZUeXBlID0gYCgke2wuc3RyYW5kfSR7ci5zdHJhbmR9KWA7CiAgICAgICAgfQogICAgICAgIFtyZWFkLCBtYXRlXS5mb3JFYWNoKChkKSA9PiB7CiAgICAgICAgICBkLmZvdW5kTWF0ZSA9IHRydWU7CiAgICAgICAgICBkLmluc2VydFNpemUgPSBpbnNlcnRTaXplOwogICAgICAgICAgZC5sYXJnZUluc2VydFNpemUgPSBsYXJnZUluc2VydFNpemU7CiAgICAgICAgICBkLnN2VHlwZSA9IHN2VHlwZTsKICAgICAgICAgIGQubnVtTWF0ZXMgPSAyOwogICAgICAgIH0pOwogICAgICB9IGVsc2UgewogICAgICAgIHNlZ21lbnRHcm91cC5mb3JFYWNoKChkKSA9PiB7CiAgICAgICAgICBkLm1hdGVJZHMgPSBzZWdtZW50R3JvdXAuZmlsdGVyKChtYXRlKSA9PiBtYXRlLmlkICE9PSBkLmlkKS5tYXAoKG1hdGUpID0+IG1hdGUuaWQpOwogICAgICAgICAgZC5mb3VuZE1hdGUgPSBmYWxzZTsKICAgICAgICAgIGQuaW5zZXJ0U2l6ZSA9IC0xOwogICAgICAgICAgZC5sYXJnZUluc2VydFNpemUgPSBmYWxzZTsKICAgICAgICAgIGQuc3ZUeXBlID0gc2VnbWVudEdyb3VwLmxlbmd0aCA9PT0gMSA/ICJtYXRlcyBub3QgZm91bmQgd2l0aGluIGNocm9tb3NvbWUiIDogIm1vcmUgdGhhbiB0d28gbWF0ZXMiOwogICAgICAgICAgZC5udW1NYXRlcyA9IHNlZ21lbnRHcm91cC5sZW5ndGg7CiAgICAgICAgfSk7CiAgICAgIH0KICAgIH0pOwogICAgcmV0dXJuIHNlZ21lbnRzQnlSZWFkTmFtZTsKICB9OwogIHZhciBmaW5kSnVuY3Rpb25zID0gKHNlZ21lbnRzLCBtaW5Db3ZlcmFnZSA9IDApID0+IHsKICAgIGNvbnN0IGp1bmN0aW9ucyA9IFtdOwogICAgc2VnbWVudHMuZm9yRWFjaCgoc2VnbWVudCkgPT4gewogICAgICBjb25zdCBzdWJzdGl0dXRpb25zID0gSlNPTi5wYXJzZShzZWdtZW50LnN1YnN0aXR1dGlvbnMpOwogICAgICBzdWJzdGl0dXRpb25zLmZvckVhY2goKHN1YikgPT4gewogICAgICAgIGNvbnN0IGRvbiA9IHNlZ21lbnQuc3RhcnQgKyBzdWIucG9zOwogICAgICAgIGNvbnN0IGFjYyA9IHNlZ21lbnQuc3RhcnQgKyBzdWIucG9zICsgc3ViLmxlbmd0aDsKICAgICAgICBpZiAoc2VnbWVudC5zdGFydCA8IGRvbiAmJiBhY2MgPCBzZWdtZW50LmVuZCkgewogICAgICAgICAgY29uc3QgaiA9IGp1bmN0aW9ucy5maW5kKChkKSA9PiBkLnN0YXJ0ID09PSBkb24gJiYgZC5lbmQgPT09IGFjYyk7CiAgICAgICAgICBpZiAoaikgewogICAgICAgICAgICBqLnNjb3JlICs9IDE7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBqdW5jdGlvbnMucHVzaCh7IHN0YXJ0OiBkb24sIGVuZDogYWNjLCBzY29yZTogMSB9KTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0pOwogICAgfSk7CiAgICByZXR1cm4ganVuY3Rpb25zLmZpbHRlcigoZCkgPT4gZC5zY29yZSA+PSBtaW5Db3ZlcmFnZSk7CiAgfTsKICB2YXIgdGlsZUZ1bmN0aW9ucyA9IHsKICAgIGluaXQsCiAgICB0aWxlc2V0SW5mbywKICAgIGZldGNoVGlsZXNEZWJvdW5jZWQsCiAgICB0aWxlLAogICAgZ2V0VGFidWxhckRhdGEKICB9OwogIGV4cG9zZSh0aWxlRnVuY3Rpb25zKTsKfSkoKTsKLyohCiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLgogKgogKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPgogKiBAbGljZW5zZSAgTUlUCiAqLwovKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqLwo=";
const blob$1 = typeof window !== "undefined" && window.Blob && new Blob([atob(encodedJs$1)], { type: "text/javascript;charset=utf-8" });
function Worker$2() {
  const objURL = blob$1 && (window.URL || window.webkitURL).createObjectURL(blob$1);
  try {
    return objURL ? new Worker(objURL) : new Worker("data:application/javascript;base64," + encodedJs$1, { type: "module" });
  } finally {
    objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
  }
}
const DEBOUNCE_TIME$1 = 200;
class BamDataFetcher {
  constructor(HGC, config2) {
    this.dataConfig = {};
    this.MAX_TILE_WIDTH = 2e4;
    this.uid = HGC.libraries.slugid.nice();
    this.toFetch = /* @__PURE__ */ new Set();
    const { url, indexUrl, assembly, ...options } = config2;
    this.worker = spawn(new Worker$2()).then(async (worker) => {
      const chromSizes = Object.entries(computeChromSizes(assembly).size);
      await worker.init(this.uid, { url, indexUrl }, chromSizes, options);
      return worker;
    });
  }
  async tilesetInfo(callback) {
    (await this.worker).tilesetInfo(this.uid).then(callback);
  }
  fetchTilesDebounced(receivedTiles, tileIds) {
    var _a;
    const { toFetch } = this;
    const thisZoomLevel = tileIds[0].split(".")[0];
    const toFetchZoomLevel = toFetch.size ? [...toFetch][0].split(".")[0] : null;
    if (thisZoomLevel !== toFetchZoomLevel) {
      for (const tileId of this.toFetch) {
        (_a = this.track) == null ? void 0 : _a.fetching.delete(tileId);
      }
      this.toFetch.clear();
    }
    tileIds.forEach((x) => this.toFetch.add(x));
    if (this.fetchTimeout) {
      clearTimeout(this.fetchTimeout);
    }
    this.fetchTimeout = setTimeout(() => {
      this.sendFetch(receivedTiles, [...this.toFetch]);
      this.toFetch.clear();
    }, DEBOUNCE_TIME$1);
  }
  async sendFetch(receivedTiles, tileIds) {
    (await this.worker).fetchTilesDebounced(this.uid, tileIds).then(receivedTiles);
  }
  async getTabularData(tileIds) {
    const buf = await (await this.worker).getTabularData(this.uid, tileIds);
    return JSON.parse(new TextDecoder().decode(buf));
  }
}
BamDataFetcher.config = { type: "bam" };
const encodedJs = "KCgpID0+IHsKICB2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlOwogIHZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7CiAgdmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllczsKICB2YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7CiAgdmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7CiAgdmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7CiAgdmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzOwogIHZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7CiAgdmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7CiAgdmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7CiAgdmFyIF9fcG93ID0gTWF0aC5wb3c7CiAgdmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlOwogIHZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7CiAgICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpCiAgICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSkKICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7CiAgICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scykKICAgICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7CiAgICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKQogICAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pOwogICAgICB9CiAgICByZXR1cm4gYTsKICB9OwogIHZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpOwogIHZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICB2YXIgX19lc20gPSAoZm4sIHJlcykgPT4gZnVuY3Rpb24gX19pbml0KCkgewogICAgcmV0dXJuIGZuICYmIChyZXMgPSAoMCwgZm5bT2JqZWN0LmtleXMoZm4pWzBdXSkoZm4gPSAwKSksIHJlczsKICB9OwogIHZhciBfX2NvbW1vbkpTID0gKGNiLCBtb2QpID0+IGZ1bmN0aW9uIF9fcmVxdWlyZSgpIHsKICAgIHJldHVybiBtb2QgfHwgKDAsIGNiW09iamVjdC5rZXlzKGNiKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzOwogIH07CiAgdmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7CiAgICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gIm9iamVjdCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKQogICAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gImRlZmF1bHQiKQogICAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTsKICAgIH0KICAgIHJldHVybiB0YXJnZXQ7CiAgfTsKICB2YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7CiAgICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCAiZGVmYXVsdCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmICJkZWZhdWx0IiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpOwogIH07CiAgdmFyIF9fYXN5bmMgPSAoX190aGlzLCBfX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSA9PiB7CiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gewogICAgICB2YXIgZnVsZmlsbGVkID0gKHZhbHVlKSA9PiB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICByZWplY3QoZSk7CiAgICAgICAgfQogICAgICB9OwogICAgICB2YXIgcmVqZWN0ZWQgPSAodmFsdWUpID0+IHsKICAgICAgICB0cnkgewogICAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICByZWplY3QoZSk7CiAgICAgICAgfQogICAgICB9OwogICAgICB2YXIgc3RlcCA9ICh4KSA9PiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7CiAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTsKICAgIH0pOwogIH07CgogIC8vIG5vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMKICB2YXIgcmVxdWlyZV9iYXNlNjRfanMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgZXhwb3J0czIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7CiAgICAgIGV4cG9ydHMyLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXk7CiAgICAgIGV4cG9ydHMyLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5OwogICAgICB2YXIgbG9va3VwID0gW107CiAgICAgIHZhciByZXZMb29rdXAgPSBbXTsKICAgICAgdmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAidW5kZWZpbmVkIiA/IFVpbnQ4QXJyYXkgOiBBcnJheTsKICAgICAgdmFyIGNvZGUgPSAiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyI7CiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHsKICAgICAgICBsb29rdXBbaV0gPSBjb2RlW2ldOwogICAgICAgIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaTsKICAgICAgfQogICAgICB2YXIgaTsKICAgICAgdmFyIGxlbjsKICAgICAgcmV2TG9va3VwWyItIi5jaGFyQ29kZUF0KDApXSA9IDYyOwogICAgICByZXZMb29rdXBbIl8iLmNoYXJDb2RlQXQoMCldID0gNjM7CiAgICAgIGZ1bmN0aW9uIGdldExlbnMoYjY0KSB7CiAgICAgICAgdmFyIGxlbjIgPSBiNjQubGVuZ3RoOwogICAgICAgIGlmIChsZW4yICUgNCA+IDApIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCIpOwogICAgICAgIH0KICAgICAgICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZigiPSIpOwogICAgICAgIGlmICh2YWxpZExlbiA9PT0gLTEpCiAgICAgICAgICB2YWxpZExlbiA9IGxlbjI7CiAgICAgICAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW4yID8gMCA6IDQgLSB2YWxpZExlbiAlIDQ7CiAgICAgICAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXTsKICAgICAgfQogICAgICBmdW5jdGlvbiBieXRlTGVuZ3RoKGI2NCkgewogICAgICAgIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpOwogICAgICAgIHZhciB2YWxpZExlbiA9IGxlbnNbMF07CiAgICAgICAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV07CiAgICAgICAgcmV0dXJuICh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCAtIHBsYWNlSG9sZGVyc0xlbjsKICAgICAgfQogICAgICBmdW5jdGlvbiBfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHsKICAgICAgICByZXR1cm4gKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzTGVuOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHRvQnl0ZUFycmF5KGI2NCkgewogICAgICAgIHZhciB0bXA7CiAgICAgICAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NCk7CiAgICAgICAgdmFyIHZhbGlkTGVuID0gbGVuc1swXTsKICAgICAgICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXTsKICAgICAgICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKTsKICAgICAgICB2YXIgY3VyQnl0ZSA9IDA7CiAgICAgICAgdmFyIGxlbjIgPSBwbGFjZUhvbGRlcnNMZW4gPiAwID8gdmFsaWRMZW4gLSA0IDogdmFsaWRMZW47CiAgICAgICAgdmFyIGkyOwogICAgICAgIGZvciAoaTIgPSAwOyBpMiA8IGxlbjI7IGkyICs9IDQpIHsKICAgICAgICAgIHRtcCA9IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMildIDw8IDE4IHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMSldIDw8IDEyIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMildIDw8IDYgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAzKV07CiAgICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCA+PiAxNiAmIDI1NTsKICAgICAgICAgIGFycltjdXJCeXRlKytdID0gdG1wID4+IDggJiAyNTU7CiAgICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDI1NTsKICAgICAgICB9CiAgICAgICAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikgewogICAgICAgICAgdG1wID0gcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyKV0gPDwgMiB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDEpXSA+PiA0OwogICAgICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAyNTU7CiAgICAgICAgfQogICAgICAgIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHsKICAgICAgICAgIHRtcCA9IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMildIDw8IDEwIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMSldIDw8IDQgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAyKV0gPj4gMjsKICAgICAgICAgIGFycltjdXJCeXRlKytdID0gdG1wID4+IDggJiAyNTU7CiAgICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDI1NTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGFycjsKICAgICAgfQogICAgICBmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQobnVtKSB7CiAgICAgICAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiA2M10gKyBsb29rdXBbbnVtID4+IDEyICYgNjNdICsgbG9va3VwW251bSA+PiA2ICYgNjNdICsgbG9va3VwW251bSAmIDYzXTsKICAgICAgfQogICAgICBmdW5jdGlvbiBlbmNvZGVDaHVuayh1aW50OCwgc3RhcnQsIGVuZCkgewogICAgICAgIHZhciB0bXA7CiAgICAgICAgdmFyIG91dHB1dCA9IFtdOwogICAgICAgIGZvciAodmFyIGkyID0gc3RhcnQ7IGkyIDwgZW5kOyBpMiArPSAzKSB7CiAgICAgICAgICB0bXAgPSAodWludDhbaTJdIDw8IDE2ICYgMTY3MTE2ODApICsgKHVpbnQ4W2kyICsgMV0gPDwgOCAmIDY1MjgwKSArICh1aW50OFtpMiArIDJdICYgMjU1KTsKICAgICAgICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG91dHB1dC5qb2luKCIiKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBmcm9tQnl0ZUFycmF5KHVpbnQ4KSB7CiAgICAgICAgdmFyIHRtcDsKICAgICAgICB2YXIgbGVuMiA9IHVpbnQ4Lmxlbmd0aDsKICAgICAgICB2YXIgZXh0cmFCeXRlcyA9IGxlbjIgJSAzOwogICAgICAgIHZhciBwYXJ0cyA9IFtdOwogICAgICAgIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzOwogICAgICAgIGZvciAodmFyIGkyID0gMCwgbGVuMjIgPSBsZW4yIC0gZXh0cmFCeXRlczsgaTIgPCBsZW4yMjsgaTIgKz0gbWF4Q2h1bmtMZW5ndGgpIHsKICAgICAgICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGkyLCBpMiArIG1heENodW5rTGVuZ3RoID4gbGVuMjIgPyBsZW4yMiA6IGkyICsgbWF4Q2h1bmtMZW5ndGgpKTsKICAgICAgICB9CiAgICAgICAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHsKICAgICAgICAgIHRtcCA9IHVpbnQ4W2xlbjIgLSAxXTsKICAgICAgICAgIHBhcnRzLnB1c2gobG9va3VwW3RtcCA+PiAyXSArIGxvb2t1cFt0bXAgPDwgNCAmIDYzXSArICI9PSIpOwogICAgICAgIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikgewogICAgICAgICAgdG1wID0gKHVpbnQ4W2xlbjIgLSAyXSA8PCA4KSArIHVpbnQ4W2xlbjIgLSAxXTsKICAgICAgICAgIHBhcnRzLnB1c2gobG9va3VwW3RtcCA+PiAxMF0gKyBsb29rdXBbdG1wID4+IDQgJiA2M10gKyBsb29rdXBbdG1wIDw8IDIgJiA2M10gKyAiPSIpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcGFydHMuam9pbigiIik7CiAgICAgIH0KICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMKICB2YXIgcmVxdWlyZV9pZWVlNzU0ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgZXhwb3J0czIucmVhZCA9IGZ1bmN0aW9uKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHsKICAgICAgICB2YXIgZSwgbTsKICAgICAgICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTsKICAgICAgICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTsKICAgICAgICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7CiAgICAgICAgdmFyIG5CaXRzID0gLTc7CiAgICAgICAgdmFyIGkgPSBpc0xFID8gbkJ5dGVzIC0gMSA6IDA7CiAgICAgICAgdmFyIGQgPSBpc0xFID8gLTEgOiAxOwogICAgICAgIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldOwogICAgICAgIGkgKz0gZDsKICAgICAgICBlID0gcyAmICgxIDw8IC1uQml0cykgLSAxOwogICAgICAgIHMgPj49IC1uQml0czsKICAgICAgICBuQml0cyArPSBlTGVuOwogICAgICAgIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHsKICAgICAgICB9CiAgICAgICAgbSA9IGUgJiAoMSA8PCAtbkJpdHMpIC0gMTsKICAgICAgICBlID4+PSAtbkJpdHM7CiAgICAgICAgbkJpdHMgKz0gbUxlbjsKICAgICAgICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7CiAgICAgICAgfQogICAgICAgIGlmIChlID09PSAwKSB7CiAgICAgICAgICBlID0gMSAtIGVCaWFzOwogICAgICAgIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkgewogICAgICAgICAgcmV0dXJuIG0gPyBOYU4gOiAocyA/IC0xIDogMSkgKiBJbmZpbml0eTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTsKICAgICAgICAgIGUgPSBlIC0gZUJpYXM7CiAgICAgICAgfQogICAgICAgIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pOwogICAgICB9OwogICAgICBleHBvcnRzMi53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7CiAgICAgICAgdmFyIGUsIG0sIGM7CiAgICAgICAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7CiAgICAgICAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7CiAgICAgICAgdmFyIGVCaWFzID0gZU1heCA+PiAxOwogICAgICAgIHZhciBydCA9IG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwOwogICAgICAgIHZhciBpID0gaXNMRSA/IDAgOiBuQnl0ZXMgLSAxOwogICAgICAgIHZhciBkID0gaXNMRSA/IDEgOiAtMTsKICAgICAgICB2YXIgcyA9IHZhbHVlIDwgMCB8fCB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwID8gMSA6IDA7CiAgICAgICAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7CiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHsKICAgICAgICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDsKICAgICAgICAgIGUgPSBlTWF4OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7CiAgICAgICAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7CiAgICAgICAgICAgIGUtLTsKICAgICAgICAgICAgYyAqPSAyOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7CiAgICAgICAgICAgIHZhbHVlICs9IHJ0IC8gYzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh2YWx1ZSAqIGMgPj0gMikgewogICAgICAgICAgICBlKys7CiAgICAgICAgICAgIGMgLz0gMjsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkgewogICAgICAgICAgICBtID0gMDsKICAgICAgICAgICAgZSA9IGVNYXg7CiAgICAgICAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7CiAgICAgICAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTsKICAgICAgICAgICAgZSA9IGUgKyBlQmlhczsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTsKICAgICAgICAgICAgZSA9IDA7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAyNTUsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkgewogICAgICAgIH0KICAgICAgICBlID0gZSA8PCBtTGVuIHwgbTsKICAgICAgICBlTGVuICs9IG1MZW47CiAgICAgICAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMjU1LCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHsKICAgICAgICB9CiAgICAgICAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4OwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfYnVmZmVyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBiYXNlNjQgPSByZXF1aXJlX2Jhc2U2NF9qcygpOwogICAgICB2YXIgaWVlZTc1NCA9IHJlcXVpcmVfaWVlZTc1NCgpOwogICAgICB2YXIgY3VzdG9tSW5zcGVjdFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICJmdW5jdGlvbiIgJiYgdHlwZW9mIFN5bWJvbFsiZm9yIl0gPT09ICJmdW5jdGlvbiIgPyBTeW1ib2xbImZvciJdKCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbSIpIDogbnVsbDsKICAgICAgZXhwb3J0czIuQnVmZmVyID0gQnVmZmVyNDsKICAgICAgZXhwb3J0czIuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXI7CiAgICAgIGV4cG9ydHMyLklOU1BFQ1RfTUFYX0JZVEVTID0gNTA7CiAgICAgIHZhciBLX01BWF9MRU5HVEggPSAyMTQ3NDgzNjQ3OwogICAgICBleHBvcnRzMi5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIOwogICAgICBCdWZmZXI0LlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpOwogICAgICBpZiAoIUJ1ZmZlcjQuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gInVuZGVmaW5lZCIgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICBjb25zb2xlLmVycm9yKCJUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4iKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCgpIHsKICAgICAgICB0cnkgewogICAgICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSk7CiAgICAgICAgICBjb25zdCBwcm90byA9IHsgZm9vOiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgcmV0dXJuIDQyOwogICAgICAgICAgfSB9OwogICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb3RvLCBVaW50OEFycmF5LnByb3RvdHlwZSk7CiAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJyLCBwcm90byk7CiAgICAgICAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MjsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICB9CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXI0LnByb3RvdHlwZSwgInBhcmVudCIsIHsKICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgICAgIGdldDogZnVuY3Rpb24oKSB7CiAgICAgICAgICBpZiAoIUJ1ZmZlcjQuaXNCdWZmZXIodGhpcykpCiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7CiAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXI7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlcjQucHJvdG90eXBlLCAib2Zmc2V0IiwgewogICAgICAgIGVudW1lcmFibGU6IHRydWUsCiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgICAgIGlmICghQnVmZmVyNC5pc0J1ZmZlcih0aGlzKSkKICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXQ7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgZnVuY3Rpb24gY3JlYXRlQnVmZmVyKGxlbmd0aCkgewogICAgICAgIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgIicgKyBsZW5ndGggKyAnIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gInNpemUiJyk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7CiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyNC5wcm90b3R5cGUpOwogICAgICAgIHJldHVybiBidWY7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gQnVmZmVyNChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewogICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAibnVtYmVyIikgewogICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAic3RyaW5nIikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgInN0cmluZyIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7CiAgICAgIH0KICAgICAgQnVmZmVyNC5wb29sU2l6ZSA9IDgxOTI7CiAgICAgIGZ1bmN0aW9uIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewogICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCk7CiAgICAgICAgfQogICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7CiAgICAgICAgICByZXR1cm4gZnJvbUFycmF5Vmlldyh2YWx1ZSk7CiAgICAgICAgfQogICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAiICsgdHlwZW9mIHZhbHVlKTsKICAgICAgICB9CiAgICAgICAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fCB2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSB7CiAgICAgICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAidW5kZWZpbmVkIiAmJiAoaXNJbnN0YW5jZSh2YWx1ZSwgU2hhcmVkQXJyYXlCdWZmZXIpIHx8IHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKSB7CiAgICAgICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAibnVtYmVyIikgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlICJ2YWx1ZSIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJyk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKTsKICAgICAgICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7CiAgICAgICAgICByZXR1cm4gQnVmZmVyNC5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGIgPSBmcm9tT2JqZWN0KHZhbHVlKTsKICAgICAgICBpZiAoYikKICAgICAgICAgIHJldHVybiBiOwogICAgICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSAidW5kZWZpbmVkIiAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgcmV0dXJuIEJ1ZmZlcjQuZnJvbSh2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCJzdHJpbmciKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgIiArIHR5cGVvZiB2YWx1ZSk7CiAgICAgIH0KICAgICAgQnVmZmVyNC5mcm9tID0gZnVuY3Rpb24odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewogICAgICAgIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpOwogICAgICB9OwogICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyNC5wcm90b3R5cGUsIFVpbnQ4QXJyYXkucHJvdG90eXBlKTsKICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlcjQsIFVpbnQ4QXJyYXkpOwogICAgICBmdW5jdGlvbiBhc3NlcnRTaXplKHNpemUpIHsKICAgICAgICBpZiAodHlwZW9mIHNpemUgIT09ICJudW1iZXIiKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcic2l6ZSIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpOwogICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgIicgKyBzaXplICsgJyIgaXMgaW52YWxpZCBmb3Igb3B0aW9uICJzaXplIicpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZykgewogICAgICAgIGFzc2VydFNpemUoc2l6ZSk7CiAgICAgICAgaWYgKHNpemUgPD0gMCkgewogICAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKTsKICAgICAgICB9CiAgICAgICAgaWYgKGZpbGwgIT09IHZvaWQgMCkgewogICAgICAgICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gInN0cmluZyIgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZykgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKTsKICAgICAgfQogICAgICBCdWZmZXI0LmFsbG9jID0gZnVuY3Rpb24oc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHsKICAgICAgICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpOwogICAgICB9OwogICAgICBmdW5jdGlvbiBhbGxvY1Vuc2FmZShzaXplKSB7CiAgICAgICAgYXNzZXJ0U2l6ZShzaXplKTsKICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKTsKICAgICAgfQogICAgICBCdWZmZXI0LmFsbG9jVW5zYWZlID0gZnVuY3Rpb24oc2l6ZSkgewogICAgICAgIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKTsKICAgICAgfTsKICAgICAgQnVmZmVyNC5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbihzaXplKSB7CiAgICAgICAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpOwogICAgICB9OwogICAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0cmluZywgZW5jb2RpbmcpIHsKICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAic3RyaW5nIiB8fCBlbmNvZGluZyA9PT0gIiIpIHsKICAgICAgICAgIGVuY29kaW5nID0gInV0ZjgiOwogICAgICAgIH0KICAgICAgICBpZiAoIUJ1ZmZlcjQuaXNFbmNvZGluZyhlbmNvZGluZykpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIlVua25vd24gZW5jb2Rpbmc6ICIgKyBlbmNvZGluZyk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwOwogICAgICAgIGxldCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKTsKICAgICAgICBjb25zdCBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZyk7CiAgICAgICAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7CiAgICAgICAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfQogICAgICBmdW5jdGlvbiBmcm9tQXJyYXlMaWtlKGFycmF5KSB7CiAgICAgICAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwOwogICAgICAgIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1OwogICAgICAgIH0KICAgICAgICByZXR1cm4gYnVmOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZyb21BcnJheVZpZXcoYXJyYXlWaWV3KSB7CiAgICAgICAgaWYgKGlzSW5zdGFuY2UoYXJyYXlWaWV3LCBVaW50OEFycmF5KSkgewogICAgICAgICAgY29uc3QgY29weSA9IG5ldyBVaW50OEFycmF5KGFycmF5Vmlldyk7CiAgICAgICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKGNvcHkuYnVmZmVyLCBjb3B5LmJ5dGVPZmZzZXQsIGNvcHkuYnl0ZUxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKGFycmF5Vmlldyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCcib2Zmc2V0IiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKTsKICAgICAgICB9CiAgICAgICAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJyJsZW5ndGgiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpOwogICAgICAgIH0KICAgICAgICBsZXQgYnVmOwogICAgICAgIGlmIChieXRlT2Zmc2V0ID09PSB2b2lkIDAgJiYgbGVuZ3RoID09PSB2b2lkIDApIHsKICAgICAgICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KTsKICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpOwogICAgICAgIH0KICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXI0LnByb3RvdHlwZSk7CiAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgfQogICAgICBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iaikgewogICAgICAgIGlmIChCdWZmZXI0LmlzQnVmZmVyKG9iaikpIHsKICAgICAgICAgIGNvbnN0IGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwOwogICAgICAgICAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbik7CiAgICAgICAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gYnVmOwogICAgICAgICAgfQogICAgICAgICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pOwogICAgICAgICAgcmV0dXJuIGJ1ZjsKICAgICAgICB9CiAgICAgICAgaWYgKG9iai5sZW5ndGggIT09IHZvaWQgMCkgewogICAgICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAibnVtYmVyIiB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkgewogICAgICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKTsKICAgICAgICB9CiAgICAgICAgaWYgKG9iai50eXBlID09PSAiQnVmZmVyIiAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkgewogICAgICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBjaGVja2VkKGxlbmd0aCkgewogICAgICAgIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSBzaXplOiAweCIgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgIiBieXRlcyIpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbGVuZ3RoIHwgMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBTbG93QnVmZmVyKGxlbmd0aCkgewogICAgICAgIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgewogICAgICAgICAgbGVuZ3RoID0gMDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJ1ZmZlcjQuYWxsb2MoK2xlbmd0aCk7CiAgICAgIH0KICAgICAgQnVmZmVyNC5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyMihiKSB7CiAgICAgICAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJiBiICE9PSBCdWZmZXI0LnByb3RvdHlwZTsKICAgICAgfTsKICAgICAgQnVmZmVyNC5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7CiAgICAgICAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpCiAgICAgICAgICBhID0gQnVmZmVyNC5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpOwogICAgICAgIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKQogICAgICAgICAgYiA9IEJ1ZmZlcjQuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKTsKICAgICAgICBpZiAoIUJ1ZmZlcjQuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlcjQuaXNCdWZmZXIoYikpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSAiYnVmMSIsICJidWYyIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheScpOwogICAgICAgIH0KICAgICAgICBpZiAoYSA9PT0gYikKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIGxldCB4ID0gYS5sZW5ndGg7CiAgICAgICAgbGV0IHkgPSBiLmxlbmd0aDsKICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkgewogICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHsKICAgICAgICAgICAgeCA9IGFbaV07CiAgICAgICAgICAgIHkgPSBiW2ldOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHggPCB5KQogICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgIGlmICh5IDwgeCkKICAgICAgICAgIHJldHVybiAxOwogICAgICAgIHJldHVybiAwOwogICAgICB9OwogICAgICBCdWZmZXI0LmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nKGVuY29kaW5nKSB7CiAgICAgICAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHsKICAgICAgICAgIGNhc2UgImhleCI6CiAgICAgICAgICBjYXNlICJ1dGY4IjoKICAgICAgICAgIGNhc2UgInV0Zi04IjoKICAgICAgICAgIGNhc2UgImFzY2lpIjoKICAgICAgICAgIGNhc2UgImxhdGluMSI6CiAgICAgICAgICBjYXNlICJiaW5hcnkiOgogICAgICAgICAgY2FzZSAiYmFzZTY0IjoKICAgICAgICAgIGNhc2UgInVjczIiOgogICAgICAgICAgY2FzZSAidWNzLTIiOgogICAgICAgICAgY2FzZSAidXRmMTZsZSI6CiAgICAgICAgICBjYXNlICJ1dGYtMTZsZSI6CiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgfTsKICAgICAgQnVmZmVyNC5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQobGlzdCwgbGVuZ3RoKSB7CiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcibGlzdCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7CiAgICAgICAgfQogICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIEJ1ZmZlcjQuYWxsb2MoMCk7CiAgICAgICAgfQogICAgICAgIGxldCBpOwogICAgICAgIGlmIChsZW5ndGggPT09IHZvaWQgMCkgewogICAgICAgICAgbGVuZ3RoID0gMDsKICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7CiAgICAgICAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyNC5hbGxvY1Vuc2FmZShsZW5ndGgpOwogICAgICAgIGxldCBwb3MgPSAwOwogICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7CiAgICAgICAgICBsZXQgYnVmID0gbGlzdFtpXTsKICAgICAgICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHsKICAgICAgICAgICAgaWYgKHBvcyArIGJ1Zi5sZW5ndGggPiBidWZmZXIubGVuZ3RoKSB7CiAgICAgICAgICAgICAgaWYgKCFCdWZmZXI0LmlzQnVmZmVyKGJ1ZikpCiAgICAgICAgICAgICAgICBidWYgPSBCdWZmZXI0LmZyb20oYnVmKTsKICAgICAgICAgICAgICBidWYuY29weShidWZmZXIsIHBvcyk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoYnVmZmVyLCBidWYsIHBvcyk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAoIUJ1ZmZlcjQuaXNCdWZmZXIoYnVmKSkgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcibGlzdCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBidWYuY29weShidWZmZXIsIHBvcyk7CiAgICAgICAgICB9CiAgICAgICAgICBwb3MgKz0gYnVmLmxlbmd0aDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ1ZmZlcjsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB7CiAgICAgICAgaWYgKEJ1ZmZlcjQuaXNCdWZmZXIoc3RyaW5nKSkgewogICAgICAgICAgcmV0dXJuIHN0cmluZy5sZW5ndGg7CiAgICAgICAgfQogICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7CiAgICAgICAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGg7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAic3RyaW5nIikgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlICJzdHJpbmciIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgbGVuID0gc3RyaW5nLmxlbmd0aDsKICAgICAgICBjb25zdCBtdXN0TWF0Y2ggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWU7CiAgICAgICAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKQogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2U7CiAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICBzd2l0Y2ggKGVuY29kaW5nKSB7CiAgICAgICAgICAgIGNhc2UgImFzY2lpIjoKICAgICAgICAgICAgY2FzZSAibGF0aW4xIjoKICAgICAgICAgICAgY2FzZSAiYmluYXJ5IjoKICAgICAgICAgICAgICByZXR1cm4gbGVuOwogICAgICAgICAgICBjYXNlICJ1dGY4IjoKICAgICAgICAgICAgY2FzZSAidXRmLTgiOgogICAgICAgICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aDsKICAgICAgICAgICAgY2FzZSAidWNzMiI6CiAgICAgICAgICAgIGNhc2UgInVjcy0yIjoKICAgICAgICAgICAgY2FzZSAidXRmMTZsZSI6CiAgICAgICAgICAgIGNhc2UgInV0Zi0xNmxlIjoKICAgICAgICAgICAgICByZXR1cm4gbGVuICogMjsKICAgICAgICAgICAgY2FzZSAiaGV4IjoKICAgICAgICAgICAgICByZXR1cm4gbGVuID4+PiAxOwogICAgICAgICAgICBjYXNlICJiYXNlNjQiOgogICAgICAgICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoOwogICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgewogICAgICAgICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGg7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGVuY29kaW5nID0gKCIiICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBCdWZmZXI0LmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoOwogICAgICBmdW5jdGlvbiBzbG93VG9TdHJpbmcoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZTsKICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCB8fCBzdGFydCA8IDApIHsKICAgICAgICAgIHN0YXJ0ID0gMDsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHsKICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICB9CiAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7CiAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDsKICAgICAgICB9CiAgICAgICAgaWYgKGVuZCA8PSAwKSB7CiAgICAgICAgICByZXR1cm4gIiI7CiAgICAgICAgfQogICAgICAgIGVuZCA+Pj49IDA7CiAgICAgICAgc3RhcnQgPj4+PSAwOwogICAgICAgIGlmIChlbmQgPD0gc3RhcnQpIHsKICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICB9CiAgICAgICAgaWYgKCFlbmNvZGluZykKICAgICAgICAgIGVuY29kaW5nID0gInV0ZjgiOwogICAgICAgIHdoaWxlICh0cnVlKSB7CiAgICAgICAgICBzd2l0Y2ggKGVuY29kaW5nKSB7CiAgICAgICAgICAgIGNhc2UgImhleCI6CiAgICAgICAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpOwogICAgICAgICAgICBjYXNlICJ1dGY4IjoKICAgICAgICAgICAgY2FzZSAidXRmLTgiOgogICAgICAgICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZCk7CiAgICAgICAgICAgIGNhc2UgImFzY2lpIjoKICAgICAgICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKTsKICAgICAgICAgICAgY2FzZSAibGF0aW4xIjoKICAgICAgICAgICAgY2FzZSAiYmluYXJ5IjoKICAgICAgICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZCk7CiAgICAgICAgICAgIGNhc2UgImJhc2U2NCI6CiAgICAgICAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpOwogICAgICAgICAgICBjYXNlICJ1Y3MyIjoKICAgICAgICAgICAgY2FzZSAidWNzLTIiOgogICAgICAgICAgICBjYXNlICJ1dGYxNmxlIjoKICAgICAgICAgICAgY2FzZSAidXRmLTE2bGUiOgogICAgICAgICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZCk7CiAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgaWYgKGxvd2VyZWRDYXNlKQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiVW5rbm93biBlbmNvZGluZzogIiArIGVuY29kaW5nKTsKICAgICAgICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICIiKS50b0xvd2VyQ2FzZSgpOwogICAgICAgICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgQnVmZmVyNC5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZTsKICAgICAgZnVuY3Rpb24gc3dhcChiLCBuLCBtKSB7CiAgICAgICAgY29uc3QgaSA9IGJbbl07CiAgICAgICAgYltuXSA9IGJbbV07CiAgICAgICAgYlttXSA9IGk7CiAgICAgIH0KICAgICAgQnVmZmVyNC5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2KCkgewogICAgICAgIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoOwogICAgICAgIGlmIChsZW4gJSAyICE9PSAwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMiKTsKICAgICAgICB9CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikgewogICAgICAgICAgc3dhcCh0aGlzLCBpLCBpICsgMSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9OwogICAgICBCdWZmZXI0LnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIoKSB7CiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGg7CiAgICAgICAgaWYgKGxlbiAlIDQgIT09IDApIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cyIpOwogICAgICAgIH0KICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7CiAgICAgICAgICBzd2FwKHRoaXMsIGksIGkgKyAzKTsKICAgICAgICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjQucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCgpIHsKICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aDsKICAgICAgICBpZiAobGVuICUgOCAhPT0gMCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzIik7CiAgICAgICAgfQogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHsKICAgICAgICAgIHN3YXAodGhpcywgaSwgaSArIDcpOwogICAgICAgICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpOwogICAgICAgICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpOwogICAgICAgICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfTsKICAgICAgQnVmZmVyNC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHsKICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aDsKICAgICAgICBpZiAobGVuZ3RoID09PSAwKQogICAgICAgICAgcmV0dXJuICIiOwogICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKQogICAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpOwogICAgICAgIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgfTsKICAgICAgQnVmZmVyNC5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXI0LnByb3RvdHlwZS50b1N0cmluZzsKICAgICAgQnVmZmVyNC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKGIpIHsKICAgICAgICBpZiAoIUJ1ZmZlcjQuaXNCdWZmZXIoYikpCiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIik7CiAgICAgICAgaWYgKHRoaXMgPT09IGIpCiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICByZXR1cm4gQnVmZmVyNC5jb21wYXJlKHRoaXMsIGIpID09PSAwOwogICAgICB9OwogICAgICBCdWZmZXI0LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHsKICAgICAgICBsZXQgc3RyID0gIiI7CiAgICAgICAgY29uc3QgbWF4ID0gZXhwb3J0czIuSU5TUEVDVF9NQVhfQllURVM7CiAgICAgICAgc3RyID0gdGhpcy50b1N0cmluZygiaGV4IiwgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgIiQxICIpLnRyaW0oKTsKICAgICAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpCiAgICAgICAgICBzdHIgKz0gIiAuLi4gIjsKICAgICAgICByZXR1cm4gIjxCdWZmZXIgIiArIHN0ciArICI+IjsKICAgICAgfTsKICAgICAgaWYgKGN1c3RvbUluc3BlY3RTeW1ib2wpIHsKICAgICAgICBCdWZmZXI0LnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IEJ1ZmZlcjQucHJvdG90eXBlLmluc3BlY3Q7CiAgICAgIH0KICAgICAgQnVmZmVyNC5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHsKICAgICAgICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7CiAgICAgICAgICB0YXJnZXQgPSBCdWZmZXI0LmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aCk7CiAgICAgICAgfQogICAgICAgIGlmICghQnVmZmVyNC5pc0J1ZmZlcih0YXJnZXQpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgInRhcmdldCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHRhcmdldCk7CiAgICAgICAgfQogICAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBzdGFydCA9IDA7CiAgICAgICAgfQogICAgICAgIGlmIChlbmQgPT09IHZvaWQgMCkgewogICAgICAgICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDA7CiAgICAgICAgfQogICAgICAgIGlmICh0aGlzU3RhcnQgPT09IHZvaWQgMCkgewogICAgICAgICAgdGhpc1N0YXJ0ID0gMDsKICAgICAgICB9CiAgICAgICAgaWYgKHRoaXNFbmQgPT09IHZvaWQgMCkgewogICAgICAgICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJvdXQgb2YgcmFuZ2UgaW5kZXgiKTsKICAgICAgICB9CiAgICAgICAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkgewogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgfQogICAgICAgIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkgewogICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhcnQgPj0gZW5kKSB7CiAgICAgICAgICByZXR1cm4gMTsKICAgICAgICB9CiAgICAgICAgc3RhcnQgPj4+PSAwOwogICAgICAgIGVuZCA+Pj49IDA7CiAgICAgICAgdGhpc1N0YXJ0ID4+Pj0gMDsKICAgICAgICB0aGlzRW5kID4+Pj0gMDsKICAgICAgICBpZiAodGhpcyA9PT0gdGFyZ2V0KQogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgbGV0IHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0OwogICAgICAgIGxldCB5ID0gZW5kIC0gc3RhcnQ7CiAgICAgICAgY29uc3QgbGVuID0gTWF0aC5taW4oeCwgeSk7CiAgICAgICAgY29uc3QgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZCk7CiAgICAgICAgY29uc3QgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7CiAgICAgICAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHsKICAgICAgICAgICAgeCA9IHRoaXNDb3B5W2ldOwogICAgICAgICAgICB5ID0gdGFyZ2V0Q29weVtpXTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmICh4IDwgeSkKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICBpZiAoeSA8IHgpCiAgICAgICAgICByZXR1cm4gMTsKICAgICAgICByZXR1cm4gMDsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHsKICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXQ7CiAgICAgICAgICBieXRlT2Zmc2V0ID0gMDsKICAgICAgICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAyMTQ3NDgzNjQ3KSB7CiAgICAgICAgICBieXRlT2Zmc2V0ID0gMjE0NzQ4MzY0NzsKICAgICAgICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMjE0NzQ4MzY0OCkgewogICAgICAgICAgYnl0ZU9mZnNldCA9IC0yMTQ3NDgzNjQ4OwogICAgICAgIH0KICAgICAgICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQ7CiAgICAgICAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7CiAgICAgICAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IGJ1ZmZlci5sZW5ndGggLSAxOwogICAgICAgIH0KICAgICAgICBpZiAoYnl0ZU9mZnNldCA8IDApCiAgICAgICAgICBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXQ7CiAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkgewogICAgICAgICAgaWYgKGRpcikKICAgICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgICAgZWxzZQogICAgICAgICAgICBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDE7CiAgICAgICAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkgewogICAgICAgICAgaWYgKGRpcikKICAgICAgICAgICAgYnl0ZU9mZnNldCA9IDA7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICB2YWwgPSBCdWZmZXI0LmZyb20odmFsLCBlbmNvZGluZyk7CiAgICAgICAgfQogICAgICAgIGlmIChCdWZmZXI0LmlzQnVmZmVyKHZhbCkpIHsKICAgICAgICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpOwogICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gIm51bWJlciIpIHsKICAgICAgICAgIHZhbCA9IHZhbCAmIDI1NTsKICAgICAgICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICBpZiAoZGlyKSB7CiAgICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpOwogICAgICAgIH0KICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJ2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXIiKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBhcnJheUluZGV4T2YoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHsKICAgICAgICBsZXQgaW5kZXhTaXplID0gMTsKICAgICAgICBsZXQgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aDsKICAgICAgICBsZXQgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aDsKICAgICAgICBpZiAoZW5jb2RpbmcgIT09IHZvaWQgMCkgewogICAgICAgICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICJ1Y3MyIiB8fCBlbmNvZGluZyA9PT0gInVjcy0yIiB8fCBlbmNvZGluZyA9PT0gInV0ZjE2bGUiIHx8IGVuY29kaW5nID09PSAidXRmLTE2bGUiKSB7CiAgICAgICAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikgewogICAgICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpbmRleFNpemUgPSAyOwogICAgICAgICAgICBhcnJMZW5ndGggLz0gMjsKICAgICAgICAgICAgdmFsTGVuZ3RoIC89IDI7CiAgICAgICAgICAgIGJ5dGVPZmZzZXQgLz0gMjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcmVhZChidWYsIGkyKSB7CiAgICAgICAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7CiAgICAgICAgICAgIHJldHVybiBidWZbaTJdOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaTIgKiBpbmRleFNpemUpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBsZXQgaTsKICAgICAgICBpZiAoZGlyKSB7CiAgICAgICAgICBsZXQgZm91bmRJbmRleCA9IC0xOwogICAgICAgICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHsKICAgICAgICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpCiAgICAgICAgICAgICAgICBmb3VuZEluZGV4ID0gaTsKICAgICAgICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpCiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpCiAgICAgICAgICAgICAgICBpIC09IGkgLSBmb3VuZEluZGV4OwogICAgICAgICAgICAgIGZvdW5kSW5kZXggPSAtMTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkKICAgICAgICAgICAgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aDsKICAgICAgICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7CiAgICAgICAgICAgIGxldCBmb3VuZCA9IHRydWU7CiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHsKICAgICAgICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7CiAgICAgICAgICAgICAgICBmb3VuZCA9IGZhbHNlOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChmb3VuZCkKICAgICAgICAgICAgICByZXR1cm4gaTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9CiAgICAgIEJ1ZmZlcjQucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXModmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgewogICAgICAgIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xOwogICAgICB9OwogICAgICBCdWZmZXI0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7CiAgICAgICAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpOwogICAgICB9OwogICAgICBCdWZmZXI0LnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHsKICAgICAgICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpOwogICAgICB9OwogICAgICBmdW5jdGlvbiBoZXhXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwOwogICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXQ7CiAgICAgICAgaWYgKCFsZW5ndGgpIHsKICAgICAgICAgIGxlbmd0aCA9IHJlbWFpbmluZzsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aCk7CiAgICAgICAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7CiAgICAgICAgICAgIGxlbmd0aCA9IHJlbWFpbmluZzsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgY29uc3Qgc3RyTGVuID0gc3RyaW5nLmxlbmd0aDsKICAgICAgICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikgewogICAgICAgICAgbGVuZ3RoID0gc3RyTGVuIC8gMjsKICAgICAgICB9CiAgICAgICAgbGV0IGk7CiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7CiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpOwogICAgICAgICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpCiAgICAgICAgICAgIHJldHVybiBpOwogICAgICAgICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkOwogICAgICAgIH0KICAgICAgICByZXR1cm4gaTsKICAgICAgfQogICAgICBmdW5jdGlvbiB1dGY4V3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYmFzZTY0V3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB1Y3MyV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgIH0KICAgICAgQnVmZmVyNC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykgewogICAgICAgIGlmIChvZmZzZXQgPT09IHZvaWQgMCkgewogICAgICAgICAgZW5jb2RpbmcgPSAidXRmOCI7CiAgICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDsKICAgICAgICAgIG9mZnNldCA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChsZW5ndGggPT09IHZvaWQgMCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAic3RyaW5nIikgewogICAgICAgICAgZW5jb2RpbmcgPSBvZmZzZXQ7CiAgICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDsKICAgICAgICAgIG9mZnNldCA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7CiAgICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkgewogICAgICAgICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDA7CiAgICAgICAgICAgIGlmIChlbmNvZGluZyA9PT0gdm9pZCAwKQogICAgICAgICAgICAgIGVuY29kaW5nID0gInV0ZjgiOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7CiAgICAgICAgICAgIGxlbmd0aCA9IHZvaWQgMDsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCIpOwogICAgICAgIH0KICAgICAgICBjb25zdCByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDsKICAgICAgICBpZiAobGVuZ3RoID09PSB2b2lkIDAgfHwgbGVuZ3RoID4gcmVtYWluaW5nKQogICAgICAgICAgbGVuZ3RoID0gcmVtYWluaW5nOwogICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkgewogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkF0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzIik7CiAgICAgICAgfQogICAgICAgIGlmICghZW5jb2RpbmcpCiAgICAgICAgICBlbmNvZGluZyA9ICJ1dGY4IjsKICAgICAgICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZTsKICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHsKICAgICAgICAgICAgY2FzZSAiaGV4IjoKICAgICAgICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgICAgICAgIGNhc2UgInV0ZjgiOgogICAgICAgICAgICBjYXNlICJ1dGYtOCI6CiAgICAgICAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgICAgICAgY2FzZSAiYXNjaWkiOgogICAgICAgICAgICBjYXNlICJsYXRpbjEiOgogICAgICAgICAgICBjYXNlICJiaW5hcnkiOgogICAgICAgICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpOwogICAgICAgICAgICBjYXNlICJiYXNlNjQiOgogICAgICAgICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTsKICAgICAgICAgICAgY2FzZSAidWNzMiI6CiAgICAgICAgICAgIGNhc2UgInVjcy0yIjoKICAgICAgICAgICAgY2FzZSAidXRmMTZsZSI6CiAgICAgICAgICAgIGNhc2UgInV0Zi0xNmxlIjoKICAgICAgICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpOwogICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgIGlmIChsb3dlcmVkQ2FzZSkKICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIlVua25vd24gZW5jb2Rpbmc6ICIgKyBlbmNvZGluZyk7CiAgICAgICAgICAgICAgZW5jb2RpbmcgPSAoIiIgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTsKICAgICAgICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9OwogICAgICBCdWZmZXI0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIHR5cGU6ICJCdWZmZXIiLAogICAgICAgICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApCiAgICAgICAgfTsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gYmFzZTY0U2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7CiAgICAgICAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkgewogICAgICAgICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zik7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiB1dGY4U2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7CiAgICAgICAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTsKICAgICAgICBjb25zdCByZXMgPSBbXTsKICAgICAgICBsZXQgaSA9IHN0YXJ0OwogICAgICAgIHdoaWxlIChpIDwgZW5kKSB7CiAgICAgICAgICBjb25zdCBmaXJzdEJ5dGUgPSBidWZbaV07CiAgICAgICAgICBsZXQgY29kZVBvaW50ID0gbnVsbDsKICAgICAgICAgIGxldCBieXRlc1BlclNlcXVlbmNlID0gZmlyc3RCeXRlID4gMjM5ID8gNCA6IGZpcnN0Qnl0ZSA+IDIyMyA/IDMgOiBmaXJzdEJ5dGUgPiAxOTEgPyAyIDogMTsKICAgICAgICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHsKICAgICAgICAgICAgbGV0IHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludDsKICAgICAgICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7CiAgICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDEyOCkgewogICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIDI6CiAgICAgICAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTsKICAgICAgICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDE5MikgPT09IDEyOCkgewogICAgICAgICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDMxKSA8PCA2IHwgc2Vjb25kQnl0ZSAmIDYzOwogICAgICAgICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDEyNykgewogICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgMzoKICAgICAgICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdOwogICAgICAgICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTsKICAgICAgICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDE5MikgPT09IDEyOCAmJiAodGhpcmRCeXRlICYgMTkyKSA9PT0gMTI4KSB7CiAgICAgICAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMTUpIDw8IDEyIHwgKHNlY29uZEJ5dGUgJiA2MykgPDwgNiB8IHRoaXJkQnl0ZSAmIDYzOwogICAgICAgICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDIwNDcgJiYgKHRlbXBDb2RlUG9pbnQgPCA1NTI5NiB8fCB0ZW1wQ29kZVBvaW50ID4gNTczNDMpKSB7CiAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSA0OgogICAgICAgICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07CiAgICAgICAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdOwogICAgICAgICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM107CiAgICAgICAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAxOTIpID09PSAxMjggJiYgKHRoaXJkQnl0ZSAmIDE5MikgPT09IDEyOCAmJiAoZm91cnRoQnl0ZSAmIDE5MikgPT09IDEyOCkgewogICAgICAgICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDE1KSA8PCAxOCB8IChzZWNvbmRCeXRlICYgNjMpIDw8IDEyIHwgKHRoaXJkQnl0ZSAmIDYzKSA8PCA2IHwgZm91cnRoQnl0ZSAmIDYzOwogICAgICAgICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDY1NTM1ICYmIHRlbXBDb2RlUG9pbnQgPCAxMTE0MTEyKSB7CiAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7CiAgICAgICAgICAgIGNvZGVQb2ludCA9IDY1NTMzOwogICAgICAgICAgICBieXRlc1BlclNlcXVlbmNlID0gMTsKICAgICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gNjU1MzUpIHsKICAgICAgICAgICAgY29kZVBvaW50IC09IDY1NTM2OwogICAgICAgICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMTAyMyB8IDU1Mjk2KTsKICAgICAgICAgICAgY29kZVBvaW50ID0gNTYzMjAgfCBjb2RlUG9pbnQgJiAxMDIzOwogICAgICAgICAgfQogICAgICAgICAgcmVzLnB1c2goY29kZVBvaW50KTsKICAgICAgICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpOwogICAgICB9CiAgICAgIHZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDQwOTY7CiAgICAgIGZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheShjb2RlUG9pbnRzKSB7CiAgICAgICAgY29uc3QgbGVuID0gY29kZVBvaW50cy5sZW5ndGg7CiAgICAgICAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkgewogICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKTsKICAgICAgICB9CiAgICAgICAgbGV0IHJlcyA9ICIiOwogICAgICAgIGxldCBpID0gMDsKICAgICAgICB3aGlsZSAoaSA8IGxlbikgewogICAgICAgICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJlczsKICAgICAgfQogICAgICBmdW5jdGlvbiBhc2NpaVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkgewogICAgICAgIGxldCByZXQgPSAiIjsKICAgICAgICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpOwogICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7CiAgICAgICAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAxMjcpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGxhdGluMVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkgewogICAgICAgIGxldCByZXQgPSAiIjsKICAgICAgICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpOwogICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7CiAgICAgICAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGhleFNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkgewogICAgICAgIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGg7CiAgICAgICAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApCiAgICAgICAgICBzdGFydCA9IDA7CiAgICAgICAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pCiAgICAgICAgICBlbmQgPSBsZW47CiAgICAgICAgbGV0IG91dCA9ICIiOwogICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7CiAgICAgICAgICBvdXQgKz0gaGV4U2xpY2VMb29rdXBUYWJsZVtidWZbaV1dOwogICAgICAgIH0KICAgICAgICByZXR1cm4gb3V0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHV0ZjE2bGVTbGljZShidWYsIHN0YXJ0LCBlbmQpIHsKICAgICAgICBjb25zdCBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKTsKICAgICAgICBsZXQgcmVzID0gIiI7CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGggLSAxOyBpICs9IDIpIHsKICAgICAgICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJlczsKICAgICAgfQogICAgICBCdWZmZXI0LnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHsKICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aDsKICAgICAgICBzdGFydCA9IH5+c3RhcnQ7CiAgICAgICAgZW5kID0gZW5kID09PSB2b2lkIDAgPyBsZW4gOiB+fmVuZDsKICAgICAgICBpZiAoc3RhcnQgPCAwKSB7CiAgICAgICAgICBzdGFydCArPSBsZW47CiAgICAgICAgICBpZiAoc3RhcnQgPCAwKQogICAgICAgICAgICBzdGFydCA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikgewogICAgICAgICAgc3RhcnQgPSBsZW47CiAgICAgICAgfQogICAgICAgIGlmIChlbmQgPCAwKSB7CiAgICAgICAgICBlbmQgKz0gbGVuOwogICAgICAgICAgaWYgKGVuZCA8IDApCiAgICAgICAgICAgIGVuZCA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHsKICAgICAgICAgIGVuZCA9IGxlbjsKICAgICAgICB9CiAgICAgICAgaWYgKGVuZCA8IHN0YXJ0KQogICAgICAgICAgZW5kID0gc3RhcnQ7CiAgICAgICAgY29uc3QgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKTsKICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXI0LnByb3RvdHlwZSk7CiAgICAgICAgcmV0dXJuIG5ld0J1ZjsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gY2hlY2tPZmZzZXQob2Zmc2V0LCBleHQsIGxlbmd0aCkgewogICAgICAgIGlmIChvZmZzZXQgJSAxICE9PSAwIHx8IG9mZnNldCA8IDApCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigib2Zmc2V0IGlzIG5vdCB1aW50Iik7CiAgICAgICAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoIik7CiAgICAgIH0KICAgICAgQnVmZmVyNC5wcm90b3R5cGUucmVhZFVpbnRMRSA9IEJ1ZmZlcjQucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFKG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGJ5dGVMZW5ndGgyID0gYnl0ZUxlbmd0aDIgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIGxldCBpID0gMDsKICAgICAgICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aDIgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHZhbDsKICAgICAgfTsKICAgICAgQnVmZmVyNC5wcm90b3R5cGUucmVhZFVpbnRCRSA9IEJ1ZmZlcjQucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFKG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGJ5dGVMZW5ndGgyID0gYnl0ZUxlbmd0aDIgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkgewogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoMiwgdGhpcy5sZW5ndGgpOwogICAgICAgIH0KICAgICAgICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGgyXTsKICAgICAgICBsZXQgbXVsID0gMTsKICAgICAgICB3aGlsZSAoYnl0ZUxlbmd0aDIgPiAwICYmIChtdWwgKj0gMjU2KSkgewogICAgICAgICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoMl0gKiBtdWw7CiAgICAgICAgfQogICAgICAgIHJldHVybiB2YWw7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjQucHJvdG90eXBlLnJlYWRVaW50OCA9IEJ1ZmZlcjQucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gdGhpc1tvZmZzZXRdOwogICAgICB9OwogICAgICBCdWZmZXI0LnByb3RvdHlwZS5yZWFkVWludDE2TEUgPSBCdWZmZXI0LnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgODsKICAgICAgfTsKICAgICAgQnVmZmVyNC5wcm90b3R5cGUucmVhZFVpbnQxNkJFID0gQnVmZmVyNC5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiB0aGlzW29mZnNldF0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgMV07CiAgICAgIH07CiAgICAgIEJ1ZmZlcjQucHJvdG90eXBlLnJlYWRVaW50MzJMRSA9IEJ1ZmZlcjQucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gKHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpICsgdGhpc1tvZmZzZXQgKyAzXSAqIDE2Nzc3MjE2OwogICAgICB9OwogICAgICBCdWZmZXI0LnByb3RvdHlwZS5yZWFkVWludDMyQkUgPSBCdWZmZXI0LnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSAqIDE2Nzc3MjE2ICsgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYgfCB0aGlzW29mZnNldCArIDJdIDw8IDggfCB0aGlzW29mZnNldCArIDNdKTsKICAgICAgfTsKICAgICAgQnVmZmVyNC5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRMRShvZmZzZXQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAib2Zmc2V0Iik7CiAgICAgICAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF07CiAgICAgICAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN107CiAgICAgICAgaWYgKGZpcnN0ID09PSB2b2lkIDAgfHwgbGFzdCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOCk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGxvID0gZmlyc3QgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNDsKICAgICAgICBjb25zdCBoaSA9IHRoaXNbKytvZmZzZXRdICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgKyBsYXN0ICogMiAqKiAyNDsKICAgICAgICByZXR1cm4gQmlnSW50KGxvKSArIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpOwogICAgICB9KTsKICAgICAgQnVmZmVyNC5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRCRShvZmZzZXQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAib2Zmc2V0Iik7CiAgICAgICAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF07CiAgICAgICAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN107CiAgICAgICAgaWYgKGZpcnN0ID09PSB2b2lkIDAgfHwgbGFzdCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOCk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGhpID0gZmlyc3QgKiAyICoqIDI0ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyB0aGlzWysrb2Zmc2V0XTsKICAgICAgICBjb25zdCBsbyA9IHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICsgbGFzdDsKICAgICAgICByZXR1cm4gKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQobG8pOwogICAgICB9KTsKICAgICAgQnVmZmVyNC5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFKG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGJ5dGVMZW5ndGgyID0gYnl0ZUxlbmd0aDIgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIGxldCBpID0gMDsKICAgICAgICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aDIgJiYgKG11bCAqPSAyNTYpKSB7CiAgICAgICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDsKICAgICAgICB9CiAgICAgICAgbXVsICo9IDEyODsKICAgICAgICBpZiAodmFsID49IG11bCkKICAgICAgICAgIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aDIpOwogICAgICAgIHJldHVybiB2YWw7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjQucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRShvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBieXRlTGVuZ3RoMiA9IGJ5dGVMZW5ndGgyID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgbGV0IGkgPSBieXRlTGVuZ3RoMjsKICAgICAgICBsZXQgbXVsID0gMTsKICAgICAgICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldOwogICAgICAgIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWw7CiAgICAgICAgfQogICAgICAgIG11bCAqPSAxMjg7CiAgICAgICAgaWYgKHZhbCA+PSBtdWwpCiAgICAgICAgICB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgyKTsKICAgICAgICByZXR1cm4gdmFsOwogICAgICB9OwogICAgICBCdWZmZXI0LnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4KG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpOwogICAgICAgIGlmICghKHRoaXNbb2Zmc2V0XSAmIDEyOCkpCiAgICAgICAgICByZXR1cm4gdGhpc1tvZmZzZXRdOwogICAgICAgIHJldHVybiAoMjU1IC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMTsKICAgICAgfTsKICAgICAgQnVmZmVyNC5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICBjb25zdCB2YWwgPSB0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDg7CiAgICAgICAgcmV0dXJuIHZhbCAmIDMyNzY4ID8gdmFsIHwgNDI5NDkwMTc2MCA6IHZhbDsKICAgICAgfTsKICAgICAgQnVmZmVyNC5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgdGhpc1tvZmZzZXRdIDw8IDg7CiAgICAgICAgcmV0dXJuIHZhbCAmIDMyNzY4ID8gdmFsIHwgNDI5NDkwMTc2MCA6IHZhbDsKICAgICAgfTsKICAgICAgQnVmZmVyNC5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgdGhpc1tvZmZzZXQgKyAxXSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAyXSA8PCAxNiB8IHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQ7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjQucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSA8PCAyNCB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYgfCB0aGlzW29mZnNldCArIDJdIDw8IDggfCB0aGlzW29mZnNldCArIDNdOwogICAgICB9OwogICAgICBCdWZmZXI0LnByb3RvdHlwZS5yZWFkQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRMRShvZmZzZXQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAib2Zmc2V0Iik7CiAgICAgICAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF07CiAgICAgICAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN107CiAgICAgICAgaWYgKGZpcnN0ID09PSB2b2lkIDAgfHwgbGFzdCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOCk7CiAgICAgICAgfQogICAgICAgIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgNF0gKyB0aGlzW29mZnNldCArIDVdICogMiAqKiA4ICsgdGhpc1tvZmZzZXQgKyA2XSAqIDIgKiogMTYgKyAobGFzdCA8PCAyNCk7CiAgICAgICAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChmaXJzdCArIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDI0KTsKICAgICAgfSk7CiAgICAgIEJ1ZmZlcjQucHJvdG90eXBlLnJlYWRCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NEJFKG9mZnNldCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICJvZmZzZXQiKTsKICAgICAgICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XTsKICAgICAgICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XTsKICAgICAgICBpZiAoZmlyc3QgPT09IHZvaWQgMCB8fCBsYXN0ID09PSB2b2lkIDApIHsKICAgICAgICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KTsKICAgICAgICB9CiAgICAgICAgY29uc3QgdmFsID0gKGZpcnN0IDw8IDI0KSArIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICsgdGhpc1srK29mZnNldF07CiAgICAgICAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludCh0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArIGxhc3QpOwogICAgICB9KTsKICAgICAgQnVmZmVyNC5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRShvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTsKICAgICAgICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpOwogICAgICB9OwogICAgICBCdWZmZXI0LnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpOwogICAgICB9OwogICAgICBCdWZmZXI0LnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUob2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCk7CiAgICAgICAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KTsKICAgICAgfTsKICAgICAgQnVmZmVyNC5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFKG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpOwogICAgICAgIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpOwogICAgICB9OwogICAgICBmdW5jdGlvbiBjaGVja0ludChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHsKICAgICAgICBpZiAoIUJ1ZmZlcjQuaXNCdWZmZXIoYnVmKSkKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJidWZmZXIiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTsKICAgICAgICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignInZhbHVlIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJyk7CiAgICAgICAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiSW5kZXggb3V0IG9mIHJhbmdlIik7CiAgICAgIH0KICAgICAgQnVmZmVyNC5wcm90b3R5cGUud3JpdGVVaW50TEUgPSBCdWZmZXI0LnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBieXRlTGVuZ3RoMiA9IGJ5dGVMZW5ndGgyID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpIHsKICAgICAgICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgyKSAtIDE7CiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbWF4Qnl0ZXMsIDApOwogICAgICAgIH0KICAgICAgICBsZXQgbXVsID0gMTsKICAgICAgICBsZXQgaSA9IDA7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGgyICYmIChtdWwgKj0gMjU2KSkgewogICAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlIC8gbXVsICYgMjU1OwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjQucHJvdG90eXBlLndyaXRlVWludEJFID0gQnVmZmVyNC5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgYnl0ZUxlbmd0aDIgPSBieXRlTGVuZ3RoMiA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7CiAgICAgICAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoMikgLSAxOwogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIG1heEJ5dGVzLCAwKTsKICAgICAgICB9CiAgICAgICAgbGV0IGkgPSBieXRlTGVuZ3RoMiAtIDE7CiAgICAgICAgbGV0IG11bCA9IDE7CiAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMjU1OwogICAgICAgIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAvIG11bCAmIDI1NTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgyOwogICAgICB9OwogICAgICBCdWZmZXI0LnByb3RvdHlwZS53cml0ZVVpbnQ4ID0gQnVmZmVyNC5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDI1NSwgMCk7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDE7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjQucHJvdG90eXBlLndyaXRlVWludDE2TEUgPSBCdWZmZXI0LnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgNjU1MzUsIDApOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gODsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMjsKICAgICAgfTsKICAgICAgQnVmZmVyNC5wcm90b3R5cGUud3JpdGVVaW50MTZCRSA9IEJ1ZmZlcjQucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCA2NTUzNSwgMCk7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgPj4+IDg7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlICYgMjU1OwogICAgICAgIHJldHVybiBvZmZzZXQgKyAyOwogICAgICB9OwogICAgICBCdWZmZXI0LnByb3RvdHlwZS53cml0ZVVpbnQzMkxFID0gQnVmZmVyNC5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDQyOTQ5NjcyOTUsIDApOwogICAgICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZSA+Pj4gMjQ7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiAxNjsKICAgICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDg7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDQ7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjQucHJvdG90eXBlLndyaXRlVWludDMyQkUgPSBCdWZmZXI0LnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgNDI5NDk2NzI5NSwgMCk7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgPj4+IDI0OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gMTY7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiA4OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZSAmIDI1NTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgNDsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gd3J0QmlnVUludDY0TEUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkgewogICAgICAgIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNyk7CiAgICAgICAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDQyOTQ5NjcyOTUpKTsKICAgICAgICBidWZbb2Zmc2V0KytdID0gbG87CiAgICAgICAgbG8gPSBsbyA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBsbzsKICAgICAgICBsbyA9IGxvID4+IDg7CiAgICAgICAgYnVmW29mZnNldCsrXSA9IGxvOwogICAgICAgIGxvID0gbG8gPj4gODsKICAgICAgICBidWZbb2Zmc2V0KytdID0gbG87CiAgICAgICAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoNDI5NDk2NzI5NSkpOwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBoaTsKICAgICAgICBoaSA9IGhpID4+IDg7CiAgICAgICAgYnVmW29mZnNldCsrXSA9IGhpOwogICAgICAgIGhpID0gaGkgPj4gODsKICAgICAgICBidWZbb2Zmc2V0KytdID0gaGk7CiAgICAgICAgaGkgPSBoaSA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQrK10gPSBoaTsKICAgICAgICByZXR1cm4gb2Zmc2V0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHdydEJpZ1VJbnQ2NEJFKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHsKICAgICAgICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpOwogICAgICAgIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCg0Mjk0OTY3Mjk1KSk7CiAgICAgICAgYnVmW29mZnNldCArIDddID0gbG87CiAgICAgICAgbG8gPSBsbyA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXQgKyA2XSA9IGxvOwogICAgICAgIGxvID0gbG8gPj4gODsKICAgICAgICBidWZbb2Zmc2V0ICsgNV0gPSBsbzsKICAgICAgICBsbyA9IGxvID4+IDg7CiAgICAgICAgYnVmW29mZnNldCArIDRdID0gbG87CiAgICAgICAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoNDI5NDk2NzI5NSkpOwogICAgICAgIGJ1ZltvZmZzZXQgKyAzXSA9IGhpOwogICAgICAgIGhpID0gaGkgPj4gODsKICAgICAgICBidWZbb2Zmc2V0ICsgMl0gPSBoaTsKICAgICAgICBoaSA9IGhpID4+IDg7CiAgICAgICAgYnVmW29mZnNldCArIDFdID0gaGk7CiAgICAgICAgaGkgPSBoaSA+PiA4OwogICAgICAgIGJ1ZltvZmZzZXRdID0gaGk7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDg7CiAgICAgIH0KICAgICAgQnVmZmVyNC5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NExFKHZhbHVlLCBvZmZzZXQgPSAwKSB7CiAgICAgICAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCIweGZmZmZmZmZmZmZmZmZmZmYiKSk7CiAgICAgIH0pOwogICAgICBCdWZmZXI0LnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0QkUodmFsdWUsIG9mZnNldCA9IDApIHsKICAgICAgICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoIjB4ZmZmZmZmZmZmZmZmZmZmZiIpKTsKICAgICAgfSk7CiAgICAgIEJ1ZmZlcjQucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7CiAgICAgICAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoMiAtIDEpOwogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIGxpbWl0IC0gMSwgLWxpbWl0KTsKICAgICAgICB9CiAgICAgICAgbGV0IGkgPSAwOwogICAgICAgIGxldCBtdWwgPSAxOwogICAgICAgIGxldCBzdWIgPSAwOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1OwogICAgICAgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoMiAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7CiAgICAgICAgICAgIHN1YiA9IDE7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsID4+IDApIC0gc3ViICYgMjU1OwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjQucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7CiAgICAgICAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoMiAtIDEpOwogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIGxpbWl0IC0gMSwgLWxpbWl0KTsKICAgICAgICB9CiAgICAgICAgbGV0IGkgPSBieXRlTGVuZ3RoMiAtIDE7CiAgICAgICAgbGV0IG11bCA9IDE7CiAgICAgICAgbGV0IHN1YiA9IDA7CiAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMjU1OwogICAgICAgIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDI1NikpIHsKICAgICAgICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7CiAgICAgICAgICAgIHN1YiA9IDE7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsID4+IDApIC0gc3ViICYgMjU1OwogICAgICAgIH0KICAgICAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDI7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjQucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMTI3LCAtMTI4KTsKICAgICAgICBpZiAodmFsdWUgPCAwKQogICAgICAgICAgdmFsdWUgPSAyNTUgKyB2YWx1ZSArIDE7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDE7CiAgICAgIH07CiAgICAgIEJ1ZmZlcjQucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDsKICAgICAgICBpZiAoIW5vQXNzZXJ0KQogICAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMzI3NjcsIC0zMjc2OCk7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiA4OwogICAgICAgIHJldHVybiBvZmZzZXQgKyAyOwogICAgICB9OwogICAgICBCdWZmZXI0LnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkKICAgICAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDMyNzY3LCAtMzI3NjgpOwogICAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlID4+PiA4OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSAmIDI1NTsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMjsKICAgICAgfTsKICAgICAgQnVmZmVyNC5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAyMTQ3NDgzNjQ3LCAtMjE0NzQ4MzY0OCk7CiAgICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiA4OwogICAgICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+Pj4gMTY7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlID4+PiAyNDsKICAgICAgICByZXR1cm4gb2Zmc2V0ICsgNDsKICAgICAgfTsKICAgICAgQnVmZmVyNC5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpCiAgICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAyMTQ3NDgzNjQ3LCAtMjE0NzQ4MzY0OCk7CiAgICAgICAgaWYgKHZhbHVlIDwgMCkKICAgICAgICAgIHZhbHVlID0gNDI5NDk2NzI5NSArIHZhbHVlICsgMTsKICAgICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gMjQ7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiAxNjsKICAgICAgICB0aGlzW29mZnNldCArIDJdID0gdmFsdWUgPj4+IDg7CiAgICAgICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlICYgMjU1OwogICAgICAgIHJldHVybiBvZmZzZXQgKyA0OwogICAgICB9OwogICAgICBCdWZmZXI0LnByb3RvdHlwZS53cml0ZUJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NExFKHZhbHVlLCBvZmZzZXQgPSAwKSB7CiAgICAgICAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoIjB4ODAwMDAwMDAwMDAwMDAwMCIpLCBCaWdJbnQoIjB4N2ZmZmZmZmZmZmZmZmZmZiIpKTsKICAgICAgfSk7CiAgICAgIEJ1ZmZlcjQucHJvdG90eXBlLndyaXRlQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0QkUodmFsdWUsIG9mZnNldCA9IDApIHsKICAgICAgICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgiMHg4MDAwMDAwMDAwMDAwMDAwIiksIEJpZ0ludCgiMHg3ZmZmZmZmZmZmZmZmZmZmIikpOwogICAgICB9KTsKICAgICAgZnVuY3Rpb24gY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikgewogICAgICAgIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKQogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkluZGV4IG91dCBvZiByYW5nZSIpOwogICAgICAgIGlmIChvZmZzZXQgPCAwKQogICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkluZGV4IG91dCBvZiByYW5nZSIpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7CiAgICAgICAgdmFsdWUgPSArdmFsdWU7CiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwOwogICAgICAgIGlmICghbm9Bc3NlcnQpIHsKICAgICAgICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDM0MDI4MjM0NjYzODUyODg2ZTIyLCAtMzQwMjgyMzQ2NjM4NTI4ODZlMjIpOwogICAgICAgIH0KICAgICAgICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNCk7CiAgICAgICAgcmV0dXJuIG9mZnNldCArIDQ7CiAgICAgIH0KICAgICAgQnVmZmVyNC5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpOwogICAgICB9OwogICAgICBCdWZmZXI0LnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpOwogICAgICB9OwogICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHsKICAgICAgICB2YWx1ZSA9ICt2YWx1ZTsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7CiAgICAgICAgaWYgKCFub0Fzc2VydCkgewogICAgICAgICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMTc5NzY5MzEzNDg2MjMxNTdlMjkyLCAtMTc5NzY5MzEzNDg2MjMxNTdlMjkyKTsKICAgICAgICB9CiAgICAgICAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpOwogICAgICAgIHJldHVybiBvZmZzZXQgKyA4OwogICAgICB9CiAgICAgIEJ1ZmZlcjQucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgICAgICAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTsKICAgICAgfTsKICAgICAgQnVmZmVyNC5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICAgICAgICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTsKICAgICAgfTsKICAgICAgQnVmZmVyNC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkgewogICAgICAgIGlmICghQnVmZmVyNC5pc0J1ZmZlcih0YXJnZXQpKQogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyIik7CiAgICAgICAgaWYgKCFzdGFydCkKICAgICAgICAgIHN0YXJ0ID0gMDsKICAgICAgICBpZiAoIWVuZCAmJiBlbmQgIT09IDApCiAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDsKICAgICAgICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkKICAgICAgICAgIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aDsKICAgICAgICBpZiAoIXRhcmdldFN0YXJ0KQogICAgICAgICAgdGFyZ2V0U3RhcnQgPSAwOwogICAgICAgIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KQogICAgICAgICAgZW5kID0gc3RhcnQ7CiAgICAgICAgaWYgKGVuZCA9PT0gc3RhcnQpCiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIGlmICh0YXJnZXRTdGFydCA8IDApIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJ0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzIik7CiAgICAgICAgfQogICAgICAgIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiSW5kZXggb3V0IG9mIHJhbmdlIik7CiAgICAgICAgaWYgKGVuZCA8IDApCiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigic291cmNlRW5kIG91dCBvZiBib3VuZHMiKTsKICAgICAgICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpCiAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDsKICAgICAgICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHsKICAgICAgICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0OwogICAgICAgIH0KICAgICAgICBjb25zdCBsZW4gPSBlbmQgLSBzdGFydDsKICAgICAgICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbCh0YXJnZXQsIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksIHRhcmdldFN0YXJ0KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGxlbjsKICAgICAgfTsKICAgICAgQnVmZmVyNC5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykgewogICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAic3RyaW5nIikgewogICAgICAgICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgZW5jb2RpbmcgPSBzdGFydDsKICAgICAgICAgICAgc3RhcnQgPSAwOwogICAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgZW5jb2RpbmcgPSBlbmQ7CiAgICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGVuY29kaW5nICE9PSB2b2lkIDAgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAic3RyaW5nIikgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nIik7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAic3RyaW5nIiAmJiAhQnVmZmVyNC5pc0VuY29kaW5nKGVuY29kaW5nKSkgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGVuY29kaW5nOiAiICsgZW5jb2RpbmcpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHsKICAgICAgICAgICAgY29uc3QgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApOwogICAgICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICJ1dGY4IiAmJiBjb2RlIDwgMTI4IHx8IGVuY29kaW5nID09PSAibGF0aW4xIikgewogICAgICAgICAgICAgIHZhbCA9IGNvZGU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICJudW1iZXIiKSB7CiAgICAgICAgICB2YWwgPSB2YWwgJiAyNTU7CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAiYm9vbGVhbiIpIHsKICAgICAgICAgIHZhbCA9IE51bWJlcih2YWwpOwogICAgICAgIH0KICAgICAgICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHsKICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCJPdXQgb2YgcmFuZ2UgaW5kZXgiKTsKICAgICAgICB9CiAgICAgICAgaWYgKGVuZCA8PSBzdGFydCkgewogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfQogICAgICAgIHN0YXJ0ID0gc3RhcnQgPj4+IDA7CiAgICAgICAgZW5kID0gZW5kID09PSB2b2lkIDAgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMDsKICAgICAgICBpZiAoIXZhbCkKICAgICAgICAgIHZhbCA9IDA7CiAgICAgICAgbGV0IGk7CiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICJudW1iZXIiKSB7CiAgICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7CiAgICAgICAgICAgIHRoaXNbaV0gPSB2YWw7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGNvbnN0IGJ5dGVzID0gQnVmZmVyNC5pc0J1ZmZlcih2YWwpID8gdmFsIDogQnVmZmVyNC5mcm9tKHZhbCwgZW5jb2RpbmcpOwogICAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoOwogICAgICAgICAgaWYgKGxlbiA9PT0gMCkgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgIicgKyB2YWwgKyAnIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCAidmFsdWUiJyk7CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkgewogICAgICAgICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH07CiAgICAgIHZhciBlcnJvcnMgPSB7fTsKICAgICAgZnVuY3Rpb24gRShzeW0sIGdldE1lc3NhZ2UsIEJhc2UpIHsKICAgICAgICBlcnJvcnNbc3ltXSA9IGNsYXNzIE5vZGVFcnJvciBleHRlbmRzIEJhc2UgewogICAgICAgICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgICAgIHN1cGVyKCk7CiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAibWVzc2FnZSIsIHsKICAgICAgICAgICAgICB2YWx1ZTogZ2V0TWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLAogICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLAogICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgICAgICAgICB9KTsKICAgICAgICAgICAgdGhpcy5uYW1lID0gYCR7dGhpcy5uYW1lfSBbJHtzeW19XWA7CiAgICAgICAgICAgIHRoaXMuc3RhY2s7CiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm5hbWU7CiAgICAgICAgICB9CiAgICAgICAgICBnZXQgY29kZSgpIHsKICAgICAgICAgICAgcmV0dXJuIHN5bTsKICAgICAgICAgIH0KICAgICAgICAgIHNldCBjb2RlKHZhbHVlKSB7CiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAiY29kZSIsIHsKICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgICAgICAgICAgICB2YWx1ZSwKICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZQogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICAgIHRvU3RyaW5nKCkgewogICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBbJHtzeW19XTogJHt0aGlzLm1lc3NhZ2V9YDsKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICB9CiAgICAgIEUoIkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUyIsIGZ1bmN0aW9uKG5hbWUpIHsKICAgICAgICBpZiAobmFtZSkgewogICAgICAgICAgcmV0dXJuIGAke25hbWV9IGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kc2A7CiAgICAgICAgfQogICAgICAgIHJldHVybiAiQXR0ZW1wdCB0byBhY2Nlc3MgbWVtb3J5IG91dHNpZGUgYnVmZmVyIGJvdW5kcyI7CiAgICAgIH0sIFJhbmdlRXJyb3IpOwogICAgICBFKCJFUlJfSU5WQUxJRF9BUkdfVFlQRSIsIGZ1bmN0aW9uKG5hbWUsIGFjdHVhbCkgewogICAgICAgIHJldHVybiBgVGhlICIke25hbWV9IiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGFjdHVhbH1gOwogICAgICB9LCBUeXBlRXJyb3IpOwogICAgICBFKCJFUlJfT1VUX09GX1JBTkdFIiwgZnVuY3Rpb24oc3RyLCByYW5nZSwgaW5wdXQpIHsKICAgICAgICBsZXQgbXNnID0gYFRoZSB2YWx1ZSBvZiAiJHtzdHJ9IiBpcyBvdXQgb2YgcmFuZ2UuYDsKICAgICAgICBsZXQgcmVjZWl2ZWQgPSBpbnB1dDsKICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihpbnB1dCkgJiYgTWF0aC5hYnMoaW5wdXQpID4gMiAqKiAzMikgewogICAgICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IoU3RyaW5nKGlucHV0KSk7CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICJiaWdpbnQiKSB7CiAgICAgICAgICByZWNlaXZlZCA9IFN0cmluZyhpbnB1dCk7CiAgICAgICAgICBpZiAoaW5wdXQgPiBCaWdJbnQoMikgKiogQmlnSW50KDMyKSB8fCBpbnB1dCA8IC0oQmlnSW50KDIpICoqIEJpZ0ludCgzMikpKSB7CiAgICAgICAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKHJlY2VpdmVkKTsKICAgICAgICAgIH0KICAgICAgICAgIHJlY2VpdmVkICs9ICJuIjsKICAgICAgICB9CiAgICAgICAgbXNnICs9IGAgSXQgbXVzdCBiZSAke3JhbmdlfS4gUmVjZWl2ZWQgJHtyZWNlaXZlZH1gOwogICAgICAgIHJldHVybiBtc2c7CiAgICAgIH0sIFJhbmdlRXJyb3IpOwogICAgICBmdW5jdGlvbiBhZGROdW1lcmljYWxTZXBhcmF0b3IodmFsKSB7CiAgICAgICAgbGV0IHJlcyA9ICIiOwogICAgICAgIGxldCBpID0gdmFsLmxlbmd0aDsKICAgICAgICBjb25zdCBzdGFydCA9IHZhbFswXSA9PT0gIi0iID8gMSA6IDA7CiAgICAgICAgZm9yICg7IGkgPj0gc3RhcnQgKyA0OyBpIC09IDMpIHsKICAgICAgICAgIHJlcyA9IGBfJHt2YWwuc2xpY2UoaSAtIDMsIGkpfSR7cmVzfWA7CiAgICAgICAgfQogICAgICAgIHJldHVybiBgJHt2YWwuc2xpY2UoMCwgaSl9JHtyZXN9YDsKICAgICAgfQogICAgICBmdW5jdGlvbiBjaGVja0JvdW5kcyhidWYsIG9mZnNldCwgYnl0ZUxlbmd0aDIpIHsKICAgICAgICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICJvZmZzZXQiKTsKICAgICAgICBpZiAoYnVmW29mZnNldF0gPT09IHZvaWQgMCB8fCBidWZbb2Zmc2V0ICsgYnl0ZUxlbmd0aDJdID09PSB2b2lkIDApIHsKICAgICAgICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgYnVmLmxlbmd0aCAtIChieXRlTGVuZ3RoMiArIDEpKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoMikgewogICAgICAgIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgewogICAgICAgICAgY29uc3QgbiA9IHR5cGVvZiBtaW4gPT09ICJiaWdpbnQiID8gIm4iIDogIiI7CiAgICAgICAgICBsZXQgcmFuZ2U7CiAgICAgICAgICBpZiAoYnl0ZUxlbmd0aDIgPiAzKSB7CiAgICAgICAgICAgIGlmIChtaW4gPT09IDAgfHwgbWluID09PSBCaWdJbnQoMCkpIHsKICAgICAgICAgICAgICByYW5nZSA9IGA+PSAwJHtufSBhbmQgPCAyJHtufSAqKiAkeyhieXRlTGVuZ3RoMiArIDEpICogOH0ke259YDsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByYW5nZSA9IGA+PSAtKDIke259ICoqICR7KGJ5dGVMZW5ndGgyICsgMSkgKiA4IC0gMX0ke259KSBhbmQgPCAyICoqICR7KGJ5dGVMZW5ndGgyICsgMSkgKiA4IC0gMX0ke259YDsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmFuZ2UgPSBgPj0gJHttaW59JHtufSBhbmQgPD0gJHttYXh9JHtufWA7CiAgICAgICAgICB9CiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UoInZhbHVlIiwgcmFuZ2UsIHZhbHVlKTsKICAgICAgICB9CiAgICAgICAgY2hlY2tCb3VuZHMoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgyKTsKICAgICAgfQogICAgICBmdW5jdGlvbiB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgbmFtZSkgewogICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICJudW1iZXIiKSB7CiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICJudW1iZXIiLCB2YWx1ZSk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJvdW5kc0Vycm9yKHZhbHVlLCBsZW5ndGgsIHR5cGUpIHsKICAgICAgICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKSB7CiAgICAgICAgICB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgdHlwZSk7CiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAib2Zmc2V0IiwgImFuIGludGVnZXIiLCB2YWx1ZSk7CiAgICAgICAgfQogICAgICAgIGlmIChsZW5ndGggPCAwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUygpOwogICAgICAgIH0KICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAib2Zmc2V0IiwgYD49ICR7dHlwZSA/IDEgOiAwfSBhbmQgPD0gJHtsZW5ndGh9YCwgdmFsdWUpOwogICAgICB9CiAgICAgIHZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2c7CiAgICAgIGZ1bmN0aW9uIGJhc2U2NGNsZWFuKHN0cikgewogICAgICAgIHN0ciA9IHN0ci5zcGxpdCgiPSIpWzBdOwogICAgICAgIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgIiIpOwogICAgICAgIGlmIChzdHIubGVuZ3RoIDwgMikKICAgICAgICAgIHJldHVybiAiIjsKICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHsKICAgICAgICAgIHN0ciA9IHN0ciArICI9IjsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHN0cjsKICAgICAgfQogICAgICBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHJpbmcsIHVuaXRzKSB7CiAgICAgICAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eTsKICAgICAgICBsZXQgY29kZVBvaW50OwogICAgICAgIGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7CiAgICAgICAgbGV0IGxlYWRTdXJyb2dhdGUgPSBudWxsOwogICAgICAgIGNvbnN0IGJ5dGVzID0gW107CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgewogICAgICAgICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7CiAgICAgICAgICBpZiAoY29kZVBvaW50ID4gNTUyOTUgJiYgY29kZVBvaW50IDwgNTczNDQpIHsKICAgICAgICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7CiAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA+IDU2MzE5KSB7CiAgICAgICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpCiAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMjM5LCAxOTEsIDE4OSk7CiAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHsKICAgICAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkKICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgyMzksIDE5MSwgMTg5KTsKICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50OwogICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPCA1NjMyMCkgewogICAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkKICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMjM5LCAxOTEsIDE4OSk7CiAgICAgICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDsKICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDU1Mjk2IDw8IDEwIHwgY29kZVBvaW50IC0gNTYzMjApICsgNjU1MzY7CiAgICAgICAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHsKICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKQogICAgICAgICAgICAgIGJ5dGVzLnB1c2goMjM5LCAxOTEsIDE4OSk7CiAgICAgICAgICB9CiAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gbnVsbDsKICAgICAgICAgIGlmIChjb2RlUG9pbnQgPCAxMjgpIHsKICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApCiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KTsKICAgICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMjA0OCkgewogICAgICAgICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQgPj4gNiB8IDE5MiwgY29kZVBvaW50ICYgNjMgfCAxMjgpOwogICAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCA2NTUzNikgewogICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQgPj4gMTIgfCAyMjQsIGNvZGVQb2ludCA+PiA2ICYgNjMgfCAxMjgsIGNvZGVQb2ludCAmIDYzIHwgMTI4KTsKICAgICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMTExNDExMikgewogICAgICAgICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQgPj4gMTggfCAyNDAsIGNvZGVQb2ludCA+PiAxMiAmIDYzIHwgMTI4LCBjb2RlUG9pbnQgPj4gNiAmIDYzIHwgMTI4LCBjb2RlUG9pbnQgJiA2MyB8IDEyOCk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgY29kZSBwb2ludCIpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gYnl0ZXM7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYXNjaWlUb0J5dGVzKHN0cikgewogICAgICAgIGNvbnN0IGJ5dGVBcnJheSA9IFtdOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7CiAgICAgICAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDI1NSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBieXRlQXJyYXk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMoc3RyLCB1bml0cykgewogICAgICAgIGxldCBjLCBoaSwgbG87CiAgICAgICAgY29uc3QgYnl0ZUFycmF5ID0gW107CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHsKICAgICAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKQogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTsKICAgICAgICAgIGhpID0gYyA+PiA4OwogICAgICAgICAgbG8gPSBjICUgMjU2OwogICAgICAgICAgYnl0ZUFycmF5LnB1c2gobG8pOwogICAgICAgICAgYnl0ZUFycmF5LnB1c2goaGkpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gYnl0ZUFycmF5OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoc3RyKSB7CiAgICAgICAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBibGl0QnVmZmVyKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkgewogICAgICAgIGxldCBpOwogICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgewogICAgICAgICAgaWYgKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCB8fCBpID49IHNyYy5sZW5ndGgpCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldOwogICAgICAgIH0KICAgICAgICByZXR1cm4gaTsKICAgICAgfQogICAgICBmdW5jdGlvbiBpc0luc3RhbmNlKG9iaiwgdHlwZSkgewogICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8IG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZTsKICAgICAgfQogICAgICBmdW5jdGlvbiBudW1iZXJJc05hTihvYmopIHsKICAgICAgICByZXR1cm4gb2JqICE9PSBvYmo7CiAgICAgIH0KICAgICAgdmFyIGhleFNsaWNlTG9va3VwVGFibGUgPSBmdW5jdGlvbigpIHsKICAgICAgICBjb25zdCBhbHBoYWJldCA9ICIwMTIzNDU2Nzg5YWJjZGVmIjsKICAgICAgICBjb25zdCB0YWJsZSA9IG5ldyBBcnJheSgyNTYpOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkgewogICAgICAgICAgY29uc3QgaTE2ID0gaSAqIDE2OwogICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgKytqKSB7CiAgICAgICAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRhYmxlOwogICAgICB9KCk7CiAgICAgIGZ1bmN0aW9uIGRlZmluZUJpZ0ludE1ldGhvZChmbikgewogICAgICAgIHJldHVybiB0eXBlb2YgQmlnSW50ID09PSAidW5kZWZpbmVkIiA/IEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgOiBmbjsKICAgICAgfQogICAgICBmdW5jdGlvbiBCdWZmZXJCaWdJbnROb3REZWZpbmVkKCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiQmlnSW50IG5vdCBzdXBwb3J0ZWQiKTsKICAgICAgfQogICAgfQogIH0pOwoKICAvLyBzcmMvYWxpYXMvYnVmZmVyLXNoaW0uanMKICB2YXIgaW1wb3J0X2J1ZmZlcjsKICB2YXIgaW5pdF9idWZmZXJfc2hpbSA9IF9fZXNtKHsKICAgICJzcmMvYWxpYXMvYnVmZmVyLXNoaW0uanMiKCkgewogICAgICBpbXBvcnRfYnVmZmVyID0gX190b01vZHVsZShyZXF1aXJlX2J1ZmZlcigpKTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL2Fib3J0Y29udHJvbGxlci1wb2x5ZmlsbC9kaXN0L2Nqcy1wb255ZmlsbC5qcwogIHZhciByZXF1aXJlX2Nqc19wb255ZmlsbCA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9hYm9ydGNvbnRyb2xsZXItcG9seWZpbGwvZGlzdC9janMtcG9ueWZpbGwuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgewogICAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24iKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgewogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07CiAgICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7CiAgICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7CiAgICAgICAgICBpZiAoInZhbHVlIiBpbiBkZXNjcmlwdG9yKQogICAgICAgICAgICBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgewogICAgICAgIGlmIChwcm90b1Byb3BzKQogICAgICAgICAgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsKICAgICAgICBpZiAoc3RhdGljUHJvcHMpCiAgICAgICAgICBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOwogICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjsKICAgICAgfQogICAgICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsKICAgICAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICJmdW5jdGlvbiIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24iKTsKICAgICAgICB9CiAgICAgICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7CiAgICAgICAgICBjb25zdHJ1Y3RvcjogewogICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsCiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLAogICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgICBpZiAoc3VwZXJDbGFzcykKICAgICAgICAgIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsKICAgICAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YyKG8yKSB7CiAgICAgICAgICByZXR1cm4gbzIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvMik7CiAgICAgICAgfTsKICAgICAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7CiAgICAgICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZjIobzIsIHAyKSB7CiAgICAgICAgICBvMi5fX3Byb3RvX18gPSBwMjsKICAgICAgICAgIHJldHVybiBvMjsKICAgICAgICB9OwogICAgICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsKICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICJ1bmRlZmluZWQiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICBpZiAodHlwZW9mIFByb3h5ID09PSAiZnVuY3Rpb24iKQogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7CiAgICAgICAgICB9KSk7CiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZjIpIHsKICAgICAgICBpZiAoc2VsZjIgPT09IHZvaWQgMCkgewogICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWQiKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHNlbGYyOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYyLCBjYWxsKSB7CiAgICAgICAgaWYgKGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSAib2JqZWN0IiB8fCB0eXBlb2YgY2FsbCA9PT0gImZ1bmN0aW9uIikpIHsKICAgICAgICAgIHJldHVybiBjYWxsOwogICAgICAgIH0KICAgICAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmMik7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsKICAgICAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsKICAgICAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7CiAgICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsKICAgICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7CiAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7CiAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7CiAgICAgICAgfTsKICAgICAgfQogICAgICBmdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7CiAgICAgICAgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsKICAgICAgICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOwogICAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICAgIHJldHVybiBvYmplY3Q7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgewogICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gInVuZGVmaW5lZCIgJiYgUmVmbGVjdC5nZXQpIHsKICAgICAgICAgIF9nZXQgPSBSZWZsZWN0LmdldDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQyKHRhcmdldDIsIHByb3BlcnR5MiwgcmVjZWl2ZXIyKSB7CiAgICAgICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0MiwgcHJvcGVydHkyKTsKICAgICAgICAgICAgaWYgKCFiYXNlKQogICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5Mik7CiAgICAgICAgICAgIGlmIChkZXNjLmdldCkgewogICAgICAgICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyMik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGRlc2MudmFsdWU7CiAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgICByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOwogICAgICB9CiAgICAgIHZhciBFbWl0dGVyID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkgewogICAgICAgIGZ1bmN0aW9uIEVtaXR0ZXIyKCkgewogICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVtaXR0ZXIyKTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAibGlzdGVuZXJzIiwgewogICAgICAgICAgICB2YWx1ZToge30sCiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLAogICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICBfY3JlYXRlQ2xhc3MoRW1pdHRlcjIsIFt7CiAgICAgICAgICBrZXk6ICJhZGRFdmVudExpc3RlbmVyIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrLCBvcHRpb25zKSB7CiAgICAgICAgICAgIGlmICghKHR5cGUgaW4gdGhpcy5saXN0ZW5lcnMpKSB7CiAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0gPSBbXTsKICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKHsKICAgICAgICAgICAgICBjYWxsYmFjaywKICAgICAgICAgICAgICBvcHRpb25zCiAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogInJlbW92ZUV2ZW50TGlzdGVuZXIiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2spIHsKICAgICAgICAgICAgaWYgKCEodHlwZSBpbiB0aGlzLmxpc3RlbmVycykpIHsKICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIHN0YWNrID0gdGhpcy5saXN0ZW5lcnNbdHlwZV07CiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3RhY2subGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgICAgICAgaWYgKHN0YWNrW2ldLmNhbGxiYWNrID09PSBjYWxsYmFjaykgewogICAgICAgICAgICAgICAgc3RhY2suc3BsaWNlKGksIDEpOwogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogImRpc3BhdGNoRXZlbnQiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHsKICAgICAgICAgICAgaWYgKCEoZXZlbnQudHlwZSBpbiB0aGlzLmxpc3RlbmVycykpIHsKICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIHN0YWNrID0gdGhpcy5saXN0ZW5lcnNbZXZlbnQudHlwZV07CiAgICAgICAgICAgIHZhciBzdGFja1RvQ2FsbCA9IHN0YWNrLnNsaWNlKCk7CiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3RhY2tUb0NhbGwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gc3RhY2tUb0NhbGxbaV07CiAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGxiYWNrLmNhbGwodGhpcywgZXZlbnQpOwogICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICAgIHRocm93IGU7CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyLm9wdGlvbnMgJiYgbGlzdGVuZXIub3B0aW9ucy5vbmNlKSB7CiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQudHlwZSwgbGlzdGVuZXIuY2FsbGJhY2spOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7CiAgICAgICAgICB9CiAgICAgICAgfV0pOwogICAgICAgIHJldHVybiBFbWl0dGVyMjsKICAgICAgfSgpOwogICAgICB2YXIgQWJvcnRTaWduYWwgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oX0VtaXR0ZXIpIHsKICAgICAgICBfaW5oZXJpdHMoQWJvcnRTaWduYWwyLCBfRW1pdHRlcik7CiAgICAgICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihBYm9ydFNpZ25hbDIpOwogICAgICAgIGZ1bmN0aW9uIEFib3J0U2lnbmFsMigpIHsKICAgICAgICAgIHZhciBfdGhpczsKICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBYm9ydFNpZ25hbDIpOwogICAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTsKICAgICAgICAgIGlmICghX3RoaXMubGlzdGVuZXJzKSB7CiAgICAgICAgICAgIEVtaXR0ZXIuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7CiAgICAgICAgICB9CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksICJhYm9ydGVkIiwgewogICAgICAgICAgICB2YWx1ZTogZmFsc2UsCiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLAogICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUKICAgICAgICAgIH0pOwogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCAib25hYm9ydCIsIHsKICAgICAgICAgICAgdmFsdWU6IG51bGwsCiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLAogICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUKICAgICAgICAgIH0pOwogICAgICAgICAgcmV0dXJuIF90aGlzOwogICAgICAgIH0KICAgICAgICBfY3JlYXRlQ2xhc3MoQWJvcnRTaWduYWwyLCBbewogICAgICAgICAga2V5OiAidG9TdHJpbmciLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkgewogICAgICAgICAgICByZXR1cm4gIltvYmplY3QgQWJvcnRTaWduYWxdIjsKICAgICAgICAgIH0KICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJkaXNwYXRjaEV2ZW50IiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7CiAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAiYWJvcnQiKSB7CiAgICAgICAgICAgICAgdGhpcy5hYm9ydGVkID0gdHJ1ZTsKICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub25hYm9ydCA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICAgICAgdGhpcy5vbmFib3J0LmNhbGwodGhpcywgZXZlbnQpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihBYm9ydFNpZ25hbDIucHJvdG90eXBlKSwgImRpc3BhdGNoRXZlbnQiLCB0aGlzKS5jYWxsKHRoaXMsIGV2ZW50KTsKICAgICAgICAgIH0KICAgICAgICB9XSk7CiAgICAgICAgcmV0dXJuIEFib3J0U2lnbmFsMjsKICAgICAgfShFbWl0dGVyKTsKICAgICAgdmFyIEFib3J0Q29udHJvbGxlciA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHsKICAgICAgICBmdW5jdGlvbiBBYm9ydENvbnRyb2xsZXIyKCkgewogICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFib3J0Q29udHJvbGxlcjIpOwogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICJzaWduYWwiLCB7CiAgICAgICAgICAgIHZhbHVlOiBuZXcgQWJvcnRTaWduYWwoKSwKICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsCiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICAgIF9jcmVhdGVDbGFzcyhBYm9ydENvbnRyb2xsZXIyLCBbewogICAgICAgICAga2V5OiAiYWJvcnQiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFib3J0KCkgewogICAgICAgICAgICB2YXIgZXZlbnQ7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgZXZlbnQgPSBuZXcgRXZlbnQoImFib3J0Iik7CiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAidW5kZWZpbmVkIikgewogICAgICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5jcmVhdGVFdmVudCkgewogICAgICAgICAgICAgICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KCk7CiAgICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSAiYWJvcnQiOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgiRXZlbnQiKTsKICAgICAgICAgICAgICAgICAgZXZlbnQuaW5pdEV2ZW50KCJhYm9ydCIsIGZhbHNlLCBmYWxzZSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGV2ZW50ID0gewogICAgICAgICAgICAgICAgICB0eXBlOiAiYWJvcnQiLAogICAgICAgICAgICAgICAgICBidWJibGVzOiBmYWxzZSwKICAgICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogZmFsc2UKICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuc2lnbmFsLmRpc3BhdGNoRXZlbnQoZXZlbnQpOwogICAgICAgICAgfQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogInRvU3RyaW5nIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHsKICAgICAgICAgICAgcmV0dXJuICJbb2JqZWN0IEFib3J0Q29udHJvbGxlcl0iOwogICAgICAgICAgfQogICAgICAgIH1dKTsKICAgICAgICByZXR1cm4gQWJvcnRDb250cm9sbGVyMjsKICAgICAgfSgpOwogICAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gInVuZGVmaW5lZCIgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7CiAgICAgICAgQWJvcnRDb250cm9sbGVyLnByb3RvdHlwZVtTeW1ib2wudG9TdHJpbmdUYWddID0gIkFib3J0Q29udHJvbGxlciI7CiAgICAgICAgQWJvcnRTaWduYWwucHJvdG90eXBlW1N5bWJvbC50b1N0cmluZ1RhZ10gPSAiQWJvcnRTaWduYWwiOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBvbHlmaWxsTmVlZGVkKHNlbGYyKSB7CiAgICAgICAgaWYgKHNlbGYyLl9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEwpIHsKICAgICAgICAgIGNvbnNvbGUubG9nKCJfX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMPXRydWUgaXMgc2V0LCB3aWxsIGZvcmNlIGluc3RhbGwgcG9seWZpbGwiKTsKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdHlwZW9mIHNlbGYyLlJlcXVlc3QgPT09ICJmdW5jdGlvbiIgJiYgIXNlbGYyLlJlcXVlc3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KCJzaWduYWwiKSB8fCAhc2VsZjIuQWJvcnRDb250cm9sbGVyOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGFib3J0YWJsZUZldGNoRGVjb3JhdG9yKHBhdGNoVGFyZ2V0cykgewogICAgICAgIGlmICh0eXBlb2YgcGF0Y2hUYXJnZXRzID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgICBwYXRjaFRhcmdldHMgPSB7CiAgICAgICAgICAgIGZldGNoOiBwYXRjaFRhcmdldHMKICAgICAgICAgIH07CiAgICAgICAgfQogICAgICAgIHZhciBfcGF0Y2hUYXJnZXRzID0gcGF0Y2hUYXJnZXRzLCBmZXRjaCA9IF9wYXRjaFRhcmdldHMuZmV0Y2gsIF9wYXRjaFRhcmdldHMkUmVxdWVzdCA9IF9wYXRjaFRhcmdldHMuUmVxdWVzdCwgTmF0aXZlUmVxdWVzdCA9IF9wYXRjaFRhcmdldHMkUmVxdWVzdCA9PT0gdm9pZCAwID8gZmV0Y2guUmVxdWVzdCA6IF9wYXRjaFRhcmdldHMkUmVxdWVzdCwgTmF0aXZlQWJvcnRDb250cm9sbGVyID0gX3BhdGNoVGFyZ2V0cy5BYm9ydENvbnRyb2xsZXIsIF9wYXRjaFRhcmdldHMkX19GT1JDRSA9IF9wYXRjaFRhcmdldHMuX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTCwgX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTCA9IF9wYXRjaFRhcmdldHMkX19GT1JDRSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcGF0Y2hUYXJnZXRzJF9fRk9SQ0U7CiAgICAgICAgaWYgKCFwb2x5ZmlsbE5lZWRlZCh7CiAgICAgICAgICBmZXRjaCwKICAgICAgICAgIFJlcXVlc3Q6IE5hdGl2ZVJlcXVlc3QsCiAgICAgICAgICBBYm9ydENvbnRyb2xsZXI6IE5hdGl2ZUFib3J0Q29udHJvbGxlciwKICAgICAgICAgIF9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEwKICAgICAgICB9KSkgewogICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgZmV0Y2gsCiAgICAgICAgICAgIFJlcXVlc3QKICAgICAgICAgIH07CiAgICAgICAgfQogICAgICAgIHZhciBSZXF1ZXN0ID0gTmF0aXZlUmVxdWVzdDsKICAgICAgICBpZiAoUmVxdWVzdCAmJiAhUmVxdWVzdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoInNpZ25hbCIpIHx8IF9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEwpIHsKICAgICAgICAgIFJlcXVlc3QgPSBmdW5jdGlvbiBSZXF1ZXN0MihpbnB1dCwgaW5pdDIpIHsKICAgICAgICAgICAgdmFyIHNpZ25hbDsKICAgICAgICAgICAgaWYgKGluaXQyICYmIGluaXQyLnNpZ25hbCkgewogICAgICAgICAgICAgIHNpZ25hbCA9IGluaXQyLnNpZ25hbDsKICAgICAgICAgICAgICBkZWxldGUgaW5pdDIuc2lnbmFsOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IE5hdGl2ZVJlcXVlc3QoaW5wdXQsIGluaXQyKTsKICAgICAgICAgICAgaWYgKHNpZ25hbCkgewogICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1ZXN0LCAic2lnbmFsIiwgewogICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLAogICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsCiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICAgICAgICAgICAgICB2YWx1ZTogc2lnbmFsCiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7CiAgICAgICAgICB9OwogICAgICAgICAgUmVxdWVzdC5wcm90b3R5cGUgPSBOYXRpdmVSZXF1ZXN0LnByb3RvdHlwZTsKICAgICAgICB9CiAgICAgICAgdmFyIHJlYWxGZXRjaCA9IGZldGNoOwogICAgICAgIHZhciBhYm9ydGFibGVGZXRjaCA9IGZ1bmN0aW9uIGFib3J0YWJsZUZldGNoMihpbnB1dCwgaW5pdDIpIHsKICAgICAgICAgIHZhciBzaWduYWwgPSBSZXF1ZXN0ICYmIFJlcXVlc3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoaW5wdXQpID8gaW5wdXQuc2lnbmFsIDogaW5pdDIgPyBpbml0Mi5zaWduYWwgOiB2b2lkIDA7CiAgICAgICAgICBpZiAoc2lnbmFsKSB7CiAgICAgICAgICAgIHZhciBhYm9ydEVycm9yOwogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIGFib3J0RXJyb3IgPSBuZXcgRE9NRXhjZXB0aW9uKCJBYm9ydGVkIiwgIkFib3J0RXJyb3IiKTsKICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICAgICAgYWJvcnRFcnJvciA9IG5ldyBFcnJvcigiQWJvcnRlZCIpOwogICAgICAgICAgICAgIGFib3J0RXJyb3IubmFtZSA9ICJBYm9ydEVycm9yIjsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHsKICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoYWJvcnRFcnJvcik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIGNhbmNlbGxhdGlvbiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKF8sIHJlamVjdCkgewogICAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCJhYm9ydCIsIGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChhYm9ydEVycm9yKTsKICAgICAgICAgICAgICB9LCB7CiAgICAgICAgICAgICAgICBvbmNlOiB0cnVlCiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICBpZiAoaW5pdDIgJiYgaW5pdDIuc2lnbmFsKSB7CiAgICAgICAgICAgICAgZGVsZXRlIGluaXQyLnNpZ25hbDsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtjYW5jZWxsYXRpb24sIHJlYWxGZXRjaChpbnB1dCwgaW5pdDIpXSk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gcmVhbEZldGNoKGlucHV0LCBpbml0Mik7CiAgICAgICAgfTsKICAgICAgICByZXR1cm4gewogICAgICAgICAgZmV0Y2g6IGFib3J0YWJsZUZldGNoLAogICAgICAgICAgUmVxdWVzdAogICAgICAgIH07CiAgICAgIH0KICAgICAgZXhwb3J0czIuQWJvcnRDb250cm9sbGVyID0gQWJvcnRDb250cm9sbGVyOwogICAgICBleHBvcnRzMi5BYm9ydFNpZ25hbCA9IEFib3J0U2lnbmFsOwogICAgICBleHBvcnRzMi5hYm9ydGFibGVGZXRjaCA9IGFib3J0YWJsZUZldGNoRGVjb3JhdG9yOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvdGFiaXgvbm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9hYm9ydGNvbnRyb2xsZXItcG9ueWZpbGwuanMKICB2YXIgcmVxdWlyZV9hYm9ydGNvbnRyb2xsZXJfcG9ueWZpbGwgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGdtb2QvdGFiaXgvbm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9hYm9ydGNvbnRyb2xsZXItcG9ueWZpbGwuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZXhwb3J0czIuQWJvcnRTaWduYWwgPSBleHBvcnRzMi5BYm9ydENvbnRyb2xsZXIgPSB2b2lkIDA7CiAgICAgIHZhciBjanNfcG9ueWZpbGxfMSA9IHJlcXVpcmVfY2pzX3BvbnlmaWxsKCk7CiAgICAgIHZhciBnZXRHbG9iYWwgPSBmdW5jdGlvbigpIHsKICAgICAgICBpZiAodHlwZW9mIHNlbGYgIT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgICByZXR1cm4gc2VsZjsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgICByZXR1cm4gd2luZG93OwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gInVuZGVmaW5lZCIpIHsKICAgICAgICAgIHJldHVybiBnbG9iYWw7CiAgICAgICAgfQogICAgICAgIHRocm93IG5ldyBFcnJvcigidW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0Iik7CiAgICAgIH07CiAgICAgIHZhciBBYm9ydENvbnRyb2xsZXIgPSB0eXBlb2YgZ2V0R2xvYmFsKCkuQWJvcnRDb250cm9sbGVyID09PSAidW5kZWZpbmVkIiA/IGNqc19wb255ZmlsbF8xLkFib3J0Q29udHJvbGxlciA6IGdldEdsb2JhbCgpLkFib3J0Q29udHJvbGxlcjsKICAgICAgZXhwb3J0czIuQWJvcnRDb250cm9sbGVyID0gQWJvcnRDb250cm9sbGVyOwogICAgICB2YXIgQWJvcnRTaWduYWwgPSB0eXBlb2YgZ2V0R2xvYmFsKCkuQWJvcnRDb250cm9sbGVyID09PSAidW5kZWZpbmVkIiA/IGNqc19wb255ZmlsbF8xLkFib3J0U2lnbmFsIDogZ2V0R2xvYmFsKCkuQWJvcnRTaWduYWw7CiAgICAgIGV4cG9ydHMyLkFib3J0U2lnbmFsID0gQWJvcnRTaWduYWw7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9ub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL0FnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlci5qcwogIHZhciByZXF1aXJlX0FnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9ub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL0FnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlci5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICB2YXIgYWJvcnRjb250cm9sbGVyX3BvbnlmaWxsXzEgPSByZXF1aXJlX2Fib3J0Y29udHJvbGxlcl9wb255ZmlsbCgpOwogICAgICB2YXIgTnVsbFNpZ25hbCA9IGNsYXNzIHsKICAgICAgfTsKICAgICAgdmFyIEFnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlciA9IGNsYXNzIHsKICAgICAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgICAgIHRoaXMuc2lnbmFscyA9IG5ldyBTZXQoKTsKICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gbmV3IGFib3J0Y29udHJvbGxlcl9wb255ZmlsbF8xLkFib3J0Q29udHJvbGxlcigpOwogICAgICAgIH0KICAgICAgICBhZGRTaWduYWwoc2lnbmFsID0gbmV3IE51bGxTaWduYWwoKSkgewogICAgICAgICAgaWYgKHRoaXMuc2lnbmFsLmFib3J0ZWQpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJjYW5ub3QgYWRkIGEgc2lnbmFsLCBhbHJlYWR5IGFib3J0ZWQhIik7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLnNpZ25hbHMuYWRkKHNpZ25hbCk7CiAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHsKICAgICAgICAgICAgdGhpcy5oYW5kbGVBYm9ydGVkKHNpZ25hbCk7CiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcigiYWJvcnQiLCAoKSA9PiB7CiAgICAgICAgICAgICAgdGhpcy5oYW5kbGVBYm9ydGVkKHNpZ25hbCk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBoYW5kbGVBYm9ydGVkKHNpZ25hbCkgewogICAgICAgICAgdGhpcy5zaWduYWxzLmRlbGV0ZShzaWduYWwpOwogICAgICAgICAgaWYgKHRoaXMuc2lnbmFscy5zaXplID09PSAwKSB7CiAgICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGdldCBzaWduYWwoKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5hYm9ydENvbnRyb2xsZXIuc2lnbmFsOwogICAgICAgIH0KICAgICAgICBhYm9ydCgpIHsKICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KCk7CiAgICAgICAgfQogICAgICB9OwogICAgICBleHBvcnRzMi5kZWZhdWx0ID0gQWdncmVnYXRlQWJvcnRDb250cm9sbGVyOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvdGFiaXgvbm9kZV9tb2R1bGVzL2Fib3J0YWJsZS1wcm9taXNlLWNhY2hlL2VzbS9BZ2dyZWdhdGVTdGF0dXNSZXBvcnRlci5qcwogIHZhciByZXF1aXJlX0FnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L25vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9lc20vQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXIuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgdmFyIEFnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyID0gY2xhc3MgewogICAgICAgIGNvbnN0cnVjdG9yKCkgewogICAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBuZXcgU2V0KCk7CiAgICAgICAgfQogICAgICAgIGFkZENhbGxiYWNrKGNhbGxiYWNrID0gKCkgPT4gewogICAgICAgIH0pIHsKICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmFkZChjYWxsYmFjayk7CiAgICAgICAgICBjYWxsYmFjayh0aGlzLmN1cnJlbnRNZXNzYWdlKTsKICAgICAgICB9CiAgICAgICAgY2FsbGJhY2sobWVzc2FnZSkgewogICAgICAgICAgdGhpcy5jdXJyZW50TWVzc2FnZSA9IG1lc3NhZ2U7CiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5mb3JFYWNoKChlbHQpID0+IHsKICAgICAgICAgICAgZWx0KG1lc3NhZ2UpOwogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICB9OwogICAgICBleHBvcnRzMi5kZWZhdWx0ID0gQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9ub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL0Fib3J0YWJsZVByb21pc2VDYWNoZS5qcwogIHZhciByZXF1aXJlX0Fib3J0YWJsZVByb21pc2VDYWNoZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9ub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL0Fib3J0YWJsZVByb21pc2VDYWNoZS5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBfX2ltcG9ydERlZmF1bHQgPSBleHBvcnRzMiAmJiBleHBvcnRzMi5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24obW9kKSB7CiAgICAgICAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHsgImRlZmF1bHQiOiBtb2QgfTsKICAgICAgfTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIHZhciBhYm9ydGNvbnRyb2xsZXJfcG9ueWZpbGxfMSA9IHJlcXVpcmVfYWJvcnRjb250cm9sbGVyX3BvbnlmaWxsKCk7CiAgICAgIHZhciBBZ2dyZWdhdGVBYm9ydENvbnRyb2xsZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlX0FnZ3JlZ2F0ZUFib3J0Q29udHJvbGxlcigpKTsKICAgICAgdmFyIEFnZ3JlZ2F0ZVN0YXR1c1JlcG9ydGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZV9BZ2dyZWdhdGVTdGF0dXNSZXBvcnRlcigpKTsKICAgICAgdmFyIEFib3J0YWJsZVByb21pc2VDYWNoZTMgPSBjbGFzcyB7CiAgICAgICAgY29uc3RydWN0b3IoeyBmaWxsLCBjYWNoZSB9KSB7CiAgICAgICAgICBpZiAodHlwZW9mIGZpbGwgIT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigibXVzdCBwYXNzIGEgZmlsbCBmdW5jdGlvbiIpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHR5cGVvZiBjYWNoZSAhPT0gIm9iamVjdCIpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigibXVzdCBwYXNzIGEgY2FjaGUgb2JqZWN0Iik7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodHlwZW9mIGNhY2hlLmdldCAhPT0gImZ1bmN0aW9uIiB8fCB0eXBlb2YgY2FjaGUuc2V0ICE9PSAiZnVuY3Rpb24iIHx8IHR5cGVvZiBjYWNoZS5kZWxldGUgIT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiY2FjaGUgbXVzdCBpbXBsZW1lbnQgZ2V0KGtleSksIHNldChrZXksIHZhbCksIGFuZCBhbmQgZGVsZXRlKGtleSkiKTsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXMuY2FjaGUgPSBjYWNoZTsKICAgICAgICAgIHRoaXMuZmlsbENhbGxiYWNrID0gZmlsbDsKICAgICAgICB9CiAgICAgICAgc3RhdGljIGlzQWJvcnRFeGNlcHRpb24oZXhjZXB0aW9uKSB7CiAgICAgICAgICByZXR1cm4gZXhjZXB0aW9uLm5hbWUgPT09ICJBYm9ydEVycm9yIiB8fCBleGNlcHRpb24uY29kZSA9PT0gIkVSUl9BQk9SVEVEIiB8fCBleGNlcHRpb24ubWVzc2FnZSA9PT0gIkFib3J0RXJyb3I6IGFib3J0ZWQiIHx8IGV4Y2VwdGlvbi5tZXNzYWdlID09PSAiRXJyb3I6IGFib3J0ZWQiOwogICAgICAgIH0KICAgICAgICBldmljdChrZXksIGVudHJ5KSB7CiAgICAgICAgICBpZiAodGhpcy5jYWNoZS5nZXQoa2V5KSA9PT0gZW50cnkpIHsKICAgICAgICAgICAgdGhpcy5jYWNoZS5kZWxldGUoa2V5KTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZmlsbChrZXksIGRhdGEsIHNpZ25hbCwgc3RhdHVzQ2FsbGJhY2spIHsKICAgICAgICAgIGNvbnN0IGFib3J0ZXIgPSBuZXcgQWdncmVnYXRlQWJvcnRDb250cm9sbGVyXzEuZGVmYXVsdCgpOwogICAgICAgICAgY29uc3Qgc3RhdHVzUmVwb3J0ZXIgPSBuZXcgQWdncmVnYXRlU3RhdHVzUmVwb3J0ZXJfMS5kZWZhdWx0KCk7CiAgICAgICAgICBzdGF0dXNSZXBvcnRlci5hZGRDYWxsYmFjayhzdGF0dXNDYWxsYmFjayk7CiAgICAgICAgICBjb25zdCBuZXdFbnRyeSA9IHsKICAgICAgICAgICAgYWJvcnRlciwKICAgICAgICAgICAgcHJvbWlzZTogdGhpcy5maWxsQ2FsbGJhY2soZGF0YSwgYWJvcnRlci5zaWduYWwsIChtZXNzYWdlKSA9PiB7CiAgICAgICAgICAgICAgc3RhdHVzUmVwb3J0ZXIuY2FsbGJhY2sobWVzc2FnZSk7CiAgICAgICAgICAgIH0pLAogICAgICAgICAgICBzZXR0bGVkOiBmYWxzZSwKICAgICAgICAgICAgc3RhdHVzUmVwb3J0ZXIsCiAgICAgICAgICAgIGdldCBhYm9ydGVkKCkgewogICAgICAgICAgICAgIHJldHVybiB0aGlzLmFib3J0ZXIuc2lnbmFsLmFib3J0ZWQ7CiAgICAgICAgICAgIH0KICAgICAgICAgIH07CiAgICAgICAgICBuZXdFbnRyeS5hYm9ydGVyLmFkZFNpZ25hbChzaWduYWwpOwogICAgICAgICAgbmV3RW50cnkuYWJvcnRlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcigiYWJvcnQiLCAoKSA9PiB7CiAgICAgICAgICAgIGlmICghbmV3RW50cnkuc2V0dGxlZCkgewogICAgICAgICAgICAgIHRoaXMuZXZpY3Qoa2V5LCBuZXdFbnRyeSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwogICAgICAgICAgbmV3RW50cnkucHJvbWlzZS50aGVuKCgpID0+IHsKICAgICAgICAgICAgbmV3RW50cnkuc2V0dGxlZCA9IHRydWU7CiAgICAgICAgICB9LCAoKSA9PiB7CiAgICAgICAgICAgIG5ld0VudHJ5LnNldHRsZWQgPSB0cnVlOwogICAgICAgICAgICB0aGlzLmV2aWN0KGtleSwgbmV3RW50cnkpOwogICAgICAgICAgfSkuY2F0Y2goKGUpID0+IHsKICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTsKICAgICAgICAgICAgdGhyb3cgZTsKICAgICAgICAgIH0pOwogICAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCBuZXdFbnRyeSk7CiAgICAgICAgfQogICAgICAgIHN0YXRpYyBjaGVja1NpbmdsZVByb21pc2UocHJvbWlzZSwgc2lnbmFsKSB7CiAgICAgICAgICBmdW5jdGlvbiBjaGVja0ZvclNpbmdsZUFib3J0KCkgewogICAgICAgICAgICBpZiAoc2lnbmFsICYmIHNpZ25hbC5hYm9ydGVkKSB7CiAgICAgICAgICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoImFib3J0ZWQiKSwgeyBjb2RlOiAiRVJSX0FCT1JURUQiIH0pOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKChyZXN1bHQpID0+IHsKICAgICAgICAgICAgY2hlY2tGb3JTaW5nbGVBYm9ydCgpOwogICAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgICAgfSwgKGVycm9yKSA9PiB7CiAgICAgICAgICAgIGNoZWNrRm9yU2luZ2xlQWJvcnQoKTsKICAgICAgICAgICAgdGhyb3cgZXJyb3I7CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgaGFzKGtleSkgewogICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuaGFzKGtleSk7CiAgICAgICAgfQogICAgICAgIGdldChrZXksIGRhdGEsIHNpZ25hbCwgc3RhdHVzQ2FsbGJhY2spIHsKICAgICAgICAgIGlmICghc2lnbmFsICYmIGRhdGEgaW5zdGFuY2VvZiBhYm9ydGNvbnRyb2xsZXJfcG9ueWZpbGxfMS5BYm9ydFNpZ25hbCkgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJzZWNvbmQgZ2V0IGFyZ3VtZW50IGFwcGVhcnMgdG8gYmUgYW4gQWJvcnRTaWduYWwsIHBlcmhhcHMgeW91IG1lYW50IHRvIHBhc3MgYG51bGxgIGZvciB0aGUgZmlsbCBkYXRhPyIpOwogICAgICAgICAgfQogICAgICAgICAgY29uc3QgY2FjaGVFbnRyeSA9IHRoaXMuY2FjaGUuZ2V0KGtleSk7CiAgICAgICAgICBpZiAoY2FjaGVFbnRyeSkgewogICAgICAgICAgICBpZiAoY2FjaGVFbnRyeS5hYm9ydGVkICYmICFjYWNoZUVudHJ5LnNldHRsZWQpIHsKICAgICAgICAgICAgICB0aGlzLmV2aWN0KGtleSwgY2FjaGVFbnRyeSk7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSwgZGF0YSwgc2lnbmFsLCBzdGF0dXNDYWxsYmFjayk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGNhY2hlRW50cnkuc2V0dGxlZCkgewogICAgICAgICAgICAgIHJldHVybiBjYWNoZUVudHJ5LnByb21pc2U7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY2FjaGVFbnRyeS5hYm9ydGVyLmFkZFNpZ25hbChzaWduYWwpOwogICAgICAgICAgICBjYWNoZUVudHJ5LnN0YXR1c1JlcG9ydGVyLmFkZENhbGxiYWNrKHN0YXR1c0NhbGxiYWNrKTsKICAgICAgICAgICAgcmV0dXJuIEFib3J0YWJsZVByb21pc2VDYWNoZTMuY2hlY2tTaW5nbGVQcm9taXNlKGNhY2hlRW50cnkucHJvbWlzZSwgc2lnbmFsKTsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXMuZmlsbChrZXksIGRhdGEsIHNpZ25hbCwgc3RhdHVzQ2FsbGJhY2spOwogICAgICAgICAgcmV0dXJuIEFib3J0YWJsZVByb21pc2VDYWNoZTMuY2hlY2tTaW5nbGVQcm9taXNlKHRoaXMuY2FjaGUuZ2V0KGtleSkucHJvbWlzZSwgc2lnbmFsKTsKICAgICAgICB9CiAgICAgICAgZGVsZXRlKGtleSkgewogICAgICAgICAgY29uc3QgY2FjaGVkRW50cnkgPSB0aGlzLmNhY2hlLmdldChrZXkpOwogICAgICAgICAgaWYgKGNhY2hlZEVudHJ5KSB7CiAgICAgICAgICAgIGlmICghY2FjaGVkRW50cnkuc2V0dGxlZCkgewogICAgICAgICAgICAgIGNhY2hlZEVudHJ5LmFib3J0ZXIuYWJvcnQoKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBjbGVhcigpIHsKICAgICAgICAgIGNvbnN0IGtleUl0ZXIgPSB0aGlzLmNhY2hlLmtleXMoKTsKICAgICAgICAgIGxldCBkZWxldGVDb3VudCA9IDA7CiAgICAgICAgICBmb3IgKGxldCByZXN1bHQgPSBrZXlJdGVyLm5leHQoKTsgIXJlc3VsdC5kb25lOyByZXN1bHQgPSBrZXlJdGVyLm5leHQoKSkgewogICAgICAgICAgICB0aGlzLmRlbGV0ZShyZXN1bHQudmFsdWUpOwogICAgICAgICAgICBkZWxldGVDb3VudCArPSAxOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGRlbGV0ZUNvdW50OwogICAgICAgIH0KICAgICAgfTsKICAgICAgZXhwb3J0czIuZGVmYXVsdCA9IEFib3J0YWJsZVByb21pc2VDYWNoZTM7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9ub2RlX21vZHVsZXMvYWJvcnRhYmxlLXByb21pc2UtY2FjaGUvZXNtL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfZXNtID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L25vZGVfbW9kdWxlcy9hYm9ydGFibGUtcHJvbWlzZS1jYWNoZS9lc20vaW5kZXguanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgX19pbXBvcnREZWZhdWx0ID0gZXhwb3J0czIgJiYgZXhwb3J0czIuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uKG1vZCkgewogICAgICAgIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7ICJkZWZhdWx0IjogbW9kIH07CiAgICAgIH07CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICB2YXIgQWJvcnRhYmxlUHJvbWlzZUNhY2hlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZV9BYm9ydGFibGVQcm9taXNlQ2FjaGUoKSk7CiAgICAgIGV4cG9ydHMyLmRlZmF1bHQgPSBBYm9ydGFibGVQcm9taXNlQ2FjaGVfMS5kZWZhdWx0OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvdGFiaXgvbm9kZV9tb2R1bGVzL3F1aWNrLWxydS9pbmRleC5qcwogIHZhciByZXF1aXJlX3F1aWNrX2xydSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9ub2RlX21vZHVsZXMvcXVpY2stbHJ1L2luZGV4LmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIFF1aWNrTFJVMiA9IGNsYXNzIHsKICAgICAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHsKICAgICAgICAgIGlmICghKG9wdGlvbnMubWF4U2l6ZSAmJiBvcHRpb25zLm1heFNpemUgPiAwKSkgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJgbWF4U2l6ZWAgbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gMCIpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5tYXhTaXplID0gb3B0aW9ucy5tYXhTaXplOwogICAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBNYXAoKTsKICAgICAgICAgIHRoaXMub2xkQ2FjaGUgPSBuZXcgTWFwKCk7CiAgICAgICAgICB0aGlzLl9zaXplID0gMDsKICAgICAgICB9CiAgICAgICAgX3NldChrZXksIHZhbHVlKSB7CiAgICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIHZhbHVlKTsKICAgICAgICAgIHRoaXMuX3NpemUrKzsKICAgICAgICAgIGlmICh0aGlzLl9zaXplID49IHRoaXMubWF4U2l6ZSkgewogICAgICAgICAgICB0aGlzLl9zaXplID0gMDsKICAgICAgICAgICAgdGhpcy5vbGRDYWNoZSA9IHRoaXMuY2FjaGU7CiAgICAgICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGdldChrZXkpIHsKICAgICAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlLmdldChrZXkpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHRoaXMub2xkQ2FjaGUuaGFzKGtleSkpIHsKICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLm9sZENhY2hlLmdldChrZXkpOwogICAgICAgICAgICB0aGlzLm9sZENhY2hlLmRlbGV0ZShrZXkpOwogICAgICAgICAgICB0aGlzLl9zZXQoa2V5LCB2YWx1ZSk7CiAgICAgICAgICAgIHJldHVybiB2YWx1ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgc2V0KGtleSwgdmFsdWUpIHsKICAgICAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgdmFsdWUpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhpcy5fc2V0KGtleSwgdmFsdWUpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfQogICAgICAgIGhhcyhrZXkpIHsKICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlLmhhcyhrZXkpIHx8IHRoaXMub2xkQ2FjaGUuaGFzKGtleSk7CiAgICAgICAgfQogICAgICAgIHBlZWsoa2V5KSB7CiAgICAgICAgICBpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5nZXQoa2V5KTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0aGlzLm9sZENhY2hlLmhhcyhrZXkpKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLm9sZENhY2hlLmdldChrZXkpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBkZWxldGUoa2V5KSB7CiAgICAgICAgICBjb25zdCBkZWxldGVkID0gdGhpcy5jYWNoZS5kZWxldGUoa2V5KTsKICAgICAgICAgIGlmIChkZWxldGVkKSB7CiAgICAgICAgICAgIHRoaXMuX3NpemUtLTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0aGlzLm9sZENhY2hlLmRlbGV0ZShrZXkpIHx8IGRlbGV0ZWQ7CiAgICAgICAgfQogICAgICAgIGNsZWFyKCkgewogICAgICAgICAgdGhpcy5jYWNoZS5jbGVhcigpOwogICAgICAgICAgdGhpcy5vbGRDYWNoZS5jbGVhcigpOwogICAgICAgICAgdGhpcy5fc2l6ZSA9IDA7CiAgICAgICAgfQogICAgICAgICprZXlzKCkgewogICAgICAgICAgZm9yIChjb25zdCBba2V5XSBvZiB0aGlzKSB7CiAgICAgICAgICAgIHlpZWxkIGtleTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgKnZhbHVlcygpIHsKICAgICAgICAgIGZvciAoY29uc3QgWywgdmFsdWVdIG9mIHRoaXMpIHsKICAgICAgICAgICAgeWllbGQgdmFsdWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHsKICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLmNhY2hlKSB7CiAgICAgICAgICAgIHlpZWxkIGl0ZW07CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5vbGRDYWNoZSkgewogICAgICAgICAgICBjb25zdCBba2V5XSA9IGl0ZW07CiAgICAgICAgICAgIGlmICghdGhpcy5jYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgICAgIHlpZWxkIGl0ZW07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZ2V0IHNpemUoKSB7CiAgICAgICAgICBsZXQgb2xkQ2FjaGVTaXplID0gMDsKICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMub2xkQ2FjaGUua2V5cygpKSB7CiAgICAgICAgICAgIGlmICghdGhpcy5jYWNoZS5oYXMoa2V5KSkgewogICAgICAgICAgICAgIG9sZENhY2hlU2l6ZSsrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZSArIG9sZENhY2hlU2l6ZTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IFF1aWNrTFJVMjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzCiAgdmFyIHJlcXVpcmVfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7CiAgICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsKICAgICAgICAgICJkZWZhdWx0Ijogb2JqCiAgICAgICAgfTsKICAgICAgfQogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0OwogICAgICBtb2R1bGUyLmV4cG9ydHNbImRlZmF1bHQiXSA9IG1vZHVsZTIuZXhwb3J0cywgbW9kdWxlMi5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOwogICAgfQogIH0pOwoKICAvLyAoZGlzYWJsZWQpOm5vZGVfbW9kdWxlcy9nZW5lcmljLWZpbGVoYW5kbGUvZGlzdC9sb2NhbEZpbGUKICB2YXIgcmVxdWlyZV9sb2NhbEZpbGUgPSBfX2NvbW1vbkpTKHsKICAgICIoZGlzYWJsZWQpOm5vZGVfbW9kdWxlcy9nZW5lcmljLWZpbGVoYW5kbGUvZGlzdC9sb2NhbEZpbGUiKCkgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMKICB2YXIgcmVxdWlyZV9ydW50aW1lID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICB2YXIgcnVudGltZSA9IGZ1bmN0aW9uKGV4cG9ydHMzKSB7CiAgICAgICAgInVzZSBzdHJpY3QiOwogICAgICAgIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7CiAgICAgICAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5OwogICAgICAgIHZhciB1bmRlZmluZWQyOwogICAgICAgIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gImZ1bmN0aW9uIiA/IFN5bWJvbCA6IHt9OwogICAgICAgIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgIkBAaXRlcmF0b3IiOwogICAgICAgIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8ICJAQGFzeW5jSXRlcmF0b3IiOwogICAgICAgIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgIkBAdG9TdHJpbmdUYWciOwogICAgICAgIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgewogICAgICAgICAgICB2YWx1ZSwKICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgICAgICAgICB3cml0YWJsZTogdHJ1ZQogICAgICAgICAgfSk7CiAgICAgICAgICByZXR1cm4gb2JqW2tleV07CiAgICAgICAgfQogICAgICAgIHRyeSB7CiAgICAgICAgICBkZWZpbmUoe30sICIiKTsKICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgIGRlZmluZSA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkgewogICAgICAgICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTsKICAgICAgICAgIH07CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZjIsIHRyeUxvY3NMaXN0KSB7CiAgICAgICAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjsKICAgICAgICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7CiAgICAgICAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTsKICAgICAgICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmMiwgY29udGV4dCk7CiAgICAgICAgICByZXR1cm4gZ2VuZXJhdG9yOwogICAgICAgIH0KICAgICAgICBleHBvcnRzMy53cmFwID0gd3JhcDsKICAgICAgICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICJub3JtYWwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07CiAgICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogInRocm93IiwgYXJnOiBlcnIgfTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSAic3VzcGVuZGVkU3RhcnQiOwogICAgICAgIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gInN1c3BlbmRlZFlpZWxkIjsKICAgICAgICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSAiZXhlY3V0aW5nIjsKICAgICAgICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSAiY29tcGxldGVkIjsKICAgICAgICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9OwogICAgICAgIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkgewogICAgICAgIH0KICAgICAgICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTsKICAgICAgICBkZWZpbmUoSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbigpIHsKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIH0pOwogICAgICAgIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjsKICAgICAgICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMyKFtdKSkpOwogICAgICAgIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJiBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiYgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkgewogICAgICAgICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTsKICAgICAgICB9CiAgICAgICAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpOwogICAgICAgIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlOwogICAgICAgIGRlZmluZShHcCwgImNvbnN0cnVjdG9yIiwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpOwogICAgICAgIGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgImNvbnN0cnVjdG9yIiwgR2VuZXJhdG9yRnVuY3Rpb24pOwogICAgICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCB0b1N0cmluZ1RhZ1N5bWJvbCwgIkdlbmVyYXRvckZ1bmN0aW9uIik7CiAgICAgICAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkgewogICAgICAgICAgWyJuZXh0IiwgInRocm93IiwgInJldHVybiJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7CiAgICAgICAgICAgIGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24oYXJnKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICAgIGV4cG9ydHMzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHsKICAgICAgICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gImZ1bmN0aW9uIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7CiAgICAgICAgICByZXR1cm4gY3RvciA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8IChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09ICJHZW5lcmF0b3JGdW5jdGlvbiIgOiBmYWxzZTsKICAgICAgICB9OwogICAgICAgIGV4cG9ydHMzLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHsKICAgICAgICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHsKICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlOwogICAgICAgICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgIkdlbmVyYXRvckZ1bmN0aW9uIik7CiAgICAgICAgICB9CiAgICAgICAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7CiAgICAgICAgICByZXR1cm4gZ2VuRnVuOwogICAgICAgIH07CiAgICAgICAgZXhwb3J0czMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHsKICAgICAgICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9OwogICAgICAgIH07CiAgICAgICAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7CiAgICAgICAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkgewogICAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTsKICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSAidGhyb3ciKSB7CiAgICAgICAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnOwogICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTsKICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAib2JqZWN0IiAmJiBoYXNPd24uY2FsbCh2YWx1ZSwgIl9fYXdhaXQiKSkgewogICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZTIpIHsKICAgICAgICAgICAgICAgICAgaW52b2tlKCJuZXh0IiwgdmFsdWUyLCByZXNvbHZlLCByZWplY3QpOwogICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7CiAgICAgICAgICAgICAgICAgIGludm9rZSgidGhyb3ciLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7CiAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7CiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7CiAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHsKICAgICAgICAgICAgICAgIHJldHVybiBpbnZva2UoInRocm93IiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7CiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHZhciBwcmV2aW91c1Byb21pc2U7CiAgICAgICAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7CiAgICAgICAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkgewogICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7CiAgICAgICAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7CiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9IHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLCBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTsKICAgICAgICB9CiAgICAgICAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTsKICAgICAgICBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uKCkgewogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfSk7CiAgICAgICAgZXhwb3J0czMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7CiAgICAgICAgZXhwb3J0czMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmMiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7CiAgICAgICAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkKICAgICAgICAgICAgUHJvbWlzZUltcGwgPSBQcm9taXNlOwogICAgICAgICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYyLCB0cnlMb2NzTGlzdCksIFByb21pc2VJbXBsKTsKICAgICAgICAgIHJldHVybiBleHBvcnRzMy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pID8gaXRlciA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7CiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpOwogICAgICAgICAgfSk7CiAgICAgICAgfTsKICAgICAgICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYyLCBjb250ZXh0KSB7CiAgICAgICAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0OwogICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykgewogICAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nIik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkgewogICAgICAgICAgICAgIGlmIChtZXRob2QgPT09ICJ0aHJvdyIpIHsKICAgICAgICAgICAgICAgIHRocm93IGFyZzsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDsKICAgICAgICAgICAgY29udGV4dC5hcmcgPSBhcmc7CiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7CiAgICAgICAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTsKICAgICAgICAgICAgICBpZiAoZGVsZWdhdGUpIHsKICAgICAgICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpOwogICAgICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7CiAgICAgICAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkKICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09ICJuZXh0IikgewogICAgICAgICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09ICJ0aHJvdyIpIHsKICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkgewogICAgICAgICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkOwogICAgICAgICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZzsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09ICJyZXR1cm4iKSB7CiAgICAgICAgICAgICAgICBjb250ZXh0LmFicnVwdCgicmV0dXJuIiwgY29udGV4dC5hcmcpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nOwogICAgICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmMiwgY29udGV4dCk7CiAgICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSAibm9ybWFsIikgewogICAgICAgICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBHZW5TdGF0ZUNvbXBsZXRlZCA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7CiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkgewogICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLAogICAgICAgICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmUKICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gInRocm93IikgewogICAgICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDsKICAgICAgICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gInRocm93IjsKICAgICAgICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZzsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH07CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHsKICAgICAgICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07CiAgICAgICAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQyKSB7CiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsOwogICAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09ICJ0aHJvdyIpIHsKICAgICAgICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbInJldHVybiJdKSB7CiAgICAgICAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9ICJyZXR1cm4iOwogICAgICAgICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQyOwogICAgICAgICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7CiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09ICJ0aHJvdyIpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gInRocm93IjsKICAgICAgICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2QiKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDsKICAgICAgICAgIH0KICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7CiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09ICJ0aHJvdyIpIHsKICAgICAgICAgICAgY29udGV4dC5tZXRob2QgPSAidGhyb3ciOwogICAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7CiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsOwogICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZzsKICAgICAgICAgIGlmICghaW5mbykgewogICAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9ICJ0aHJvdyI7CiAgICAgICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcigiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3QiKTsKICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7CiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGluZm8uZG9uZSkgewogICAgICAgICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTsKICAgICAgICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYzsKICAgICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSAicmV0dXJuIikgewogICAgICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gIm5leHQiOwogICAgICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkMjsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIGluZm87CiAgICAgICAgICB9CiAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDsKICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsOwogICAgICAgIH0KICAgICAgICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApOwogICAgICAgIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsICJHZW5lcmF0b3IiKTsKICAgICAgICBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbigpIHsKICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIH0pOwogICAgICAgIGRlZmluZShHcCwgInRvU3RyaW5nIiwgZnVuY3Rpb24oKSB7CiAgICAgICAgICByZXR1cm4gIltvYmplY3QgR2VuZXJhdG9yXSI7CiAgICAgICAgfSk7CiAgICAgICAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHsKICAgICAgICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07CiAgICAgICAgICBpZiAoMSBpbiBsb2NzKSB7CiAgICAgICAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICgyIGluIGxvY3MpIHsKICAgICAgICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07CiAgICAgICAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkgewogICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307CiAgICAgICAgICByZWNvcmQudHlwZSA9ICJub3JtYWwiOwogICAgICAgICAgZGVsZXRlIHJlY29yZC5hcmc7CiAgICAgICAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7CiAgICAgICAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6ICJyb290IiB9XTsKICAgICAgICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTsKICAgICAgICAgIHRoaXMucmVzZXQodHJ1ZSk7CiAgICAgICAgfQogICAgICAgIGV4cG9ydHMzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHsKICAgICAgICAgIHZhciBrZXlzMiA9IFtdOwogICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkgewogICAgICAgICAgICBrZXlzMi5wdXNoKGtleSk7CiAgICAgICAgICB9CiAgICAgICAgICBrZXlzMi5yZXZlcnNlKCk7CiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHsKICAgICAgICAgICAgd2hpbGUgKGtleXMyLmxlbmd0aCkgewogICAgICAgICAgICAgIHZhciBrZXkyID0ga2V5czIucG9wKCk7CiAgICAgICAgICAgICAgaWYgKGtleTIgaW4gb2JqZWN0KSB7CiAgICAgICAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5MjsKICAgICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlOwogICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7CiAgICAgICAgICAgIHJldHVybiBuZXh0OwogICAgICAgICAgfTsKICAgICAgICB9OwogICAgICAgIGZ1bmN0aW9uIHZhbHVlczIoaXRlcmFibGUpIHsKICAgICAgICAgIGlmIChpdGVyYWJsZSkgewogICAgICAgICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07CiAgICAgICAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkgewogICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgICAgICByZXR1cm4gaXRlcmFibGU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7CiAgICAgICAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQyKCkgewogICAgICAgICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7CiAgICAgICAgICAgICAgICAgICAgbmV4dDIudmFsdWUgPSBpdGVyYWJsZVtpXTsKICAgICAgICAgICAgICAgICAgICBuZXh0Mi5kb25lID0gZmFsc2U7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQyOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBuZXh0Mi52YWx1ZSA9IHVuZGVmaW5lZDI7CiAgICAgICAgICAgICAgICBuZXh0Mi5kb25lID0gdHJ1ZTsKICAgICAgICAgICAgICAgIHJldHVybiBuZXh0MjsKICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0OwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07CiAgICAgICAgfQogICAgICAgIGV4cG9ydHMzLnZhbHVlcyA9IHZhbHVlczI7CiAgICAgICAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHsKICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQyLCBkb25lOiB0cnVlIH07CiAgICAgICAgfQogICAgICAgIENvbnRleHQucHJvdG90eXBlID0gewogICAgICAgICAgY29uc3RydWN0b3I6IENvbnRleHQsCiAgICAgICAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkgewogICAgICAgICAgICB0aGlzLnByZXYgPSAwOwogICAgICAgICAgICB0aGlzLm5leHQgPSAwOwogICAgICAgICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkMjsKICAgICAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7CiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsOwogICAgICAgICAgICB0aGlzLm1ldGhvZCA9ICJuZXh0IjsKICAgICAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQyOwogICAgICAgICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTsKICAgICAgICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7CiAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7CiAgICAgICAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09ICJ0IiAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7CiAgICAgICAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQyOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfSwKICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlOwogICAgICAgICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdOwogICAgICAgICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uOwogICAgICAgICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSAidGhyb3ciKSB7CiAgICAgICAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHRoaXMucnZhbDsKICAgICAgICAgIH0sCiAgICAgICAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7CiAgICAgICAgICAgIGlmICh0aGlzLmRvbmUpIHsKICAgICAgICAgICAgICB0aHJvdyBleGNlcHRpb247CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzOwogICAgICAgICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHsKICAgICAgICAgICAgICByZWNvcmQudHlwZSA9ICJ0aHJvdyI7CiAgICAgICAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjsKICAgICAgICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7CiAgICAgICAgICAgICAgaWYgKGNhdWdodCkgewogICAgICAgICAgICAgICAgY29udGV4dC5tZXRob2QgPSAibmV4dCI7CiAgICAgICAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDI7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJldHVybiAhIWNhdWdodDsKICAgICAgICAgICAgfQogICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7CiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOwogICAgICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uOwogICAgICAgICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09ICJyb290IikgewogICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZSgiZW5kIik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7CiAgICAgICAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgImNhdGNoTG9jIik7CiAgICAgICAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCAiZmluYWxseUxvYyIpOwogICAgICAgICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHsKICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7CiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHsKICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkgewogICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHkiKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0sCiAgICAgICAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykgewogICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7CiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOwogICAgICAgICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGhhc093bi5jYWxsKGVudHJ5LCAiZmluYWxseUxvYyIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHsKICAgICAgICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoZmluYWxseUVudHJ5ICYmICh0eXBlID09PSAiYnJlYWsiIHx8IHR5cGUgPT09ICJjb250aW51ZSIpICYmIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykgewogICAgICAgICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307CiAgICAgICAgICAgIHJlY29yZC50eXBlID0gdHlwZTsKICAgICAgICAgICAgcmVjb3JkLmFyZyA9IGFyZzsKICAgICAgICAgICAgaWYgKGZpbmFsbHlFbnRyeSkgewogICAgICAgICAgICAgIHRoaXMubWV0aG9kID0gIm5leHQiOwogICAgICAgICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jOwogICAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7CiAgICAgICAgICB9LAogICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHsKICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSAidGhyb3ciKSB7CiAgICAgICAgICAgICAgdGhyb3cgcmVjb3JkLmFyZzsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09ICJicmVhayIgfHwgcmVjb3JkLnR5cGUgPT09ICJjb250aW51ZSIpIHsKICAgICAgICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnOwogICAgICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSAicmV0dXJuIikgewogICAgICAgICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZzsKICAgICAgICAgICAgICB0aGlzLm1ldGhvZCA9ICJyZXR1cm4iOwogICAgICAgICAgICAgIHRoaXMubmV4dCA9ICJlbmQiOwogICAgICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSAibm9ybWFsIiAmJiBhZnRlckxvYykgewogICAgICAgICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsOwogICAgICAgICAgfSwKICAgICAgICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykgewogICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7CiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOwogICAgICAgICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7CiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTsKICAgICAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpOwogICAgICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9LAogICAgICAgICAgImNhdGNoIjogZnVuY3Rpb24odHJ5TG9jKSB7CiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsKICAgICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07CiAgICAgICAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7CiAgICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjsKICAgICAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gInRocm93IikgewogICAgICAgICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZzsKICAgICAgICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3duOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdCIpOwogICAgICAgICAgfSwKICAgICAgICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7CiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUgPSB7CiAgICAgICAgICAgICAgaXRlcmF0b3I6IHZhbHVlczIoaXRlcmFibGUpLAogICAgICAgICAgICAgIHJlc3VsdE5hbWUsCiAgICAgICAgICAgICAgbmV4dExvYwogICAgICAgICAgICB9OwogICAgICAgICAgICBpZiAodGhpcy5tZXRob2QgPT09ICJuZXh0IikgewogICAgICAgICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkMjsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDsKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICAgIHJldHVybiBleHBvcnRzMzsKICAgICAgfSh0eXBlb2YgbW9kdWxlMiA9PT0gIm9iamVjdCIgPyBtb2R1bGUyLmV4cG9ydHMgOiB7fSk7CiAgICAgIHRyeSB7CiAgICAgICAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTsKICAgICAgfSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHsKICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICJvYmplY3QiKSB7CiAgICAgICAgICBnbG9iYWxUaGlzLnJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIEZ1bmN0aW9uKCJyIiwgInJlZ2VuZXJhdG9yUnVudGltZSA9IHIiKShydW50aW1lKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfcmVnZW5lcmF0b3IgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgbW9kdWxlMi5leHBvcnRzID0gcmVxdWlyZV9ydW50aW1lKCk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMKICB2YXIgcmVxdWlyZV9hc3luY1RvR2VuZXJhdG9yID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsKICAgICAgICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7CiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgIHJlamVjdChlcnJvcik7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGlmIChpbmZvLmRvbmUpIHsKICAgICAgICAgIHJlc29sdmUodmFsdWUpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgewogICAgICAgICAgdmFyIHNlbGYyID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsKICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHsKICAgICAgICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYyLCBhcmdzKTsKICAgICAgICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHsKICAgICAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csICJuZXh0IiwgdmFsdWUpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHsKICAgICAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csICJ0aHJvdyIsIGVycik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgX25leHQodm9pZCAwKTsKICAgICAgICAgIH0pOwogICAgICAgIH07CiAgICAgIH0KICAgICAgbW9kdWxlMi5leHBvcnRzID0gX2FzeW5jVG9HZW5lcmF0b3I7CiAgICAgIG1vZHVsZTIuZXhwb3J0c1siZGVmYXVsdCJdID0gbW9kdWxlMi5leHBvcnRzLCBtb2R1bGUyLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzCiAgdmFyIHJlcXVpcmVfY2xhc3NDYWxsQ2hlY2sgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7CiAgICAgICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpOwogICAgICAgIH0KICAgICAgfQogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBfY2xhc3NDYWxsQ2hlY2s7CiAgICAgIG1vZHVsZTIuZXhwb3J0c1siZGVmYXVsdCJdID0gbW9kdWxlMi5leHBvcnRzLCBtb2R1bGUyLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzCiAgdmFyIHJlcXVpcmVfY3JlYXRlQ2xhc3MgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7CiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsKICAgICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsKICAgICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsKICAgICAgICAgIGlmICgidmFsdWUiIGluIGRlc2NyaXB0b3IpCiAgICAgICAgICAgIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOwogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7CiAgICAgICAgaWYgKHByb3RvUHJvcHMpCiAgICAgICAgICBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOwogICAgICAgIGlmIChzdGF0aWNQcm9wcykKICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7CiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yOwogICAgICB9CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IF9jcmVhdGVDbGFzczsKICAgICAgbW9kdWxlMi5leHBvcnRzWyJkZWZhdWx0Il0gPSBtb2R1bGUyLmV4cG9ydHMsIG1vZHVsZTIuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMKICB2YXIgcmVxdWlyZV9kZWZpbmVQcm9wZXJ0eSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsKICAgICAgICBpZiAoa2V5IGluIG9iaikgewogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7CiAgICAgICAgICAgIHZhbHVlLAogICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG9iajsKICAgICAgfQogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHk7CiAgICAgIG1vZHVsZTIuZXhwb3J0c1siZGVmYXVsdCJdID0gbW9kdWxlMi5leHBvcnRzLCBtb2R1bGUyLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7CiAgICB9CiAgfSk7CgogIC8vIChkaXNhYmxlZCk6bm9kZV9tb2R1bGVzL2ZpbGUtdXJpLXRvLXBhdGgvZGlzdC9zcmMvaW5kZXguanMKICB2YXIgcmVxdWlyZV9zcmMgPSBfX2NvbW1vbkpTKHsKICAgICIoZGlzYWJsZWQpOm5vZGVfbW9kdWxlcy9maWxlLXVyaS10by1wYXRoL2Rpc3Qvc3JjL2luZGV4LmpzIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvZ2VuZXJpYy1maWxlaGFuZGxlL2Rpc3QvcmVtb3RlRmlsZS5qcwogIHZhciByZXF1aXJlX3JlbW90ZUZpbGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvZ2VuZXJpYy1maWxlaGFuZGxlL2Rpc3QvcmVtb3RlRmlsZS5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoKTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsKICAgICAgICB2YWx1ZTogdHJ1ZQogICAgICB9KTsKICAgICAgZXhwb3J0czIuZGVmYXVsdCA9IHZvaWQgMDsKICAgICAgdmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9yZWdlbmVyYXRvcigpKTsKICAgICAgdmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9hc3luY1RvR2VuZXJhdG9yKCkpOwogICAgICB2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9jbGFzc0NhbGxDaGVjaygpKTsKICAgICAgdmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfY3JlYXRlQ2xhc3MoKSk7CiAgICAgIHZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2RlZmluZVByb3BlcnR5KCkpOwogICAgICB2YXIgX2ZpbGVVcmlUb1BhdGggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfc3JjKCkpOwogICAgICB2YXIgXyA9IHJlcXVpcmVfZGlzdCgpOwogICAgICBmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsKICAgICAgICB2YXIga2V5czIgPSBPYmplY3Qua2V5cyhvYmplY3QpOwogICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7CiAgICAgICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsKICAgICAgICAgIGlmIChlbnVtZXJhYmxlT25seSkKICAgICAgICAgICAgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uKHN5bSkgewogICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOwogICAgICAgICAgICB9KTsKICAgICAgICAgIGtleXMyLnB1c2guYXBwbHkoa2V5czIsIHN5bWJvbHMpOwogICAgICAgIH0KICAgICAgICByZXR1cm4ga2V5czI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsKICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgewogICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307CiAgICAgICAgICBpZiAoaSAlIDIpIHsKICAgICAgICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHsKICAgICAgICAgICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsKICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7CiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gdGFyZ2V0OwogICAgICB9CiAgICAgIHZhciBteUdsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09ICJ1bmRlZmluZWQiID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT09ICJ1bmRlZmluZWQiID8gc2VsZiA6IHsKICAgICAgICBmZXRjaDogdm9pZCAwCiAgICAgIH07CiAgICAgIHZhciBSZW1vdGVGaWxlMiA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHsKICAgICAgICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShSZW1vdGVGaWxlMywgW3sKICAgICAgICAgIGtleTogImdldEJ1ZmZlckZyb21SZXNwb25zZSIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciBfZ2V0QnVmZmVyRnJvbVJlc3BvbnNlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KSgvKiBAX19QVVJFX18gKi8gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKHJlc3BvbnNlKSB7CiAgICAgICAgICAgICAgdmFyIHJlc3A7CiAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHsKICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHsKICAgICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0eXBlb2YgcmVzcG9uc2UuYnVmZmVyID09PSAiZnVuY3Rpb24iKSkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCJyZXR1cm4iLCByZXNwb25zZS5idWZmZXIoKSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OgogICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHlwZW9mIHJlc3BvbnNlLmFycmF5QnVmZmVyID09PSAiZnVuY3Rpb24iKSkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDc6CiAgICAgICAgICAgICAgICAgICAgICByZXNwID0gX2NvbnRleHQuc2VudDsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoInJldHVybiIsIGltcG9ydF9idWZmZXIuQnVmZmVyLmZyb20ocmVzcCkpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6CiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJpbnZhbGlkIEhUVFAgcmVzcG9uc2Ugb2JqZWN0LCBoYXMgbm8gYnVmZmVyIG1ldGhvZCwgYW5kIG5vIGFycmF5QnVmZmVyIG1ldGhvZCIpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6CiAgICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9LCBfY2FsbGVlKTsKICAgICAgICAgICAgfSkpOwogICAgICAgICAgICBmdW5jdGlvbiBnZXRCdWZmZXJGcm9tUmVzcG9uc2UoX3gpIHsKICAgICAgICAgICAgICByZXR1cm4gX2dldEJ1ZmZlckZyb21SZXNwb25zZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBnZXRCdWZmZXJGcm9tUmVzcG9uc2U7CiAgICAgICAgICB9KCkKICAgICAgICB9XSk7CiAgICAgICAgZnVuY3Rpb24gUmVtb3RlRmlsZTMoc291cmNlKSB7CiAgICAgICAgICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDoge307CiAgICAgICAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBSZW1vdGVGaWxlMyk7CiAgICAgICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCAidXJsIiwgdm9pZCAwKTsKICAgICAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsICJfc3RhdCIsIHZvaWQgMCk7CiAgICAgICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCAiZmV0Y2hJbXBsZW1lbnRhdGlvbiIsIHZvaWQgMCk7CiAgICAgICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCAiYmFzZU92ZXJyaWRlcyIsIHt9KTsKICAgICAgICAgIHRoaXMudXJsID0gc291cmNlOwogICAgICAgICAgaWYgKHNvdXJjZS5zdGFydHNXaXRoKCJmaWxlOi8vIikpIHsKICAgICAgICAgICAgdmFyIHBhdGggPSAoMCwgX2ZpbGVVcmlUb1BhdGguZGVmYXVsdCkoc291cmNlKTsKICAgICAgICAgICAgaWYgKCFwYXRoKSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiaW52YWxpZCBmaWxlIHVybCIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBsb2NhbEZpbGUgPSBuZXcgXy5Mb2NhbEZpbGUocGF0aCk7CiAgICAgICAgICAgIHRoaXMucmVhZCA9IGxvY2FsRmlsZS5yZWFkLmJpbmQobG9jYWxGaWxlKTsKICAgICAgICAgICAgdGhpcy5yZWFkRmlsZSA9IGxvY2FsRmlsZS5yZWFkRmlsZS5iaW5kKGxvY2FsRmlsZSk7CiAgICAgICAgICAgIHRoaXMuc3RhdCA9IGxvY2FsRmlsZS5zdGF0LmJpbmQobG9jYWxGaWxlKTsKICAgICAgICAgICAgdGhpcy5mZXRjaEltcGxlbWVudGF0aW9uID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBmZXRjaCA9IG9wdHMuZmV0Y2ggfHwgbXlHbG9iYWwuZmV0Y2ggJiYgbXlHbG9iYWwuZmV0Y2guYmluZChteUdsb2JhbCk7CiAgICAgICAgICBpZiAoIWZldGNoKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIm5vIGZldGNoIGZ1bmN0aW9uIHN1cHBsaWVkLCBhbmQgbm9uZSBmb3VuZCBpbiBnbG9iYWwgZW52aXJvbm1lbnQiKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChvcHRzLm92ZXJyaWRlcykgewogICAgICAgICAgICB0aGlzLmJhc2VPdmVycmlkZXMgPSBvcHRzLm92ZXJyaWRlczsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXMuZmV0Y2hJbXBsZW1lbnRhdGlvbiA9IGZldGNoOwogICAgICAgIH0KICAgICAgICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShSZW1vdGVGaWxlMywgW3sKICAgICAgICAgIGtleTogImZldGNoIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgdmFyIF9mZXRjaCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoaW5wdXQsIGluaXQyKSB7CiAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlOwogICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHsKICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkgewogICAgICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMDsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMzsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoSW1wbGVtZW50YXRpb24oaW5wdXQsIGluaXQyKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0Mi5zZW50OwogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNjsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIGNhc2UgNjoKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gNjsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0MlsiY2F0Y2giXSgwKTsKICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9jb250ZXh0Mi50MC5tZXNzYWdlID09PSAiRmFpbGVkIHRvIGZldGNoIikpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNTsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oImdlbmVyaWMtZmlsZWhhbmRsZTogcmVmZXRjaGluZyAiLmNvbmNhdChpbnB1dCwgIiB0byBhdHRlbXB0IHRvIHdvcmsgYXJvdW5kIGNocm9tZSBDT1JTIGhlYWRlciBjYWNoaW5nIGJ1ZyIpKTsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTI7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEltcGxlbWVudGF0aW9uKGlucHV0LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGluaXQyKSwge30sIHsKICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6ICJyZWxvYWQiCiAgICAgICAgICAgICAgICAgICAgICB9KSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjoKICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2NvbnRleHQyLnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE2OwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNToKICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0Mi50MDsKICAgICAgICAgICAgICAgICAgICBjYXNlIDE2OgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoInJldHVybiIsIHJlc3BvbnNlKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OgogICAgICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzLCBbWzAsIDZdXSk7CiAgICAgICAgICAgIH0pKTsKICAgICAgICAgICAgZnVuY3Rpb24gZmV0Y2goX3gyLCBfeDMpIHsKICAgICAgICAgICAgICByZXR1cm4gX2ZldGNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGZldGNoOwogICAgICAgICAgfSgpCiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAicmVhZCIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciBfcmVhZCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoYnVmZmVyKSB7CiAgICAgICAgICAgICAgdmFyIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgb3B0cywgX29wdHMkaGVhZGVycywgaGVhZGVycywgc2lnbmFsLCBfb3B0cyRvdmVycmlkZXMsIG92ZXJyaWRlcywgYXJncywgcmVzcG9uc2UsIHJlc3BvbnNlRGF0YSwgYnl0ZXNDb3BpZWQsIHJlcywgc2l6ZU1hdGNoLCBfYXJnczMgPSBhcmd1bWVudHM7CiAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0MykgewogICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gX2FyZ3MzLmxlbmd0aCA+IDEgJiYgX2FyZ3MzWzFdICE9PSB2b2lkIDAgPyBfYXJnczNbMV0gOiAwOwogICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gX2FyZ3MzLmxlbmd0aCA+IDIgPyBfYXJnczNbMl0gOiB2b2lkIDA7CiAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IF9hcmdzMy5sZW5ndGggPiAzICYmIF9hcmdzM1szXSAhPT0gdm9pZCAwID8gX2FyZ3MzWzNdIDogMDsKICAgICAgICAgICAgICAgICAgICAgIG9wdHMgPSBfYXJnczMubGVuZ3RoID4gNCAmJiBfYXJnczNbNF0gIT09IHZvaWQgMCA/IF9hcmdzM1s0XSA6IHt9OwogICAgICAgICAgICAgICAgICAgICAgX29wdHMkaGVhZGVycyA9IG9wdHMuaGVhZGVycywgaGVhZGVycyA9IF9vcHRzJGhlYWRlcnMgPT09IHZvaWQgMCA/IHt9IDogX29wdHMkaGVhZGVycywgc2lnbmFsID0gb3B0cy5zaWduYWwsIF9vcHRzJG92ZXJyaWRlcyA9IG9wdHMub3ZlcnJpZGVzLCBvdmVycmlkZXMgPSBfb3B0cyRvdmVycmlkZXMgPT09IHZvaWQgMCA/IHt9IDogX29wdHMkb3ZlcnJpZGVzOwogICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA8IEluZmluaXR5KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnMucmFuZ2UgPSAiYnl0ZXM9Ii5jb25jYXQocG9zaXRpb24sICItIikuY29uY2F0KHBvc2l0aW9uICsgbGVuZ3RoKTsKICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID09PSBJbmZpbml0eSAmJiBwb3NpdGlvbiAhPT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLnJhbmdlID0gImJ5dGVzPSIuY29uY2F0KHBvc2l0aW9uLCAiLSIpOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgYXJncyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLmJhc2VPdmVycmlkZXMpLCBvdmVycmlkZXMpLCB7fSwgewogICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaGVhZGVycyksIG92ZXJyaWRlcy5oZWFkZXJzKSwgdGhpcy5iYXNlT3ZlcnJpZGVzLmhlYWRlcnMpLAogICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICJHRVQiLAogICAgICAgICAgICAgICAgICAgICAgICByZWRpcmVjdDogImZvbGxvdyIsCiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6ICJjb3JzIiwKICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsCiAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gOTsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKHRoaXMudXJsLCBhcmdzKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDk6CiAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0My5zZW50OwogICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTI7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJIVFRQICIuY29uY2F0KHJlc3BvbnNlLnN0YXR1cywgIiAiKS5jb25jYXQocmVzcG9uc2Uuc3RhdHVzVGV4dCkpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZXNwb25zZS5zdGF0dXMgPT09IDIwMCAmJiBwb3NpdGlvbiA9PT0gMCB8fCByZXNwb25zZS5zdGF0dXMgPT09IDIwNikpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAyMTsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE1OwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyRnJvbVJlc3BvbnNlKHJlc3BvbnNlKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OgogICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VEYXRhID0gX2NvbnRleHQzLnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgICBieXRlc0NvcGllZCA9IHJlc3BvbnNlRGF0YS5jb3B5KGJ1ZmZlciwgb2Zmc2V0LCAwLCBNYXRoLm1pbihsZW5ndGgsIHJlc3BvbnNlRGF0YS5sZW5ndGgpKTsKICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCJjb250ZW50LXJhbmdlIik7CiAgICAgICAgICAgICAgICAgICAgICBzaXplTWF0Y2ggPSAvXC8oXGQrKSQvLmV4ZWMocmVzIHx8ICIiKTsKICAgICAgICAgICAgICAgICAgICAgIGlmIChzaXplTWF0Y2ggJiYgc2l6ZU1hdGNoWzFdKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXQgPSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogcGFyc2VJbnQoc2l6ZU1hdGNoWzFdLCAxMCkKICAgICAgICAgICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KCJyZXR1cm4iLCB7CiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzUmVhZDogYnl0ZXNDb3BpZWQsCiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcgogICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMToKICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDIzOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiJHt0aGlzLnVybH0gZmV0Y2ggcmV0dXJuZWQgc3RhdHVzIDIwMCwgZXhwZWN0ZWQgMjA2Iik7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzoKICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiSFRUUCAiLmNvbmNhdChyZXNwb25zZS5zdGF0dXMsICIgZmV0Y2hpbmcgIikuY29uY2F0KHRoaXMudXJsKSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAyNDoKICAgICAgICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9LCBfY2FsbGVlMywgdGhpcyk7CiAgICAgICAgICAgIH0pKTsKICAgICAgICAgICAgZnVuY3Rpb24gcmVhZChfeDQpIHsKICAgICAgICAgICAgICByZXR1cm4gX3JlYWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gcmVhZDsKICAgICAgICAgIH0oKQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogInJlYWRGaWxlIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgdmFyIF9yZWFkRmlsZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoKSB7CiAgICAgICAgICAgICAgdmFyIG9wdGlvbnMsIGVuY29kaW5nLCBvcHRzLCBfb3B0cywgX29wdHMkaGVhZGVyczIsIGhlYWRlcnMsIHNpZ25hbCwgX29wdHMkb3ZlcnJpZGVzMiwgb3ZlcnJpZGVzLCBhcmdzLCByZXNwb25zZSwgX2FyZ3M0ID0gYXJndW1lbnRzOwogICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHsKICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkgewogICAgICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBfYXJnczQubGVuZ3RoID4gMCAmJiBfYXJnczRbMF0gIT09IHZvaWQgMCA/IF9hcmdzNFswXSA6IHt9OwogICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAic3RyaW5nIikgewogICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZyA9IG9wdGlvbnM7CiAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMgPSB7fTsKICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZzsKICAgICAgICAgICAgICAgICAgICAgICAgb3B0cyA9IG9wdGlvbnM7CiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRzLmVuY29kaW5nOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgX29wdHMgPSBvcHRzLCBfb3B0cyRoZWFkZXJzMiA9IF9vcHRzLmhlYWRlcnMsIGhlYWRlcnMgPSBfb3B0cyRoZWFkZXJzMiA9PT0gdm9pZCAwID8ge30gOiBfb3B0cyRoZWFkZXJzMiwgc2lnbmFsID0gX29wdHMuc2lnbmFsLCBfb3B0cyRvdmVycmlkZXMyID0gX29wdHMub3ZlcnJpZGVzLCBvdmVycmlkZXMgPSBfb3B0cyRvdmVycmlkZXMyID09PSB2b2lkIDAgPyB7fSA6IF9vcHRzJG92ZXJyaWRlczI7CiAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHsKICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVycywKICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAiR0VUIiwKICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3Q6ICJmb2xsb3ciLAogICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiAiY29ycyIsCiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbAogICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5iYXNlT3ZlcnJpZGVzKSwgb3ZlcnJpZGVzKTsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNjsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKHRoaXMudXJsLCBhcmdzKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDY6CiAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0NC5zZW50OwogICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gOTsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImdlbmVyaWMtZmlsZWhhbmRsZSBmYWlsZWQgdG8gZmV0Y2giKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDk6CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxMTsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBFcnJvcigiSFRUUCAiLmNvbmNhdChyZXNwb25zZS5zdGF0dXMsICIgZmV0Y2hpbmcgIikuY29uY2F0KHRoaXMudXJsKSksIHsKICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMKICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIShlbmNvZGluZyA9PT0gInV0ZjgiKSkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDEzOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KCJyZXR1cm4iLCByZXNwb25zZS50ZXh0KCkpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVuY29kaW5nKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTU7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJ1bnN1cHBvcnRlZCBlbmNvZGluZzogIi5jb25jYXQoZW5jb2RpbmcpKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoInJldHVybiIsIHRoaXMuZ2V0QnVmZmVyRnJvbVJlc3BvbnNlKHJlc3BvbnNlKSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNjoKICAgICAgICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9LCBfY2FsbGVlNCwgdGhpcyk7CiAgICAgICAgICAgIH0pKTsKICAgICAgICAgICAgZnVuY3Rpb24gcmVhZEZpbGUoKSB7CiAgICAgICAgICAgICAgcmV0dXJuIF9yZWFkRmlsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiByZWFkRmlsZTsKICAgICAgICAgIH0oKQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogInN0YXQiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgX3N0YXQgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKC8qIEBfX1BVUkVfXyAqLyBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KCkgewogICAgICAgICAgICAgIHZhciBidWY7CiAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkgewogICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA2OwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGJ1ZiA9IGltcG9ydF9idWZmZXIuQnVmZmVyLmFsbG9jVW5zYWZlKDEwKTsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNDsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWQoYnVmLCAwLCAxMCwgMCk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OgogICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA2OwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigidW5hYmxlIHRvIGRldGVybWluZSBzaXplIG9mIGZpbGUgYXQgIi5jb25jYXQodGhpcy51cmwpKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDY6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdCgicmV0dXJuIiwgdGhpcy5fc3RhdCk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OgogICAgICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0sIF9jYWxsZWU1LCB0aGlzKTsKICAgICAgICAgICAgfSkpOwogICAgICAgICAgICBmdW5jdGlvbiBzdGF0KCkgewogICAgICAgICAgICAgIHJldHVybiBfc3RhdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBzdGF0OwogICAgICAgICAgfSgpCiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiY2xvc2UiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgX2Nsb3NlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KSgvKiBAX19QVVJFX18gKi8gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlNigpIHsKICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7CiAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHsKICAgICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdCgicmV0dXJuIik7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0sIF9jYWxsZWU2KTsKICAgICAgICAgICAgfSkpOwogICAgICAgICAgICBmdW5jdGlvbiBjbG9zZSgpIHsKICAgICAgICAgICAgICByZXR1cm4gX2Nsb3NlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGNsb3NlOwogICAgICAgICAgfSgpCiAgICAgICAgfV0pOwogICAgICAgIHJldHVybiBSZW1vdGVGaWxlMzsKICAgICAgfSgpOwogICAgICBleHBvcnRzMi5kZWZhdWx0ID0gUmVtb3RlRmlsZTI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9nZW5lcmljLWZpbGVoYW5kbGUvZGlzdC9ibG9iRmlsZS5qcwogIHZhciByZXF1aXJlX2Jsb2JGaWxlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2dlbmVyaWMtZmlsZWhhbmRsZS9kaXN0L2Jsb2JGaWxlLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlX2ludGVyb3BSZXF1aXJlRGVmYXVsdCgpOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgewogICAgICAgIHZhbHVlOiB0cnVlCiAgICAgIH0pOwogICAgICBleHBvcnRzMi5kZWZhdWx0ID0gdm9pZCAwOwogICAgICB2YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3JlZ2VuZXJhdG9yKCkpOwogICAgICB2YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2FzeW5jVG9HZW5lcmF0b3IoKSk7CiAgICAgIHZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2NsYXNzQ2FsbENoZWNrKCkpOwogICAgICB2YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9jcmVhdGVDbGFzcygpKTsKICAgICAgdmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfZGVmaW5lUHJvcGVydHkoKSk7CiAgICAgIGZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7CiAgICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpOwogICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHsKICAgICAgICAgIGZpbGVSZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICBmaWxlUmVhZGVyLmFib3J0KCk7CiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoInByb2JsZW0gcmVhZGluZyBibG9iIikpOwogICAgICAgICAgfTsKICAgICAgICAgIGZpbGVSZWFkZXIub25hYm9ydCA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCJibG9iIHJlYWRpbmcgd2FzIGFib3J0ZWQiKSk7CiAgICAgICAgICB9OwogICAgICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgaWYgKGZpbGVSZWFkZXIucmVzdWx0ICYmIHR5cGVvZiBmaWxlUmVhZGVyLnJlc3VsdCAhPT0gInN0cmluZyIpIHsKICAgICAgICAgICAgICByZXNvbHZlKGZpbGVSZWFkZXIucmVzdWx0KTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCJ1bmtub3duIGVycm9yIHJlYWRpbmcgYmxvYiIpKTsKICAgICAgICAgICAgfQogICAgICAgICAgfTsKICAgICAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7CiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikgewogICAgICAgIHZhciBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTsKICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7CiAgICAgICAgICBmaWxlUmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgZmlsZVJlYWRlci5hYm9ydCgpOwogICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCJwcm9ibGVtIHJlYWRpbmcgYmxvYiIpKTsKICAgICAgICAgIH07CiAgICAgICAgICBmaWxlUmVhZGVyLm9uYWJvcnQgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcigiYmxvYiByZWFkaW5nIHdhcyBhYm9ydGVkIikpOwogICAgICAgICAgfTsKICAgICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIGlmIChmaWxlUmVhZGVyLnJlc3VsdCAmJiB0eXBlb2YgZmlsZVJlYWRlci5yZXN1bHQgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgICAgcmVzb2x2ZShmaWxlUmVhZGVyLnJlc3VsdCk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcigidW5rbm93biBlcnJvciByZWFkaW5nIGJsb2IiKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH07CiAgICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc1RleHQoYmxvYik7CiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgdmFyIEJsb2JGaWxlID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkgewogICAgICAgIGZ1bmN0aW9uIEJsb2JGaWxlMihibG9iKSB7CiAgICAgICAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBCbG9iRmlsZTIpOwogICAgICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgImJsb2IiLCB2b2lkIDApOwogICAgICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgInNpemUiLCB2b2lkIDApOwogICAgICAgICAgdGhpcy5ibG9iID0gYmxvYjsKICAgICAgICAgIHRoaXMuc2l6ZSA9IGJsb2Iuc2l6ZTsKICAgICAgICB9CiAgICAgICAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoQmxvYkZpbGUyLCBbewogICAgICAgICAga2V5OiAicmVhZCIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciBfcmVhZCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShidWZmZXIpIHsKICAgICAgICAgICAgICB2YXIgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBzdGFydCwgZW5kLCByZXN1bHQsIHJlc3VsdEJ1ZmZlciwgYnl0ZXNDb3BpZWQsIF9hcmdzID0gYXJndW1lbnRzOwogICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7CiAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gX2FyZ3MubGVuZ3RoID4gMSAmJiBfYXJnc1sxXSAhPT0gdm9pZCAwID8gX2FyZ3NbMV0gOiAwOwogICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gX2FyZ3MubGVuZ3RoID4gMiA/IF9hcmdzWzJdIDogdm9pZCAwOwogICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBfYXJncy5sZW5ndGggPiAzICYmIF9hcmdzWzNdICE9PSB2b2lkIDAgPyBfYXJnc1szXSA6IDA7CiAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1OwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoInJldHVybiIsIHsKICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNSZWFkOiAwLAogICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIKICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgIGNhc2UgNToKICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gcG9zaXRpb247CiAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBzdGFydCArIGxlbmd0aDsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5OwogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcih0aGlzLmJsb2Iuc2xpY2Uoc3RhcnQsIGVuZCkpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgOToKICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0LnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgICByZXN1bHRCdWZmZXIgPSBpbXBvcnRfYnVmZmVyLkJ1ZmZlci5mcm9tKHJlc3VsdCk7CiAgICAgICAgICAgICAgICAgICAgICBieXRlc0NvcGllZCA9IHJlc3VsdEJ1ZmZlci5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoInJldHVybiIsIHsKICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNSZWFkOiBieXRlc0NvcGllZCwKICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiByZXN1bHRCdWZmZXIKICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6CiAgICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTsKICAgICAgICAgICAgfSkpOwogICAgICAgICAgICBmdW5jdGlvbiByZWFkKF94KSB7CiAgICAgICAgICAgICAgcmV0dXJuIF9yZWFkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHJlYWQ7CiAgICAgICAgICB9KCkKICAgICAgICB9LCB7CiAgICAgICAgICBrZXk6ICJyZWFkRmlsZSIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciBfcmVhZEZpbGUgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKC8qIEBfX1BVUkVfXyAqLyBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKG9wdGlvbnMpIHsKICAgICAgICAgICAgICB2YXIgZW5jb2RpbmcsIHJlc3VsdDsKICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7CiAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHsKICAgICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nID0gb3B0aW9uczsKICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nID0gb3B0aW9ucyAmJiBvcHRpb25zLmVuY29kaW5nOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZW5jb2RpbmcgPT09ICJ1dGY4IikpIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KCJyZXR1cm4iLCByZWFkQmxvYkFzVGV4dCh0aGlzLmJsb2IpKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVuY29kaW5nKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNTsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoInVuc3VwcG9ydGVkIGVuY29kaW5nOiAiLmNvbmNhdChlbmNvZGluZykpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgNToKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNzsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkQmxvYkFzQXJyYXlCdWZmZXIodGhpcy5ibG9iKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDc6CiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDIuc2VudDsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KCJyZXR1cm4iLCBpbXBvcnRfYnVmZmVyLkJ1ZmZlci5mcm9tKHJlc3VsdCkpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgOToKICAgICAgICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7CiAgICAgICAgICAgIH0pKTsKICAgICAgICAgICAgZnVuY3Rpb24gcmVhZEZpbGUoX3gyKSB7CiAgICAgICAgICAgICAgcmV0dXJuIF9yZWFkRmlsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiByZWFkRmlsZTsKICAgICAgICAgIH0oKQogICAgICAgIH0sIHsKICAgICAgICAgIGtleTogInN0YXQiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgX3N0YXQgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKC8qIEBfX1BVUkVfXyAqLyBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKCkgewogICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHsKICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkgewogICAgICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KCJyZXR1cm4iLCB7CiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IHRoaXMuc2l6ZQogICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTsKICAgICAgICAgICAgfSkpOwogICAgICAgICAgICBmdW5jdGlvbiBzdGF0KCkgewogICAgICAgICAgICAgIHJldHVybiBfc3RhdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBzdGF0OwogICAgICAgICAgfSgpCiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiY2xvc2UiLAogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgX2Nsb3NlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KSgvKiBAX19QVVJFX18gKi8gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlNCgpIHsKICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7CiAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHsKICAgICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdCgicmV0dXJuIik7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0sIF9jYWxsZWU0KTsKICAgICAgICAgICAgfSkpOwogICAgICAgICAgICBmdW5jdGlvbiBjbG9zZSgpIHsKICAgICAgICAgICAgICByZXR1cm4gX2Nsb3NlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGNsb3NlOwogICAgICAgICAgfSgpCiAgICAgICAgfV0pOwogICAgICAgIHJldHVybiBCbG9iRmlsZTI7CiAgICAgIH0oKTsKICAgICAgZXhwb3J0czIuZGVmYXVsdCA9IEJsb2JGaWxlOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvZ2VuZXJpYy1maWxlaGFuZGxlL2Rpc3QvZmlsZWhhbmRsZS5qcwogIHZhciByZXF1aXJlX2ZpbGVoYW5kbGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvZ2VuZXJpYy1maWxlaGFuZGxlL2Rpc3QvZmlsZWhhbmRsZS5qcyIoKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvZ2VuZXJpYy1maWxlaGFuZGxlL2Rpc3QvaW5kZXguanMKICB2YXIgcmVxdWlyZV9kaXN0ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL2dlbmVyaWMtZmlsZWhhbmRsZS9kaXN0L2luZGV4LmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlX2ludGVyb3BSZXF1aXJlRGVmYXVsdCgpOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgewogICAgICAgIHZhbHVlOiB0cnVlCiAgICAgIH0pOwogICAgICB2YXIgX2V4cG9ydE5hbWVzID0gewogICAgICAgIG9wZW46IHRydWUsCiAgICAgICAgZnJvbVVybDogdHJ1ZSwKICAgICAgICBMb2NhbEZpbGU6IHRydWUsCiAgICAgICAgUmVtb3RlRmlsZTogdHJ1ZSwKICAgICAgICBCbG9iRmlsZTogdHJ1ZQogICAgICB9OwogICAgICBleHBvcnRzMi5vcGVuID0gb3BlbjsKICAgICAgZXhwb3J0czIuZnJvbVVybCA9IGZyb21Vcmw7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIkxvY2FsRmlsZSIsIHsKICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgcmV0dXJuIF9sb2NhbEZpbGUuZGVmYXVsdDsKICAgICAgICB9CiAgICAgIH0pOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJSZW1vdGVGaWxlIiwgewogICAgICAgIGVudW1lcmFibGU6IHRydWUsCiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgICAgICByZXR1cm4gX3JlbW90ZUZpbGUuZGVmYXVsdDsKICAgICAgICB9CiAgICAgIH0pOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJCbG9iRmlsZSIsIHsKICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICAgICAgcmV0dXJuIF9ibG9iRmlsZS5kZWZhdWx0OwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIHZhciBfbG9jYWxGaWxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2xvY2FsRmlsZSgpKTsKICAgICAgdmFyIF9yZW1vdGVGaWxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3JlbW90ZUZpbGUoKSk7CiAgICAgIHZhciBfYmxvYkZpbGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfYmxvYkZpbGUoKSk7CiAgICAgIHZhciBfZmlsZWhhbmRsZSA9IHJlcXVpcmVfZmlsZWhhbmRsZSgpOwogICAgICBPYmplY3Qua2V5cyhfZmlsZWhhbmRsZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHsKICAgICAgICBpZiAoa2V5ID09PSAiZGVmYXVsdCIgfHwga2V5ID09PSAiX19lc01vZHVsZSIpCiAgICAgICAgICByZXR1cm47CiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpCiAgICAgICAgICByZXR1cm47CiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCBrZXksIHsKICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsCiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgICAgICAgcmV0dXJuIF9maWxlaGFuZGxlW2tleV07CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgIH0pOwogICAgICBmdW5jdGlvbiBmcm9tVXJsKHNvdXJjZSkgewogICAgICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiB7fTsKICAgICAgICByZXR1cm4gbmV3IF9yZW1vdGVGaWxlLmRlZmF1bHQoc291cmNlLCBvcHRzKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBvcGVuKG1heWJlVXJsLCBtYXliZVBhdGgsIG1heWJlRmlsZWhhbmRsZSkgewogICAgICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbM10gOiB7fTsKICAgICAgICBpZiAobWF5YmVGaWxlaGFuZGxlICE9PSB2b2lkIDApIHsKICAgICAgICAgIHJldHVybiBtYXliZUZpbGVoYW5kbGU7CiAgICAgICAgfQogICAgICAgIGlmIChtYXliZVVybCAhPT0gdm9pZCAwKSB7CiAgICAgICAgICByZXR1cm4gZnJvbVVybChtYXliZVVybCwgb3B0cyk7CiAgICAgICAgfQogICAgICAgIGlmIChtYXliZVBhdGggIT09IHZvaWQgMCkgewogICAgICAgICAgcmV0dXJuIG5ldyBfbG9jYWxGaWxlLmRlZmF1bHQobWF5YmVQYXRoLCBvcHRzKTsKICAgICAgICB9CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJubyB1cmwsIHBhdGgsIG9yIGZpbGVoYW5kbGUgcHJvdmlkZWQsIGNhbm5vdCBvcGVuIik7CiAgICAgIH0KICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRoSG9sZXMuanMKICB2YXIgcmVxdWlyZV9hcnJheVdpdGhIb2xlcyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aEhvbGVzLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIGZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsKICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKQogICAgICAgICAgcmV0dXJuIGFycjsKICAgICAgfQogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBfYXJyYXlXaXRoSG9sZXM7CiAgICAgIG1vZHVsZTIuZXhwb3J0c1siZGVmYXVsdCJdID0gbW9kdWxlMi5leHBvcnRzLCBtb2R1bGUyLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzCiAgdmFyIHJlcXVpcmVfaXRlcmFibGVUb0FycmF5TGltaXQgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7CiAgICAgICAgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gInVuZGVmaW5lZCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyWyJAQGl0ZXJhdG9yIl07CiAgICAgICAgaWYgKF9pID09IG51bGwpCiAgICAgICAgICByZXR1cm47CiAgICAgICAgdmFyIF9hcnIgPSBbXTsKICAgICAgICB2YXIgX24gPSB0cnVlOwogICAgICAgIHZhciBfZCA9IGZhbHNlOwogICAgICAgIHZhciBfcywgX2U7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsKICAgICAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTsKICAgICAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpCiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICBfZCA9IHRydWU7CiAgICAgICAgICBfZSA9IGVycjsKICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgaWYgKCFfbiAmJiBfaVsicmV0dXJuIl0gIT0gbnVsbCkKICAgICAgICAgICAgICBfaVsicmV0dXJuIl0oKTsKICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgIGlmIChfZCkKICAgICAgICAgICAgICB0aHJvdyBfZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIF9hcnI7CiAgICAgIH0KICAgICAgbW9kdWxlMi5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheUxpbWl0OwogICAgICBtb2R1bGUyLmV4cG9ydHNbImRlZmF1bHQiXSA9IG1vZHVsZTIuZXhwb3J0cywgbW9kdWxlMi5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzCiAgdmFyIHJlcXVpcmVfYXJyYXlMaWtlVG9BcnJheSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5TGlrZVRvQXJyYXkuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsKICAgICAgICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkKICAgICAgICAgIGxlbiA9IGFyci5sZW5ndGg7CiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgICBhcnIyW2ldID0gYXJyW2ldOwogICAgICAgIH0KICAgICAgICByZXR1cm4gYXJyMjsKICAgICAgfQogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBfYXJyYXlMaWtlVG9BcnJheTsKICAgICAgbW9kdWxlMi5leHBvcnRzWyJkZWZhdWx0Il0gPSBtb2R1bGUyLmV4cG9ydHMsIG1vZHVsZTIuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanMKICB2YXIgcmVxdWlyZV91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIHZhciBhcnJheUxpa2VUb0FycmF5ID0gcmVxdWlyZV9hcnJheUxpa2VUb0FycmF5KCk7CiAgICAgIGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsKICAgICAgICBpZiAoIW8pCiAgICAgICAgICByZXR1cm47CiAgICAgICAgaWYgKHR5cGVvZiBvID09PSAic3RyaW5nIikKICAgICAgICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7CiAgICAgICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOwogICAgICAgIGlmIChuID09PSAiT2JqZWN0IiAmJiBvLmNvbnN0cnVjdG9yKQogICAgICAgICAgbiA9IG8uY29uc3RydWN0b3IubmFtZTsKICAgICAgICBpZiAobiA9PT0gIk1hcCIgfHwgbiA9PT0gIlNldCIpCiAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShvKTsKICAgICAgICBpZiAobiA9PT0gIkFyZ3VtZW50cyIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpCiAgICAgICAgICByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOwogICAgICB9CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheTsKICAgICAgbW9kdWxlMi5leHBvcnRzWyJkZWZhdWx0Il0gPSBtb2R1bGUyLmV4cG9ydHMsIG1vZHVsZTIuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVSZXN0LmpzCiAgdmFyIHJlcXVpcmVfbm9uSXRlcmFibGVSZXN0ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVSZXN0LmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC4iKTsKICAgICAgfQogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVSZXN0OwogICAgICBtb2R1bGUyLmV4cG9ydHNbImRlZmF1bHQiXSA9IG1vZHVsZTIuZXhwb3J0cywgbW9kdWxlMi5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzCiAgdmFyIHJlcXVpcmVfc2xpY2VkVG9BcnJheSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgdmFyIGFycmF5V2l0aEhvbGVzID0gcmVxdWlyZV9hcnJheVdpdGhIb2xlcygpOwogICAgICB2YXIgaXRlcmFibGVUb0FycmF5TGltaXQgPSByZXF1aXJlX2l0ZXJhYmxlVG9BcnJheUxpbWl0KCk7CiAgICAgIHZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmVfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoKTsKICAgICAgdmFyIG5vbkl0ZXJhYmxlUmVzdCA9IHJlcXVpcmVfbm9uSXRlcmFibGVSZXN0KCk7CiAgICAgIGZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgewogICAgICAgIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTsKICAgICAgfQogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBfc2xpY2VkVG9BcnJheTsKICAgICAgbW9kdWxlMi5leHBvcnRzWyJkZWZhdWx0Il0gPSBtb2R1bGUyLmV4cG9ydHMsIG1vZHVsZTIuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL2NvbW1vbi5qcwogIHZhciByZXF1aXJlX2NvbW1vbiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9jb21tb24uanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgVFlQRURfT0sgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gInVuZGVmaW5lZCIgJiYgdHlwZW9mIFVpbnQxNkFycmF5ICE9PSAidW5kZWZpbmVkIiAmJiB0eXBlb2YgSW50MzJBcnJheSAhPT0gInVuZGVmaW5lZCI7CiAgICAgIGZ1bmN0aW9uIF9oYXMob2JqLCBrZXkpIHsKICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTsKICAgICAgfQogICAgICBleHBvcnRzMi5hc3NpZ24gPSBmdW5jdGlvbihvYmopIHsKICAgICAgICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7CiAgICAgICAgd2hpbGUgKHNvdXJjZXMubGVuZ3RoKSB7CiAgICAgICAgICB2YXIgc291cmNlID0gc291cmNlcy5zaGlmdCgpOwogICAgICAgICAgaWYgKCFzb3VyY2UpIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gIm9iamVjdCIpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAibXVzdCBiZSBub24tb2JqZWN0Iik7CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKHZhciBwIGluIHNvdXJjZSkgewogICAgICAgICAgICBpZiAoX2hhcyhzb3VyY2UsIHApKSB7CiAgICAgICAgICAgICAgb2JqW3BdID0gc291cmNlW3BdOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBvYmo7CiAgICAgIH07CiAgICAgIGV4cG9ydHMyLnNocmlua0J1ZiA9IGZ1bmN0aW9uKGJ1Ziwgc2l6ZSkgewogICAgICAgIGlmIChidWYubGVuZ3RoID09PSBzaXplKSB7CiAgICAgICAgICByZXR1cm4gYnVmOwogICAgICAgIH0KICAgICAgICBpZiAoYnVmLnN1YmFycmF5KSB7CiAgICAgICAgICByZXR1cm4gYnVmLnN1YmFycmF5KDAsIHNpemUpOwogICAgICAgIH0KICAgICAgICBidWYubGVuZ3RoID0gc2l6ZTsKICAgICAgICByZXR1cm4gYnVmOwogICAgICB9OwogICAgICB2YXIgZm5UeXBlZCA9IHsKICAgICAgICBhcnJheVNldDogZnVuY3Rpb24oZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHsKICAgICAgICAgIGlmIChzcmMuc3ViYXJyYXkgJiYgZGVzdC5zdWJhcnJheSkgewogICAgICAgICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjX29mZnMsIHNyY19vZmZzICsgbGVuKSwgZGVzdF9vZmZzKTsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgfQogICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgewogICAgICAgICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbihjaHVua3MpIHsKICAgICAgICAgIHZhciBpLCBsLCBsZW4sIHBvcywgY2h1bmssIHJlc3VsdDsKICAgICAgICAgIGxlbiA9IDA7CiAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDsKICAgICAgICAgIH0KICAgICAgICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7CiAgICAgICAgICBwb3MgPSAwOwogICAgICAgICAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgICAgICAgICAgY2h1bmsgPSBjaHVua3NbaV07CiAgICAgICAgICAgIHJlc3VsdC5zZXQoY2h1bmssIHBvcyk7CiAgICAgICAgICAgIHBvcyArPSBjaHVuay5sZW5ndGg7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgIH0KICAgICAgfTsKICAgICAgdmFyIGZuVW50eXBlZCA9IHsKICAgICAgICBhcnJheVNldDogZnVuY3Rpb24oZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHsKICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsKICAgICAgICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldOwogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24oY2h1bmtzKSB7CiAgICAgICAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBjaHVua3MpOwogICAgICAgIH0KICAgICAgfTsKICAgICAgZXhwb3J0czIuc2V0VHlwZWQgPSBmdW5jdGlvbihvbikgewogICAgICAgIGlmIChvbikgewogICAgICAgICAgZXhwb3J0czIuQnVmOCA9IFVpbnQ4QXJyYXk7CiAgICAgICAgICBleHBvcnRzMi5CdWYxNiA9IFVpbnQxNkFycmF5OwogICAgICAgICAgZXhwb3J0czIuQnVmMzIgPSBJbnQzMkFycmF5OwogICAgICAgICAgZXhwb3J0czIuYXNzaWduKGV4cG9ydHMyLCBmblR5cGVkKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgZXhwb3J0czIuQnVmOCA9IEFycmF5OwogICAgICAgICAgZXhwb3J0czIuQnVmMTYgPSBBcnJheTsKICAgICAgICAgIGV4cG9ydHMyLkJ1ZjMyID0gQXJyYXk7CiAgICAgICAgICBleHBvcnRzMi5hc3NpZ24oZXhwb3J0czIsIGZuVW50eXBlZCk7CiAgICAgICAgfQogICAgICB9OwogICAgICBleHBvcnRzMi5zZXRUeXBlZChUWVBFRF9PSyk7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3RyZWVzLmpzCiAgdmFyIHJlcXVpcmVfdHJlZXMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi90cmVlcy5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciB1dGlscyA9IHJlcXVpcmVfY29tbW9uKCk7CiAgICAgIHZhciBaX0ZJWEVEID0gNDsKICAgICAgdmFyIFpfQklOQVJZID0gMDsKICAgICAgdmFyIFpfVEVYVCA9IDE7CiAgICAgIHZhciBaX1VOS05PV04gPSAyOwogICAgICBmdW5jdGlvbiB6ZXJvKGJ1ZikgewogICAgICAgIHZhciBsZW4gPSBidWYubGVuZ3RoOwogICAgICAgIHdoaWxlICgtLWxlbiA+PSAwKSB7CiAgICAgICAgICBidWZbbGVuXSA9IDA7CiAgICAgICAgfQogICAgICB9CiAgICAgIHZhciBTVE9SRURfQkxPQ0sgPSAwOwogICAgICB2YXIgU1RBVElDX1RSRUVTID0gMTsKICAgICAgdmFyIERZTl9UUkVFUyA9IDI7CiAgICAgIHZhciBNSU5fTUFUQ0ggPSAzOwogICAgICB2YXIgTUFYX01BVENIID0gMjU4OwogICAgICB2YXIgTEVOR1RIX0NPREVTID0gMjk7CiAgICAgIHZhciBMSVRFUkFMUyA9IDI1NjsKICAgICAgdmFyIExfQ09ERVMgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7CiAgICAgIHZhciBEX0NPREVTID0gMzA7CiAgICAgIHZhciBCTF9DT0RFUyA9IDE5OwogICAgICB2YXIgSEVBUF9TSVpFID0gMiAqIExfQ09ERVMgKyAxOwogICAgICB2YXIgTUFYX0JJVFMgPSAxNTsKICAgICAgdmFyIEJ1Zl9zaXplID0gMTY7CiAgICAgIHZhciBNQVhfQkxfQklUUyA9IDc7CiAgICAgIHZhciBFTkRfQkxPQ0sgPSAyNTY7CiAgICAgIHZhciBSRVBfM182ID0gMTY7CiAgICAgIHZhciBSRVBaXzNfMTAgPSAxNzsKICAgICAgdmFyIFJFUFpfMTFfMTM4ID0gMTg7CiAgICAgIHZhciBleHRyYV9sYml0cyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAxLCAxLCAxLCAyLCAyLCAyLCAyLCAzLCAzLCAzLCAzLCA0LCA0LCA0LCA0LCA1LCA1LCA1LCA1LCAwXTsKICAgICAgdmFyIGV4dHJhX2RiaXRzID0gWzAsIDAsIDAsIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDQsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDgsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEzLCAxM107CiAgICAgIHZhciBleHRyYV9ibGJpdHMgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMiwgMywgN107CiAgICAgIHZhciBibF9vcmRlciA9IFsxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1XTsKICAgICAgdmFyIERJU1RfQ09ERV9MRU4gPSA1MTI7CiAgICAgIHZhciBzdGF0aWNfbHRyZWUgPSBuZXcgQXJyYXkoKExfQ09ERVMgKyAyKSAqIDIpOwogICAgICB6ZXJvKHN0YXRpY19sdHJlZSk7CiAgICAgIHZhciBzdGF0aWNfZHRyZWUgPSBuZXcgQXJyYXkoRF9DT0RFUyAqIDIpOwogICAgICB6ZXJvKHN0YXRpY19kdHJlZSk7CiAgICAgIHZhciBfZGlzdF9jb2RlID0gbmV3IEFycmF5KERJU1RfQ09ERV9MRU4pOwogICAgICB6ZXJvKF9kaXN0X2NvZGUpOwogICAgICB2YXIgX2xlbmd0aF9jb2RlID0gbmV3IEFycmF5KE1BWF9NQVRDSCAtIE1JTl9NQVRDSCArIDEpOwogICAgICB6ZXJvKF9sZW5ndGhfY29kZSk7CiAgICAgIHZhciBiYXNlX2xlbmd0aCA9IG5ldyBBcnJheShMRU5HVEhfQ09ERVMpOwogICAgICB6ZXJvKGJhc2VfbGVuZ3RoKTsKICAgICAgdmFyIGJhc2VfZGlzdCA9IG5ldyBBcnJheShEX0NPREVTKTsKICAgICAgemVybyhiYXNlX2Rpc3QpOwogICAgICBmdW5jdGlvbiBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfdHJlZSwgZXh0cmFfYml0cywgZXh0cmFfYmFzZSwgZWxlbXMsIG1heF9sZW5ndGgpIHsKICAgICAgICB0aGlzLnN0YXRpY190cmVlID0gc3RhdGljX3RyZWU7CiAgICAgICAgdGhpcy5leHRyYV9iaXRzID0gZXh0cmFfYml0czsKICAgICAgICB0aGlzLmV4dHJhX2Jhc2UgPSBleHRyYV9iYXNlOwogICAgICAgIHRoaXMuZWxlbXMgPSBlbGVtczsKICAgICAgICB0aGlzLm1heF9sZW5ndGggPSBtYXhfbGVuZ3RoOwogICAgICAgIHRoaXMuaGFzX3N0cmVlID0gc3RhdGljX3RyZWUgJiYgc3RhdGljX3RyZWUubGVuZ3RoOwogICAgICB9CiAgICAgIHZhciBzdGF0aWNfbF9kZXNjOwogICAgICB2YXIgc3RhdGljX2RfZGVzYzsKICAgICAgdmFyIHN0YXRpY19ibF9kZXNjOwogICAgICBmdW5jdGlvbiBUcmVlRGVzYyhkeW5fdHJlZSwgc3RhdF9kZXNjKSB7CiAgICAgICAgdGhpcy5keW5fdHJlZSA9IGR5bl90cmVlOwogICAgICAgIHRoaXMubWF4X2NvZGUgPSAwOwogICAgICAgIHRoaXMuc3RhdF9kZXNjID0gc3RhdF9kZXNjOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRfY29kZShkaXN0KSB7CiAgICAgICAgcmV0dXJuIGRpc3QgPCAyNTYgPyBfZGlzdF9jb2RlW2Rpc3RdIDogX2Rpc3RfY29kZVsyNTYgKyAoZGlzdCA+Pj4gNyldOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHB1dF9zaG9ydChzLCB3KSB7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSB3ICYgMjU1OwogICAgICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gdyA+Pj4gOCAmIDI1NTsKICAgICAgfQogICAgICBmdW5jdGlvbiBzZW5kX2JpdHMocywgdmFsdWUsIGxlbmd0aCkgewogICAgICAgIGlmIChzLmJpX3ZhbGlkID4gQnVmX3NpemUgLSBsZW5ndGgpIHsKICAgICAgICAgIHMuYmlfYnVmIHw9IHZhbHVlIDw8IHMuYmlfdmFsaWQgJiA2NTUzNTsKICAgICAgICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7CiAgICAgICAgICBzLmJpX2J1ZiA9IHZhbHVlID4+IEJ1Zl9zaXplIC0gcy5iaV92YWxpZDsKICAgICAgICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoIC0gQnVmX3NpemU7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHMuYmlfYnVmIHw9IHZhbHVlIDw8IHMuYmlfdmFsaWQgJiA2NTUzNTsKICAgICAgICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBzZW5kX2NvZGUocywgYywgdHJlZSkgewogICAgICAgIHNlbmRfYml0cyhzLCB0cmVlW2MgKiAyXSwgdHJlZVtjICogMiArIDFdKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBiaV9yZXZlcnNlKGNvZGUsIGxlbikgewogICAgICAgIHZhciByZXMgPSAwOwogICAgICAgIGRvIHsKICAgICAgICAgIHJlcyB8PSBjb2RlICYgMTsKICAgICAgICAgIGNvZGUgPj4+PSAxOwogICAgICAgICAgcmVzIDw8PSAxOwogICAgICAgIH0gd2hpbGUgKC0tbGVuID4gMCk7CiAgICAgICAgcmV0dXJuIHJlcyA+Pj4gMTsKICAgICAgfQogICAgICBmdW5jdGlvbiBiaV9mbHVzaChzKSB7CiAgICAgICAgaWYgKHMuYmlfdmFsaWQgPT09IDE2KSB7CiAgICAgICAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpOwogICAgICAgICAgcy5iaV9idWYgPSAwOwogICAgICAgICAgcy5iaV92YWxpZCA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID49IDgpIHsKICAgICAgICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWYgJiAyNTU7CiAgICAgICAgICBzLmJpX2J1ZiA+Pj0gODsKICAgICAgICAgIHMuYmlfdmFsaWQgLT0gODsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZ2VuX2JpdGxlbihzLCBkZXNjKSB7CiAgICAgICAgdmFyIHRyZWUgPSBkZXNjLmR5bl90cmVlOwogICAgICAgIHZhciBtYXhfY29kZSA9IGRlc2MubWF4X2NvZGU7CiAgICAgICAgdmFyIHN0cmVlID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7CiAgICAgICAgdmFyIGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTsKICAgICAgICB2YXIgZXh0cmEgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iaXRzOwogICAgICAgIHZhciBiYXNlID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYmFzZTsKICAgICAgICB2YXIgbWF4X2xlbmd0aCA9IGRlc2Muc3RhdF9kZXNjLm1heF9sZW5ndGg7CiAgICAgICAgdmFyIGg7CiAgICAgICAgdmFyIG4sIG07CiAgICAgICAgdmFyIGJpdHM7CiAgICAgICAgdmFyIHhiaXRzOwogICAgICAgIHZhciBmOwogICAgICAgIHZhciBvdmVyZmxvdyA9IDA7CiAgICAgICAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7CiAgICAgICAgICBzLmJsX2NvdW50W2JpdHNdID0gMDsKICAgICAgICB9CiAgICAgICAgdHJlZVtzLmhlYXBbcy5oZWFwX21heF0gKiAyICsgMV0gPSAwOwogICAgICAgIGZvciAoaCA9IHMuaGVhcF9tYXggKyAxOyBoIDwgSEVBUF9TSVpFOyBoKyspIHsKICAgICAgICAgIG4gPSBzLmhlYXBbaF07CiAgICAgICAgICBiaXRzID0gdHJlZVt0cmVlW24gKiAyICsgMV0gKiAyICsgMV0gKyAxOwogICAgICAgICAgaWYgKGJpdHMgPiBtYXhfbGVuZ3RoKSB7CiAgICAgICAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoOwogICAgICAgICAgICBvdmVyZmxvdysrOwogICAgICAgICAgfQogICAgICAgICAgdHJlZVtuICogMiArIDFdID0gYml0czsKICAgICAgICAgIGlmIChuID4gbWF4X2NvZGUpIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgICBzLmJsX2NvdW50W2JpdHNdKys7CiAgICAgICAgICB4Yml0cyA9IDA7CiAgICAgICAgICBpZiAobiA+PSBiYXNlKSB7CiAgICAgICAgICAgIHhiaXRzID0gZXh0cmFbbiAtIGJhc2VdOwogICAgICAgICAgfQogICAgICAgICAgZiA9IHRyZWVbbiAqIDJdOwogICAgICAgICAgcy5vcHRfbGVuICs9IGYgKiAoYml0cyArIHhiaXRzKTsKICAgICAgICAgIGlmIChoYXNfc3RyZWUpIHsKICAgICAgICAgICAgcy5zdGF0aWNfbGVuICs9IGYgKiAoc3RyZWVbbiAqIDIgKyAxXSArIHhiaXRzKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKG92ZXJmbG93ID09PSAwKSB7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGRvIHsKICAgICAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoIC0gMTsKICAgICAgICAgIHdoaWxlIChzLmJsX2NvdW50W2JpdHNdID09PSAwKSB7CiAgICAgICAgICAgIGJpdHMtLTsKICAgICAgICAgIH0KICAgICAgICAgIHMuYmxfY291bnRbYml0c10tLTsKICAgICAgICAgIHMuYmxfY291bnRbYml0cyArIDFdICs9IDI7CiAgICAgICAgICBzLmJsX2NvdW50W21heF9sZW5ndGhdLS07CiAgICAgICAgICBvdmVyZmxvdyAtPSAyOwogICAgICAgIH0gd2hpbGUgKG92ZXJmbG93ID4gMCk7CiAgICAgICAgZm9yIChiaXRzID0gbWF4X2xlbmd0aDsgYml0cyAhPT0gMDsgYml0cy0tKSB7CiAgICAgICAgICBuID0gcy5ibF9jb3VudFtiaXRzXTsKICAgICAgICAgIHdoaWxlIChuICE9PSAwKSB7CiAgICAgICAgICAgIG0gPSBzLmhlYXBbLS1oXTsKICAgICAgICAgICAgaWYgKG0gPiBtYXhfY29kZSkgewogICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh0cmVlW20gKiAyICsgMV0gIT09IGJpdHMpIHsKICAgICAgICAgICAgICBzLm9wdF9sZW4gKz0gKGJpdHMgLSB0cmVlW20gKiAyICsgMV0pICogdHJlZVttICogMl07CiAgICAgICAgICAgICAgdHJlZVttICogMiArIDFdID0gYml0czsKICAgICAgICAgICAgfQogICAgICAgICAgICBuLS07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgYmxfY291bnQpIHsKICAgICAgICB2YXIgbmV4dF9jb2RlID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7CiAgICAgICAgdmFyIGNvZGUgPSAwOwogICAgICAgIHZhciBiaXRzOwogICAgICAgIHZhciBuOwogICAgICAgIGZvciAoYml0cyA9IDE7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykgewogICAgICAgICAgbmV4dF9jb2RlW2JpdHNdID0gY29kZSA9IGNvZGUgKyBibF9jb3VudFtiaXRzIC0gMV0gPDwgMTsKICAgICAgICB9CiAgICAgICAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7CiAgICAgICAgICB2YXIgbGVuID0gdHJlZVtuICogMiArIDFdOwogICAgICAgICAgaWYgKGxlbiA9PT0gMCkgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIHRyZWVbbiAqIDJdID0gYmlfcmV2ZXJzZShuZXh0X2NvZGVbbGVuXSsrLCBsZW4pOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiB0cl9zdGF0aWNfaW5pdCgpIHsKICAgICAgICB2YXIgbjsKICAgICAgICB2YXIgYml0czsKICAgICAgICB2YXIgbGVuZ3RoOwogICAgICAgIHZhciBjb2RlOwogICAgICAgIHZhciBkaXN0OwogICAgICAgIHZhciBibF9jb3VudCA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpOwogICAgICAgIGxlbmd0aCA9IDA7CiAgICAgICAgZm9yIChjb2RlID0gMDsgY29kZSA8IExFTkdUSF9DT0RFUyAtIDE7IGNvZGUrKykgewogICAgICAgICAgYmFzZV9sZW5ndGhbY29kZV0gPSBsZW5ndGg7CiAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgMSA8PCBleHRyYV9sYml0c1tjb2RlXTsgbisrKSB7CiAgICAgICAgICAgIF9sZW5ndGhfY29kZVtsZW5ndGgrK10gPSBjb2RlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBfbGVuZ3RoX2NvZGVbbGVuZ3RoIC0gMV0gPSBjb2RlOwogICAgICAgIGRpc3QgPSAwOwogICAgICAgIGZvciAoY29kZSA9IDA7IGNvZGUgPCAxNjsgY29kZSsrKSB7CiAgICAgICAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0OwogICAgICAgICAgZm9yIChuID0gMDsgbiA8IDEgPDwgZXh0cmFfZGJpdHNbY29kZV07IG4rKykgewogICAgICAgICAgICBfZGlzdF9jb2RlW2Rpc3QrK10gPSBjb2RlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBkaXN0ID4+PSA3OwogICAgICAgIGZvciAoOyBjb2RlIDwgRF9DT0RFUzsgY29kZSsrKSB7CiAgICAgICAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0IDw8IDc7CiAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgMSA8PCBleHRyYV9kYml0c1tjb2RlXSAtIDc7IG4rKykgewogICAgICAgICAgICBfZGlzdF9jb2RlWzI1NiArIGRpc3QrK10gPSBjb2RlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHsKICAgICAgICAgIGJsX2NvdW50W2JpdHNdID0gMDsKICAgICAgICB9CiAgICAgICAgbiA9IDA7CiAgICAgICAgd2hpbGUgKG4gPD0gMTQzKSB7CiAgICAgICAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXSA9IDg7CiAgICAgICAgICBuKys7CiAgICAgICAgICBibF9jb3VudFs4XSsrOwogICAgICAgIH0KICAgICAgICB3aGlsZSAobiA8PSAyNTUpIHsKICAgICAgICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdID0gOTsKICAgICAgICAgIG4rKzsKICAgICAgICAgIGJsX2NvdW50WzldKys7CiAgICAgICAgfQogICAgICAgIHdoaWxlIChuIDw9IDI3OSkgewogICAgICAgICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0gPSA3OwogICAgICAgICAgbisrOwogICAgICAgICAgYmxfY291bnRbN10rKzsKICAgICAgICB9CiAgICAgICAgd2hpbGUgKG4gPD0gMjg3KSB7CiAgICAgICAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXSA9IDg7CiAgICAgICAgICBuKys7CiAgICAgICAgICBibF9jb3VudFs4XSsrOwogICAgICAgIH0KICAgICAgICBnZW5fY29kZXMoc3RhdGljX2x0cmVlLCBMX0NPREVTICsgMSwgYmxfY291bnQpOwogICAgICAgIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyBuKyspIHsKICAgICAgICAgIHN0YXRpY19kdHJlZVtuICogMiArIDFdID0gNTsKICAgICAgICAgIHN0YXRpY19kdHJlZVtuICogMl0gPSBiaV9yZXZlcnNlKG4sIDUpOwogICAgICAgIH0KICAgICAgICBzdGF0aWNfbF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19sdHJlZSwgZXh0cmFfbGJpdHMsIExJVEVSQUxTICsgMSwgTF9DT0RFUywgTUFYX0JJVFMpOwogICAgICAgIHN0YXRpY19kX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2R0cmVlLCBleHRyYV9kYml0cywgMCwgRF9DT0RFUywgTUFYX0JJVFMpOwogICAgICAgIHN0YXRpY19ibF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKG5ldyBBcnJheSgwKSwgZXh0cmFfYmxiaXRzLCAwLCBCTF9DT0RFUywgTUFYX0JMX0JJVFMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluaXRfYmxvY2socykgewogICAgICAgIHZhciBuOwogICAgICAgIGZvciAobiA9IDA7IG4gPCBMX0NPREVTOyBuKyspIHsKICAgICAgICAgIHMuZHluX2x0cmVlW24gKiAyXSA9IDA7CiAgICAgICAgfQogICAgICAgIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyBuKyspIHsKICAgICAgICAgIHMuZHluX2R0cmVlW24gKiAyXSA9IDA7CiAgICAgICAgfQogICAgICAgIGZvciAobiA9IDA7IG4gPCBCTF9DT0RFUzsgbisrKSB7CiAgICAgICAgICBzLmJsX3RyZWVbbiAqIDJdID0gMDsKICAgICAgICB9CiAgICAgICAgcy5keW5fbHRyZWVbRU5EX0JMT0NLICogMl0gPSAxOwogICAgICAgIHMub3B0X2xlbiA9IHMuc3RhdGljX2xlbiA9IDA7CiAgICAgICAgcy5sYXN0X2xpdCA9IHMubWF0Y2hlcyA9IDA7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gYmlfd2luZHVwKHMpIHsKICAgICAgICBpZiAocy5iaV92YWxpZCA+IDgpIHsKICAgICAgICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7CiAgICAgICAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID4gMCkgewogICAgICAgICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZjsKICAgICAgICB9CiAgICAgICAgcy5iaV9idWYgPSAwOwogICAgICAgIHMuYmlfdmFsaWQgPSAwOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNvcHlfYmxvY2socywgYnVmLCBsZW4sIGhlYWRlcikgewogICAgICAgIGJpX3dpbmR1cChzKTsKICAgICAgICBpZiAoaGVhZGVyKSB7CiAgICAgICAgICBwdXRfc2hvcnQocywgbGVuKTsKICAgICAgICAgIHB1dF9zaG9ydChzLCB+bGVuKTsKICAgICAgICB9CiAgICAgICAgdXRpbHMuYXJyYXlTZXQocy5wZW5kaW5nX2J1Ziwgcy53aW5kb3csIGJ1ZiwgbGVuLCBzLnBlbmRpbmcpOwogICAgICAgIHMucGVuZGluZyArPSBsZW47CiAgICAgIH0KICAgICAgZnVuY3Rpb24gc21hbGxlcih0cmVlLCBuLCBtLCBkZXB0aCkgewogICAgICAgIHZhciBfbjIgPSBuICogMjsKICAgICAgICB2YXIgX20yID0gbSAqIDI7CiAgICAgICAgcmV0dXJuIHRyZWVbX24yXSA8IHRyZWVbX20yXSB8fCB0cmVlW19uMl0gPT09IHRyZWVbX20yXSAmJiBkZXB0aFtuXSA8PSBkZXB0aFttXTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwcWRvd25oZWFwKHMsIHRyZWUsIGspIHsKICAgICAgICB2YXIgdiA9IHMuaGVhcFtrXTsKICAgICAgICB2YXIgaiA9IGsgPDwgMTsKICAgICAgICB3aGlsZSAoaiA8PSBzLmhlYXBfbGVuKSB7CiAgICAgICAgICBpZiAoaiA8IHMuaGVhcF9sZW4gJiYgc21hbGxlcih0cmVlLCBzLmhlYXBbaiArIDFdLCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7CiAgICAgICAgICAgIGorKzsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzbWFsbGVyKHRyZWUsIHYsIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBzLmhlYXBba10gPSBzLmhlYXBbal07CiAgICAgICAgICBrID0gajsKICAgICAgICAgIGogPDw9IDE7CiAgICAgICAgfQogICAgICAgIHMuaGVhcFtrXSA9IHY7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gY29tcHJlc3NfYmxvY2socywgbHRyZWUsIGR0cmVlKSB7CiAgICAgICAgdmFyIGRpc3Q7CiAgICAgICAgdmFyIGxjOwogICAgICAgIHZhciBseCA9IDA7CiAgICAgICAgdmFyIGNvZGU7CiAgICAgICAgdmFyIGV4dHJhOwogICAgICAgIGlmIChzLmxhc3RfbGl0ICE9PSAwKSB7CiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIGRpc3QgPSBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDJdIDw8IDggfCBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDIgKyAxXTsKICAgICAgICAgICAgbGMgPSBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBseF07CiAgICAgICAgICAgIGx4Kys7CiAgICAgICAgICAgIGlmIChkaXN0ID09PSAwKSB7CiAgICAgICAgICAgICAgc2VuZF9jb2RlKHMsIGxjLCBsdHJlZSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgY29kZSA9IF9sZW5ndGhfY29kZVtsY107CiAgICAgICAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUgKyBMSVRFUkFMUyArIDEsIGx0cmVlKTsKICAgICAgICAgICAgICBleHRyYSA9IGV4dHJhX2xiaXRzW2NvZGVdOwogICAgICAgICAgICAgIGlmIChleHRyYSAhPT0gMCkgewogICAgICAgICAgICAgICAgbGMgLT0gYmFzZV9sZW5ndGhbY29kZV07CiAgICAgICAgICAgICAgICBzZW5kX2JpdHMocywgbGMsIGV4dHJhKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZGlzdC0tOwogICAgICAgICAgICAgIGNvZGUgPSBkX2NvZGUoZGlzdCk7CiAgICAgICAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUsIGR0cmVlKTsKICAgICAgICAgICAgICBleHRyYSA9IGV4dHJhX2RiaXRzW2NvZGVdOwogICAgICAgICAgICAgIGlmIChleHRyYSAhPT0gMCkgewogICAgICAgICAgICAgICAgZGlzdCAtPSBiYXNlX2Rpc3RbY29kZV07CiAgICAgICAgICAgICAgICBzZW5kX2JpdHMocywgZGlzdCwgZXh0cmEpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfSB3aGlsZSAobHggPCBzLmxhc3RfbGl0KTsKICAgICAgICB9CiAgICAgICAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgbHRyZWUpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGJ1aWxkX3RyZWUocywgZGVzYykgewogICAgICAgIHZhciB0cmVlID0gZGVzYy5keW5fdHJlZTsKICAgICAgICB2YXIgc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTsKICAgICAgICB2YXIgaGFzX3N0cmVlID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlOwogICAgICAgIHZhciBlbGVtcyA9IGRlc2Muc3RhdF9kZXNjLmVsZW1zOwogICAgICAgIHZhciBuLCBtOwogICAgICAgIHZhciBtYXhfY29kZSA9IC0xOwogICAgICAgIHZhciBub2RlOwogICAgICAgIHMuaGVhcF9sZW4gPSAwOwogICAgICAgIHMuaGVhcF9tYXggPSBIRUFQX1NJWkU7CiAgICAgICAgZm9yIChuID0gMDsgbiA8IGVsZW1zOyBuKyspIHsKICAgICAgICAgIGlmICh0cmVlW24gKiAyXSAhPT0gMCkgewogICAgICAgICAgICBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IG1heF9jb2RlID0gbjsKICAgICAgICAgICAgcy5kZXB0aFtuXSA9IDA7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0cmVlW24gKiAyICsgMV0gPSAwOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHsKICAgICAgICAgIG5vZGUgPSBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IG1heF9jb2RlIDwgMiA/ICsrbWF4X2NvZGUgOiAwOwogICAgICAgICAgdHJlZVtub2RlICogMl0gPSAxOwogICAgICAgICAgcy5kZXB0aFtub2RlXSA9IDA7CiAgICAgICAgICBzLm9wdF9sZW4tLTsKICAgICAgICAgIGlmIChoYXNfc3RyZWUpIHsKICAgICAgICAgICAgcy5zdGF0aWNfbGVuIC09IHN0cmVlW25vZGUgKiAyICsgMV07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGRlc2MubWF4X2NvZGUgPSBtYXhfY29kZTsKICAgICAgICBmb3IgKG4gPSBzLmhlYXBfbGVuID4+IDE7IG4gPj0gMTsgbi0tKSB7CiAgICAgICAgICBwcWRvd25oZWFwKHMsIHRyZWUsIG4pOwogICAgICAgIH0KICAgICAgICBub2RlID0gZWxlbXM7CiAgICAgICAgZG8gewogICAgICAgICAgbiA9IHMuaGVhcFsxXTsKICAgICAgICAgIHMuaGVhcFsxXSA9IHMuaGVhcFtzLmhlYXBfbGVuLS1dOwogICAgICAgICAgcHFkb3duaGVhcChzLCB0cmVlLCAxKTsKICAgICAgICAgIG0gPSBzLmhlYXBbMV07CiAgICAgICAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG47CiAgICAgICAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG07CiAgICAgICAgICB0cmVlW25vZGUgKiAyXSA9IHRyZWVbbiAqIDJdICsgdHJlZVttICogMl07CiAgICAgICAgICBzLmRlcHRoW25vZGVdID0gKHMuZGVwdGhbbl0gPj0gcy5kZXB0aFttXSA/IHMuZGVwdGhbbl0gOiBzLmRlcHRoW21dKSArIDE7CiAgICAgICAgICB0cmVlW24gKiAyICsgMV0gPSB0cmVlW20gKiAyICsgMV0gPSBub2RlOwogICAgICAgICAgcy5oZWFwWzFdID0gbm9kZSsrOwogICAgICAgICAgcHFkb3duaGVhcChzLCB0cmVlLCAxKTsKICAgICAgICB9IHdoaWxlIChzLmhlYXBfbGVuID49IDIpOwogICAgICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gcy5oZWFwWzFdOwogICAgICAgIGdlbl9iaXRsZW4ocywgZGVzYyk7CiAgICAgICAgZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBzLmJsX2NvdW50KTsKICAgICAgfQogICAgICBmdW5jdGlvbiBzY2FuX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpIHsKICAgICAgICB2YXIgbjsKICAgICAgICB2YXIgcHJldmxlbiA9IC0xOwogICAgICAgIHZhciBjdXJsZW47CiAgICAgICAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV07CiAgICAgICAgdmFyIGNvdW50ID0gMDsKICAgICAgICB2YXIgbWF4X2NvdW50ID0gNzsKICAgICAgICB2YXIgbWluX2NvdW50ID0gNDsKICAgICAgICBpZiAobmV4dGxlbiA9PT0gMCkgewogICAgICAgICAgbWF4X2NvdW50ID0gMTM4OwogICAgICAgICAgbWluX2NvdW50ID0gMzsKICAgICAgICB9CiAgICAgICAgdHJlZVsobWF4X2NvZGUgKyAxKSAqIDIgKyAxXSA9IDY1NTM1OwogICAgICAgIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykgewogICAgICAgICAgY3VybGVuID0gbmV4dGxlbjsKICAgICAgICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV07CiAgICAgICAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7CiAgICAgICAgICAgIHMuYmxfdHJlZVtjdXJsZW4gKiAyXSArPSBjb3VudDsKICAgICAgICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7CiAgICAgICAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHsKICAgICAgICAgICAgICBzLmJsX3RyZWVbY3VybGVuICogMl0rKzsKICAgICAgICAgICAgfQogICAgICAgICAgICBzLmJsX3RyZWVbUkVQXzNfNiAqIDJdKys7CiAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7CiAgICAgICAgICAgIHMuYmxfdHJlZVtSRVBaXzNfMTAgKiAyXSsrOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcy5ibF90cmVlW1JFUFpfMTFfMTM4ICogMl0rKzsKICAgICAgICAgIH0KICAgICAgICAgIGNvdW50ID0gMDsKICAgICAgICAgIHByZXZsZW4gPSBjdXJsZW47CiAgICAgICAgICBpZiAobmV4dGxlbiA9PT0gMCkgewogICAgICAgICAgICBtYXhfY291bnQgPSAxMzg7CiAgICAgICAgICAgIG1pbl9jb3VudCA9IDM7CiAgICAgICAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikgewogICAgICAgICAgICBtYXhfY291bnQgPSA2OwogICAgICAgICAgICBtaW5fY291bnQgPSAzOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgbWF4X2NvdW50ID0gNzsKICAgICAgICAgICAgbWluX2NvdW50ID0gNDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gc2VuZF90cmVlKHMsIHRyZWUsIG1heF9jb2RlKSB7CiAgICAgICAgdmFyIG47CiAgICAgICAgdmFyIHByZXZsZW4gPSAtMTsKICAgICAgICB2YXIgY3VybGVuOwogICAgICAgIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdOwogICAgICAgIHZhciBjb3VudCA9IDA7CiAgICAgICAgdmFyIG1heF9jb3VudCA9IDc7CiAgICAgICAgdmFyIG1pbl9jb3VudCA9IDQ7CiAgICAgICAgaWYgKG5leHRsZW4gPT09IDApIHsKICAgICAgICAgIG1heF9jb3VudCA9IDEzODsKICAgICAgICAgIG1pbl9jb3VudCA9IDM7CiAgICAgICAgfQogICAgICAgIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykgewogICAgICAgICAgY3VybGVuID0gbmV4dGxlbjsKICAgICAgICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV07CiAgICAgICAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpOwogICAgICAgICAgICB9IHdoaWxlICgtLWNvdW50ICE9PSAwKTsKICAgICAgICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7CiAgICAgICAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHsKICAgICAgICAgICAgICBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpOwogICAgICAgICAgICAgIGNvdW50LS07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgc2VuZF9jb2RlKHMsIFJFUF8zXzYsIHMuYmxfdHJlZSk7CiAgICAgICAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDIpOwogICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkgewogICAgICAgICAgICBzZW5kX2NvZGUocywgUkVQWl8zXzEwLCBzLmJsX3RyZWUpOwogICAgICAgICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAzKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHNlbmRfY29kZShzLCBSRVBaXzExXzEzOCwgcy5ibF90cmVlKTsKICAgICAgICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMTEsIDcpOwogICAgICAgICAgfQogICAgICAgICAgY291bnQgPSAwOwogICAgICAgICAgcHJldmxlbiA9IGN1cmxlbjsKICAgICAgICAgIGlmIChuZXh0bGVuID09PSAwKSB7CiAgICAgICAgICAgIG1heF9jb3VudCA9IDEzODsKICAgICAgICAgICAgbWluX2NvdW50ID0gMzsKICAgICAgICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7CiAgICAgICAgICAgIG1heF9jb3VudCA9IDY7CiAgICAgICAgICAgIG1pbl9jb3VudCA9IDM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBtYXhfY291bnQgPSA3OwogICAgICAgICAgICBtaW5fY291bnQgPSA0OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBidWlsZF9ibF90cmVlKHMpIHsKICAgICAgICB2YXIgbWF4X2JsaW5kZXg7CiAgICAgICAgc2Nhbl90cmVlKHMsIHMuZHluX2x0cmVlLCBzLmxfZGVzYy5tYXhfY29kZSk7CiAgICAgICAgc2Nhbl90cmVlKHMsIHMuZHluX2R0cmVlLCBzLmRfZGVzYy5tYXhfY29kZSk7CiAgICAgICAgYnVpbGRfdHJlZShzLCBzLmJsX2Rlc2MpOwogICAgICAgIGZvciAobWF4X2JsaW5kZXggPSBCTF9DT0RFUyAtIDE7IG1heF9ibGluZGV4ID49IDM7IG1heF9ibGluZGV4LS0pIHsKICAgICAgICAgIGlmIChzLmJsX3RyZWVbYmxfb3JkZXJbbWF4X2JsaW5kZXhdICogMiArIDFdICE9PSAwKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzLm9wdF9sZW4gKz0gMyAqIChtYXhfYmxpbmRleCArIDEpICsgNSArIDUgKyA0OwogICAgICAgIHJldHVybiBtYXhfYmxpbmRleDsKICAgICAgfQogICAgICBmdW5jdGlvbiBzZW5kX2FsbF90cmVlcyhzLCBsY29kZXMsIGRjb2RlcywgYmxjb2RlcykgewogICAgICAgIHZhciByYW5rOwogICAgICAgIHNlbmRfYml0cyhzLCBsY29kZXMgLSAyNTcsIDUpOwogICAgICAgIHNlbmRfYml0cyhzLCBkY29kZXMgLSAxLCA1KTsKICAgICAgICBzZW5kX2JpdHMocywgYmxjb2RlcyAtIDQsIDQpOwogICAgICAgIGZvciAocmFuayA9IDA7IHJhbmsgPCBibGNvZGVzOyByYW5rKyspIHsKICAgICAgICAgIHNlbmRfYml0cyhzLCBzLmJsX3RyZWVbYmxfb3JkZXJbcmFua10gKiAyICsgMV0sIDMpOwogICAgICAgIH0KICAgICAgICBzZW5kX3RyZWUocywgcy5keW5fbHRyZWUsIGxjb2RlcyAtIDEpOwogICAgICAgIHNlbmRfdHJlZShzLCBzLmR5bl9kdHJlZSwgZGNvZGVzIC0gMSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGV0ZWN0X2RhdGFfdHlwZShzKSB7CiAgICAgICAgdmFyIGJsYWNrX21hc2sgPSA0MDkzNjI0NDQ3OwogICAgICAgIHZhciBuOwogICAgICAgIGZvciAobiA9IDA7IG4gPD0gMzE7IG4rKywgYmxhY2tfbWFzayA+Pj49IDEpIHsKICAgICAgICAgIGlmIChibGFja19tYXNrICYgMSAmJiBzLmR5bl9sdHJlZVtuICogMl0gIT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIFpfQklOQVJZOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocy5keW5fbHRyZWVbOSAqIDJdICE9PSAwIHx8IHMuZHluX2x0cmVlWzEwICogMl0gIT09IDAgfHwgcy5keW5fbHRyZWVbMTMgKiAyXSAhPT0gMCkgewogICAgICAgICAgcmV0dXJuIFpfVEVYVDsKICAgICAgICB9CiAgICAgICAgZm9yIChuID0gMzI7IG4gPCBMSVRFUkFMUzsgbisrKSB7CiAgICAgICAgICBpZiAocy5keW5fbHRyZWVbbiAqIDJdICE9PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBaX1RFWFQ7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBaX0JJTkFSWTsKICAgICAgfQogICAgICB2YXIgc3RhdGljX2luaXRfZG9uZSA9IGZhbHNlOwogICAgICBmdW5jdGlvbiBfdHJfaW5pdChzKSB7CiAgICAgICAgaWYgKCFzdGF0aWNfaW5pdF9kb25lKSB7CiAgICAgICAgICB0cl9zdGF0aWNfaW5pdCgpOwogICAgICAgICAgc3RhdGljX2luaXRfZG9uZSA9IHRydWU7CiAgICAgICAgfQogICAgICAgIHMubF9kZXNjID0gbmV3IFRyZWVEZXNjKHMuZHluX2x0cmVlLCBzdGF0aWNfbF9kZXNjKTsKICAgICAgICBzLmRfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmR5bl9kdHJlZSwgc3RhdGljX2RfZGVzYyk7CiAgICAgICAgcy5ibF9kZXNjID0gbmV3IFRyZWVEZXNjKHMuYmxfdHJlZSwgc3RhdGljX2JsX2Rlc2MpOwogICAgICAgIHMuYmlfYnVmID0gMDsKICAgICAgICBzLmJpX3ZhbGlkID0gMDsKICAgICAgICBpbml0X2Jsb2NrKHMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KSB7CiAgICAgICAgc2VuZF9iaXRzKHMsIChTVE9SRURfQkxPQ0sgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7CiAgICAgICAgY29weV9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIHRydWUpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF90cl9hbGlnbihzKSB7CiAgICAgICAgc2VuZF9iaXRzKHMsIFNUQVRJQ19UUkVFUyA8PCAxLCAzKTsKICAgICAgICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBzdGF0aWNfbHRyZWUpOwogICAgICAgIGJpX2ZsdXNoKHMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF90cl9mbHVzaF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpIHsKICAgICAgICB2YXIgb3B0X2xlbmIsIHN0YXRpY19sZW5iOwogICAgICAgIHZhciBtYXhfYmxpbmRleCA9IDA7CiAgICAgICAgaWYgKHMubGV2ZWwgPiAwKSB7CiAgICAgICAgICBpZiAocy5zdHJtLmRhdGFfdHlwZSA9PT0gWl9VTktOT1dOKSB7CiAgICAgICAgICAgIHMuc3RybS5kYXRhX3R5cGUgPSBkZXRlY3RfZGF0YV90eXBlKHMpOwogICAgICAgICAgfQogICAgICAgICAgYnVpbGRfdHJlZShzLCBzLmxfZGVzYyk7CiAgICAgICAgICBidWlsZF90cmVlKHMsIHMuZF9kZXNjKTsKICAgICAgICAgIG1heF9ibGluZGV4ID0gYnVpbGRfYmxfdHJlZShzKTsKICAgICAgICAgIG9wdF9sZW5iID0gcy5vcHRfbGVuICsgMyArIDcgPj4+IDM7CiAgICAgICAgICBzdGF0aWNfbGVuYiA9IHMuc3RhdGljX2xlbiArIDMgKyA3ID4+PiAzOwogICAgICAgICAgaWYgKHN0YXRpY19sZW5iIDw9IG9wdF9sZW5iKSB7CiAgICAgICAgICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmI7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmIgPSBzdG9yZWRfbGVuICsgNTsKICAgICAgICB9CiAgICAgICAgaWYgKHN0b3JlZF9sZW4gKyA0IDw9IG9wdF9sZW5iICYmIGJ1ZiAhPT0gLTEpIHsKICAgICAgICAgIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KTsKICAgICAgICB9IGVsc2UgaWYgKHMuc3RyYXRlZ3kgPT09IFpfRklYRUQgfHwgc3RhdGljX2xlbmIgPT09IG9wdF9sZW5iKSB7CiAgICAgICAgICBzZW5kX2JpdHMocywgKFNUQVRJQ19UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsKICAgICAgICAgIGNvbXByZXNzX2Jsb2NrKHMsIHN0YXRpY19sdHJlZSwgc3RhdGljX2R0cmVlKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgc2VuZF9iaXRzKHMsIChEWU5fVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7CiAgICAgICAgICBzZW5kX2FsbF90cmVlcyhzLCBzLmxfZGVzYy5tYXhfY29kZSArIDEsIHMuZF9kZXNjLm1heF9jb2RlICsgMSwgbWF4X2JsaW5kZXggKyAxKTsKICAgICAgICAgIGNvbXByZXNzX2Jsb2NrKHMsIHMuZHluX2x0cmVlLCBzLmR5bl9kdHJlZSk7CiAgICAgICAgfQogICAgICAgIGluaXRfYmxvY2socyk7CiAgICAgICAgaWYgKGxhc3QpIHsKICAgICAgICAgIGJpX3dpbmR1cChzKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3RyX3RhbGx5KHMsIGRpc3QsIGxjKSB7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDJdID0gZGlzdCA+Pj4gOCAmIDI1NTsKICAgICAgICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMiArIDFdID0gZGlzdCAmIDI1NTsKICAgICAgICBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBzLmxhc3RfbGl0XSA9IGxjICYgMjU1OwogICAgICAgIHMubGFzdF9saXQrKzsKICAgICAgICBpZiAoZGlzdCA9PT0gMCkgewogICAgICAgICAgcy5keW5fbHRyZWVbbGMgKiAyXSsrOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBzLm1hdGNoZXMrKzsKICAgICAgICAgIGRpc3QtLTsKICAgICAgICAgIHMuZHluX2x0cmVlWyhfbGVuZ3RoX2NvZGVbbGNdICsgTElURVJBTFMgKyAxKSAqIDJdKys7CiAgICAgICAgICBzLmR5bl9kdHJlZVtkX2NvZGUoZGlzdCkgKiAyXSsrOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcy5sYXN0X2xpdCA9PT0gcy5saXRfYnVmc2l6ZSAtIDE7CiAgICAgIH0KICAgICAgZXhwb3J0czIuX3RyX2luaXQgPSBfdHJfaW5pdDsKICAgICAgZXhwb3J0czIuX3RyX3N0b3JlZF9ibG9jayA9IF90cl9zdG9yZWRfYmxvY2s7CiAgICAgIGV4cG9ydHMyLl90cl9mbHVzaF9ibG9jayA9IF90cl9mbHVzaF9ibG9jazsKICAgICAgZXhwb3J0czIuX3RyX3RhbGx5ID0gX3RyX3RhbGx5OwogICAgICBleHBvcnRzMi5fdHJfYWxpZ24gPSBfdHJfYWxpZ247CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2FkbGVyMzIuanMKICB2YXIgcmVxdWlyZV9hZGxlcjMyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvYWRsZXIzMi5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIGZ1bmN0aW9uIGFkbGVyMzIoYWRsZXIsIGJ1ZiwgbGVuLCBwb3MpIHsKICAgICAgICB2YXIgczEgPSBhZGxlciAmIDY1NTM1IHwgMCwgczIgPSBhZGxlciA+Pj4gMTYgJiA2NTUzNSB8IDAsIG4gPSAwOwogICAgICAgIHdoaWxlIChsZW4gIT09IDApIHsKICAgICAgICAgIG4gPSBsZW4gPiAyZTMgPyAyZTMgOiBsZW47CiAgICAgICAgICBsZW4gLT0gbjsKICAgICAgICAgIGRvIHsKICAgICAgICAgICAgczEgPSBzMSArIGJ1Zltwb3MrK10gfCAwOwogICAgICAgICAgICBzMiA9IHMyICsgczEgfCAwOwogICAgICAgICAgfSB3aGlsZSAoLS1uKTsKICAgICAgICAgIHMxICU9IDY1NTIxOwogICAgICAgICAgczIgJT0gNjU1MjE7CiAgICAgICAgfQogICAgICAgIHJldHVybiBzMSB8IHMyIDw8IDE2IHwgMDsKICAgICAgfQogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBhZGxlcjMyOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jcmMzMi5qcwogIHZhciByZXF1aXJlX2NyYzMyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBmdW5jdGlvbiBtYWtlVGFibGUoKSB7CiAgICAgICAgdmFyIGMsIHRhYmxlID0gW107CiAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCAyNTY7IG4rKykgewogICAgICAgICAgYyA9IG47CiAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IDg7IGsrKykgewogICAgICAgICAgICBjID0gYyAmIDEgPyAzOTg4MjkyMzg0IF4gYyA+Pj4gMSA6IGMgPj4+IDE7CiAgICAgICAgICB9CiAgICAgICAgICB0YWJsZVtuXSA9IGM7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0YWJsZTsKICAgICAgfQogICAgICB2YXIgY3JjVGFibGUgPSBtYWtlVGFibGUoKTsKICAgICAgZnVuY3Rpb24gY3JjMzIoY3JjLCBidWYsIGxlbiwgcG9zKSB7CiAgICAgICAgdmFyIHQgPSBjcmNUYWJsZSwgZW5kID0gcG9zICsgbGVuOwogICAgICAgIGNyYyBePSAtMTsKICAgICAgICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKyspIHsKICAgICAgICAgIGNyYyA9IGNyYyA+Pj4gOCBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAyNTVdOwogICAgICAgIH0KICAgICAgICByZXR1cm4gY3JjIF4gLTE7CiAgICAgIH0KICAgICAgbW9kdWxlMi5leHBvcnRzID0gY3JjMzI7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL21lc3NhZ2VzLmpzCiAgdmFyIHJlcXVpcmVfbWVzc2FnZXMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9tZXNzYWdlcy5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IHsKICAgICAgICAyOiAibmVlZCBkaWN0aW9uYXJ5IiwKICAgICAgICAxOiAic3RyZWFtIGVuZCIsCiAgICAgICAgMDogIiIsCiAgICAgICAgIi0xIjogImZpbGUgZXJyb3IiLAogICAgICAgICItMiI6ICJzdHJlYW0gZXJyb3IiLAogICAgICAgICItMyI6ICJkYXRhIGVycm9yIiwKICAgICAgICAiLTQiOiAiaW5zdWZmaWNpZW50IG1lbW9yeSIsCiAgICAgICAgIi01IjogImJ1ZmZlciBlcnJvciIsCiAgICAgICAgIi02IjogImluY29tcGF0aWJsZSB2ZXJzaW9uIgogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9kZWZsYXRlLmpzCiAgdmFyIHJlcXVpcmVfZGVmbGF0ZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2RlZmxhdGUuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgdXRpbHMgPSByZXF1aXJlX2NvbW1vbigpOwogICAgICB2YXIgdHJlZXMgPSByZXF1aXJlX3RyZWVzKCk7CiAgICAgIHZhciBhZGxlcjMyID0gcmVxdWlyZV9hZGxlcjMyKCk7CiAgICAgIHZhciBjcmMzMiA9IHJlcXVpcmVfY3JjMzIoKTsKICAgICAgdmFyIG1zZyA9IHJlcXVpcmVfbWVzc2FnZXMoKTsKICAgICAgdmFyIFpfTk9fRkxVU0ggPSAwOwogICAgICB2YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTsKICAgICAgdmFyIFpfRlVMTF9GTFVTSCA9IDM7CiAgICAgIHZhciBaX0ZJTklTSCA9IDQ7CiAgICAgIHZhciBaX0JMT0NLID0gNTsKICAgICAgdmFyIFpfT0sgPSAwOwogICAgICB2YXIgWl9TVFJFQU1fRU5EID0gMTsKICAgICAgdmFyIFpfU1RSRUFNX0VSUk9SID0gLTI7CiAgICAgIHZhciBaX0RBVEFfRVJST1IgPSAtMzsKICAgICAgdmFyIFpfQlVGX0VSUk9SID0gLTU7CiAgICAgIHZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTsKICAgICAgdmFyIFpfRklMVEVSRUQgPSAxOwogICAgICB2YXIgWl9IVUZGTUFOX09OTFkgPSAyOwogICAgICB2YXIgWl9STEUgPSAzOwogICAgICB2YXIgWl9GSVhFRCA9IDQ7CiAgICAgIHZhciBaX0RFRkFVTFRfU1RSQVRFR1kgPSAwOwogICAgICB2YXIgWl9VTktOT1dOID0gMjsKICAgICAgdmFyIFpfREVGTEFURUQgPSA4OwogICAgICB2YXIgTUFYX01FTV9MRVZFTCA9IDk7CiAgICAgIHZhciBNQVhfV0JJVFMgPSAxNTsKICAgICAgdmFyIERFRl9NRU1fTEVWRUwgPSA4OwogICAgICB2YXIgTEVOR1RIX0NPREVTID0gMjk7CiAgICAgIHZhciBMSVRFUkFMUyA9IDI1NjsKICAgICAgdmFyIExfQ09ERVMgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7CiAgICAgIHZhciBEX0NPREVTID0gMzA7CiAgICAgIHZhciBCTF9DT0RFUyA9IDE5OwogICAgICB2YXIgSEVBUF9TSVpFID0gMiAqIExfQ09ERVMgKyAxOwogICAgICB2YXIgTUFYX0JJVFMgPSAxNTsKICAgICAgdmFyIE1JTl9NQVRDSCA9IDM7CiAgICAgIHZhciBNQVhfTUFUQ0ggPSAyNTg7CiAgICAgIHZhciBNSU5fTE9PS0FIRUFEID0gTUFYX01BVENIICsgTUlOX01BVENIICsgMTsKICAgICAgdmFyIFBSRVNFVF9ESUNUID0gMzI7CiAgICAgIHZhciBJTklUX1NUQVRFID0gNDI7CiAgICAgIHZhciBFWFRSQV9TVEFURSA9IDY5OwogICAgICB2YXIgTkFNRV9TVEFURSA9IDczOwogICAgICB2YXIgQ09NTUVOVF9TVEFURSA9IDkxOwogICAgICB2YXIgSENSQ19TVEFURSA9IDEwMzsKICAgICAgdmFyIEJVU1lfU1RBVEUgPSAxMTM7CiAgICAgIHZhciBGSU5JU0hfU1RBVEUgPSA2NjY7CiAgICAgIHZhciBCU19ORUVEX01PUkUgPSAxOwogICAgICB2YXIgQlNfQkxPQ0tfRE9ORSA9IDI7CiAgICAgIHZhciBCU19GSU5JU0hfU1RBUlRFRCA9IDM7CiAgICAgIHZhciBCU19GSU5JU0hfRE9ORSA9IDQ7CiAgICAgIHZhciBPU19DT0RFID0gMzsKICAgICAgZnVuY3Rpb24gZXJyKHN0cm0sIGVycm9yQ29kZSkgewogICAgICAgIHN0cm0ubXNnID0gbXNnW2Vycm9yQ29kZV07CiAgICAgICAgcmV0dXJuIGVycm9yQ29kZTsKICAgICAgfQogICAgICBmdW5jdGlvbiByYW5rKGYpIHsKICAgICAgICByZXR1cm4gKGYgPDwgMSkgLSAoZiA+IDQgPyA5IDogMCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gemVybyhidWYpIHsKICAgICAgICB2YXIgbGVuID0gYnVmLmxlbmd0aDsKICAgICAgICB3aGlsZSAoLS1sZW4gPj0gMCkgewogICAgICAgICAgYnVmW2xlbl0gPSAwOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBmbHVzaF9wZW5kaW5nKHN0cm0pIHsKICAgICAgICB2YXIgcyA9IHN0cm0uc3RhdGU7CiAgICAgICAgdmFyIGxlbiA9IHMucGVuZGluZzsKICAgICAgICBpZiAobGVuID4gc3RybS5hdmFpbF9vdXQpIHsKICAgICAgICAgIGxlbiA9IHN0cm0uYXZhaWxfb3V0OwogICAgICAgIH0KICAgICAgICBpZiAobGVuID09PSAwKSB7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmdfb3V0LCBsZW4sIHN0cm0ubmV4dF9vdXQpOwogICAgICAgIHN0cm0ubmV4dF9vdXQgKz0gbGVuOwogICAgICAgIHMucGVuZGluZ19vdXQgKz0gbGVuOwogICAgICAgIHN0cm0udG90YWxfb3V0ICs9IGxlbjsKICAgICAgICBzdHJtLmF2YWlsX291dCAtPSBsZW47CiAgICAgICAgcy5wZW5kaW5nIC09IGxlbjsKICAgICAgICBpZiAocy5wZW5kaW5nID09PSAwKSB7CiAgICAgICAgICBzLnBlbmRpbmdfb3V0ID0gMDsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZmx1c2hfYmxvY2tfb25seShzLCBsYXN0KSB7CiAgICAgICAgdHJlZXMuX3RyX2ZsdXNoX2Jsb2NrKHMsIHMuYmxvY2tfc3RhcnQgPj0gMCA/IHMuYmxvY2tfc3RhcnQgOiAtMSwgcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQsIGxhc3QpOwogICAgICAgIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0OwogICAgICAgIGZsdXNoX3BlbmRpbmcocy5zdHJtKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwdXRfYnl0ZShzLCBiKSB7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHB1dFNob3J0TVNCKHMsIGIpIHsKICAgICAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGIgPj4+IDggJiAyNTU7CiAgICAgICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiICYgMjU1OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHJlYWRfYnVmKHN0cm0sIGJ1Ziwgc3RhcnQsIHNpemUpIHsKICAgICAgICB2YXIgbGVuID0gc3RybS5hdmFpbF9pbjsKICAgICAgICBpZiAobGVuID4gc2l6ZSkgewogICAgICAgICAgbGVuID0gc2l6ZTsKICAgICAgICB9CiAgICAgICAgaWYgKGxlbiA9PT0gMCkgewogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgfQogICAgICAgIHN0cm0uYXZhaWxfaW4gLT0gbGVuOwogICAgICAgIHV0aWxzLmFycmF5U2V0KGJ1Ziwgc3RybS5pbnB1dCwgc3RybS5uZXh0X2luLCBsZW4sIHN0YXJ0KTsKICAgICAgICBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAxKSB7CiAgICAgICAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpOwogICAgICAgIH0gZWxzZSBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAyKSB7CiAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTsKICAgICAgICB9CiAgICAgICAgc3RybS5uZXh0X2luICs9IGxlbjsKICAgICAgICBzdHJtLnRvdGFsX2luICs9IGxlbjsKICAgICAgICByZXR1cm4gbGVuOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGxvbmdlc3RfbWF0Y2gocywgY3VyX21hdGNoKSB7CiAgICAgICAgdmFyIGNoYWluX2xlbmd0aCA9IHMubWF4X2NoYWluX2xlbmd0aDsKICAgICAgICB2YXIgc2NhbiA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgdmFyIG1hdGNoOwogICAgICAgIHZhciBsZW47CiAgICAgICAgdmFyIGJlc3RfbGVuID0gcy5wcmV2X2xlbmd0aDsKICAgICAgICB2YXIgbmljZV9tYXRjaCA9IHMubmljZV9tYXRjaDsKICAgICAgICB2YXIgbGltaXQgPSBzLnN0cnN0YXJ0ID4gcy53X3NpemUgLSBNSU5fTE9PS0FIRUFEID8gcy5zdHJzdGFydCAtIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIDogMDsKICAgICAgICB2YXIgX3dpbiA9IHMud2luZG93OwogICAgICAgIHZhciB3bWFzayA9IHMud19tYXNrOwogICAgICAgIHZhciBwcmV2ID0gcy5wcmV2OwogICAgICAgIHZhciBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIOwogICAgICAgIHZhciBzY2FuX2VuZDEgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdOwogICAgICAgIHZhciBzY2FuX2VuZCA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTsKICAgICAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBzLmdvb2RfbWF0Y2gpIHsKICAgICAgICAgIGNoYWluX2xlbmd0aCA+Pj0gMjsKICAgICAgICB9CiAgICAgICAgaWYgKG5pY2VfbWF0Y2ggPiBzLmxvb2thaGVhZCkgewogICAgICAgICAgbmljZV9tYXRjaCA9IHMubG9va2FoZWFkOwogICAgICAgIH0KICAgICAgICBkbyB7CiAgICAgICAgICBtYXRjaCA9IGN1cl9tYXRjaDsKICAgICAgICAgIGlmIChfd2luW21hdGNoICsgYmVzdF9sZW5dICE9PSBzY2FuX2VuZCB8fCBfd2luW21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPT0gc2Nhbl9lbmQxIHx8IF93aW5bbWF0Y2hdICE9PSBfd2luW3NjYW5dIHx8IF93aW5bKyttYXRjaF0gIT09IF93aW5bc2NhbiArIDFdKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgc2NhbiArPSAyOwogICAgICAgICAgbWF0Y2grKzsKICAgICAgICAgIGRvIHsKICAgICAgICAgIH0gd2hpbGUgKF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgc2NhbiA8IHN0cmVuZCk7CiAgICAgICAgICBsZW4gPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7CiAgICAgICAgICBzY2FuID0gc3RyZW5kIC0gTUFYX01BVENIOwogICAgICAgICAgaWYgKGxlbiA+IGJlc3RfbGVuKSB7CiAgICAgICAgICAgIHMubWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7CiAgICAgICAgICAgIGJlc3RfbGVuID0gbGVuOwogICAgICAgICAgICBpZiAobGVuID49IG5pY2VfbWF0Y2gpIHsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgICBzY2FuX2VuZDEgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdOwogICAgICAgICAgICBzY2FuX2VuZCA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTsKICAgICAgICAgIH0KICAgICAgICB9IHdoaWxlICgoY3VyX21hdGNoID0gcHJldltjdXJfbWF0Y2ggJiB3bWFza10pID4gbGltaXQgJiYgLS1jaGFpbl9sZW5ndGggIT09IDApOwogICAgICAgIGlmIChiZXN0X2xlbiA8PSBzLmxvb2thaGVhZCkgewogICAgICAgICAgcmV0dXJuIGJlc3RfbGVuOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcy5sb29rYWhlYWQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZmlsbF93aW5kb3cocykgewogICAgICAgIHZhciBfd19zaXplID0gcy53X3NpemU7CiAgICAgICAgdmFyIHAsIG4sIG0sIG1vcmUsIHN0cjsKICAgICAgICBkbyB7CiAgICAgICAgICBtb3JlID0gcy53aW5kb3dfc2l6ZSAtIHMubG9va2FoZWFkIC0gcy5zdHJzdGFydDsKICAgICAgICAgIGlmIChzLnN0cnN0YXJ0ID49IF93X3NpemUgKyAoX3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7CiAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KHMud2luZG93LCBzLndpbmRvdywgX3dfc2l6ZSwgX3dfc2l6ZSwgMCk7CiAgICAgICAgICAgIHMubWF0Y2hfc3RhcnQgLT0gX3dfc2l6ZTsKICAgICAgICAgICAgcy5zdHJzdGFydCAtPSBfd19zaXplOwogICAgICAgICAgICBzLmJsb2NrX3N0YXJ0IC09IF93X3NpemU7CiAgICAgICAgICAgIG4gPSBzLmhhc2hfc2l6ZTsKICAgICAgICAgICAgcCA9IG47CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBtID0gcy5oZWFkWy0tcF07CiAgICAgICAgICAgICAgcy5oZWFkW3BdID0gbSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwOwogICAgICAgICAgICB9IHdoaWxlICgtLW4pOwogICAgICAgICAgICBuID0gX3dfc2l6ZTsKICAgICAgICAgICAgcCA9IG47CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBtID0gcy5wcmV2Wy0tcF07CiAgICAgICAgICAgICAgcy5wcmV2W3BdID0gbSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwOwogICAgICAgICAgICB9IHdoaWxlICgtLW4pOwogICAgICAgICAgICBtb3JlICs9IF93X3NpemU7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX2luID09PSAwKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgbiA9IHJlYWRfYnVmKHMuc3RybSwgcy53aW5kb3csIHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCwgbW9yZSk7CiAgICAgICAgICBzLmxvb2thaGVhZCArPSBuOwogICAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPj0gTUlOX01BVENIKSB7CiAgICAgICAgICAgIHN0ciA9IHMuc3Ryc3RhcnQgLSBzLmluc2VydDsKICAgICAgICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07CiAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzdHIgKyAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgd2hpbGUgKHMuaW5zZXJ0KSB7CiAgICAgICAgICAgICAgcy5pbnNfaCA9IChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrOwogICAgICAgICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07CiAgICAgICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyOwogICAgICAgICAgICAgIHN0cisrOwogICAgICAgICAgICAgIHMuaW5zZXJ0LS07CiAgICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPCBNSU5fTUFUQ0gpIHsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gd2hpbGUgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzLnN0cm0uYXZhaWxfaW4gIT09IDApOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVfc3RvcmVkKHMsIGZsdXNoKSB7CiAgICAgICAgdmFyIG1heF9ibG9ja19zaXplID0gNjU1MzU7CiAgICAgICAgaWYgKG1heF9ibG9ja19zaXplID4gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNSkgewogICAgICAgICAgbWF4X2Jsb2NrX3NpemUgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSA1OwogICAgICAgIH0KICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA8PSAxKSB7CiAgICAgICAgICAgIGZpbGxfd2luZG93KHMpOwogICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDAgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkOwogICAgICAgICAgcy5sb29rYWhlYWQgPSAwOwogICAgICAgICAgdmFyIG1heF9zdGFydCA9IHMuYmxvY2tfc3RhcnQgKyBtYXhfYmxvY2tfc2l6ZTsKICAgICAgICAgIGlmIChzLnN0cnN0YXJ0ID09PSAwIHx8IHMuc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7CiAgICAgICAgICAgIHMubG9va2FoZWFkID0gcy5zdHJzdGFydCAtIG1heF9zdGFydDsKICAgICAgICAgICAgcy5zdHJzdGFydCA9IG1heF9zdGFydDsKICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0ID49IHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgewogICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHMuaW5zZXJ0ID0gMDsKICAgICAgICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FOwogICAgICAgIH0KICAgICAgICBpZiAocy5zdHJzdGFydCA+IHMuYmxvY2tfc3RhcnQpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlX2Zhc3QocywgZmx1c2gpIHsKICAgICAgICB2YXIgaGFzaF9oZWFkOwogICAgICAgIHZhciBiZmx1c2g7CiAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7CiAgICAgICAgICAgIGZpbGxfd2luZG93KHMpOwogICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaGFzaF9oZWFkID0gMDsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICAgICAgcy5pbnNfaCA9IChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07CiAgICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoaGFzaF9oZWFkICE9PSAwICYmIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gcy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB7CiAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkgewogICAgICAgICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTsKICAgICAgICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7CiAgICAgICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSBzLm1heF9sYXp5X21hdGNoICYmIHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkgewogICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoLS07CiAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgcy5zdHJzdGFydCsrOwogICAgICAgICAgICAgICAgcy5pbnNfaCA9IChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdOwogICAgICAgICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDsKICAgICAgICAgICAgICB9IHdoaWxlICgtLXMubWF0Y2hfbGVuZ3RoICE9PSAwKTsKICAgICAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDsKICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7CiAgICAgICAgICAgICAgcy5pbnNfaCA9IHMud2luZG93W3Muc3Ryc3RhcnRdOwogICAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7CiAgICAgICAgICAgIHMubG9va2FoZWFkLS07CiAgICAgICAgICAgIHMuc3Ryc3RhcnQrKzsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChiZmx1c2gpIHsKICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0ggLSAxID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDE7CiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTsKICAgICAgICB9CiAgICAgICAgaWYgKHMubGFzdF9saXQpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZV9zbG93KHMsIGZsdXNoKSB7CiAgICAgICAgdmFyIGhhc2hfaGVhZDsKICAgICAgICB2YXIgYmZsdXNoOwogICAgICAgIHZhciBtYXhfaW5zZXJ0OwogICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkgewogICAgICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGhhc2hfaGVhZCA9IDA7CiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7CiAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7CiAgICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdOwogICAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0OwogICAgICAgICAgfQogICAgICAgICAgcy5wcmV2X2xlbmd0aCA9IHMubWF0Y2hfbGVuZ3RoOwogICAgICAgICAgcy5wcmV2X21hdGNoID0gcy5tYXRjaF9zdGFydDsKICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTsKICAgICAgICAgIGlmIChoYXNoX2hlYWQgIT09IDAgJiYgcy5wcmV2X2xlbmd0aCA8IHMubWF4X2xhenlfbWF0Y2ggJiYgcy5zdHJzdGFydCAtIGhhc2hfaGVhZCA8PSBzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHsKICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7CiAgICAgICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSA1ICYmIChzLnN0cmF0ZWd5ID09PSBaX0ZJTFRFUkVEIHx8IHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQgPiA0MDk2KSkgewogICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHMucHJldl9sZW5ndGggPj0gTUlOX01BVENIICYmIHMubWF0Y2hfbGVuZ3RoIDw9IHMucHJldl9sZW5ndGgpIHsKICAgICAgICAgICAgbWF4X2luc2VydCA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCAtIE1JTl9NQVRDSDsKICAgICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENIKTsKICAgICAgICAgICAgcy5sb29rYWhlYWQgLT0gcy5wcmV2X2xlbmd0aCAtIDE7CiAgICAgICAgICAgIHMucHJldl9sZW5ndGggLT0gMjsKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIGlmICgrK3Muc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkgewogICAgICAgICAgICAgICAgcy5pbnNfaCA9IChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdOwogICAgICAgICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gd2hpbGUgKC0tcy5wcmV2X2xlbmd0aCAhPT0gMCk7CiAgICAgICAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDsKICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxOwogICAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICAgIGlmIChiZmx1c2gpIHsKICAgICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHsKICAgICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7CiAgICAgICAgICAgIGlmIChiZmx1c2gpIHsKICAgICAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICAgIHMubG9va2FoZWFkLS07CiAgICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAxOwogICAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICAgIHMubG9va2FoZWFkLS07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkgewogICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7CiAgICAgICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7CiAgICAgICAgfQogICAgICAgIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSCAtIDEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMTsKICAgICAgICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FOwogICAgICAgIH0KICAgICAgICBpZiAocy5sYXN0X2xpdCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gQlNfQkxPQ0tfRE9ORTsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlX3JsZShzLCBmbHVzaCkgewogICAgICAgIHZhciBiZmx1c2g7CiAgICAgICAgdmFyIHByZXY7CiAgICAgICAgdmFyIHNjYW4sIHN0cmVuZDsKICAgICAgICB2YXIgX3dpbiA9IHMud2luZG93OwogICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCkgewogICAgICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCA+IDApIHsKICAgICAgICAgICAgc2NhbiA9IHMuc3Ryc3RhcnQgLSAxOwogICAgICAgICAgICBwcmV2ID0gX3dpbltzY2FuXTsKICAgICAgICAgICAgaWYgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dKSB7CiAgICAgICAgICAgICAgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDsKICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgfSB3aGlsZSAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBzY2FuIDwgc3RyZW5kKTsKICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTsKICAgICAgICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPiBzLmxvb2thaGVhZCkgewogICAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLmxvb2thaGVhZDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTsKICAgICAgICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7CiAgICAgICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7CiAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7CiAgICAgICAgICAgIHMubG9va2FoZWFkLS07CiAgICAgICAgICAgIHMuc3Ryc3RhcnQrKzsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChiZmx1c2gpIHsKICAgICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7CiAgICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzLmluc2VydCA9IDA7CiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkgewogICAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTsKICAgICAgICB9CiAgICAgICAgaWYgKHMubGFzdF9saXQpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSB7CiAgICAgICAgdmFyIGJmbHVzaDsKICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgewogICAgICAgICAgICBmaWxsX3dpbmRvdyhzKTsKICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7CiAgICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwOwogICAgICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTsKICAgICAgICAgIHMubG9va2FoZWFkLS07CiAgICAgICAgICBzLnN0cnN0YXJ0Kys7CiAgICAgICAgICBpZiAoYmZsdXNoKSB7CiAgICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpOwogICAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcy5pbnNlcnQgPSAwOwogICAgICAgIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHsKICAgICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7CiAgICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7CiAgICAgICAgfQogICAgICAgIGlmIChzLmxhc3RfbGl0KSB7CiAgICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTsKICAgICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBCU19CTE9DS19ET05FOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIENvbmZpZyhnb29kX2xlbmd0aCwgbWF4X2xhenksIG5pY2VfbGVuZ3RoLCBtYXhfY2hhaW4sIGZ1bmMpIHsKICAgICAgICB0aGlzLmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7CiAgICAgICAgdGhpcy5tYXhfbGF6eSA9IG1heF9sYXp5OwogICAgICAgIHRoaXMubmljZV9sZW5ndGggPSBuaWNlX2xlbmd0aDsKICAgICAgICB0aGlzLm1heF9jaGFpbiA9IG1heF9jaGFpbjsKICAgICAgICB0aGlzLmZ1bmMgPSBmdW5jOwogICAgICB9CiAgICAgIHZhciBjb25maWd1cmF0aW9uX3RhYmxlOwogICAgICBjb25maWd1cmF0aW9uX3RhYmxlID0gWwogICAgICAgIG5ldyBDb25maWcoMCwgMCwgMCwgMCwgZGVmbGF0ZV9zdG9yZWQpLAogICAgICAgIG5ldyBDb25maWcoNCwgNCwgOCwgNCwgZGVmbGF0ZV9mYXN0KSwKICAgICAgICBuZXcgQ29uZmlnKDQsIDUsIDE2LCA4LCBkZWZsYXRlX2Zhc3QpLAogICAgICAgIG5ldyBDb25maWcoNCwgNiwgMzIsIDMyLCBkZWZsYXRlX2Zhc3QpLAogICAgICAgIG5ldyBDb25maWcoNCwgNCwgMTYsIDE2LCBkZWZsYXRlX3Nsb3cpLAogICAgICAgIG5ldyBDb25maWcoOCwgMTYsIDMyLCAzMiwgZGVmbGF0ZV9zbG93KSwKICAgICAgICBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgZGVmbGF0ZV9zbG93KSwKICAgICAgICBuZXcgQ29uZmlnKDgsIDMyLCAxMjgsIDI1NiwgZGVmbGF0ZV9zbG93KSwKICAgICAgICBuZXcgQ29uZmlnKDMyLCAxMjgsIDI1OCwgMTAyNCwgZGVmbGF0ZV9zbG93KSwKICAgICAgICBuZXcgQ29uZmlnKDMyLCAyNTgsIDI1OCwgNDA5NiwgZGVmbGF0ZV9zbG93KQogICAgICBdOwogICAgICBmdW5jdGlvbiBsbV9pbml0KHMpIHsKICAgICAgICBzLndpbmRvd19zaXplID0gMiAqIHMud19zaXplOwogICAgICAgIHplcm8ocy5oZWFkKTsKICAgICAgICBzLm1heF9sYXp5X21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfbGF6eTsKICAgICAgICBzLmdvb2RfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmdvb2RfbGVuZ3RoOwogICAgICAgIHMubmljZV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubmljZV9sZW5ndGg7CiAgICAgICAgcy5tYXhfY2hhaW5fbGVuZ3RoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfY2hhaW47CiAgICAgICAgcy5zdHJzdGFydCA9IDA7CiAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7CiAgICAgICAgcy5sb29rYWhlYWQgPSAwOwogICAgICAgIHMuaW5zZXJ0ID0gMDsKICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxOwogICAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDsKICAgICAgICBzLmluc19oID0gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBEZWZsYXRlU3RhdGUoKSB7CiAgICAgICAgdGhpcy5zdHJtID0gbnVsbDsKICAgICAgICB0aGlzLnN0YXR1cyA9IDA7CiAgICAgICAgdGhpcy5wZW5kaW5nX2J1ZiA9IG51bGw7CiAgICAgICAgdGhpcy5wZW5kaW5nX2J1Zl9zaXplID0gMDsKICAgICAgICB0aGlzLnBlbmRpbmdfb3V0ID0gMDsKICAgICAgICB0aGlzLnBlbmRpbmcgPSAwOwogICAgICAgIHRoaXMud3JhcCA9IDA7CiAgICAgICAgdGhpcy5nemhlYWQgPSBudWxsOwogICAgICAgIHRoaXMuZ3ppbmRleCA9IDA7CiAgICAgICAgdGhpcy5tZXRob2QgPSBaX0RFRkxBVEVEOwogICAgICAgIHRoaXMubGFzdF9mbHVzaCA9IC0xOwogICAgICAgIHRoaXMud19zaXplID0gMDsKICAgICAgICB0aGlzLndfYml0cyA9IDA7CiAgICAgICAgdGhpcy53X21hc2sgPSAwOwogICAgICAgIHRoaXMud2luZG93ID0gbnVsbDsKICAgICAgICB0aGlzLndpbmRvd19zaXplID0gMDsKICAgICAgICB0aGlzLnByZXYgPSBudWxsOwogICAgICAgIHRoaXMuaGVhZCA9IG51bGw7CiAgICAgICAgdGhpcy5pbnNfaCA9IDA7CiAgICAgICAgdGhpcy5oYXNoX3NpemUgPSAwOwogICAgICAgIHRoaXMuaGFzaF9iaXRzID0gMDsKICAgICAgICB0aGlzLmhhc2hfbWFzayA9IDA7CiAgICAgICAgdGhpcy5oYXNoX3NoaWZ0ID0gMDsKICAgICAgICB0aGlzLmJsb2NrX3N0YXJ0ID0gMDsKICAgICAgICB0aGlzLm1hdGNoX2xlbmd0aCA9IDA7CiAgICAgICAgdGhpcy5wcmV2X21hdGNoID0gMDsKICAgICAgICB0aGlzLm1hdGNoX2F2YWlsYWJsZSA9IDA7CiAgICAgICAgdGhpcy5zdHJzdGFydCA9IDA7CiAgICAgICAgdGhpcy5tYXRjaF9zdGFydCA9IDA7CiAgICAgICAgdGhpcy5sb29rYWhlYWQgPSAwOwogICAgICAgIHRoaXMucHJldl9sZW5ndGggPSAwOwogICAgICAgIHRoaXMubWF4X2NoYWluX2xlbmd0aCA9IDA7CiAgICAgICAgdGhpcy5tYXhfbGF6eV9tYXRjaCA9IDA7CiAgICAgICAgdGhpcy5sZXZlbCA9IDA7CiAgICAgICAgdGhpcy5zdHJhdGVneSA9IDA7CiAgICAgICAgdGhpcy5nb29kX21hdGNoID0gMDsKICAgICAgICB0aGlzLm5pY2VfbWF0Y2ggPSAwOwogICAgICAgIHRoaXMuZHluX2x0cmVlID0gbmV3IHV0aWxzLkJ1ZjE2KEhFQVBfU0laRSAqIDIpOwogICAgICAgIHRoaXMuZHluX2R0cmVlID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogRF9DT0RFUyArIDEpICogMik7CiAgICAgICAgdGhpcy5ibF90cmVlID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogQkxfQ09ERVMgKyAxKSAqIDIpOwogICAgICAgIHplcm8odGhpcy5keW5fbHRyZWUpOwogICAgICAgIHplcm8odGhpcy5keW5fZHRyZWUpOwogICAgICAgIHplcm8odGhpcy5ibF90cmVlKTsKICAgICAgICB0aGlzLmxfZGVzYyA9IG51bGw7CiAgICAgICAgdGhpcy5kX2Rlc2MgPSBudWxsOwogICAgICAgIHRoaXMuYmxfZGVzYyA9IG51bGw7CiAgICAgICAgdGhpcy5ibF9jb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhfQklUUyArIDEpOwogICAgICAgIHRoaXMuaGVhcCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOwogICAgICAgIHplcm8odGhpcy5oZWFwKTsKICAgICAgICB0aGlzLmhlYXBfbGVuID0gMDsKICAgICAgICB0aGlzLmhlYXBfbWF4ID0gMDsKICAgICAgICB0aGlzLmRlcHRoID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7CiAgICAgICAgemVybyh0aGlzLmRlcHRoKTsKICAgICAgICB0aGlzLmxfYnVmID0gMDsKICAgICAgICB0aGlzLmxpdF9idWZzaXplID0gMDsKICAgICAgICB0aGlzLmxhc3RfbGl0ID0gMDsKICAgICAgICB0aGlzLmRfYnVmID0gMDsKICAgICAgICB0aGlzLm9wdF9sZW4gPSAwOwogICAgICAgIHRoaXMuc3RhdGljX2xlbiA9IDA7CiAgICAgICAgdGhpcy5tYXRjaGVzID0gMDsKICAgICAgICB0aGlzLmluc2VydCA9IDA7CiAgICAgICAgdGhpcy5iaV9idWYgPSAwOwogICAgICAgIHRoaXMuYmlfdmFsaWQgPSAwOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVSZXNldEtlZXAoc3RybSkgewogICAgICAgIHZhciBzOwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7CiAgICAgICAgfQogICAgICAgIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IDA7CiAgICAgICAgc3RybS5kYXRhX3R5cGUgPSBaX1VOS05PV047CiAgICAgICAgcyA9IHN0cm0uc3RhdGU7CiAgICAgICAgcy5wZW5kaW5nID0gMDsKICAgICAgICBzLnBlbmRpbmdfb3V0ID0gMDsKICAgICAgICBpZiAocy53cmFwIDwgMCkgewogICAgICAgICAgcy53cmFwID0gLXMud3JhcDsKICAgICAgICB9CiAgICAgICAgcy5zdGF0dXMgPSBzLndyYXAgPyBJTklUX1NUQVRFIDogQlVTWV9TVEFURTsKICAgICAgICBzdHJtLmFkbGVyID0gcy53cmFwID09PSAyID8gMCA6IDE7CiAgICAgICAgcy5sYXN0X2ZsdXNoID0gWl9OT19GTFVTSDsKICAgICAgICB0cmVlcy5fdHJfaW5pdChzKTsKICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlUmVzZXQoc3RybSkgewogICAgICAgIHZhciByZXQgPSBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pOwogICAgICAgIGlmIChyZXQgPT09IFpfT0spIHsKICAgICAgICAgIGxtX2luaXQoc3RybS5zdGF0ZSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZVNldEhlYWRlcihzdHJtLCBoZWFkKSB7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIGlmIChzdHJtLnN0YXRlLndyYXAgIT09IDIpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RybS5zdGF0ZS5nemhlYWQgPSBoZWFkOwogICAgICAgIHJldHVybiBaX09LOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgbWV0aG9kLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3kpIHsKICAgICAgICBpZiAoIXN0cm0pIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgdmFyIHdyYXAgPSAxOwogICAgICAgIGlmIChsZXZlbCA9PT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKSB7CiAgICAgICAgICBsZXZlbCA9IDY7CiAgICAgICAgfQogICAgICAgIGlmICh3aW5kb3dCaXRzIDwgMCkgewogICAgICAgICAgd3JhcCA9IDA7CiAgICAgICAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7CiAgICAgICAgfSBlbHNlIGlmICh3aW5kb3dCaXRzID4gMTUpIHsKICAgICAgICAgIHdyYXAgPSAyOwogICAgICAgICAgd2luZG93Qml0cyAtPSAxNjsKICAgICAgICB9CiAgICAgICAgaWYgKG1lbUxldmVsIDwgMSB8fCBtZW1MZXZlbCA+IE1BWF9NRU1fTEVWRUwgfHwgbWV0aG9kICE9PSBaX0RFRkxBVEVEIHx8IHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSB8fCBsZXZlbCA8IDAgfHwgbGV2ZWwgPiA5IHx8IHN0cmF0ZWd5IDwgMCB8fCBzdHJhdGVneSA+IFpfRklYRUQpIHsKICAgICAgICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpOwogICAgICAgIH0KICAgICAgICBpZiAod2luZG93Qml0cyA9PT0gOCkgewogICAgICAgICAgd2luZG93Qml0cyA9IDk7CiAgICAgICAgfQogICAgICAgIHZhciBzID0gbmV3IERlZmxhdGVTdGF0ZSgpOwogICAgICAgIHN0cm0uc3RhdGUgPSBzOwogICAgICAgIHMuc3RybSA9IHN0cm07CiAgICAgICAgcy53cmFwID0gd3JhcDsKICAgICAgICBzLmd6aGVhZCA9IG51bGw7CiAgICAgICAgcy53X2JpdHMgPSB3aW5kb3dCaXRzOwogICAgICAgIHMud19zaXplID0gMSA8PCBzLndfYml0czsKICAgICAgICBzLndfbWFzayA9IHMud19zaXplIC0gMTsKICAgICAgICBzLmhhc2hfYml0cyA9IG1lbUxldmVsICsgNzsKICAgICAgICBzLmhhc2hfc2l6ZSA9IDEgPDwgcy5oYXNoX2JpdHM7CiAgICAgICAgcy5oYXNoX21hc2sgPSBzLmhhc2hfc2l6ZSAtIDE7CiAgICAgICAgcy5oYXNoX3NoaWZ0ID0gfn4oKHMuaGFzaF9iaXRzICsgTUlOX01BVENIIC0gMSkgLyBNSU5fTUFUQ0gpOwogICAgICAgIHMud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUgKiAyKTsKICAgICAgICBzLmhlYWQgPSBuZXcgdXRpbHMuQnVmMTYocy5oYXNoX3NpemUpOwogICAgICAgIHMucHJldiA9IG5ldyB1dGlscy5CdWYxNihzLndfc2l6ZSk7CiAgICAgICAgcy5saXRfYnVmc2l6ZSA9IDEgPDwgbWVtTGV2ZWwgKyA2OwogICAgICAgIHMucGVuZGluZ19idWZfc2l6ZSA9IHMubGl0X2J1ZnNpemUgKiA0OwogICAgICAgIHMucGVuZGluZ19idWYgPSBuZXcgdXRpbHMuQnVmOChzLnBlbmRpbmdfYnVmX3NpemUpOwogICAgICAgIHMuZF9idWYgPSAxICogcy5saXRfYnVmc2l6ZTsKICAgICAgICBzLmxfYnVmID0gKDEgKyAyKSAqIHMubGl0X2J1ZnNpemU7CiAgICAgICAgcy5sZXZlbCA9IGxldmVsOwogICAgICAgIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTsKICAgICAgICBzLm1ldGhvZCA9IG1ldGhvZDsKICAgICAgICByZXR1cm4gZGVmbGF0ZVJlc2V0KHN0cm0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGVJbml0KHN0cm0sIGxldmVsKSB7CiAgICAgICAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCwgTUFYX1dCSVRTLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlZmxhdGUoc3RybSwgZmx1c2gpIHsKICAgICAgICB2YXIgb2xkX2ZsdXNoLCBzOwogICAgICAgIHZhciBiZWcsIHZhbDsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHwgZmx1c2ggPiBaX0JMT0NLIHx8IGZsdXNoIDwgMCkgewogICAgICAgICAgcmV0dXJuIHN0cm0gPyBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpIDogWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHMgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmICghc3RybS5vdXRwdXQgfHwgIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIGZsdXNoICE9PSBaX0ZJTklTSCkgewogICAgICAgICAgcmV0dXJuIGVycihzdHJtLCBzdHJtLmF2YWlsX291dCA9PT0gMCA/IFpfQlVGX0VSUk9SIDogWl9TVFJFQU1fRVJST1IpOwogICAgICAgIH0KICAgICAgICBzLnN0cm0gPSBzdHJtOwogICAgICAgIG9sZF9mbHVzaCA9IHMubGFzdF9mbHVzaDsKICAgICAgICBzLmxhc3RfZmx1c2ggPSBmbHVzaDsKICAgICAgICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHsKICAgICAgICAgIGlmIChzLndyYXAgPT09IDIpIHsKICAgICAgICAgICAgc3RybS5hZGxlciA9IDA7CiAgICAgICAgICAgIHB1dF9ieXRlKHMsIDMxKTsKICAgICAgICAgICAgcHV0X2J5dGUocywgMTM5KTsKICAgICAgICAgICAgcHV0X2J5dGUocywgOCk7CiAgICAgICAgICAgIGlmICghcy5nemhlYWQpIHsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCAwKTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCAwKTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCAwKTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCAwKTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCAwKTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6IHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgPyA0IDogMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgT1NfQ09ERSk7CiAgICAgICAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50ZXh0ID8gMSA6IDApICsgKHMuZ3poZWFkLmhjcmMgPyAyIDogMCkgKyAoIXMuZ3poZWFkLmV4dHJhID8gMCA6IDQpICsgKCFzLmd6aGVhZC5uYW1lID8gMCA6IDgpICsgKCFzLmd6aGVhZC5jb21tZW50ID8gMCA6IDE2KSk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSAmIDI1NSk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSA+PiA4ICYgMjU1KTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lID4+IDE2ICYgMjU1KTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lID4+IDI0ICYgMjU1KTsKICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6IHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgPyA0IDogMCk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQub3MgJiAyNTUpOwogICAgICAgICAgICAgIGlmIChzLmd6aGVhZC5leHRyYSAmJiBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDI1NSk7CiAgICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggPj4gOCAmIDI1NSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7CiAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nLCAwKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcy5nemluZGV4ID0gMDsKICAgICAgICAgICAgICBzLnN0YXR1cyA9IEVYVFJBX1NUQVRFOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB2YXIgaGVhZGVyID0gWl9ERUZMQVRFRCArIChzLndfYml0cyAtIDggPDwgNCkgPDwgODsKICAgICAgICAgICAgdmFyIGxldmVsX2ZsYWdzID0gLTE7CiAgICAgICAgICAgIGlmIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyKSB7CiAgICAgICAgICAgICAgbGV2ZWxfZmxhZ3MgPSAwOwogICAgICAgICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPCA2KSB7CiAgICAgICAgICAgICAgbGV2ZWxfZmxhZ3MgPSAxOwogICAgICAgICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPT09IDYpIHsKICAgICAgICAgICAgICBsZXZlbF9mbGFncyA9IDI7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgbGV2ZWxfZmxhZ3MgPSAzOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGhlYWRlciB8PSBsZXZlbF9mbGFncyA8PCA2OwogICAgICAgICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgewogICAgICAgICAgICAgIGhlYWRlciB8PSBQUkVTRVRfRElDVDsKICAgICAgICAgICAgfQogICAgICAgICAgICBoZWFkZXIgKz0gMzEgLSBoZWFkZXIgJSAzMTsKICAgICAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFOwogICAgICAgICAgICBwdXRTaG9ydE1TQihzLCBoZWFkZXIpOwogICAgICAgICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgewogICAgICAgICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTsKICAgICAgICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgNjU1MzUpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSAxOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocy5zdGF0dXMgPT09IEVYVFJBX1NUQVRFKSB7CiAgICAgICAgICBpZiAocy5nemhlYWQuZXh0cmEpIHsKICAgICAgICAgICAgYmVnID0gcy5wZW5kaW5nOwogICAgICAgICAgICB3aGlsZSAocy5nemluZGV4IDwgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDY1NTM1KSkgewogICAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pOwogICAgICAgICAgICAgICAgYmVnID0gcy5wZW5kaW5nOwogICAgICAgICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYVtzLmd6aW5kZXhdICYgMjU1KTsKICAgICAgICAgICAgICBzLmd6aW5kZXgrKzsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHsKICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzLmd6aW5kZXggPT09IHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkgewogICAgICAgICAgICAgIHMuZ3ppbmRleCA9IDA7CiAgICAgICAgICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChzLnN0YXR1cyA9PT0gTkFNRV9TVEFURSkgewogICAgICAgICAgaWYgKHMuZ3poZWFkLm5hbWUpIHsKICAgICAgICAgICAgYmVnID0gcy5wZW5kaW5nOwogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHsKICAgICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7CiAgICAgICAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7CiAgICAgICAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICAgICAgdmFsID0gMTsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5uYW1lLmxlbmd0aCkgewogICAgICAgICAgICAgICAgdmFsID0gcy5nemhlYWQubmFtZS5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDI1NTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdmFsID0gMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgdmFsKTsKICAgICAgICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTsKICAgICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7CiAgICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodmFsID09PSAwKSB7CiAgICAgICAgICAgICAgcy5nemluZGV4ID0gMDsKICAgICAgICAgICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHMuc3RhdHVzID09PSBDT01NRU5UX1NUQVRFKSB7CiAgICAgICAgICBpZiAocy5nemhlYWQuY29tbWVudCkgewogICAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHsKICAgICAgICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykgewogICAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTsKICAgICAgICAgICAgICAgIGJlZyA9IHMucGVuZGluZzsKICAgICAgICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgICAgICB2YWwgPSAxOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLmNvbW1lbnQubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5jb21tZW50LmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMjU1OwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB2YWwgPSAwOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBwdXRfYnl0ZShzLCB2YWwpOwogICAgICAgICAgICB9IHdoaWxlICh2YWwgIT09IDApOwogICAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHsKICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh2YWwgPT09IDApIHsKICAgICAgICAgICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHMuc3RhdHVzID09PSBIQ1JDX1NUQVRFKSB7CiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYykgewogICAgICAgICAgICBpZiAocy5wZW5kaW5nICsgMiA+IHMucGVuZGluZ19idWZfc2l6ZSkgewogICAgICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHMucGVuZGluZyArIDIgPD0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDI1NSk7CiAgICAgICAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciA+PiA4ICYgMjU1KTsKICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gMDsKICAgICAgICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHMucGVuZGluZyAhPT0gMCkgewogICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTsKICAgICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkgewogICAgICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsKICAgICAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHJhbmsoZmx1c2gpIDw9IHJhbmsob2xkX2ZsdXNoKSAmJiBmbHVzaCAhPT0gWl9GSU5JU0gpIHsKICAgICAgICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpOwogICAgICAgIH0KICAgICAgICBpZiAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB7CiAgICAgICAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTsKICAgICAgICB9CiAgICAgICAgaWYgKHN0cm0uYXZhaWxfaW4gIT09IDAgfHwgcy5sb29rYWhlYWQgIT09IDAgfHwgZmx1c2ggIT09IFpfTk9fRkxVU0ggJiYgcy5zdGF0dXMgIT09IEZJTklTSF9TVEFURSkgewogICAgICAgICAgdmFyIGJzdGF0ZSA9IHMuc3RyYXRlZ3kgPT09IFpfSFVGRk1BTl9PTkxZID8gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSA6IHMuc3RyYXRlZ3kgPT09IFpfUkxFID8gZGVmbGF0ZV9ybGUocywgZmx1c2gpIDogY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5mdW5jKHMsIGZsdXNoKTsKICAgICAgICAgIGlmIChic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX0RPTkUpIHsKICAgICAgICAgICAgcy5zdGF0dXMgPSBGSU5JU0hfU1RBVEU7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYnN0YXRlID09PSBCU19ORUVEX01PUkUgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCkgewogICAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChic3RhdGUgPT09IEJTX0JMT0NLX0RPTkUpIHsKICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX1BBUlRJQUxfRkxVU0gpIHsKICAgICAgICAgICAgICB0cmVlcy5fdHJfYWxpZ24ocyk7CiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmx1c2ggIT09IFpfQkxPQ0spIHsKICAgICAgICAgICAgICB0cmVlcy5fdHJfc3RvcmVkX2Jsb2NrKHMsIDAsIDAsIGZhbHNlKTsKICAgICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfRlVMTF9GTFVTSCkgewogICAgICAgICAgICAgICAgemVybyhzLmhlYWQpOwogICAgICAgICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSAwOwogICAgICAgICAgICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gMDsKICAgICAgICAgICAgICAgICAgcy5pbnNlcnQgPSAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pOwogICAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsKICAgICAgICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAoZmx1c2ggIT09IFpfRklOSVNIKSB7CiAgICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgICB9CiAgICAgICAgaWYgKHMud3JhcCA8PSAwKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRU5EOwogICAgICAgIH0KICAgICAgICBpZiAocy53cmFwID09PSAyKSB7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMjU1KTsKICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgPj4gOCAmIDI1NSk7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyID4+IDE2ICYgMjU1KTsKICAgICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgPj4gMjQgJiAyNTUpOwogICAgICAgICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiAmIDI1NSk7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luID4+IDggJiAyNTUpOwogICAgICAgICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiA+PiAxNiAmIDI1NSk7CiAgICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luID4+IDI0ICYgMjU1KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpOwogICAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDY1NTM1KTsKICAgICAgICB9CiAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTsKICAgICAgICBpZiAocy53cmFwID4gMCkgewogICAgICAgICAgcy53cmFwID0gLXMud3JhcDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHMucGVuZGluZyAhPT0gMCA/IFpfT0sgOiBaX1NUUkVBTV9FTkQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZUVuZChzdHJtKSB7CiAgICAgICAgdmFyIHN0YXR1czsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdHVzID0gc3RybS5zdGF0ZS5zdGF0dXM7CiAgICAgICAgaWYgKHN0YXR1cyAhPT0gSU5JVF9TVEFURSAmJiBzdGF0dXMgIT09IEVYVFJBX1NUQVRFICYmIHN0YXR1cyAhPT0gTkFNRV9TVEFURSAmJiBzdGF0dXMgIT09IENPTU1FTlRfU1RBVEUgJiYgc3RhdHVzICE9PSBIQ1JDX1NUQVRFICYmIHN0YXR1cyAhPT0gQlVTWV9TVEFURSAmJiBzdGF0dXMgIT09IEZJTklTSF9TVEFURSkgewogICAgICAgICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7CiAgICAgICAgfQogICAgICAgIHN0cm0uc3RhdGUgPSBudWxsOwogICAgICAgIHJldHVybiBzdGF0dXMgPT09IEJVU1lfU1RBVEUgPyBlcnIoc3RybSwgWl9EQVRBX0VSUk9SKSA6IFpfT0s7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVmbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkgewogICAgICAgIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7CiAgICAgICAgdmFyIHM7CiAgICAgICAgdmFyIHN0ciwgbjsKICAgICAgICB2YXIgd3JhcDsKICAgICAgICB2YXIgYXZhaWw7CiAgICAgICAgdmFyIG5leHQ7CiAgICAgICAgdmFyIGlucHV0OwogICAgICAgIHZhciB0bXBEaWN0OwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzID0gc3RybS5zdGF0ZTsKICAgICAgICB3cmFwID0gcy53cmFwOwogICAgICAgIGlmICh3cmFwID09PSAyIHx8IHdyYXAgPT09IDEgJiYgcy5zdGF0dXMgIT09IElOSVRfU1RBVEUgfHwgcy5sb29rYWhlYWQpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgaWYgKHdyYXAgPT09IDEpIHsKICAgICAgICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApOwogICAgICAgIH0KICAgICAgICBzLndyYXAgPSAwOwogICAgICAgIGlmIChkaWN0TGVuZ3RoID49IHMud19zaXplKSB7CiAgICAgICAgICBpZiAod3JhcCA9PT0gMCkgewogICAgICAgICAgICB6ZXJvKHMuaGVhZCk7CiAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSAwOwogICAgICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gMDsKICAgICAgICAgICAgcy5pbnNlcnQgPSAwOwogICAgICAgICAgfQogICAgICAgICAgdG1wRGljdCA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplKTsKICAgICAgICAgIHV0aWxzLmFycmF5U2V0KHRtcERpY3QsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGggLSBzLndfc2l6ZSwgcy53X3NpemUsIDApOwogICAgICAgICAgZGljdGlvbmFyeSA9IHRtcERpY3Q7CiAgICAgICAgICBkaWN0TGVuZ3RoID0gcy53X3NpemU7CiAgICAgICAgfQogICAgICAgIGF2YWlsID0gc3RybS5hdmFpbF9pbjsKICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luOwogICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDsKICAgICAgICBzdHJtLmF2YWlsX2luID0gZGljdExlbmd0aDsKICAgICAgICBzdHJtLm5leHRfaW4gPSAwOwogICAgICAgIHN0cm0uaW5wdXQgPSBkaWN0aW9uYXJ5OwogICAgICAgIGZpbGxfd2luZG93KHMpOwogICAgICAgIHdoaWxlIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHsKICAgICAgICAgIHN0ciA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgICBuID0gcy5sb29rYWhlYWQgLSAoTUlOX01BVENIIC0gMSk7CiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIHMuaW5zX2ggPSAocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzazsKICAgICAgICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTsKICAgICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyOwogICAgICAgICAgICBzdHIrKzsKICAgICAgICAgIH0gd2hpbGUgKC0tbik7CiAgICAgICAgICBzLnN0cnN0YXJ0ID0gc3RyOwogICAgICAgICAgcy5sb29rYWhlYWQgPSBNSU5fTUFUQ0ggLSAxOwogICAgICAgICAgZmlsbF93aW5kb3cocyk7CiAgICAgICAgfQogICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7CiAgICAgICAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7CiAgICAgICAgcy5pbnNlcnQgPSBzLmxvb2thaGVhZDsKICAgICAgICBzLmxvb2thaGVhZCA9IDA7CiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTsKICAgICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7CiAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDsKICAgICAgICBzdHJtLmlucHV0ID0gaW5wdXQ7CiAgICAgICAgc3RybS5hdmFpbF9pbiA9IGF2YWlsOwogICAgICAgIHMud3JhcCA9IHdyYXA7CiAgICAgICAgcmV0dXJuIFpfT0s7CiAgICAgIH0KICAgICAgZXhwb3J0czIuZGVmbGF0ZUluaXQgPSBkZWZsYXRlSW5pdDsKICAgICAgZXhwb3J0czIuZGVmbGF0ZUluaXQyID0gZGVmbGF0ZUluaXQyOwogICAgICBleHBvcnRzMi5kZWZsYXRlUmVzZXQgPSBkZWZsYXRlUmVzZXQ7CiAgICAgIGV4cG9ydHMyLmRlZmxhdGVSZXNldEtlZXAgPSBkZWZsYXRlUmVzZXRLZWVwOwogICAgICBleHBvcnRzMi5kZWZsYXRlU2V0SGVhZGVyID0gZGVmbGF0ZVNldEhlYWRlcjsKICAgICAgZXhwb3J0czIuZGVmbGF0ZSA9IGRlZmxhdGU7CiAgICAgIGV4cG9ydHMyLmRlZmxhdGVFbmQgPSBkZWZsYXRlRW5kOwogICAgICBleHBvcnRzMi5kZWZsYXRlU2V0RGljdGlvbmFyeSA9IGRlZmxhdGVTZXREaWN0aW9uYXJ5OwogICAgICBleHBvcnRzMi5kZWZsYXRlSW5mbyA9ICJwYWtvIGRlZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpIjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL3N0cmluZ3MuanMKICB2YXIgcmVxdWlyZV9zdHJpbmdzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL3N0cmluZ3MuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgdXRpbHMgPSByZXF1aXJlX2NvbW1vbigpOwogICAgICB2YXIgU1RSX0FQUExZX09LID0gdHJ1ZTsKICAgICAgdmFyIFNUUl9BUFBMWV9VSUFfT0sgPSB0cnVlOwogICAgICB0cnkgewogICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgWzBdKTsKICAgICAgfSBjYXRjaCAoX18pIHsKICAgICAgICBTVFJfQVBQTFlfT0sgPSBmYWxzZTsKICAgICAgfQogICAgICB0cnkgewogICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoMSkpOwogICAgICB9IGNhdGNoIChfXykgewogICAgICAgIFNUUl9BUFBMWV9VSUFfT0sgPSBmYWxzZTsKICAgICAgfQogICAgICB2YXIgX3V0ZjhsZW4gPSBuZXcgdXRpbHMuQnVmOCgyNTYpOwogICAgICBmb3IgKHEgPSAwOyBxIDwgMjU2OyBxKyspIHsKICAgICAgICBfdXRmOGxlbltxXSA9IHEgPj0gMjUyID8gNiA6IHEgPj0gMjQ4ID8gNSA6IHEgPj0gMjQwID8gNCA6IHEgPj0gMjI0ID8gMyA6IHEgPj0gMTkyID8gMiA6IDE7CiAgICAgIH0KICAgICAgdmFyIHE7CiAgICAgIF91dGY4bGVuWzI1NF0gPSBfdXRmOGxlblsyNTRdID0gMTsKICAgICAgZXhwb3J0czIuc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uKHN0cikgewogICAgICAgIHZhciBidWYsIGMsIGMyLCBtX3BvcywgaSwgc3RyX2xlbiA9IHN0ci5sZW5ndGgsIGJ1Zl9sZW4gPSAwOwogICAgICAgIGZvciAobV9wb3MgPSAwOyBtX3BvcyA8IHN0cl9sZW47IG1fcG9zKyspIHsKICAgICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7CiAgICAgICAgICBpZiAoKGMgJiA2NDUxMikgPT09IDU1Mjk2ICYmIG1fcG9zICsgMSA8IHN0cl9sZW4pIHsKICAgICAgICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpOwogICAgICAgICAgICBpZiAoKGMyICYgNjQ1MTIpID09PSA1NjMyMCkgewogICAgICAgICAgICAgIGMgPSA2NTUzNiArIChjIC0gNTUyOTYgPDwgMTApICsgKGMyIC0gNTYzMjApOwogICAgICAgICAgICAgIG1fcG9zKys7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGJ1Zl9sZW4gKz0gYyA8IDEyOCA/IDEgOiBjIDwgMjA0OCA/IDIgOiBjIDwgNjU1MzYgPyAzIDogNDsKICAgICAgICB9CiAgICAgICAgYnVmID0gbmV3IHV0aWxzLkJ1ZjgoYnVmX2xlbik7CiAgICAgICAgZm9yIChpID0gMCwgbV9wb3MgPSAwOyBpIDwgYnVmX2xlbjsgbV9wb3MrKykgewogICAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTsKICAgICAgICAgIGlmICgoYyAmIDY0NTEyKSA9PT0gNTUyOTYgJiYgbV9wb3MgKyAxIDwgc3RyX2xlbikgewogICAgICAgICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7CiAgICAgICAgICAgIGlmICgoYzIgJiA2NDUxMikgPT09IDU2MzIwKSB7CiAgICAgICAgICAgICAgYyA9IDY1NTM2ICsgKGMgLSA1NTI5NiA8PCAxMCkgKyAoYzIgLSA1NjMyMCk7CiAgICAgICAgICAgICAgbV9wb3MrKzsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKGMgPCAxMjgpIHsKICAgICAgICAgICAgYnVmW2krK10gPSBjOwogICAgICAgICAgfSBlbHNlIGlmIChjIDwgMjA0OCkgewogICAgICAgICAgICBidWZbaSsrXSA9IDE5MiB8IGMgPj4+IDY7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMTI4IHwgYyAmIDYzOwogICAgICAgICAgfSBlbHNlIGlmIChjIDwgNjU1MzYpIHsKICAgICAgICAgICAgYnVmW2krK10gPSAyMjQgfCBjID4+PiAxMjsKICAgICAgICAgICAgYnVmW2krK10gPSAxMjggfCBjID4+PiA2ICYgNjM7CiAgICAgICAgICAgIGJ1ZltpKytdID0gMTI4IHwgYyAmIDYzOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgYnVmW2krK10gPSAyNDAgfCBjID4+PiAxODsKICAgICAgICAgICAgYnVmW2krK10gPSAxMjggfCBjID4+PiAxMiAmIDYzOwogICAgICAgICAgICBidWZbaSsrXSA9IDEyOCB8IGMgPj4+IDYgJiA2MzsKICAgICAgICAgICAgYnVmW2krK10gPSAxMjggfCBjICYgNjM7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBidWY7CiAgICAgIH07CiAgICAgIGZ1bmN0aW9uIGJ1ZjJiaW5zdHJpbmcoYnVmLCBsZW4pIHsKICAgICAgICBpZiAobGVuIDwgNjU1MzQpIHsKICAgICAgICAgIGlmIChidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX1VJQV9PSyB8fCAhYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9PSykgewogICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB1dGlscy5zaHJpbmtCdWYoYnVmLCBsZW4pKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgdmFyIHJlc3VsdCA9ICIiOwogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsKICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgIH0KICAgICAgZXhwb3J0czIuYnVmMmJpbnN0cmluZyA9IGZ1bmN0aW9uKGJ1ZikgewogICAgICAgIHJldHVybiBidWYyYmluc3RyaW5nKGJ1ZiwgYnVmLmxlbmd0aCk7CiAgICAgIH07CiAgICAgIGV4cG9ydHMyLmJpbnN0cmluZzJidWYgPSBmdW5jdGlvbihzdHIpIHsKICAgICAgICB2YXIgYnVmID0gbmV3IHV0aWxzLkJ1Zjgoc3RyLmxlbmd0aCk7CiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkrKykgewogICAgICAgICAgYnVmW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBidWY7CiAgICAgIH07CiAgICAgIGV4cG9ydHMyLmJ1ZjJzdHJpbmcgPSBmdW5jdGlvbihidWYsIG1heCkgewogICAgICAgIHZhciBpLCBvdXQsIGMsIGNfbGVuOwogICAgICAgIHZhciBsZW4gPSBtYXggfHwgYnVmLmxlbmd0aDsKICAgICAgICB2YXIgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuICogMik7CiAgICAgICAgZm9yIChvdXQgPSAwLCBpID0gMDsgaSA8IGxlbjsgKSB7CiAgICAgICAgICBjID0gYnVmW2krK107CiAgICAgICAgICBpZiAoYyA8IDEyOCkgewogICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSBjOwogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIGNfbGVuID0gX3V0ZjhsZW5bY107CiAgICAgICAgICBpZiAoY19sZW4gPiA0KSB7CiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDY1NTMzOwogICAgICAgICAgICBpICs9IGNfbGVuIC0gMTsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgICBjICY9IGNfbGVuID09PSAyID8gMzEgOiBjX2xlbiA9PT0gMyA/IDE1IDogNzsKICAgICAgICAgIHdoaWxlIChjX2xlbiA+IDEgJiYgaSA8IGxlbikgewogICAgICAgICAgICBjID0gYyA8PCA2IHwgYnVmW2krK10gJiA2MzsKICAgICAgICAgICAgY19sZW4tLTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChjX2xlbiA+IDEpIHsKICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gNjU1MzM7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGMgPCA2NTUzNikgewogICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSBjOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgYyAtPSA2NTUzNjsKICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gNTUyOTYgfCBjID4+IDEwICYgMTAyMzsKICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gNTYzMjAgfCBjICYgMTAyMzsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcodXRmMTZidWYsIG91dCk7CiAgICAgIH07CiAgICAgIGV4cG9ydHMyLnV0Zjhib3JkZXIgPSBmdW5jdGlvbihidWYsIG1heCkgewogICAgICAgIHZhciBwb3M7CiAgICAgICAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7CiAgICAgICAgaWYgKG1heCA+IGJ1Zi5sZW5ndGgpIHsKICAgICAgICAgIG1heCA9IGJ1Zi5sZW5ndGg7CiAgICAgICAgfQogICAgICAgIHBvcyA9IG1heCAtIDE7CiAgICAgICAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDE5MikgPT09IDEyOCkgewogICAgICAgICAgcG9zLS07CiAgICAgICAgfQogICAgICAgIGlmIChwb3MgPCAwKSB7CiAgICAgICAgICByZXR1cm4gbWF4OwogICAgICAgIH0KICAgICAgICBpZiAocG9zID09PSAwKSB7CiAgICAgICAgICByZXR1cm4gbWF4OwogICAgICAgIH0KICAgICAgICByZXR1cm4gcG9zICsgX3V0ZjhsZW5bYnVmW3Bvc11dID4gbWF4ID8gcG9zIDogbWF4OwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi96c3RyZWFtLmpzCiAgdmFyIHJlcXVpcmVfenN0cmVhbSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3pzdHJlYW0uanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBmdW5jdGlvbiBaU3RyZWFtKCkgewogICAgICAgIHRoaXMuaW5wdXQgPSBudWxsOwogICAgICAgIHRoaXMubmV4dF9pbiA9IDA7CiAgICAgICAgdGhpcy5hdmFpbF9pbiA9IDA7CiAgICAgICAgdGhpcy50b3RhbF9pbiA9IDA7CiAgICAgICAgdGhpcy5vdXRwdXQgPSBudWxsOwogICAgICAgIHRoaXMubmV4dF9vdXQgPSAwOwogICAgICAgIHRoaXMuYXZhaWxfb3V0ID0gMDsKICAgICAgICB0aGlzLnRvdGFsX291dCA9IDA7CiAgICAgICAgdGhpcy5tc2cgPSAiIjsKICAgICAgICB0aGlzLnN0YXRlID0gbnVsbDsKICAgICAgICB0aGlzLmRhdGFfdHlwZSA9IDI7CiAgICAgICAgdGhpcy5hZGxlciA9IDA7CiAgICAgIH0KICAgICAgbW9kdWxlMi5leHBvcnRzID0gWlN0cmVhbTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL2RlZmxhdGUuanMKICB2YXIgcmVxdWlyZV9kZWZsYXRlMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi9kZWZsYXRlLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIHpsaWJfZGVmbGF0ZSA9IHJlcXVpcmVfZGVmbGF0ZSgpOwogICAgICB2YXIgdXRpbHMgPSByZXF1aXJlX2NvbW1vbigpOwogICAgICB2YXIgc3RyaW5ncyA9IHJlcXVpcmVfc3RyaW5ncygpOwogICAgICB2YXIgbXNnID0gcmVxdWlyZV9tZXNzYWdlcygpOwogICAgICB2YXIgWlN0cmVhbSA9IHJlcXVpcmVfenN0cmVhbSgpOwogICAgICB2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nOwogICAgICB2YXIgWl9OT19GTFVTSCA9IDA7CiAgICAgIHZhciBaX0ZJTklTSCA9IDQ7CiAgICAgIHZhciBaX09LID0gMDsKICAgICAgdmFyIFpfU1RSRUFNX0VORCA9IDE7CiAgICAgIHZhciBaX1NZTkNfRkxVU0ggPSAyOwogICAgICB2YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7CiAgICAgIHZhciBaX0RFRkFVTFRfU1RSQVRFR1kgPSAwOwogICAgICB2YXIgWl9ERUZMQVRFRCA9IDg7CiAgICAgIGZ1bmN0aW9uIERlZmxhdGUob3B0aW9ucykgewogICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEZWZsYXRlKSkKICAgICAgICAgIHJldHVybiBuZXcgRGVmbGF0ZShvcHRpb25zKTsKICAgICAgICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oewogICAgICAgICAgbGV2ZWw6IFpfREVGQVVMVF9DT01QUkVTU0lPTiwKICAgICAgICAgIG1ldGhvZDogWl9ERUZMQVRFRCwKICAgICAgICAgIGNodW5rU2l6ZTogMTYzODQsCiAgICAgICAgICB3aW5kb3dCaXRzOiAxNSwKICAgICAgICAgIG1lbUxldmVsOiA4LAogICAgICAgICAgc3RyYXRlZ3k6IFpfREVGQVVMVF9TVFJBVEVHWSwKICAgICAgICAgIHRvOiAiIgogICAgICAgIH0sIG9wdGlvbnMgfHwge30pOwogICAgICAgIHZhciBvcHQgPSB0aGlzLm9wdGlvbnM7CiAgICAgICAgaWYgKG9wdC5yYXcgJiYgb3B0LndpbmRvd0JpdHMgPiAwKSB7CiAgICAgICAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0czsKICAgICAgICB9IGVsc2UgaWYgKG9wdC5nemlwICYmIG9wdC53aW5kb3dCaXRzID4gMCAmJiBvcHQud2luZG93Qml0cyA8IDE2KSB7CiAgICAgICAgICBvcHQud2luZG93Qml0cyArPSAxNjsKICAgICAgICB9CiAgICAgICAgdGhpcy5lcnIgPSAwOwogICAgICAgIHRoaXMubXNnID0gIiI7CiAgICAgICAgdGhpcy5lbmRlZCA9IGZhbHNlOwogICAgICAgIHRoaXMuY2h1bmtzID0gW107CiAgICAgICAgdGhpcy5zdHJtID0gbmV3IFpTdHJlYW0oKTsKICAgICAgICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDsKICAgICAgICB2YXIgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVJbml0Mih0aGlzLnN0cm0sIG9wdC5sZXZlbCwgb3B0Lm1ldGhvZCwgb3B0LndpbmRvd0JpdHMsIG9wdC5tZW1MZXZlbCwgb3B0LnN0cmF0ZWd5KTsKICAgICAgICBpZiAoc3RhdHVzICE9PSBaX09LKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pOwogICAgICAgIH0KICAgICAgICBpZiAob3B0LmhlYWRlcikgewogICAgICAgICAgemxpYl9kZWZsYXRlLmRlZmxhdGVTZXRIZWFkZXIodGhpcy5zdHJtLCBvcHQuaGVhZGVyKTsKICAgICAgICB9CiAgICAgICAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7CiAgICAgICAgICB2YXIgZGljdDsKICAgICAgICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIGRpY3QgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpOwogICAgICAgICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gIltvYmplY3QgQXJyYXlCdWZmZXJdIikgewogICAgICAgICAgICBkaWN0ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgZGljdCA9IG9wdC5kaWN0aW9uYXJ5OwogICAgICAgICAgfQogICAgICAgICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdCk7CiAgICAgICAgICBpZiAoc3RhdHVzICE9PSBaX09LKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLl9kaWN0X3NldCA9IHRydWU7CiAgICAgICAgfQogICAgICB9CiAgICAgIERlZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihkYXRhLCBtb2RlKSB7CiAgICAgICAgdmFyIHN0cm0gPSB0aGlzLnN0cm07CiAgICAgICAgdmFyIGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7CiAgICAgICAgdmFyIHN0YXR1cywgX21vZGU7CiAgICAgICAgaWYgKHRoaXMuZW5kZWQpIHsKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgICAgX21vZGUgPSBtb2RlID09PSB+fm1vZGUgPyBtb2RlIDogbW9kZSA9PT0gdHJ1ZSA/IFpfRklOSVNIIDogWl9OT19GTFVTSDsKICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKGRhdGEpOwogICAgICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gIltvYmplY3QgQXJyYXlCdWZmZXJdIikgewogICAgICAgICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBzdHJtLmlucHV0ID0gZGF0YTsKICAgICAgICB9CiAgICAgICAgc3RybS5uZXh0X2luID0gMDsKICAgICAgICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7CiAgICAgICAgZG8gewogICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IHV0aWxzLkJ1ZjgoY2h1bmtTaXplKTsKICAgICAgICAgICAgc3RybS5uZXh0X291dCA9IDA7CiAgICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplOwogICAgICAgICAgfQogICAgICAgICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGUoc3RybSwgX21vZGUpOwogICAgICAgICAgaWYgKHN0YXR1cyAhPT0gWl9TVFJFQU1fRU5EICYmIHN0YXR1cyAhPT0gWl9PSykgewogICAgICAgICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7CiAgICAgICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlOwogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgc3RybS5hdmFpbF9pbiA9PT0gMCAmJiAoX21vZGUgPT09IFpfRklOSVNIIHx8IF9tb2RlID09PSBaX1NZTkNfRkxVU0gpKSB7CiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgICAgdGhpcy5vbkRhdGEoc3RyaW5ncy5idWYyYmluc3RyaW5nKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQpOwogICAgICAgIGlmIChfbW9kZSA9PT0gWl9GSU5JU0gpIHsKICAgICAgICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlRW5kKHRoaXMuc3RybSk7CiAgICAgICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7CiAgICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTsKICAgICAgICAgIHJldHVybiBzdGF0dXMgPT09IFpfT0s7CiAgICAgICAgfQogICAgICAgIGlmIChfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIKSB7CiAgICAgICAgICB0aGlzLm9uRW5kKFpfT0spOwogICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSAwOwogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9OwogICAgICBEZWZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihjaHVuaykgewogICAgICAgIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspOwogICAgICB9OwogICAgICBEZWZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uKHN0YXR1cykgewogICAgICAgIGlmIChzdGF0dXMgPT09IFpfT0spIHsKICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbigiIik7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHV0aWxzLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB0aGlzLmNodW5rcyA9IFtdOwogICAgICAgIHRoaXMuZXJyID0gc3RhdHVzOwogICAgICAgIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZzsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucykgewogICAgICAgIHZhciBkZWZsYXRvciA9IG5ldyBEZWZsYXRlKG9wdGlvbnMpOwogICAgICAgIGRlZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpOwogICAgICAgIGlmIChkZWZsYXRvci5lcnIpIHsKICAgICAgICAgIHRocm93IGRlZmxhdG9yLm1zZyB8fCBtc2dbZGVmbGF0b3IuZXJyXTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGRlZmxhdG9yLnJlc3VsdDsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7CiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307CiAgICAgICAgb3B0aW9ucy5yYXcgPSB0cnVlOwogICAgICAgIHJldHVybiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBnemlwKGlucHV0LCBvcHRpb25zKSB7CiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307CiAgICAgICAgb3B0aW9ucy5nemlwID0gdHJ1ZTsKICAgICAgICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7CiAgICAgIH0KICAgICAgZXhwb3J0czIuRGVmbGF0ZSA9IERlZmxhdGU7CiAgICAgIGV4cG9ydHMyLmRlZmxhdGUgPSBkZWZsYXRlOwogICAgICBleHBvcnRzMi5kZWZsYXRlUmF3ID0gZGVmbGF0ZVJhdzsKICAgICAgZXhwb3J0czIuZ3ppcCA9IGd6aXA7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmZhc3QuanMKICB2YXIgcmVxdWlyZV9pbmZmYXN0ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mZmFzdC5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciBCQUQgPSAzMDsKICAgICAgdmFyIFRZUEUgPSAxMjsKICAgICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV9mYXN0KHN0cm0sIHN0YXJ0KSB7CiAgICAgICAgdmFyIHN0YXRlOwogICAgICAgIHZhciBfaW47CiAgICAgICAgdmFyIGxhc3Q7CiAgICAgICAgdmFyIF9vdXQ7CiAgICAgICAgdmFyIGJlZzsKICAgICAgICB2YXIgZW5kOwogICAgICAgIHZhciBkbWF4OwogICAgICAgIHZhciB3c2l6ZTsKICAgICAgICB2YXIgd2hhdmU7CiAgICAgICAgdmFyIHduZXh0OwogICAgICAgIHZhciBzX3dpbmRvdzsKICAgICAgICB2YXIgaG9sZDsKICAgICAgICB2YXIgYml0czsKICAgICAgICB2YXIgbGNvZGU7CiAgICAgICAgdmFyIGRjb2RlOwogICAgICAgIHZhciBsbWFzazsKICAgICAgICB2YXIgZG1hc2s7CiAgICAgICAgdmFyIGhlcmU7CiAgICAgICAgdmFyIG9wOwogICAgICAgIHZhciBsZW47CiAgICAgICAgdmFyIGRpc3Q7CiAgICAgICAgdmFyIGZyb207CiAgICAgICAgdmFyIGZyb21fc291cmNlOwogICAgICAgIHZhciBpbnB1dCwgb3V0cHV0OwogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBfaW4gPSBzdHJtLm5leHRfaW47CiAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0OwogICAgICAgIGxhc3QgPSBfaW4gKyAoc3RybS5hdmFpbF9pbiAtIDUpOwogICAgICAgIF9vdXQgPSBzdHJtLm5leHRfb3V0OwogICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0OwogICAgICAgIGJlZyA9IF9vdXQgLSAoc3RhcnQgLSBzdHJtLmF2YWlsX291dCk7CiAgICAgICAgZW5kID0gX291dCArIChzdHJtLmF2YWlsX291dCAtIDI1Nyk7CiAgICAgICAgZG1heCA9IHN0YXRlLmRtYXg7CiAgICAgICAgd3NpemUgPSBzdGF0ZS53c2l6ZTsKICAgICAgICB3aGF2ZSA9IHN0YXRlLndoYXZlOwogICAgICAgIHduZXh0ID0gc3RhdGUud25leHQ7CiAgICAgICAgc193aW5kb3cgPSBzdGF0ZS53aW5kb3c7CiAgICAgICAgaG9sZCA9IHN0YXRlLmhvbGQ7CiAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7CiAgICAgICAgbGNvZGUgPSBzdGF0ZS5sZW5jb2RlOwogICAgICAgIGRjb2RlID0gc3RhdGUuZGlzdGNvZGU7CiAgICAgICAgbG1hc2sgPSAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDE7CiAgICAgICAgZG1hc2sgPSAoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxOwogICAgICAgIHRvcDoKICAgICAgICAgIGRvIHsKICAgICAgICAgICAgaWYgKGJpdHMgPCAxNSkgewogICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICB9CiAgICAgICAgICAgIGhlcmUgPSBsY29kZVtob2xkICYgbG1hc2tdOwogICAgICAgICAgICBkb2xlbjoKICAgICAgICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gb3A7CiAgICAgICAgICAgICAgICBiaXRzIC09IG9wOwogICAgICAgICAgICAgICAgb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgIGlmIChvcCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGhlcmUgJiA2NTUzNTsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3AgJiAxNikgewogICAgICAgICAgICAgICAgICBsZW4gPSBoZXJlICYgNjU1MzU7CiAgICAgICAgICAgICAgICAgIG9wICY9IDE1OwogICAgICAgICAgICAgICAgICBpZiAob3ApIHsKICAgICAgICAgICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7CiAgICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBsZW4gKz0gaG9sZCAmICgxIDw8IG9wKSAtIDE7CiAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IG9wOwogICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gb3A7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGJpdHMgPCAxNSkgewogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhlcmUgPSBkY29kZVtob2xkICYgZG1hc2tdOwogICAgICAgICAgICAgICAgICBkb2Rpc3Q6CiAgICAgICAgICAgICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgICAgICAgICAgICBvcCA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IG9wOwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSBvcDsKICAgICAgICAgICAgICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMTYgJiAyNTU7CiAgICAgICAgICAgICAgICAgICAgICBpZiAob3AgJiAxNikgewogICAgICAgICAgICAgICAgICAgICAgICBkaXN0ID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICAgICAgICBvcCAmPSAxNTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3QgKz0gaG9sZCAmICgxIDw8IG9wKSAtIDE7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXN0ID4gZG1heCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrIjsKICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gX291dCAtIGJlZzsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3QgPiBvcCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gZGlzdCAtIG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCA+IHdoYXZlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBzX3dpbmRvdzsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod25leHQgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod25leHQgPCBvcCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSArIHduZXh0IC0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSB3bmV4dDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGxlbiA+IDIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiAtPSAzOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsKICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gLT0gMzsKICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGhlcmUgPSBkY29kZVsoaGVyZSAmIDY1NTM1KSArIChob2xkICYgKDEgPDwgb3ApIC0gMSldOwogICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7CiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlIGNvZGUiOwogICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhayB0b3A7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgewogICAgICAgICAgICAgICAgICBoZXJlID0gbGNvZGVbKGhlcmUgJiA2NTUzNSkgKyAoaG9sZCAmICgxIDw8IG9wKSAtIDEpXTsKICAgICAgICAgICAgICAgICAgY29udGludWUgZG9sZW47CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wICYgMzIpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7CiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0gd2hpbGUgKF9pbiA8IGxhc3QgJiYgX291dCA8IGVuZCk7CiAgICAgICAgbGVuID0gYml0cyA+PiAzOwogICAgICAgIF9pbiAtPSBsZW47CiAgICAgICAgYml0cyAtPSBsZW4gPDwgMzsKICAgICAgICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTsKICAgICAgICBzdHJtLm5leHRfaW4gPSBfaW47CiAgICAgICAgc3RybS5uZXh0X291dCA9IF9vdXQ7CiAgICAgICAgc3RybS5hdmFpbF9pbiA9IF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KTsKICAgICAgICBzdHJtLmF2YWlsX291dCA9IF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCk7CiAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7CiAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7CiAgICAgICAgcmV0dXJuOwogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZ0cmVlcy5qcwogIHZhciByZXF1aXJlX2luZnRyZWVzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mdHJlZXMuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgdXRpbHMgPSByZXF1aXJlX2NvbW1vbigpOwogICAgICB2YXIgTUFYQklUUyA9IDE1OwogICAgICB2YXIgRU5PVUdIX0xFTlMgPSA4NTI7CiAgICAgIHZhciBFTk9VR0hfRElTVFMgPSA1OTI7CiAgICAgIHZhciBDT0RFUyA9IDA7CiAgICAgIHZhciBMRU5TID0gMTsKICAgICAgdmFyIERJU1RTID0gMjsKICAgICAgdmFyIGxiYXNlID0gWwogICAgICAgIDMsCiAgICAgICAgNCwKICAgICAgICA1LAogICAgICAgIDYsCiAgICAgICAgNywKICAgICAgICA4LAogICAgICAgIDksCiAgICAgICAgMTAsCiAgICAgICAgMTEsCiAgICAgICAgMTMsCiAgICAgICAgMTUsCiAgICAgICAgMTcsCiAgICAgICAgMTksCiAgICAgICAgMjMsCiAgICAgICAgMjcsCiAgICAgICAgMzEsCiAgICAgICAgMzUsCiAgICAgICAgNDMsCiAgICAgICAgNTEsCiAgICAgICAgNTksCiAgICAgICAgNjcsCiAgICAgICAgODMsCiAgICAgICAgOTksCiAgICAgICAgMTE1LAogICAgICAgIDEzMSwKICAgICAgICAxNjMsCiAgICAgICAgMTk1LAogICAgICAgIDIyNywKICAgICAgICAyNTgsCiAgICAgICAgMCwKICAgICAgICAwCiAgICAgIF07CiAgICAgIHZhciBsZXh0ID0gWwogICAgICAgIDE2LAogICAgICAgIDE2LAogICAgICAgIDE2LAogICAgICAgIDE2LAogICAgICAgIDE2LAogICAgICAgIDE2LAogICAgICAgIDE2LAogICAgICAgIDE2LAogICAgICAgIDE3LAogICAgICAgIDE3LAogICAgICAgIDE3LAogICAgICAgIDE3LAogICAgICAgIDE4LAogICAgICAgIDE4LAogICAgICAgIDE4LAogICAgICAgIDE4LAogICAgICAgIDE5LAogICAgICAgIDE5LAogICAgICAgIDE5LAogICAgICAgIDE5LAogICAgICAgIDIwLAogICAgICAgIDIwLAogICAgICAgIDIwLAogICAgICAgIDIwLAogICAgICAgIDIxLAogICAgICAgIDIxLAogICAgICAgIDIxLAogICAgICAgIDIxLAogICAgICAgIDE2LAogICAgICAgIDcyLAogICAgICAgIDc4CiAgICAgIF07CiAgICAgIHZhciBkYmFzZSA9IFsKICAgICAgICAxLAogICAgICAgIDIsCiAgICAgICAgMywKICAgICAgICA0LAogICAgICAgIDUsCiAgICAgICAgNywKICAgICAgICA5LAogICAgICAgIDEzLAogICAgICAgIDE3LAogICAgICAgIDI1LAogICAgICAgIDMzLAogICAgICAgIDQ5LAogICAgICAgIDY1LAogICAgICAgIDk3LAogICAgICAgIDEyOSwKICAgICAgICAxOTMsCiAgICAgICAgMjU3LAogICAgICAgIDM4NSwKICAgICAgICA1MTMsCiAgICAgICAgNzY5LAogICAgICAgIDEwMjUsCiAgICAgICAgMTUzNywKICAgICAgICAyMDQ5LAogICAgICAgIDMwNzMsCiAgICAgICAgNDA5NywKICAgICAgICA2MTQ1LAogICAgICAgIDgxOTMsCiAgICAgICAgMTIyODksCiAgICAgICAgMTYzODUsCiAgICAgICAgMjQ1NzcsCiAgICAgICAgMCwKICAgICAgICAwCiAgICAgIF07CiAgICAgIHZhciBkZXh0ID0gWwogICAgICAgIDE2LAogICAgICAgIDE2LAogICAgICAgIDE2LAogICAgICAgIDE2LAogICAgICAgIDE3LAogICAgICAgIDE3LAogICAgICAgIDE4LAogICAgICAgIDE4LAogICAgICAgIDE5LAogICAgICAgIDE5LAogICAgICAgIDIwLAogICAgICAgIDIwLAogICAgICAgIDIxLAogICAgICAgIDIxLAogICAgICAgIDIyLAogICAgICAgIDIyLAogICAgICAgIDIzLAogICAgICAgIDIzLAogICAgICAgIDI0LAogICAgICAgIDI0LAogICAgICAgIDI1LAogICAgICAgIDI1LAogICAgICAgIDI2LAogICAgICAgIDI2LAogICAgICAgIDI3LAogICAgICAgIDI3LAogICAgICAgIDI4LAogICAgICAgIDI4LAogICAgICAgIDI5LAogICAgICAgIDI5LAogICAgICAgIDY0LAogICAgICAgIDY0CiAgICAgIF07CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfdGFibGUodHlwZSwgbGVucywgbGVuc19pbmRleCwgY29kZXMsIHRhYmxlLCB0YWJsZV9pbmRleCwgd29yaywgb3B0cykgewogICAgICAgIHZhciBiaXRzID0gb3B0cy5iaXRzOwogICAgICAgIHZhciBsZW4gPSAwOwogICAgICAgIHZhciBzeW0gPSAwOwogICAgICAgIHZhciBtaW4gPSAwLCBtYXggPSAwOwogICAgICAgIHZhciByb290MiA9IDA7CiAgICAgICAgdmFyIGN1cnIgPSAwOwogICAgICAgIHZhciBkcm9wID0gMDsKICAgICAgICB2YXIgbGVmdCA9IDA7CiAgICAgICAgdmFyIHVzZWQgPSAwOwogICAgICAgIHZhciBodWZmID0gMDsKICAgICAgICB2YXIgaW5jcjsKICAgICAgICB2YXIgZmlsbDsKICAgICAgICB2YXIgbG93OwogICAgICAgIHZhciBtYXNrOwogICAgICAgIHZhciBuZXh0OwogICAgICAgIHZhciBiYXNlID0gbnVsbDsKICAgICAgICB2YXIgYmFzZV9pbmRleCA9IDA7CiAgICAgICAgdmFyIGVuZDsKICAgICAgICB2YXIgY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOwogICAgICAgIHZhciBvZmZzID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsKICAgICAgICB2YXIgZXh0cmEgPSBudWxsOwogICAgICAgIHZhciBleHRyYV9pbmRleCA9IDA7CiAgICAgICAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7CiAgICAgICAgZm9yIChsZW4gPSAwOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHsKICAgICAgICAgIGNvdW50W2xlbl0gPSAwOwogICAgICAgIH0KICAgICAgICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykgewogICAgICAgICAgY291bnRbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rKzsKICAgICAgICB9CiAgICAgICAgcm9vdDIgPSBiaXRzOwogICAgICAgIGZvciAobWF4ID0gTUFYQklUUzsgbWF4ID49IDE7IG1heC0tKSB7CiAgICAgICAgICBpZiAoY291bnRbbWF4XSAhPT0gMCkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHJvb3QyID4gbWF4KSB7CiAgICAgICAgICByb290MiA9IG1heDsKICAgICAgICB9CiAgICAgICAgaWYgKG1heCA9PT0gMCkgewogICAgICAgICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAxIDw8IDI0IHwgNjQgPDwgMTYgfCAwOwogICAgICAgICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAxIDw8IDI0IHwgNjQgPDwgMTYgfCAwOwogICAgICAgICAgb3B0cy5iaXRzID0gMTsKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0KICAgICAgICBmb3IgKG1pbiA9IDE7IG1pbiA8IG1heDsgbWluKyspIHsKICAgICAgICAgIGlmIChjb3VudFttaW5dICE9PSAwKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAocm9vdDIgPCBtaW4pIHsKICAgICAgICAgIHJvb3QyID0gbWluOwogICAgICAgIH0KICAgICAgICBsZWZ0ID0gMTsKICAgICAgICBmb3IgKGxlbiA9IDE7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykgewogICAgICAgICAgbGVmdCA8PD0gMTsKICAgICAgICAgIGxlZnQgLT0gY291bnRbbGVuXTsKICAgICAgICAgIGlmIChsZWZ0IDwgMCkgewogICAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChsZWZ0ID4gMCAmJiAodHlwZSA9PT0gQ09ERVMgfHwgbWF4ICE9PSAxKSkgewogICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgIH0KICAgICAgICBvZmZzWzFdID0gMDsKICAgICAgICBmb3IgKGxlbiA9IDE7IGxlbiA8IE1BWEJJVFM7IGxlbisrKSB7CiAgICAgICAgICBvZmZzW2xlbiArIDFdID0gb2Zmc1tsZW5dICsgY291bnRbbGVuXTsKICAgICAgICB9CiAgICAgICAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHsKICAgICAgICAgIGlmIChsZW5zW2xlbnNfaW5kZXggKyBzeW1dICE9PSAwKSB7CiAgICAgICAgICAgIHdvcmtbb2Zmc1tsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrXSA9IHN5bTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHR5cGUgPT09IENPREVTKSB7CiAgICAgICAgICBiYXNlID0gZXh0cmEgPSB3b3JrOwogICAgICAgICAgZW5kID0gMTk7CiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBMRU5TKSB7CiAgICAgICAgICBiYXNlID0gbGJhc2U7CiAgICAgICAgICBiYXNlX2luZGV4IC09IDI1NzsKICAgICAgICAgIGV4dHJhID0gbGV4dDsKICAgICAgICAgIGV4dHJhX2luZGV4IC09IDI1NzsKICAgICAgICAgIGVuZCA9IDI1NjsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgYmFzZSA9IGRiYXNlOwogICAgICAgICAgZXh0cmEgPSBkZXh0OwogICAgICAgICAgZW5kID0gLTE7CiAgICAgICAgfQogICAgICAgIGh1ZmYgPSAwOwogICAgICAgIHN5bSA9IDA7CiAgICAgICAgbGVuID0gbWluOwogICAgICAgIG5leHQgPSB0YWJsZV9pbmRleDsKICAgICAgICBjdXJyID0gcm9vdDI7CiAgICAgICAgZHJvcCA9IDA7CiAgICAgICAgbG93ID0gLTE7CiAgICAgICAgdXNlZCA9IDEgPDwgcm9vdDI7CiAgICAgICAgbWFzayA9IHVzZWQgLSAxOwogICAgICAgIGlmICh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUyB8fCB0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSB7CiAgICAgICAgICByZXR1cm4gMTsKICAgICAgICB9CiAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICBoZXJlX2JpdHMgPSBsZW4gLSBkcm9wOwogICAgICAgICAgaWYgKHdvcmtbc3ltXSA8IGVuZCkgewogICAgICAgICAgICBoZXJlX29wID0gMDsKICAgICAgICAgICAgaGVyZV92YWwgPSB3b3JrW3N5bV07CiAgICAgICAgICB9IGVsc2UgaWYgKHdvcmtbc3ltXSA+IGVuZCkgewogICAgICAgICAgICBoZXJlX29wID0gZXh0cmFbZXh0cmFfaW5kZXggKyB3b3JrW3N5bV1dOwogICAgICAgICAgICBoZXJlX3ZhbCA9IGJhc2VbYmFzZV9pbmRleCArIHdvcmtbc3ltXV07CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBoZXJlX29wID0gMzIgKyA2NDsKICAgICAgICAgICAgaGVyZV92YWwgPSAwOwogICAgICAgICAgfQogICAgICAgICAgaW5jciA9IDEgPDwgbGVuIC0gZHJvcDsKICAgICAgICAgIGZpbGwgPSAxIDw8IGN1cnI7CiAgICAgICAgICBtaW4gPSBmaWxsOwogICAgICAgICAgZG8gewogICAgICAgICAgICBmaWxsIC09IGluY3I7CiAgICAgICAgICAgIHRhYmxlW25leHQgKyAoaHVmZiA+PiBkcm9wKSArIGZpbGxdID0gaGVyZV9iaXRzIDw8IDI0IHwgaGVyZV9vcCA8PCAxNiB8IGhlcmVfdmFsIHwgMDsKICAgICAgICAgIH0gd2hpbGUgKGZpbGwgIT09IDApOwogICAgICAgICAgaW5jciA9IDEgPDwgbGVuIC0gMTsKICAgICAgICAgIHdoaWxlIChodWZmICYgaW5jcikgewogICAgICAgICAgICBpbmNyID4+PSAxOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGluY3IgIT09IDApIHsKICAgICAgICAgICAgaHVmZiAmPSBpbmNyIC0gMTsKICAgICAgICAgICAgaHVmZiArPSBpbmNyOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgaHVmZiA9IDA7CiAgICAgICAgICB9CiAgICAgICAgICBzeW0rKzsKICAgICAgICAgIGlmICgtLWNvdW50W2xlbl0gPT09IDApIHsKICAgICAgICAgICAgaWYgKGxlbiA9PT0gbWF4KSB7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgbGVuID0gbGVuc1tsZW5zX2luZGV4ICsgd29ya1tzeW1dXTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChsZW4gPiByb290MiAmJiAoaHVmZiAmIG1hc2spICE9PSBsb3cpIHsKICAgICAgICAgICAgaWYgKGRyb3AgPT09IDApIHsKICAgICAgICAgICAgICBkcm9wID0gcm9vdDI7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgbmV4dCArPSBtaW47CiAgICAgICAgICAgIGN1cnIgPSBsZW4gLSBkcm9wOwogICAgICAgICAgICBsZWZ0ID0gMSA8PCBjdXJyOwogICAgICAgICAgICB3aGlsZSAoY3VyciArIGRyb3AgPCBtYXgpIHsKICAgICAgICAgICAgICBsZWZ0IC09IGNvdW50W2N1cnIgKyBkcm9wXTsKICAgICAgICAgICAgICBpZiAobGVmdCA8PSAwKSB7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgY3VycisrOwogICAgICAgICAgICAgIGxlZnQgPDw9IDE7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdXNlZCArPSAxIDw8IGN1cnI7CiAgICAgICAgICAgIGlmICh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUyB8fCB0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSB7CiAgICAgICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgbG93ID0gaHVmZiAmIG1hc2s7CiAgICAgICAgICAgIHRhYmxlW2xvd10gPSByb290MiA8PCAyNCB8IGN1cnIgPDwgMTYgfCBuZXh0IC0gdGFibGVfaW5kZXggfCAwOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAoaHVmZiAhPT0gMCkgewogICAgICAgICAgdGFibGVbbmV4dCArIGh1ZmZdID0gbGVuIC0gZHJvcCA8PCAyNCB8IDY0IDw8IDE2IHwgMDsKICAgICAgICB9CiAgICAgICAgb3B0cy5iaXRzID0gcm9vdDI7CiAgICAgICAgcmV0dXJuIDA7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmxhdGUuanMKICB2YXIgcmVxdWlyZV9pbmZsYXRlID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIHZhciB1dGlscyA9IHJlcXVpcmVfY29tbW9uKCk7CiAgICAgIHZhciBhZGxlcjMyID0gcmVxdWlyZV9hZGxlcjMyKCk7CiAgICAgIHZhciBjcmMzMiA9IHJlcXVpcmVfY3JjMzIoKTsKICAgICAgdmFyIGluZmxhdGVfZmFzdCA9IHJlcXVpcmVfaW5mZmFzdCgpOwogICAgICB2YXIgaW5mbGF0ZV90YWJsZSA9IHJlcXVpcmVfaW5mdHJlZXMoKTsKICAgICAgdmFyIENPREVTID0gMDsKICAgICAgdmFyIExFTlMgPSAxOwogICAgICB2YXIgRElTVFMgPSAyOwogICAgICB2YXIgWl9GSU5JU0ggPSA0OwogICAgICB2YXIgWl9CTE9DSyA9IDU7CiAgICAgIHZhciBaX1RSRUVTID0gNjsKICAgICAgdmFyIFpfT0sgPSAwOwogICAgICB2YXIgWl9TVFJFQU1fRU5EID0gMTsKICAgICAgdmFyIFpfTkVFRF9ESUNUID0gMjsKICAgICAgdmFyIFpfU1RSRUFNX0VSUk9SID0gLTI7CiAgICAgIHZhciBaX0RBVEFfRVJST1IgPSAtMzsKICAgICAgdmFyIFpfTUVNX0VSUk9SID0gLTQ7CiAgICAgIHZhciBaX0JVRl9FUlJPUiA9IC01OwogICAgICB2YXIgWl9ERUZMQVRFRCA9IDg7CiAgICAgIHZhciBIRUFEID0gMTsKICAgICAgdmFyIEZMQUdTID0gMjsKICAgICAgdmFyIFRJTUUgPSAzOwogICAgICB2YXIgT1MgPSA0OwogICAgICB2YXIgRVhMRU4gPSA1OwogICAgICB2YXIgRVhUUkEgPSA2OwogICAgICB2YXIgTkFNRSA9IDc7CiAgICAgIHZhciBDT01NRU5UID0gODsKICAgICAgdmFyIEhDUkMgPSA5OwogICAgICB2YXIgRElDVElEID0gMTA7CiAgICAgIHZhciBESUNUID0gMTE7CiAgICAgIHZhciBUWVBFID0gMTI7CiAgICAgIHZhciBUWVBFRE8gPSAxMzsKICAgICAgdmFyIFNUT1JFRCA9IDE0OwogICAgICB2YXIgQ09QWV8gPSAxNTsKICAgICAgdmFyIENPUFkgPSAxNjsKICAgICAgdmFyIFRBQkxFID0gMTc7CiAgICAgIHZhciBMRU5MRU5TID0gMTg7CiAgICAgIHZhciBDT0RFTEVOUyA9IDE5OwogICAgICB2YXIgTEVOXyA9IDIwOwogICAgICB2YXIgTEVOID0gMjE7CiAgICAgIHZhciBMRU5FWFQgPSAyMjsKICAgICAgdmFyIERJU1QgPSAyMzsKICAgICAgdmFyIERJU1RFWFQgPSAyNDsKICAgICAgdmFyIE1BVENIID0gMjU7CiAgICAgIHZhciBMSVQgPSAyNjsKICAgICAgdmFyIENIRUNLID0gMjc7CiAgICAgIHZhciBMRU5HVEggPSAyODsKICAgICAgdmFyIERPTkUgPSAyOTsKICAgICAgdmFyIEJBRCA9IDMwOwogICAgICB2YXIgTUVNID0gMzE7CiAgICAgIHZhciBTWU5DID0gMzI7CiAgICAgIHZhciBFTk9VR0hfTEVOUyA9IDg1MjsKICAgICAgdmFyIEVOT1VHSF9ESVNUUyA9IDU5MjsKICAgICAgdmFyIE1BWF9XQklUUyA9IDE1OwogICAgICB2YXIgREVGX1dCSVRTID0gTUFYX1dCSVRTOwogICAgICBmdW5jdGlvbiB6c3dhcDMyKHEpIHsKICAgICAgICByZXR1cm4gKHEgPj4+IDI0ICYgMjU1KSArIChxID4+PiA4ICYgNjUyODApICsgKChxICYgNjUyODApIDw8IDgpICsgKChxICYgMjU1KSA8PCAyNCk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gSW5mbGF0ZVN0YXRlKCkgewogICAgICAgIHRoaXMubW9kZSA9IDA7CiAgICAgICAgdGhpcy5sYXN0ID0gZmFsc2U7CiAgICAgICAgdGhpcy53cmFwID0gMDsKICAgICAgICB0aGlzLmhhdmVkaWN0ID0gZmFsc2U7CiAgICAgICAgdGhpcy5mbGFncyA9IDA7CiAgICAgICAgdGhpcy5kbWF4ID0gMDsKICAgICAgICB0aGlzLmNoZWNrID0gMDsKICAgICAgICB0aGlzLnRvdGFsID0gMDsKICAgICAgICB0aGlzLmhlYWQgPSBudWxsOwogICAgICAgIHRoaXMud2JpdHMgPSAwOwogICAgICAgIHRoaXMud3NpemUgPSAwOwogICAgICAgIHRoaXMud2hhdmUgPSAwOwogICAgICAgIHRoaXMud25leHQgPSAwOwogICAgICAgIHRoaXMud2luZG93ID0gbnVsbDsKICAgICAgICB0aGlzLmhvbGQgPSAwOwogICAgICAgIHRoaXMuYml0cyA9IDA7CiAgICAgICAgdGhpcy5sZW5ndGggPSAwOwogICAgICAgIHRoaXMub2Zmc2V0ID0gMDsKICAgICAgICB0aGlzLmV4dHJhID0gMDsKICAgICAgICB0aGlzLmxlbmNvZGUgPSBudWxsOwogICAgICAgIHRoaXMuZGlzdGNvZGUgPSBudWxsOwogICAgICAgIHRoaXMubGVuYml0cyA9IDA7CiAgICAgICAgdGhpcy5kaXN0Yml0cyA9IDA7CiAgICAgICAgdGhpcy5uY29kZSA9IDA7CiAgICAgICAgdGhpcy5ubGVuID0gMDsKICAgICAgICB0aGlzLm5kaXN0ID0gMDsKICAgICAgICB0aGlzLmhhdmUgPSAwOwogICAgICAgIHRoaXMubmV4dCA9IG51bGw7CiAgICAgICAgdGhpcy5sZW5zID0gbmV3IHV0aWxzLkJ1ZjE2KDMyMCk7CiAgICAgICAgdGhpcy53b3JrID0gbmV3IHV0aWxzLkJ1ZjE2KDI4OCk7CiAgICAgICAgdGhpcy5sZW5keW4gPSBudWxsOwogICAgICAgIHRoaXMuZGlzdGR5biA9IG51bGw7CiAgICAgICAgdGhpcy5zYW5lID0gMDsKICAgICAgICB0aGlzLmJhY2sgPSAwOwogICAgICAgIHRoaXMud2FzID0gMDsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pIHsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSBzdGF0ZS50b3RhbCA9IDA7CiAgICAgICAgc3RybS5tc2cgPSAiIjsKICAgICAgICBpZiAoc3RhdGUud3JhcCkgewogICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLndyYXAgJiAxOwogICAgICAgIH0KICAgICAgICBzdGF0ZS5tb2RlID0gSEVBRDsKICAgICAgICBzdGF0ZS5sYXN0ID0gMDsKICAgICAgICBzdGF0ZS5oYXZlZGljdCA9IDA7CiAgICAgICAgc3RhdGUuZG1heCA9IDMyNzY4OwogICAgICAgIHN0YXRlLmhlYWQgPSBudWxsOwogICAgICAgIHN0YXRlLmhvbGQgPSAwOwogICAgICAgIHN0YXRlLmJpdHMgPSAwOwogICAgICAgIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0xFTlMpOwogICAgICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfRElTVFMpOwogICAgICAgIHN0YXRlLnNhbmUgPSAxOwogICAgICAgIHN0YXRlLmJhY2sgPSAtMTsKICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgfQogICAgICBmdW5jdGlvbiBpbmZsYXRlUmVzZXQoc3RybSkgewogICAgICAgIHZhciBzdGF0ZTsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIHN0YXRlLndzaXplID0gMDsKICAgICAgICBzdGF0ZS53aGF2ZSA9IDA7CiAgICAgICAgc3RhdGUud25leHQgPSAwOwogICAgICAgIHJldHVybiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cykgewogICAgICAgIHZhciB3cmFwOwogICAgICAgIHZhciBzdGF0ZTsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmICh3aW5kb3dCaXRzIDwgMCkgewogICAgICAgICAgd3JhcCA9IDA7CiAgICAgICAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHdyYXAgPSAod2luZG93Qml0cyA+PiA0KSArIDE7CiAgICAgICAgICBpZiAod2luZG93Qml0cyA8IDQ4KSB7CiAgICAgICAgICAgIHdpbmRvd0JpdHMgJj0gMTU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmICh3aW5kb3dCaXRzICYmICh3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUpKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIGlmIChzdGF0ZS53aW5kb3cgIT09IG51bGwgJiYgc3RhdGUud2JpdHMgIT09IHdpbmRvd0JpdHMpIHsKICAgICAgICAgIHN0YXRlLndpbmRvdyA9IG51bGw7CiAgICAgICAgfQogICAgICAgIHN0YXRlLndyYXAgPSB3cmFwOwogICAgICAgIHN0YXRlLndiaXRzID0gd2luZG93Qml0czsKICAgICAgICByZXR1cm4gaW5mbGF0ZVJlc2V0KHN0cm0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVJbml0MihzdHJtLCB3aW5kb3dCaXRzKSB7CiAgICAgICAgdmFyIHJldDsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgaWYgKCFzdHJtKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gbmV3IEluZmxhdGVTdGF0ZSgpOwogICAgICAgIHN0cm0uc3RhdGUgPSBzdGF0ZTsKICAgICAgICBzdGF0ZS53aW5kb3cgPSBudWxsOwogICAgICAgIHJldCA9IGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cyk7CiAgICAgICAgaWYgKHJldCAhPT0gWl9PSykgewogICAgICAgICAgc3RybS5zdGF0ZSA9IG51bGw7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaW5mbGF0ZUluaXQoc3RybSkgewogICAgICAgIHJldHVybiBpbmZsYXRlSW5pdDIoc3RybSwgREVGX1dCSVRTKTsKICAgICAgfQogICAgICB2YXIgdmlyZ2luID0gdHJ1ZTsKICAgICAgdmFyIGxlbmZpeDsKICAgICAgdmFyIGRpc3RmaXg7CiAgICAgIGZ1bmN0aW9uIGZpeGVkdGFibGVzKHN0YXRlKSB7CiAgICAgICAgaWYgKHZpcmdpbikgewogICAgICAgICAgdmFyIHN5bTsKICAgICAgICAgIGxlbmZpeCA9IG5ldyB1dGlscy5CdWYzMig1MTIpOwogICAgICAgICAgZGlzdGZpeCA9IG5ldyB1dGlscy5CdWYzMigzMik7CiAgICAgICAgICBzeW0gPSAwOwogICAgICAgICAgd2hpbGUgKHN5bSA8IDE0NCkgewogICAgICAgICAgICBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7CiAgICAgICAgICB9CiAgICAgICAgICB3aGlsZSAoc3ltIDwgMjU2KSB7CiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3ltKytdID0gOTsKICAgICAgICAgIH0KICAgICAgICAgIHdoaWxlIChzeW0gPCAyODApIHsKICAgICAgICAgICAgc3RhdGUubGVuc1tzeW0rK10gPSA3OwogICAgICAgICAgfQogICAgICAgICAgd2hpbGUgKHN5bSA8IDI4OCkgewogICAgICAgICAgICBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7CiAgICAgICAgICB9CiAgICAgICAgICBpbmZsYXRlX3RhYmxlKExFTlMsIHN0YXRlLmxlbnMsIDAsIDI4OCwgbGVuZml4LCAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDkgfSk7CiAgICAgICAgICBzeW0gPSAwOwogICAgICAgICAgd2hpbGUgKHN5bSA8IDMyKSB7CiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3ltKytdID0gNTsKICAgICAgICAgIH0KICAgICAgICAgIGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIDAsIDMyLCBkaXN0Zml4LCAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDUgfSk7CiAgICAgICAgICB2aXJnaW4gPSBmYWxzZTsKICAgICAgICB9CiAgICAgICAgc3RhdGUubGVuY29kZSA9IGxlbmZpeDsKICAgICAgICBzdGF0ZS5sZW5iaXRzID0gOTsKICAgICAgICBzdGF0ZS5kaXN0Y29kZSA9IGRpc3RmaXg7CiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSA1OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHVwZGF0ZXdpbmRvdyhzdHJtLCBzcmMsIGVuZCwgY29weSkgewogICAgICAgIHZhciBkaXN0OwogICAgICAgIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAgICAgaWYgKHN0YXRlLndpbmRvdyA9PT0gbnVsbCkgewogICAgICAgICAgc3RhdGUud3NpemUgPSAxIDw8IHN0YXRlLndiaXRzOwogICAgICAgICAgc3RhdGUud25leHQgPSAwOwogICAgICAgICAgc3RhdGUud2hhdmUgPSAwOwogICAgICAgICAgc3RhdGUud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgoc3RhdGUud3NpemUpOwogICAgICAgIH0KICAgICAgICBpZiAoY29weSA+PSBzdGF0ZS53c2l6ZSkgewogICAgICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIHN0YXRlLndzaXplLCBzdGF0ZS53c2l6ZSwgMCk7CiAgICAgICAgICBzdGF0ZS53bmV4dCA9IDA7CiAgICAgICAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBkaXN0ID0gc3RhdGUud3NpemUgLSBzdGF0ZS53bmV4dDsKICAgICAgICAgIGlmIChkaXN0ID4gY29weSkgewogICAgICAgICAgICBkaXN0ID0gY29weTsKICAgICAgICAgIH0KICAgICAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBkaXN0LCBzdGF0ZS53bmV4dCk7CiAgICAgICAgICBjb3B5IC09IGRpc3Q7CiAgICAgICAgICBpZiAoY29weSkgewogICAgICAgICAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgY29weSwgMCk7CiAgICAgICAgICAgIHN0YXRlLnduZXh0ID0gY29weTsKICAgICAgICAgICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHN0YXRlLnduZXh0ICs9IGRpc3Q7CiAgICAgICAgICAgIGlmIChzdGF0ZS53bmV4dCA9PT0gc3RhdGUud3NpemUpIHsKICAgICAgICAgICAgICBzdGF0ZS53bmV4dCA9IDA7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHN0YXRlLndoYXZlIDwgc3RhdGUud3NpemUpIHsKICAgICAgICAgICAgICBzdGF0ZS53aGF2ZSArPSBkaXN0OwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiAwOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGUoc3RybSwgZmx1c2gpIHsKICAgICAgICB2YXIgc3RhdGU7CiAgICAgICAgdmFyIGlucHV0LCBvdXRwdXQ7CiAgICAgICAgdmFyIG5leHQ7CiAgICAgICAgdmFyIHB1dDsKICAgICAgICB2YXIgaGF2ZSwgbGVmdDsKICAgICAgICB2YXIgaG9sZDsKICAgICAgICB2YXIgYml0czsKICAgICAgICB2YXIgX2luLCBfb3V0OwogICAgICAgIHZhciBjb3B5OwogICAgICAgIHZhciBmcm9tOwogICAgICAgIHZhciBmcm9tX3NvdXJjZTsKICAgICAgICB2YXIgaGVyZSA9IDA7CiAgICAgICAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7CiAgICAgICAgdmFyIGxhc3RfYml0cywgbGFzdF9vcCwgbGFzdF92YWw7CiAgICAgICAgdmFyIGxlbjsKICAgICAgICB2YXIgcmV0OwogICAgICAgIHZhciBoYnVmID0gbmV3IHV0aWxzLkJ1ZjgoNCk7CiAgICAgICAgdmFyIG9wdHM7CiAgICAgICAgdmFyIG47CiAgICAgICAgdmFyIG9yZGVyID0gWzE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTVdOwogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fCAhc3RybS5vdXRwdXQgfHwgIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHsKICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87CiAgICAgICAgfQogICAgICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7CiAgICAgICAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7CiAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0OwogICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47CiAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0OwogICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luOwogICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkOwogICAgICAgIGJpdHMgPSBzdGF0ZS5iaXRzOwogICAgICAgIF9pbiA9IGhhdmU7CiAgICAgICAgX291dCA9IGxlZnQ7CiAgICAgICAgcmV0ID0gWl9PSzsKICAgICAgICBpbmZfbGVhdmU6CiAgICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgICAgc3dpdGNoIChzdGF0ZS5tb2RlKSB7CiAgICAgICAgICAgICAgY2FzZSBIRUFEOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLndyYXAgPT09IDApIHsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEVETzsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChzdGF0ZS53cmFwICYgMiAmJiBob2xkID09PSAzNTYxNSkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IDA7CiAgICAgICAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMjU1OwogICAgICAgICAgICAgICAgICBoYnVmWzFdID0gaG9sZCA+Pj4gOCAmIDI1NTsKICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7CiAgICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEZMQUdTOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmZsYWdzID0gMDsKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IGZhbHNlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKCEoc3RhdGUud3JhcCAmIDEpIHx8ICgoKGhvbGQgJiAyNTUpIDw8IDgpICsgKGhvbGQgPj4gOCkpICUgMzEpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW5jb3JyZWN0IGhlYWRlciBjaGVjayI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKChob2xkICYgMTUpICE9PSBaX0RFRkxBVEVEKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gInVua25vd24gY29tcHJlc3Npb24gbWV0aG9kIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gNDsKICAgICAgICAgICAgICAgIGJpdHMgLT0gNDsKICAgICAgICAgICAgICAgIGxlbiA9IChob2xkICYgMTUpICsgODsKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS53Yml0cyA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS53Yml0cyA9IGxlbjsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVuID4gc3RhdGUud2JpdHMpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCB3aW5kb3cgc2l6ZSI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuZG1heCA9IDEgPDwgbGVuOwogICAgICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMTsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBob2xkICYgNTEyID8gRElDVElEIDogVFlQRTsKICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIEZMQUdTOgogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5mbGFncyA9IGhvbGQ7CiAgICAgICAgICAgICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMjU1KSAhPT0gWl9ERUZMQVRFRCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJ1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTczNDQpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAidW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0IjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLnRleHQgPSBob2xkID4+IDggJiAxOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMjU1OwogICAgICAgICAgICAgICAgICBoYnVmWzFdID0gaG9sZCA+Pj4gOCAmIDI1NTsKICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRJTUU7CiAgICAgICAgICAgICAgY2FzZSBUSU1FOgogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLnRpbWUgPSBob2xkOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMjU1OwogICAgICAgICAgICAgICAgICBoYnVmWzFdID0gaG9sZCA+Pj4gOCAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGJ1ZlsyXSA9IGhvbGQgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgICBoYnVmWzNdID0gaG9sZCA+Pj4gMjQgJiAyNTU7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDQsIDApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBPUzsKICAgICAgICAgICAgICBjYXNlIE9TOgogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLnhmbGFncyA9IGhvbGQgJiAyNTU7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQub3MgPSBob2xkID4+IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA1MTIpIHsKICAgICAgICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAyNTU7CiAgICAgICAgICAgICAgICAgIGhidWZbMV0gPSBob2xkID4+PiA4ICYgMjU1OwogICAgICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gRVhMRU47CiAgICAgICAgICAgICAgY2FzZSBFWExFTjoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDEwMjQpIHsKICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikgewogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZDsKICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX2xlbiA9IGhvbGQ7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAyNTU7CiAgICAgICAgICAgICAgICAgICAgaGJ1ZlsxXSA9IGhvbGQgPj4+IDggJiAyNTU7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBudWxsOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEVYVFJBOwogICAgICAgICAgICAgIGNhc2UgRVhUUkE6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAxMDI0KSB7CiAgICAgICAgICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgewogICAgICAgICAgICAgICAgICAgIGNvcHkgPSBoYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5KSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmhlYWQuZXh0cmFfbGVuIC0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5oZWFkLmV4dHJhKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBuZXcgQXJyYXkoc3RhdGUuaGVhZC5leHRyYV9sZW4pOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUuaGVhZC5leHRyYSwgaW5wdXQsIG5leHQsIGNvcHksIGxlbik7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlIC09IGNvcHk7CiAgICAgICAgICAgICAgICAgICAgbmV4dCArPSBjb3B5OwogICAgICAgICAgICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTkFNRTsKICAgICAgICAgICAgICBjYXNlIE5BTUU6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAyMDQ4KSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGNvcHkgPSAwOwogICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107CiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmIHN0YXRlLmxlbmd0aCA8IDY1NTM2KSB7CiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTsKICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUgLT0gY29weTsKICAgICAgICAgICAgICAgICAgbmV4dCArPSBjb3B5OwogICAgICAgICAgICAgICAgICBpZiAobGVuKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5uYW1lID0gbnVsbDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQ09NTUVOVDsKICAgICAgICAgICAgICBjYXNlIENPTU1FTlQ6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiA0MDk2KSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGNvcHkgPSAwOwogICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107CiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmIHN0YXRlLmxlbmd0aCA8IDY1NTM2KSB7CiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTsKICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUgLT0gY29weTsKICAgICAgICAgICAgICAgICAgbmV4dCArPSBjb3B5OwogICAgICAgICAgICAgICAgICBpZiAobGVuKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ID0gbnVsbDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBIQ1JDOwogICAgICAgICAgICAgIGNhc2UgSENSQzoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDUxMikgewogICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLmNoZWNrICYgNjU1MzUpKSB7CiAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaGVhZGVyIGNyYyBtaXNtYXRjaCI7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmhjcmMgPSBzdGF0ZS5mbGFncyA+PiA5ICYgMTsKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gdHJ1ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDA7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgRElDVElEOgogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSB6c3dhcDMyKGhvbGQpOwogICAgICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBESUNUOwogICAgICAgICAgICAgIGNhc2UgRElDVDoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlZGljdCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0OwogICAgICAgICAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7CiAgICAgICAgICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7CiAgICAgICAgICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlOwogICAgICAgICAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDsKICAgICAgICAgICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7CiAgICAgICAgICAgICAgICAgIHJldHVybiBaX05FRURfRElDVDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDE7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTsKICAgICAgICAgICAgICBjYXNlIFRZUEU6CiAgICAgICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfQkxPQ0sgfHwgZmx1c2ggPT09IFpfVFJFRVMpIHsKICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGNhc2UgVFlQRURPOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmxhc3QpIHsKICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3OwogICAgICAgICAgICAgICAgICBiaXRzIC09IGJpdHMgJiA3OwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQ0hFQ0s7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmxhc3QgPSBob2xkICYgMTsKICAgICAgICAgICAgICAgIGhvbGQgPj4+PSAxOwogICAgICAgICAgICAgICAgYml0cyAtPSAxOwogICAgICAgICAgICAgICAgc3dpdGNoIChob2xkICYgMykgewogICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFNUT1JFRDsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICAgICAgICAgIGZpeGVkdGFibGVzKHN0YXRlKTsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsKICAgICAgICAgICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsKICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSAyOwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSAyOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUQUJMRTsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgY2FzZSAzOgogICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgYmxvY2sgdHlwZSI7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGhvbGQgPj4+PSAyOwogICAgICAgICAgICAgICAgYml0cyAtPSAyOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSBTVE9SRUQ6CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7CiAgICAgICAgICAgICAgICBiaXRzIC09IGJpdHMgJiA3OwogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikgewogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoKGhvbGQgJiA2NTUzNSkgIT09IChob2xkID4+PiAxNiBeIDY1NTM1KSkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkICYgNjU1MzU7CiAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IENPUFlfOwogICAgICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7CiAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBjYXNlIENPUFlfOgogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IENPUFk7CiAgICAgICAgICAgICAgY2FzZSBDT1BZOgogICAgICAgICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDsKICAgICAgICAgICAgICAgIGlmIChjb3B5KSB7CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgewogICAgICAgICAgICAgICAgICAgIGNvcHkgPSBoYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgewogICAgICAgICAgICAgICAgICAgIGNvcHkgPSBsZWZ0OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5ID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KG91dHB1dCwgaW5wdXQsIG5leHQsIGNvcHksIHB1dCk7CiAgICAgICAgICAgICAgICAgIGhhdmUgLT0gY29weTsKICAgICAgICAgICAgICAgICAgbmV4dCArPSBjb3B5OwogICAgICAgICAgICAgICAgICBsZWZ0IC09IGNvcHk7CiAgICAgICAgICAgICAgICAgIHB1dCArPSBjb3B5OwogICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgVEFCTEU6CiAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IDE0KSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLm5sZW4gPSAoaG9sZCAmIDMxKSArIDI1NzsKICAgICAgICAgICAgICAgIGhvbGQgPj4+PSA1OwogICAgICAgICAgICAgICAgYml0cyAtPSA1OwogICAgICAgICAgICAgICAgc3RhdGUubmRpc3QgPSAoaG9sZCAmIDMxKSArIDE7CiAgICAgICAgICAgICAgICBob2xkID4+Pj0gNTsKICAgICAgICAgICAgICAgIGJpdHMgLT0gNTsKICAgICAgICAgICAgICAgIHN0YXRlLm5jb2RlID0gKGhvbGQgJiAxNSkgKyA0OwogICAgICAgICAgICAgICAgaG9sZCA+Pj49IDQ7CiAgICAgICAgICAgICAgICBiaXRzIC09IDQ7CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUubmxlbiA+IDI4NiB8fCBzdGF0ZS5uZGlzdCA+IDMwKSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gInRvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5oYXZlID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5MRU5TOwogICAgICAgICAgICAgIGNhc2UgTEVOTEVOUzoKICAgICAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmNvZGUpIHsKICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gaG9sZCAmIDc7CiAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSAzOwogICAgICAgICAgICAgICAgICBiaXRzIC09IDM7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IDE5KSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5bjsKICAgICAgICAgICAgICAgIHN0YXRlLmxlbmJpdHMgPSA3OwogICAgICAgICAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9OwogICAgICAgICAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShDT0RFUywgc3RhdGUubGVucywgMCwgMTksIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpOwogICAgICAgICAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0czsKICAgICAgICAgICAgICAgIGlmIChyZXQpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBjb2RlIGxlbmd0aHMgc2V0IjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5oYXZlID0gMDsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBDT0RFTEVOUzsKICAgICAgICAgICAgICBjYXNlIENPREVMRU5TOgogICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHsKICAgICAgICAgICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMV07CiAgICAgICAgICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgICAgICAgICAgaGVyZV9vcCA9IGhlcmUgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGhlcmVfdmFsIDwgMTYpIHsKICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGhlcmVfdmFsOwogICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGlmIChoZXJlX3ZhbCA9PT0gMTYpIHsKICAgICAgICAgICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAyOwogICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgYml0IGxlbmd0aCByZXBlYXQiOwogICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSAtIDFdOwogICAgICAgICAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDMpOwogICAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IDI7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoZXJlX3ZhbCA9PT0gMTcpIHsKICAgICAgICAgICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAzOwogICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IDA7CiAgICAgICAgICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgNyk7CiAgICAgICAgICAgICAgICAgICAgICBob2xkID4+Pj0gMzsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gMzsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDc7CiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgICAgICAgbGVuID0gMDsKICAgICAgICAgICAgICAgICAgICAgIGNvcHkgPSAxMSArIChob2xkICYgMTI3KTsKICAgICAgICAgICAgICAgICAgICAgIGhvbGQgPj4+PSA3OwogICAgICAgICAgICAgICAgICAgICAgYml0cyAtPSA3OwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSArIGNvcHkgPiBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHsKICAgICAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgYml0IGxlbmd0aCByZXBlYXQiOwogICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY29weS0tKSB7CiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBsZW47CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gQkFEKSB7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHN0YXRlLmxlbnNbMjU2XSA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGNvZGUgLS0gbWlzc2luZyBlbmQtb2YtYmxvY2siOwogICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHN0YXRlLmxlbmJpdHMgPSA5OwogICAgICAgICAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9OwogICAgICAgICAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShMRU5TLCBzdGF0ZS5sZW5zLCAwLCBzdGF0ZS5ubGVuLCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTsKICAgICAgICAgICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7CiAgICAgICAgICAgICAgICBpZiAocmV0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldCI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSA2OwogICAgICAgICAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluOwogICAgICAgICAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUuZGlzdGJpdHMgfTsKICAgICAgICAgICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIHN0YXRlLm5sZW4sIHN0YXRlLm5kaXN0LCBzdGF0ZS5kaXN0Y29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7CiAgICAgICAgICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IG9wdHMuYml0czsKICAgICAgICAgICAgICAgIGlmIChyZXQpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBkaXN0YW5jZXMgc2V0IjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsKICAgICAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgewogICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgY2FzZSBMRU5fOgogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTjsKICAgICAgICAgICAgICBjYXNlIExFTjoKICAgICAgICAgICAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHsKICAgICAgICAgICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDsKICAgICAgICAgICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0OwogICAgICAgICAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0OwogICAgICAgICAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTsKICAgICAgICAgICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzOwogICAgICAgICAgICAgICAgICBpbmZsYXRlX2Zhc3Qoc3RybSwgX291dCk7CiAgICAgICAgICAgICAgICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7CiAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0OwogICAgICAgICAgICAgICAgICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7CiAgICAgICAgICAgICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47CiAgICAgICAgICAgICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDsKICAgICAgICAgICAgICAgICAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47CiAgICAgICAgICAgICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkOwogICAgICAgICAgICAgICAgICBiaXRzID0gc3RhdGUuYml0czsKICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHsKICAgICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrID0gMDsKICAgICAgICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKDEgPDwgc3RhdGUubGVuYml0cykgLSAxXTsKICAgICAgICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgICAgICAgIGhlcmVfb3AgPSBoZXJlID4+PiAxNiAmIDI1NTsKICAgICAgICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgNjU1MzU7CiAgICAgICAgICAgICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgewogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChoZXJlX29wICYmIChoZXJlX29wICYgMjQwKSA9PT0gMCkgewogICAgICAgICAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wOwogICAgICAgICAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsOwogICAgICAgICAgICAgICAgICBmb3IgKDsgOyApIHsKICAgICAgICAgICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtsYXN0X3ZhbCArICgoaG9sZCAmICgxIDw8IGxhc3RfYml0cyArIGxhc3Rfb3ApIC0gMSkgPj4gbGFzdF9iaXRzKV07CiAgICAgICAgICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgICAgICAgICAgaGVyZV9vcCA9IGhlcmUgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICAgIGlmIChsYXN0X2JpdHMgKyBoZXJlX2JpdHMgPD0gYml0cykgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0czsKICAgICAgICAgICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0czsKICAgICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICBzdGF0ZS5sZW5ndGggPSBoZXJlX3ZhbDsKICAgICAgICAgICAgICAgIGlmIChoZXJlX29wID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMSVQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKGhlcmVfb3AgJiAzMikgewogICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChoZXJlX29wICYgNjQpIHsKICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlIjsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5leHRyYSA9IGhlcmVfb3AgJiAxNTsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5FWFQ7CiAgICAgICAgICAgICAgY2FzZSBMRU5FWFQ6CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHsKICAgICAgICAgICAgICAgICAgbiA9IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBob2xkICYgKDEgPDwgc3RhdGUuZXh0cmEpIC0gMTsKICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUud2FzID0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IERJU1Q7CiAgICAgICAgICAgICAgY2FzZSBESVNUOgogICAgICAgICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtob2xkICYgKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMV07CiAgICAgICAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgICAgICBoZXJlX29wID0gaGVyZSA+Pj4gMTYgJiAyNTU7CiAgICAgICAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoKGhlcmVfb3AgJiAyNDApID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0czsKICAgICAgICAgICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7CiAgICAgICAgICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7CiAgICAgICAgICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtsYXN0X3ZhbCArICgoaG9sZCAmICgxIDw8IGxhc3RfYml0cyArIGxhc3Rfb3ApIC0gMSkgPj4gbGFzdF9iaXRzKV07CiAgICAgICAgICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7CiAgICAgICAgICAgICAgICAgICAgaGVyZV9vcCA9IGhlcmUgPj4+IDE2ICYgMjU1OwogICAgICAgICAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDY1NTM1OwogICAgICAgICAgICAgICAgICAgIGlmIChsYXN0X2JpdHMgKyBoZXJlX2JpdHMgPD0gYml0cykgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0czsKICAgICAgICAgICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0czsKICAgICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7CiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gImludmFsaWQgZGlzdGFuY2UgY29kZSI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUub2Zmc2V0ID0gaGVyZV92YWw7CiAgICAgICAgICAgICAgICBzdGF0ZS5leHRyYSA9IGhlcmVfb3AgJiAxNTsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBESVNURVhUOwogICAgICAgICAgICAgIGNhc2UgRElTVEVYVDoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5leHRyYSkgewogICAgICAgICAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7CiAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikgewogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgc3RhdGUub2Zmc2V0ICs9IGhvbGQgJiAoMSA8PCBzdGF0ZS5leHRyYSkgLSAxOwogICAgICAgICAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7CiAgICAgICAgICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7CiAgICAgICAgICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gc3RhdGUuZG1heCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayI7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IE1BVENIOwogICAgICAgICAgICAgIGNhc2UgTUFUQ0g6CiAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gMCkgewogICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBjb3B5ID0gX291dCAtIGxlZnQ7CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gY29weSkgewogICAgICAgICAgICAgICAgICBjb3B5ID0gc3RhdGUub2Zmc2V0IC0gY29weTsKICAgICAgICAgICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53aGF2ZSkgewogICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7CiAgICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayI7CiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud25leHQpIHsKICAgICAgICAgICAgICAgICAgICBjb3B5IC09IHN0YXRlLnduZXh0OwogICAgICAgICAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53c2l6ZSAtIGNvcHk7CiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IHN0YXRlLnduZXh0IC0gY29weTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBzdGF0ZS53aW5kb3c7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDsKICAgICAgICAgICAgICAgICAgZnJvbSA9IHB1dCAtIHN0YXRlLm9mZnNldDsKICAgICAgICAgICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgewogICAgICAgICAgICAgICAgICBjb3B5ID0gbGVmdDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGxlZnQgLT0gY29weTsKICAgICAgICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5OwogICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICBvdXRwdXRbcHV0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTsKICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tY29weSk7CiAgICAgICAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU47CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlIExJVDoKICAgICAgICAgICAgICAgIGlmIChsZWZ0ID09PSAwKSB7CiAgICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIG91dHB1dFtwdXQrK10gPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICBsZWZ0LS07CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSBDSEVDSzoKICAgICAgICAgICAgICAgIGlmIChzdGF0ZS53cmFwKSB7CiAgICAgICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgICAgaG9sZCB8PSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIF9vdXQgLT0gbGVmdDsKICAgICAgICAgICAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gX291dDsKICAgICAgICAgICAgICAgICAgc3RhdGUudG90YWwgKz0gX291dDsKICAgICAgICAgICAgICAgICAgaWYgKF9vdXQpIHsKICAgICAgICAgICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSBzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBfb3V0ID0gbGVmdDsKICAgICAgICAgICAgICAgICAgaWYgKChzdGF0ZS5mbGFncyA/IGhvbGQgOiB6c3dhcDMyKGhvbGQpKSAhPT0gc3RhdGUuY2hlY2spIHsKICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICJpbmNvcnJlY3QgZGF0YSBjaGVjayI7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOR1RIOwogICAgICAgICAgICAgIGNhc2UgTEVOR1RIOgogICAgICAgICAgICAgICAgaWYgKHN0YXRlLndyYXAgJiYgc3RhdGUuZmxhZ3MpIHsKICAgICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikgewogICAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS50b3RhbCAmIDQyOTQ5NjcyOTUpKSB7CiAgICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAiaW5jb3JyZWN0IGxlbmd0aCBjaGVjayI7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gRE9ORTsKICAgICAgICAgICAgICBjYXNlIERPTkU6CiAgICAgICAgICAgICAgICByZXQgPSBaX1NUUkVBTV9FTkQ7CiAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgY2FzZSBCQUQ6CiAgICAgICAgICAgICAgICByZXQgPSBaX0RBVEFfRVJST1I7CiAgICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgICAgICAgY2FzZSBNRU06CiAgICAgICAgICAgICAgICByZXR1cm4gWl9NRU1fRVJST1I7CiAgICAgICAgICAgICAgY2FzZSBTWU5DOgogICAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0OwogICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDsKICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0OwogICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlOwogICAgICAgIHN0YXRlLmhvbGQgPSBob2xkOwogICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzOwogICAgICAgIGlmIChzdGF0ZS53c2l6ZSB8fCBfb3V0ICE9PSBzdHJtLmF2YWlsX291dCAmJiBzdGF0ZS5tb2RlIDwgQkFEICYmIChzdGF0ZS5tb2RlIDwgQ0hFQ0sgfHwgZmx1c2ggIT09IFpfRklOSVNIKSkgewogICAgICAgICAgaWYgKHVwZGF0ZXdpbmRvdyhzdHJtLCBzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCwgX291dCAtIHN0cm0uYXZhaWxfb3V0KSkgewogICAgICAgICAgICBzdGF0ZS5tb2RlID0gTUVNOwogICAgICAgICAgICByZXR1cm4gWl9NRU1fRVJST1I7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIF9pbiAtPSBzdHJtLmF2YWlsX2luOwogICAgICAgIF9vdXQgLT0gc3RybS5hdmFpbF9vdXQ7CiAgICAgICAgc3RybS50b3RhbF9pbiArPSBfaW47CiAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gX291dDsKICAgICAgICBzdGF0ZS50b3RhbCArPSBfb3V0OwogICAgICAgIGlmIChzdGF0ZS53cmFwICYmIF9vdXQpIHsKICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCk7CiAgICAgICAgfQogICAgICAgIHN0cm0uZGF0YV90eXBlID0gc3RhdGUuYml0cyArIChzdGF0ZS5sYXN0ID8gNjQgOiAwKSArIChzdGF0ZS5tb2RlID09PSBUWVBFID8gMTI4IDogMCkgKyAoc3RhdGUubW9kZSA9PT0gTEVOXyB8fCBzdGF0ZS5tb2RlID09PSBDT1BZXyA/IDI1NiA6IDApOwogICAgICAgIGlmICgoX2luID09PSAwICYmIF9vdXQgPT09IDAgfHwgZmx1c2ggPT09IFpfRklOSVNIKSAmJiByZXQgPT09IFpfT0spIHsKICAgICAgICAgIHJldCA9IFpfQlVGX0VSUk9SOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVFbmQoc3RybSkgewogICAgICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgewogICAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgICAgIH0KICAgICAgICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmIChzdGF0ZS53aW5kb3cpIHsKICAgICAgICAgIHN0YXRlLndpbmRvdyA9IG51bGw7CiAgICAgICAgfQogICAgICAgIHN0cm0uc3RhdGUgPSBudWxsOwogICAgICAgIHJldHVybiBaX09LOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVHZXRIZWFkZXIoc3RybSwgaGVhZCkgewogICAgICAgIHZhciBzdGF0ZTsKICAgICAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgICB9CiAgICAgICAgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgICAgIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlLmhlYWQgPSBoZWFkOwogICAgICAgIGhlYWQuZG9uZSA9IGZhbHNlOwogICAgICAgIHJldHVybiBaX09LOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHsKICAgICAgICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoOwogICAgICAgIHZhciBzdGF0ZTsKICAgICAgICB2YXIgZGljdGlkOwogICAgICAgIHZhciByZXQ7CiAgICAgICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgICAgICBpZiAoc3RhdGUud3JhcCAhPT0gMCAmJiBzdGF0ZS5tb2RlICE9PSBESUNUKSB7CiAgICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBESUNUKSB7CiAgICAgICAgICBkaWN0aWQgPSAxOwogICAgICAgICAgZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApOwogICAgICAgICAgaWYgKGRpY3RpZCAhPT0gc3RhdGUuY2hlY2spIHsKICAgICAgICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0ID0gdXBkYXRld2luZG93KHN0cm0sIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIGRpY3RMZW5ndGgpOwogICAgICAgIGlmIChyZXQpIHsKICAgICAgICAgIHN0YXRlLm1vZGUgPSBNRU07CiAgICAgICAgICByZXR1cm4gWl9NRU1fRVJST1I7CiAgICAgICAgfQogICAgICAgIHN0YXRlLmhhdmVkaWN0ID0gMTsKICAgICAgICByZXR1cm4gWl9PSzsKICAgICAgfQogICAgICBleHBvcnRzMi5pbmZsYXRlUmVzZXQgPSBpbmZsYXRlUmVzZXQ7CiAgICAgIGV4cG9ydHMyLmluZmxhdGVSZXNldDIgPSBpbmZsYXRlUmVzZXQyOwogICAgICBleHBvcnRzMi5pbmZsYXRlUmVzZXRLZWVwID0gaW5mbGF0ZVJlc2V0S2VlcDsKICAgICAgZXhwb3J0czIuaW5mbGF0ZUluaXQgPSBpbmZsYXRlSW5pdDsKICAgICAgZXhwb3J0czIuaW5mbGF0ZUluaXQyID0gaW5mbGF0ZUluaXQyOwogICAgICBleHBvcnRzMi5pbmZsYXRlID0gaW5mbGF0ZTsKICAgICAgZXhwb3J0czIuaW5mbGF0ZUVuZCA9IGluZmxhdGVFbmQ7CiAgICAgIGV4cG9ydHMyLmluZmxhdGVHZXRIZWFkZXIgPSBpbmZsYXRlR2V0SGVhZGVyOwogICAgICBleHBvcnRzMi5pbmZsYXRlU2V0RGljdGlvbmFyeSA9IGluZmxhdGVTZXREaWN0aW9uYXJ5OwogICAgICBleHBvcnRzMi5pbmZsYXRlSW5mbyA9ICJwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpIjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY29uc3RhbnRzLmpzCiAgdmFyIHJlcXVpcmVfY29uc3RhbnRzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY29uc3RhbnRzLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgbW9kdWxlMi5leHBvcnRzID0gewogICAgICAgIFpfTk9fRkxVU0g6IDAsCiAgICAgICAgWl9QQVJUSUFMX0ZMVVNIOiAxLAogICAgICAgIFpfU1lOQ19GTFVTSDogMiwKICAgICAgICBaX0ZVTExfRkxVU0g6IDMsCiAgICAgICAgWl9GSU5JU0g6IDQsCiAgICAgICAgWl9CTE9DSzogNSwKICAgICAgICBaX1RSRUVTOiA2LAogICAgICAgIFpfT0s6IDAsCiAgICAgICAgWl9TVFJFQU1fRU5EOiAxLAogICAgICAgIFpfTkVFRF9ESUNUOiAyLAogICAgICAgIFpfRVJSTk86IC0xLAogICAgICAgIFpfU1RSRUFNX0VSUk9SOiAtMiwKICAgICAgICBaX0RBVEFfRVJST1I6IC0zLAogICAgICAgIFpfQlVGX0VSUk9SOiAtNSwKICAgICAgICBaX05PX0NPTVBSRVNTSU9OOiAwLAogICAgICAgIFpfQkVTVF9TUEVFRDogMSwKICAgICAgICBaX0JFU1RfQ09NUFJFU1NJT046IDksCiAgICAgICAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAtMSwKICAgICAgICBaX0ZJTFRFUkVEOiAxLAogICAgICAgIFpfSFVGRk1BTl9PTkxZOiAyLAogICAgICAgIFpfUkxFOiAzLAogICAgICAgIFpfRklYRUQ6IDQsCiAgICAgICAgWl9ERUZBVUxUX1NUUkFURUdZOiAwLAogICAgICAgIFpfQklOQVJZOiAwLAogICAgICAgIFpfVEVYVDogMSwKICAgICAgICBaX1VOS05PV046IDIsCiAgICAgICAgWl9ERUZMQVRFRDogOAogICAgICB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9nemhlYWRlci5qcwogIHZhciByZXF1aXJlX2d6aGVhZGVyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZ3poZWFkZXIuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBmdW5jdGlvbiBHWmhlYWRlcigpIHsKICAgICAgICB0aGlzLnRleHQgPSAwOwogICAgICAgIHRoaXMudGltZSA9IDA7CiAgICAgICAgdGhpcy54ZmxhZ3MgPSAwOwogICAgICAgIHRoaXMub3MgPSAwOwogICAgICAgIHRoaXMuZXh0cmEgPSBudWxsOwogICAgICAgIHRoaXMuZXh0cmFfbGVuID0gMDsKICAgICAgICB0aGlzLm5hbWUgPSAiIjsKICAgICAgICB0aGlzLmNvbW1lbnQgPSAiIjsKICAgICAgICB0aGlzLmhjcmMgPSAwOwogICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlOwogICAgICB9CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IEdaaGVhZGVyOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvcGFrby9saWIvaW5mbGF0ZS5qcwogIHZhciByZXF1aXJlX2luZmxhdGUyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3Bha28vbGliL2luZmxhdGUuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgemxpYl9pbmZsYXRlID0gcmVxdWlyZV9pbmZsYXRlKCk7CiAgICAgIHZhciB1dGlscyA9IHJlcXVpcmVfY29tbW9uKCk7CiAgICAgIHZhciBzdHJpbmdzID0gcmVxdWlyZV9zdHJpbmdzKCk7CiAgICAgIHZhciBjID0gcmVxdWlyZV9jb25zdGFudHMoKTsKICAgICAgdmFyIG1zZyA9IHJlcXVpcmVfbWVzc2FnZXMoKTsKICAgICAgdmFyIFpTdHJlYW0gPSByZXF1aXJlX3pzdHJlYW0oKTsKICAgICAgdmFyIEdaaGVhZGVyID0gcmVxdWlyZV9nemhlYWRlcigpOwogICAgICB2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nOwogICAgICBmdW5jdGlvbiBJbmZsYXRlKG9wdGlvbnMpIHsKICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5mbGF0ZSkpCiAgICAgICAgICByZXR1cm4gbmV3IEluZmxhdGUob3B0aW9ucyk7CiAgICAgICAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHsKICAgICAgICAgIGNodW5rU2l6ZTogMTYzODQsCiAgICAgICAgICB3aW5kb3dCaXRzOiAwLAogICAgICAgICAgdG86ICIiCiAgICAgICAgfSwgb3B0aW9ucyB8fCB7fSk7CiAgICAgICAgdmFyIG9wdCA9IHRoaXMub3B0aW9uczsKICAgICAgICBpZiAob3B0LnJhdyAmJiBvcHQud2luZG93Qml0cyA+PSAwICYmIG9wdC53aW5kb3dCaXRzIDwgMTYpIHsKICAgICAgICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzOwogICAgICAgICAgaWYgKG9wdC53aW5kb3dCaXRzID09PSAwKSB7CiAgICAgICAgICAgIG9wdC53aW5kb3dCaXRzID0gLTE1OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAob3B0LndpbmRvd0JpdHMgPj0gMCAmJiBvcHQud2luZG93Qml0cyA8IDE2ICYmICEob3B0aW9ucyAmJiBvcHRpb25zLndpbmRvd0JpdHMpKSB7CiAgICAgICAgICBvcHQud2luZG93Qml0cyArPSAzMjsKICAgICAgICB9CiAgICAgICAgaWYgKG9wdC53aW5kb3dCaXRzID4gMTUgJiYgb3B0LndpbmRvd0JpdHMgPCA0OCkgewogICAgICAgICAgaWYgKChvcHQud2luZG93Qml0cyAmIDE1KSA9PT0gMCkgewogICAgICAgICAgICBvcHQud2luZG93Qml0cyB8PSAxNTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgdGhpcy5lcnIgPSAwOwogICAgICAgIHRoaXMubXNnID0gIiI7CiAgICAgICAgdGhpcy5lbmRlZCA9IGZhbHNlOwogICAgICAgIHRoaXMuY2h1bmtzID0gW107CiAgICAgICAgdGhpcy5zdHJtID0gbmV3IFpTdHJlYW0oKTsKICAgICAgICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDsKICAgICAgICB2YXIgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVJbml0Mih0aGlzLnN0cm0sIG9wdC53aW5kb3dCaXRzKTsKICAgICAgICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7CiAgICAgICAgfQogICAgICAgIHRoaXMuaGVhZGVyID0gbmV3IEdaaGVhZGVyKCk7CiAgICAgICAgemxpYl9pbmZsYXRlLmluZmxhdGVHZXRIZWFkZXIodGhpcy5zdHJtLCB0aGlzLmhlYWRlcik7CiAgICAgICAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7CiAgICAgICAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAic3RyaW5nIikgewogICAgICAgICAgICBvcHQuZGljdGlvbmFyeSA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7CiAgICAgICAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAiW29iamVjdCBBcnJheUJ1ZmZlcl0iKSB7CiAgICAgICAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKG9wdC5yYXcpIHsKICAgICAgICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgb3B0LmRpY3Rpb25hcnkpOwogICAgICAgICAgICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIEluZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihkYXRhLCBtb2RlKSB7CiAgICAgICAgdmFyIHN0cm0gPSB0aGlzLnN0cm07CiAgICAgICAgdmFyIGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7CiAgICAgICAgdmFyIGRpY3Rpb25hcnkgPSB0aGlzLm9wdGlvbnMuZGljdGlvbmFyeTsKICAgICAgICB2YXIgc3RhdHVzLCBfbW9kZTsKICAgICAgICB2YXIgbmV4dF9vdXRfdXRmOCwgdGFpbCwgdXRmOHN0cjsKICAgICAgICB2YXIgYWxsb3dCdWZFcnJvciA9IGZhbHNlOwogICAgICAgIGlmICh0aGlzLmVuZGVkKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgICAgIF9tb2RlID0gbW9kZSA9PT0gfn5tb2RlID8gbW9kZSA6IG1vZGUgPT09IHRydWUgPyBjLlpfRklOSVNIIDogYy5aX05PX0ZMVVNIOwogICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gInN0cmluZyIpIHsKICAgICAgICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLmJpbnN0cmluZzJidWYoZGF0YSk7CiAgICAgICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpID09PSAiW29iamVjdCBBcnJheUJ1ZmZlcl0iKSB7CiAgICAgICAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHN0cm0uaW5wdXQgPSBkYXRhOwogICAgICAgIH0KICAgICAgICBzdHJtLm5leHRfaW4gPSAwOwogICAgICAgIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDsKICAgICAgICBkbyB7CiAgICAgICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpOwogICAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gMDsKICAgICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZShzdHJtLCBjLlpfTk9fRkxVU0gpOwogICAgICAgICAgaWYgKHN0YXR1cyA9PT0gYy5aX05FRURfRElDVCAmJiBkaWN0aW9uYXJ5KSB7CiAgICAgICAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3Rpb25hcnkpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHN0YXR1cyA9PT0gYy5aX0JVRl9FUlJPUiAmJiBhbGxvd0J1ZkVycm9yID09PSB0cnVlKSB7CiAgICAgICAgICAgIHN0YXR1cyA9IGMuWl9PSzsKICAgICAgICAgICAgYWxsb3dCdWZFcnJvciA9IGZhbHNlOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBjLlpfT0spIHsKICAgICAgICAgICAgdGhpcy5vbkVuZChzdGF0dXMpOwogICAgICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHN0cm0ubmV4dF9vdXQpIHsKICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IHN0YXR1cyA9PT0gYy5aX1NUUkVBTV9FTkQgfHwgc3RybS5hdmFpbF9pbiA9PT0gMCAmJiAoX21vZGUgPT09IGMuWl9GSU5JU0ggfHwgX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSkgewogICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgICAgICBuZXh0X291dF91dGY4ID0gc3RyaW5ncy51dGY4Ym9yZGVyKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KTsKICAgICAgICAgICAgICAgIHRhaWwgPSBzdHJtLm5leHRfb3V0IC0gbmV4dF9vdXRfdXRmODsKICAgICAgICAgICAgICAgIHV0ZjhzdHIgPSBzdHJpbmdzLmJ1ZjJzdHJpbmcoc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgpOwogICAgICAgICAgICAgICAgc3RybS5uZXh0X291dCA9IHRhaWw7CiAgICAgICAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZSAtIHRhaWw7CiAgICAgICAgICAgICAgICBpZiAodGFpbCkgewogICAgICAgICAgICAgICAgICB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgsIHRhaWwsIDApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgdGhpcy5vbkRhdGEodXRmOHN0cik7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHRoaXMub25EYXRhKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICAgICAgYWxsb3dCdWZFcnJvciA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfSB3aGlsZSAoKHN0cm0uYXZhaWxfaW4gPiAwIHx8IHN0cm0uYXZhaWxfb3V0ID09PSAwKSAmJiBzdGF0dXMgIT09IGMuWl9TVFJFQU1fRU5EKTsKICAgICAgICBpZiAoc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCkgewogICAgICAgICAgX21vZGUgPSBjLlpfRklOSVNIOwogICAgICAgIH0KICAgICAgICBpZiAoX21vZGUgPT09IGMuWl9GSU5JU0gpIHsKICAgICAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlRW5kKHRoaXMuc3RybSk7CiAgICAgICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7CiAgICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTsKICAgICAgICAgIHJldHVybiBzdGF0dXMgPT09IGMuWl9PSzsKICAgICAgICB9CiAgICAgICAgaWYgKF9tb2RlID09PSBjLlpfU1lOQ19GTFVTSCkgewogICAgICAgICAgdGhpcy5vbkVuZChjLlpfT0spOwogICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSAwOwogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9OwogICAgICBJbmZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihjaHVuaykgewogICAgICAgIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspOwogICAgICB9OwogICAgICBJbmZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uKHN0YXR1cykgewogICAgICAgIGlmIChzdGF0dXMgPT09IGMuWl9PSykgewogICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gInN0cmluZyIpIHsKICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCIiKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHRoaXMuY2h1bmtzID0gW107CiAgICAgICAgdGhpcy5lcnIgPSBzdGF0dXM7CiAgICAgICAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnOwogICAgICB9OwogICAgICBmdW5jdGlvbiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKSB7CiAgICAgICAgdmFyIGluZmxhdG9yID0gbmV3IEluZmxhdGUob3B0aW9ucyk7CiAgICAgICAgaW5mbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7CiAgICAgICAgaWYgKGluZmxhdG9yLmVycikgewogICAgICAgICAgdGhyb3cgaW5mbGF0b3IubXNnIHx8IG1zZ1tpbmZsYXRvci5lcnJdOwogICAgICAgIH0KICAgICAgICByZXR1cm4gaW5mbGF0b3IucmVzdWx0OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGluZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHsKICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsKICAgICAgICBvcHRpb25zLnJhdyA9IHRydWU7CiAgICAgICAgcmV0dXJuIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpOwogICAgICB9CiAgICAgIGV4cG9ydHMyLkluZmxhdGUgPSBJbmZsYXRlOwogICAgICBleHBvcnRzMi5pbmZsYXRlID0gaW5mbGF0ZTsKICAgICAgZXhwb3J0czIuaW5mbGF0ZVJhdyA9IGluZmxhdGVSYXc7CiAgICAgIGV4cG9ydHMyLnVuZ3ppcCA9IGluZmxhdGU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9wYWtvL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfcGFrbyA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9wYWtvL2luZGV4LmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIGFzc2lnbiA9IHJlcXVpcmVfY29tbW9uKCkuYXNzaWduOwogICAgICB2YXIgZGVmbGF0ZSA9IHJlcXVpcmVfZGVmbGF0ZTIoKTsKICAgICAgdmFyIGluZmxhdGUgPSByZXF1aXJlX2luZmxhdGUyKCk7CiAgICAgIHZhciBjb25zdGFudHMgPSByZXF1aXJlX2NvbnN0YW50cygpOwogICAgICB2YXIgcGFrbyA9IHt9OwogICAgICBhc3NpZ24ocGFrbywgZGVmbGF0ZSwgaW5mbGF0ZSwgY29uc3RhbnRzKTsKICAgICAgbW9kdWxlMi5leHBvcnRzID0gcGFrbzsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL2JnemYtZmlsZWhhbmRsZS9kaXN0L3VuemlwLXBha28uanMKICB2YXIgcmVxdWlyZV91bnppcF9wYWtvID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BnbW9kL2JnemYtZmlsZWhhbmRsZS9kaXN0L3VuemlwLXBha28uanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmVfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KCk7CiAgICAgIHZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfcmVnZW5lcmF0b3IoKSk7CiAgICAgIHZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfYXN5bmNUb0dlbmVyYXRvcigpKTsKICAgICAgdmFyIF9yZXF1aXJlID0gcmVxdWlyZV9wYWtvKCk7CiAgICAgIHZhciBaX1NZTkNfRkxVU0ggPSBfcmVxdWlyZS5aX1NZTkNfRkxVU0g7CiAgICAgIHZhciBJbmZsYXRlID0gX3JlcXVpcmUuSW5mbGF0ZTsKICAgICAgZnVuY3Rpb24gdW56aXA0KF94KSB7CiAgICAgICAgcmV0dXJuIF91bnppcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF91bnppcCgpIHsKICAgICAgICBfdW56aXAgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKC8qIEBfX1BVUkVfXyAqLyBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoaW5wdXREYXRhKSB7CiAgICAgICAgICB2YXIgc3RybSwgcG9zLCBpLCBjaHVua3MsIGluZmxhdG9yLCByZW1haW5pbmdJbnB1dCwgX2luZmxhdG9yLCByZXN1bHQ7CiAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkgewogICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHsKICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDA7CiAgICAgICAgICAgICAgICAgIHBvcyA9IDA7CiAgICAgICAgICAgICAgICAgIGkgPSAwOwogICAgICAgICAgICAgICAgICBjaHVua3MgPSBbXTsKICAgICAgICAgICAgICAgIGNhc2UgNDoKICAgICAgICAgICAgICAgICAgcmVtYWluaW5nSW5wdXQgPSBpbnB1dERhdGEuc2xpY2UocG9zKTsKICAgICAgICAgICAgICAgICAgaW5mbGF0b3IgPSBuZXcgSW5mbGF0ZSgpOwogICAgICAgICAgICAgICAgICBfaW5mbGF0b3IgPSBpbmZsYXRvcjsKICAgICAgICAgICAgICAgICAgc3RybSA9IF9pbmZsYXRvci5zdHJtOwogICAgICAgICAgICAgICAgICBpbmZsYXRvci5wdXNoKHJlbWFpbmluZ0lucHV0LCBaX1NZTkNfRkxVU0gpOwogICAgICAgICAgICAgICAgICBpZiAoIWluZmxhdG9yLmVycikgewogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaW5mbGF0b3IubXNnKTsKICAgICAgICAgICAgICAgIGNhc2UgMTE6CiAgICAgICAgICAgICAgICAgIHBvcyArPSBzdHJtLm5leHRfaW47CiAgICAgICAgICAgICAgICAgIGNodW5rc1tpXSA9IGltcG9ydF9idWZmZXIuQnVmZmVyLmZyb20oaW5mbGF0b3IucmVzdWx0KTsKICAgICAgICAgICAgICAgICAgaSArPSAxOwogICAgICAgICAgICAgICAgY2FzZSAxNDoKICAgICAgICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfaW4pIHsKICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgY2FzZSAxNToKICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gaW1wb3J0X2J1ZmZlci5CdWZmZXIuY29uY2F0KGNodW5rcyk7CiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoInJldHVybiIsIHJlc3VsdCk7CiAgICAgICAgICAgICAgICBjYXNlIDE5OgogICAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTk7CiAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbImNhdGNoIl0oMCk7CiAgICAgICAgICAgICAgICAgIGlmICghX2NvbnRleHQudDAubWVzc2FnZS5tYXRjaCgvaW5jb3JyZWN0IGhlYWRlciBjaGVjay8pKSB7CiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIzOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigicHJvYmxlbSBkZWNvbXByZXNzaW5nIGJsb2NrOiBpbmNvcnJlY3QgZ3ppcCBoZWFkZXIgY2hlY2siKTsKICAgICAgICAgICAgICAgIGNhc2UgMjM6CiAgICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfSwgX2NhbGxlZSwgbnVsbCwgW1swLCAxOV1dKTsKICAgICAgICB9KSk7CiAgICAgICAgcmV0dXJuIF91bnppcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHVuemlwQ2h1bmsoX3gyKSB7CiAgICAgICAgcmV0dXJuIF91bnppcENodW5rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gX3VuemlwQ2h1bmsoKSB7CiAgICAgICAgX3VuemlwQ2h1bmsgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKC8qIEBfX1BVUkVfXyAqLyBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGlucHV0RGF0YSkgewogICAgICAgICAgdmFyIHN0cm0sIGNwb3MsIGRwb3MsIGJsb2NrcywgY3Bvc2l0aW9ucywgZHBvc2l0aW9ucywgcmVtYWluaW5nSW5wdXQsIGluZmxhdG9yLCBfYnVmZmVyLCBidWZmZXI7CiAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7CiAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7CiAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMDsKICAgICAgICAgICAgICAgICAgY3BvcyA9IDA7CiAgICAgICAgICAgICAgICAgIGRwb3MgPSAwOwogICAgICAgICAgICAgICAgICBibG9ja3MgPSBbXTsKICAgICAgICAgICAgICAgICAgY3Bvc2l0aW9ucyA9IFtdOwogICAgICAgICAgICAgICAgICBkcG9zaXRpb25zID0gW107CiAgICAgICAgICAgICAgICBjYXNlIDY6CiAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ0lucHV0ID0gaW5wdXREYXRhLnNsaWNlKGNwb3MpOwogICAgICAgICAgICAgICAgICBpbmZsYXRvciA9IG5ldyBJbmZsYXRlKCk7CiAgICAgICAgICAgICAgICAgIHN0cm0gPSBpbmZsYXRvci5zdHJtOwogICAgICAgICAgICAgICAgICBpbmZsYXRvci5wdXNoKHJlbWFpbmluZ0lucHV0LCBaX1NZTkNfRkxVU0gpOwogICAgICAgICAgICAgICAgICBpZiAoIWluZmxhdG9yLmVycikgewogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTI7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGluZmxhdG9yLm1zZyk7CiAgICAgICAgICAgICAgICBjYXNlIDEyOgogICAgICAgICAgICAgICAgICBfYnVmZmVyID0gaW1wb3J0X2J1ZmZlci5CdWZmZXIuZnJvbShpbmZsYXRvci5yZXN1bHQpOwogICAgICAgICAgICAgICAgICBibG9ja3MucHVzaChfYnVmZmVyKTsKICAgICAgICAgICAgICAgICAgY3Bvc2l0aW9ucy5wdXNoKGNwb3MpOwogICAgICAgICAgICAgICAgICBkcG9zaXRpb25zLnB1c2goZHBvcyk7CiAgICAgICAgICAgICAgICAgIGNwb3MgKz0gc3RybS5uZXh0X2luOwogICAgICAgICAgICAgICAgICBkcG9zICs9IF9idWZmZXIubGVuZ3RoOwogICAgICAgICAgICAgICAgY2FzZSAxODoKICAgICAgICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfaW4pIHsKICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDY7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGNhc2UgMTk6CiAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGltcG9ydF9idWZmZXIuQnVmZmVyLmNvbmNhdChibG9ja3MpOwogICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdCgicmV0dXJuIiwgeyBidWZmZXIsIGNwb3NpdGlvbnMsIGRwb3NpdGlvbnMgfSk7CiAgICAgICAgICAgICAgICBjYXNlIDIzOgogICAgICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDIzOwogICAgICAgICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbImNhdGNoIl0oMCk7CiAgICAgICAgICAgICAgICAgIGlmICghX2NvbnRleHQyLnQwLm1lc3NhZ2UubWF0Y2goL2luY29ycmVjdCBoZWFkZXIgY2hlY2svKSkgewogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjc7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJwcm9ibGVtIGRlY29tcHJlc3NpbmcgYmxvY2s6IGluY29ycmVjdCBnemlwIGhlYWRlciBjaGVjayIpOwogICAgICAgICAgICAgICAgY2FzZSAyNzoKICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfSwgX2NhbGxlZTIsIG51bGwsIFtbMCwgMjNdXSk7CiAgICAgICAgfSkpOwogICAgICAgIHJldHVybiBfdW56aXBDaHVuay5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHVuemlwQ2h1bmtTbGljZTIoX3gzLCBfeDQpIHsKICAgICAgICByZXR1cm4gX3VuemlwQ2h1bmtTbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIF91bnppcENodW5rU2xpY2UoKSB7CiAgICAgICAgX3VuemlwQ2h1bmtTbGljZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoaW5wdXREYXRhLCBjaHVuaykgewogICAgICAgICAgdmFyIHN0cm0sIGNwb3MsIGRwb3MsIGRlY29tcHJlc3NlZEJsb2NrcywgY3Bvc2l0aW9ucywgZHBvc2l0aW9ucywgcmVtYWluaW5nSW5wdXQsIGluZmxhdG9yLCBfYnVmZmVyMiwgbGVuLCBvcmlnQ3BvcywgYnVmZmVyOwogICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0MykgewogICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkgewogICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDA7CiAgICAgICAgICAgICAgICAgIGNwb3MgPSBjaHVuay5taW52LmJsb2NrUG9zaXRpb247CiAgICAgICAgICAgICAgICAgIGRwb3MgPSBjaHVuay5taW52LmRhdGFQb3NpdGlvbjsKICAgICAgICAgICAgICAgICAgZGVjb21wcmVzc2VkQmxvY2tzID0gW107CiAgICAgICAgICAgICAgICAgIGNwb3NpdGlvbnMgPSBbXTsKICAgICAgICAgICAgICAgICAgZHBvc2l0aW9ucyA9IFtdOwogICAgICAgICAgICAgICAgY2FzZSA2OgogICAgICAgICAgICAgICAgICByZW1haW5pbmdJbnB1dCA9IGlucHV0RGF0YS5zbGljZShjcG9zIC0gY2h1bmsubWludi5ibG9ja1Bvc2l0aW9uKTsKICAgICAgICAgICAgICAgICAgaW5mbGF0b3IgPSBuZXcgSW5mbGF0ZSgpOwogICAgICAgICAgICAgICAgICBzdHJtID0gaW5mbGF0b3Iuc3RybTsKICAgICAgICAgICAgICAgICAgaW5mbGF0b3IucHVzaChyZW1haW5pbmdJbnB1dCwgWl9TWU5DX0ZMVVNIKTsKICAgICAgICAgICAgICAgICAgaWYgKCFpbmZsYXRvci5lcnIpIHsKICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDEyOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpbmZsYXRvci5tc2cpOwogICAgICAgICAgICAgICAgY2FzZSAxMjoKICAgICAgICAgICAgICAgICAgX2J1ZmZlcjIgPSBpbXBvcnRfYnVmZmVyLkJ1ZmZlci5mcm9tKGluZmxhdG9yLnJlc3VsdCk7CiAgICAgICAgICAgICAgICAgIGRlY29tcHJlc3NlZEJsb2Nrcy5wdXNoKF9idWZmZXIyKTsKICAgICAgICAgICAgICAgICAgbGVuID0gX2J1ZmZlcjIubGVuZ3RoOwogICAgICAgICAgICAgICAgICBjcG9zaXRpb25zLnB1c2goY3Bvcyk7CiAgICAgICAgICAgICAgICAgIGRwb3NpdGlvbnMucHVzaChkcG9zKTsKICAgICAgICAgICAgICAgICAgaWYgKGRlY29tcHJlc3NlZEJsb2Nrcy5sZW5ndGggPT09IDEgJiYgY2h1bmsubWludi5kYXRhUG9zaXRpb24pIHsKICAgICAgICAgICAgICAgICAgICBkZWNvbXByZXNzZWRCbG9ja3NbMF0gPSBkZWNvbXByZXNzZWRCbG9ja3NbMF0uc2xpY2UoY2h1bmsubWludi5kYXRhUG9zaXRpb24pOwogICAgICAgICAgICAgICAgICAgIGxlbiA9IGRlY29tcHJlc3NlZEJsb2Nrc1swXS5sZW5ndGg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgb3JpZ0Nwb3MgPSBjcG9zOwogICAgICAgICAgICAgICAgICBjcG9zICs9IHN0cm0ubmV4dF9pbjsKICAgICAgICAgICAgICAgICAgZHBvcyArPSBsZW47CiAgICAgICAgICAgICAgICAgIGlmICghKG9yaWdDcG9zID49IGNodW5rLm1heHYuYmxvY2tQb3NpdGlvbikpIHsKICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI2OwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGRlY29tcHJlc3NlZEJsb2Nrc1tkZWNvbXByZXNzZWRCbG9ja3MubGVuZ3RoIC0gMV0gPSBkZWNvbXByZXNzZWRCbG9ja3NbZGVjb21wcmVzc2VkQmxvY2tzLmxlbmd0aCAtIDFdLnNsaWNlKDAsIGNodW5rLm1heHYuYmxvY2tQb3NpdGlvbiA9PT0gY2h1bmsubWludi5ibG9ja1Bvc2l0aW9uID8gY2h1bmsubWF4di5kYXRhUG9zaXRpb24gLSBjaHVuay5taW52LmRhdGFQb3NpdGlvbiArIDEgOiBjaHVuay5tYXh2LmRhdGFQb3NpdGlvbiArIDEpOwogICAgICAgICAgICAgICAgICBjcG9zaXRpb25zLnB1c2goY3Bvcyk7CiAgICAgICAgICAgICAgICAgIGRwb3NpdGlvbnMucHVzaChkcG9zKTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoImJyZWFrIiwgMjcpOwogICAgICAgICAgICAgICAgY2FzZSAyNjoKICAgICAgICAgICAgICAgICAgaWYgKHN0cm0uYXZhaWxfaW4pIHsKICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDY7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGNhc2UgMjc6CiAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGltcG9ydF9idWZmZXIuQnVmZmVyLmNvbmNhdChkZWNvbXByZXNzZWRCbG9ja3MpOwogICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdCgicmV0dXJuIiwgeyBidWZmZXIsIGNwb3NpdGlvbnMsIGRwb3NpdGlvbnMgfSk7CiAgICAgICAgICAgICAgICBjYXNlIDMxOgogICAgICAgICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDMxOwogICAgICAgICAgICAgICAgICBfY29udGV4dDMudDAgPSBfY29udGV4dDNbImNhdGNoIl0oMCk7CiAgICAgICAgICAgICAgICAgIGlmICghX2NvbnRleHQzLnQwLm1lc3NhZ2UubWF0Y2goL2luY29ycmVjdCBoZWFkZXIgY2hlY2svKSkgewogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMzU7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJwcm9ibGVtIGRlY29tcHJlc3NpbmcgYmxvY2s6IGluY29ycmVjdCBnemlwIGhlYWRlciBjaGVjayIpOwogICAgICAgICAgICAgICAgY2FzZSAzNToKICAgICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQzLnQwOwogICAgICAgICAgICAgICAgY2FzZSAzNjoKICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfSwgX2NhbGxlZTMsIG51bGwsIFtbMCwgMzFdXSk7CiAgICAgICAgfSkpOwogICAgICAgIHJldHVybiBfdW56aXBDaHVua1NsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgIH0KICAgICAgbW9kdWxlMi5leHBvcnRzID0gewogICAgICAgIHVuemlwOiB1bnppcDQsCiAgICAgICAgdW56aXBDaHVuaywKICAgICAgICB1bnppcENodW5rU2xpY2U6IHVuemlwQ2h1bmtTbGljZTIsCiAgICAgICAgcGFrb1VuemlwOiB1bnppcDQsCiAgICAgICAgbm9kZVVuemlwOiBmdW5jdGlvbiBub2RlVW56aXAoKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIm5vZGVVbnppcCBub3QgaW1wbGVtZW50ZWQuIik7CiAgICAgICAgfQogICAgICB9OwogICAgfQogIH0pOwoKICAvLyAoZGlzYWJsZWQpOm5vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9pbmRleC5qcwogIHZhciByZXF1aXJlX2xpYiA9IF9fY29tbW9uSlMoewogICAgIihkaXNhYmxlZCk6bm9kZV9tb2R1bGVzL0BnbW9kL2JnemYtZmlsZWhhbmRsZS9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2luZGV4LmpzIigpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvYmd6Zi1maWxlaGFuZGxlL2Rpc3QvbG9jYWxGaWxlLmpzCiAgdmFyIHJlcXVpcmVfbG9jYWxGaWxlMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvZGlzdC9sb2NhbEZpbGUuanMiKGV4cG9ydHMyLCBtb2R1bGUyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmVfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KCk7CiAgICAgIHZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfcmVnZW5lcmF0b3IoKSk7CiAgICAgIHZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfYXN5bmNUb0dlbmVyYXRvcigpKTsKICAgICAgdmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfY2xhc3NDYWxsQ2hlY2soKSk7CiAgICAgIHZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2NyZWF0ZUNsYXNzKCkpOwogICAgICB2YXIgZnMgPSByZXF1aXJlX2xpYigpOwogICAgICB2YXIgTG9jYWxGaWxlMiA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHsKICAgICAgICBmdW5jdGlvbiBMb2NhbEZpbGUzKHBhdGgpIHsKICAgICAgICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIExvY2FsRmlsZTMpOwogICAgICAgICAgdGhpcy5mZFByb21pc2UgPSBmcy5vcGVuKHBhdGgsICJyIik7CiAgICAgICAgICB0aGlzLnBhdGggPSBwYXRoOwogICAgICAgIH0KICAgICAgICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShMb2NhbEZpbGUzLCBbeyBrZXk6ICJyZWFkIiwgdmFsdWU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgdmFyIF9yZWFkID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KSgvKiBAX19QVVJFX18gKi8gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKGJ1Ziwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7CiAgICAgICAgICAgIHZhciBmZCwgcmV0OwogICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkgewogICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7CiAgICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZFByb21pc2U7CiAgICAgICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgICAgICBmZCA9IF9jb250ZXh0LnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZzLnJlYWQoZmQsIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTsKICAgICAgICAgICAgICAgICAgY2FzZSA1OgogICAgICAgICAgICAgICAgICAgIHJldCA9IF9jb250ZXh0LnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgicmV0dXJuIiwgcmV0KTsKICAgICAgICAgICAgICAgICAgY2FzZSA3OgogICAgICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTsKICAgICAgICAgIH0pKTsKICAgICAgICAgIGZ1bmN0aW9uIHJlYWQoX3gsIF94MiwgX3gzLCBfeDQpIHsKICAgICAgICAgICAgcmV0dXJuIF9yZWFkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gcmVhZDsKICAgICAgICB9KCkgfSwgeyBrZXk6ICJzdGF0IiwgdmFsdWU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgdmFyIF9zdGF0ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KSgvKiBAX19QVVJFX18gKi8gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHsKICAgICAgICAgICAgdmFyIGZkOwogICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7CiAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkgewogICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyOwogICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZkUHJvbWlzZTsKICAgICAgICAgICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICAgICAgICAgIGZkID0gX2NvbnRleHQyLnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoInJldHVybiIsIGZzLmZzdGF0KGZkKSk7CiAgICAgICAgICAgICAgICAgIGNhc2UgNDoKICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTsKICAgICAgICAgIH0pKTsKICAgICAgICAgIGZ1bmN0aW9uIHN0YXQoKSB7CiAgICAgICAgICAgIHJldHVybiBfc3RhdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHN0YXQ7CiAgICAgICAgfSgpIH1dKTsKICAgICAgICByZXR1cm4gTG9jYWxGaWxlMzsKICAgICAgfSgpOwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBMb2NhbEZpbGUyOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvbG9uZy9zcmMvbG9uZy5qcwogIHZhciByZXF1aXJlX2xvbmcgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvbG9uZy9zcmMvbG9uZy5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICBtb2R1bGUyLmV4cG9ydHMgPSBMb25nMzsKICAgICAgdmFyIHdhc20gPSBudWxsOwogICAgICB0cnkgewogICAgICAgIHdhc20gPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheShbCiAgICAgICAgICAwLAogICAgICAgICAgOTcsCiAgICAgICAgICAxMTUsCiAgICAgICAgICAxMDksCiAgICAgICAgICAxLAogICAgICAgICAgMCwKICAgICAgICAgIDAsCiAgICAgICAgICAwLAogICAgICAgICAgMSwKICAgICAgICAgIDEzLAogICAgICAgICAgMiwKICAgICAgICAgIDk2LAogICAgICAgICAgMCwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjcsCiAgICAgICAgICA5NiwKICAgICAgICAgIDQsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxMjcsCiAgICAgICAgICAxLAogICAgICAgICAgMTI3LAogICAgICAgICAgMywKICAgICAgICAgIDcsCiAgICAgICAgICA2LAogICAgICAgICAgMCwKICAgICAgICAgIDEsCiAgICAgICAgICAxLAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxLAogICAgICAgICAgNiwKICAgICAgICAgIDYsCiAgICAgICAgICAxLAogICAgICAgICAgMTI3LAogICAgICAgICAgMSwKICAgICAgICAgIDY1LAogICAgICAgICAgMCwKICAgICAgICAgIDExLAogICAgICAgICAgNywKICAgICAgICAgIDUwLAogICAgICAgICAgNiwKICAgICAgICAgIDMsCiAgICAgICAgICAxMDksCiAgICAgICAgICAxMTcsCiAgICAgICAgICAxMDgsCiAgICAgICAgICAwLAogICAgICAgICAgMSwKICAgICAgICAgIDUsCiAgICAgICAgICAxMDAsCiAgICAgICAgICAxMDUsCiAgICAgICAgICAxMTgsCiAgICAgICAgICA5NSwKICAgICAgICAgIDExNSwKICAgICAgICAgIDAsCiAgICAgICAgICAyLAogICAgICAgICAgNSwKICAgICAgICAgIDEwMCwKICAgICAgICAgIDEwNSwKICAgICAgICAgIDExOCwKICAgICAgICAgIDk1LAogICAgICAgICAgMTE3LAogICAgICAgICAgMCwKICAgICAgICAgIDMsCiAgICAgICAgICA1LAogICAgICAgICAgMTE0LAogICAgICAgICAgMTAxLAogICAgICAgICAgMTA5LAogICAgICAgICAgOTUsCiAgICAgICAgICAxMTUsCiAgICAgICAgICAwLAogICAgICAgICAgNCwKICAgICAgICAgIDUsCiAgICAgICAgICAxMTQsCiAgICAgICAgICAxMDEsCiAgICAgICAgICAxMDksCiAgICAgICAgICA5NSwKICAgICAgICAgIDExNywKICAgICAgICAgIDAsCiAgICAgICAgICA1LAogICAgICAgICAgOCwKICAgICAgICAgIDEwMywKICAgICAgICAgIDEwMSwKICAgICAgICAgIDExNiwKICAgICAgICAgIDk1LAogICAgICAgICAgMTA0LAogICAgICAgICAgMTA1LAogICAgICAgICAgMTAzLAogICAgICAgICAgMTA0LAogICAgICAgICAgMCwKICAgICAgICAgIDAsCiAgICAgICAgICAxMCwKICAgICAgICAgIDE5MSwKICAgICAgICAgIDEsCiAgICAgICAgICA2LAogICAgICAgICAgNCwKICAgICAgICAgIDAsCiAgICAgICAgICAzNSwKICAgICAgICAgIDAsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyNiwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyNywKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyOCwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEyOSwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMSwKICAgICAgICAgIDM2LAogICAgICAgICAgMSwKICAgICAgICAgIDEsCiAgICAgICAgICAxMjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDAsCiAgICAgICAgICAxNzMsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEsCiAgICAgICAgICAxNzMsCiAgICAgICAgICA2NiwKICAgICAgICAgIDMyLAogICAgICAgICAgMTM0LAogICAgICAgICAgMTMyLAogICAgICAgICAgMzIsCiAgICAgICAgICAyLAogICAgICAgICAgMTczLAogICAgICAgICAgMzIsCiAgICAgICAgICAzLAogICAgICAgICAgMTczLAogICAgICAgICAgNjYsCiAgICAgICAgICAzMiwKICAgICAgICAgIDEzNCwKICAgICAgICAgIDEzMiwKICAgICAgICAgIDEzMCwKICAgICAgICAgIDM0LAogICAgICAgICAgNCwKICAgICAgICAgIDY2LAogICAgICAgICAgMzIsCiAgICAgICAgICAxMzUsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAzNiwKICAgICAgICAgIDAsCiAgICAgICAgICAzMiwKICAgICAgICAgIDQsCiAgICAgICAgICAxNjcsCiAgICAgICAgICAxMQogICAgICAgIF0pKSwge30pLmV4cG9ydHM7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgfQogICAgICBmdW5jdGlvbiBMb25nMyhsb3csIGhpZ2gsIHVuc2lnbmVkKSB7CiAgICAgICAgdGhpcy5sb3cgPSBsb3cgfCAwOwogICAgICAgIHRoaXMuaGlnaCA9IGhpZ2ggfCAwOwogICAgICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkOwogICAgICB9CiAgICAgIExvbmczLnByb3RvdHlwZS5fX2lzTG9uZ19fOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9uZzMucHJvdG90eXBlLCAiX19pc0xvbmdfXyIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGZ1bmN0aW9uIGlzTG9uZyhvYmopIHsKICAgICAgICByZXR1cm4gKG9iaiAmJiBvYmpbIl9faXNMb25nX18iXSkgPT09IHRydWU7CiAgICAgIH0KICAgICAgTG9uZzMuaXNMb25nID0gaXNMb25nOwogICAgICB2YXIgSU5UX0NBQ0hFID0ge307CiAgICAgIHZhciBVSU5UX0NBQ0hFID0ge307CiAgICAgIGZ1bmN0aW9uIGZyb21JbnQodmFsdWUsIHVuc2lnbmVkKSB7CiAgICAgICAgdmFyIG9iaiwgY2FjaGVkT2JqLCBjYWNoZTsKICAgICAgICBpZiAodW5zaWduZWQpIHsKICAgICAgICAgIHZhbHVlID4+Pj0gMDsKICAgICAgICAgIGlmIChjYWNoZSA9IDAgPD0gdmFsdWUgJiYgdmFsdWUgPCAyNTYpIHsKICAgICAgICAgICAgY2FjaGVkT2JqID0gVUlOVF9DQUNIRVt2YWx1ZV07CiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopCiAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajsKICAgICAgICAgIH0KICAgICAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCAodmFsdWUgfCAwKSA8IDAgPyAtMSA6IDAsIHRydWUpOwogICAgICAgICAgaWYgKGNhY2hlKQogICAgICAgICAgICBVSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajsKICAgICAgICAgIHJldHVybiBvYmo7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHZhbHVlIHw9IDA7CiAgICAgICAgICBpZiAoY2FjaGUgPSAtMTI4IDw9IHZhbHVlICYmIHZhbHVlIDwgMTI4KSB7CiAgICAgICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07CiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopCiAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajsKICAgICAgICAgIH0KICAgICAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCB2YWx1ZSA8IDAgPyAtMSA6IDAsIGZhbHNlKTsKICAgICAgICAgIGlmIChjYWNoZSkKICAgICAgICAgICAgSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajsKICAgICAgICAgIHJldHVybiBvYmo7CiAgICAgICAgfQogICAgICB9CiAgICAgIExvbmczLmZyb21JbnQgPSBmcm9tSW50OwogICAgICBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlLCB1bnNpZ25lZCkgewogICAgICAgIGlmIChpc05hTih2YWx1ZSkpCiAgICAgICAgICByZXR1cm4gdW5zaWduZWQgPyBVWkVSTyA6IFpFUk87CiAgICAgICAgaWYgKHVuc2lnbmVkKSB7CiAgICAgICAgICBpZiAodmFsdWUgPCAwKQogICAgICAgICAgICByZXR1cm4gVVpFUk87CiAgICAgICAgICBpZiAodmFsdWUgPj0gVFdPX1BXUl82NF9EQkwpCiAgICAgICAgICAgIHJldHVybiBNQVhfVU5TSUdORURfVkFMVUU7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGlmICh2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwpCiAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7CiAgICAgICAgICBpZiAodmFsdWUgKyAxID49IFRXT19QV1JfNjNfREJMKQogICAgICAgICAgICByZXR1cm4gTUFYX1ZBTFVFOwogICAgICAgIH0KICAgICAgICBpZiAodmFsdWUgPCAwKQogICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLCB1bnNpZ25lZCkubmVnKCk7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwgfCAwLCB2YWx1ZSAvIFRXT19QV1JfMzJfREJMIHwgMCwgdW5zaWduZWQpOwogICAgICB9CiAgICAgIExvbmczLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyOwogICAgICBmdW5jdGlvbiBmcm9tQml0cyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpIHsKICAgICAgICByZXR1cm4gbmV3IExvbmczKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCk7CiAgICAgIH0KICAgICAgTG9uZzMuZnJvbUJpdHMgPSBmcm9tQml0czsKICAgICAgdmFyIHBvd19kYmwgPSBNYXRoLnBvdzsKICAgICAgZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIsIHVuc2lnbmVkLCByYWRpeCkgewogICAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwKQogICAgICAgICAgdGhyb3cgRXJyb3IoImVtcHR5IHN0cmluZyIpOwogICAgICAgIGlmIChzdHIgPT09ICJOYU4iIHx8IHN0ciA9PT0gIkluZmluaXR5IiB8fCBzdHIgPT09ICIrSW5maW5pdHkiIHx8IHN0ciA9PT0gIi1JbmZpbml0eSIpCiAgICAgICAgICByZXR1cm4gWkVSTzsKICAgICAgICBpZiAodHlwZW9mIHVuc2lnbmVkID09PSAibnVtYmVyIikgewogICAgICAgICAgcmFkaXggPSB1bnNpZ25lZCwgdW5zaWduZWQgPSBmYWxzZTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdW5zaWduZWQgPSAhIXVuc2lnbmVkOwogICAgICAgIH0KICAgICAgICByYWRpeCA9IHJhZGl4IHx8IDEwOwogICAgICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeCkKICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoInJhZGl4Iik7CiAgICAgICAgdmFyIHA7CiAgICAgICAgaWYgKChwID0gc3RyLmluZGV4T2YoIi0iKSkgPiAwKQogICAgICAgICAgdGhyb3cgRXJyb3IoImludGVyaW9yIGh5cGhlbiIpOwogICAgICAgIGVsc2UgaWYgKHAgPT09IDApIHsKICAgICAgICAgIHJldHVybiBmcm9tU3RyaW5nKHN0ci5zdWJzdHJpbmcoMSksIHVuc2lnbmVkLCByYWRpeCkubmVnKCk7CiAgICAgICAgfQogICAgICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDgpKTsKICAgICAgICB2YXIgcmVzdWx0ID0gWkVSTzsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gOCkgewogICAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbig4LCBzdHIubGVuZ3RoIC0gaSksIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTsKICAgICAgICAgIGlmIChzaXplIDwgOCkgewogICAgICAgICAgICB2YXIgcG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIHNpemUpKTsKICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChwb3dlcikuYWRkKGZyb21OdW1iZXIodmFsdWUpKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocmFkaXhUb1Bvd2VyKTsKICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJlc3VsdC51bnNpZ25lZCA9IHVuc2lnbmVkOwogICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgIH0KICAgICAgTG9uZzMuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7CiAgICAgIGZ1bmN0aW9uIGZyb21WYWx1ZSh2YWwsIHVuc2lnbmVkKSB7CiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICJudW1iZXIiKQogICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodmFsLCB1bnNpZ25lZCk7CiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICJzdHJpbmciKQogICAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcodmFsLCB1bnNpZ25lZCk7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHZhbC5sb3csIHZhbC5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICJib29sZWFuIiA/IHVuc2lnbmVkIDogdmFsLnVuc2lnbmVkKTsKICAgICAgfQogICAgICBMb25nMy5mcm9tVmFsdWUgPSBmcm9tVmFsdWU7CiAgICAgIHZhciBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7CiAgICAgIHZhciBUV09fUFdSXzI0X0RCTCA9IDEgPDwgMjQ7CiAgICAgIHZhciBUV09fUFdSXzMyX0RCTCA9IFRXT19QV1JfMTZfREJMICogVFdPX1BXUl8xNl9EQkw7CiAgICAgIHZhciBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7CiAgICAgIHZhciBUV09fUFdSXzYzX0RCTCA9IFRXT19QV1JfNjRfREJMIC8gMjsKICAgICAgdmFyIFRXT19QV1JfMjQgPSBmcm9tSW50KFRXT19QV1JfMjRfREJMKTsKICAgICAgdmFyIFpFUk8gPSBmcm9tSW50KDApOwogICAgICBMb25nMy5aRVJPID0gWkVSTzsKICAgICAgdmFyIFVaRVJPID0gZnJvbUludCgwLCB0cnVlKTsKICAgICAgTG9uZzMuVVpFUk8gPSBVWkVSTzsKICAgICAgdmFyIE9ORSA9IGZyb21JbnQoMSk7CiAgICAgIExvbmczLk9ORSA9IE9ORTsKICAgICAgdmFyIFVPTkUgPSBmcm9tSW50KDEsIHRydWUpOwogICAgICBMb25nMy5VT05FID0gVU9ORTsKICAgICAgdmFyIE5FR19PTkUgPSBmcm9tSW50KC0xKTsKICAgICAgTG9uZzMuTkVHX09ORSA9IE5FR19PTkU7CiAgICAgIHZhciBNQVhfVkFMVUUgPSBmcm9tQml0cyg0Mjk0OTY3Mjk1IHwgMCwgMjE0NzQ4MzY0NyB8IDAsIGZhbHNlKTsKICAgICAgTG9uZzMuTUFYX1ZBTFVFID0gTUFYX1ZBTFVFOwogICAgICB2YXIgTUFYX1VOU0lHTkVEX1ZBTFVFID0gZnJvbUJpdHMoNDI5NDk2NzI5NSB8IDAsIDQyOTQ5NjcyOTUgfCAwLCB0cnVlKTsKICAgICAgTG9uZzMuTUFYX1VOU0lHTkVEX1ZBTFVFID0gTUFYX1VOU0lHTkVEX1ZBTFVFOwogICAgICB2YXIgTUlOX1ZBTFVFID0gZnJvbUJpdHMoMCwgMjE0NzQ4MzY0OCB8IDAsIGZhbHNlKTsKICAgICAgTG9uZzMuTUlOX1ZBTFVFID0gTUlOX1ZBTFVFOwogICAgICB2YXIgTG9uZ1Byb3RvdHlwZSA9IExvbmczLnByb3RvdHlwZTsKICAgICAgTG9uZ1Byb3RvdHlwZS50b0ludCA9IGZ1bmN0aW9uIHRvSW50KCkgewogICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gdGhpcy5sb3cgPj4+IDAgOiB0aGlzLmxvdzsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyMigpIHsKICAgICAgICBpZiAodGhpcy51bnNpZ25lZCkKICAgICAgICAgIHJldHVybiAodGhpcy5oaWdoID4+PiAwKSAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTsKICAgICAgICByZXR1cm4gdGhpcy5oaWdoICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcocmFkaXgpIHsKICAgICAgICByYWRpeCA9IHJhZGl4IHx8IDEwOwogICAgICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeCkKICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoInJhZGl4Iik7CiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpCiAgICAgICAgICByZXR1cm4gIjAiOwogICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgewogICAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkgewogICAgICAgICAgICB2YXIgcmFkaXhMb25nID0gZnJvbU51bWJlcihyYWRpeCksIGRpdiA9IHRoaXMuZGl2KHJhZGl4TG9uZyksIHJlbTEgPSBkaXYubXVsKHJhZGl4TG9uZykuc3ViKHRoaXMpOwogICAgICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7CiAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgcmV0dXJuICItIiArIHRoaXMubmVnKCkudG9TdHJpbmcocmFkaXgpOwogICAgICAgIH0KICAgICAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA2KSwgdGhpcy51bnNpZ25lZCksIHJlbSA9IHRoaXM7CiAgICAgICAgdmFyIHJlc3VsdCA9ICIiOwogICAgICAgIHdoaWxlICh0cnVlKSB7CiAgICAgICAgICB2YXIgcmVtRGl2ID0gcmVtLmRpdihyYWRpeFRvUG93ZXIpLCBpbnR2YWwgPSByZW0uc3ViKHJlbURpdi5tdWwocmFkaXhUb1Bvd2VyKSkudG9JbnQoKSA+Pj4gMCwgZGlnaXRzID0gaW50dmFsLnRvU3RyaW5nKHJhZGl4KTsKICAgICAgICAgIHJlbSA9IHJlbURpdjsKICAgICAgICAgIGlmIChyZW0uaXNaZXJvKCkpCiAgICAgICAgICAgIHJldHVybiBkaWdpdHMgKyByZXN1bHQ7CiAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCA2KQogICAgICAgICAgICAgIGRpZ2l0cyA9ICIwIiArIGRpZ2l0czsKICAgICAgICAgICAgcmVzdWx0ID0gIiIgKyBkaWdpdHMgKyByZXN1bHQ7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHMoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHNVbnNpZ25lZCgpIHsKICAgICAgICByZXR1cm4gdGhpcy5oaWdoID4+PiAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmdldExvd0JpdHMgPSBmdW5jdGlvbiBnZXRMb3dCaXRzKCkgewogICAgICAgIHJldHVybiB0aGlzLmxvdzsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5nZXRMb3dCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRMb3dCaXRzVW5zaWduZWQoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMubG93ID4+PiAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmdldE51bUJpdHNBYnMgPSBmdW5jdGlvbiBnZXROdW1CaXRzQWJzKCkgewogICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkKICAgICAgICAgIHJldHVybiB0aGlzLmVxKE1JTl9WQUxVRSkgPyA2NCA6IHRoaXMubmVnKCkuZ2V0TnVtQml0c0FicygpOwogICAgICAgIHZhciB2YWwgPSB0aGlzLmhpZ2ggIT0gMCA/IHRoaXMuaGlnaCA6IHRoaXMubG93OwogICAgICAgIGZvciAodmFyIGJpdCA9IDMxOyBiaXQgPiAwOyBiaXQtLSkKICAgICAgICAgIGlmICgodmFsICYgMSA8PCBiaXQpICE9IDApCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgIHJldHVybiB0aGlzLmhpZ2ggIT0gMCA/IGJpdCArIDMzIDogYml0ICsgMTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8oKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gMCAmJiB0aGlzLmxvdyA9PT0gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5lcXogPSBMb25nUHJvdG90eXBlLmlzWmVybzsKICAgICAgTG9uZ1Byb3RvdHlwZS5pc05lZ2F0aXZlID0gZnVuY3Rpb24gaXNOZWdhdGl2ZSgpIHsKICAgICAgICByZXR1cm4gIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoIDwgMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gaXNQb3NpdGl2ZSgpIHsKICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCB8fCB0aGlzLmhpZ2ggPj0gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uIGlzT2RkKCkgewogICAgICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiBpc0V2ZW4oKSB7CiAgICAgICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAwOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikgewogICAgICAgIGlmICghaXNMb25nKG90aGVyKSkKICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTsKICAgICAgICBpZiAodGhpcy51bnNpZ25lZCAhPT0gb3RoZXIudW5zaWduZWQgJiYgdGhpcy5oaWdoID4+PiAzMSA9PT0gMSAmJiBvdGhlci5oaWdoID4+PiAzMSA9PT0gMSkKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICByZXR1cm4gdGhpcy5oaWdoID09PSBvdGhlci5oaWdoICYmIHRoaXMubG93ID09PSBvdGhlci5sb3c7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuZXEgPSBMb25nUHJvdG90eXBlLmVxdWFsczsKICAgICAgTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHMgPSBmdW5jdGlvbiBub3RFcXVhbHMob3RoZXIpIHsKICAgICAgICByZXR1cm4gIXRoaXMuZXEob3RoZXIpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLm5lcSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzOwogICAgICBMb25nUHJvdG90eXBlLm5lID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7CiAgICAgIExvbmdQcm90b3R5cGUubGVzc1RoYW4gPSBmdW5jdGlvbiBsZXNzVGhhbihvdGhlcikgewogICAgICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpIDwgMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5sdCA9IExvbmdQcm90b3R5cGUubGVzc1RoYW47CiAgICAgIExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsID0gZnVuY3Rpb24gbGVzc1RoYW5PckVxdWFsKG90aGVyKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuY29tcChvdGhlcikgPD0gMDsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5sdGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDsKICAgICAgTG9uZ1Byb3RvdHlwZS5sZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsOwogICAgICBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gZ3JlYXRlclRoYW4ob3RoZXIpIHsKICAgICAgICByZXR1cm4gdGhpcy5jb21wKG90aGVyKSA+IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuZ3QgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuOwogICAgICBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuT3JFcXVhbChvdGhlcikgewogICAgICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpID49IDA7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuZ3RlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7CiAgICAgIExvbmdQcm90b3R5cGUuZ2UgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDsKICAgICAgTG9uZ1Byb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShvdGhlcikgewogICAgICAgIGlmICghaXNMb25nKG90aGVyKSkKICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTsKICAgICAgICBpZiAodGhpcy5lcShvdGhlcikpCiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB2YXIgdGhpc05lZyA9IHRoaXMuaXNOZWdhdGl2ZSgpLCBvdGhlck5lZyA9IG90aGVyLmlzTmVnYXRpdmUoKTsKICAgICAgICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpCiAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgaWYgKCF0aGlzTmVnICYmIG90aGVyTmVnKQogICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKQogICAgICAgICAgcmV0dXJuIHRoaXMuc3ViKG90aGVyKS5pc05lZ2F0aXZlKCkgPyAtMSA6IDE7CiAgICAgICAgcmV0dXJuIG90aGVyLmhpZ2ggPj4+IDAgPiB0aGlzLmhpZ2ggPj4+IDAgfHwgb3RoZXIuaGlnaCA9PT0gdGhpcy5oaWdoICYmIG90aGVyLmxvdyA+Pj4gMCA+IHRoaXMubG93ID4+PiAwID8gLTEgOiAxOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLmNvbXAgPSBMb25nUHJvdG90eXBlLmNvbXBhcmU7CiAgICAgIExvbmdQcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gbmVnYXRlKCkgewogICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmVxKE1JTl9WQUxVRSkpCiAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFOwogICAgICAgIHJldHVybiB0aGlzLm5vdCgpLmFkZChPTkUpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLm5lZyA9IExvbmdQcm90b3R5cGUubmVnYXRlOwogICAgICBMb25nUHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChhZGRlbmQpIHsKICAgICAgICBpZiAoIWlzTG9uZyhhZGRlbmQpKQogICAgICAgICAgYWRkZW5kID0gZnJvbVZhbHVlKGFkZGVuZCk7CiAgICAgICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7CiAgICAgICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDY1NTM1OwogICAgICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7CiAgICAgICAgdmFyIGEwMCA9IHRoaXMubG93ICYgNjU1MzU7CiAgICAgICAgdmFyIGI0OCA9IGFkZGVuZC5oaWdoID4+PiAxNjsKICAgICAgICB2YXIgYjMyID0gYWRkZW5kLmhpZ2ggJiA2NTUzNTsKICAgICAgICB2YXIgYjE2ID0gYWRkZW5kLmxvdyA+Pj4gMTY7CiAgICAgICAgdmFyIGIwMCA9IGFkZGVuZC5sb3cgJiA2NTUzNTsKICAgICAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDsKICAgICAgICBjMDAgKz0gYTAwICsgYjAwOwogICAgICAgIGMxNiArPSBjMDAgPj4+IDE2OwogICAgICAgIGMwMCAmPSA2NTUzNTsKICAgICAgICBjMTYgKz0gYTE2ICsgYjE2OwogICAgICAgIGMzMiArPSBjMTYgPj4+IDE2OwogICAgICAgIGMxNiAmPSA2NTUzNTsKICAgICAgICBjMzIgKz0gYTMyICsgYjMyOwogICAgICAgIGM0OCArPSBjMzIgPj4+IDE2OwogICAgICAgIGMzMiAmPSA2NTUzNTsKICAgICAgICBjNDggKz0gYTQ4ICsgYjQ4OwogICAgICAgIGM0OCAmPSA2NTUzNTsKICAgICAgICByZXR1cm4gZnJvbUJpdHMoYzE2IDw8IDE2IHwgYzAwLCBjNDggPDwgMTYgfCBjMzIsIHRoaXMudW5zaWduZWQpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3Qoc3VidHJhaGVuZCkgewogICAgICAgIGlmICghaXNMb25nKHN1YnRyYWhlbmQpKQogICAgICAgICAgc3VidHJhaGVuZCA9IGZyb21WYWx1ZShzdWJ0cmFoZW5kKTsKICAgICAgICByZXR1cm4gdGhpcy5hZGQoc3VidHJhaGVuZC5uZWcoKSk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuc3ViID0gTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdDsKICAgICAgTG9uZ1Byb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KG11bHRpcGxpZXIpIHsKICAgICAgICBpZiAodGhpcy5pc1plcm8oKSkKICAgICAgICAgIHJldHVybiBaRVJPOwogICAgICAgIGlmICghaXNMb25nKG11bHRpcGxpZXIpKQogICAgICAgICAgbXVsdGlwbGllciA9IGZyb21WYWx1ZShtdWx0aXBsaWVyKTsKICAgICAgICBpZiAod2FzbSkgewogICAgICAgICAgdmFyIGxvdyA9IHdhc20ubXVsKHRoaXMubG93LCB0aGlzLmhpZ2gsIG11bHRpcGxpZXIubG93LCBtdWx0aXBsaWVyLmhpZ2gpOwogICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICB9CiAgICAgICAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpCiAgICAgICAgICByZXR1cm4gWkVSTzsKICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKQogICAgICAgICAgcmV0dXJuIG11bHRpcGxpZXIuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87CiAgICAgICAgaWYgKG11bHRpcGxpZXIuZXEoTUlOX1ZBTFVFKSkKICAgICAgICAgIHJldHVybiB0aGlzLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPOwogICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgewogICAgICAgICAgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKQogICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllci5uZWcoKSk7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyKS5uZWcoKTsKICAgICAgICB9IGVsc2UgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKQogICAgICAgICAgcmV0dXJuIHRoaXMubXVsKG11bHRpcGxpZXIubmVnKCkpLm5lZygpOwogICAgICAgIGlmICh0aGlzLmx0KFRXT19QV1JfMjQpICYmIG11bHRpcGxpZXIubHQoVFdPX1BXUl8yNCkpCiAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLnRvTnVtYmVyKCkgKiBtdWx0aXBsaWVyLnRvTnVtYmVyKCksIHRoaXMudW5zaWduZWQpOwogICAgICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2OwogICAgICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiA2NTUzNTsKICAgICAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2OwogICAgICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDY1NTM1OwogICAgICAgIHZhciBiNDggPSBtdWx0aXBsaWVyLmhpZ2ggPj4+IDE2OwogICAgICAgIHZhciBiMzIgPSBtdWx0aXBsaWVyLmhpZ2ggJiA2NTUzNTsKICAgICAgICB2YXIgYjE2ID0gbXVsdGlwbGllci5sb3cgPj4+IDE2OwogICAgICAgIHZhciBiMDAgPSBtdWx0aXBsaWVyLmxvdyAmIDY1NTM1OwogICAgICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwOwogICAgICAgIGMwMCArPSBhMDAgKiBiMDA7CiAgICAgICAgYzE2ICs9IGMwMCA+Pj4gMTY7CiAgICAgICAgYzAwICY9IDY1NTM1OwogICAgICAgIGMxNiArPSBhMTYgKiBiMDA7CiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7CiAgICAgICAgYzE2ICY9IDY1NTM1OwogICAgICAgIGMxNiArPSBhMDAgKiBiMTY7CiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7CiAgICAgICAgYzE2ICY9IDY1NTM1OwogICAgICAgIGMzMiArPSBhMzIgKiBiMDA7CiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7CiAgICAgICAgYzMyICY9IDY1NTM1OwogICAgICAgIGMzMiArPSBhMTYgKiBiMTY7CiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7CiAgICAgICAgYzMyICY9IDY1NTM1OwogICAgICAgIGMzMiArPSBhMDAgKiBiMzI7CiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7CiAgICAgICAgYzMyICY9IDY1NTM1OwogICAgICAgIGM0OCArPSBhNDggKiBiMDAgKyBhMzIgKiBiMTYgKyBhMTYgKiBiMzIgKyBhMDAgKiBiNDg7CiAgICAgICAgYzQ4ICY9IDY1NTM1OwogICAgICAgIHJldHVybiBmcm9tQml0cyhjMTYgPDwgMTYgfCBjMDAsIGM0OCA8PCAxNiB8IGMzMiwgdGhpcy51bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUubXVsID0gTG9uZ1Byb3RvdHlwZS5tdWx0aXBseTsKICAgICAgTG9uZ1Byb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiBkaXZpZGUoZGl2aXNvcikgewogICAgICAgIGlmICghaXNMb25nKGRpdmlzb3IpKQogICAgICAgICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTsKICAgICAgICBpZiAoZGl2aXNvci5pc1plcm8oKSkKICAgICAgICAgIHRocm93IEVycm9yKCJkaXZpc2lvbiBieSB6ZXJvIik7CiAgICAgICAgaWYgKHdhc20pIHsKICAgICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPT09IC0yMTQ3NDgzNjQ4ICYmIGRpdmlzb3IubG93ID09PSAtMSAmJiBkaXZpc29yLmhpZ2ggPT09IC0xKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbS5kaXZfdSA6IHdhc20uZGl2X3MpKHRoaXMubG93LCB0aGlzLmhpZ2gsIGRpdmlzb3IubG93LCBkaXZpc29yLmhpZ2gpOwogICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICB9CiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpCiAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTzsKICAgICAgICB2YXIgYXBwcm94LCByZW0sIHJlczsKICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQpIHsKICAgICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHsKICAgICAgICAgICAgaWYgKGRpdmlzb3IuZXEoT05FKSB8fCBkaXZpc29yLmVxKE5FR19PTkUpKQogICAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7CiAgICAgICAgICAgIGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSkKICAgICAgICAgICAgICByZXR1cm4gT05FOwogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICB2YXIgaGFsZlRoaXMgPSB0aGlzLnNocigxKTsKICAgICAgICAgICAgICBhcHByb3ggPSBoYWxmVGhpcy5kaXYoZGl2aXNvcikuc2hsKDEpOwogICAgICAgICAgICAgIGlmIChhcHByb3guZXEoWkVSTykpIHsKICAgICAgICAgICAgICAgIHJldHVybiBkaXZpc29yLmlzTmVnYXRpdmUoKSA/IE9ORSA6IE5FR19PTkU7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHJlbSA9IHRoaXMuc3ViKGRpdmlzb3IubXVsKGFwcHJveCkpOwogICAgICAgICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTsKICAgICAgICAgICAgICAgIHJldHVybiByZXM7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSkKICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87CiAgICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsKICAgICAgICAgICAgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKQogICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yLm5lZygpKTsKICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IpLm5lZygpOwogICAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSkKICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpOwogICAgICAgICAgcmVzID0gWkVSTzsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgaWYgKCFkaXZpc29yLnVuc2lnbmVkKQogICAgICAgICAgICBkaXZpc29yID0gZGl2aXNvci50b1Vuc2lnbmVkKCk7CiAgICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzKSkKICAgICAgICAgICAgcmV0dXJuIFVaRVJPOwogICAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcy5zaHJ1KDEpKSkKICAgICAgICAgICAgcmV0dXJuIFVPTkU7CiAgICAgICAgICByZXMgPSBVWkVSTzsKICAgICAgICB9CiAgICAgICAgcmVtID0gdGhpczsKICAgICAgICB3aGlsZSAocmVtLmd0ZShkaXZpc29yKSkgewogICAgICAgICAgYXBwcm94ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihyZW0udG9OdW1iZXIoKSAvIGRpdmlzb3IudG9OdW1iZXIoKSkpOwogICAgICAgICAgdmFyIGxvZzIgPSBNYXRoLmNlaWwoTWF0aC5sb2coYXBwcm94KSAvIE1hdGguTE4yKSwgZGVsdGEgPSBsb2cyIDw9IDQ4ID8gMSA6IHBvd19kYmwoMiwgbG9nMiAtIDQ4KSwgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gpLCBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpOwogICAgICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHsKICAgICAgICAgICAgYXBwcm94IC09IGRlbHRhOwogICAgICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCwgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYXBwcm94UmVzLmlzWmVybygpKQogICAgICAgICAgICBhcHByb3hSZXMgPSBPTkU7CiAgICAgICAgICByZXMgPSByZXMuYWRkKGFwcHJveFJlcyk7CiAgICAgICAgICByZW0gPSByZW0uc3ViKGFwcHJveFJlbSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXM7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuZGl2ID0gTG9uZ1Byb3RvdHlwZS5kaXZpZGU7CiAgICAgIExvbmdQcm90b3R5cGUubW9kdWxvID0gZnVuY3Rpb24gbW9kdWxvKGRpdmlzb3IpIHsKICAgICAgICBpZiAoIWlzTG9uZyhkaXZpc29yKSkKICAgICAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7CiAgICAgICAgaWYgKHdhc20pIHsKICAgICAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc20ucmVtX3UgOiB3YXNtLnJlbV9zKSh0aGlzLmxvdywgdGhpcy5oaWdoLCBkaXZpc29yLmxvdywgZGl2aXNvci5oaWdoKTsKICAgICAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0aGlzLnN1Yih0aGlzLmRpdihkaXZpc29yKS5tdWwoZGl2aXNvcikpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLm1vZCA9IExvbmdQcm90b3R5cGUubW9kdWxvOwogICAgICBMb25nUHJvdG90eXBlLnJlbSA9IExvbmdQcm90b3R5cGUubW9kdWxvOwogICAgICBMb25nUHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uIG5vdCgpIHsKICAgICAgICByZXR1cm4gZnJvbUJpdHMofnRoaXMubG93LCB+dGhpcy5oaWdoLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQob3RoZXIpIHsKICAgICAgICBpZiAoIWlzTG9uZyhvdGhlcikpCiAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93ICYgb3RoZXIubG93LCB0aGlzLmhpZ2ggJiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKG90aGVyKSB7CiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKQogICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpOwogICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyB8IG90aGVyLmxvdywgdGhpcy5oaWdoIHwgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yKG90aGVyKSB7CiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKQogICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpOwogICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyBeIG90aGVyLmxvdywgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gc2hpZnRMZWZ0KG51bUJpdHMpIHsKICAgICAgICBpZiAoaXNMb25nKG51bUJpdHMpKQogICAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTsKICAgICAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKQogICAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IDw8IG51bUJpdHMsIHRoaXMuaGlnaCA8PCBudW1CaXRzIHwgdGhpcy5sb3cgPj4+IDMyIC0gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgZWxzZQogICAgICAgICAgcmV0dXJuIGZyb21CaXRzKDAsIHRoaXMubG93IDw8IG51bUJpdHMgLSAzMiwgdGhpcy51bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuc2hsID0gTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQ7CiAgICAgIExvbmdQcm90b3R5cGUuc2hpZnRSaWdodCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHQobnVtQml0cykgewogICAgICAgIGlmIChpc0xvbmcobnVtQml0cykpCiAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpOwogICAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApCiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpCiAgICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPj4+IG51bUJpdHMgfCB0aGlzLmhpZ2ggPDwgMzIgLSBudW1CaXRzLCB0aGlzLmhpZ2ggPj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7CiAgICAgICAgZWxzZQogICAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+PiBudW1CaXRzIC0gMzIsIHRoaXMuaGlnaCA+PSAwID8gMCA6IC0xLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgfTsKICAgICAgTG9uZ1Byb3RvdHlwZS5zaHIgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHQ7CiAgICAgIExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkID0gZnVuY3Rpb24gc2hpZnRSaWdodFVuc2lnbmVkKG51bUJpdHMpIHsKICAgICAgICBpZiAoaXNMb25nKG51bUJpdHMpKQogICAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTsKICAgICAgICBudW1CaXRzICY9IDYzOwogICAgICAgIGlmIChudW1CaXRzID09PSAwKQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgZWxzZSB7CiAgICAgICAgICB2YXIgaGlnaCA9IHRoaXMuaGlnaDsKICAgICAgICAgIGlmIChudW1CaXRzIDwgMzIpIHsKICAgICAgICAgICAgdmFyIGxvdyA9IHRoaXMubG93OwogICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMobG93ID4+PiBudW1CaXRzIHwgaGlnaCA8PCAzMiAtIG51bUJpdHMsIGhpZ2ggPj4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpOwogICAgICAgICAgfSBlbHNlIGlmIChudW1CaXRzID09PSAzMikKICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGhpZ2gsIDAsIHRoaXMudW5zaWduZWQpOwogICAgICAgICAgZWxzZQogICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoaGlnaCA+Pj4gbnVtQml0cyAtIDMyLCAwLCB0aGlzLnVuc2lnbmVkKTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUuc2hydSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkOwogICAgICBMb25nUHJvdG90eXBlLnNocl91ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7CiAgICAgIExvbmdQcm90b3R5cGUudG9TaWduZWQgPSBmdW5jdGlvbiB0b1NpZ25lZCgpIHsKICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQpCiAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgZmFsc2UpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLnRvVW5zaWduZWQgPSBmdW5jdGlvbiB0b1Vuc2lnbmVkKCkgewogICAgICAgIGlmICh0aGlzLnVuc2lnbmVkKQogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIHRydWUpOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbiB0b0J5dGVzKGxlKSB7CiAgICAgICAgcmV0dXJuIGxlID8gdGhpcy50b0J5dGVzTEUoKSA6IHRoaXMudG9CeXRlc0JFKCk7CiAgICAgIH07CiAgICAgIExvbmdQcm90b3R5cGUudG9CeXRlc0xFID0gZnVuY3Rpb24gdG9CeXRlc0xFKCkgewogICAgICAgIHZhciBoaSA9IHRoaXMuaGlnaCwgbG8gPSB0aGlzLmxvdzsKICAgICAgICByZXR1cm4gWwogICAgICAgICAgbG8gJiAyNTUsCiAgICAgICAgICBsbyA+Pj4gOCAmIDI1NSwKICAgICAgICAgIGxvID4+PiAxNiAmIDI1NSwKICAgICAgICAgIGxvID4+PiAyNCwKICAgICAgICAgIGhpICYgMjU1LAogICAgICAgICAgaGkgPj4+IDggJiAyNTUsCiAgICAgICAgICBoaSA+Pj4gMTYgJiAyNTUsCiAgICAgICAgICBoaSA+Pj4gMjQKICAgICAgICBdOwogICAgICB9OwogICAgICBMb25nUHJvdG90eXBlLnRvQnl0ZXNCRSA9IGZ1bmN0aW9uIHRvQnl0ZXNCRSgpIHsKICAgICAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsIGxvID0gdGhpcy5sb3c7CiAgICAgICAgcmV0dXJuIFsKICAgICAgICAgIGhpID4+PiAyNCwKICAgICAgICAgIGhpID4+PiAxNiAmIDI1NSwKICAgICAgICAgIGhpID4+PiA4ICYgMjU1LAogICAgICAgICAgaGkgJiAyNTUsCiAgICAgICAgICBsbyA+Pj4gMjQsCiAgICAgICAgICBsbyA+Pj4gMTYgJiAyNTUsCiAgICAgICAgICBsbyA+Pj4gOCAmIDI1NSwKICAgICAgICAgIGxvICYgMjU1CiAgICAgICAgXTsKICAgICAgfTsKICAgICAgTG9uZzMuZnJvbUJ5dGVzID0gZnVuY3Rpb24gZnJvbUJ5dGVzMihieXRlcywgdW5zaWduZWQsIGxlKSB7CiAgICAgICAgcmV0dXJuIGxlID8gTG9uZzMuZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSA6IExvbmczLmZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmczLmZyb21CeXRlc0xFID0gZnVuY3Rpb24gZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSB7CiAgICAgICAgcmV0dXJuIG5ldyBMb25nMyhieXRlc1swXSB8IGJ5dGVzWzFdIDw8IDggfCBieXRlc1syXSA8PCAxNiB8IGJ5dGVzWzNdIDw8IDI0LCBieXRlc1s0XSB8IGJ5dGVzWzVdIDw8IDggfCBieXRlc1s2XSA8PCAxNiB8IGJ5dGVzWzddIDw8IDI0LCB1bnNpZ25lZCk7CiAgICAgIH07CiAgICAgIExvbmczLmZyb21CeXRlc0JFID0gZnVuY3Rpb24gZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKSB7CiAgICAgICAgcmV0dXJuIG5ldyBMb25nMyhieXRlc1s0XSA8PCAyNCB8IGJ5dGVzWzVdIDw8IDE2IHwgYnl0ZXNbNl0gPDwgOCB8IGJ5dGVzWzddLCBieXRlc1swXSA8PCAyNCB8IGJ5dGVzWzFdIDw8IDE2IHwgYnl0ZXNbMl0gPDwgOCB8IGJ5dGVzWzNdLCB1bnNpZ25lZCk7CiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvZGlzdC9nemlJbmRleC5qcwogIHZhciByZXF1aXJlX2d6aUluZGV4ID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BnbW9kL2JnemYtZmlsZWhhbmRsZS9kaXN0L2d6aUluZGV4LmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlX2ludGVyb3BSZXF1aXJlRGVmYXVsdCgpOwogICAgICB2YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3JlZ2VuZXJhdG9yKCkpOwogICAgICB2YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2FzeW5jVG9HZW5lcmF0b3IoKSk7CiAgICAgIHZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2NsYXNzQ2FsbENoZWNrKCkpOwogICAgICB2YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZV9jcmVhdGVDbGFzcygpKTsKICAgICAgdmFyIExvbmczID0gcmVxdWlyZV9sb25nKCk7CiAgICAgIHZhciBMb2NhbEZpbGUyID0gcmVxdWlyZV9sb2NhbEZpbGUyKCk7CiAgICAgIHZhciBVTkNPTVBSRVNTRURfUE9TSVRJT04gPSAxOwogICAgICB2YXIgR3ppSW5kZXggPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7CiAgICAgICAgZnVuY3Rpb24gR3ppSW5kZXgyKF9yZWYpIHsKICAgICAgICAgIHZhciBmaWxlaGFuZGxlID0gX3JlZi5maWxlaGFuZGxlLCBwYXRoID0gX3JlZi5wYXRoOwogICAgICAgICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgR3ppSW5kZXgyKTsKICAgICAgICAgIGlmIChmaWxlaGFuZGxlKQogICAgICAgICAgICB0aGlzLmZpbGVoYW5kbGUgPSBmaWxlaGFuZGxlOwogICAgICAgICAgZWxzZSBpZiAocGF0aCkKICAgICAgICAgICAgdGhpcy5maWxlaGFuZGxlID0gbmV3IExvY2FsRmlsZTIocGF0aCk7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImVpdGhlciBmaWxlaGFuZGxlIG9yIHBhdGggbXVzdCBiZSBkZWZpbmVkIik7CiAgICAgICAgfQogICAgICAgICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEd6aUluZGV4MiwgW3sga2V5OiAiX3JlYWRMb25nV2l0aE92ZXJmbG93IiwgdmFsdWU6IGZ1bmN0aW9uIF9yZWFkTG9uZ1dpdGhPdmVyZmxvdyhidWYpIHsKICAgICAgICAgIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IDA7CiAgICAgICAgICB2YXIgdW5zaWduZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6IHRydWU7CiAgICAgICAgICB2YXIgbG9uZyA9IExvbmczLmZyb21CeXRlc0xFKGJ1Zi5zbGljZShvZmZzZXQsIG9mZnNldCArIDgpLCB1bnNpZ25lZCk7CiAgICAgICAgICBpZiAobG9uZy5ncmVhdGVyVGhhbihOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikgfHwgbG9uZy5sZXNzVGhhbihOdW1iZXIuTUlOX1NBRkVfSU5URUdFUikpCiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImludGVnZXIgb3ZlcmZsb3ciKTsKICAgICAgICAgIHJldHVybiBsb25nLnRvTnVtYmVyKCk7CiAgICAgICAgfSB9LCB7IGtleTogIl9nZXRJbmRleCIsIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SW5kZXgoKSB7CiAgICAgICAgICBpZiAoIXRoaXMuaW5kZXgpCiAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLl9yZWFkSW5kZXgoKTsKICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4OwogICAgICAgIH0gfSwgewogICAgICAgICAga2V5OiAiX3JlYWRJbmRleCIsCiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciBfcmVhZEluZGV4MiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHsKICAgICAgICAgICAgICB2YXIgYnVmLCBudW1FbnRyaWVzLCBlbnRyaWVzLCBidWZTaXplLCBlbnRyeU51bWJlciwgY29tcHJlc3NlZFBvc2l0aW9uLCB1bmNvbXByZXNzZWRQb3NpdGlvbjsKICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkgewogICAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkgewogICAgICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgICAgIGJ1ZiA9IGltcG9ydF9idWZmZXIuQnVmZmVyLmFsbG9jVW5zYWZlKDgpOwogICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlaGFuZGxlLnJlYWQoYnVmLCAwLCA4LCAwKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgICAgICAgICBudW1FbnRyaWVzID0gdGhpcy5fcmVhZExvbmdXaXRoT3ZlcmZsb3coYnVmLCAwLCB0cnVlKTsKICAgICAgICAgICAgICAgICAgICAgIGlmIChudW1FbnRyaWVzKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2OwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoInJldHVybiIsIFtbMCwgMF1dKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDY6CiAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzID0gbmV3IEFycmF5KG51bUVudHJpZXMgKyAxKTsKICAgICAgICAgICAgICAgICAgICAgIGVudHJpZXNbMF0gPSBbMCwgMF07CiAgICAgICAgICAgICAgICAgICAgICBidWZTaXplID0gOCAqIDIgKiBudW1FbnRyaWVzOwogICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYnVmU2l6ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiaW50ZWdlciBvdmVyZmxvdyIpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6CiAgICAgICAgICAgICAgICAgICAgICBidWYgPSBpbXBvcnRfYnVmZmVyLkJ1ZmZlci5hbGxvY1Vuc2FmZShidWZTaXplKTsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNDsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGVoYW5kbGUucmVhZChidWYsIDAsIGJ1ZlNpemUsIDgpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6CiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGVudHJ5TnVtYmVyID0gMDsgZW50cnlOdW1iZXIgPCBudW1FbnRyaWVzOyBlbnRyeU51bWJlciArPSAxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXByZXNzZWRQb3NpdGlvbiA9IHRoaXMuX3JlYWRMb25nV2l0aE92ZXJmbG93KGJ1ZiwgZW50cnlOdW1iZXIgKiAxNik7CiAgICAgICAgICAgICAgICAgICAgICAgIHVuY29tcHJlc3NlZFBvc2l0aW9uID0gdGhpcy5fcmVhZExvbmdXaXRoT3ZlcmZsb3coYnVmLCBlbnRyeU51bWJlciAqIDE2ICsgOCk7CiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJpZXNbZW50cnlOdW1iZXIgKyAxXSA9IFtjb21wcmVzc2VkUG9zaXRpb24sIHVuY29tcHJlc3NlZFBvc2l0aW9uXTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoInJldHVybiIsIGVudHJpZXMpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6CiAgICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTsKICAgICAgICAgICAgfSkpOwogICAgICAgICAgICBmdW5jdGlvbiBfcmVhZEluZGV4KCkgewogICAgICAgICAgICAgIHJldHVybiBfcmVhZEluZGV4Mi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBfcmVhZEluZGV4OwogICAgICAgICAgfSgpCiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiZ2V0TGFzdEJsb2NrIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgdmFyIF9nZXRMYXN0QmxvY2sgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKC8qIEBfX1BVUkVfXyAqLyBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkgewogICAgICAgICAgICAgIHZhciBlbnRyaWVzOwogICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHsKICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkgewogICAgICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRJbmRleCgpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgICAgICAgIGVudHJpZXMgPSBfY29udGV4dDIuc2VudDsKICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDU7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoInJldHVybiIsIHZvaWQgMCk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoInJldHVybiIsIGVudHJpZXNbZW50cmllcy5sZW5ndGggLSAxXSk7CiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OgogICAgICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTsKICAgICAgICAgICAgfSkpOwogICAgICAgICAgICBmdW5jdGlvbiBnZXRMYXN0QmxvY2soKSB7CiAgICAgICAgICAgICAgcmV0dXJuIF9nZXRMYXN0QmxvY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gZ2V0TGFzdEJsb2NrOwogICAgICAgICAgfSgpCiAgICAgICAgfSwgewogICAgICAgICAga2V5OiAiZ2V0UmVsZXZhbnRCbG9ja3NGb3JSZWFkIiwKICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgdmFyIF9nZXRSZWxldmFudEJsb2Nrc0ZvclJlYWQgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKC8qIEBfX1BVUkVfXyAqLyBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGxlbmd0aCwgcG9zaXRpb24pIHsKICAgICAgICAgICAgICB2YXIgZW5kUG9zaXRpb24sIGVudHJpZXMsIHJlbGV2YW50LCBjb21wYXJlLCBsb3dlckJvdW5kLCB1cHBlckJvdW5kLCBzZWFyY2hQb3NpdGlvbiwgY29tcGFyaXNvbiwgaTsKICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7CiAgICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHsKICAgICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgICBlbmRQb3NpdGlvbiA9IHBvc2l0aW9uICsgbGVuZ3RoOwogICAgICAgICAgICAgICAgICAgICAgaWYgKCEobGVuZ3RoID09PSAwKSkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDM7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoInJldHVybiIsIFtdKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDU7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SW5kZXgoKTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDU6CiAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzID0gX2NvbnRleHQzLnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgICByZWxldmFudCA9IFtdOwogICAgICAgICAgICAgICAgICAgICAgY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUyKGVudHJ5LCBuZXh0RW50cnkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVuY29tcHJlc3NlZFBvc2l0aW9uID0gZW50cnlbVU5DT01QUkVTU0VEX1BPU0lUSU9OXTsKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRVbmNvbXByZXNzZWRQb3NpdGlvbiA9IG5leHRFbnRyeSA/IG5leHRFbnRyeVtVTkNPTVBSRVNTRURfUE9TSVRJT05dIDogSW5maW5pdHk7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmNvbXByZXNzZWRQb3NpdGlvbiA8PSBwb3NpdGlvbiAmJiBuZXh0VW5jb21wcmVzc2VkUG9zaXRpb24gPiBwb3NpdGlvbikgewogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmNvbXByZXNzZWRQb3NpdGlvbiA8IHBvc2l0aW9uKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxOwogICAgICAgICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgICAgICAgIGxvd2VyQm91bmQgPSAwOwogICAgICAgICAgICAgICAgICAgICAgdXBwZXJCb3VuZCA9IGVudHJpZXMubGVuZ3RoIC0gMTsKICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFBvc2l0aW9uID0gTWF0aC5mbG9vcihlbnRyaWVzLmxlbmd0aCAvIDIpOwogICAgICAgICAgICAgICAgICAgICAgY29tcGFyaXNvbiA9IGNvbXBhcmUoZW50cmllc1tzZWFyY2hQb3NpdGlvbl0sIGVudHJpZXNbc2VhcmNoUG9zaXRpb24gKyAxXSk7CiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyaXNvbiAhPT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyaXNvbiA+IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckJvdW5kID0gc2VhcmNoUG9zaXRpb24gLSAxOwogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbXBhcmlzb24gPCAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJCb3VuZCA9IHNlYXJjaFBvc2l0aW9uICsgMTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hQb3NpdGlvbiA9IE1hdGguY2VpbCgodXBwZXJCb3VuZCAtIGxvd2VyQm91bmQpIC8gMikgKyBsb3dlckJvdW5kOwogICAgICAgICAgICAgICAgICAgICAgICBjb21wYXJpc29uID0gY29tcGFyZShlbnRyaWVzW3NlYXJjaFBvc2l0aW9uXSwgZW50cmllc1tzZWFyY2hQb3NpdGlvbiArIDFdKTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHJlbGV2YW50LnB1c2goZW50cmllc1tzZWFyY2hQb3NpdGlvbl0pOwogICAgICAgICAgICAgICAgICAgICAgaSA9IHNlYXJjaFBvc2l0aW9uICsgMTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OgogICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaSA8IGVudHJpZXMubGVuZ3RoKSkgewogICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDIyOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIHJlbGV2YW50LnB1c2goZW50cmllc1tpXSk7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIShlbnRyaWVzW2ldW1VOQ09NUFJFU1NFRF9QT1NJVElPTl0gPj0gZW5kUG9zaXRpb24pKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTk7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoImJyZWFrIiwgMjIpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMTk6CiAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE1OwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMjoKICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWxldmFudFtyZWxldmFudC5sZW5ndGggLSAxXVtVTkNPTVBSRVNTRURfUE9TSVRJT05dIDwgZW5kUG9zaXRpb24pIHsKICAgICAgICAgICAgICAgICAgICAgICAgcmVsZXZhbnQucHVzaChbXSk7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdCgicmV0dXJuIiwgcmVsZXZhbnQpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgMjQ6CiAgICAgICAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSwgX2NhbGxlZTMsIHRoaXMpOwogICAgICAgICAgICB9KSk7CiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFJlbGV2YW50QmxvY2tzRm9yUmVhZChfeCwgX3gyKSB7CiAgICAgICAgICAgICAgcmV0dXJuIF9nZXRSZWxldmFudEJsb2Nrc0ZvclJlYWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gZ2V0UmVsZXZhbnRCbG9ja3NGb3JSZWFkOwogICAgICAgICAgfSgpCiAgICAgICAgfV0pOwogICAgICAgIHJldHVybiBHemlJbmRleDI7CiAgICAgIH0oKTsKICAgICAgbW9kdWxlMi5leHBvcnRzID0gR3ppSW5kZXg7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvZGlzdC9iZ3pGaWxlaGFuZGxlLmpzCiAgdmFyIHJlcXVpcmVfYmd6RmlsZWhhbmRsZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvZGlzdC9iZ3pGaWxlaGFuZGxlLmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlX2ludGVyb3BSZXF1aXJlRGVmYXVsdCgpOwogICAgICB2YXIgX3NsaWNlZFRvQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX3NsaWNlZFRvQXJyYXkoKSk7CiAgICAgIHZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfcmVnZW5lcmF0b3IoKSk7CiAgICAgIHZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfYXN5bmNUb0dlbmVyYXRvcigpKTsKICAgICAgdmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmVfY2xhc3NDYWxsQ2hlY2soKSk7CiAgICAgIHZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlX2NyZWF0ZUNsYXNzKCkpOwogICAgICB2YXIgX3JlcXVpcmUgPSByZXF1aXJlX3VuemlwX3Bha28oKTsKICAgICAgdmFyIHVuemlwNCA9IF9yZXF1aXJlLnVuemlwOwogICAgICB2YXIgTG9jYWxGaWxlMiA9IHJlcXVpcmVfbG9jYWxGaWxlMigpOwogICAgICB2YXIgR3ppSW5kZXggPSByZXF1aXJlX2d6aUluZGV4KCk7CiAgICAgIHZhciBCZ3pGaWxlaGFuZGxlID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkgewogICAgICAgIGZ1bmN0aW9uIEJnekZpbGVoYW5kbGUyKF9yZWYpIHsKICAgICAgICAgIHZhciBmaWxlaGFuZGxlID0gX3JlZi5maWxlaGFuZGxlLCBwYXRoID0gX3JlZi5wYXRoLCBnemlGaWxlaGFuZGxlID0gX3JlZi5nemlGaWxlaGFuZGxlLCBnemlQYXRoID0gX3JlZi5nemlQYXRoOwogICAgICAgICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgQmd6RmlsZWhhbmRsZTIpOwogICAgICAgICAgaWYgKGZpbGVoYW5kbGUpCiAgICAgICAgICAgIHRoaXMuZmlsZWhhbmRsZSA9IGZpbGVoYW5kbGU7CiAgICAgICAgICBlbHNlIGlmIChwYXRoKQogICAgICAgICAgICB0aGlzLmZpbGVoYW5kbGUgPSBuZXcgTG9jYWxGaWxlMihwYXRoKTsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiZWl0aGVyIGZpbGVoYW5kbGUgb3IgcGF0aCBtdXN0IGJlIGRlZmluZWQiKTsKICAgICAgICAgIGlmICghZ3ppRmlsZWhhbmRsZSAmJiAhZ3ppUGF0aCAmJiAhcGF0aCkKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiZWl0aGVyIGd6aUZpbGVoYW5kbGUgb3IgZ3ppUGF0aCBtdXN0IGJlIGRlZmluZWQiKTsKICAgICAgICAgIHRoaXMuZ3ppID0gbmV3IEd6aUluZGV4KHsKICAgICAgICAgICAgZmlsZWhhbmRsZTogZ3ppRmlsZWhhbmRsZSwKICAgICAgICAgICAgcGF0aDogIWd6aUZpbGVoYW5kbGUgJiYgIWd6aVBhdGggJiYgcGF0aCA/IGd6aVBhdGggOiAiIi5jb25jYXQocGF0aCwgIi5nemkiKQogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICAgICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEJnekZpbGVoYW5kbGUyLCBbeyBrZXk6ICJzdGF0IiwgdmFsdWU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgdmFyIF9zdGF0ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KSgvKiBAX19QVVJFX18gKi8gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkgewogICAgICAgICAgICB2YXIgY29tcHJlc3NlZFN0YXQ7CiAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7CiAgICAgICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHsKICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyOwogICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGVoYW5kbGUuc3RhdCgpOwogICAgICAgICAgICAgICAgICBjYXNlIDI6CiAgICAgICAgICAgICAgICAgICAgY29tcHJlc3NlZFN0YXQgPSBfY29udGV4dC5zZW50OwogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gT2JqZWN0OwogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnQxID0gY29tcHJlc3NlZFN0YXQ7CiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VW5jb21wcmVzc2VkRmlsZVNpemUoKTsKICAgICAgICAgICAgICAgICAgY2FzZSA3OgogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnQyID0gX2NvbnRleHQuc2VudDsKICAgICAgICAgICAgICAgICAgICBfY29udGV4dC50MyA9IHZvaWQgMDsKICAgICAgICAgICAgICAgICAgICBfY29udGV4dC50NCA9IHZvaWQgMDsKICAgICAgICAgICAgICAgICAgICBfY29udGV4dC50NSA9IHsgc2l6ZTogX2NvbnRleHQudDIsIGJsb2NrczogX2NvbnRleHQudDMsIGJsa3NpemU6IF9jb250ZXh0LnQ0IH07CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgicmV0dXJuIiwgX2NvbnRleHQudDAuYXNzaWduLmNhbGwoX2NvbnRleHQudDAsIF9jb250ZXh0LnQxLCBfY29udGV4dC50NSkpOwogICAgICAgICAgICAgICAgICBjYXNlIDEyOgogICAgICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTsKICAgICAgICAgIH0pKTsKICAgICAgICAgIGZ1bmN0aW9uIHN0YXQoKSB7CiAgICAgICAgICAgIHJldHVybiBfc3RhdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHN0YXQ7CiAgICAgICAgfSgpIH0sIHsga2V5OiAiZ2V0VW5jb21wcmVzc2VkRmlsZVNpemUiLCB2YWx1ZTogZnVuY3Rpb24oKSB7CiAgICAgICAgICB2YXIgX2dldFVuY29tcHJlc3NlZEZpbGVTaXplID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KSgvKiBAX19QVVJFX18gKi8gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHsKICAgICAgICAgICAgdmFyIF9yZWYyLCBfcmVmMywgdW5jb21wcmVzc2VkUG9zaXRpb24sIF9yZWY0LCBzaXplLCBidWYsIF9yZWY1LCBieXRlc1JlYWQsIGxhc3RCbG9ja1VuY29tcHJlc3NlZFNpemU7CiAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHsKICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7CiAgICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3ppLmdldExhc3RCbG9jaygpOwogICAgICAgICAgICAgICAgICBjYXNlIDI6CiAgICAgICAgICAgICAgICAgICAgX3JlZjIgPSBfY29udGV4dDIuc2VudDsKICAgICAgICAgICAgICAgICAgICBfcmVmMyA9ICgwLCBfc2xpY2VkVG9BcnJheTIuZGVmYXVsdCkoX3JlZjIsIDIpOwogICAgICAgICAgICAgICAgICAgIHVuY29tcHJlc3NlZFBvc2l0aW9uID0gX3JlZjNbMV07CiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA3OwogICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGVoYW5kbGUuc3RhdCgpOwogICAgICAgICAgICAgICAgICBjYXNlIDc6CiAgICAgICAgICAgICAgICAgICAgX3JlZjQgPSBfY29udGV4dDIuc2VudDsKICAgICAgICAgICAgICAgICAgICBzaXplID0gX3JlZjQuc2l6ZTsKICAgICAgICAgICAgICAgICAgICBidWYgPSBpbXBvcnRfYnVmZmVyLkJ1ZmZlci5hbGxvY1Vuc2FmZSg0KTsKICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEyOwogICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGVoYW5kbGUucmVhZChidWYsIDAsIDQsIHNpemUgLSAyOCAtIDQpOwogICAgICAgICAgICAgICAgICBjYXNlIDEyOgogICAgICAgICAgICAgICAgICAgIF9yZWY1ID0gX2NvbnRleHQyLnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgYnl0ZXNSZWFkID0gX3JlZjUuYnl0ZXNSZWFkOwogICAgICAgICAgICAgICAgICAgIGlmICghKGJ5dGVzUmVhZCAhPT0gNCkpIHsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTY7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJyZWFkIGVycm9yIik7CiAgICAgICAgICAgICAgICAgIGNhc2UgMTY6CiAgICAgICAgICAgICAgICAgICAgbGFzdEJsb2NrVW5jb21wcmVzc2VkU2l6ZSA9IGJ1Zi5yZWFkVUludDMyTEUoMCk7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoInJldHVybiIsIHVuY29tcHJlc3NlZFBvc2l0aW9uICsgbGFzdEJsb2NrVW5jb21wcmVzc2VkU2l6ZSk7CiAgICAgICAgICAgICAgICAgIGNhc2UgMTg6CiAgICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7CiAgICAgICAgICB9KSk7CiAgICAgICAgICBmdW5jdGlvbiBnZXRVbmNvbXByZXNzZWRGaWxlU2l6ZSgpIHsKICAgICAgICAgICAgcmV0dXJuIF9nZXRVbmNvbXByZXNzZWRGaWxlU2l6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGdldFVuY29tcHJlc3NlZEZpbGVTaXplOwogICAgICAgIH0oKSB9LCB7IGtleTogIl9yZWFkQW5kVW5jb21wcmVzc0Jsb2NrIiwgdmFsdWU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgdmFyIF9yZWFkQW5kVW5jb21wcmVzc0Jsb2NrMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoLyogQF9fUFVSRV9fICovIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoYmxvY2tCdWZmZXIsIF9yZWY2LCBfcmVmNykgewogICAgICAgICAgICB2YXIgX3JlZjgsIGNvbXByZXNzZWRQb3NpdGlvbiwgX3JlZjksIG5leHRDb21wcmVzc2VkUG9zaXRpb24sIG5leHQsIGJsb2NrQ29tcHJlc3NlZExlbmd0aCwgdW56aXBwZWRCdWZmZXI7CiAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHsKICAgICAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7CiAgICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgICBfcmVmOCA9ICgwLCBfc2xpY2VkVG9BcnJheTIuZGVmYXVsdCkoX3JlZjYsIDEpLCBjb21wcmVzc2VkUG9zaXRpb24gPSBfcmVmOFswXTsKICAgICAgICAgICAgICAgICAgICBfcmVmOSA9ICgwLCBfc2xpY2VkVG9BcnJheTIuZGVmYXVsdCkoX3JlZjcsIDEpLCBuZXh0Q29tcHJlc3NlZFBvc2l0aW9uID0gX3JlZjlbMF07CiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IG5leHRDb21wcmVzc2VkUG9zaXRpb247CiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQpIHsKICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNzsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDY7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsZWhhbmRsZS5zdGF0KCk7CiAgICAgICAgICAgICAgICAgIGNhc2UgNjoKICAgICAgICAgICAgICAgICAgICBuZXh0ID0gX2NvbnRleHQzLnNlbnQuc2l6ZTsKICAgICAgICAgICAgICAgICAgY2FzZSA3OgogICAgICAgICAgICAgICAgICAgIGJsb2NrQ29tcHJlc3NlZExlbmd0aCA9IG5leHQgLSBjb21wcmVzc2VkUG9zaXRpb247CiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMDsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlaGFuZGxlLnJlYWQoYmxvY2tCdWZmZXIsIDAsIGJsb2NrQ29tcHJlc3NlZExlbmd0aCwgY29tcHJlc3NlZFBvc2l0aW9uKTsKICAgICAgICAgICAgICAgICAgY2FzZSAxMDoKICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDEyOwogICAgICAgICAgICAgICAgICAgIHJldHVybiB1bnppcDQoYmxvY2tCdWZmZXIuc2xpY2UoMCwgYmxvY2tDb21wcmVzc2VkTGVuZ3RoKSk7CiAgICAgICAgICAgICAgICAgIGNhc2UgMTI6CiAgICAgICAgICAgICAgICAgICAgdW56aXBwZWRCdWZmZXIgPSBfY29udGV4dDMuc2VudDsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdCgicmV0dXJuIiwgdW56aXBwZWRCdWZmZXIpOwogICAgICAgICAgICAgICAgICBjYXNlIDE0OgogICAgICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwgX2NhbGxlZTMsIHRoaXMpOwogICAgICAgICAgfSkpOwogICAgICAgICAgZnVuY3Rpb24gX3JlYWRBbmRVbmNvbXByZXNzQmxvY2soX3gsIF94MiwgX3gzKSB7CiAgICAgICAgICAgIHJldHVybiBfcmVhZEFuZFVuY29tcHJlc3NCbG9jazIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBfcmVhZEFuZFVuY29tcHJlc3NCbG9jazsKICAgICAgICB9KCkgfSwgeyBrZXk6ICJyZWFkIiwgdmFsdWU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgdmFyIF9yZWFkID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KSgvKiBAX19QVVJFX18gKi8gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlNChidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikgewogICAgICAgICAgICB2YXIgYmxvY2tQb3NpdGlvbnMsIGJsb2NrQnVmZmVyLCBkZXN0aW5hdGlvbk9mZnNldCwgYnl0ZXNSZWFkLCBibG9ja051bSwgdW5jb21wcmVzc2VkQnVmZmVyLCBfYmxvY2tQb3NpdGlvbnMkYmxvY2ssIHVuY29tcHJlc3NlZFBvc2l0aW9uLCBzb3VyY2VPZmZzZXQsIHNvdXJjZUVuZDsKICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkgewogICAgICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHsKICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMjsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nemkuZ2V0UmVsZXZhbnRCbG9ja3NGb3JSZWFkKGxlbmd0aCwgcG9zaXRpb24pOwogICAgICAgICAgICAgICAgICBjYXNlIDI6CiAgICAgICAgICAgICAgICAgICAgYmxvY2tQb3NpdGlvbnMgPSBfY29udGV4dDQuc2VudDsKICAgICAgICAgICAgICAgICAgICBibG9ja0J1ZmZlciA9IGltcG9ydF9idWZmZXIuQnVmZmVyLmFsbG9jVW5zYWZlKDMyNzY4ICogMik7CiAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25PZmZzZXQgPSBvZmZzZXQ7CiAgICAgICAgICAgICAgICAgICAgYnl0ZXNSZWFkID0gMDsKICAgICAgICAgICAgICAgICAgICBibG9ja051bSA9IDA7CiAgICAgICAgICAgICAgICAgIGNhc2UgNzoKICAgICAgICAgICAgICAgICAgICBpZiAoIShibG9ja051bSA8IGJsb2NrUG9zaXRpb25zLmxlbmd0aCAtIDEpKSB7CiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDE4OwogICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTA7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRBbmRVbmNvbXByZXNzQmxvY2soYmxvY2tCdWZmZXIsIGJsb2NrUG9zaXRpb25zW2Jsb2NrTnVtXSwgYmxvY2tQb3NpdGlvbnNbYmxvY2tOdW0gKyAxXSk7CiAgICAgICAgICAgICAgICAgIGNhc2UgMTA6CiAgICAgICAgICAgICAgICAgICAgdW5jb21wcmVzc2VkQnVmZmVyID0gX2NvbnRleHQ0LnNlbnQ7CiAgICAgICAgICAgICAgICAgICAgX2Jsb2NrUG9zaXRpb25zJGJsb2NrID0gKDAsIF9zbGljZWRUb0FycmF5Mi5kZWZhdWx0KShibG9ja1Bvc2l0aW9uc1tibG9ja051bV0sIDIpLCB1bmNvbXByZXNzZWRQb3NpdGlvbiA9IF9ibG9ja1Bvc2l0aW9ucyRibG9ja1sxXTsKICAgICAgICAgICAgICAgICAgICBzb3VyY2VPZmZzZXQgPSB1bmNvbXByZXNzZWRQb3NpdGlvbiA+PSBwb3NpdGlvbiA/IDAgOiBwb3NpdGlvbiAtIHVuY29tcHJlc3NlZFBvc2l0aW9uOwogICAgICAgICAgICAgICAgICAgIHNvdXJjZUVuZCA9IE1hdGgubWluKHBvc2l0aW9uICsgbGVuZ3RoLCB1bmNvbXByZXNzZWRQb3NpdGlvbiArIHVuY29tcHJlc3NlZEJ1ZmZlci5sZW5ndGgpIC0gdW5jb21wcmVzc2VkUG9zaXRpb247CiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZU9mZnNldCA+PSAwICYmIHNvdXJjZU9mZnNldCA8IHVuY29tcHJlc3NlZEJ1ZmZlci5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICAgIHVuY29tcHJlc3NlZEJ1ZmZlci5jb3B5KGJ1ZiwgZGVzdGluYXRpb25PZmZzZXQsIHNvdXJjZU9mZnNldCwgc291cmNlRW5kKTsKICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uT2Zmc2V0ICs9IHNvdXJjZUVuZCAtIHNvdXJjZU9mZnNldDsKICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzUmVhZCArPSBzb3VyY2VFbmQgLSBzb3VyY2VPZmZzZXQ7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBjYXNlIDE1OgogICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtICs9IDE7CiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA3OwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICBjYXNlIDE4OgogICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KCJyZXR1cm4iLCB7IGJ5dGVzUmVhZCwgYnVmZmVyOiBidWYgfSk7CiAgICAgICAgICAgICAgICAgIGNhc2UgMTk6CiAgICAgICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LCBfY2FsbGVlNCwgdGhpcyk7CiAgICAgICAgICB9KSk7CiAgICAgICAgICBmdW5jdGlvbiByZWFkKF94NCwgX3g1LCBfeDYsIF94NykgewogICAgICAgICAgICByZXR1cm4gX3JlYWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiByZWFkOwogICAgICAgIH0oKSB9XSk7CiAgICAgICAgcmV0dXJuIEJnekZpbGVoYW5kbGUyOwogICAgICB9KCk7CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IEJnekZpbGVoYW5kbGU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC9iZ3pmLWZpbGVoYW5kbGUvZGlzdC9pbmRleC5qcwogIHZhciByZXF1aXJlX2Rpc3QyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL0BnbW9kL2JnemYtZmlsZWhhbmRsZS9kaXN0L2luZGV4LmpzIihleHBvcnRzMiwgbW9kdWxlMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgdmFyIEJnemZGaWxlaGFuZGxlID0gcmVxdWlyZV9iZ3pGaWxlaGFuZGxlKCk7CiAgICAgIHZhciBfcmVxdWlyZSA9IHJlcXVpcmVfdW56aXBfcGFrbygpOwogICAgICB2YXIgdW56aXA0ID0gX3JlcXVpcmUudW56aXA7CiAgICAgIHZhciB1bnppcENodW5rID0gX3JlcXVpcmUudW56aXBDaHVuazsKICAgICAgdmFyIHVuemlwQ2h1bmtTbGljZTIgPSBfcmVxdWlyZS51bnppcENodW5rU2xpY2U7CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9IHsgQmd6ZkZpbGVoYW5kbGUsIHVuemlwOiB1bnppcDQsIHVuemlwQ2h1bmssIHVuemlwQ2h1bmtTbGljZTogdW56aXBDaHVua1NsaWNlMiB9OwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvaXMtb2JzZXJ2YWJsZS9pbmRleC5qcwogIHZhciByZXF1aXJlX2lzX29ic2VydmFibGUgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvaXMtb2JzZXJ2YWJsZS9pbmRleC5qcyIoZXhwb3J0czIsIG1vZHVsZTIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIG1vZHVsZTIuZXhwb3J0cyA9ICh2YWx1ZSkgPT4gewogICAgICAgIGlmICghdmFsdWUpIHsKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiBTeW1ib2wub2JzZXJ2YWJsZSA9PT0gInN5bWJvbCIgJiYgdHlwZW9mIHZhbHVlW1N5bWJvbC5vYnNlcnZhYmxlXSA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVtTeW1ib2wub2JzZXJ2YWJsZV0oKTsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZVsiQEBvYnNlcnZhYmxlIl0gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVbIkBAb2JzZXJ2YWJsZSJdKCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC9zZXJpYWxpemVycy5qcwogIHZhciByZXF1aXJlX3NlcmlhbGl6ZXJzID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC9zZXJpYWxpemVycy5qcyIoZXhwb3J0czIpIHsKICAgICAgaW5pdF9idWZmZXJfc2hpbSgpOwogICAgICAidXNlIHN0cmljdCI7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIl9fZXNNb2R1bGUiLCB7IHZhbHVlOiB0cnVlIH0pOwogICAgICBleHBvcnRzMi5EZWZhdWx0U2VyaWFsaXplciA9IGV4cG9ydHMyLmV4dGVuZFNlcmlhbGl6ZXIgPSB2b2lkIDA7CiAgICAgIGZ1bmN0aW9uIGV4dGVuZFNlcmlhbGl6ZXIoZXh0ZW5kLCBpbXBsZW1lbnRhdGlvbikgewogICAgICAgIGNvbnN0IGZhbGxiYWNrRGVzZXJpYWxpemVyID0gZXh0ZW5kLmRlc2VyaWFsaXplLmJpbmQoZXh0ZW5kKTsKICAgICAgICBjb25zdCBmYWxsYmFja1NlcmlhbGl6ZXIgPSBleHRlbmQuc2VyaWFsaXplLmJpbmQoZXh0ZW5kKTsKICAgICAgICByZXR1cm4gewogICAgICAgICAgZGVzZXJpYWxpemUobWVzc2FnZSkgewogICAgICAgICAgICByZXR1cm4gaW1wbGVtZW50YXRpb24uZGVzZXJpYWxpemUobWVzc2FnZSwgZmFsbGJhY2tEZXNlcmlhbGl6ZXIpOwogICAgICAgICAgfSwKICAgICAgICAgIHNlcmlhbGl6ZShpbnB1dCkgewogICAgICAgICAgICByZXR1cm4gaW1wbGVtZW50YXRpb24uc2VyaWFsaXplKGlucHV0LCBmYWxsYmFja1NlcmlhbGl6ZXIpOwogICAgICAgICAgfQogICAgICAgIH07CiAgICAgIH0KICAgICAgZXhwb3J0czIuZXh0ZW5kU2VyaWFsaXplciA9IGV4dGVuZFNlcmlhbGl6ZXI7CiAgICAgIHZhciBEZWZhdWx0RXJyb3JTZXJpYWxpemVyID0gewogICAgICAgIGRlc2VyaWFsaXplKG1lc3NhZ2UpIHsKICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKEVycm9yKG1lc3NhZ2UubWVzc2FnZSksIHsKICAgICAgICAgICAgbmFtZTogbWVzc2FnZS5uYW1lLAogICAgICAgICAgICBzdGFjazogbWVzc2FnZS5zdGFjawogICAgICAgICAgfSk7CiAgICAgICAgfSwKICAgICAgICBzZXJpYWxpemUoZXJyb3IpIHsKICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIF9fZXJyb3JfbWFya2VyOiAiJCRlcnJvciIsCiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsCiAgICAgICAgICAgIG5hbWU6IGVycm9yLm5hbWUsCiAgICAgICAgICAgIHN0YWNrOiBlcnJvci5zdGFjawogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIHZhciBpc1NlcmlhbGl6ZWRFcnJvciA9ICh0aGluZykgPT4gdGhpbmcgJiYgdHlwZW9mIHRoaW5nID09PSAib2JqZWN0IiAmJiAiX19lcnJvcl9tYXJrZXIiIGluIHRoaW5nICYmIHRoaW5nLl9fZXJyb3JfbWFya2VyID09PSAiJCRlcnJvciI7CiAgICAgIGV4cG9ydHMyLkRlZmF1bHRTZXJpYWxpemVyID0gewogICAgICAgIGRlc2VyaWFsaXplKG1lc3NhZ2UpIHsKICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRFcnJvcihtZXNzYWdlKSkgewogICAgICAgICAgICByZXR1cm4gRGVmYXVsdEVycm9yU2VyaWFsaXplci5kZXNlcmlhbGl6ZShtZXNzYWdlKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlOwogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgc2VyaWFsaXplKGlucHV0KSB7CiAgICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBFcnJvcikgewogICAgICAgICAgICByZXR1cm4gRGVmYXVsdEVycm9yU2VyaWFsaXplci5zZXJpYWxpemUoaW5wdXQpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIGlucHV0OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfTsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC9jb21tb24uanMKICB2YXIgcmVxdWlyZV9jb21tb24yID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC9jb21tb24uanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZXhwb3J0czIuc2VyaWFsaXplID0gZXhwb3J0czIuZGVzZXJpYWxpemUgPSBleHBvcnRzMi5yZWdpc3RlclNlcmlhbGl6ZXIgPSB2b2lkIDA7CiAgICAgIHZhciBzZXJpYWxpemVyc18xID0gcmVxdWlyZV9zZXJpYWxpemVycygpOwogICAgICB2YXIgcmVnaXN0ZXJlZFNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyc18xLkRlZmF1bHRTZXJpYWxpemVyOwogICAgICBmdW5jdGlvbiByZWdpc3RlclNlcmlhbGl6ZXIyKHNlcmlhbGl6ZXIpIHsKICAgICAgICByZWdpc3RlcmVkU2VyaWFsaXplciA9IHNlcmlhbGl6ZXJzXzEuZXh0ZW5kU2VyaWFsaXplcihyZWdpc3RlcmVkU2VyaWFsaXplciwgc2VyaWFsaXplcik7CiAgICAgIH0KICAgICAgZXhwb3J0czIucmVnaXN0ZXJTZXJpYWxpemVyID0gcmVnaXN0ZXJTZXJpYWxpemVyMjsKICAgICAgZnVuY3Rpb24gZGVzZXJpYWxpemUobWVzc2FnZSkgewogICAgICAgIHJldHVybiByZWdpc3RlcmVkU2VyaWFsaXplci5kZXNlcmlhbGl6ZShtZXNzYWdlKTsKICAgICAgfQogICAgICBleHBvcnRzMi5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplOwogICAgICBmdW5jdGlvbiBzZXJpYWxpemUoaW5wdXQpIHsKICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZFNlcmlhbGl6ZXIuc2VyaWFsaXplKGlucHV0KTsKICAgICAgfQogICAgICBleHBvcnRzMi5zZXJpYWxpemUgPSBzZXJpYWxpemU7CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvc3ltYm9scy5qcwogIHZhciByZXF1aXJlX3N5bWJvbHMgPSBfX2NvbW1vbkpTKHsKICAgICJub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3N5bWJvbHMuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZXhwb3J0czIuJHdvcmtlciA9IGV4cG9ydHMyLiR0cmFuc2ZlcmFibGUgPSBleHBvcnRzMi4kdGVybWluYXRlID0gZXhwb3J0czIuJGV2ZW50cyA9IGV4cG9ydHMyLiRlcnJvcnMgPSB2b2lkIDA7CiAgICAgIGV4cG9ydHMyLiRlcnJvcnMgPSBTeW1ib2woInRocmVhZC5lcnJvcnMiKTsKICAgICAgZXhwb3J0czIuJGV2ZW50cyA9IFN5bWJvbCgidGhyZWFkLmV2ZW50cyIpOwogICAgICBleHBvcnRzMi4kdGVybWluYXRlID0gU3ltYm9sKCJ0aHJlYWQudGVybWluYXRlIik7CiAgICAgIGV4cG9ydHMyLiR0cmFuc2ZlcmFibGUgPSBTeW1ib2woInRocmVhZC50cmFuc2ZlcmFibGUiKTsKICAgICAgZXhwb3J0czIuJHdvcmtlciA9IFN5bWJvbCgidGhyZWFkLndvcmtlciIpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3RyYW5zZmVyYWJsZS5qcwogIHZhciByZXF1aXJlX3RyYW5zZmVyYWJsZSA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3QvdHJhbnNmZXJhYmxlLmpzIihleHBvcnRzMikgewogICAgICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgICAgICJ1c2Ugc3RyaWN0IjsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGV4cG9ydHMyLlRyYW5zZmVyID0gZXhwb3J0czIuaXNUcmFuc2ZlckRlc2NyaXB0b3IgPSB2b2lkIDA7CiAgICAgIHZhciBzeW1ib2xzXzEgPSByZXF1aXJlX3N5bWJvbHMoKTsKICAgICAgZnVuY3Rpb24gaXNUcmFuc2ZlcmFibGUodGhpbmcpIHsKICAgICAgICBpZiAoIXRoaW5nIHx8IHR5cGVvZiB0aGluZyAhPT0gIm9iamVjdCIpCiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaXNUcmFuc2ZlckRlc2NyaXB0b3IodGhpbmcpIHsKICAgICAgICByZXR1cm4gdGhpbmcgJiYgdHlwZW9mIHRoaW5nID09PSAib2JqZWN0IiAmJiB0aGluZ1tzeW1ib2xzXzEuJHRyYW5zZmVyYWJsZV07CiAgICAgIH0KICAgICAgZXhwb3J0czIuaXNUcmFuc2ZlckRlc2NyaXB0b3IgPSBpc1RyYW5zZmVyRGVzY3JpcHRvcjsKICAgICAgZnVuY3Rpb24gVHJhbnNmZXIyKHBheWxvYWQsIHRyYW5zZmVyYWJsZXMpIHsKICAgICAgICBpZiAoIXRyYW5zZmVyYWJsZXMpIHsKICAgICAgICAgIGlmICghaXNUcmFuc2ZlcmFibGUocGF5bG9hZCkpCiAgICAgICAgICAgIHRocm93IEVycm9yKCk7CiAgICAgICAgICB0cmFuc2ZlcmFibGVzID0gW3BheWxvYWRdOwogICAgICAgIH0KICAgICAgICByZXR1cm4gewogICAgICAgICAgW3N5bWJvbHNfMS4kdHJhbnNmZXJhYmxlXTogdHJ1ZSwKICAgICAgICAgIHNlbmQ6IHBheWxvYWQsCiAgICAgICAgICB0cmFuc2ZlcmFibGVzCiAgICAgICAgfTsKICAgICAgfQogICAgICBleHBvcnRzMi5UcmFuc2ZlciA9IFRyYW5zZmVyMjsKICAgIH0KICB9KTsKCiAgLy8gbm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC90eXBlcy9tZXNzYWdlcy5qcwogIHZhciByZXF1aXJlX21lc3NhZ2VzMiA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3QvdHlwZXMvbWVzc2FnZXMuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgZXhwb3J0czIuV29ya2VyTWVzc2FnZVR5cGUgPSBleHBvcnRzMi5NYXN0ZXJNZXNzYWdlVHlwZSA9IHZvaWQgMDsKICAgICAgdmFyIE1hc3Rlck1lc3NhZ2VUeXBlOwogICAgICAoZnVuY3Rpb24oTWFzdGVyTWVzc2FnZVR5cGUyKSB7CiAgICAgICAgTWFzdGVyTWVzc2FnZVR5cGUyWyJjYW5jZWwiXSA9ICJjYW5jZWwiOwogICAgICAgIE1hc3Rlck1lc3NhZ2VUeXBlMlsicnVuIl0gPSAicnVuIjsKICAgICAgfSkoTWFzdGVyTWVzc2FnZVR5cGUgPSBleHBvcnRzMi5NYXN0ZXJNZXNzYWdlVHlwZSB8fCAoZXhwb3J0czIuTWFzdGVyTWVzc2FnZVR5cGUgPSB7fSkpOwogICAgICB2YXIgV29ya2VyTWVzc2FnZVR5cGU7CiAgICAgIChmdW5jdGlvbihXb3JrZXJNZXNzYWdlVHlwZTIpIHsKICAgICAgICBXb3JrZXJNZXNzYWdlVHlwZTJbImVycm9yIl0gPSAiZXJyb3IiOwogICAgICAgIFdvcmtlck1lc3NhZ2VUeXBlMlsiaW5pdCJdID0gImluaXQiOwogICAgICAgIFdvcmtlck1lc3NhZ2VUeXBlMlsicmVzdWx0Il0gPSAicmVzdWx0IjsKICAgICAgICBXb3JrZXJNZXNzYWdlVHlwZTJbInJ1bm5pbmciXSA9ICJydW5uaW5nIjsKICAgICAgICBXb3JrZXJNZXNzYWdlVHlwZTJbInVuY2F1Z2h0RXJyb3IiXSA9ICJ1bmNhdWdodEVycm9yIjsKICAgICAgfSkoV29ya2VyTWVzc2FnZVR5cGUgPSBleHBvcnRzMi5Xb3JrZXJNZXNzYWdlVHlwZSB8fCAoZXhwb3J0czIuV29ya2VyTWVzc2FnZVR5cGUgPSB7fSkpOwogICAgfQogIH0pOwoKICAvLyBub2RlX21vZHVsZXMvdGhyZWFkcy9kaXN0L3dvcmtlci9pbXBsZW1lbnRhdGlvbi5icm93c2VyLmpzCiAgdmFyIHJlcXVpcmVfaW1wbGVtZW50YXRpb25fYnJvd3NlciA9IF9fY29tbW9uSlMoewogICAgIm5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvd29ya2VyL2ltcGxlbWVudGF0aW9uLmJyb3dzZXIuanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgICAgdmFyIGlzV29ya2VyUnVudGltZSA9IGZ1bmN0aW9uIGlzV29ya2VyUnVudGltZTIoKSB7CiAgICAgICAgY29uc3QgaXNXaW5kb3dDb250ZXh0ID0gdHlwZW9mIHNlbGYgIT09ICJ1bmRlZmluZWQiICYmIHR5cGVvZiBXaW5kb3cgIT09ICJ1bmRlZmluZWQiICYmIHNlbGYgaW5zdGFuY2VvZiBXaW5kb3c7CiAgICAgICAgcmV0dXJuIHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiAmJiBzZWxmLnBvc3RNZXNzYWdlICYmICFpc1dpbmRvd0NvbnRleHQgPyB0cnVlIDogZmFsc2U7CiAgICAgIH07CiAgICAgIHZhciBwb3N0TWVzc2FnZVRvTWFzdGVyID0gZnVuY3Rpb24gcG9zdE1lc3NhZ2VUb01hc3RlcjIoZGF0YSwgdHJhbnNmZXJMaXN0KSB7CiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZShkYXRhLCB0cmFuc2Zlckxpc3QpOwogICAgICB9OwogICAgICB2YXIgc3Vic2NyaWJlVG9NYXN0ZXJNZXNzYWdlcyA9IGZ1bmN0aW9uIHN1YnNjcmliZVRvTWFzdGVyTWVzc2FnZXMyKG9uTWVzc2FnZSkgewogICAgICAgIGNvbnN0IG1lc3NhZ2VIYW5kbGVyID0gKG1lc3NhZ2VFdmVudCkgPT4gewogICAgICAgICAgb25NZXNzYWdlKG1lc3NhZ2VFdmVudC5kYXRhKTsKICAgICAgICB9OwogICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gKCkgPT4gewogICAgICAgICAgc2VsZi5yZW1vdmVFdmVudExpc3RlbmVyKCJtZXNzYWdlIiwgbWVzc2FnZUhhbmRsZXIpOwogICAgICAgIH07CiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIiwgbWVzc2FnZUhhbmRsZXIpOwogICAgICAgIHJldHVybiB1bnN1YnNjcmliZTsKICAgICAgfTsKICAgICAgZXhwb3J0czIuZGVmYXVsdCA9IHsKICAgICAgICBpc1dvcmtlclJ1bnRpbWUsCiAgICAgICAgcG9zdE1lc3NhZ2VUb01hc3RlciwKICAgICAgICBzdWJzY3JpYmVUb01hc3Rlck1lc3NhZ2VzCiAgICAgIH07CiAgICB9CiAgfSk7CgogIC8vIG5vZGVfbW9kdWxlcy90aHJlYWRzL2Rpc3Qvd29ya2VyL2luZGV4LmpzCiAgdmFyIHJlcXVpcmVfd29ya2VyID0gX19jb21tb25KUyh7CiAgICAibm9kZV9tb2R1bGVzL3RocmVhZHMvZGlzdC93b3JrZXIvaW5kZXguanMiKGV4cG9ydHMyKSB7CiAgICAgIGluaXRfYnVmZmVyX3NoaW0oKTsKICAgICAgInVzZSBzdHJpY3QiOwogICAgICB2YXIgX19hd2FpdGVyID0gZXhwb3J0czIgJiYgZXhwb3J0czIuX19hd2FpdGVyIHx8IGZ1bmN0aW9uKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikgewogICAgICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7CiAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbihyZXNvbHZlKSB7CiAgICAgICAgICAgIHJlc29sdmUodmFsdWUpOwogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7CiAgICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7CiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICByZWplY3QoZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3JbInRocm93Il0odmFsdWUpKTsKICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgIHJlamVjdChlKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsKICAgICAgICAgICAgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7CiAgICAgICAgICB9CiAgICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7CiAgICAgICAgfSk7CiAgICAgIH07CiAgICAgIHZhciBfX2ltcG9ydERlZmF1bHQgPSBleHBvcnRzMiAmJiBleHBvcnRzMi5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24obW9kKSB7CiAgICAgICAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHsgImRlZmF1bHQiOiBtb2QgfTsKICAgICAgfTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAiX19lc01vZHVsZSIsIHsgdmFsdWU6IHRydWUgfSk7CiAgICAgIGV4cG9ydHMyLmV4cG9zZSA9IGV4cG9ydHMyLmlzV29ya2VyUnVudGltZSA9IGV4cG9ydHMyLlRyYW5zZmVyID0gZXhwb3J0czIucmVnaXN0ZXJTZXJpYWxpemVyID0gdm9pZCAwOwogICAgICB2YXIgaXNfb2JzZXJ2YWJsZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmVfaXNfb2JzZXJ2YWJsZSgpKTsKICAgICAgdmFyIGNvbW1vbl8xID0gcmVxdWlyZV9jb21tb24yKCk7CiAgICAgIHZhciB0cmFuc2ZlcmFibGVfMSA9IHJlcXVpcmVfdHJhbnNmZXJhYmxlKCk7CiAgICAgIHZhciBtZXNzYWdlc18xID0gcmVxdWlyZV9tZXNzYWdlczIoKTsKICAgICAgdmFyIGltcGxlbWVudGF0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZV9pbXBsZW1lbnRhdGlvbl9icm93c2VyKCkpOwogICAgICB2YXIgY29tbW9uXzIgPSByZXF1aXJlX2NvbW1vbjIoKTsKICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCAicmVnaXN0ZXJTZXJpYWxpemVyIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiBjb21tb25fMi5yZWdpc3RlclNlcmlhbGl6ZXI7CiAgICAgIH0gfSk7CiAgICAgIHZhciB0cmFuc2ZlcmFibGVfMiA9IHJlcXVpcmVfdHJhbnNmZXJhYmxlKCk7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzMiwgIlRyYW5zZmVyIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiB0cmFuc2ZlcmFibGVfMi5UcmFuc2ZlcjsKICAgICAgfSB9KTsKICAgICAgZXhwb3J0czIuaXNXb3JrZXJSdW50aW1lID0gaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LmlzV29ya2VyUnVudGltZTsKICAgICAgdmFyIGV4cG9zZUNhbGxlZCA9IGZhbHNlOwogICAgICB2YXIgYWN0aXZlU3Vic2NyaXB0aW9ucyA9IG5ldyBNYXAoKTsKICAgICAgdmFyIGlzTWFzdGVySm9iQ2FuY2VsTWVzc2FnZSA9ICh0aGluZykgPT4gdGhpbmcgJiYgdGhpbmcudHlwZSA9PT0gbWVzc2FnZXNfMS5NYXN0ZXJNZXNzYWdlVHlwZS5jYW5jZWw7CiAgICAgIHZhciBpc01hc3RlckpvYlJ1bk1lc3NhZ2UgPSAodGhpbmcpID0+IHRoaW5nICYmIHRoaW5nLnR5cGUgPT09IG1lc3NhZ2VzXzEuTWFzdGVyTWVzc2FnZVR5cGUucnVuOwogICAgICB2YXIgaXNPYnNlcnZhYmxlID0gKHRoaW5nKSA9PiBpc19vYnNlcnZhYmxlXzEuZGVmYXVsdCh0aGluZykgfHwgaXNaZW5PYnNlcnZhYmxlKHRoaW5nKTsKICAgICAgZnVuY3Rpb24gaXNaZW5PYnNlcnZhYmxlKHRoaW5nKSB7CiAgICAgICAgcmV0dXJuIHRoaW5nICYmIHR5cGVvZiB0aGluZyA9PT0gIm9iamVjdCIgJiYgdHlwZW9mIHRoaW5nLnN1YnNjcmliZSA9PT0gImZ1bmN0aW9uIjsKICAgICAgfQogICAgICBmdW5jdGlvbiBkZWNvbnN0cnVjdFRyYW5zZmVyKHRoaW5nKSB7CiAgICAgICAgcmV0dXJuIHRyYW5zZmVyYWJsZV8xLmlzVHJhbnNmZXJEZXNjcmlwdG9yKHRoaW5nKSA/IHsgcGF5bG9hZDogdGhpbmcuc2VuZCwgdHJhbnNmZXJhYmxlczogdGhpbmcudHJhbnNmZXJhYmxlcyB9IDogeyBwYXlsb2FkOiB0aGluZywgdHJhbnNmZXJhYmxlczogdm9pZCAwIH07CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9zdEZ1bmN0aW9uSW5pdE1lc3NhZ2UoKSB7CiAgICAgICAgY29uc3QgaW5pdE1lc3NhZ2UgPSB7CiAgICAgICAgICB0eXBlOiBtZXNzYWdlc18xLldvcmtlck1lc3NhZ2VUeXBlLmluaXQsCiAgICAgICAgICBleHBvc2VkOiB7CiAgICAgICAgICAgIHR5cGU6ICJmdW5jdGlvbiIKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5wb3N0TWVzc2FnZVRvTWFzdGVyKGluaXRNZXNzYWdlKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwb3N0TW9kdWxlSW5pdE1lc3NhZ2UobWV0aG9kTmFtZXMpIHsKICAgICAgICBjb25zdCBpbml0TWVzc2FnZSA9IHsKICAgICAgICAgIHR5cGU6IG1lc3NhZ2VzXzEuV29ya2VyTWVzc2FnZVR5cGUuaW5pdCwKICAgICAgICAgIGV4cG9zZWQ6IHsKICAgICAgICAgICAgdHlwZTogIm1vZHVsZSIsCiAgICAgICAgICAgIG1ldGhvZHM6IG1ldGhvZE5hbWVzCiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQucG9zdE1lc3NhZ2VUb01hc3Rlcihpbml0TWVzc2FnZSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9zdEpvYkVycm9yTWVzc2FnZSh1aWQsIHJhd0Vycm9yKSB7CiAgICAgICAgY29uc3QgeyBwYXlsb2FkOiBlcnJvciwgdHJhbnNmZXJhYmxlcyB9ID0gZGVjb25zdHJ1Y3RUcmFuc2ZlcihyYXdFcnJvcik7CiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gewogICAgICAgICAgdHlwZTogbWVzc2FnZXNfMS5Xb3JrZXJNZXNzYWdlVHlwZS5lcnJvciwKICAgICAgICAgIHVpZCwKICAgICAgICAgIGVycm9yOiBjb21tb25fMS5zZXJpYWxpemUoZXJyb3IpCiAgICAgICAgfTsKICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQucG9zdE1lc3NhZ2VUb01hc3RlcihlcnJvck1lc3NhZ2UsIHRyYW5zZmVyYWJsZXMpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHBvc3RKb2JSZXN1bHRNZXNzYWdlKHVpZCwgY29tcGxldGVkLCByZXN1bHRWYWx1ZSkgewogICAgICAgIGNvbnN0IHsgcGF5bG9hZCwgdHJhbnNmZXJhYmxlcyB9ID0gZGVjb25zdHJ1Y3RUcmFuc2ZlcihyZXN1bHRWYWx1ZSk7CiAgICAgICAgY29uc3QgcmVzdWx0TWVzc2FnZSA9IHsKICAgICAgICAgIHR5cGU6IG1lc3NhZ2VzXzEuV29ya2VyTWVzc2FnZVR5cGUucmVzdWx0LAogICAgICAgICAgdWlkLAogICAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlZCA/IHRydWUgOiB2b2lkIDAsCiAgICAgICAgICBwYXlsb2FkCiAgICAgICAgfTsKICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQucG9zdE1lc3NhZ2VUb01hc3RlcihyZXN1bHRNZXNzYWdlLCB0cmFuc2ZlcmFibGVzKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwb3N0Sm9iU3RhcnRNZXNzYWdlKHVpZCwgcmVzdWx0VHlwZSkgewogICAgICAgIGNvbnN0IHN0YXJ0TWVzc2FnZSA9IHsKICAgICAgICAgIHR5cGU6IG1lc3NhZ2VzXzEuV29ya2VyTWVzc2FnZVR5cGUucnVubmluZywKICAgICAgICAgIHVpZCwKICAgICAgICAgIHJlc3VsdFR5cGUKICAgICAgICB9OwogICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5wb3N0TWVzc2FnZVRvTWFzdGVyKHN0YXJ0TWVzc2FnZSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9zdFVuY2F1Z2h0RXJyb3JNZXNzYWdlKGVycm9yKSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHsKICAgICAgICAgICAgdHlwZTogbWVzc2FnZXNfMS5Xb3JrZXJNZXNzYWdlVHlwZS51bmNhdWdodEVycm9yLAogICAgICAgICAgICBlcnJvcjogY29tbW9uXzEuc2VyaWFsaXplKGVycm9yKQogICAgICAgICAgfTsKICAgICAgICAgIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5wb3N0TWVzc2FnZVRvTWFzdGVyKGVycm9yTWVzc2FnZSk7CiAgICAgICAgfSBjYXRjaCAoc3ViRXJyb3IpIHsKICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIk5vdCByZXBvcnRpbmcgdW5jYXVnaHQgZXJyb3IgYmFjayB0byBtYXN0ZXIgdGhyZWFkIGFzIGl0IG9jY3VyZWQgd2hpbGUgcmVwb3J0aW5nIGFuIHVuY2F1Z2h0IGVycm9yIGFscmVhZHkuXG5MYXRlc3QgZXJyb3I6Iiwgc3ViRXJyb3IsICJcbk9yaWdpbmFsIGVycm9yOiIsIGVycm9yKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcnVuRnVuY3Rpb24oam9iVUlELCBmbiwgYXJncykgewogICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7CiAgICAgICAgICBsZXQgc3luY1Jlc3VsdDsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHN5bmNSZXN1bHQgPSBmbiguLi5hcmdzKTsKICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgICAgIHJldHVybiBwb3N0Sm9iRXJyb3JNZXNzYWdlKGpvYlVJRCwgZXJyb3IpOwogICAgICAgICAgfQogICAgICAgICAgY29uc3QgcmVzdWx0VHlwZSA9IGlzT2JzZXJ2YWJsZShzeW5jUmVzdWx0KSA/ICJvYnNlcnZhYmxlIiA6ICJwcm9taXNlIjsKICAgICAgICAgIHBvc3RKb2JTdGFydE1lc3NhZ2Uoam9iVUlELCByZXN1bHRUeXBlKTsKICAgICAgICAgIGlmIChpc09ic2VydmFibGUoc3luY1Jlc3VsdCkpIHsKICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gc3luY1Jlc3VsdC5zdWJzY3JpYmUoKHZhbHVlKSA9PiBwb3N0Sm9iUmVzdWx0TWVzc2FnZShqb2JVSUQsIGZhbHNlLCBjb21tb25fMS5zZXJpYWxpemUodmFsdWUpKSwgKGVycm9yKSA9PiB7CiAgICAgICAgICAgICAgcG9zdEpvYkVycm9yTWVzc2FnZShqb2JVSUQsIGNvbW1vbl8xLnNlcmlhbGl6ZShlcnJvcikpOwogICAgICAgICAgICAgIGFjdGl2ZVN1YnNjcmlwdGlvbnMuZGVsZXRlKGpvYlVJRCk7CiAgICAgICAgICAgIH0sICgpID0+IHsKICAgICAgICAgICAgICBwb3N0Sm9iUmVzdWx0TWVzc2FnZShqb2JVSUQsIHRydWUpOwogICAgICAgICAgICAgIGFjdGl2ZVN1YnNjcmlwdGlvbnMuZGVsZXRlKGpvYlVJRCk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICBhY3RpdmVTdWJzY3JpcHRpb25zLnNldChqb2JVSUQsIHN1YnNjcmlwdGlvbik7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHN5bmNSZXN1bHQ7CiAgICAgICAgICAgICAgcG9zdEpvYlJlc3VsdE1lc3NhZ2Uoam9iVUlELCB0cnVlLCBjb21tb25fMS5zZXJpYWxpemUocmVzdWx0KSk7CiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgICAgICAgcG9zdEpvYkVycm9yTWVzc2FnZShqb2JVSUQsIGNvbW1vbl8xLnNlcmlhbGl6ZShlcnJvcikpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZXhwb3NlMihleHBvc2VkKSB7CiAgICAgICAgaWYgKCFpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQuaXNXb3JrZXJSdW50aW1lKCkpIHsKICAgICAgICAgIHRocm93IEVycm9yKCJleHBvc2UoKSBjYWxsZWQgaW4gdGhlIG1hc3RlciB0aHJlYWQuIik7CiAgICAgICAgfQogICAgICAgIGlmIChleHBvc2VDYWxsZWQpIHsKICAgICAgICAgIHRocm93IEVycm9yKCJleHBvc2UoKSBjYWxsZWQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgaXMgbm90IHBvc3NpYmxlLiBQYXNzIGFuIG9iamVjdCB0byBleHBvc2UoKSBpZiB5b3Ugd2FudCB0byBleHBvc2UgbXVsdGlwbGUgZnVuY3Rpb25zLiIpOwogICAgICAgIH0KICAgICAgICBleHBvc2VDYWxsZWQgPSB0cnVlOwogICAgICAgIGlmICh0eXBlb2YgZXhwb3NlZCA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnN1YnNjcmliZVRvTWFzdGVyTWVzc2FnZXMoKG1lc3NhZ2VEYXRhKSA9PiB7CiAgICAgICAgICAgIGlmIChpc01hc3RlckpvYlJ1bk1lc3NhZ2UobWVzc2FnZURhdGEpICYmICFtZXNzYWdlRGF0YS5tZXRob2QpIHsKICAgICAgICAgICAgICBydW5GdW5jdGlvbihtZXNzYWdlRGF0YS51aWQsIGV4cG9zZWQsIG1lc3NhZ2VEYXRhLmFyZ3MubWFwKGNvbW1vbl8xLmRlc2VyaWFsaXplKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwogICAgICAgICAgcG9zdEZ1bmN0aW9uSW5pdE1lc3NhZ2UoKTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvc2VkID09PSAib2JqZWN0IiAmJiBleHBvc2VkKSB7CiAgICAgICAgICBpbXBsZW1lbnRhdGlvbl8xLmRlZmF1bHQuc3Vic2NyaWJlVG9NYXN0ZXJNZXNzYWdlcygobWVzc2FnZURhdGEpID0+IHsKICAgICAgICAgICAgaWYgKGlzTWFzdGVySm9iUnVuTWVzc2FnZShtZXNzYWdlRGF0YSkgJiYgbWVzc2FnZURhdGEubWV0aG9kKSB7CiAgICAgICAgICAgICAgcnVuRnVuY3Rpb24obWVzc2FnZURhdGEudWlkLCBleHBvc2VkW21lc3NhZ2VEYXRhLm1ldGhvZF0sIG1lc3NhZ2VEYXRhLmFyZ3MubWFwKGNvbW1vbl8xLmRlc2VyaWFsaXplKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwogICAgICAgICAgY29uc3QgbWV0aG9kTmFtZXMgPSBPYmplY3Qua2V5cyhleHBvc2VkKS5maWx0ZXIoKGtleSkgPT4gdHlwZW9mIGV4cG9zZWRba2V5XSA9PT0gImZ1bmN0aW9uIik7CiAgICAgICAgICBwb3N0TW9kdWxlSW5pdE1lc3NhZ2UobWV0aG9kTmFtZXMpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aHJvdyBFcnJvcihgSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgdG8gZXhwb3NlKCkuIEV4cGVjdGVkIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0LCBnb3Q6ICR7ZXhwb3NlZH1gKTsKICAgICAgICB9CiAgICAgICAgaW1wbGVtZW50YXRpb25fMS5kZWZhdWx0LnN1YnNjcmliZVRvTWFzdGVyTWVzc2FnZXMoKG1lc3NhZ2VEYXRhKSA9PiB7CiAgICAgICAgICBpZiAoaXNNYXN0ZXJKb2JDYW5jZWxNZXNzYWdlKG1lc3NhZ2VEYXRhKSkgewogICAgICAgICAgICBjb25zdCBqb2JVSUQgPSBtZXNzYWdlRGF0YS51aWQ7CiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGFjdGl2ZVN1YnNjcmlwdGlvbnMuZ2V0KGpvYlVJRCk7CiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHsKICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTsKICAgICAgICAgICAgICBhY3RpdmVTdWJzY3JpcHRpb25zLmRlbGV0ZShqb2JVSUQpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgZXhwb3J0czIuZXhwb3NlID0gZXhwb3NlMjsKICAgICAgaWYgKHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiAmJiB0eXBlb2Ygc2VsZi5hZGRFdmVudExpc3RlbmVyID09PSAiZnVuY3Rpb24iICYmIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5pc1dvcmtlclJ1bnRpbWUoKSkgewogICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcigiZXJyb3IiLCAoZXZlbnQpID0+IHsKICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcG9zdFVuY2F1Z2h0RXJyb3JNZXNzYWdlKGV2ZW50LmVycm9yIHx8IGV2ZW50KSwgMjUwKTsKICAgICAgICB9KTsKICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoInVuaGFuZGxlZHJlamVjdGlvbiIsIChldmVudCkgPT4gewogICAgICAgICAgY29uc3QgZXJyb3IgPSBldmVudC5yZWFzb247CiAgICAgICAgICBpZiAoZXJyb3IgJiYgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcG9zdFVuY2F1Z2h0RXJyb3JNZXNzYWdlKGVycm9yKSwgMjUwKTsKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgfQogICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICJ1bmRlZmluZWQiICYmIHR5cGVvZiBwcm9jZXNzLm9uID09PSAiZnVuY3Rpb24iICYmIGltcGxlbWVudGF0aW9uXzEuZGVmYXVsdC5pc1dvcmtlclJ1bnRpbWUoKSkgewogICAgICAgIHByb2Nlc3Mub24oInVuY2F1Z2h0RXhjZXB0aW9uIiwgKGVycm9yKSA9PiB7CiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHBvc3RVbmNhdWdodEVycm9yTWVzc2FnZShlcnJvciksIDI1MCk7CiAgICAgICAgfSk7CiAgICAgICAgcHJvY2Vzcy5vbigidW5oYW5kbGVkUmVqZWN0aW9uIiwgKGVycm9yKSA9PiB7CiAgICAgICAgICBpZiAoZXJyb3IgJiYgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09ICJzdHJpbmciKSB7CiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcG9zdFVuY2F1Z2h0RXJyb3JNZXNzYWdlKGVycm9yKSwgMjUwKTsKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgfQogICAgfQogIH0pOwoKICAvLyBzcmMvZGF0YS1mZXRjaGVycy92Y2YvdmNmLXdvcmtlci50cz93b3JrZXImaW5saW5lP3dvcmtlcl9maWxlCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvdmNmL2VzbS9pbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL3ZjZi9lc20vcGFyc2UuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC92Y2YvZXNtL3ZjZlJlc2VydmVkLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciB2Y2ZSZXNlcnZlZF9kZWZhdWx0ID0gewogICAgSW5mb0ZpZWxkczogewogICAgICBBQTogeyBOdW1iZXI6IDEsIFR5cGU6ICJTdHJpbmciLCBEZXNjcmlwdGlvbjogIkFuY2VzdHJhbCBhbGxlbGUiIH0sCiAgICAgIEFDOiB7CiAgICAgICAgTnVtYmVyOiAiQSIsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiQWxsZWxlIGNvdW50IGluIGdlbm90eXBlcywgZm9yIGVhY2ggQUxUIGFsbGVsZSwgaW4gdGhlIHNhbWUgb3JkZXIgYXMgbGlzdGVkIgogICAgICB9LAogICAgICBBRDogewogICAgICAgIE51bWJlcjogIlIiLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIlRvdGFsIHJlYWQgZGVwdGggZm9yIGVhY2ggYWxsZWxlIgogICAgICB9LAogICAgICBBREY6IHsKICAgICAgICBOdW1iZXI6ICJSIiwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJSZWFkIGRlcHRoIGZvciBlYWNoIGFsbGVsZSBvbiB0aGUgZm9yd2FyZCBzdHJhbmQiCiAgICAgIH0sCiAgICAgIEFEUjogewogICAgICAgIE51bWJlcjogIlIiLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIlJlYWQgZGVwdGggZm9yIGVhY2ggYWxsZWxlIG9uIHRoZSByZXZlcnNlIHN0cmFuZCIKICAgICAgfSwKICAgICAgQUY6IHsKICAgICAgICBOdW1iZXI6ICJBIiwKICAgICAgICBUeXBlOiAiRmxvYXQiLAogICAgICAgIERlc2NyaXB0aW9uOiAiQWxsZWxlIGZyZXF1ZW5jeSBmb3IgZWFjaCBBTFQgYWxsZWxlIGluIHRoZSBzYW1lIG9yZGVyIGFzIGxpc3RlZCAoZXN0aW1hdGVkIGZyb20gcHJpbWFyeSBkYXRhLCBub3QgY2FsbGVkIGdlbm90eXBlcykiCiAgICAgIH0sCiAgICAgIEFOOiB7CiAgICAgICAgTnVtYmVyOiAxLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIlRvdGFsIG51bWJlciBvZiBhbGxlbGVzIGluIGNhbGxlZCBnZW5vdHlwZXMiCiAgICAgIH0sCiAgICAgIEJROiB7CiAgICAgICAgTnVtYmVyOiAxLAogICAgICAgIFR5cGU6ICJGbG9hdCIsCiAgICAgICAgRGVzY3JpcHRpb246ICJSTVMgYmFzZSBxdWFsaXR5IgogICAgICB9LAogICAgICBDSUdBUjogewogICAgICAgIE51bWJlcjogMSwKICAgICAgICBUeXBlOiAiRmxvYXQiLAogICAgICAgIERlc2NyaXB0aW9uOiAiQ2lnYXIgc3RyaW5nIGRlc2NyaWJpbmcgaG93IHRvIGFsaWduIGFuIGFsdGVybmF0ZSBhbGxlbGUgdG8gdGhlIHJlZmVyZW5jZSBhbGxlbGUiCiAgICAgIH0sCiAgICAgIERCOiB7CiAgICAgICAgTnVtYmVyOiAwLAogICAgICAgIFR5cGU6ICJGbGFnIiwKICAgICAgICBEZXNjcmlwdGlvbjogImRiU05QIG1lbWJlcnNoaXAiCiAgICAgIH0sCiAgICAgIERQOiB7CiAgICAgICAgTnVtYmVyOiAxLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogImNvbWJpbmVkIGRlcHRoIGFjcm9zcyBzYW1wbGVzIgogICAgICB9LAogICAgICBFTkQ6IHsKICAgICAgICBOdW1iZXI6IDEsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiRW5kIHBvc2l0aW9uIChmb3IgdXNlIHdpdGggc3ltYm9saWMgYWxsZWxlcykiCiAgICAgIH0sCiAgICAgIEgyOiB7CiAgICAgICAgTnVtYmVyOiAwLAogICAgICAgIFR5cGU6ICJGbGFnIiwKICAgICAgICBEZXNjcmlwdGlvbjogIkhhcE1hcDIgbWVtYmVyc2hpcCIKICAgICAgfSwKICAgICAgSDM6IHsKICAgICAgICBOdW1iZXI6IDAsCiAgICAgICAgVHlwZTogIkZsYWciLAogICAgICAgIERlc2NyaXB0aW9uOiAiSGFwTWFwMyBtZW1iZXJzaGlwIgogICAgICB9LAogICAgICBNUTogewogICAgICAgIE51bWJlcjogMSwKICAgICAgICBUeXBlOiBudWxsLAogICAgICAgIERlc2NyaXB0aW9uOiAiUk1TIG1hcHBpbmcgcXVhbGl0eSIKICAgICAgfSwKICAgICAgTVEwOiB7CiAgICAgICAgTnVtYmVyOiAxLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIk51bWJlciBvZiBNQVBRID09IDAgcmVhZHMiCiAgICAgIH0sCiAgICAgIE5TOiB7CiAgICAgICAgTnVtYmVyOiAxLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIk51bWJlciBvZiBzYW1wbGVzIHdpdGggZGF0YSIKICAgICAgfSwKICAgICAgU0I6IHsKICAgICAgICBOdW1iZXI6IDQsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiU3RyYW5kIGJpYXMiCiAgICAgIH0sCiAgICAgIFNPTUFUSUM6IHsKICAgICAgICBOdW1iZXI6IDAsCiAgICAgICAgVHlwZTogIkZsYWciLAogICAgICAgIERlc2NyaXB0aW9uOiAiU29tYXRpYyBtdXRhdGlvbiAoZm9yIGNhbmNlciBnZW5vbWljcykiCiAgICAgIH0sCiAgICAgIFZBTElEQVRFRDogewogICAgICAgIE51bWJlcjogMCwKICAgICAgICBUeXBlOiAiRmxhZyIsCiAgICAgICAgRGVzY3JpcHRpb246ICJWYWxpZGF0ZWQgYnkgZm9sbG93LXVwIGV4cGVyaW1lbnQiCiAgICAgIH0sCiAgICAgICIxMDAwRyI6IHsKICAgICAgICBOdW1iZXI6IDAsCiAgICAgICAgVHlwZTogIkZsYWciLAogICAgICAgIERlc2NyaXB0aW9uOiAiMTAwMCBHZW5vbWVzIG1lbWJlcnNoaXAiCiAgICAgIH0sCiAgICAgIElNUFJFQ0lTRTogewogICAgICAgIE51bWJlcjogMCwKICAgICAgICBUeXBlOiAiRmxhZyIsCiAgICAgICAgRGVzY3JpcHRpb246ICJJbXByZWNpc2Ugc3RydWN0dXJhbCB2YXJpYXRpb24iCiAgICAgIH0sCiAgICAgIE5PVkVMOiB7CiAgICAgICAgTnVtYmVyOiAwLAogICAgICAgIFR5cGU6ICJGbGFnIiwKICAgICAgICBEZXNjcmlwdGlvbjogIkluZGljYXRlcyBhIG5vdmVsIHN0cnVjdHVyYWwgdmFyaWF0aW9uIgogICAgICB9LAogICAgICBTVlRZUEU6IHsKICAgICAgICBOdW1iZXI6IDEsCiAgICAgICAgVHlwZTogIlN0cmluZyIsCiAgICAgICAgRGVzY3JpcHRpb246ICJUeXBlIG9mIHN0cnVjdHVyYWwgdmFyaWFudCIKICAgICAgfSwKICAgICAgU1ZMRU46IHsKICAgICAgICBOdW1iZXI6IG51bGwsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiRGlmZmVyZW5jZSBpbiBsZW5ndGggYmV0d2VlbiBSRUYgYW5kIEFMVCBhbGxlbGVzIgogICAgICB9LAogICAgICBDSVBPUzogewogICAgICAgIE51bWJlcjogMiwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJDb25maWRlbmNlIGludGVydmFsIGFyb3VuZCBQT1MgZm9yIGltcHJlY2lzZSB2YXJpYW50cyIKICAgICAgfSwKICAgICAgQ0lFTkQ6IHsKICAgICAgICBOdW1iZXI6IDIsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiQ29uZmlkZW5jZSBpbnRlcnZhbCBhcm91bmQgRU5EIGZvciBpbXByZWNpc2UgdmFyaWFudHMiCiAgICAgIH0sCiAgICAgIEhPTUxFTjogewogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIkxlbmd0aCBvZiBiYXNlIHBhaXIgaWRlbnRpY2FsIG1pY3JvLWhvbW9sb2d5IGF0IGV2ZW50IGJyZWFrcG9pbnRzIgogICAgICB9LAogICAgICBIT01TRVE6IHsKICAgICAgICBUeXBlOiAiU3RyaW5nIiwKICAgICAgICBEZXNjcmlwdGlvbjogIlNlcXVlbmNlIG9mIGJhc2UgcGFpciBpZGVudGljYWwgbWljcm8taG9tb2xvZ3kgYXQgZXZlbnQgYnJlYWtwb2ludHMiCiAgICAgIH0sCiAgICAgIEJLUFRJRDogewogICAgICAgIFR5cGU6ICJTdHJpbmciLAogICAgICAgIERlc2NyaXB0aW9uOiAiSUQgb2YgdGhlIGFzc2VtYmxlZCBhbHRlcm5hdGUgYWxsZWxlIGluIHRoZSBhc3NlbWJseSBmaWxlIgogICAgICB9LAogICAgICBNRUlORk86IHsKICAgICAgICBOdW1iZXI6IDQsCiAgICAgICAgVHlwZTogIlN0cmluZyIsCiAgICAgICAgRGVzY3JpcHRpb246ICJNb2JpbGUgZWxlbWVudCBpbmZvIG9mIHRoZSBmb3JtIE5BTUUsU1RBUlQsRU5ELFBPTEFSSVRZIgogICAgICB9LAogICAgICBNRVRSQU5TOiB7CiAgICAgICAgTnVtYmVyOiA0LAogICAgICAgIFR5cGU6ICJTdHJpbmciLAogICAgICAgIERlc2NyaXB0aW9uOiAiTW9iaWxlIGVsZW1lbnQgdHJhbnNkdWN0aW9uIGluZm8gb2YgdGhlIGZvcm0gQ0hSLFNUQVJULEVORCxQT0xBUklUWSIKICAgICAgfSwKICAgICAgREdWSUQ6IHsKICAgICAgICBOdW1iZXI6IDEsCiAgICAgICAgVHlwZTogIlN0cmluZyIsCiAgICAgICAgRGVzY3JpcHRpb246ICJJRCBvZiB0aGlzIGVsZW1lbnQgaW4gRGF0YWJhc2Ugb2YgR2Vub21pYyBWYXJpYXRpb24iCiAgICAgIH0sCiAgICAgIERCVkFSSUQ6IHsKICAgICAgICBOdW1iZXI6IDEsCiAgICAgICAgVHlwZTogIlN0cmluZyIsCiAgICAgICAgRGVzY3JpcHRpb246ICJJRCBvZiB0aGlzIGVsZW1lbnQgaW4gREJWQVIiCiAgICAgIH0sCiAgICAgIERCUklQSUQ6IHsKICAgICAgICBOdW1iZXI6IDEsCiAgICAgICAgVHlwZTogIlN0cmluZyIsCiAgICAgICAgRGVzY3JpcHRpb246ICJJRCBvZiB0aGlzIGVsZW1lbnQgaW4gREJSSVAiCiAgICAgIH0sCiAgICAgIE1BVEVJRDogewogICAgICAgIE51bWJlcjogbnVsbCwKICAgICAgICBUeXBlOiAiU3RyaW5nIiwKICAgICAgICBEZXNjcmlwdGlvbjogIklEIG9mIG1hdGUgYnJlYWtlbmRzIgogICAgICB9LAogICAgICBQQVJJRDogewogICAgICAgIE51bWJlcjogMSwKICAgICAgICBUeXBlOiAiU3RyaW5nIiwKICAgICAgICBEZXNjcmlwdGlvbjogIklEIG9mIHBhcnRuZXIgYnJlYWtlbmQiCiAgICAgIH0sCiAgICAgIEVWRU5UOiB7CiAgICAgICAgTnVtYmVyOiAxLAogICAgICAgIFR5cGU6ICJTdHJpbmciLAogICAgICAgIERlc2NyaXB0aW9uOiAiSUQgb2YgZXZlbnQgYXNzb2NpYXRlZCB0byBicmVha2VuZCIKICAgICAgfSwKICAgICAgQ0lMRU46IHsKICAgICAgICBOdW1iZXI6IDIsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiQ29uZmlkZW5jZSBpbnRlcnZhbCBhcm91bmQgdGhlIGluc2VydGVkIG1hdGVyaWFsIGJldHdlZW4gYnJlYWtlbmQiCiAgICAgIH0sCiAgICAgIERQQURKOiB7IFR5cGU6ICJJbnRlZ2VyIiwgRGVzY3JpcHRpb246ICJSZWFkIERlcHRoIG9mIGFkamFjZW5jeSIgfSwKICAgICAgQ046IHsKICAgICAgICBOdW1iZXI6IDEsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiQ29weSBudW1iZXIgb2Ygc2VnbWVudCBjb250YWluaW5nIGJyZWFrZW5kIgogICAgICB9LAogICAgICBDTkFESjogewogICAgICAgIE51bWJlcjogbnVsbCwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJDb3B5IG51bWJlciBvZiBhZGphY2VuY3kiCiAgICAgIH0sCiAgICAgIENJQ046IHsKICAgICAgICBOdW1iZXI6IDIsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiQ29uZmlkZW5jZSBpbnRlcnZhbCBhcm91bmQgY29weSBudW1iZXIgZm9yIHRoZSBzZWdtZW50IgogICAgICB9LAogICAgICBDSUNOQURKOiB7CiAgICAgICAgTnVtYmVyOiBudWxsLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIkNvbmZpZGVuY2UgaW50ZXJ2YWwgYXJvdW5kIGNvcHkgbnVtYmVyIGZvciB0aGUgYWRqYWNlbmN5IgogICAgICB9CiAgICB9LAogICAgR2Vub3R5cGVGaWVsZHM6IHsKICAgICAgQUQ6IHsKICAgICAgICBOdW1iZXI6ICJSIiwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJSZWFkIGRlcHRoIGZvciBlYWNoIGFsbGVsZSIKICAgICAgfSwKICAgICAgQURGOiB7CiAgICAgICAgTnVtYmVyOiAiUiIsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiUmVhZCBkZXB0aCBmb3IgZWFjaCBhbGxlbGUgb24gdGhlIGZvcndhcmQgc3RyYW5kIgogICAgICB9LAogICAgICBBRFI6IHsKICAgICAgICBOdW1iZXI6ICJSIiwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJSZWFkIGRlcHRoIGZvciBlYWNoIGFsbGVsZSBvbiB0aGUgcmV2ZXJzZSBzdHJhbmQiCiAgICAgIH0sCiAgICAgIERQOiB7CiAgICAgICAgTnVtYmVyOiAxLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIlJlYWQgZGVwdGgiCiAgICAgIH0sCiAgICAgIEVDOiB7CiAgICAgICAgTnVtYmVyOiAiQSIsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiRXhwZWN0ZWQgYWx0ZXJuYXRlIGFsbGVsZSBjb3VudHMiCiAgICAgIH0sCiAgICAgIEZUOiB7CiAgICAgICAgTnVtYmVyOiAxLAogICAgICAgIFR5cGU6ICJTdHJpbmciLAogICAgICAgIERlc2NyaXB0aW9uOiAnRmlsdGVyIGluZGljYXRpbmcgaWYgdGhpcyBnZW5vdHlwZSB3YXMgImNhbGxlZCInCiAgICAgIH0sCiAgICAgIEdMOiB7CiAgICAgICAgTnVtYmVyOiAiRyIsCiAgICAgICAgVHlwZTogIkZsb2F0IiwKICAgICAgICBEZXNjcmlwdGlvbjogIkdlbm90eXBlIGxpa2VsaWhvb2RzIgogICAgICB9LAogICAgICBHUDogewogICAgICAgIE51bWJlcjogIkciLAogICAgICAgIFR5cGU6ICJGbG9hdCIsCiAgICAgICAgRGVzY3JpcHRpb246ICJHZW5vdHlwZSBwb3N0ZXJpb3IgcHJvYmFiaWxpdGllcyIKICAgICAgfSwKICAgICAgR1E6IHsKICAgICAgICBOdW1iZXI6IDEsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiQ29uZGl0aW9uYWwgZ2Vub3R5cGUgcXVhbGl0eSIKICAgICAgfSwKICAgICAgR1Q6IHsKICAgICAgICBOdW1iZXI6IDEsCiAgICAgICAgVHlwZTogIlN0cmluZyIsCiAgICAgICAgRGVzY3JpcHRpb246ICJHZW5vdHlwZSIKICAgICAgfSwKICAgICAgSFE6IHsKICAgICAgICBOdW1iZXI6IDIsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiSGFwbG90eXBlIHF1YWxpdHkiCiAgICAgIH0sCiAgICAgIE1ROiB7CiAgICAgICAgTnVtYmVyOiAxLAogICAgICAgIFR5cGU6ICJJbnRlZ2VyIiwKICAgICAgICBEZXNjcmlwdGlvbjogIlJNUyBtYXBwaW5nIHF1YWxpdHkiCiAgICAgIH0sCiAgICAgIFBMOiB7CiAgICAgICAgTnVtYmVyOiAiRyIsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiUGhyZWQtc2NhbGVkIGdlbm90eXBlIGxpa2VsaWhvb2RzIHJvdW5kZWQgdG8gdGhlIGNsb3Nlc3QgaW50ZWdlciIKICAgICAgfSwKICAgICAgUFE6IHsKICAgICAgICBOdW1iZXI6IDEsCiAgICAgICAgVHlwZTogIkludGVnZXIiLAogICAgICAgIERlc2NyaXB0aW9uOiAiUGhhc2luZyBxdWFsaXR5IgogICAgICB9LAogICAgICBQUzogewogICAgICAgIE51bWJlcjogMSwKICAgICAgICBUeXBlOiAiSW50ZWdlciIsCiAgICAgICAgRGVzY3JpcHRpb246ICJQaGFzZSBzZXQiCiAgICAgIH0KICAgIH0sCiAgICBBbHRUeXBlczogewogICAgICBERUw6IHsKICAgICAgICBEZXNjcmlwdGlvbjogIkRlbGV0aW9uIHJlbGF0aXZlIHRvIHRoZSByZWZlcmVuY2UiCiAgICAgIH0sCiAgICAgIElOUzogewogICAgICAgIERlc2NyaXB0aW9uOiAiSW5zZXJ0aW9uIG9mIG5vdmVsIHNlcXVlbmNlIHJlbGF0aXZlIHRvIHRoZSByZWZlcmVuY2UiCiAgICAgIH0sCiAgICAgIERVUDogewogICAgICAgIERlc2NyaXB0aW9uOiAiUmVnaW9uIG9mIGVsZXZhdGVkIGNvcHkgbnVtYmVyIHJlbGF0aXZlIHRvIHRoZSByZWZlcmVuY2UiCiAgICAgIH0sCiAgICAgIElOVjogewogICAgICAgIERlc2NyaXB0aW9uOiAiSW52ZXJzaW9uIG9mIHJlZmVyZW5jZSBzZXF1ZW5jZSIKICAgICAgfSwKICAgICAgQ05WOiB7CiAgICAgICAgRGVzY3JpcHRpb246ICJDb3B5IG51bWJlciB2YXJpYWJsZSByZWdpb24gKG1heSBiZSBib3RoIGRlbGV0aW9uIGFuZCBkdXBsaWNhdGlvbikiCiAgICAgIH0sCiAgICAgICJEVVA6VEFOREVNIjogewogICAgICAgIERlc2NyaXB0aW9uOiAiVGFuZGVtIGR1cGxpY2F0aW9uIgogICAgICB9LAogICAgICAiREVMOk1FIjogewogICAgICAgIERlc2NyaXB0aW9uOiAiRGVsZXRpb24gb2YgbW9iaWxlIGVsZW1lbnQgcmVsYXRpdmUgdG8gdGhlIHJlZmVyZW5jZSIKICAgICAgfSwKICAgICAgIklOUzpNRSI6IHsKICAgICAgICBEZXNjcmlwdGlvbjogIkluc2VydGlvbiBvZiBhIG1vYmlsZSBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZSByZWZlcmVuY2UiCiAgICAgIH0sCiAgICAgIE5PTl9SRUY6IHsKICAgICAgICBEZXNjcmlwdGlvbjogIlJlcHJlc2VudHMgYW55IHBvc3NpYmxlIGFsdGVybmF0aXZlIGFsbGVsZSBhdCB0aGlzIGxvY2F0aW9uIgogICAgICB9LAogICAgICAiKiI6IHsKICAgICAgICBEZXNjcmlwdGlvbjogIlJlcHJlc2VudHMgYW55IHBvc3NpYmxlIGFsdGVybmF0aXZlIGFsbGVsZSBhdCB0aGlzIGxvY2F0aW9uIgogICAgICB9CiAgICB9LAogICAgRmlsdGVyVHlwZXM6IHsKICAgICAgUEFTUzogewogICAgICAgIERlc2NyaXB0aW9uOiAiUGFzc2VkIGFsbCBmaWx0ZXJzIgogICAgICB9CiAgICB9CiAgfTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL3ZjZi9lc20vcGFyc2UuanMKICBmdW5jdGlvbiBWYXJpYW50KHN0dWZmKSB7CiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHN0dWZmKTsKICB9CiAgZnVuY3Rpb24gZGVjb2RlVVJJQ29tcG9uZW50Tm9UaHJvdyh1cmkpIHsKICAgIHRyeSB7CiAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQodXJpKTsKICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgcmV0dXJuIHVyaTsKICAgIH0KICB9CiAgdmFyIFZDRiA9IGNsYXNzIHsKICAgIGNvbnN0cnVjdG9yKHsgaGVhZGVyID0gIiIsIHN0cmljdCA9IHRydWUgfSkgewogICAgICBpZiAoIWhlYWRlciB8fCAhaGVhZGVyLmxlbmd0aCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiZW1wdHkgaGVhZGVyIHJlY2VpdmVkIik7CiAgICAgIH0KICAgICAgY29uc3QgaGVhZGVyTGluZXMgPSBoZWFkZXIuc3BsaXQoL1tcclxuXSsvKS5maWx0ZXIoKGxpbmUpID0+IGxpbmUpOwogICAgICBpZiAoIWhlYWRlckxpbmVzLmxlbmd0aCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigibm8gbm9uLWVtcHR5IGhlYWRlciBsaW5lcyBzcGVjaWZpZWQiKTsKICAgICAgfQogICAgICB0aGlzLnN0cmljdCA9IHN0cmljdDsKICAgICAgdGhpcy5tZXRhZGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoewogICAgICAgIElORk86IHZjZlJlc2VydmVkX2RlZmF1bHQuSW5mb0ZpZWxkcywKICAgICAgICBGT1JNQVQ6IHZjZlJlc2VydmVkX2RlZmF1bHQuR2Vub3R5cGVGaWVsZHMsCiAgICAgICAgQUxUOiB2Y2ZSZXNlcnZlZF9kZWZhdWx0LkFsdFR5cGVzLAogICAgICAgIEZJTFRFUjogdmNmUmVzZXJ2ZWRfZGVmYXVsdC5GaWx0ZXJUeXBlcwogICAgICB9KSk7CiAgICAgIGxldCBsYXN0TGluZTsKICAgICAgaGVhZGVyTGluZXMuZm9yRWFjaCgobGluZSkgPT4gewogICAgICAgIGlmICghbGluZS5zdGFydHNXaXRoKCIjIikpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmFkIGxpbmUgaW4gaGVhZGVyOgoke2xpbmV9YCk7CiAgICAgICAgfSBlbHNlIGlmIChsaW5lLnN0YXJ0c1dpdGgoIiMjIikpIHsKICAgICAgICAgIHRoaXMuX3BhcnNlTWV0YWRhdGEobGluZSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGxhc3RMaW5lID0gbGluZTsKICAgICAgICB9CiAgICAgIH0pOwogICAgICBpZiAoIWxhc3RMaW5lKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJObyBmb3JtYXQgbGluZSBmb3VuZCBpbiBoZWFkZXIiKTsKICAgICAgfQogICAgICBjb25zdCBmaWVsZHMgPSBsYXN0TGluZS50cmltKCkuc3BsaXQoIgkiKTsKICAgICAgY29uc3QgdGhpc0hlYWRlciA9IGZpZWxkcy5zbGljZSgwLCA4KTsKICAgICAgY29uc3QgY29ycmVjdEhlYWRlciA9IFsKICAgICAgICAiI0NIUk9NIiwKICAgICAgICAiUE9TIiwKICAgICAgICAiSUQiLAogICAgICAgICJSRUYiLAogICAgICAgICJBTFQiLAogICAgICAgICJRVUFMIiwKICAgICAgICAiRklMVEVSIiwKICAgICAgICAiSU5GTyIKICAgICAgXTsKICAgICAgaWYgKGZpZWxkcy5sZW5ndGggPCA4KSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWQ0YgaGVhZGVyIG1pc3NpbmcgY29sdW1uczoKJHtsYXN0TGluZX1gKTsKICAgICAgfSBlbHNlIGlmIChmaWVsZHMubGVuZ3RoID09PSA5KSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWQ0YgaGVhZGVyIGhhcyBGT1JNQVQgYnV0IG5vIHNhbXBsZXM6CiR7bGFzdExpbmV9YCk7CiAgICAgIH0gZWxzZSBpZiAodGhpc0hlYWRlci5sZW5ndGggIT09IGNvcnJlY3RIZWFkZXIubGVuZ3RoIHx8ICF0aGlzSGVhZGVyLmV2ZXJ5KCh2YWx1ZSwgaW5kZXgpID0+IHZhbHVlID09PSBjb3JyZWN0SGVhZGVyW2luZGV4XSkpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZDRiBjb2x1bW4gaGVhZGVycyBub3QgY29ycmVjdDoKJHtsYXN0TGluZX1gKTsKICAgICAgfQogICAgICB0aGlzLnNhbXBsZXMgPSBmaWVsZHMuc2xpY2UoOSk7CiAgICB9CiAgICBfcGFyc2VHZW5vdHlwZXMoZm9ybWF0LCBwcmVyZXN0KSB7CiAgICAgIGNvbnN0IHJlc3QgPSBwcmVyZXN0LnNwbGl0KCIJIik7CiAgICAgIGNvbnN0IGdlbm90eXBlcyA9IHt9OwogICAgICBjb25zdCBmb3JtYXRLZXlzID0gZm9ybWF0ID09PSBudWxsIHx8IGZvcm1hdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9ybWF0LnNwbGl0KCI6Iik7CiAgICAgIGlmIChmb3JtYXRLZXlzKSB7CiAgICAgICAgdGhpcy5zYW1wbGVzLmZvckVhY2goKHNhbXBsZSwgaW5kZXgpID0+IHsKICAgICAgICAgIGdlbm90eXBlc1tzYW1wbGVdID0ge307CiAgICAgICAgICBmb3JtYXRLZXlzLmZvckVhY2goKGtleSkgPT4gewogICAgICAgICAgICBnZW5vdHlwZXNbc2FtcGxlXVtrZXldID0gbnVsbDsKICAgICAgICAgIH0pOwogICAgICAgICAgcmVzdFtpbmRleF0uc3BsaXQoIjoiKS5maWx0ZXIoKGYpID0+IGYpLmZvckVhY2goKHZhbCwgaW5kZXgyKSA9PiB7CiAgICAgICAgICAgIGxldCB0aGlzVmFsdWU7CiAgICAgICAgICAgIGlmICh2YWwgPT09ICIiIHx8IHZhbCA9PT0gIi4iIHx8IHZhbCA9PT0gdm9pZCAwKSB7CiAgICAgICAgICAgICAgdGhpc1ZhbHVlID0gbnVsbDsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gdmFsLnNwbGl0KCIsIikubWFwKChlbnQpID0+IGVudCA9PT0gIi4iID8gbnVsbCA6IGVudCk7CiAgICAgICAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5nZXRNZXRhZGF0YSgiRk9STUFUIiwgZm9ybWF0S2V5c1tpbmRleDJdLCAiVHlwZSIpOwogICAgICAgICAgICAgIGlmICh2YWx1ZVR5cGUgPT09ICJJbnRlZ2VyIiB8fCB2YWx1ZVR5cGUgPT09ICJGbG9hdCIpIHsKICAgICAgICAgICAgICAgIHRoaXNWYWx1ZSA9IGVudHJpZXMubWFwKCh2YWwyKSA9PiB2YWwyID8gK3ZhbDIgOiB2YWwyKTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdGhpc1ZhbHVlID0gZW50cmllczsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZ2Vub3R5cGVzW3NhbXBsZV1bZm9ybWF0S2V5c1tpbmRleDJdXSA9IHRoaXNWYWx1ZTsKICAgICAgICAgIH0sIHt9KTsKICAgICAgICB9KTsKICAgICAgfQogICAgICByZXR1cm4gZ2Vub3R5cGVzOwogICAgfQogICAgX3BhcnNlTWV0YWRhdGEobGluZSkgewogICAgICBjb25zdCBtYXRjaCA9IGxpbmUudHJpbSgpLm1hdGNoKC9eIyMoLis/KT0oLiopLyk7CiAgICAgIGlmICghbWF0Y2gpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmUgaXMgbm90IGEgdmFsaWQgbWV0YWRhdGEgbGluZTogJHtsaW5lfWApOwogICAgICB9CiAgICAgIGNvbnN0IFttZXRhS2V5LCBtZXRhVmFsXSA9IG1hdGNoLnNsaWNlKDEsIDMpOwogICAgICBpZiAobWV0YVZhbC5zdGFydHNXaXRoKCI8IikpIHsKICAgICAgICBpZiAoIShtZXRhS2V5IGluIHRoaXMubWV0YWRhdGEpKSB7CiAgICAgICAgICB0aGlzLm1ldGFkYXRhW21ldGFLZXldID0ge307CiAgICAgICAgfQogICAgICAgIGNvbnN0IFtpZCwga2V5VmFsc10gPSB0aGlzLl9wYXJzZVN0cnVjdHVyZWRNZXRhVmFsKG1ldGFWYWwpOwogICAgICAgIHRoaXMubWV0YWRhdGFbbWV0YUtleV1baWRdID0ga2V5VmFsczsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLm1ldGFkYXRhW21ldGFLZXldID0gbWV0YVZhbDsKICAgICAgfQogICAgfQogICAgX3BhcnNlU3RydWN0dXJlZE1ldGFWYWwobWV0YVZhbCkgewogICAgICBjb25zdCBrZXlWYWxzID0gdGhpcy5fcGFyc2VLZXlWYWx1ZShtZXRhVmFsLnJlcGxhY2UoL148fD4kL2csICIiKSwgIiwiKTsKICAgICAgY29uc3QgaWQgPSBrZXlWYWxzLklEOwogICAgICBkZWxldGUga2V5VmFscy5JRDsKICAgICAgaWYgKCJOdW1iZXIiIGluIGtleVZhbHMpIHsKICAgICAgICBpZiAoIU51bWJlci5pc05hTihOdW1iZXIoa2V5VmFscy5OdW1iZXIpKSkgewogICAgICAgICAga2V5VmFscy5OdW1iZXIgPSBOdW1iZXIoa2V5VmFscy5OdW1iZXIpOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gW2lkLCBrZXlWYWxzXTsKICAgIH0KICAgIGdldE1ldGFkYXRhKC4uLmFyZ3MpIHsKICAgICAgbGV0IGZpbHRlcmVkTWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhOwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICBmaWx0ZXJlZE1ldGFkYXRhID0gZmlsdGVyZWRNZXRhZGF0YVthcmdzW2ldXTsKICAgICAgICBpZiAoIWZpbHRlcmVkTWV0YWRhdGEpIHsKICAgICAgICAgIHJldHVybiBmaWx0ZXJlZE1ldGFkYXRhOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gZmlsdGVyZWRNZXRhZGF0YTsKICAgIH0KICAgIF9wYXJzZUtleVZhbHVlKHN0ciwgcGFpclNlcGFyYXRvciA9ICI7IikgewogICAgICBjb25zdCBkYXRhID0ge307CiAgICAgIGxldCBjdXJyS2V5ID0gIiI7CiAgICAgIGxldCBjdXJyVmFsdWUgPSAiIjsKICAgICAgbGV0IHN0YXRlID0gMTsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICBpZiAoc3RhdGUgPT09IDEpIHsKICAgICAgICAgIGlmIChzdHJbaV0gPT09ICI9IikgewogICAgICAgICAgICBzdGF0ZSA9IDI7CiAgICAgICAgICB9IGVsc2UgaWYgKHN0cltpXSAhPT0gcGFpclNlcGFyYXRvcikgewogICAgICAgICAgICBjdXJyS2V5ICs9IHN0cltpXTsKICAgICAgICAgIH0gZWxzZSBpZiAoY3VyclZhbHVlID09PSAiIikgewogICAgICAgICAgICBkYXRhW2N1cnJLZXldID0gbnVsbDsKICAgICAgICAgICAgY3VycktleSA9ICIiOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IDIpIHsKICAgICAgICAgIGlmIChzdHJbaV0gPT09IHBhaXJTZXBhcmF0b3IpIHsKICAgICAgICAgICAgZGF0YVtjdXJyS2V5XSA9IGN1cnJWYWx1ZTsKICAgICAgICAgICAgY3VycktleSA9ICIiOwogICAgICAgICAgICBjdXJyVmFsdWUgPSAiIjsKICAgICAgICAgICAgc3RhdGUgPSAxOwogICAgICAgICAgfSBlbHNlIGlmIChzdHJbaV0gPT09ICciJykgewogICAgICAgICAgICBzdGF0ZSA9IDM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjdXJyVmFsdWUgKz0gc3RyW2ldOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IDMpIHsKICAgICAgICAgIGlmIChzdHJbaV0gIT09ICciJykgewogICAgICAgICAgICBjdXJyVmFsdWUgKz0gc3RyW2ldOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgc3RhdGUgPSAyOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBpZiAoc3RhdGUgPT09IDIgfHwgc3RhdGUgPT09IDMpIHsKICAgICAgICBkYXRhW2N1cnJLZXldID0gY3VyclZhbHVlOwogICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAxKSB7CiAgICAgICAgZGF0YVtjdXJyS2V5XSA9IG51bGw7CiAgICAgIH0KICAgICAgcmV0dXJuIGRhdGE7CiAgICB9CiAgICBwYXJzZUxpbmUobGluZSkgewogICAgICBsaW5lID0gbGluZS50cmltKCk7CiAgICAgIGlmICghbGluZS5sZW5ndGgpIHsKICAgICAgICByZXR1cm4gdm9pZCAwOwogICAgICB9CiAgICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7CiAgICAgIGxldCBjdXJyQ2hhciA9IDA7CiAgICAgIGZvciAobGV0IGN1cnJGaWVsZCA9IDA7IGN1cnJDaGFyIDwgbGluZS5sZW5ndGg7IGN1cnJDaGFyICs9IDEpIHsKICAgICAgICBpZiAobGluZVtjdXJyQ2hhcl0gPT09ICIJIikgewogICAgICAgICAgY3VyckZpZWxkICs9IDE7CiAgICAgICAgfQogICAgICAgIGlmIChjdXJyRmllbGQgPT09IDkpIHsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgfQogICAgICBjb25zdCBmaWVsZHMgPSBsaW5lLnN1YnN0cigwLCBjdXJyQ2hhcikuc3BsaXQoIgkiKTsKICAgICAgY29uc3QgcmVzdCA9IGxpbmUuc3Vic3RyKGN1cnJDaGFyICsgMSk7CiAgICAgIGNvbnN0IFtDSFJPTSwgUE9TLCBJRCwgUkVGLCBBTFQsIFFVQUwsIEZJTFRFUl0gPSBmaWVsZHM7CiAgICAgIGNvbnN0IGNocm9tID0gQ0hST007CiAgICAgIGNvbnN0IHBvcyA9ICtQT1M7CiAgICAgIGNvbnN0IGlkID0gSUQgPT09ICIuIiA/IG51bGwgOiBJRC5zcGxpdCgiOyIpOwogICAgICBjb25zdCByZWYgPSBSRUY7CiAgICAgIGNvbnN0IGFsdCA9IEFMVCA9PT0gIi4iID8gbnVsbCA6IEFMVC5zcGxpdCgiLCIpOwogICAgICBjb25zdCBxdWFsID0gUVVBTCA9PT0gIi4iID8gbnVsbCA6ICtRVUFMOwogICAgICBjb25zdCBmaWx0ZXIgPSBGSUxURVIgPT09ICIuIiA/IG51bGwgOiBGSUxURVIuc3BsaXQoIjsiKTsKICAgICAgaWYgKHRoaXMuc3RyaWN0ICYmIGZpZWxkc1s3XSA9PT0gdm9pZCAwKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJubyBJTkZPIGZpZWxkIHNwZWNpZmllZCwgbXVzdCBjb250YWluIGF0IGxlYXN0IGEgJy4nICh0dXJuIG9mZiBzdHJpY3QgbW9kZSB0byBhbGxvdykiKTsKICAgICAgfQogICAgICBjb25zdCBpbmZvID0gZmllbGRzWzddID09PSB2b2lkIDAgfHwgZmllbGRzWzddID09PSAiLiIgPyB7fSA6IHRoaXMuX3BhcnNlS2V5VmFsdWUoZmllbGRzWzddKTsKICAgICAgT2JqZWN0LmtleXMoaW5mbykuZm9yRWFjaCgoa2V5KSA9PiB7CiAgICAgICAgbGV0IGl0ZW1zOwogICAgICAgIGlmIChpbmZvW2tleV0pIHsKICAgICAgICAgIGl0ZW1zID0gaW5mb1trZXldLnNwbGl0KCIsIikubWFwKCh2YWwpID0+IHZhbCA9PT0gIi4iID8gbnVsbCA6IHZhbCkubWFwKChmKSA9PiBmID8gZGVjb2RlVVJJQ29tcG9uZW50Tm9UaHJvdyhmKSA6IGYpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpdGVtcyA9IGluZm9ba2V5XTsKICAgICAgICB9CiAgICAgICAgY29uc3QgaXRlbVR5cGUgPSB0aGlzLmdldE1ldGFkYXRhKCJJTkZPIiwga2V5LCAiVHlwZSIpOwogICAgICAgIGlmIChpdGVtVHlwZSkgewogICAgICAgICAgaWYgKGl0ZW1UeXBlID09PSAiSW50ZWdlciIgfHwgaXRlbVR5cGUgPT09ICJGbG9hdCIpIHsKICAgICAgICAgICAgaXRlbXMgPSBpdGVtcy5tYXAoKHZhbCkgPT4gewogICAgICAgICAgICAgIGlmICh2YWwgPT09IG51bGwpIHsKICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbCk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSBlbHNlIGlmIChpdGVtVHlwZSA9PT0gIkZsYWciKSB7CiAgICAgICAgICAgIGlmIChpbmZvW2tleV0pIHsKICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEluZm8gZmllbGQgJHtrZXl9IGlzIGEgRmxhZyBhbmQgc2hvdWxkIG5vdCBoYXZlIGEgdmFsdWUgKGdvdCB2YWx1ZSAke2luZm9ba2V5XX0pYCk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgaXRlbXMgPSB0cnVlOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGluZm9ba2V5XSA9IGl0ZW1zOwogICAgICB9KTsKICAgICAgY29uc3QgdmFyaWFudCA9IG5ldyBWYXJpYW50KHsKICAgICAgICBDSFJPTTogY2hyb20sCiAgICAgICAgUE9TOiBwb3MsCiAgICAgICAgQUxUOiBhbHQsCiAgICAgICAgSU5GTzogaW5mbywKICAgICAgICBSRUY6IHJlZiwKICAgICAgICBGSUxURVI6IGZpbHRlciAmJiBmaWx0ZXIubGVuZ3RoID09PSAxICYmIGZpbHRlclswXSA9PT0gIlBBU1MiID8gIlBBU1MiIDogZmlsdGVyLAogICAgICAgIElEOiBpZCwKICAgICAgICBRVUFMOiBxdWFsCiAgICAgIH0pOwogICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFyaWFudCwgIlNBTVBMRVMiLCB7CiAgICAgICAgZ2V0KCkgewogICAgICAgICAgY29uc3Qgc2FtcGxlcyA9IHBhcnNlci5fcGFyc2VHZW5vdHlwZXMoZmllbGRzWzhdLCByZXN0KTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAiU0FNUExFUyIsIHsKICAgICAgICAgICAgdmFsdWU6IHNhbXBsZXMsCiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UKICAgICAgICAgIH0pOwogICAgICAgICAgcmV0dXJuIHNhbXBsZXM7CiAgICAgICAgfSwKICAgICAgICBjb25maWd1cmFibGU6IHRydWUKICAgICAgfSk7CiAgICAgIHJldHVybiB2YXJpYW50OwogICAgfQogIH07CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC92Y2YvZXNtL2luZGV4LmpzCiAgdmFyIGVzbV9kZWZhdWx0ID0gVkNGOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvdGFiaXgvZXNtL2luZGV4LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvdGFiaXgvZXNtL3RhYml4SW5kZXhlZEZpbGUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9hYm9ydGFibGVfcHJvbWlzZV9jYWNoZTIgPSBfX3RvTW9kdWxlKHJlcXVpcmVfZXNtKCkpOwogIHZhciBpbXBvcnRfcXVpY2tfbHJ1MiA9IF9fdG9Nb2R1bGUocmVxdWlyZV9xdWlja19scnUoKSk7CiAgdmFyIGltcG9ydF9nZW5lcmljX2ZpbGVoYW5kbGUgPSBfX3RvTW9kdWxlKHJlcXVpcmVfZGlzdCgpKTsKICB2YXIgaW1wb3J0X2JnemZfZmlsZWhhbmRsZTMgPSBfX3RvTW9kdWxlKHJlcXVpcmVfZGlzdDIoKSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9lc20vdXRpbC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBsb25nVG9OdW1iZXIobG9uZykgewogICAgaWYgKGxvbmcuZ3JlYXRlclRoYW4oTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHx8IGxvbmcubGVzc1RoYW4oTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpKSB7CiAgICAgIHRocm93IG5ldyBFcnJvcigiaW50ZWdlciBvdmVyZmxvdyIpOwogICAgfQogICAgcmV0dXJuIGxvbmcudG9OdW1iZXIoKTsKICB9CiAgdmFyIEFib3J0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHsKICB9OwogIGZ1bmN0aW9uIGNoZWNrQWJvcnRTaWduYWwoc2lnbmFsKSB7CiAgICBpZiAoIXNpZ25hbCkgewogICAgICByZXR1cm47CiAgICB9CiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHsKICAgICAgaWYgKHR5cGVvZiBET01FeGNlcHRpb24gIT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbigiYWJvcnRlZCIsICJBYm9ydEVycm9yIik7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29uc3QgZSA9IG5ldyBBYm9ydEVycm9yKCJhYm9ydGVkIik7CiAgICAgICAgZS5jb2RlID0gIkVSUl9BQk9SVEVEIjsKICAgICAgICB0aHJvdyBlOwogICAgICB9CiAgICB9CiAgfQogIGZ1bmN0aW9uIGNhbk1lcmdlQmxvY2tzKGNodW5rMSwgY2h1bmsyKSB7CiAgICByZXR1cm4gY2h1bmsyLm1pbnYuYmxvY2tQb3NpdGlvbiAtIGNodW5rMS5tYXh2LmJsb2NrUG9zaXRpb24gPCA2NWUzICYmIGNodW5rMi5tYXh2LmJsb2NrUG9zaXRpb24gLSBjaHVuazEubWludi5ibG9ja1Bvc2l0aW9uIDwgNWU2OwogIH0KICBmdW5jdGlvbiBvcHRpbWl6ZUNodW5rcyhjaHVua3MsIGxvd2VzdCkgewogICAgY29uc3QgbWVyZ2VkQ2h1bmtzID0gW107CiAgICBsZXQgbGFzdENodW5rID0gbnVsbDsKICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSB7CiAgICAgIHJldHVybiBjaHVua3M7CiAgICB9CiAgICBjaHVua3Muc29ydChmdW5jdGlvbihjMCwgYzEpIHsKICAgICAgY29uc3QgZGlmID0gYzAubWludi5ibG9ja1Bvc2l0aW9uIC0gYzEubWludi5ibG9ja1Bvc2l0aW9uOwogICAgICBpZiAoZGlmICE9PSAwKSB7CiAgICAgICAgcmV0dXJuIGRpZjsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gYzAubWludi5kYXRhUG9zaXRpb24gLSBjMS5taW52LmRhdGFQb3NpdGlvbjsKICAgICAgfQogICAgfSk7CiAgICBjaHVua3MuZm9yRWFjaCgoY2h1bmspID0+IHsKICAgICAgaWYgKCFsb3dlc3QgfHwgY2h1bmsubWF4di5jb21wYXJlVG8obG93ZXN0KSA+IDApIHsKICAgICAgICBpZiAobGFzdENodW5rID09PSBudWxsKSB7CiAgICAgICAgICBtZXJnZWRDaHVua3MucHVzaChjaHVuayk7CiAgICAgICAgICBsYXN0Q2h1bmsgPSBjaHVuazsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgaWYgKGNhbk1lcmdlQmxvY2tzKGxhc3RDaHVuaywgY2h1bmspKSB7CiAgICAgICAgICAgIGlmIChjaHVuay5tYXh2LmNvbXBhcmVUbyhsYXN0Q2h1bmsubWF4dikgPiAwKSB7CiAgICAgICAgICAgICAgbGFzdENodW5rLm1heHYgPSBjaHVuay5tYXh2OwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBtZXJnZWRDaHVua3MucHVzaChjaHVuayk7CiAgICAgICAgICAgIGxhc3RDaHVuayA9IGNodW5rOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfSk7CiAgICByZXR1cm4gbWVyZ2VkQ2h1bmtzOwogIH0KCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS90YmkuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9sb25nID0gX190b01vZHVsZShyZXF1aXJlX2xvbmcoKSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9lc20vdmlydHVhbE9mZnNldC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgVmlydHVhbE9mZnNldCA9IGNsYXNzIHsKICAgIGNvbnN0cnVjdG9yKGJsb2NrUG9zaXRpb24sIGRhdGFQb3NpdGlvbikgewogICAgICB0aGlzLmJsb2NrUG9zaXRpb24gPSBibG9ja1Bvc2l0aW9uOwogICAgICB0aGlzLmRhdGFQb3NpdGlvbiA9IGRhdGFQb3NpdGlvbjsKICAgIH0KICAgIHRvU3RyaW5nKCkgewogICAgICByZXR1cm4gYCR7dGhpcy5ibG9ja1Bvc2l0aW9ufToke3RoaXMuZGF0YVBvc2l0aW9ufWA7CiAgICB9CiAgICBjb21wYXJlVG8oYikgewogICAgICByZXR1cm4gdGhpcy5ibG9ja1Bvc2l0aW9uIC0gYi5ibG9ja1Bvc2l0aW9uIHx8IHRoaXMuZGF0YVBvc2l0aW9uIC0gYi5kYXRhUG9zaXRpb247CiAgICB9CiAgICBzdGF0aWMgbWluKC4uLmFyZ3MpIHsKICAgICAgbGV0IG1pbjsKICAgICAgbGV0IGkgPSAwOwogICAgICBmb3IgKDsgIW1pbjsgaSArPSAxKSB7CiAgICAgICAgbWluID0gYXJnc1tpXTsKICAgICAgfQogICAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICBpZiAobWluLmNvbXBhcmVUbyhhcmdzW2ldKSA+IDApIHsKICAgICAgICAgIG1pbiA9IGFyZ3NbaV07CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBtaW47CiAgICB9CiAgfTsKICBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMsIG9mZnNldCA9IDAsIGJpZ2VuZGlhbiA9IGZhbHNlKSB7CiAgICBpZiAoYmlnZW5kaWFuKSB7CiAgICAgIHRocm93IG5ldyBFcnJvcigiYmlnLWVuZGlhbiB2aXJ0dWFsIGZpbGUgb2Zmc2V0cyBub3QgaW1wbGVtZW50ZWQiKTsKICAgIH0KICAgIHJldHVybiBuZXcgVmlydHVhbE9mZnNldChieXRlc1tvZmZzZXQgKyA3XSAqIDEwOTk1MTE2Mjc3NzYgKyBieXRlc1tvZmZzZXQgKyA2XSAqIDQyOTQ5NjcyOTYgKyBieXRlc1tvZmZzZXQgKyA1XSAqIDE2Nzc3MjE2ICsgYnl0ZXNbb2Zmc2V0ICsgNF0gKiA2NTUzNiArIGJ5dGVzW29mZnNldCArIDNdICogMjU2ICsgYnl0ZXNbb2Zmc2V0ICsgMl0sIGJ5dGVzW29mZnNldCArIDFdIDw8IDggfCBieXRlc1tvZmZzZXRdKTsKICB9CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9lc20vY2h1bmsuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIENodW5rID0gY2xhc3MgewogICAgY29uc3RydWN0b3IobWludiwgbWF4diwgYmluLCBmZXRjaGVkU2l6ZSA9IHZvaWQgMCkgewogICAgICB0aGlzLm1pbnYgPSBtaW52OwogICAgICB0aGlzLm1heHYgPSBtYXh2OwogICAgICB0aGlzLmJpbiA9IGJpbjsKICAgICAgdGhpcy5fZmV0Y2hlZFNpemUgPSBmZXRjaGVkU2l6ZTsKICAgIH0KICAgIHRvVW5pcXVlU3RyaW5nKCkgewogICAgICByZXR1cm4gYCR7dGhpcy5taW52fS4uJHt0aGlzLm1heHZ9IChiaW4gJHt0aGlzLmJpbn0sIGZldGNoZWRTaXplICR7dGhpcy5mZXRjaGVkU2l6ZSgpfSlgOwogICAgfQogICAgdG9TdHJpbmcoKSB7CiAgICAgIHJldHVybiB0aGlzLnRvVW5pcXVlU3RyaW5nKCk7CiAgICB9CiAgICBjb21wYXJlVG8oYikgewogICAgICByZXR1cm4gdGhpcy5taW52LmNvbXBhcmVUbyhiLm1pbnYpIHx8IHRoaXMubWF4di5jb21wYXJlVG8oYi5tYXh2KSB8fCB0aGlzLmJpbiAtIGIuYmluOwogICAgfQogICAgZmV0Y2hlZFNpemUoKSB7CiAgICAgIGlmICh0aGlzLl9mZXRjaGVkU2l6ZSAhPT0gdm9pZCAwKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoZWRTaXplOwogICAgICB9CiAgICAgIHJldHVybiB0aGlzLm1heHYuYmxvY2tQb3NpdGlvbiArICgxIDw8IDE2KSAtIHRoaXMubWludi5ibG9ja1Bvc2l0aW9uOwogICAgfQogIH07CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9lc20vdGJpLmpzCiAgdmFyIGltcG9ydF9iZ3pmX2ZpbGVoYW5kbGUgPSBfX3RvTW9kdWxlKHJlcXVpcmVfZGlzdDIoKSk7CgogIC8vIG5vZGVfbW9kdWxlcy9AZ21vZC90YWJpeC9lc20vaW5kZXhGaWxlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfYWJvcnRhYmxlX3Byb21pc2VfY2FjaGUgPSBfX3RvTW9kdWxlKHJlcXVpcmVfZXNtKCkpOwogIHZhciBpbXBvcnRfcXVpY2tfbHJ1ID0gX190b01vZHVsZShyZXF1aXJlX3F1aWNrX2xydSgpKTsKICB2YXIgSW5kZXhGaWxlID0gY2xhc3MgewogICAgY29uc3RydWN0b3IoeyBmaWxlaGFuZGxlLCByZW5hbWVSZWZTZXFzID0gKG4pID0+IG4gfSkgewogICAgICB0aGlzLmZpbGVoYW5kbGUgPSBmaWxlaGFuZGxlOwogICAgICB0aGlzLnJlbmFtZVJlZlNlcSA9IHJlbmFtZVJlZlNlcXM7CiAgICB9CiAgICBhc3luYyBnZXRNZXRhZGF0YShvcHRzID0ge30pIHsKICAgICAgY29uc3QgeyBpbmRpY2VzLCAuLi5yZXN0IH0gPSBhd2FpdCB0aGlzLnBhcnNlKG9wdHMpOwogICAgICByZXR1cm4gcmVzdDsKICAgIH0KICAgIF9maW5kRmlyc3REYXRhKGN1cnJlbnRGZGwsIHZpcnR1YWxPZmZzZXQpIHsKICAgICAgaWYgKGN1cnJlbnRGZGwpIHsKICAgICAgICByZXR1cm4gY3VycmVudEZkbC5jb21wYXJlVG8odmlydHVhbE9mZnNldCkgPiAwID8gdmlydHVhbE9mZnNldCA6IGN1cnJlbnRGZGw7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0dXJuIHZpcnR1YWxPZmZzZXQ7CiAgICAgIH0KICAgIH0KICAgIGFzeW5jIHBhcnNlKG9wdHMgPSB7fSkgewogICAgICBpZiAoIXRoaXMuX3BhcnNlQ2FjaGUpIHsKICAgICAgICB0aGlzLl9wYXJzZUNhY2hlID0gbmV3IGltcG9ydF9hYm9ydGFibGVfcHJvbWlzZV9jYWNoZS5kZWZhdWx0KHsKICAgICAgICAgIGNhY2hlOiBuZXcgaW1wb3J0X3F1aWNrX2xydS5kZWZhdWx0KHsgbWF4U2l6ZTogMSB9KSwKICAgICAgICAgIGZpbGw6ICgpID0+IHRoaXMuX3BhcnNlKG9wdHMpCiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlQ2FjaGUuZ2V0KCJpbmRleCIsIG51bGwsIHZvaWQgMCk7CiAgICB9CiAgICBhc3luYyBoYXNSZWZTZXEoc2VxSWQsIG9wdHMgPSB7fSkgewogICAgICByZXR1cm4gISEoKGF3YWl0IHRoaXMucGFyc2Uob3B0cykpLmluZGljZXNbc2VxSWRdIHx8IHt9KS5iaW5JbmRleDsKICAgIH0KICB9OwoKICAvLyBub2RlX21vZHVsZXMvQGdtb2QvdGFiaXgvZXNtL3RiaS5qcwogIHZhciBUQklfTUFHSUMgPSAyMTU3ODMyNDsKICB2YXIgVEFEX0xJRFhfU0hJRlQgPSAxNDsKICBmdW5jdGlvbiByZWcyYmlucyhiZWcsIGVuZCkgewogICAgYmVnICs9IDE7CiAgICBlbmQgLT0gMTsKICAgIHJldHVybiBbCiAgICAgIFswLCAwXSwKICAgICAgWzEgKyAoYmVnID4+IDI2KSwgMSArIChlbmQgPj4gMjYpXSwKICAgICAgWzkgKyAoYmVnID4+IDIzKSwgOSArIChlbmQgPj4gMjMpXSwKICAgICAgWzczICsgKGJlZyA+PiAyMCksIDczICsgKGVuZCA+PiAyMCldLAogICAgICBbNTg1ICsgKGJlZyA+PiAxNyksIDU4NSArIChlbmQgPj4gMTcpXSwKICAgICAgWzQ2ODEgKyAoYmVnID4+IDE0KSwgNDY4MSArIChlbmQgPj4gMTQpXQogICAgXTsKICB9CiAgdmFyIFRhYml4SW5kZXggPSBjbGFzcyBleHRlbmRzIEluZGV4RmlsZSB7CiAgICBhc3luYyBsaW5lQ291bnQocmVmTmFtZSwgb3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IGluZGV4RGF0YSA9IGF3YWl0IHRoaXMucGFyc2Uob3B0cyk7CiAgICAgIGlmICghaW5kZXhEYXRhKSB7CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9CiAgICAgIGNvbnN0IHJlZklkID0gaW5kZXhEYXRhLnJlZk5hbWVUb0lkW3JlZk5hbWVdOwogICAgICBjb25zdCBpZHggPSBpbmRleERhdGEuaW5kaWNlc1tyZWZJZF07CiAgICAgIGlmICghaWR4KSB7CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9CiAgICAgIGNvbnN0IHsgc3RhdHMgfSA9IGluZGV4RGF0YS5pbmRpY2VzW3JlZklkXTsKICAgICAgaWYgKHN0YXRzKSB7CiAgICAgICAgcmV0dXJuIHN0YXRzLmxpbmVDb3VudDsKICAgICAgfQogICAgICByZXR1cm4gLTE7CiAgICB9CiAgICBhc3luYyBfcGFyc2Uob3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgKDAsIGltcG9ydF9iZ3pmX2ZpbGVoYW5kbGUudW56aXApKGF3YWl0IHRoaXMuZmlsZWhhbmRsZS5yZWFkRmlsZShvcHRzKSk7CiAgICAgIGNoZWNrQWJvcnRTaWduYWwob3B0cy5zaWduYWwpOwogICAgICBpZiAoYnl0ZXMucmVhZFVJbnQzMkxFKDApICE9PSBUQklfTUFHSUMpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIk5vdCBhIFRCSSBmaWxlIik7CiAgICAgIH0KICAgICAgY29uc3QgcmVmQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRSg0KTsKICAgICAgY29uc3QgZm9ybWF0RmxhZ3MgPSBieXRlcy5yZWFkSW50MzJMRSg4KTsKICAgICAgY29uc3QgY29vcmRpbmF0ZVR5cGUgPSBmb3JtYXRGbGFncyAmIDY1NTM2ID8gInplcm8tYmFzZWQtaGFsZi1vcGVuIiA6ICIxLWJhc2VkLWNsb3NlZCI7CiAgICAgIGNvbnN0IGZvcm1hdE9wdHMgPSB7CiAgICAgICAgMDogImdlbmVyaWMiLAogICAgICAgIDE6ICJTQU0iLAogICAgICAgIDI6ICJWQ0YiCiAgICAgIH07CiAgICAgIGNvbnN0IGZvcm1hdCA9IGZvcm1hdE9wdHNbZm9ybWF0RmxhZ3MgJiAxNV07CiAgICAgIGlmICghZm9ybWF0KSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIFRhYml4IHByZXNldCBmb3JtYXQgZmxhZ3MgJHtmb3JtYXRGbGFnc31gKTsKICAgICAgfQogICAgICBjb25zdCBjb2x1bW5OdW1iZXJzID0gewogICAgICAgIHJlZjogYnl0ZXMucmVhZEludDMyTEUoMTIpLAogICAgICAgIHN0YXJ0OiBieXRlcy5yZWFkSW50MzJMRSgxNiksCiAgICAgICAgZW5kOiBieXRlcy5yZWFkSW50MzJMRSgyMCkKICAgICAgfTsKICAgICAgY29uc3QgbWV0YVZhbHVlID0gYnl0ZXMucmVhZEludDMyTEUoMjQpOwogICAgICBjb25zdCBkZXB0aCA9IDU7CiAgICAgIGNvbnN0IG1heEJpbk51bWJlciA9ICgoMSA8PCAoZGVwdGggKyAxKSAqIDMpIC0gMSkgLyA3OwogICAgICBjb25zdCBtYXhSZWZMZW5ndGggPSAyICoqICgxNCArIGRlcHRoICogMyk7CiAgICAgIGNvbnN0IG1ldGFDaGFyID0gbWV0YVZhbHVlID8gU3RyaW5nLmZyb21DaGFyQ29kZShtZXRhVmFsdWUpIDogbnVsbDsKICAgICAgY29uc3Qgc2tpcExpbmVzID0gYnl0ZXMucmVhZEludDMyTEUoMjgpOwogICAgICBjb25zdCBuYW1lU2VjdGlvbkxlbmd0aCA9IGJ5dGVzLnJlYWRJbnQzMkxFKDMyKTsKICAgICAgY29uc3QgeyByZWZOYW1lVG9JZCwgcmVmSWRUb05hbWUgfSA9IHRoaXMuX3BhcnNlTmFtZUJ5dGVzKGJ5dGVzLnNsaWNlKDM2LCAzNiArIG5hbWVTZWN0aW9uTGVuZ3RoKSk7CiAgICAgIGxldCBjdXJyT2Zmc2V0ID0gMzYgKyBuYW1lU2VjdGlvbkxlbmd0aDsKICAgICAgbGV0IGZpcnN0RGF0YUxpbmU7CiAgICAgIGNvbnN0IGluZGljZXMgPSBuZXcgQXJyYXkocmVmQ291bnQpLmZpbGwoMCkubWFwKCgpID0+IHsKICAgICAgICBjb25zdCBiaW5Db3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKGN1cnJPZmZzZXQpOwogICAgICAgIGN1cnJPZmZzZXQgKz0gNDsKICAgICAgICBjb25zdCBiaW5JbmRleCA9IHt9OwogICAgICAgIGxldCBzdGF0czsKICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJpbkNvdW50OyBqICs9IDEpIHsKICAgICAgICAgIGNvbnN0IGJpbiA9IGJ5dGVzLnJlYWRVSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICAgIGN1cnJPZmZzZXQgKz0gNDsKICAgICAgICAgIGlmIChiaW4gPiBtYXhCaW5OdW1iZXIgKyAxKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigidGFiaXggaW5kZXggY29udGFpbnMgdG9vIG1hbnkgYmlucywgcGxlYXNlIHVzZSBhIENTSSBpbmRleCIpOwogICAgICAgICAgfSBlbHNlIGlmIChiaW4gPT09IG1heEJpbk51bWJlciArIDEpIHsKICAgICAgICAgICAgY29uc3QgY2h1bmtDb3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKGN1cnJPZmZzZXQpOwogICAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDQ7CiAgICAgICAgICAgIGlmIChjaHVua0NvdW50ID09PSAyKSB7CiAgICAgICAgICAgICAgc3RhdHMgPSB0aGlzLnBhcnNlUHNldWRvQmluKGJ5dGVzLCBjdXJyT2Zmc2V0KTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDE2ICogY2h1bmtDb3VudDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGNvbnN0IGNodW5rQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICAgICAgY3Vyck9mZnNldCArPSA0OwogICAgICAgICAgICBjb25zdCBjaHVua3MgPSBuZXcgQXJyYXkoY2h1bmtDb3VudCk7CiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgY2h1bmtDb3VudDsgayArPSAxKSB7CiAgICAgICAgICAgICAgY29uc3QgdSA9IGZyb21CeXRlcyhieXRlcywgY3Vyck9mZnNldCk7CiAgICAgICAgICAgICAgY29uc3QgdiA9IGZyb21CeXRlcyhieXRlcywgY3Vyck9mZnNldCArIDgpOwogICAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gMTY7CiAgICAgICAgICAgICAgZmlyc3REYXRhTGluZSA9IHRoaXMuX2ZpbmRGaXJzdERhdGEoZmlyc3REYXRhTGluZSwgdSk7CiAgICAgICAgICAgICAgY2h1bmtzW2tdID0gbmV3IENodW5rKHUsIHYsIGJpbik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgYmluSW5kZXhbYmluXSA9IGNodW5rczsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgY29uc3QgbGluZWFyQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICBjdXJyT2Zmc2V0ICs9IDQ7CiAgICAgICAgY29uc3QgbGluZWFySW5kZXggPSBuZXcgQXJyYXkobGluZWFyQ291bnQpOwogICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbGluZWFyQ291bnQ7IGsgKz0gMSkgewogICAgICAgICAgbGluZWFySW5kZXhba10gPSBmcm9tQnl0ZXMoYnl0ZXMsIGN1cnJPZmZzZXQpOwogICAgICAgICAgY3Vyck9mZnNldCArPSA4OwogICAgICAgICAgZmlyc3REYXRhTGluZSA9IHRoaXMuX2ZpbmRGaXJzdERhdGEoZmlyc3REYXRhTGluZSwgbGluZWFySW5kZXhba10pOwogICAgICAgIH0KICAgICAgICByZXR1cm4geyBiaW5JbmRleCwgbGluZWFySW5kZXgsIHN0YXRzIH07CiAgICAgIH0pOwogICAgICByZXR1cm4gewogICAgICAgIGluZGljZXMsCiAgICAgICAgbWV0YUNoYXIsCiAgICAgICAgbWF4QmluTnVtYmVyLAogICAgICAgIG1heFJlZkxlbmd0aCwKICAgICAgICBza2lwTGluZXMsCiAgICAgICAgZmlyc3REYXRhTGluZSwKICAgICAgICBjb2x1bW5OdW1iZXJzLAogICAgICAgIGNvb3JkaW5hdGVUeXBlLAogICAgICAgIGZvcm1hdCwKICAgICAgICByZWZJZFRvTmFtZSwKICAgICAgICByZWZOYW1lVG9JZCwKICAgICAgICBtYXhCbG9ja1NpemU6IDEgPDwgMTYKICAgICAgfTsKICAgIH0KICAgIHBhcnNlUHNldWRvQmluKGJ5dGVzLCBvZmZzZXQpIHsKICAgICAgY29uc3QgbGluZUNvdW50ID0gbG9uZ1RvTnVtYmVyKGltcG9ydF9sb25nLmRlZmF1bHQuZnJvbUJ5dGVzTEUoYnl0ZXMuc2xpY2Uob2Zmc2V0ICsgMTYsIG9mZnNldCArIDI0KSwgdHJ1ZSkpOwogICAgICByZXR1cm4geyBsaW5lQ291bnQgfTsKICAgIH0KICAgIF9wYXJzZU5hbWVCeXRlcyhuYW1lc0J5dGVzKSB7CiAgICAgIGxldCBjdXJyUmVmSWQgPSAwOwogICAgICBsZXQgY3Vyck5hbWVTdGFydCA9IDA7CiAgICAgIGNvbnN0IHJlZklkVG9OYW1lID0gW107CiAgICAgIGNvbnN0IHJlZk5hbWVUb0lkID0ge307CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNCeXRlcy5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgIGlmICghbmFtZXNCeXRlc1tpXSkgewogICAgICAgICAgaWYgKGN1cnJOYW1lU3RhcnQgPCBpKSB7CiAgICAgICAgICAgIGxldCByZWZOYW1lID0gbmFtZXNCeXRlcy50b1N0cmluZygidXRmOCIsIGN1cnJOYW1lU3RhcnQsIGkpOwogICAgICAgICAgICByZWZOYW1lID0gdGhpcy5yZW5hbWVSZWZTZXEocmVmTmFtZSk7CiAgICAgICAgICAgIHJlZklkVG9OYW1lW2N1cnJSZWZJZF0gPSByZWZOYW1lOwogICAgICAgICAgICByZWZOYW1lVG9JZFtyZWZOYW1lXSA9IGN1cnJSZWZJZDsKICAgICAgICAgIH0KICAgICAgICAgIGN1cnJOYW1lU3RhcnQgPSBpICsgMTsKICAgICAgICAgIGN1cnJSZWZJZCArPSAxOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4geyByZWZOYW1lVG9JZCwgcmVmSWRUb05hbWUgfTsKICAgIH0KICAgIGFzeW5jIGJsb2Nrc0ZvclJhbmdlKHJlZk5hbWUsIG1pbiwgbWF4LCBvcHRzID0ge30pIHsKICAgICAgaWYgKG1pbiA8IDApIHsKICAgICAgICBtaW4gPSAwOwogICAgICB9CiAgICAgIGNvbnN0IGluZGV4RGF0YSA9IGF3YWl0IHRoaXMucGFyc2Uob3B0cyk7CiAgICAgIGlmICghaW5kZXhEYXRhKSB7CiAgICAgICAgcmV0dXJuIFtdOwogICAgICB9CiAgICAgIGNvbnN0IHJlZklkID0gaW5kZXhEYXRhLnJlZk5hbWVUb0lkW3JlZk5hbWVdOwogICAgICBjb25zdCBiYSA9IGluZGV4RGF0YS5pbmRpY2VzW3JlZklkXTsKICAgICAgaWYgKCFiYSkgewogICAgICAgIHJldHVybiBbXTsKICAgICAgfQogICAgICBjb25zdCBtaW5PZmZzZXQgPSBiYS5saW5lYXJJbmRleC5sZW5ndGggPyBiYS5saW5lYXJJbmRleFttaW4gPj4gVEFEX0xJRFhfU0hJRlQgPj0gYmEubGluZWFySW5kZXgubGVuZ3RoID8gYmEubGluZWFySW5kZXgubGVuZ3RoIC0gMSA6IG1pbiA+PiBUQURfTElEWF9TSElGVF0gOiBuZXcgVmlydHVhbE9mZnNldCgwLCAwKTsKICAgICAgaWYgKCFtaW5PZmZzZXQpIHsKICAgICAgICBjb25zb2xlLndhcm4oInF1ZXJ5aW5nIG91dHNpZGUgb2YgcG9zc2libGUgdGFiaXggcmFuZ2UiKTsKICAgICAgfQogICAgICBjb25zdCBvdmVybGFwcGluZ0JpbnMgPSByZWcyYmlucyhtaW4sIG1heCk7CiAgICAgIGNvbnN0IGNodW5rcyA9IFtdOwogICAgICBmb3IgKGNvbnN0IFtzdGFydCwgZW5kXSBvZiBvdmVybGFwcGluZ0JpbnMpIHsKICAgICAgICBmb3IgKGxldCBiaW4gPSBzdGFydDsgYmluIDw9IGVuZDsgYmluKyspIHsKICAgICAgICAgIGlmIChiYS5iaW5JbmRleFtiaW5dKSB7CiAgICAgICAgICAgIGNvbnN0IGJpbkNodW5rcyA9IGJhLmJpbkluZGV4W2Jpbl07CiAgICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgYmluQ2h1bmtzLmxlbmd0aDsgKytjKSB7CiAgICAgICAgICAgICAgY2h1bmtzLnB1c2gobmV3IENodW5rKGJpbkNodW5rc1tjXS5taW52LCBiaW5DaHVua3NbY10ubWF4diwgYmluKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgY29uc3QgbmludHYgPSBiYS5saW5lYXJJbmRleC5sZW5ndGg7CiAgICAgIGxldCBsb3dlc3QgPSBudWxsOwogICAgICBjb25zdCBtaW5MaW4gPSBNYXRoLm1pbihtaW4gPj4gMTQsIG5pbnR2IC0gMSk7CiAgICAgIGNvbnN0IG1heExpbiA9IE1hdGgubWluKG1heCA+PiAxNCwgbmludHYgLSAxKTsKICAgICAgZm9yIChsZXQgaSA9IG1pbkxpbjsgaSA8PSBtYXhMaW47ICsraSkgewogICAgICAgIGNvbnN0IHZwID0gYmEubGluZWFySW5kZXhbaV07CiAgICAgICAgaWYgKHZwKSB7CiAgICAgICAgICBpZiAoIWxvd2VzdCB8fCB2cC5jb21wYXJlVG8obG93ZXN0KSA8IDApIHsKICAgICAgICAgICAgbG93ZXN0ID0gdnA7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBvcHRpbWl6ZUNodW5rcyhjaHVua3MsIGxvd2VzdCk7CiAgICB9CiAgfTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS9jc2kuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGltcG9ydF9sb25nMiA9IF9fdG9Nb2R1bGUocmVxdWlyZV9sb25nKCkpOwogIHZhciBpbXBvcnRfYmd6Zl9maWxlaGFuZGxlMiA9IF9fdG9Nb2R1bGUocmVxdWlyZV9kaXN0MigpKTsKICB2YXIgQ1NJMV9NQUdJQyA9IDIxNTgyNjU5OwogIHZhciBDU0kyX01BR0lDID0gMzgzNTk4NzU7CiAgZnVuY3Rpb24gbHNoaWZ0KG51bSwgYml0cykgewogICAgcmV0dXJuIG51bSAqIDIgKiogYml0czsKICB9CiAgZnVuY3Rpb24gcnNoaWZ0KG51bSwgYml0cykgewogICAgcmV0dXJuIE1hdGguZmxvb3IobnVtIC8gMiAqKiBiaXRzKTsKICB9CiAgdmFyIENTSSA9IGNsYXNzIGV4dGVuZHMgSW5kZXhGaWxlIHsKICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHsKICAgICAgc3VwZXIoYXJncyk7CiAgICAgIHRoaXMubWF4QmluTnVtYmVyID0gMDsKICAgICAgdGhpcy5kZXB0aCA9IDA7CiAgICAgIHRoaXMubWluU2hpZnQgPSAwOwogICAgfQogICAgYXN5bmMgbGluZUNvdW50KHJlZk5hbWUsIG9wdHMgPSB7fSkgewogICAgICBjb25zdCBpbmRleERhdGEgPSBhd2FpdCB0aGlzLnBhcnNlKG9wdHMpOwogICAgICBpZiAoIWluZGV4RGF0YSkgewogICAgICAgIHJldHVybiAtMTsKICAgICAgfQogICAgICBjb25zdCByZWZJZCA9IGluZGV4RGF0YS5yZWZOYW1lVG9JZFtyZWZOYW1lXTsKICAgICAgY29uc3QgaWR4ID0gaW5kZXhEYXRhLmluZGljZXNbcmVmSWRdOwogICAgICBpZiAoIWlkeCkgewogICAgICAgIHJldHVybiAtMTsKICAgICAgfQogICAgICBjb25zdCB7IHN0YXRzIH0gPSBpbmRleERhdGEuaW5kaWNlc1tyZWZJZF07CiAgICAgIGlmIChzdGF0cykgewogICAgICAgIHJldHVybiBzdGF0cy5saW5lQ291bnQ7CiAgICAgIH0KICAgICAgcmV0dXJuIC0xOwogICAgfQogICAgYXN5bmMgaW5kZXhDb3YoKSB7CiAgICAgIHRocm93IG5ldyBFcnJvcigiQ1NJIGluZGV4ZXMgZG8gbm90IHN1cHBvcnQgaW5kZXhjb3YiKTsKICAgICAgcmV0dXJuIFtdOwogICAgfQogICAgcGFyc2VBdXhEYXRhKGJ5dGVzLCBvZmZzZXQsIGF1eExlbmd0aCkgewogICAgICBpZiAoYXV4TGVuZ3RoIDwgMzApIHsKICAgICAgICByZXR1cm4gewogICAgICAgICAgcmVmSWRUb05hbWU6IFtdLAogICAgICAgICAgcmVmTmFtZVRvSWQ6IHt9CiAgICAgICAgfTsKICAgICAgfQogICAgICBjb25zdCBmb3JtYXRGbGFncyA9IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCk7CiAgICAgIGNvbnN0IGNvb3JkaW5hdGVUeXBlID0gZm9ybWF0RmxhZ3MgJiA2NTUzNiA/ICJ6ZXJvLWJhc2VkLWhhbGYtb3BlbiIgOiAiMS1iYXNlZC1jbG9zZWQiOwogICAgICBjb25zdCBmb3JtYXQgPSB7IDA6ICJnZW5lcmljIiwgMTogIlNBTSIsIDI6ICJWQ0YiIH1bZm9ybWF0RmxhZ3MgJiAxNV07CiAgICAgIGlmICghZm9ybWF0KSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIFRhYml4IHByZXNldCBmb3JtYXQgZmxhZ3MgJHtmb3JtYXRGbGFnc31gKTsKICAgICAgfQogICAgICBjb25zdCBjb2x1bW5OdW1iZXJzID0gewogICAgICAgIHJlZjogYnl0ZXMucmVhZEludDMyTEUob2Zmc2V0ICsgNCksCiAgICAgICAgc3RhcnQ6IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDgpLAogICAgICAgIGVuZDogYnl0ZXMucmVhZEludDMyTEUob2Zmc2V0ICsgMTIpCiAgICAgIH07CiAgICAgIGNvbnN0IG1ldGFWYWx1ZSA9IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDE2KTsKICAgICAgY29uc3QgbWV0YUNoYXIgPSBtZXRhVmFsdWUgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKG1ldGFWYWx1ZSkgOiAiIjsKICAgICAgY29uc3Qgc2tpcExpbmVzID0gYnl0ZXMucmVhZEludDMyTEUob2Zmc2V0ICsgMjApOwogICAgICBjb25zdCBuYW1lU2VjdGlvbkxlbmd0aCA9IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDI0KTsKICAgICAgY29uc3QgeyByZWZJZFRvTmFtZSwgcmVmTmFtZVRvSWQgfSA9IHRoaXMuX3BhcnNlTmFtZUJ5dGVzKGJ5dGVzLnNsaWNlKG9mZnNldCArIDI4LCBvZmZzZXQgKyAyOCArIG5hbWVTZWN0aW9uTGVuZ3RoKSk7CiAgICAgIHJldHVybiB7CiAgICAgICAgcmVmSWRUb05hbWUsCiAgICAgICAgcmVmTmFtZVRvSWQsCiAgICAgICAgc2tpcExpbmVzLAogICAgICAgIG1ldGFDaGFyLAogICAgICAgIGNvbHVtbk51bWJlcnMsCiAgICAgICAgZm9ybWF0LAogICAgICAgIGNvb3JkaW5hdGVUeXBlCiAgICAgIH07CiAgICB9CiAgICBfcGFyc2VOYW1lQnl0ZXMobmFtZXNCeXRlcykgewogICAgICBsZXQgY3VyclJlZklkID0gMDsKICAgICAgbGV0IGN1cnJOYW1lU3RhcnQgPSAwOwogICAgICBjb25zdCByZWZJZFRvTmFtZSA9IFtdOwogICAgICBjb25zdCByZWZOYW1lVG9JZCA9IHt9OwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzQnl0ZXMubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICBpZiAoIW5hbWVzQnl0ZXNbaV0pIHsKICAgICAgICAgIGlmIChjdXJyTmFtZVN0YXJ0IDwgaSkgewogICAgICAgICAgICBsZXQgcmVmTmFtZSA9IG5hbWVzQnl0ZXMudG9TdHJpbmcoInV0ZjgiLCBjdXJyTmFtZVN0YXJ0LCBpKTsKICAgICAgICAgICAgcmVmTmFtZSA9IHRoaXMucmVuYW1lUmVmU2VxKHJlZk5hbWUpOwogICAgICAgICAgICByZWZJZFRvTmFtZVtjdXJyUmVmSWRdID0gcmVmTmFtZTsKICAgICAgICAgICAgcmVmTmFtZVRvSWRbcmVmTmFtZV0gPSBjdXJyUmVmSWQ7CiAgICAgICAgICB9CiAgICAgICAgICBjdXJyTmFtZVN0YXJ0ID0gaSArIDE7CiAgICAgICAgICBjdXJyUmVmSWQgKz0gMTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHsgcmVmTmFtZVRvSWQsIHJlZklkVG9OYW1lIH07CiAgICB9CiAgICBhc3luYyBfcGFyc2Uob3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgKDAsIGltcG9ydF9iZ3pmX2ZpbGVoYW5kbGUyLnVuemlwKShhd2FpdCB0aGlzLmZpbGVoYW5kbGUucmVhZEZpbGUob3B0cykpOwogICAgICBsZXQgY3NpVmVyc2lvbjsKICAgICAgaWYgKGJ5dGVzLnJlYWRVSW50MzJMRSgwKSA9PT0gQ1NJMV9NQUdJQykgewogICAgICAgIGNzaVZlcnNpb24gPSAxOwogICAgICB9IGVsc2UgaWYgKGJ5dGVzLnJlYWRVSW50MzJMRSgwKSA9PT0gQ1NJMl9NQUdJQykgewogICAgICAgIGNzaVZlcnNpb24gPSAyOwogICAgICB9IGVsc2UgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiTm90IGEgQ1NJIGZpbGUiKTsKICAgICAgfQogICAgICB0aGlzLm1pblNoaWZ0ID0gYnl0ZXMucmVhZEludDMyTEUoNCk7CiAgICAgIHRoaXMuZGVwdGggPSBieXRlcy5yZWFkSW50MzJMRSg4KTsKICAgICAgdGhpcy5tYXhCaW5OdW1iZXIgPSAoKDEgPDwgKHRoaXMuZGVwdGggKyAxKSAqIDMpIC0gMSkgLyA3OwogICAgICBjb25zdCBtYXhSZWZMZW5ndGggPSAyICoqICh0aGlzLm1pblNoaWZ0ICsgdGhpcy5kZXB0aCAqIDMpOwogICAgICBjb25zdCBhdXhMZW5ndGggPSBieXRlcy5yZWFkSW50MzJMRSgxMik7CiAgICAgIGxldCBhdXggPSB7CiAgICAgICAgcmVmSWRUb05hbWU6IFtdLAogICAgICAgIHJlZk5hbWVUb0lkOiB7fQogICAgICB9OwogICAgICBpZiAoYXV4TGVuZ3RoKSB7CiAgICAgICAgYXV4ID0gdGhpcy5wYXJzZUF1eERhdGEoYnl0ZXMsIDE2LCBhdXhMZW5ndGgpOwogICAgICB9CiAgICAgIGNvbnN0IHJlZkNvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoMTYgKyBhdXhMZW5ndGgpOwogICAgICBsZXQgZmlyc3REYXRhTGluZTsKICAgICAgbGV0IGN1cnJPZmZzZXQgPSAxNiArIGF1eExlbmd0aCArIDQ7CiAgICAgIGNvbnN0IGluZGljZXMgPSBuZXcgQXJyYXkocmVmQ291bnQpLmZpbGwoMCkubWFwKCgpID0+IHsKICAgICAgICBjb25zdCBiaW5Db3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKGN1cnJPZmZzZXQpOwogICAgICAgIGN1cnJPZmZzZXQgKz0gNDsKICAgICAgICBjb25zdCBiaW5JbmRleCA9IHt9OwogICAgICAgIGxldCBzdGF0czsKICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJpbkNvdW50OyBqICs9IDEpIHsKICAgICAgICAgIGNvbnN0IGJpbiA9IGJ5dGVzLnJlYWRVSW50MzJMRShjdXJyT2Zmc2V0KTsKICAgICAgICAgIGlmIChiaW4gPiB0aGlzLm1heEJpbk51bWJlcikgewogICAgICAgICAgICBzdGF0cyA9IHRoaXMucGFyc2VQc2V1ZG9CaW4oYnl0ZXMsIGN1cnJPZmZzZXQgKyA0KTsKICAgICAgICAgICAgY3Vyck9mZnNldCArPSA0ICsgOCArIDQgKyAxNiArIDE2OwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY29uc3QgbG9mZnNldCA9IGZyb21CeXRlcyhieXRlcywgY3Vyck9mZnNldCArIDQpOwogICAgICAgICAgICBmaXJzdERhdGFMaW5lID0gdGhpcy5fZmluZEZpcnN0RGF0YShmaXJzdERhdGFMaW5lLCBsb2Zmc2V0KTsKICAgICAgICAgICAgY29uc3QgY2h1bmtDb3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKGN1cnJPZmZzZXQgKyAxMik7CiAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gMTY7CiAgICAgICAgICAgIGNvbnN0IGNodW5rcyA9IG5ldyBBcnJheShjaHVua0NvdW50KTsKICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBjaHVua0NvdW50OyBrICs9IDEpIHsKICAgICAgICAgICAgICBjb25zdCB1ID0gZnJvbUJ5dGVzKGJ5dGVzLCBjdXJyT2Zmc2V0KTsKICAgICAgICAgICAgICBjb25zdCB2ID0gZnJvbUJ5dGVzKGJ5dGVzLCBjdXJyT2Zmc2V0ICsgOCk7CiAgICAgICAgICAgICAgY3Vyck9mZnNldCArPSAxNjsKICAgICAgICAgICAgICBjaHVua3Nba10gPSBuZXcgQ2h1bmsodSwgdiwgYmluKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBiaW5JbmRleFtiaW5dID0gY2h1bmtzOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4geyBiaW5JbmRleCwgc3RhdHMgfTsKICAgICAgfSk7CiAgICAgIHJldHVybiB7CiAgICAgICAgLi4uYXV4LAogICAgICAgIGNzaTogdHJ1ZSwKICAgICAgICByZWZDb3VudCwKICAgICAgICBtYXhCbG9ja1NpemU6IDEgPDwgMTYsCiAgICAgICAgZmlyc3REYXRhTGluZSwKICAgICAgICBjc2lWZXJzaW9uLAogICAgICAgIGluZGljZXMsCiAgICAgICAgZGVwdGg6IHRoaXMuZGVwdGgsCiAgICAgICAgbWF4QmluTnVtYmVyOiB0aGlzLm1heEJpbk51bWJlciwKICAgICAgICBtYXhSZWZMZW5ndGgKICAgICAgfTsKICAgIH0KICAgIHBhcnNlUHNldWRvQmluKGJ5dGVzLCBvZmZzZXQpIHsKICAgICAgY29uc3QgbGluZUNvdW50ID0gbG9uZ1RvTnVtYmVyKGltcG9ydF9sb25nMi5kZWZhdWx0LmZyb21CeXRlc0xFKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJ5dGVzLCBvZmZzZXQgKyAyOCwgb2Zmc2V0ICsgMzYpLCB0cnVlKSk7CiAgICAgIHJldHVybiB7IGxpbmVDb3VudCB9OwogICAgfQogICAgYXN5bmMgYmxvY2tzRm9yUmFuZ2UocmVmTmFtZSwgbWluLCBtYXgsIG9wdHMgPSB7fSkgewogICAgICBpZiAobWluIDwgMCkgewogICAgICAgIG1pbiA9IDA7CiAgICAgIH0KICAgICAgY29uc3QgaW5kZXhEYXRhID0gYXdhaXQgdGhpcy5wYXJzZShvcHRzKTsKICAgICAgaWYgKCFpbmRleERhdGEpIHsKICAgICAgICByZXR1cm4gW107CiAgICAgIH0KICAgICAgY29uc3QgcmVmSWQgPSBpbmRleERhdGEucmVmTmFtZVRvSWRbcmVmTmFtZV07CiAgICAgIGNvbnN0IGJhID0gaW5kZXhEYXRhLmluZGljZXNbcmVmSWRdOwogICAgICBpZiAoIWJhKSB7CiAgICAgICAgcmV0dXJuIFtdOwogICAgICB9CiAgICAgIGNvbnN0IG92ZXJsYXBwaW5nQmlucyA9IHRoaXMucmVnMmJpbnMobWluLCBtYXgpOwogICAgICBjb25zdCBjaHVua3MgPSBbXTsKICAgICAgZm9yIChjb25zdCBbc3RhcnQsIGVuZF0gb2Ygb3ZlcmxhcHBpbmdCaW5zKSB7CiAgICAgICAgZm9yIChsZXQgYmluID0gc3RhcnQ7IGJpbiA8PSBlbmQ7IGJpbisrKSB7CiAgICAgICAgICBpZiAoYmEuYmluSW5kZXhbYmluXSkgewogICAgICAgICAgICBjb25zdCBiaW5DaHVua3MgPSBiYS5iaW5JbmRleFtiaW5dOwogICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGJpbkNodW5rcy5sZW5ndGg7ICsrYykgewogICAgICAgICAgICAgIGNodW5rcy5wdXNoKG5ldyBDaHVuayhiaW5DaHVua3NbY10ubWludiwgYmluQ2h1bmtzW2NdLm1heHYsIGJpbikpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBvcHRpbWl6ZUNodW5rcyhjaHVua3MsIG5ldyBWaXJ0dWFsT2Zmc2V0KDAsIDApKTsKICAgIH0KICAgIHJlZzJiaW5zKGJlZywgZW5kKSB7CiAgICAgIGJlZyAtPSAxOwogICAgICBpZiAoYmVnIDwgMSkgewogICAgICAgIGJlZyA9IDE7CiAgICAgIH0KICAgICAgaWYgKGVuZCA+IDIgKiogNTApIHsKICAgICAgICBlbmQgPSAyICoqIDM0OwogICAgICB9CiAgICAgIGVuZCAtPSAxOwogICAgICBsZXQgbCA9IDA7CiAgICAgIGxldCB0ID0gMDsKICAgICAgbGV0IHMgPSB0aGlzLm1pblNoaWZ0ICsgdGhpcy5kZXB0aCAqIDM7CiAgICAgIGNvbnN0IGJpbnMgPSBbXTsKICAgICAgZm9yICg7IGwgPD0gdGhpcy5kZXB0aDsgcyAtPSAzLCB0ICs9IGxzaGlmdCgxLCBsICogMyksIGwgKz0gMSkgewogICAgICAgIGNvbnN0IGIgPSB0ICsgcnNoaWZ0KGJlZywgcyk7CiAgICAgICAgY29uc3QgZSA9IHQgKyByc2hpZnQoZW5kLCBzKTsKICAgICAgICBpZiAoZSAtIGIgKyBiaW5zLmxlbmd0aCA+IHRoaXMubWF4QmluTnVtYmVyKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHF1ZXJ5ICR7YmVnfS0ke2VuZH0gaXMgdG9vIGxhcmdlIGZvciBjdXJyZW50IGJpbm5pbmcgc2NoZW1lIChzaGlmdCAke3RoaXMubWluU2hpZnR9LCBkZXB0aCAke3RoaXMuZGVwdGh9KSwgdHJ5IGEgc21hbGxlciBxdWVyeSBvciBhIGNvYXJzZXIgaW5kZXggYmlubmluZyBzY2hlbWVgKTsKICAgICAgICB9CiAgICAgICAgYmlucy5wdXNoKFtiLCBlXSk7CiAgICAgIH0KICAgICAgcmV0dXJuIGJpbnM7CiAgICB9CiAgfTsKCiAgLy8gbm9kZV9tb2R1bGVzL0BnbW9kL3RhYml4L2VzbS90YWJpeEluZGV4ZWRGaWxlLmpzCiAgZnVuY3Rpb24gdGltZW91dCh0aW1lKSB7CiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsKICAgICAgc2V0VGltZW91dChyZXNvbHZlLCB0aW1lKTsKICAgIH0pOwogIH0KICB2YXIgVGFiaXhJbmRleGVkRmlsZSA9IGNsYXNzIHsKICAgIGNvbnN0cnVjdG9yKHsgcGF0aCwgZmlsZWhhbmRsZSwgdGJpUGF0aCwgdGJpRmlsZWhhbmRsZSwgY3NpUGF0aCwgY3NpRmlsZWhhbmRsZSwgY2h1bmtTaXplTGltaXQgPSA1ZTcsIHJlbmFtZVJlZlNlcXMgPSAobikgPT4gbiwgY2h1bmtDYWNoZVNpemUgPSA1ICogMiAqKiAyMCB9KSB7CiAgICAgIGlmIChmaWxlaGFuZGxlKSB7CiAgICAgICAgdGhpcy5maWxlaGFuZGxlID0gZmlsZWhhbmRsZTsKICAgICAgfSBlbHNlIGlmIChwYXRoKSB7CiAgICAgICAgdGhpcy5maWxlaGFuZGxlID0gbmV3IGltcG9ydF9nZW5lcmljX2ZpbGVoYW5kbGUuTG9jYWxGaWxlKHBhdGgpOwogICAgICB9IGVsc2UgewogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIm11c3QgcHJvdmlkZSBlaXRoZXIgZmlsZWhhbmRsZSBvciBwYXRoIik7CiAgICAgIH0KICAgICAgaWYgKHRiaUZpbGVoYW5kbGUpIHsKICAgICAgICB0aGlzLmluZGV4ID0gbmV3IFRhYml4SW5kZXgoewogICAgICAgICAgZmlsZWhhbmRsZTogdGJpRmlsZWhhbmRsZSwKICAgICAgICAgIHJlbmFtZVJlZlNlcXMKICAgICAgICB9KTsKICAgICAgfSBlbHNlIGlmIChjc2lGaWxlaGFuZGxlKSB7CiAgICAgICAgdGhpcy5pbmRleCA9IG5ldyBDU0koewogICAgICAgICAgZmlsZWhhbmRsZTogY3NpRmlsZWhhbmRsZSwKICAgICAgICAgIHJlbmFtZVJlZlNlcXMKICAgICAgICB9KTsKICAgICAgfSBlbHNlIGlmICh0YmlQYXRoKSB7CiAgICAgICAgdGhpcy5pbmRleCA9IG5ldyBUYWJpeEluZGV4KHsKICAgICAgICAgIGZpbGVoYW5kbGU6IG5ldyBpbXBvcnRfZ2VuZXJpY19maWxlaGFuZGxlLkxvY2FsRmlsZSh0YmlQYXRoKSwKICAgICAgICAgIHJlbmFtZVJlZlNlcXMKICAgICAgICB9KTsKICAgICAgfSBlbHNlIGlmIChjc2lQYXRoKSB7CiAgICAgICAgdGhpcy5pbmRleCA9IG5ldyBDU0koewogICAgICAgICAgZmlsZWhhbmRsZTogbmV3IGltcG9ydF9nZW5lcmljX2ZpbGVoYW5kbGUuTG9jYWxGaWxlKGNzaVBhdGgpLAogICAgICAgICAgcmVuYW1lUmVmU2VxcwogICAgICAgIH0pOwogICAgICB9IGVsc2UgaWYgKHBhdGgpIHsKICAgICAgICB0aGlzLmluZGV4ID0gbmV3IFRhYml4SW5kZXgoewogICAgICAgICAgZmlsZWhhbmRsZTogbmV3IGltcG9ydF9nZW5lcmljX2ZpbGVoYW5kbGUuTG9jYWxGaWxlKGAke3BhdGh9LnRiaWApLAogICAgICAgICAgcmVuYW1lUmVmU2VxcwogICAgICAgIH0pOwogICAgICB9IGVsc2UgewogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIm11c3QgcHJvdmlkZSBvbmUgb2YgdGJpRmlsZWhhbmRsZSwgdGJpUGF0aCwgY3NpRmlsZWhhbmRsZSwgb3IgY3NpUGF0aCIpOwogICAgICB9CiAgICAgIHRoaXMuY2h1bmtTaXplTGltaXQgPSBjaHVua1NpemVMaW1pdDsKICAgICAgdGhpcy5yZW5hbWVSZWZTZXEgPSByZW5hbWVSZWZTZXFzOwogICAgICB0aGlzLmNodW5rQ2FjaGUgPSBuZXcgaW1wb3J0X2Fib3J0YWJsZV9wcm9taXNlX2NhY2hlMi5kZWZhdWx0KHsKICAgICAgICBjYWNoZTogbmV3IGltcG9ydF9xdWlja19scnUyLmRlZmF1bHQoewogICAgICAgICAgbWF4U2l6ZTogTWF0aC5mbG9vcihjaHVua0NhY2hlU2l6ZSAvICgxIDw8IDE2KSkKICAgICAgICB9KSwKICAgICAgICBmaWxsOiB0aGlzLnJlYWRDaHVuay5iaW5kKHRoaXMpCiAgICAgIH0pOwogICAgfQogICAgYXN5bmMgZ2V0TGluZXMocmVmTmFtZSwgc3RhcnQsIGVuZCwgb3B0cykgewogICAgICBsZXQgc2lnbmFsOwogICAgICBsZXQgb3B0aW9ucyA9IHt9OwogICAgICBsZXQgY2FsbGJhY2s7CiAgICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gInVuZGVmaW5lZCIpIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJsaW5lIGNhbGxiYWNrIG11c3QgYmUgcHJvdmlkZWQiKTsKICAgICAgfQogICAgICBpZiAodHlwZW9mIG9wdHMgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICBjYWxsYmFjayA9IG9wdHM7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgb3B0aW9ucyA9IG9wdHM7CiAgICAgICAgY2FsbGJhY2sgPSBvcHRzLmxpbmVDYWxsYmFjazsKICAgICAgfQogICAgICBpZiAocmVmTmFtZSA9PT0gdm9pZCAwKSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigibXVzdCBwcm92aWRlIGEgcmVmZXJlbmNlIHNlcXVlbmNlIG5hbWUiKTsKICAgICAgfQogICAgICBpZiAoIWNhbGxiYWNrKSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigibGluZSBjYWxsYmFjayBtdXN0IGJlIHByb3ZpZGVkIik7CiAgICAgIH0KICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCB0aGlzLmluZGV4LmdldE1ldGFkYXRhKG9wdGlvbnMpOwogICAgICBjaGVja0Fib3J0U2lnbmFsKHNpZ25hbCk7CiAgICAgIGlmICghc3RhcnQpIHsKICAgICAgICBzdGFydCA9IDA7CiAgICAgIH0KICAgICAgaWYgKCFlbmQpIHsKICAgICAgICBlbmQgPSBtZXRhZGF0YS5tYXhSZWZMZW5ndGg7CiAgICAgIH0KICAgICAgaWYgKCEoc3RhcnQgPD0gZW5kKSkgewogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoImludmFsaWQgc3RhcnQgYW5kIGVuZCBjb29yZGluYXRlcy4gc3RhcnQgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gZW5kIik7CiAgICAgIH0KICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgY29uc3QgY2h1bmtzID0gYXdhaXQgdGhpcy5pbmRleC5ibG9ja3NGb3JSYW5nZShyZWZOYW1lLCBzdGFydCwgZW5kLCBvcHRpb25zKTsKICAgICAgY2hlY2tBYm9ydFNpZ25hbChzaWduYWwpOwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgIGNvbnN0IHNpemUgPSBjaHVua3NbaV0uZmV0Y2hlZFNpemUoKTsKICAgICAgICBpZiAoc2l6ZSA+IHRoaXMuY2h1bmtTaXplTGltaXQpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9vIG11Y2ggZGF0YS4gQ2h1bmsgc2l6ZSAke3NpemUudG9Mb2NhbGVTdHJpbmcoKX0gYnl0ZXMgZXhjZWVkcyBjaHVua1NpemVMaW1pdCBvZiAke3RoaXMuY2h1bmtTaXplTGltaXQudG9Mb2NhbGVTdHJpbmcoKX0uYCk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGxldCBsYXN0ID0gRGF0ZS5ub3coKTsKICAgICAgZm9yIChsZXQgY2h1bmtOdW0gPSAwOyBjaHVua051bSA8IGNodW5rcy5sZW5ndGg7IGNodW5rTnVtICs9IDEpIHsKICAgICAgICBsZXQgcHJldmlvdXNTdGFydENvb3JkaW5hdGU7CiAgICAgICAgY29uc3QgYyA9IGNodW5rc1tjaHVua051bV07CiAgICAgICAgY29uc3QgeyBidWZmZXIsIGNwb3NpdGlvbnMsIGRwb3NpdGlvbnMgfSA9IGF3YWl0IHRoaXMuY2h1bmtDYWNoZS5nZXQoYy50b1N0cmluZygpLCBjLCBzaWduYWwpOwogICAgICAgIGNvbnN0IGxpbmVzID0gKHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gInVuZGVmaW5lZCIgPyBuZXcgVGV4dERlY29kZXIoInV0Zi04IikuZGVjb2RlKGJ1ZmZlcikgOiBidWZmZXIudG9TdHJpbmcoKSkuc3BsaXQoIlxuIik7CiAgICAgICAgbGluZXMucG9wKCk7CiAgICAgICAgY2hlY2tBYm9ydFNpZ25hbChzaWduYWwpOwogICAgICAgIGxldCBibG9ja1N0YXJ0ID0gYy5taW52LmRhdGFQb3NpdGlvbjsKICAgICAgICBsZXQgcG9zOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTsKICAgICAgICAgIGZvciAocG9zID0gMDsgYmxvY2tTdGFydCA+PSBkcG9zaXRpb25zW3Bvc107IHBvcyArPSAxKSB7CiAgICAgICAgICB9CiAgICAgICAgICBjb25zdCB7IHN0YXJ0Q29vcmRpbmF0ZSwgb3ZlcmxhcHMgfSA9IHRoaXMuY2hlY2tMaW5lKG1ldGFkYXRhLCByZWZOYW1lLCBzdGFydCwgZW5kLCBsaW5lKTsKICAgICAgICAgIGlmIChwcmV2aW91c1N0YXJ0Q29vcmRpbmF0ZSAhPT0gdm9pZCAwICYmIHN0YXJ0Q29vcmRpbmF0ZSAhPT0gdm9pZCAwICYmIHByZXZpb3VzU3RhcnRDb29yZGluYXRlID4gc3RhcnRDb29yZGluYXRlKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGluZXMgbm90IHNvcnRlZCBieSBzdGFydCBjb29yZGluYXRlICgke3ByZXZpb3VzU3RhcnRDb29yZGluYXRlfSA+ICR7c3RhcnRDb29yZGluYXRlfSksIHRoaXMgZmlsZSBpcyBub3QgdXNhYmxlIHdpdGggVGFiaXguYCk7CiAgICAgICAgICB9CiAgICAgICAgICBwcmV2aW91c1N0YXJ0Q29vcmRpbmF0ZSA9IHN0YXJ0Q29vcmRpbmF0ZTsKICAgICAgICAgIGlmIChvdmVybGFwcykgewogICAgICAgICAgICBjYWxsYmFjayhsaW5lLnRyaW0oKSwgY3Bvc2l0aW9uc1twb3NdICogKDEgPDwgOCkgKyAoYmxvY2tTdGFydCAtIGRwb3NpdGlvbnNbcG9zXSkpOwogICAgICAgICAgfSBlbHNlIGlmIChzdGFydENvb3JkaW5hdGUgIT09IHZvaWQgMCAmJiBzdGFydENvb3JkaW5hdGUgPj0gZW5kKSB7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KICAgICAgICAgIGJsb2NrU3RhcnQgKz0gbGluZS5sZW5ndGggKyAxOwogICAgICAgICAgaWYgKGxhc3QgLSBEYXRlLm5vdygpID4gNTAwKSB7CiAgICAgICAgICAgIGxhc3QgPSBEYXRlLm5vdygpOwogICAgICAgICAgICBjaGVja0Fib3J0U2lnbmFsKHNpZ25hbCk7CiAgICAgICAgICAgIGF3YWl0IHRpbWVvdXQoMSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBhc3luYyBnZXRNZXRhZGF0YShvcHRzID0ge30pIHsKICAgICAgcmV0dXJuIHRoaXMuaW5kZXguZ2V0TWV0YWRhdGEob3B0cyk7CiAgICB9CiAgICBhc3luYyBnZXRIZWFkZXJCdWZmZXIob3B0cyA9IHt9KSB7CiAgICAgIGNvbnN0IHsgZmlyc3REYXRhTGluZSwgbWV0YUNoYXIsIG1heEJsb2NrU2l6ZSB9ID0gYXdhaXQgdGhpcy5nZXRNZXRhZGF0YShvcHRzKTsKICAgICAgY2hlY2tBYm9ydFNpZ25hbChvcHRzLnNpZ25hbCk7CiAgICAgIGNvbnN0IG1heEZldGNoID0gZmlyc3REYXRhTGluZSAmJiBmaXJzdERhdGFMaW5lLmJsb2NrUG9zaXRpb24gPyBmaXJzdERhdGFMaW5lLmJsb2NrUG9zaXRpb24gKyBtYXhCbG9ja1NpemUgOiBtYXhCbG9ja1NpemU7CiAgICAgIGxldCBieXRlcyA9IGF3YWl0IHRoaXMuX3JlYWRSZWdpb24oMCwgbWF4RmV0Y2gsIG9wdHMpOwogICAgICBjaGVja0Fib3J0U2lnbmFsKG9wdHMuc2lnbmFsKTsKICAgICAgdHJ5IHsKICAgICAgICBieXRlcyA9IGF3YWl0ICgwLCBpbXBvcnRfYmd6Zl9maWxlaGFuZGxlMy51bnppcCkoYnl0ZXMpOwogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgY29uc29sZS5lcnJvcihlKTsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGVycm9yIGRlY29tcHJlc3NpbmcgYmxvY2sgJHtlLmNvZGV9IGF0IDAgKGxlbmd0aCAke21heEZldGNofSkgJHtlfWApOwogICAgICB9CiAgICAgIGlmIChtZXRhQ2hhcikgewogICAgICAgIGxldCBsYXN0TmV3bGluZSA9IC0xOwogICAgICAgIGNvbnN0IG5ld2xpbmVCeXRlID0gIlxuIi5jaGFyQ29kZUF0KDApOwogICAgICAgIGNvbnN0IG1ldGFCeXRlID0gbWV0YUNoYXIuY2hhckNvZGVBdCgwKTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgICBpZiAoaSA9PT0gbGFzdE5ld2xpbmUgKyAxICYmIGJ5dGVzW2ldICE9PSBtZXRhQnl0ZSkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChieXRlc1tpXSA9PT0gbmV3bGluZUJ5dGUpIHsKICAgICAgICAgICAgbGFzdE5ld2xpbmUgPSBpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBieXRlcyA9IGJ5dGVzLnNsaWNlKDAsIGxhc3ROZXdsaW5lICsgMSk7CiAgICAgIH0KICAgICAgcmV0dXJuIGJ5dGVzOwogICAgfQogICAgYXN5bmMgZ2V0SGVhZGVyKG9wdHMgPSB7fSkgewogICAgICBjb25zdCBieXRlcyA9IGF3YWl0IHRoaXMuZ2V0SGVhZGVyQnVmZmVyKG9wdHMpOwogICAgICBjaGVja0Fib3J0U2lnbmFsKG9wdHMuc2lnbmFsKTsKICAgICAgcmV0dXJuIGJ5dGVzLnRvU3RyaW5nKCJ1dGY4Iik7CiAgICB9CiAgICBhc3luYyBnZXRSZWZlcmVuY2VTZXF1ZW5jZU5hbWVzKG9wdHMgPSB7fSkgewogICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMuZ2V0TWV0YWRhdGEob3B0cyk7CiAgICAgIHJldHVybiBtZXRhZGF0YS5yZWZJZFRvTmFtZTsKICAgIH0KICAgIGNoZWNrTGluZSh7IGNvbHVtbk51bWJlcnMsIG1ldGFDaGFyLCBjb29yZGluYXRlVHlwZSwgZm9ybWF0IH0sIHJlZ2lvblJlZk5hbWUsIHJlZ2lvblN0YXJ0LCByZWdpb25FbmQsIGxpbmUpIHsKICAgICAgaWYgKGxpbmUuY2hhckF0KDApID09PSBtZXRhQ2hhcikgewogICAgICAgIHJldHVybiB7IG92ZXJsYXBzOiBmYWxzZSB9OwogICAgICB9CiAgICAgIGxldCB7IHJlZiwgc3RhcnQsIGVuZCB9ID0gY29sdW1uTnVtYmVyczsKICAgICAgaWYgKCFyZWYpIHsKICAgICAgICByZWYgPSAwOwogICAgICB9CiAgICAgIGlmICghc3RhcnQpIHsKICAgICAgICBzdGFydCA9IDA7CiAgICAgIH0KICAgICAgaWYgKCFlbmQpIHsKICAgICAgICBlbmQgPSAwOwogICAgICB9CiAgICAgIGlmIChmb3JtYXQgPT09ICJWQ0YiKSB7CiAgICAgICAgZW5kID0gODsKICAgICAgfQogICAgICBjb25zdCBtYXhDb2x1bW4gPSBNYXRoLm1heChyZWYsIHN0YXJ0LCBlbmQpOwogICAgICBsZXQgY3VycmVudENvbHVtbk51bWJlciA9IDE7CiAgICAgIGxldCBjdXJyZW50Q29sdW1uU3RhcnQgPSAwOwogICAgICBsZXQgcmVmU2VxID0gIiI7CiAgICAgIGxldCBzdGFydENvb3JkaW5hdGUgPSAtSW5maW5pdHk7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZS5sZW5ndGggKyAxOyBpICs9IDEpIHsKICAgICAgICBpZiAobGluZVtpXSA9PT0gIgkiIHx8IGkgPT09IGxpbmUubGVuZ3RoKSB7CiAgICAgICAgICBpZiAoY3VycmVudENvbHVtbk51bWJlciA9PT0gcmVmKSB7CiAgICAgICAgICAgIGlmICh0aGlzLnJlbmFtZVJlZlNlcShsaW5lLnNsaWNlKGN1cnJlbnRDb2x1bW5TdGFydCwgaSkpICE9PSByZWdpb25SZWZOYW1lKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHsgb3ZlcmxhcHM6IGZhbHNlIH07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudENvbHVtbk51bWJlciA9PT0gc3RhcnQpIHsKICAgICAgICAgICAgc3RhcnRDb29yZGluYXRlID0gcGFyc2VJbnQobGluZS5zbGljZShjdXJyZW50Q29sdW1uU3RhcnQsIGkpLCAxMCk7CiAgICAgICAgICAgIGlmIChjb29yZGluYXRlVHlwZSA9PT0gIjEtYmFzZWQtY2xvc2VkIikgewogICAgICAgICAgICAgIHN0YXJ0Q29vcmRpbmF0ZSAtPSAxOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzdGFydENvb3JkaW5hdGUgPj0gcmVnaW9uRW5kKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnRDb29yZGluYXRlLCBvdmVybGFwczogZmFsc2UgfTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoZW5kID09PSAwIHx8IGVuZCA9PT0gc3RhcnQpIHsKICAgICAgICAgICAgICBpZiAoc3RhcnRDb29yZGluYXRlICsgMSA8PSByZWdpb25TdGFydCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnRDb29yZGluYXRlLCBvdmVybGFwczogZmFsc2UgfTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAiVkNGIiAmJiBjdXJyZW50Q29sdW1uTnVtYmVyID09PSA0KSB7CiAgICAgICAgICAgIHJlZlNlcSA9IGxpbmUuc2xpY2UoY3VycmVudENvbHVtblN0YXJ0LCBpKTsKICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudENvbHVtbk51bWJlciA9PT0gZW5kKSB7CiAgICAgICAgICAgIGxldCBlbmRDb29yZGluYXRlOwogICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAiVkNGIikgewogICAgICAgICAgICAgIGVuZENvb3JkaW5hdGUgPSB0aGlzLl9nZXRWY2ZFbmQoc3RhcnRDb29yZGluYXRlLCByZWZTZXEsIGxpbmUuc2xpY2UoY3VycmVudENvbHVtblN0YXJ0LCBpKSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgZW5kQ29vcmRpbmF0ZSA9IHBhcnNlSW50KGxpbmUuc2xpY2UoY3VycmVudENvbHVtblN0YXJ0LCBpKSwgMTApOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChlbmRDb29yZGluYXRlIDw9IHJlZ2lvblN0YXJ0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIHsgb3ZlcmxhcHM6IGZhbHNlIH07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGN1cnJlbnRDb2x1bW5TdGFydCA9IGkgKyAxOwogICAgICAgICAgY3VycmVudENvbHVtbk51bWJlciArPSAxOwogICAgICAgICAgaWYgKGN1cnJlbnRDb2x1bW5OdW1iZXIgPiBtYXhDb2x1bW4pIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiB7IHN0YXJ0Q29vcmRpbmF0ZSwgb3ZlcmxhcHM6IHRydWUgfTsKICAgIH0KICAgIF9nZXRWY2ZFbmQoc3RhcnRDb29yZGluYXRlLCByZWZTZXEsIGluZm8pIHsKICAgICAgbGV0IGVuZENvb3JkaW5hdGUgPSBzdGFydENvb3JkaW5hdGUgKyByZWZTZXEubGVuZ3RoOwogICAgICBjb25zdCBpc1RSQSA9IGluZm8uaW5kZXhPZigiU1ZUWVBFPVRSQSIpICE9PSAtMTsKICAgICAgaWYgKGluZm9bMF0gIT09ICIuIiAmJiAhaXNUUkEpIHsKICAgICAgICBsZXQgcHJldkNoYXIgPSAiOyI7CiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbmZvLmxlbmd0aDsgaiArPSAxKSB7CiAgICAgICAgICBpZiAocHJldkNoYXIgPT09ICI7IiAmJiBpbmZvLnNsaWNlKGosIGogKyA0KSA9PT0gIkVORD0iKSB7CiAgICAgICAgICAgIGxldCB2YWx1ZUVuZCA9IGluZm8uaW5kZXhPZigiOyIsIGopOwogICAgICAgICAgICBpZiAodmFsdWVFbmQgPT09IC0xKSB7CiAgICAgICAgICAgICAgdmFsdWVFbmQgPSBpbmZvLmxlbmd0aDsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbmRDb29yZGluYXRlID0gcGFyc2VJbnQoaW5mby5zbGljZShqICsgNCwgdmFsdWVFbmQpLCAxMCk7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgcHJldkNoYXIgPSBpbmZvW2pdOwogICAgICAgIH0KICAgICAgfSBlbHNlIGlmIChpc1RSQSkgewogICAgICAgIHJldHVybiBzdGFydENvb3JkaW5hdGUgKyAxOwogICAgICB9CiAgICAgIHJldHVybiBlbmRDb29yZGluYXRlOwogICAgfQogICAgYXN5bmMgbGluZUNvdW50KHJlZk5hbWUsIG9wdHMgPSB7fSkgewogICAgICByZXR1cm4gdGhpcy5pbmRleC5saW5lQ291bnQocmVmTmFtZSwgb3B0cyk7CiAgICB9CiAgICBhc3luYyBfcmVhZFJlZ2lvbihwb3NpdGlvbiwgY29tcHJlc3NlZFNpemUsIG9wdHMgPSB7fSkgewogICAgICBjb25zdCB7IGJ5dGVzUmVhZCwgYnVmZmVyIH0gPSBhd2FpdCB0aGlzLmZpbGVoYW5kbGUucmVhZChpbXBvcnRfYnVmZmVyLkJ1ZmZlci5hbGxvYyhjb21wcmVzc2VkU2l6ZSksIDAsIGNvbXByZXNzZWRTaXplLCBwb3NpdGlvbiwgb3B0cyk7CiAgICAgIHJldHVybiBieXRlc1JlYWQgPCBjb21wcmVzc2VkU2l6ZSA/IGJ1ZmZlci5zbGljZSgwLCBieXRlc1JlYWQpIDogYnVmZmVyOwogICAgfQogICAgYXN5bmMgcmVhZENodW5rKGNodW5rLCBvcHRzID0ge30pIHsKICAgICAgY29uc3QgY29tcHJlc3NlZERhdGEgPSBhd2FpdCB0aGlzLl9yZWFkUmVnaW9uKGNodW5rLm1pbnYuYmxvY2tQb3NpdGlvbiwgY2h1bmsuZmV0Y2hlZFNpemUoKSwgb3B0cyk7CiAgICAgIHRyeSB7CiAgICAgICAgcmV0dXJuICgwLCBpbXBvcnRfYmd6Zl9maWxlaGFuZGxlMy51bnppcENodW5rU2xpY2UpKGNvbXByZXNzZWREYXRhLCBjaHVuayk7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGVycm9yIGRlY29tcHJlc3NpbmcgY2h1bmsgJHtjaHVuay50b1N0cmluZygpfSAke2V9YCk7CiAgICAgIH0KICAgIH0KICB9OwoKICAvLyBub2RlX21vZHVsZXMvdGhyZWFkcy93b3JrZXIubWpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBpbXBvcnRfd29ya2VyID0gX190b01vZHVsZShyZXF1aXJlX3dvcmtlcigpKTsKICB2YXIgZXhwb3NlID0gaW1wb3J0X3dvcmtlci5kZWZhdWx0LmV4cG9zZTsKICB2YXIgcmVnaXN0ZXJTZXJpYWxpemVyID0gaW1wb3J0X3dvcmtlci5kZWZhdWx0LnJlZ2lzdGVyU2VyaWFsaXplcjsKICB2YXIgVHJhbnNmZXIgPSBpbXBvcnRfd29ya2VyLmRlZmF1bHQuVHJhbnNmZXI7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbG9kYXNoLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzU3ltYm9sLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TeW1ib2wuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Jvb3QuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICJvYmplY3QiICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsOwogIHZhciBmcmVlR2xvYmFsX2RlZmF1bHQgPSBmcmVlR2xvYmFsOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzCiAgdmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gIm9iamVjdCIgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7CiAgdmFyIHJvb3QgPSBmcmVlR2xvYmFsX2RlZmF1bHQgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oInJldHVybiB0aGlzIikoKTsKICB2YXIgcm9vdF9kZWZhdWx0ID0gcm9vdDsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzCiAgdmFyIFN5bWJvbDIgPSByb290X2RlZmF1bHQuU3ltYm9sOwogIHZhciBTeW1ib2xfZGVmYXVsdCA9IFN5bWJvbDI7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFJhd1RhZy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlOwogIHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5OwogIHZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nOwogIHZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbF9kZWZhdWx0ID8gU3ltYm9sX2RlZmF1bHQudG9TdHJpbmdUYWcgOiB2b2lkIDA7CiAgZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7CiAgICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTsKICAgIHRyeSB7CiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHZvaWQgMDsKICAgICAgdmFyIHVubWFza2VkID0gdHJ1ZTsKICAgIH0gY2F0Y2ggKGUpIHsKICAgIH0KICAgIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTsKICAgIGlmICh1bm1hc2tlZCkgewogICAgICBpZiAoaXNPd24pIHsKICAgICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9CiAgdmFyIGdldFJhd1RhZ19kZWZhdWx0ID0gZ2V0UmF3VGFnOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vYmplY3RUb1N0cmluZy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgb2JqZWN0UHJvdG8yID0gT2JqZWN0LnByb3RvdHlwZTsKICB2YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcyID0gb2JqZWN0UHJvdG8yLnRvU3RyaW5nOwogIGZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7CiAgICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcyLmNhbGwodmFsdWUpOwogIH0KICB2YXIgb2JqZWN0VG9TdHJpbmdfZGVmYXVsdCA9IG9iamVjdFRvU3RyaW5nOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzCiAgdmFyIG51bGxUYWcgPSAiW29iamVjdCBOdWxsXSI7CiAgdmFyIHVuZGVmaW5lZFRhZyA9ICJbb2JqZWN0IFVuZGVmaW5lZF0iOwogIHZhciBzeW1Ub1N0cmluZ1RhZzIgPSBTeW1ib2xfZGVmYXVsdCA/IFN5bWJvbF9kZWZhdWx0LnRvU3RyaW5nVGFnIDogdm9pZCAwOwogIGZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHsKICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7CiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZzsKICAgIH0KICAgIHJldHVybiBzeW1Ub1N0cmluZ1RhZzIgJiYgc3ltVG9TdHJpbmdUYWcyIGluIE9iamVjdCh2YWx1ZSkgPyBnZXRSYXdUYWdfZGVmYXVsdCh2YWx1ZSkgOiBvYmplY3RUb1N0cmluZ19kZWZhdWx0KHZhbHVlKTsKICB9CiAgdmFyIGJhc2VHZXRUYWdfZGVmYXVsdCA9IGJhc2VHZXRUYWc7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3RMaWtlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkgewogICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICJvYmplY3QiOwogIH0KICB2YXIgaXNPYmplY3RMaWtlX2RlZmF1bHQgPSBpc09iamVjdExpa2U7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNTeW1ib2wuanMKICB2YXIgc3ltYm9sVGFnID0gIltvYmplY3QgU3ltYm9sXSI7CiAgZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHsKICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gInN5bWJvbCIgfHwgaXNPYmplY3RMaWtlX2RlZmF1bHQodmFsdWUpICYmIGJhc2VHZXRUYWdfZGVmYXVsdCh2YWx1ZSkgPT0gc3ltYm9sVGFnOwogIH0KICB2YXIgaXNTeW1ib2xfZGVmYXVsdCA9IGlzU3ltYm9sOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheU1hcC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHsKICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCwgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTsKICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7CiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH0KICB2YXIgYXJyYXlNYXBfZGVmYXVsdCA9IGFycmF5TWFwOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXkuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5OwogIHZhciBpc0FycmF5X2RlZmF1bHQgPSBpc0FycmF5OwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RvSW50ZWdlci5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b0Zpbml0ZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b051bWJlci5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRyaW0uanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3RyaW1tZWRFbmRJbmRleC5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgcmVXaGl0ZXNwYWNlID0gL1xzLzsKICBmdW5jdGlvbiB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSB7CiAgICB2YXIgaW5kZXggPSBzdHJpbmcubGVuZ3RoOwogICAgd2hpbGUgKGluZGV4LS0gJiYgcmVXaGl0ZXNwYWNlLnRlc3Qoc3RyaW5nLmNoYXJBdChpbmRleCkpKSB7CiAgICB9CiAgICByZXR1cm4gaW5kZXg7CiAgfQogIHZhciB0cmltbWVkRW5kSW5kZXhfZGVmYXVsdCA9IHRyaW1tZWRFbmRJbmRleDsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRyaW0uanMKICB2YXIgcmVUcmltU3RhcnQgPSAvXlxzKy87CiAgZnVuY3Rpb24gYmFzZVRyaW0oc3RyaW5nKSB7CiAgICByZXR1cm4gc3RyaW5nID8gc3RyaW5nLnNsaWNlKDAsIHRyaW1tZWRFbmRJbmRleF9kZWZhdWx0KHN0cmluZykgKyAxKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAiIikgOiBzdHJpbmc7CiAgfQogIHZhciBiYXNlVHJpbV9kZWZhdWx0ID0gYmFzZVRyaW07CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3QuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHsKICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlOwogICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gIm9iamVjdCIgfHwgdHlwZSA9PSAiZnVuY3Rpb24iKTsKICB9CiAgdmFyIGlzT2JqZWN0X2RlZmF1bHQgPSBpc09iamVjdDsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b051bWJlci5qcwogIHZhciBOQU4gPSAwIC8gMDsKICB2YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pOwogIHZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pOwogIHZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pOwogIHZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDsKICBmdW5jdGlvbiB0b051bWJlcih2YWx1ZSkgewogICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAibnVtYmVyIikgewogICAgICByZXR1cm4gdmFsdWU7CiAgICB9CiAgICBpZiAoaXNTeW1ib2xfZGVmYXVsdCh2YWx1ZSkpIHsKICAgICAgcmV0dXJuIE5BTjsKICAgIH0KICAgIGlmIChpc09iamVjdF9kZWZhdWx0KHZhbHVlKSkgewogICAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAiZnVuY3Rpb24iID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7CiAgICAgIHZhbHVlID0gaXNPYmplY3RfZGVmYXVsdChvdGhlcikgPyBvdGhlciArICIiIDogb3RoZXI7CiAgICB9CiAgICBpZiAodHlwZW9mIHZhbHVlICE9ICJzdHJpbmciKSB7CiAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlOwogICAgfQogICAgdmFsdWUgPSBiYXNlVHJpbV9kZWZhdWx0KHZhbHVlKTsKICAgIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7CiAgICByZXR1cm4gaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KSA6IHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWU7CiAgfQogIHZhciB0b051bWJlcl9kZWZhdWx0ID0gdG9OdW1iZXI7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9GaW5pdGUuanMKICB2YXIgSU5GSU5JVFkgPSAxIC8gMDsKICB2YXIgTUFYX0lOVEVHRVIgPSAxNzk3NjkzMTM0ODYyMzE1N2UyOTI7CiAgZnVuY3Rpb24gdG9GaW5pdGUodmFsdWUpIHsKICAgIGlmICghdmFsdWUpIHsKICAgICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwOwogICAgfQogICAgdmFsdWUgPSB0b051bWJlcl9kZWZhdWx0KHZhbHVlKTsKICAgIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkgewogICAgICB2YXIgc2lnbiA9IHZhbHVlIDwgMCA/IC0xIDogMTsKICAgICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjsKICAgIH0KICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSA6IDA7CiAgfQogIHZhciB0b0Zpbml0ZV9kZWZhdWx0ID0gdG9GaW5pdGU7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9JbnRlZ2VyLmpzCiAgZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7CiAgICB2YXIgcmVzdWx0ID0gdG9GaW5pdGVfZGVmYXVsdCh2YWx1ZSksIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7CiAgICByZXR1cm4gcmVzdWx0ID09PSByZXN1bHQgPyByZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQgOiAwOwogIH0KICB2YXIgdG9JbnRlZ2VyX2RlZmF1bHQgPSB0b0ludGVnZXI7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNGdW5jdGlvbi5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgYXN5bmNUYWcgPSAiW29iamVjdCBBc3luY0Z1bmN0aW9uXSI7CiAgdmFyIGZ1bmNUYWcgPSAiW29iamVjdCBGdW5jdGlvbl0iOwogIHZhciBnZW5UYWcgPSAiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0iOwogIHZhciBwcm94eVRhZyA9ICJbb2JqZWN0IFByb3h5XSI7CiAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkgewogICAgaWYgKCFpc09iamVjdF9kZWZhdWx0KHZhbHVlKSkgewogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CiAgICB2YXIgdGFnID0gYmFzZUdldFRhZ19kZWZhdWx0KHZhbHVlKTsKICAgIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7CiAgfQogIHZhciBpc0Z1bmN0aW9uX2RlZmF1bHQgPSBpc0Z1bmN0aW9uOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5QXJyYXkuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHsKICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoOwogICAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7CiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkgewogICAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdOwogICAgfQogICAgcmV0dXJuIGFycmF5OwogIH0KICB2YXIgY29weUFycmF5X2RlZmF1bHQgPSBjb3B5QXJyYXk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzSW5kZXguanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxOwogIHZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxkKikkLzsKICBmdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHsKICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlOwogICAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoOwogICAgcmV0dXJuICEhbGVuZ3RoICYmICh0eXBlID09ICJudW1iZXIiIHx8IHR5cGUgIT0gInN5bWJvbCIgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTsKICB9CiAgdmFyIGlzSW5kZXhfZGVmYXVsdCA9IGlzSW5kZXg7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZXEuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7CiAgICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8IHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7CiAgfQogIHZhciBlcV9kZWZhdWx0ID0gZXE7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzSXRlcmF0ZWVDYWxsLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXlMaWtlLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzTGVuZ3RoLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBNQVhfU0FGRV9JTlRFR0VSMiA9IDkwMDcxOTkyNTQ3NDA5OTE7CiAgZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHsKICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gIm51bWJlciIgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSMjsKICB9CiAgdmFyIGlzTGVuZ3RoX2RlZmF1bHQgPSBpc0xlbmd0aDsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5TGlrZS5qcwogIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7CiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aF9kZWZhdWx0KHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb25fZGVmYXVsdCh2YWx1ZSk7CiAgfQogIHZhciBpc0FycmF5TGlrZV9kZWZhdWx0ID0gaXNBcnJheUxpa2U7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzSXRlcmF0ZWVDYWxsLmpzCiAgZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHsKICAgIGlmICghaXNPYmplY3RfZGVmYXVsdChvYmplY3QpKSB7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4OwogICAgaWYgKHR5cGUgPT0gIm51bWJlciIgPyBpc0FycmF5TGlrZV9kZWZhdWx0KG9iamVjdCkgJiYgaXNJbmRleF9kZWZhdWx0KGluZGV4LCBvYmplY3QubGVuZ3RoKSA6IHR5cGUgPT0gInN0cmluZyIgJiYgaW5kZXggaW4gb2JqZWN0KSB7CiAgICAgIHJldHVybiBlcV9kZWZhdWx0KG9iamVjdFtpbmRleF0sIHZhbHVlKTsKICAgIH0KICAgIHJldHVybiBmYWxzZTsKICB9CiAgdmFyIGlzSXRlcmF0ZWVDYWxsX2RlZmF1bHQgPSBpc0l0ZXJhdGVlQ2FsbDsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNQcm90b3R5cGUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIG9iamVjdFByb3RvMyA9IE9iamVjdC5wcm90b3R5cGU7CiAgZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHsKICAgIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsIHByb3RvID0gdHlwZW9mIEN0b3IgPT0gImZ1bmN0aW9uIiAmJiBDdG9yLnByb3RvdHlwZSB8fCBvYmplY3RQcm90bzM7CiAgICByZXR1cm4gdmFsdWUgPT09IHByb3RvOwogIH0KICB2YXIgaXNQcm90b3R5cGVfZGVmYXVsdCA9IGlzUHJvdG90eXBlOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL2tleXMuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TGlrZUtleXMuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUaW1lcy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHsKICAgIHZhciBpbmRleCA9IC0xLCByZXN1bHQgPSBBcnJheShuKTsKICAgIHdoaWxlICgrK2luZGV4IDwgbikgewogICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpOwogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9CiAgdmFyIGJhc2VUaW1lc19kZWZhdWx0ID0gYmFzZVRpbWVzOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJndW1lbnRzLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNBcmd1bWVudHMuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgdmFyIGFyZ3NUYWcgPSAiW29iamVjdCBBcmd1bWVudHNdIjsKICBmdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHsKICAgIHJldHVybiBpc09iamVjdExpa2VfZGVmYXVsdCh2YWx1ZSkgJiYgYmFzZUdldFRhZ19kZWZhdWx0KHZhbHVlKSA9PSBhcmdzVGFnOwogIH0KICB2YXIgYmFzZUlzQXJndW1lbnRzX2RlZmF1bHQgPSBiYXNlSXNBcmd1bWVudHM7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcmd1bWVudHMuanMKICB2YXIgb2JqZWN0UHJvdG80ID0gT2JqZWN0LnByb3RvdHlwZTsKICB2YXIgaGFzT3duUHJvcGVydHkyID0gb2JqZWN0UHJvdG80Lmhhc093blByb3BlcnR5OwogIHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvNC5wcm9wZXJ0eUlzRW51bWVyYWJsZTsKICB2YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHNfZGVmYXVsdChmdW5jdGlvbigpIHsKICAgIHJldHVybiBhcmd1bWVudHM7CiAgfSgpKSA/IGJhc2VJc0FyZ3VtZW50c19kZWZhdWx0IDogZnVuY3Rpb24odmFsdWUpIHsKICAgIHJldHVybiBpc09iamVjdExpa2VfZGVmYXVsdCh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkyLmNhbGwodmFsdWUsICJjYWxsZWUiKSAmJiAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgImNhbGxlZSIpOwogIH07CiAgdmFyIGlzQXJndW1lbnRzX2RlZmF1bHQgPSBpc0FyZ3VtZW50czsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0J1ZmZlci5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zdHViRmFsc2UuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gc3R1YkZhbHNlKCkgewogICAgcmV0dXJuIGZhbHNlOwogIH0KICB2YXIgc3R1YkZhbHNlX2RlZmF1bHQgPSBzdHViRmFsc2U7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNCdWZmZXIuanMKICB2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAib2JqZWN0IiAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7CiAgdmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICJvYmplY3QiICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTsKICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0czsKICB2YXIgQnVmZmVyMyA9IG1vZHVsZUV4cG9ydHMgPyByb290X2RlZmF1bHQuQnVmZmVyIDogdm9pZCAwOwogIHZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlcjMgPyBCdWZmZXIzLmlzQnVmZmVyIDogdm9pZCAwOwogIHZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZV9kZWZhdWx0OwogIHZhciBpc0J1ZmZlcl9kZWZhdWx0ID0gaXNCdWZmZXI7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNUeXBlZEFycmF5LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNUeXBlZEFycmF5LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBhcmdzVGFnMiA9ICJbb2JqZWN0IEFyZ3VtZW50c10iOwogIHZhciBhcnJheVRhZyA9ICJbb2JqZWN0IEFycmF5XSI7CiAgdmFyIGJvb2xUYWcgPSAiW29iamVjdCBCb29sZWFuXSI7CiAgdmFyIGRhdGVUYWcgPSAiW29iamVjdCBEYXRlXSI7CiAgdmFyIGVycm9yVGFnID0gIltvYmplY3QgRXJyb3JdIjsKICB2YXIgZnVuY1RhZzIgPSAiW29iamVjdCBGdW5jdGlvbl0iOwogIHZhciBtYXBUYWcgPSAiW29iamVjdCBNYXBdIjsKICB2YXIgbnVtYmVyVGFnID0gIltvYmplY3QgTnVtYmVyXSI7CiAgdmFyIG9iamVjdFRhZyA9ICJbb2JqZWN0IE9iamVjdF0iOwogIHZhciByZWdleHBUYWcgPSAiW29iamVjdCBSZWdFeHBdIjsKICB2YXIgc2V0VGFnID0gIltvYmplY3QgU2V0XSI7CiAgdmFyIHN0cmluZ1RhZyA9ICJbb2JqZWN0IFN0cmluZ10iOwogIHZhciB3ZWFrTWFwVGFnID0gIltvYmplY3QgV2Vha01hcF0iOwogIHZhciBhcnJheUJ1ZmZlclRhZyA9ICJbb2JqZWN0IEFycmF5QnVmZmVyXSI7CiAgdmFyIGRhdGFWaWV3VGFnID0gIltvYmplY3QgRGF0YVZpZXddIjsKICB2YXIgZmxvYXQzMlRhZyA9ICJbb2JqZWN0IEZsb2F0MzJBcnJheV0iOwogIHZhciBmbG9hdDY0VGFnID0gIltvYmplY3QgRmxvYXQ2NEFycmF5XSI7CiAgdmFyIGludDhUYWcgPSAiW29iamVjdCBJbnQ4QXJyYXldIjsKICB2YXIgaW50MTZUYWcgPSAiW29iamVjdCBJbnQxNkFycmF5XSI7CiAgdmFyIGludDMyVGFnID0gIltvYmplY3QgSW50MzJBcnJheV0iOwogIHZhciB1aW50OFRhZyA9ICJbb2JqZWN0IFVpbnQ4QXJyYXldIjsKICB2YXIgdWludDhDbGFtcGVkVGFnID0gIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldIjsKICB2YXIgdWludDE2VGFnID0gIltvYmplY3QgVWludDE2QXJyYXldIjsKICB2YXIgdWludDMyVGFnID0gIltvYmplY3QgVWludDMyQXJyYXldIjsKICB2YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTsKICB0eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlOwogIHR5cGVkQXJyYXlUYWdzW2FyZ3NUYWcyXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPSB0eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnMl0gPSB0eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID0gdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPSB0eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlOwogIGZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHsKICAgIHJldHVybiBpc09iamVjdExpa2VfZGVmYXVsdCh2YWx1ZSkgJiYgaXNMZW5ndGhfZGVmYXVsdCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZ19kZWZhdWx0KHZhbHVlKV07CiAgfQogIHZhciBiYXNlSXNUeXBlZEFycmF5X2RlZmF1bHQgPSBiYXNlSXNUeXBlZEFycmF5OwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVW5hcnkuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHsKICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkgewogICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7CiAgICB9OwogIH0KICB2YXIgYmFzZVVuYXJ5X2RlZmF1bHQgPSBiYXNlVW5hcnk7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25vZGVVdGlsLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIHZhciBmcmVlRXhwb3J0czIgPSB0eXBlb2YgZXhwb3J0cyA9PSAib2JqZWN0IiAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7CiAgdmFyIGZyZWVNb2R1bGUyID0gZnJlZUV4cG9ydHMyICYmIHR5cGVvZiBtb2R1bGUgPT0gIm9iamVjdCIgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlOwogIHZhciBtb2R1bGVFeHBvcnRzMiA9IGZyZWVNb2R1bGUyICYmIGZyZWVNb2R1bGUyLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzMjsKICB2YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzMiAmJiBmcmVlR2xvYmFsX2RlZmF1bHQucHJvY2VzczsKICB2YXIgbm9kZVV0aWwgPSBmdW5jdGlvbigpIHsKICAgIHRyeSB7CiAgICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUyICYmIGZyZWVNb2R1bGUyLnJlcXVpcmUgJiYgZnJlZU1vZHVsZTIucmVxdWlyZSgidXRpbCIpLnR5cGVzOwogICAgICBpZiAodHlwZXMpIHsKICAgICAgICByZXR1cm4gdHlwZXM7CiAgICAgIH0KICAgICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygidXRpbCIpOwogICAgfSBjYXRjaCAoZSkgewogICAgfQogIH0oKTsKICB2YXIgbm9kZVV0aWxfZGVmYXVsdCA9IG5vZGVVdGlsOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzVHlwZWRBcnJheS5qcwogIHZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWxfZGVmYXVsdCAmJiBub2RlVXRpbF9kZWZhdWx0LmlzVHlwZWRBcnJheTsKICB2YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeV9kZWZhdWx0KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheV9kZWZhdWx0OwogIHZhciBpc1R5cGVkQXJyYXlfZGVmYXVsdCA9IGlzVHlwZWRBcnJheTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlMaWtlS2V5cy5qcwogIHZhciBvYmplY3RQcm90bzUgPSBPYmplY3QucHJvdG90eXBlOwogIHZhciBoYXNPd25Qcm9wZXJ0eTMgPSBvYmplY3RQcm90bzUuaGFzT3duUHJvcGVydHk7CiAgZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7CiAgICB2YXIgaXNBcnIgPSBpc0FycmF5X2RlZmF1bHQodmFsdWUpLCBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50c19kZWZhdWx0KHZhbHVlKSwgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcl9kZWZhdWx0KHZhbHVlKSwgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheV9kZWZhdWx0KHZhbHVlKSwgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLCByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lc19kZWZhdWx0KHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLCBsZW5ndGggPSByZXN1bHQubGVuZ3RoOwogICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7CiAgICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5My5jYWxsKHZhbHVlLCBrZXkpKSAmJiAhKHNraXBJbmRleGVzICYmIChrZXkgPT0gImxlbmd0aCIgfHwgaXNCdWZmICYmIChrZXkgPT0gIm9mZnNldCIgfHwga2V5ID09ICJwYXJlbnQiKSB8fCBpc1R5cGUgJiYgKGtleSA9PSAiYnVmZmVyIiB8fCBrZXkgPT0gImJ5dGVMZW5ndGgiIHx8IGtleSA9PSAiYnl0ZU9mZnNldCIpIHx8IGlzSW5kZXhfZGVmYXVsdChrZXksIGxlbmd0aCkpKSkgewogICAgICAgIHJlc3VsdC5wdXNoKGtleSk7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfQogIHZhciBhcnJheUxpa2VLZXlzX2RlZmF1bHQgPSBhcnJheUxpa2VLZXlzOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5cy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbmF0aXZlS2V5cy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb3ZlckFyZy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkgewogICAgcmV0dXJuIGZ1bmN0aW9uKGFyZykgewogICAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7CiAgICB9OwogIH0KICB2YXIgb3ZlckFyZ19kZWZhdWx0ID0gb3ZlckFyZzsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbmF0aXZlS2V5cy5qcwogIHZhciBuYXRpdmVLZXlzID0gb3ZlckFyZ19kZWZhdWx0KE9iamVjdC5rZXlzLCBPYmplY3QpOwogIHZhciBuYXRpdmVLZXlzX2RlZmF1bHQgPSBuYXRpdmVLZXlzOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5cy5qcwogIHZhciBvYmplY3RQcm90bzYgPSBPYmplY3QucHJvdG90eXBlOwogIHZhciBoYXNPd25Qcm9wZXJ0eTQgPSBvYmplY3RQcm90bzYuaGFzT3duUHJvcGVydHk7CiAgZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7CiAgICBpZiAoIWlzUHJvdG90eXBlX2RlZmF1bHQob2JqZWN0KSkgewogICAgICByZXR1cm4gbmF0aXZlS2V5c19kZWZhdWx0KG9iamVjdCk7CiAgICB9CiAgICB2YXIgcmVzdWx0ID0gW107CiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHsKICAgICAgaWYgKGhhc093blByb3BlcnR5NC5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gImNvbnN0cnVjdG9yIikgewogICAgICAgIHJlc3VsdC5wdXNoKGtleSk7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfQogIHZhciBiYXNlS2V5c19kZWZhdWx0ID0gYmFzZUtleXM7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5cy5qcwogIGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7CiAgICByZXR1cm4gaXNBcnJheUxpa2VfZGVmYXVsdChvYmplY3QpID8gYXJyYXlMaWtlS2V5c19kZWZhdWx0KG9iamVjdCkgOiBiYXNlS2V5c19kZWZhdWx0KG9iamVjdCk7CiAgfQogIHZhciBrZXlzX2RlZmF1bHQgPSBrZXlzOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlQ2xhbXAuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gYmFzZUNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7CiAgICBpZiAobnVtYmVyID09PSBudW1iZXIpIHsKICAgICAgaWYgKHVwcGVyICE9PSB2b2lkIDApIHsKICAgICAgICBudW1iZXIgPSBudW1iZXIgPD0gdXBwZXIgPyBudW1iZXIgOiB1cHBlcjsKICAgICAgfQogICAgICBpZiAobG93ZXIgIT09IHZvaWQgMCkgewogICAgICAgIG51bWJlciA9IG51bWJlciA+PSBsb3dlciA/IG51bWJlciA6IGxvd2VyOwogICAgICB9CiAgICB9CiAgICByZXR1cm4gbnVtYmVyOwogIH0KICB2YXIgYmFzZUNsYW1wX2RlZmF1bHQgPSBiYXNlQ2xhbXA7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdmFsdWVzLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVmFsdWVzLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykgewogICAgcmV0dXJuIGFycmF5TWFwX2RlZmF1bHQocHJvcHMsIGZ1bmN0aW9uKGtleSkgewogICAgICByZXR1cm4gb2JqZWN0W2tleV07CiAgICB9KTsKICB9CiAgdmFyIGJhc2VWYWx1ZXNfZGVmYXVsdCA9IGJhc2VWYWx1ZXM7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdmFsdWVzLmpzCiAgZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkgewogICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzX2RlZmF1bHQob2JqZWN0LCBrZXlzX2RlZmF1bHQob2JqZWN0KSk7CiAgfQogIHZhciB2YWx1ZXNfZGVmYXVsdCA9IHZhbHVlczsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVJhbmRvbS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICB2YXIgbmF0aXZlRmxvb3IgPSBNYXRoLmZsb29yOwogIHZhciBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbTsKICBmdW5jdGlvbiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcikgewogICAgcmV0dXJuIGxvd2VyICsgbmF0aXZlRmxvb3IobmF0aXZlUmFuZG9tKCkgKiAodXBwZXIgLSBsb3dlciArIDEpKTsKICB9CiAgdmFyIGJhc2VSYW5kb21fZGVmYXVsdCA9IGJhc2VSYW5kb207CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvc2FtcGxlU2l6ZS5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlTYW1wbGVTaXplLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zaHVmZmxlU2VsZi5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBzaHVmZmxlU2VsZihhcnJheSwgc2l6ZSkgewogICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCwgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTsKICAgIHNpemUgPSBzaXplID09PSB2b2lkIDAgPyBsZW5ndGggOiBzaXplOwogICAgd2hpbGUgKCsraW5kZXggPCBzaXplKSB7CiAgICAgIHZhciByYW5kID0gYmFzZVJhbmRvbV9kZWZhdWx0KGluZGV4LCBsYXN0SW5kZXgpLCB2YWx1ZSA9IGFycmF5W3JhbmRdOwogICAgICBhcnJheVtyYW5kXSA9IGFycmF5W2luZGV4XTsKICAgICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7CiAgICB9CiAgICBhcnJheS5sZW5ndGggPSBzaXplOwogICAgcmV0dXJuIGFycmF5OwogIH0KICB2YXIgc2h1ZmZsZVNlbGZfZGVmYXVsdCA9IHNodWZmbGVTZWxmOwoKICAvLyBub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheVNhbXBsZVNpemUuanMKICBmdW5jdGlvbiBhcnJheVNhbXBsZVNpemUoYXJyYXksIG4pIHsKICAgIHJldHVybiBzaHVmZmxlU2VsZl9kZWZhdWx0KGNvcHlBcnJheV9kZWZhdWx0KGFycmF5KSwgYmFzZUNsYW1wX2RlZmF1bHQobiwgMCwgYXJyYXkubGVuZ3RoKSk7CiAgfQogIHZhciBhcnJheVNhbXBsZVNpemVfZGVmYXVsdCA9IGFycmF5U2FtcGxlU2l6ZTsKCiAgLy8gbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVNhbXBsZVNpemUuanMKICBpbml0X2J1ZmZlcl9zaGltKCk7CiAgZnVuY3Rpb24gYmFzZVNhbXBsZVNpemUoY29sbGVjdGlvbiwgbikgewogICAgdmFyIGFycmF5ID0gdmFsdWVzX2RlZmF1bHQoY29sbGVjdGlvbik7CiAgICByZXR1cm4gc2h1ZmZsZVNlbGZfZGVmYXVsdChhcnJheSwgYmFzZUNsYW1wX2RlZmF1bHQobiwgMCwgYXJyYXkubGVuZ3RoKSk7CiAgfQogIHZhciBiYXNlU2FtcGxlU2l6ZV9kZWZhdWx0ID0gYmFzZVNhbXBsZVNpemU7CgogIC8vIG5vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvc2FtcGxlU2l6ZS5qcwogIGZ1bmN0aW9uIHNhbXBsZVNpemUoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIHsKICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsX2RlZmF1bHQoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIDogbiA9PT0gdm9pZCAwKSB7CiAgICAgIG4gPSAxOwogICAgfSBlbHNlIHsKICAgICAgbiA9IHRvSW50ZWdlcl9kZWZhdWx0KG4pOwogICAgfQogICAgdmFyIGZ1bmMgPSBpc0FycmF5X2RlZmF1bHQoY29sbGVjdGlvbikgPyBhcnJheVNhbXBsZVNpemVfZGVmYXVsdCA6IGJhc2VTYW1wbGVTaXplX2RlZmF1bHQ7CiAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuKTsKICB9CiAgdmFyIHNhbXBsZVNpemVfZGVmYXVsdCA9IHNhbXBsZVNpemU7CgogIC8vIHNyYy9kYXRhLWZldGNoZXJzL3V0aWxzLnRzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2luZGV4LmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwoKICAvLyBub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2FzY2VuZGluZy5qcwogIGluaXRfYnVmZmVyX3NoaW0oKTsKICBmdW5jdGlvbiBhc2NlbmRpbmdfZGVmYXVsdChhLCBiKSB7CiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47CiAgfQoKICAvLyBub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2Jpc2VjdG9yLmpzCiAgaW5pdF9idWZmZXJfc2hpbSgpOwogIGZ1bmN0aW9uIGJpc2VjdG9yX2RlZmF1bHQoZikgewogICAgbGV0IGRlbHRhID0gZjsKICAgIGxldCBjb21wYXJlID0gZjsKICAgIGlmIChmLmxlbmd0aCA9PT0gMSkgewogICAgICBkZWx0YSA9IChkLCB4KSA9PiBmKGQpIC0geDsKICAgICAgY29tcGFyZSA9IGFzY2VuZGluZ0NvbXBhcmF0b3IoZik7CiAgICB9CiAgICBmdW5jdGlvbiBsZWZ0KGEsIHgsIGxvLCBoaSkgewogICAgICBpZiAobG8gPT0gbnVsbCkKICAgICAgICBsbyA9IDA7CiAgICAgIGlmIChoaSA9PSBudWxsKQogICAgICAgIGhpID0gYS5sZW5ndGg7CiAgICAgIHdoaWxlIChsbyA8IGhpKSB7CiAgICAgICAgY29uc3QgbWlkID0gbG8gKyBoaSA+Pj4gMTsKICAgICAgICBpZiAoY29tcGFyZShhW21pZF0sIHgpIDwgMCkKICAgICAgICAgIGxvID0gbWlkICsgMTsKICAgICAgICBlbHNlCiAgICAgICAgICBoaSA9IG1pZDsKICAgICAgfQogICAgICByZXR1cm4gbG87CiAgICB9CiAgICBmdW5jdGlvbiByaWdodChhLCB4LCBsbywgaGkpIHsKICAgICAgaWYgKGxvID09IG51bGwpCiAgICAgICAgbG8gPSAwOwogICAgICBpZiAoaGkgPT0gbnVsbCkKICAgICAgICBoaSA9IGEubGVuZ3RoOwogICAgICB3aGlsZSAobG8gPCBoaSkgewogICAgICAgIGNvbnN0IG1pZCA9IGxvICsgaGkgPj4+IDE7CiAgICAgICAgaWYgKGNvbXBhcmUoYVttaWRdLCB4KSA+IDApCiAgICAgICAgICBoaSA9IG1pZDsKICAgICAgICBlbHNlCiAgICAgICAgICBsbyA9IG1pZCArIDE7CiAgICAgIH0KICAgICAgcmV0dXJuIGxvOwogICAgfQogICAgZnVuY3Rpb24gY2VudGVyKGEsIHgsIGxvLCBoaSkgewogICAgICBpZiAobG8gPT0gbnVsbCkKICAgICAgICBsbyA9IDA7CiAgICAgIGlmIChoaSA9PSBudWxsKQogICAgICAgIGhpID0gYS5sZW5ndGg7CiAgICAgIGNvbnN0IGkgPSBsZWZ0KGEsIHgsIGxvLCBoaSAtIDEpOwogICAgICByZXR1cm4gaSA+IGxvICYmIGRlbHRhKGFbaSAtIDFdLCB4KSA+IC1kZWx0YShhW2ldLCB4KSA/IGkgLSAxIDogaTsKICAgIH0KICAgIHJldHVybiB7IGxlZnQsIGNlbnRlciwgcmlnaHQgfTsKICB9CiAgZnVuY3Rpb24gYXNjZW5kaW5nQ29tcGFyYXRvcihmKSB7CiAgICByZXR1cm4gKGQsIHgpID0+IGFzY2VuZGluZ19kZWZhdWx0KGYoZCksIHgpOwogIH0KCiAgLy8gc3JjL2RhdGEtZmV0Y2hlcnMvdXRpbHMudHMKICB2YXIgaW1wb3J0X2dlbmVyaWNfZmlsZWhhbmRsZTIgPSBfX3RvTW9kdWxlKHJlcXVpcmVfZGlzdCgpKTsKICB2YXIgRGF0YVNvdXJjZSA9IGNsYXNzIHsKICAgIGNvbnN0cnVjdG9yKGZpbGUsIGNocm9tU2l6ZXMsIG9wdGlvbnMpIHsKICAgICAgdGhpcy5maWxlID0gZmlsZTsKICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9uczsKICAgICAgdGhpcy5jaHJvbUluZm8gPSBzaXplc1RvQ2hyb21JbmZvKGNocm9tU2l6ZXMpOwogICAgICB0aGlzLnRpbGVzZXRJbmZvID0gdGlsZXNldEluZm9Gcm9tQ2hyb21JbmZvKHRoaXMuY2hyb21JbmZvKTsKICAgIH0KICB9OwogIHZhciBjaHJvbUluZm9CaXNlY3RvciA9IGJpc2VjdG9yX2RlZmF1bHQoKGQpID0+IGQucG9zKS5sZWZ0OwogIHZhciBjaHJUb0FicyA9IChjaHJvbSwgY2hyb21Qb3MsIGNocm9tSW5mbykgPT4gY2hyb21JbmZvLmNoclBvc2l0aW9uc1tjaHJvbV0ucG9zICsgY2hyb21Qb3M7CiAgdmFyIGFic1RvQ2hyID0gKGFic1Bvc2l0aW9uLCBjaHJvbUluZm8pID0+IHsKICAgIGlmICghY2hyb21JbmZvIHx8ICFjaHJvbUluZm8uY3VtUG9zaXRpb25zIHx8ICFjaHJvbUluZm8uY3VtUG9zaXRpb25zLmxlbmd0aCkgewogICAgICByZXR1cm4gbnVsbDsKICAgIH0KICAgIGxldCBpbnNlcnRQb2ludCA9IGNocm9tSW5mb0Jpc2VjdG9yKGNocm9tSW5mby5jdW1Qb3NpdGlvbnMsIGFic1Bvc2l0aW9uKTsKICAgIGNvbnN0IGxhc3RDaHIgPSBjaHJvbUluZm8uY3VtUG9zaXRpb25zW2Nocm9tSW5mby5jdW1Qb3NpdGlvbnMubGVuZ3RoIC0gMV0uY2hyOwogICAgY29uc3QgbGFzdExlbmd0aCA9IGNocm9tSW5mby5jaHJvbUxlbmd0aHNbbGFzdENocl07CiAgICBpbnNlcnRQb2ludCAtPSBpbnNlcnRQb2ludCA+IDAgJiYgMTsKICAgIGxldCBjaHJQb3NpdGlvbiA9IE1hdGguZmxvb3IoYWJzUG9zaXRpb24gLSBjaHJvbUluZm8uY3VtUG9zaXRpb25zW2luc2VydFBvaW50XS5wb3MpOwogICAgbGV0IG9mZnNldCA9IDA7CiAgICBpZiAoY2hyUG9zaXRpb24gPCAwKSB7CiAgICAgIG9mZnNldCA9IGNoclBvc2l0aW9uIC0gMTsKICAgICAgY2hyUG9zaXRpb24gPSAxOwogICAgfQogICAgaWYgKGluc2VydFBvaW50ID09PSBjaHJvbUluZm8uY3VtUG9zaXRpb25zLmxlbmd0aCAtIDEgJiYgY2hyUG9zaXRpb24gPiBsYXN0TGVuZ3RoKSB7CiAgICAgIG9mZnNldCA9IGNoclBvc2l0aW9uIC0gbGFzdExlbmd0aDsKICAgICAgY2hyUG9zaXRpb24gPSBsYXN0TGVuZ3RoOwogICAgfQogICAgcmV0dXJuIFtjaHJvbUluZm8uY3VtUG9zaXRpb25zW2luc2VydFBvaW50XS5jaHIsIGNoclBvc2l0aW9uLCBvZmZzZXQsIGluc2VydFBvaW50XTsKICB9OwogIGZ1bmN0aW9uIHRpbGVzZXRJbmZvRnJvbUNocm9tSW5mbyhjaHJvbUluZm8sIHRpbGVTaXplID0gMTAyNCkgewogICAgcmV0dXJuIHsKICAgICAgdGlsZV9zaXplOiB0aWxlU2l6ZSwKICAgICAgYmluc19wZXJfZGltZW5zaW9uOiB0aWxlU2l6ZSwKICAgICAgbWF4X3pvb206IE1hdGguY2VpbChNYXRoLmxvZyhjaHJvbUluZm8udG90YWxMZW5ndGggLyB0aWxlU2l6ZSkgLyBNYXRoLmxvZygyKSksCiAgICAgIG1heF93aWR0aDogY2hyb21JbmZvLnRvdGFsTGVuZ3RoLAogICAgICBtaW5fcG9zOiBbMF0sCiAgICAgIG1heF9wb3M6IFtjaHJvbUluZm8udG90YWxMZW5ndGhdCiAgICB9OwogIH0KICBmdW5jdGlvbiBzaXplc1RvQ2hyb21JbmZvKHNpemVzKSB7CiAgICBjb25zdCBpbmZvID0gewogICAgICBjdW1Qb3NpdGlvbnM6IFtdLAogICAgICBjaHJvbUxlbmd0aHM6IHt9LAogICAgICBjaHJQb3NpdGlvbnM6IHt9LAogICAgICB0b3RhbExlbmd0aDogMAogICAgfTsKICAgIHNpemVzLmZvckVhY2goKFtjaHIsIGxlbmd0aF0sIGkpID0+IHsKICAgICAgY29uc3QgY2hyUG9zaXRpb24gPSB7IGlkOiBpLCBjaHIsIHBvczogaW5mby50b3RhbExlbmd0aCB9OwogICAgICBpbmZvLmNoclBvc2l0aW9uc1tjaHJdID0gY2hyUG9zaXRpb247CiAgICAgIGluZm8uY2hyb21MZW5ndGhzW2Nocl0gPSBsZW5ndGg7CiAgICAgIGluZm8uY3VtUG9zaXRpb25zLnB1c2goY2hyUG9zaXRpb24pOwogICAgICBpbmZvLnRvdGFsTGVuZ3RoICs9IGxlbmd0aDsKICAgIH0pOwogICAgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGluZm8pLCB7CiAgICAgIGFic1RvQ2hyOiAoYWJzUG9zKSA9PiBpbmZvLmNoclBvc2l0aW9ucyA/IGFic1RvQ2hyKGFic1BvcywgaW5mbykgOiBudWxsLAogICAgICBjaHJUb0FiczogKFtjaHJOYW1lLCBjaHJQb3NdKSA9PiBpbmZvLmNoclBvc2l0aW9ucyA/IGNoclRvQWJzKGNock5hbWUsIGNoclBvcywgaW5mbykgOiBudWxsCiAgICB9KTsKICB9CiAgdmFyIFJlbW90ZUZpbGUgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9nZW5lcmljX2ZpbGVoYW5kbGUyLlJlbW90ZUZpbGUgewogICAgY29uc3RydWN0b3IoKSB7CiAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7CiAgICAgIHRoaXMucmVhZCA9IChfMCwgLi4uXzEpID0+IF9fYXN5bmModGhpcywgW18wLCAuLi5fMV0sIGZ1bmN0aW9uKiAoYnVmZmVyLCBvZmZzZXQgPSAwLCBsZW5ndGgsIHBvc2l0aW9uID0gMCwgb3B0cyA9IHt9KSB7CiAgICAgICAgY29uc3QgeyBoZWFkZXJzID0ge30sIHNpZ25hbCwgb3ZlcnJpZGVzID0ge30gfSA9IG9wdHM7CiAgICAgICAgaWYgKGxlbmd0aCA8IEluZmluaXR5KSB7CiAgICAgICAgICBoZWFkZXJzLnJhbmdlID0gYGJ5dGVzPSR7cG9zaXRpb259LSR7cG9zaXRpb24gKyBsZW5ndGh9YDsKICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gSW5maW5pdHkgJiYgcG9zaXRpb24gIT09IDApIHsKICAgICAgICAgIGhlYWRlcnMucmFuZ2UgPSBgYnl0ZXM9JHtwb3NpdGlvbn0tYDsKICAgICAgICB9CiAgICAgICAgY29uc3QgYXJncyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMuYmFzZU92ZXJyaWRlcyksIG92ZXJyaWRlcyksIHsKICAgICAgICAgIGhlYWRlcnM6IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBoZWFkZXJzKSwgb3ZlcnJpZGVzLmhlYWRlcnMpLCB0aGlzLmJhc2VPdmVycmlkZXMuaGVhZGVycyksCiAgICAgICAgICBtZXRob2Q6ICJHRVQiLAogICAgICAgICAgcmVkaXJlY3Q6ICJmb2xsb3ciLAogICAgICAgICAgbW9kZTogImNvcnMiLAogICAgICAgICAgc2lnbmFsCiAgICAgICAgfSk7CiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmZldGNoKHRoaXMudXJsLCBhcmdzKTsKICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0gJHt0aGlzLnVybH1gKTsKICAgICAgICB9CiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA2KSB7CiAgICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSB5aWVsZCB0aGlzLmdldEJ1ZmZlckZyb21SZXNwb25zZShyZXNwb25zZSk7CiAgICAgICAgICBjb25zdCBieXRlc0NvcGllZCA9IHJlc3BvbnNlRGF0YS5jb3B5KGJ1ZmZlciwgb2Zmc2V0LCAwLCBNYXRoLm1pbihsZW5ndGgsIHJlc3BvbnNlRGF0YS5sZW5ndGgpKTsKICAgICAgICAgIGNvbnN0IHJlcyA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCJjb250ZW50LXJhbmdlIik7CiAgICAgICAgICBjb25zdCBzaXplTWF0Y2ggPSAvXC8oXGQrKSQvLmV4ZWMocmVzIHx8ICIiKTsKICAgICAgICAgIGlmIChzaXplTWF0Y2ggJiYgc2l6ZU1hdGNoWzFdKSB7CiAgICAgICAgICAgIHRoaXMuX3N0YXQgPSB7IHNpemU6IHBhcnNlSW50KHNpemVNYXRjaFsxXSwgMTApIH07CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4geyBieXRlc1JlYWQ6IGJ5dGVzQ29waWVkLCBidWZmZXIgfTsKICAgICAgICB9CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfSBmZXRjaGluZyAke3RoaXMudXJsfWApOwogICAgICB9KTsKICAgIH0KICB9OwoKICAvLyBzcmMvZGF0YS1mZXRjaGVycy92Y2YvdmNmLXdvcmtlci50cz93b3JrZXImaW5saW5lP3dvcmtlcl9maWxlCiAgdmFyIHZjZkZpbGVzID0gbmV3IE1hcCgpOwogIHZhciBWY2ZGaWxlID0gY2xhc3MgewogICAgY29uc3RydWN0b3IodGJpKSB7CiAgICAgIHRoaXMudGJpID0gdGJpOwogICAgfQogICAgZ2V0UGFyc2VyKCkgewogICAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkgewogICAgICAgIGlmICghdGhpcy5wYXJzZXIpIHsKICAgICAgICAgIGNvbnN0IGhlYWRlciA9IHlpZWxkIHRoaXMudGJpLmdldEhlYWRlcigpOwogICAgICAgICAgdGhpcy5wYXJzZXIgPSBuZXcgZXNtX2RlZmF1bHQoeyBoZWFkZXIgfSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0aGlzLnBhcnNlcjsKICAgICAgfSk7CiAgICB9CiAgICBzdGF0aWMgZnJvbVVybCh1cmwsIGluZGV4VXJsKSB7CiAgICAgIGNvbnN0IHRiaSA9IG5ldyBUYWJpeEluZGV4ZWRGaWxlKHsKICAgICAgICBmaWxlaGFuZGxlOiBuZXcgUmVtb3RlRmlsZSh1cmwpLAogICAgICAgIHRiaUZpbGVoYW5kbGU6IG5ldyBSZW1vdGVGaWxlKGluZGV4VXJsKQogICAgICB9KTsKICAgICAgcmV0dXJuIG5ldyBWY2ZGaWxlKHRiaSk7CiAgICB9CiAgfTsKICB2YXIgdGlsZVZhbHVlcyA9IHt9OwogIHZhciBkYXRhU291cmNlcyA9IG5ldyBNYXAoKTsKICBmdW5jdGlvbiBpbml0KHVpZCwgdmNmLCBjaHJvbVNpemVzLCBvcHRpb25zID0ge30pIHsKICAgIGxldCB2Y2ZGaWxlID0gdmNmRmlsZXMuZ2V0KHZjZi51cmwpOwogICAgaWYgKCF2Y2ZGaWxlKSB7CiAgICAgIHZjZkZpbGUgPSBWY2ZGaWxlLmZyb21VcmwodmNmLnVybCwgdmNmLmluZGV4VXJsKTsKICAgIH0KICAgIGNvbnN0IGRhdGFTb3VyY2UgPSBuZXcgRGF0YVNvdXJjZSh2Y2ZGaWxlLCBjaHJvbVNpemVzLCBfX3NwcmVhZFZhbHVlcyh7CiAgICAgIHNhbXBsZUxlbmd0aDogMWUzCiAgICB9LCBvcHRpb25zKSk7CiAgICBkYXRhU291cmNlcy5zZXQodWlkLCBkYXRhU291cmNlKTsKICB9CiAgdmFyIHRpbGVzZXRJbmZvID0gKHVpZCkgPT4gewogICAgcmV0dXJuIGRhdGFTb3VyY2VzLmdldCh1aWQpLnRpbGVzZXRJbmZvOwogIH07CiAgdmFyIGdldE11dGF0aW9uVHlwZSA9IChyZWYsIGFsdCkgPT4gewogICAgaWYgKCFhbHQpCiAgICAgIHJldHVybiAidW5rbm93biI7CiAgICBpZiAocmVmLmxlbmd0aCA9PT0gYWx0Lmxlbmd0aCkKICAgICAgcmV0dXJuICJzdWJzdGl0dXRpb24iOwogICAgaWYgKHJlZi5sZW5ndGggPiBhbHQubGVuZ3RoKQogICAgICByZXR1cm4gImRlbGV0aW9uIjsKICAgIGlmIChyZWYubGVuZ3RoIDwgYWx0Lmxlbmd0aCkKICAgICAgcmV0dXJuICJpbnNlcnRpb24iOwogICAgcmV0dXJuICJ1bmtub3duIjsKICB9OwogIHZhciBnZXRTdWJzdGl0dXRpb25UeXBlID0gKHJlZiwgYWx0KSA9PiB7CiAgICBzd2l0Y2ggKHJlZiArIGFsdCkgewogICAgICBjYXNlICJDQSI6CiAgICAgIGNhc2UgIkdUIjoKICAgICAgICByZXR1cm4gIkM+QSI7CiAgICAgIGNhc2UgIkNHIjoKICAgICAgY2FzZSAiR0MiOgogICAgICAgIHJldHVybiAiQz5HIjsKICAgICAgY2FzZSAiQ1QiOgogICAgICBjYXNlICJHQSI6CiAgICAgICAgcmV0dXJuICJDPlQiOwogICAgICBjYXNlICJUQSI6CiAgICAgIGNhc2UgIkFUIjoKICAgICAgICByZXR1cm4gIlQ+QSI7CiAgICAgIGNhc2UgIlRDIjoKICAgICAgY2FzZSAiQUciOgogICAgICAgIHJldHVybiAiVD5DIjsKICAgICAgY2FzZSAiVEciOgogICAgICBjYXNlICJBQyI6CiAgICAgICAgcmV0dXJuICJUPkciOwogICAgICBkZWZhdWx0OgogICAgICAgIHJldHVybiAidW5rbm93biI7CiAgICB9CiAgfTsKICB2YXIgdGlsZSA9ICh1aWQsIHosIHgpID0+IF9fYXN5bmModm9pZCAwLCBudWxsLCBmdW5jdGlvbiogKCkgewogICAgY29uc3Qgc291cmNlID0gZGF0YVNvdXJjZXMuZ2V0KHVpZCk7CiAgICBjb25zdCBwYXJzZXIgPSB5aWVsZCBzb3VyY2UuZmlsZS5nZXRQYXJzZXIoKTsKICAgIGNvbnN0IENBQ0hFX0tFWSA9IGAke3VpZH0uJHt6fS4ke3h9YDsKICAgIHRpbGVWYWx1ZXNbQ0FDSEVfS0VZXSA9IFtdOwogICAgY29uc3QgcmVjb3JkUHJvbWlzZXMgPSBbXTsKICAgIGNvbnN0IHRpbGVXaWR0aCA9ICtzb3VyY2UudGlsZXNldEluZm8ubWF4X3dpZHRoIC8gX19wb3coMiwgK3opOwogICAgY29uc3QgbWluWCA9IHNvdXJjZS50aWxlc2V0SW5mby5taW5fcG9zWzBdICsgeCAqIHRpbGVXaWR0aDsKICAgIGNvbnN0IG1heFggPSBzb3VyY2UudGlsZXNldEluZm8ubWluX3Bvc1swXSArICh4ICsgMSkgKiB0aWxlV2lkdGg7CiAgICBsZXQgY3VyTWluWCA9IG1pblg7CiAgICBjb25zdCB7IGNocm9tTGVuZ3RocywgY3VtUG9zaXRpb25zIH0gPSBzb3VyY2UuY2hyb21JbmZvOwogICAgY3VtUG9zaXRpb25zLmZvckVhY2goKGN1bVBvcykgPT4gewogICAgICBjb25zdCBjaHJvbU5hbWUgPSBjdW1Qb3MuY2hyOwogICAgICBjb25zdCBjaHJvbVN0YXJ0ID0gY3VtUG9zLnBvczsKICAgICAgY29uc3QgY2hyb21FbmQgPSBjdW1Qb3MucG9zICsgY2hyb21MZW5ndGhzW2Nocm9tTmFtZV07CiAgICAgIGNvbnN0IHBhcnNlTGluZVN0b3JlRGF0YSA9IChsaW5lLCBwcmV2UG9zKSA9PiB7CiAgICAgICAgY29uc3QgdmNmUmVjb3JkID0gcGFyc2VyLnBhcnNlTGluZShsaW5lKTsKICAgICAgICBjb25zdCBQT1MgPSBjdW1Qb3MucG9zICsgdmNmUmVjb3JkLlBPUyArIDE7CiAgICAgICAgbGV0IEFMVDsKICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2Y2ZSZWNvcmQuQUxUKSAmJiB2Y2ZSZWNvcmQuQUxULmxlbmd0aCA+IDApIHsKICAgICAgICAgIEFMVCA9IHZjZlJlY29yZC5BTFRbMF07CiAgICAgICAgfQogICAgICAgIGNvbnN0IERJU1RQUkVWID0gIXByZXZQb3MgPyBudWxsIDogdmNmUmVjb3JkLlBPUyAtIHByZXZQb3M7CiAgICAgICAgY29uc3QgRElTVFBSRVZMT0dFID0gIXByZXZQb3MgPyBudWxsIDogTWF0aC5sb2codmNmUmVjb3JkLlBPUyAtIHByZXZQb3MpOwogICAgICAgIGNvbnN0IE1VVFRZUEUgPSBnZXRNdXRhdGlvblR5cGUodmNmUmVjb3JkLlJFRiwgQUxUKTsKICAgICAgICBjb25zdCBTVUJUWVBFID0gZ2V0U3Vic3RpdHV0aW9uVHlwZSh2Y2ZSZWNvcmQuUkVGLCBBTFQpOwogICAgICAgIGNvbnN0IFBPU0VORCA9IFBPUyArIHZjZlJlY29yZC5SRUYubGVuZ3RoOwogICAgICAgIGNvbnN0IGRhdGEgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCB2Y2ZSZWNvcmQpLCB7CiAgICAgICAgICBBTFQsCiAgICAgICAgICBNVVRUWVBFLAogICAgICAgICAgU1VCVFlQRSwKICAgICAgICAgIElORk86IEpTT04uc3RyaW5naWZ5KHZjZlJlY29yZC5JTkZPKSwKICAgICAgICAgIE9SSUdJTkFMUE9TOiB2Y2ZSZWNvcmQuUE9TLAogICAgICAgICAgUE9TLAogICAgICAgICAgUE9TRU5ELAogICAgICAgICAgRElTVFBSRVYsCiAgICAgICAgICBESVNUUFJFVkxPR0UKICAgICAgICB9KTsKICAgICAgICBPYmplY3Qua2V5cyh2Y2ZSZWNvcmQuSU5GTykuZm9yRWFjaCgoa2V5KSA9PiB7CiAgICAgICAgICBjb25zdCB2YWwgPSB2Y2ZSZWNvcmQuSU5GT1trZXldOwogICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkKICAgICAgICAgICAgcmV0dXJuIFtrZXksIHZhbFswXV07CiAgICAgICAgICByZXR1cm4gW2tleSwgdmFsXTsKICAgICAgICB9KTsKICAgICAgICB0aWxlVmFsdWVzW0NBQ0hFX0tFWV0gPSB0aWxlVmFsdWVzW0NBQ0hFX0tFWV0uY29uY2F0KFtkYXRhXSk7CiAgICAgICAgcmV0dXJuIHZjZlJlY29yZC5QT1M7CiAgICAgIH07CiAgICAgIGxldCBzdGFydFBvcywgZW5kUG9zOwogICAgICBpZiAoY2hyb21TdGFydCA8PSBjdXJNaW5YICYmIGN1ck1pblggPCBjaHJvbUVuZCkgewogICAgICAgIGxldCBwcmV2UE9TOwogICAgICAgIGlmIChtYXhYID4gY2hyb21FbmQpIHsKICAgICAgICAgIHN0YXJ0UG9zID0gY3VyTWluWCAtIGNocm9tU3RhcnQ7CiAgICAgICAgICBlbmRQb3MgPSBjaHJvbUVuZCAtIGNocm9tU3RhcnQ7CiAgICAgICAgICByZWNvcmRQcm9taXNlcy5wdXNoKHNvdXJjZS5maWxlLnRiaS5nZXRMaW5lcyhjaHJvbU5hbWUsIHN0YXJ0UG9zLCBlbmRQb3MsIChsaW5lKSA9PiB7CiAgICAgICAgICAgIHByZXZQT1MgPSBwYXJzZUxpbmVTdG9yZURhdGEobGluZSwgcHJldlBPUyk7CiAgICAgICAgICB9KS50aGVuKCgpID0+IHsKICAgICAgICAgIH0pKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgc3RhcnRQb3MgPSBNYXRoLmZsb29yKGN1ck1pblggLSBjaHJvbVN0YXJ0KTsKICAgICAgICAgIGVuZFBvcyA9IE1hdGguY2VpbChtYXhYIC0gY2hyb21TdGFydCk7CiAgICAgICAgICByZWNvcmRQcm9taXNlcy5wdXNoKHNvdXJjZS5maWxlLnRiaS5nZXRMaW5lcyhjaHJvbU5hbWUsIHN0YXJ0UG9zLCBlbmRQb3MsIChsaW5lKSA9PiB7CiAgICAgICAgICAgIHByZXZQT1MgPSBwYXJzZUxpbmVTdG9yZURhdGEobGluZSwgcHJldlBPUyk7CiAgICAgICAgICB9KS50aGVuKCgpID0+IHsKICAgICAgICAgIH0pKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgY3VyTWluWCA9IGNocm9tRW5kOwogICAgICB9CiAgICB9KTsKICAgIHJldHVybiBQcm9taXNlLmFsbChyZWNvcmRQcm9taXNlcykudGhlbigodmFsdWVzMikgPT4gdmFsdWVzMi5mbGF0KCkpOwogIH0pOwogIHZhciBmZXRjaFRpbGVzRGVib3VuY2VkID0gKHVpZCwgdGlsZUlkcykgPT4gX19hc3luYyh2b2lkIDAsIG51bGwsIGZ1bmN0aW9uKiAoKSB7CiAgICBjb25zdCB0aWxlcyA9IHt9OwogICAgY29uc3QgdmFsaWRUaWxlSWRzID0gW107CiAgICBjb25zdCB0aWxlUHJvbWlzZXMgPSBbXTsKICAgIGZvciAoY29uc3QgdGlsZUlkIG9mIHRpbGVJZHMpIHsKICAgICAgY29uc3QgcGFydHMgPSB0aWxlSWQuc3BsaXQoIi4iKTsKICAgICAgY29uc3QgeiA9IHBhcnNlSW50KHBhcnRzWzBdLCAxMCk7CiAgICAgIGNvbnN0IHggPSBwYXJzZUludChwYXJ0c1sxXSwgMTApOwogICAgICBpZiAoTnVtYmVyLmlzTmFOKHgpIHx8IE51bWJlci5pc05hTih6KSkgewogICAgICAgIGNvbnNvbGUud2FybigiSW52YWxpZCB0aWxlIHpvb20gb3IgcG9zaXRpb246IiwgeiwgeCk7CiAgICAgICAgY29udGludWU7CiAgICAgIH0KICAgICAgdmFsaWRUaWxlSWRzLnB1c2godGlsZUlkKTsKICAgICAgdGlsZVByb21pc2VzLnB1c2godGlsZSh1aWQsIHosIHgpKTsKICAgIH0KICAgIHJldHVybiBQcm9taXNlLmFsbCh0aWxlUHJvbWlzZXMpLnRoZW4oKHZhbHVlczIpID0+IHsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMyLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgY29uc3QgdmFsaWRUaWxlSWQgPSB2YWxpZFRpbGVJZHNbaV07CiAgICAgICAgdGlsZXNbdmFsaWRUaWxlSWRdID0gdmFsdWVzMltpXTsKICAgICAgICB0aWxlc1t2YWxpZFRpbGVJZF0udGlsZVBvc2l0aW9uSWQgPSB2YWxpZFRpbGVJZDsKICAgICAgfQogICAgICByZXR1cm4gdGlsZXM7CiAgICB9KTsKICB9KTsKICB2YXIgZ2V0VGFidWxhckRhdGEgPSAodWlkLCB0aWxlSWRzKSA9PiB7CiAgICBjb25zdCBkYXRhID0gW107CiAgICB0aWxlSWRzLmZvckVhY2goKHRpbGVJZCkgPT4gewogICAgICBjb25zdCBwYXJ0cyA9IHRpbGVJZC5zcGxpdCgiLiIpOwogICAgICBjb25zdCB6ID0gcGFyc2VJbnQocGFydHNbMF0sIDEwKTsKICAgICAgY29uc3QgeCA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7CiAgICAgIGNvbnN0IHRpbGVWYWx1ZSA9IHRpbGVWYWx1ZXNbYCR7dWlkfS4ke3p9LiR7eH1gXTsKICAgICAgaWYgKCF0aWxlVmFsdWUpIHsKICAgICAgICBjb25zb2xlLndhcm4oYE5vIHRpbGUgZGF0YSBjb25zdHJ1Y3RlZCAoJHt0aWxlSWR9KWApOwogICAgICB9CiAgICAgIGRhdGEucHVzaCh0aWxlVmFsdWUpOwogICAgfSk7CiAgICBsZXQgb3V0cHV0ID0gT2JqZWN0LnZhbHVlcyhkYXRhKS5mbGF0KCk7CiAgICBjb25zdCBzYW1wbGVMZW5ndGggPSBkYXRhU291cmNlcy5nZXQodWlkKS5vcHRpb25zLnNhbXBsZUxlbmd0aDsKICAgIGlmIChvdXRwdXQubGVuZ3RoID49IHNhbXBsZUxlbmd0aCkgewogICAgICBjb25zdCBoaWdoUHJpb3JpdHkgPSBvdXRwdXQuc29ydCgoYSwgYikgPT4gewogICAgICAgIHZhciBfYSwgX2I7CiAgICAgICAgcmV0dXJuIC0oKF9hID0gYS5ESVNUUFJFVikgIT0gbnVsbCA/IF9hIDogMCkgKyAoKF9iID0gYi5ESVNUUFJFVikgIT0gbnVsbCA/IF9iIDogMCk7CiAgICAgIH0pLnNsaWNlKDAsIHNhbXBsZUxlbmd0aCAvIDIpOwogICAgICBvdXRwdXQgPSBzYW1wbGVTaXplX2RlZmF1bHQob3V0cHV0LCBzYW1wbGVMZW5ndGggLyAyKS5jb25jYXQoaGlnaFByaW9yaXR5KTsKICAgIH0KICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShKU09OLnN0cmluZ2lmeShvdXRwdXQpKS5idWZmZXI7CiAgICByZXR1cm4gVHJhbnNmZXIoYnVmZmVyLCBbYnVmZmVyXSk7CiAgfTsKICB2YXIgdGlsZUZ1bmN0aW9ucyA9IHsKICAgIGluaXQsCiAgICB0aWxlc2V0SW5mbywKICAgIGZldGNoVGlsZXNEZWJvdW5jZWQsCiAgICB0aWxlLAogICAgZ2V0VGFidWxhckRhdGEKICB9OwogIGV4cG9zZSh0aWxlRnVuY3Rpb25zKTsKfSkoKTsKLyohCiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLgogKgogKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPgogKiBAbGljZW5zZSAgTUlUCiAqLwovKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqLwovKioKICogQGxpY2Vuc2UKICogTG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPgogKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9ImVzIiAtbyAuL2AKICogQ29weXJpZ2h0IE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vb3BlbmpzZi5vcmcvPgogKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+CiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+CiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9ycwogKi8K";
const blob = typeof window !== "undefined" && window.Blob && new Blob([atob(encodedJs)], { type: "text/javascript;charset=utf-8" });
function Worker$1() {
  const objURL = blob && (window.URL || window.webkitURL).createObjectURL(blob);
  try {
    return objURL ? new Worker(objURL) : new Worker("data:application/javascript;base64," + encodedJs, { type: "module" });
  } finally {
    objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
  }
}
const DEBOUNCE_TIME = 200;
class VcfDataFetcher {
  constructor(HGC, config2) {
    this.dataConfig = {};
    this.uid = HGC.libraries.slugid.nice();
    this.prevRequestTime = 0;
    this.toFetch = /* @__PURE__ */ new Set();
    const { url, indexUrl, assembly, ...options } = config2;
    this.worker = spawn(new Worker$1()).then(async (worker) => {
      const chromSizes = Object.entries(computeChromSizes(assembly).size);
      await worker.init(this.uid, { url, indexUrl }, chromSizes, options);
      return worker;
    });
  }
  async tilesetInfo(callback) {
    (await this.worker).tilesetInfo(this.uid).then(callback);
  }
  fetchTilesDebounced(receivedTiles, tileIds) {
    this.track.drawLoadingCue();
    tileIds.forEach((tileId) => this.toFetch.add(tileId));
    if (this.fetchTimeout) {
      clearTimeout(this.fetchTimeout);
    }
    this.fetchTimeout = setTimeout(() => {
      this.sendFetch(receivedTiles, [...this.toFetch]);
      this.toFetch.clear();
    }, DEBOUNCE_TIME);
  }
  async sendFetch(receivedTiles, tileIds) {
    (await this.worker).fetchTilesDebounced(this.uid, tileIds).then(receivedTiles);
  }
  async getTabularData(tileIds) {
    const buf = await (await this.worker).getTabularData(this.uid, tileIds);
    return JSON.parse(new TextDecoder().decode(buf));
  }
}
VcfDataFetcher.config = { type: "vcf" };
var dist$1 = {};
var bigwig = {};
var interopRequireDefault = { exports: {} };
(function(module) {
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }
  module.exports = _interopRequireDefault2;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(interopRequireDefault);
var runtime = { exports: {} };
(function(module) {
  var runtime2 = function(exports) {
    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1;
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function(obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self2, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context2 = new Context3(tryLocsList || []);
      generator._invoke = makeInvokeMethod(innerFn, self2, context2);
      return generator;
    }
    exports.wrap = wrap;
    function tryCatch(fn, obj, arg) {
      try {
        return { type: "normal", arg: fn.call(obj, arg) };
      } catch (err) {
        return { type: "throw", arg: err };
      }
    }
    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";
    var ContinueSentinel = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function() {
      return this;
    });
    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      IteratorPrototype = NativeIteratorPrototype;
    }
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = GeneratorFunctionPrototype;
    define(Gp, "constructor", GeneratorFunctionPrototype);
    define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method) {
        define(prototype, method, function(arg) {
          return this._invoke(method, arg);
        });
      });
    }
    exports.isGeneratorFunction = function(genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };
    exports.mark = function(genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };
    exports.awrap = function(arg) {
      return { __await: arg };
    };
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve2, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function(value2) {
              invoke("next", value2, resolve2, reject);
            }, function(err) {
              invoke("throw", err, resolve2, reject);
            });
          }
          return PromiseImpl.resolve(value).then(function(unwrapped) {
            result.value = unwrapped;
            resolve2(result);
          }, function(error) {
            return invoke("throw", error, resolve2, reject);
          });
        }
      }
      var previousPromise;
      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve2, reject) {
            invoke(method, arg, resolve2, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
      this._invoke = enqueue;
    }
    defineIteratorMethods(AsyncIterator.prototype);
    define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
      return this;
    });
    exports.AsyncIterator = AsyncIterator;
    exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0)
        PromiseImpl = Promise;
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
        return result.done ? result.value : iter.next();
      });
    };
    function makeInvokeMethod(innerFn, self2, context2) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }
        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }
          return doneResult();
        }
        context2.method = method;
        context2.arg = arg;
        while (true) {
          var delegate = context2.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context2);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel)
                continue;
              return delegateResult;
            }
          }
          if (context2.method === "next") {
            context2.sent = context2._sent = context2.arg;
          } else if (context2.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context2.arg;
            }
            context2.dispatchException(context2.arg);
          } else if (context2.method === "return") {
            context2.abrupt("return", context2.arg);
          }
          state = GenStateExecuting;
          var record = tryCatch(innerFn, self2, context2);
          if (record.type === "normal") {
            state = context2.done ? GenStateCompleted : GenStateSuspendedYield;
            if (record.arg === ContinueSentinel) {
              continue;
            }
            return {
              value: record.arg,
              done: context2.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted;
            context2.method = "throw";
            context2.arg = record.arg;
          }
        }
      };
    }
    function maybeInvokeDelegate(delegate, context2) {
      var method = delegate.iterator[context2.method];
      if (method === undefined$1) {
        context2.delegate = null;
        if (context2.method === "throw") {
          if (delegate.iterator["return"]) {
            context2.method = "return";
            context2.arg = undefined$1;
            maybeInvokeDelegate(delegate, context2);
            if (context2.method === "throw") {
              return ContinueSentinel;
            }
          }
          context2.method = "throw";
          context2.arg = new TypeError("The iterator does not provide a 'throw' method");
        }
        return ContinueSentinel;
      }
      var record = tryCatch(method, delegate.iterator, context2.arg);
      if (record.type === "throw") {
        context2.method = "throw";
        context2.arg = record.arg;
        context2.delegate = null;
        return ContinueSentinel;
      }
      var info = record.arg;
      if (!info) {
        context2.method = "throw";
        context2.arg = new TypeError("iterator result is not an object");
        context2.delegate = null;
        return ContinueSentinel;
      }
      if (info.done) {
        context2[delegate.resultName] = info.value;
        context2.next = delegate.nextLoc;
        if (context2.method !== "return") {
          context2.method = "next";
          context2.arg = undefined$1;
        }
      } else {
        return info;
      }
      context2.delegate = null;
      return ContinueSentinel;
    }
    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator");
    define(Gp, iteratorSymbol, function() {
      return this;
    });
    define(Gp, "toString", function() {
      return "[object Generator]";
    });
    function pushTryEntry(locs) {
      var entry = { tryLoc: locs[0] };
      if (1 in locs) {
        entry.catchLoc = locs[1];
      }
      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }
      this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }
    function Context3(tryLocsList) {
      this.tryEntries = [{ tryLoc: "root" }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }
    exports.keys = function(object) {
      var keys = [];
      for (var key in object) {
        keys.push(key);
      }
      keys.reverse();
      return function next() {
        while (keys.length) {
          var key2 = keys.pop();
          if (key2 in object) {
            next.value = key2;
            next.done = false;
            return next;
          }
        }
        next.done = true;
        return next;
      };
    };
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }
        if (typeof iterable.next === "function") {
          return iterable;
        }
        if (!isNaN(iterable.length)) {
          var i = -1, next = function next2() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next2.value = iterable[i];
                next2.done = false;
                return next2;
              }
            }
            next2.value = undefined$1;
            next2.done = true;
            return next2;
          };
          return next.next = next;
        }
      }
      return { next: doneResult };
    }
    exports.values = values;
    function doneResult() {
      return { value: undefined$1, done: true };
    }
    Context3.prototype = {
      constructor: Context3,
      reset: function(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);
        if (!skipTempReset) {
          for (var name2 in this) {
            if (name2.charAt(0) === "t" && hasOwn.call(this, name2) && !isNaN(+name2.slice(1))) {
              this[name2] = undefined$1;
            }
          }
        }
      },
      stop: function() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }
        return this.rval;
      },
      dispatchException: function(exception) {
        if (this.done) {
          throw exception;
        }
        var context2 = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context2.next = loc;
          if (caught) {
            context2.method = "next";
            context2.arg = undefined$1;
          }
          return !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;
          if (entry.tryLoc === "root") {
            return handle("end");
          }
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function(type2, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        if (finallyEntry && (type2 === "break" || type2 === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          finallyEntry = null;
        }
        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type2;
        record.arg = arg;
        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }
        return this.complete(record);
      },
      complete: function(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }
        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }
        return ContinueSentinel;
      },
      finish: function(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName,
          nextLoc
        };
        if (this.method === "next") {
          this.arg = undefined$1;
        }
        return ContinueSentinel;
      }
    };
    return exports;
  }(module.exports);
  try {
    regeneratorRuntime = runtime2;
  } catch (accidentalStrictMode) {
    if (typeof globalThis === "object") {
      globalThis.regeneratorRuntime = runtime2;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime2);
    }
  }
})(runtime);
var regenerator = runtime.exports;
var asyncToGenerator = { exports: {} };
(function(module) {
  function asyncGeneratorStep(gen, resolve2, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve2(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve2, reject) {
        var gen = fn.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "throw", err);
        }
        _next(void 0);
      });
    };
  }
  module.exports = _asyncToGenerator;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(asyncToGenerator);
var classCallCheck = { exports: {} };
(function(module) {
  function _classCallCheck3(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  module.exports = _classCallCheck3;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(classCallCheck);
var createClass = { exports: {} };
(function(module) {
  function _defineProperties2(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass3(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties2(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties2(Constructor, staticProps);
    return Constructor;
  }
  module.exports = _createClass3;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(createClass);
var inherits = { exports: {} };
var setPrototypeOf = { exports: {} };
(function(module) {
  function _setPrototypeOf2(o, p) {
    module.exports = _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    module.exports["default"] = module.exports, module.exports.__esModule = true;
    return _setPrototypeOf2(o, p);
  }
  module.exports = _setPrototypeOf2;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(setPrototypeOf);
(function(module) {
  var setPrototypeOf$1 = setPrototypeOf.exports;
  function _inherits3(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass)
      setPrototypeOf$1(subClass, superClass);
  }
  module.exports = _inherits3;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(inherits);
var possibleConstructorReturn = { exports: {} };
var _typeof$2 = { exports: {} };
(function(module) {
  function _typeof3(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      module.exports = _typeof3 = function _typeof4(obj2) {
        return typeof obj2;
      };
      module.exports["default"] = module.exports, module.exports.__esModule = true;
    } else {
      module.exports = _typeof3 = function _typeof4(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
      module.exports["default"] = module.exports, module.exports.__esModule = true;
    }
    return _typeof3(obj);
  }
  module.exports = _typeof3;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(_typeof$2);
var assertThisInitialized = { exports: {} };
(function(module) {
  function _assertThisInitialized3(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  module.exports = _assertThisInitialized3;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(assertThisInitialized);
(function(module) {
  var _typeof3 = _typeof$2.exports["default"];
  var assertThisInitialized$1 = assertThisInitialized.exports;
  function _possibleConstructorReturn3(self2, call) {
    if (call && (_typeof3(call) === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return assertThisInitialized$1(self2);
  }
  module.exports = _possibleConstructorReturn3;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(possibleConstructorReturn);
var getPrototypeOf = { exports: {} };
(function(module) {
  function _getPrototypeOf3(o) {
    module.exports = _getPrototypeOf3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf4(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    module.exports["default"] = module.exports, module.exports.__esModule = true;
    return _getPrototypeOf3(o);
  }
  module.exports = _getPrototypeOf3;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(getPrototypeOf);
var blockView = {};
var defineProperty = { exports: {} };
(function(module) {
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  module.exports = _defineProperty;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(defineProperty);
var binary_parser = {};
var vmBrowser = {};
function runInThisContext(code) {
  const fn = new Function("code", "return eval(code);");
  return fn.call(globalThis, code);
}
vmBrowser.runInThisContext = runInThisContext;
var context = {};
function _typeof$1(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function _typeof3(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1 = function _typeof3(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1(obj);
}
var Context$2 = function Context() {
  this.code = "";
  this.scopes = [["vars"]];
  this.isAsync = false;
  this.bitFields = [];
  this.tmpVariableCount = 0;
  this.references = {};
};
Context$2.prototype.generateVariable = function(name2) {
  var arr = [];
  Array.prototype.push.apply(arr, this.scopes[this.scopes.length - 1]);
  while (/^\$parent\./.test(name2)) {
    arr.pop();
    name2 = name2.replace(/^\$parent\./, "");
  }
  if (name2) {
    arr.push(name2);
  }
  return arr.join(".");
};
Context$2.prototype.generateOption = function(val) {
  switch (_typeof$1(val)) {
    case "number":
      return val.toString();
    case "string":
      return this.generateVariable(val);
    case "function":
      return "(".concat(val, ").call(").concat(this.generateVariable(), ", vars)");
    default:
      return void 0;
  }
};
Context$2.prototype.generateError = function() {
  var args = Array.prototype.slice.call(arguments);
  var err = Context$2.interpolate.apply(this, args);
  if (this.isAsync) {
    this.pushCode("return process.nextTick(function() { callback(new Error(".concat(err, "), vars); });"));
  } else {
    this.pushCode("throw new Error(".concat(err, ");"));
  }
};
Context$2.prototype.generateTmpVariable = function() {
  return "$tmp".concat(this.tmpVariableCount++);
};
Context$2.prototype.pushCode = function() {
  var args = Array.prototype.slice.call(arguments);
  this.code += "".concat(Context$2.interpolate.apply(this, args), "\n");
};
Context$2.prototype.pushPath = function(name2) {
  if (name2) {
    this.scopes[this.scopes.length - 1].push(name2);
  }
};
Context$2.prototype.popPath = function(name2) {
  if (name2) {
    this.scopes[this.scopes.length - 1].pop();
  }
};
Context$2.prototype.pushScope = function(name2) {
  this.scopes.push([name2]);
};
Context$2.prototype.popScope = function() {
  this.scopes.pop();
};
Context$2.prototype.addReference = function(alias) {
  if (this.references[alias])
    return;
  this.references[alias] = { resolved: false, requested: false };
};
Context$2.prototype.markResolved = function(alias) {
  this.references[alias].resolved = true;
};
Context$2.prototype.markRequested = function(aliasList) {
  aliasList.forEach(function(alias) {
    this.references[alias].requested = true;
  }.bind(this));
};
Context$2.prototype.getUnresolvedReferences = function() {
  var references = this.references;
  return Object.keys(this.references).filter(function(alias) {
    return !references[alias].resolved && !references[alias].requested;
  });
};
Context$2.interpolate = function(s) {
  var re2 = /{\d+}/g;
  var matches = s.match(re2);
  var params = Array.prototype.slice.call(arguments, 1);
  if (matches) {
    matches.forEach(function(match) {
      var index = parseInt(match.substr(1, match.length - 2), 10);
      s = s.replace(match, params[index].toString());
    });
  }
  return s;
};
context.Context = Context$2;
var long = Long$1;
var wasm = null;
try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    13,
    2,
    96,
    0,
    1,
    127,
    96,
    4,
    127,
    127,
    127,
    127,
    1,
    127,
    3,
    7,
    6,
    0,
    1,
    1,
    1,
    1,
    1,
    6,
    6,
    1,
    127,
    1,
    65,
    0,
    11,
    7,
    50,
    6,
    3,
    109,
    117,
    108,
    0,
    1,
    5,
    100,
    105,
    118,
    95,
    115,
    0,
    2,
    5,
    100,
    105,
    118,
    95,
    117,
    0,
    3,
    5,
    114,
    101,
    109,
    95,
    115,
    0,
    4,
    5,
    114,
    101,
    109,
    95,
    117,
    0,
    5,
    8,
    103,
    101,
    116,
    95,
    104,
    105,
    103,
    104,
    0,
    0,
    10,
    191,
    1,
    6,
    4,
    0,
    35,
    0,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    126,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    127,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    128,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    129,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    130,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11
  ])), {}).exports;
} catch (e) {
}
function Long$1(low, high, unsigned) {
  this.low = low | 0;
  this.high = high | 0;
  this.unsigned = !!unsigned;
}
Long$1.prototype.__isLong__;
Object.defineProperty(Long$1.prototype, "__isLong__", { value: true });
function isLong(obj) {
  return (obj && obj["__isLong__"]) === true;
}
Long$1.isLong = isLong;
var INT_CACHE = {};
var UINT_CACHE = {};
function fromInt(value, unsigned) {
  var obj, cachedObj, cache2;
  if (unsigned) {
    value >>>= 0;
    if (cache2 = 0 <= value && value < 256) {
      cachedObj = UINT_CACHE[value];
      if (cachedObj)
        return cachedObj;
    }
    obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
    if (cache2)
      UINT_CACHE[value] = obj;
    return obj;
  } else {
    value |= 0;
    if (cache2 = -128 <= value && value < 128) {
      cachedObj = INT_CACHE[value];
      if (cachedObj)
        return cachedObj;
    }
    obj = fromBits(value, value < 0 ? -1 : 0, false);
    if (cache2)
      INT_CACHE[value] = obj;
    return obj;
  }
}
Long$1.fromInt = fromInt;
function fromNumber(value, unsigned) {
  if (isNaN(value))
    return unsigned ? UZERO : ZERO;
  if (unsigned) {
    if (value < 0)
      return UZERO;
    if (value >= TWO_PWR_64_DBL)
      return MAX_UNSIGNED_VALUE;
  } else {
    if (value <= -TWO_PWR_63_DBL)
      return MIN_VALUE;
    if (value + 1 >= TWO_PWR_63_DBL)
      return MAX_VALUE;
  }
  if (value < 0)
    return fromNumber(-value, unsigned).neg();
  return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
}
Long$1.fromNumber = fromNumber;
function fromBits(lowBits, highBits, unsigned) {
  return new Long$1(lowBits, highBits, unsigned);
}
Long$1.fromBits = fromBits;
var pow_dbl = Math.pow;
function fromString(str, unsigned, radix) {
  if (str.length === 0)
    throw Error("empty string");
  if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
    return ZERO;
  if (typeof unsigned === "number") {
    radix = unsigned, unsigned = false;
  } else {
    unsigned = !!unsigned;
  }
  radix = radix || 10;
  if (radix < 2 || 36 < radix)
    throw RangeError("radix");
  var p;
  if ((p = str.indexOf("-")) > 0)
    throw Error("interior hyphen");
  else if (p === 0) {
    return fromString(str.substring(1), unsigned, radix).neg();
  }
  var radixToPower = fromNumber(pow_dbl(radix, 8));
  var result = ZERO;
  for (var i = 0; i < str.length; i += 8) {
    var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
    if (size < 8) {
      var power = fromNumber(pow_dbl(radix, size));
      result = result.mul(power).add(fromNumber(value));
    } else {
      result = result.mul(radixToPower);
      result = result.add(fromNumber(value));
    }
  }
  result.unsigned = unsigned;
  return result;
}
Long$1.fromString = fromString;
function fromValue(val, unsigned) {
  if (typeof val === "number")
    return fromNumber(val, unsigned);
  if (typeof val === "string")
    return fromString(val, unsigned);
  return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
}
Long$1.fromValue = fromValue;
var TWO_PWR_16_DBL = 1 << 16;
var TWO_PWR_24_DBL = 1 << 24;
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
var ZERO = fromInt(0);
Long$1.ZERO = ZERO;
var UZERO = fromInt(0, true);
Long$1.UZERO = UZERO;
var ONE = fromInt(1);
Long$1.ONE = ONE;
var UONE = fromInt(1, true);
Long$1.UONE = UONE;
var NEG_ONE = fromInt(-1);
Long$1.NEG_ONE = NEG_ONE;
var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
Long$1.MAX_VALUE = MAX_VALUE;
var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
Long$1.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
Long$1.MIN_VALUE = MIN_VALUE;
var LongPrototype = Long$1.prototype;
LongPrototype.toInt = function toInt() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
LongPrototype.toNumber = function toNumber() {
  if (this.unsigned)
    return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
  return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};
LongPrototype.toString = function toString(radix) {
  radix = radix || 10;
  if (radix < 2 || 36 < radix)
    throw RangeError("radix");
  if (this.isZero())
    return "0";
  if (this.isNegative()) {
    if (this.eq(MIN_VALUE)) {
      var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
      return div.toString(radix) + rem1.toInt().toString(radix);
    } else
      return "-" + this.neg().toString(radix);
  }
  var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
  var result = "";
  while (true) {
    var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
    rem = remDiv;
    if (rem.isZero())
      return digits + result;
    else {
      while (digits.length < 6)
        digits = "0" + digits;
      result = "" + digits + result;
    }
  }
};
LongPrototype.getHighBits = function getHighBits() {
  return this.high;
};
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
  return this.high >>> 0;
};
LongPrototype.getLowBits = function getLowBits() {
  return this.low;
};
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
  return this.low >>> 0;
};
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
  if (this.isNegative())
    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
  var val = this.high != 0 ? this.high : this.low;
  for (var bit = 31; bit > 0; bit--)
    if ((val & 1 << bit) != 0)
      break;
  return this.high != 0 ? bit + 33 : bit + 1;
};
LongPrototype.isZero = function isZero() {
  return this.high === 0 && this.low === 0;
};
LongPrototype.eqz = LongPrototype.isZero;
LongPrototype.isNegative = function isNegative() {
  return !this.unsigned && this.high < 0;
};
LongPrototype.isPositive = function isPositive() {
  return this.unsigned || this.high >= 0;
};
LongPrototype.isOdd = function isOdd() {
  return (this.low & 1) === 1;
};
LongPrototype.isEven = function isEven() {
  return (this.low & 1) === 0;
};
LongPrototype.equals = function equals(other) {
  if (!isLong(other))
    other = fromValue(other);
  if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
    return false;
  return this.high === other.high && this.low === other.low;
};
LongPrototype.eq = LongPrototype.equals;
LongPrototype.notEquals = function notEquals(other) {
  return !this.eq(other);
};
LongPrototype.neq = LongPrototype.notEquals;
LongPrototype.ne = LongPrototype.notEquals;
LongPrototype.lessThan = function lessThan(other) {
  return this.comp(other) < 0;
};
LongPrototype.lt = LongPrototype.lessThan;
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
  return this.comp(other) <= 0;
};
LongPrototype.lte = LongPrototype.lessThanOrEqual;
LongPrototype.le = LongPrototype.lessThanOrEqual;
LongPrototype.greaterThan = function greaterThan(other) {
  return this.comp(other) > 0;
};
LongPrototype.gt = LongPrototype.greaterThan;
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
  return this.comp(other) >= 0;
};
LongPrototype.gte = LongPrototype.greaterThanOrEqual;
LongPrototype.ge = LongPrototype.greaterThanOrEqual;
LongPrototype.compare = function compare(other) {
  if (!isLong(other))
    other = fromValue(other);
  if (this.eq(other))
    return 0;
  var thisNeg = this.isNegative(), otherNeg = other.isNegative();
  if (thisNeg && !otherNeg)
    return -1;
  if (!thisNeg && otherNeg)
    return 1;
  if (!this.unsigned)
    return this.sub(other).isNegative() ? -1 : 1;
  return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
};
LongPrototype.comp = LongPrototype.compare;
LongPrototype.negate = function negate() {
  if (!this.unsigned && this.eq(MIN_VALUE))
    return MIN_VALUE;
  return this.not().add(ONE);
};
LongPrototype.neg = LongPrototype.negate;
LongPrototype.add = function add(addend) {
  if (!isLong(addend))
    addend = fromValue(addend);
  var a48 = this.high >>> 16;
  var a32 = this.high & 65535;
  var a16 = this.low >>> 16;
  var a00 = this.low & 65535;
  var b48 = addend.high >>> 16;
  var b32 = addend.high & 65535;
  var b16 = addend.low >>> 16;
  var b00 = addend.low & 65535;
  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 + b00;
  c16 += c00 >>> 16;
  c00 &= 65535;
  c16 += a16 + b16;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c32 += a32 + b32;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c48 += a48 + b48;
  c48 &= 65535;
  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
LongPrototype.subtract = function subtract(subtrahend) {
  if (!isLong(subtrahend))
    subtrahend = fromValue(subtrahend);
  return this.add(subtrahend.neg());
};
LongPrototype.sub = LongPrototype.subtract;
LongPrototype.multiply = function multiply(multiplier) {
  if (this.isZero())
    return ZERO;
  if (!isLong(multiplier))
    multiplier = fromValue(multiplier);
  if (wasm) {
    var low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
    return fromBits(low, wasm.get_high(), this.unsigned);
  }
  if (multiplier.isZero())
    return ZERO;
  if (this.eq(MIN_VALUE))
    return multiplier.isOdd() ? MIN_VALUE : ZERO;
  if (multiplier.eq(MIN_VALUE))
    return this.isOdd() ? MIN_VALUE : ZERO;
  if (this.isNegative()) {
    if (multiplier.isNegative())
      return this.neg().mul(multiplier.neg());
    else
      return this.neg().mul(multiplier).neg();
  } else if (multiplier.isNegative())
    return this.mul(multiplier.neg()).neg();
  if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
    return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
  var a48 = this.high >>> 16;
  var a32 = this.high & 65535;
  var a16 = this.low >>> 16;
  var a00 = this.low & 65535;
  var b48 = multiplier.high >>> 16;
  var b32 = multiplier.high & 65535;
  var b16 = multiplier.low >>> 16;
  var b00 = multiplier.low & 65535;
  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 * b00;
  c16 += c00 >>> 16;
  c00 &= 65535;
  c16 += a16 * b00;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c16 += a00 * b16;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c32 += a32 * b00;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c32 += a16 * b16;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c32 += a00 * b32;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &= 65535;
  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
LongPrototype.mul = LongPrototype.multiply;
LongPrototype.divide = function divide(divisor) {
  if (!isLong(divisor))
    divisor = fromValue(divisor);
  if (divisor.isZero())
    throw Error("division by zero");
  if (wasm) {
    if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
      return this;
    }
    var low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
    return fromBits(low, wasm.get_high(), this.unsigned);
  }
  if (this.isZero())
    return this.unsigned ? UZERO : ZERO;
  var approx, rem, res;
  if (!this.unsigned) {
    if (this.eq(MIN_VALUE)) {
      if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
        return MIN_VALUE;
      else if (divisor.eq(MIN_VALUE))
        return ONE;
      else {
        var halfThis = this.shr(1);
        approx = halfThis.div(divisor).shl(1);
        if (approx.eq(ZERO)) {
          return divisor.isNegative() ? ONE : NEG_ONE;
        } else {
          rem = this.sub(divisor.mul(approx));
          res = approx.add(rem.div(divisor));
          return res;
        }
      }
    } else if (divisor.eq(MIN_VALUE))
      return this.unsigned ? UZERO : ZERO;
    if (this.isNegative()) {
      if (divisor.isNegative())
        return this.neg().div(divisor.neg());
      return this.neg().div(divisor).neg();
    } else if (divisor.isNegative())
      return this.div(divisor.neg()).neg();
    res = ZERO;
  } else {
    if (!divisor.unsigned)
      divisor = divisor.toUnsigned();
    if (divisor.gt(this))
      return UZERO;
    if (divisor.gt(this.shru(1)))
      return UONE;
    res = UZERO;
  }
  rem = this;
  while (rem.gte(divisor)) {
    approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
    var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
    while (approxRem.isNegative() || approxRem.gt(rem)) {
      approx -= delta;
      approxRes = fromNumber(approx, this.unsigned);
      approxRem = approxRes.mul(divisor);
    }
    if (approxRes.isZero())
      approxRes = ONE;
    res = res.add(approxRes);
    rem = rem.sub(approxRem);
  }
  return res;
};
LongPrototype.div = LongPrototype.divide;
LongPrototype.modulo = function modulo(divisor) {
  if (!isLong(divisor))
    divisor = fromValue(divisor);
  if (wasm) {
    var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
    return fromBits(low, wasm.get_high(), this.unsigned);
  }
  return this.sub(this.div(divisor).mul(divisor));
};
LongPrototype.mod = LongPrototype.modulo;
LongPrototype.rem = LongPrototype.modulo;
LongPrototype.not = function not() {
  return fromBits(~this.low, ~this.high, this.unsigned);
};
LongPrototype.and = function and(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};
LongPrototype.or = function or(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};
LongPrototype.xor = function xor(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};
LongPrototype.shiftLeft = function shiftLeft(numBits) {
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  else if (numBits < 32)
    return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
  else
    return fromBits(0, this.low << numBits - 32, this.unsigned);
};
LongPrototype.shl = LongPrototype.shiftLeft;
LongPrototype.shiftRight = function shiftRight(numBits) {
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  else if (numBits < 32)
    return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
  else
    return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
};
LongPrototype.shr = LongPrototype.shiftRight;
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
  if (isLong(numBits))
    numBits = numBits.toInt();
  numBits &= 63;
  if (numBits === 0)
    return this;
  else {
    var high = this.high;
    if (numBits < 32) {
      var low = this.low;
      return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
    } else if (numBits === 32)
      return fromBits(high, 0, this.unsigned);
    else
      return fromBits(high >>> numBits - 32, 0, this.unsigned);
  }
};
LongPrototype.shru = LongPrototype.shiftRightUnsigned;
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
LongPrototype.toSigned = function toSigned() {
  if (!this.unsigned)
    return this;
  return fromBits(this.low, this.high, false);
};
LongPrototype.toUnsigned = function toUnsigned() {
  if (this.unsigned)
    return this;
  return fromBits(this.low, this.high, true);
};
LongPrototype.toBytes = function toBytes(le) {
  return le ? this.toBytesLE() : this.toBytesBE();
};
LongPrototype.toBytesLE = function toBytesLE() {
  var hi = this.high, lo = this.low;
  return [
    lo & 255,
    lo >>> 8 & 255,
    lo >>> 16 & 255,
    lo >>> 24,
    hi & 255,
    hi >>> 8 & 255,
    hi >>> 16 & 255,
    hi >>> 24
  ];
};
LongPrototype.toBytesBE = function toBytesBE() {
  var hi = this.high, lo = this.low;
  return [
    hi >>> 24,
    hi >>> 16 & 255,
    hi >>> 8 & 255,
    hi & 255,
    lo >>> 24,
    lo >>> 16 & 255,
    lo >>> 8 & 255,
    lo & 255
  ];
};
Long$1.fromBytes = function fromBytes(bytes, unsigned, le) {
  return le ? Long$1.fromBytesLE(bytes, unsigned) : Long$1.fromBytesBE(bytes, unsigned);
};
Long$1.fromBytesLE = function fromBytesLE(bytes, unsigned) {
  return new Long$1(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
};
Long$1.fromBytesBE = function fromBytesBE(bytes, unsigned) {
  return new Long$1(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
};
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof3(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof3(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
var _require = require$$0, Buffer$1 = _require.Buffer;
var vm = vmBrowser;
var Context$1 = context.Context;
var Long = long;
if (typeof window !== "undefined")
  window.Buffer = Buffer$1;
if (typeof self !== "undefined")
  self.Buffer = Buffer$1;
var PRIMITIVE_TYPES = {
  UInt8: 1,
  UInt16LE: 2,
  UInt16BE: 2,
  UInt32LE: 4,
  UInt32BE: 4,
  Int8: 1,
  Int16LE: 2,
  Int16BE: 2,
  Int32LE: 4,
  Int32BE: 4,
  FloatLE: 4,
  FloatBE: 4,
  DoubleLE: 8,
  DoubleBE: 8,
  UInt64: 8,
  Int64: 8
};
var SPECIAL_TYPES = {
  String: null,
  Buffer: null,
  Array: null,
  Skip: null,
  Choice: null,
  Nest: null,
  Bit: null,
  Itf8: null,
  Ltf8: null
};
var aliasRegistry = {};
var FUNCTION_PREFIX = "___parser_";
var BIT_RANGE = [];
(function() {
  var i;
  for (i = 1; i <= 32; i++) {
    BIT_RANGE.push(i);
  }
})();
var NAME_MAP = {};
Object.keys(PRIMITIVE_TYPES).concat(Object.keys(SPECIAL_TYPES)).forEach(function(type2) {
  NAME_MAP[type2.toLowerCase()] = type2;
});
var Parser = function Parser2() {
  this.varName = "";
  this.type = "";
  this.options = {};
  this.next = null;
  this.head = null;
  this.compiled = null;
  this.endian = "le";
  this.constructorFn = null;
  this.alias = null;
};
Parser.start = function() {
  return new Parser();
};
Object.keys(PRIMITIVE_TYPES).forEach(function(type2) {
  Parser.prototype[type2.toLowerCase()] = function(varName, options) {
    return this.setNextParser(type2.toLowerCase(), varName, options);
  };
  var typeWithoutEndian = type2.replace(/BE|LE/, "").toLowerCase();
  if (!(typeWithoutEndian in Parser.prototype)) {
    Parser.prototype[typeWithoutEndian] = function(varName, options) {
      return this[typeWithoutEndian + this.endian](varName, options);
    };
  }
});
BIT_RANGE.forEach(function(i) {
  Parser.prototype["bit".concat(i.toString())] = function(varName, options) {
    if (!options) {
      options = {};
    }
    options.length = i;
    return this.setNextParser("bit", varName, options);
  };
});
Parser.prototype.namely = function(alias) {
  aliasRegistry[alias] = this;
  this.alias = alias;
  return this;
};
Parser.prototype.skip = function(length, options) {
  if (options && options.assert) {
    throw new Error("assert option on skip is not allowed.");
  }
  return this.setNextParser("skip", "", { length });
};
Parser.prototype.string = function(varName, options) {
  if (!options.zeroTerminated && !options.length && !options.greedy) {
    throw new Error("Neither length, zeroTerminated, nor greedy is defined for string.");
  }
  if ((options.zeroTerminated || options.length) && options.greedy) {
    throw new Error("greedy is mutually exclusive with length and zeroTerminated for string.");
  }
  if (options.stripNull && !(options.length || options.greedy)) {
    throw new Error("Length or greedy must be defined if stripNull is defined.");
  }
  options.encoding = options.encoding || "utf8";
  return this.setNextParser("string", varName, options);
};
Parser.prototype.buffer = function(varName, options) {
  if (!options.length && !options.readUntil) {
    throw new Error("Length nor readUntil is defined in buffer parser");
  }
  return this.setNextParser("buffer", varName, options);
};
Parser.prototype.array = function(varName, options) {
  if (!options.readUntil && !options.length && !options.lengthInBytes) {
    throw new Error("Length option of array is not defined.");
  }
  if (!options.type) {
    throw new Error("Type option of array is not defined.");
  }
  if (typeof options.type === "string" && !aliasRegistry[options.type] && Object.keys(PRIMITIVE_TYPES).indexOf(NAME_MAP[options.type]) < 0) {
    throw new Error('Specified primitive type "'.concat(options.type, '" is not supported.'));
  }
  return this.setNextParser("array", varName, options);
};
Parser.prototype.choice = function(varName, options) {
  if (arguments.length === 1 && _typeof(varName) === "object") {
    options = varName;
    varName = null;
  }
  if (!options.tag) {
    throw new Error("Tag option of array is not defined.");
  }
  if (!options.choices) {
    throw new Error("Choices option of array is not defined.");
  }
  Object.keys(options.choices).forEach(function(key) {
    if (!options.choices[key]) {
      throw new Error("Choice Case ".concat(key, " of ").concat(varName, " is not valid."));
    }
    if (typeof options.choices[key] === "string" && !aliasRegistry[options.choices[key]] && Object.keys(PRIMITIVE_TYPES).indexOf(NAME_MAP[options.choices[key]]) < 0) {
      throw new Error('Specified primitive type "'.concat(options.choices[key], '" is not supported.'));
    }
  }, this);
  return this.setNextParser("choice", varName, options);
};
Parser.prototype.nest = function(varName, options) {
  if (arguments.length === 1 && _typeof(varName) === "object") {
    options = varName;
    varName = null;
  }
  if (!options.type) {
    throw new Error("Type option of nest is not defined.");
  }
  if (!(options.type instanceof Parser) && !aliasRegistry[options.type]) {
    throw new Error("Type option of nest must be a Parser object.");
  }
  if (!(options.type instanceof Parser) && !varName) {
    throw new Error("options.type must be a object if variable name is omitted.");
  }
  return this.setNextParser("nest", varName, options);
};
Parser.prototype.endianess = function(endianess) {
  switch (endianess.toLowerCase()) {
    case "little":
      this.endian = "le";
      break;
    case "big":
      this.endian = "be";
      break;
    default:
      throw new Error("Invalid endianess: ".concat(endianess));
  }
  return this;
};
Parser.prototype.create = function(constructorFn) {
  if (!(constructorFn instanceof Function)) {
    throw new Error("Constructor must be a Function object.");
  }
  this.constructorFn = constructorFn;
  return this;
};
Parser.prototype.getCode = function() {
  var ctx = new Context$1();
  ctx.pushCode("if (!Buffer.isBuffer(buffer)) {");
  ctx.generateError('"argument buffer is not a Buffer object"');
  ctx.pushCode("}");
  if (!this.alias) {
    this.addRawCode(ctx);
  } else {
    this.addAliasedCode(ctx);
  }
  if (this.alias) {
    ctx.pushCode("return {0}(0)", FUNCTION_PREFIX + this.alias);
  } else {
    ctx.pushCode("return { offset: offset, result: vars };");
  }
  return ctx.code;
};
Parser.prototype.addRawCode = function(ctx) {
  ctx.pushCode("var offset = 0;");
  if (this.constructorFn) {
    ctx.pushCode("var vars = new constructorFn();");
  } else {
    ctx.pushCode("var vars = {};");
  }
  this.generate(ctx);
  this.resolveReferences(ctx);
  ctx.pushCode("return { offset: offset, result: vars };");
};
Parser.prototype.addAliasedCode = function(ctx) {
  ctx.pushCode("function {0}(offset) {", FUNCTION_PREFIX + this.alias);
  if (this.constructorFn) {
    ctx.pushCode("var vars = new constructorFn();");
  } else {
    ctx.pushCode("var vars = {};");
  }
  this.generate(ctx);
  ctx.markResolved(this.alias);
  this.resolveReferences(ctx);
  ctx.pushCode("return { offset: offset, result: vars };");
  ctx.pushCode("}");
  return ctx;
};
Parser.prototype.resolveReferences = function(ctx) {
  var references = ctx.getUnresolvedReferences();
  ctx.markRequested(references);
  references.forEach(function(alias) {
    var parser = aliasRegistry[alias];
    parser.addAliasedCode(ctx);
  });
};
Parser.prototype.compile = function() {
  var src = "(function(buffer, constructorFn, Long) { ".concat(this.getCode(), " })");
  this.compiled = vm.runInThisContext(src);
};
Parser.prototype.sizeOf = function() {
  var size = NaN;
  if (Object.keys(PRIMITIVE_TYPES).indexOf(this.type) >= 0) {
    size = PRIMITIVE_TYPES[this.type];
  } else if (this.type === "String" && typeof this.options.length === "number") {
    size = this.options.length;
  } else if (this.type === "Buffer" && typeof this.options.length === "number") {
    size = this.options.length;
  } else if (this.type === "Array" && typeof this.options.length === "number") {
    var elementSize = NaN;
    if (typeof this.options.type === "string") {
      elementSize = PRIMITIVE_TYPES[NAME_MAP[this.options.type]];
    } else if (this.options.type instanceof Parser) {
      elementSize = this.options.type.sizeOf();
    }
    size = this.options.length * elementSize;
  } else if (this.type === "Skip") {
    size = this.options.length;
  } else if (this.type === "Nest") {
    size = this.options.type.sizeOf();
  } else if (!this.type) {
    size = 0;
  }
  if (this.next) {
    size += this.next.sizeOf();
  }
  return size;
};
Parser.prototype.parse = function(buffer2) {
  if (!this.compiled) {
    this.compile();
  }
  return this.compiled(buffer2, this.constructorFn, Long);
};
Parser.prototype.setNextParser = function(type2, varName, options) {
  var parser = new Parser();
  parser.type = NAME_MAP[type2];
  parser.varName = varName;
  parser.options = options || parser.options;
  parser.endian = this.endian;
  if (this.head) {
    this.head.next = parser;
  } else {
    this.next = parser;
  }
  this.head = parser;
  return this;
};
Parser.prototype.generate = function(ctx) {
  if (this.type) {
    this["generate".concat(this.type)](ctx);
    this.generateAssert(ctx);
  }
  var varName = ctx.generateVariable(this.varName);
  if (this.options.formatter) {
    this.generateFormatter(ctx, varName, this.options.formatter);
  }
  return this.generateNext(ctx);
};
Parser.prototype.generateAssert = function(ctx) {
  if (!this.options.assert) {
    return;
  }
  var varName = ctx.generateVariable(this.varName);
  switch (_typeof(this.options.assert)) {
    case "function":
      ctx.pushCode("if (!({0}).call(vars, {1})) {", this.options.assert, varName);
      break;
    case "number":
      ctx.pushCode("if ({0} !== {1}) {", this.options.assert, varName);
      break;
    case "string":
      ctx.pushCode('if ("{0}" !== {1}) {', this.options.assert, varName);
      break;
    default:
      throw new Error("Assert option supports only strings, numbers and assert functions.");
  }
  ctx.generateError('"Assert error: {0} is " + {0}', varName);
  ctx.pushCode("}");
};
Parser.prototype.generateNext = function(ctx) {
  if (this.next) {
    ctx = this.next.generate(ctx);
  }
  return ctx;
};
Object.keys(PRIMITIVE_TYPES).forEach(function(type2) {
  Parser.prototype["generate".concat(type2)] = function(ctx) {
    if (type2 === "UInt64") {
      ctx.pushCode("{0} = Long.fromBytes(buffer.slice(offset,offset+8), true, this.endian === 'le').toNumber();", ctx.generateVariable(this.varName), type2);
    } else if (type2 === "Int64") {
      ctx.pushCode("{0} = Long.fromBytes(buffer.slice(offset,offset+8), false, this.endian === 'le').toNumber();", ctx.generateVariable(this.varName), type2);
    } else {
      ctx.pushCode("{0} = buffer.read{1}(offset);", ctx.generateVariable(this.varName), type2);
    }
    ctx.pushCode("offset += {0};", PRIMITIVE_TYPES[type2]);
  };
});
Parser.prototype.generateBit = function(ctx) {
  var parser = JSON.parse(JSON.stringify(this));
  parser.varName = ctx.generateVariable(parser.varName);
  ctx.bitFields.push(parser);
  if (!this.next || this.next && ["Bit", "Nest"].indexOf(this.next.type) < 0) {
    var sum2 = 0;
    ctx.bitFields.forEach(function(p) {
      sum2 += p.options.length;
    });
    var val = ctx.generateTmpVariable();
    if (sum2 <= 8) {
      ctx.pushCode("var {0} = buffer.readUInt8(offset);", val);
      sum2 = 8;
    } else if (sum2 <= 16) {
      ctx.pushCode("var {0} = buffer.readUInt16BE(offset);", val);
      sum2 = 16;
    } else if (sum2 <= 24) {
      var val1 = ctx.generateTmpVariable();
      var val2 = ctx.generateTmpVariable();
      ctx.pushCode("var {0} = buffer.readUInt16BE(offset);", val1);
      ctx.pushCode("var {0} = buffer.readUInt8(offset + 2);", val2);
      ctx.pushCode("var {2} = ({0} << 8) | {1};", val1, val2, val);
      sum2 = 24;
    } else if (sum2 <= 32) {
      ctx.pushCode("var {0} = buffer.readUInt32BE(offset);", val);
      sum2 = 32;
    } else {
      throw new Error("Currently, bit field sequence longer than 4-bytes is not supported.");
    }
    ctx.pushCode("offset += {0};", sum2 / 8);
    var bitOffset = 0;
    var isBigEndian = this.endian === "be";
    ctx.bitFields.forEach(function(p) {
      ctx.pushCode("{0} = {1} >> {2} & {3};", p.varName, val, isBigEndian ? sum2 - bitOffset - p.options.length : bitOffset, (1 << p.options.length) - 1);
      bitOffset += p.options.length;
    });
    ctx.bitFields = [];
  }
};
Parser.prototype.generateSkip = function(ctx) {
  var length = ctx.generateOption(this.options.length);
  ctx.pushCode("offset += {0};", length);
};
Parser.prototype.generateString = function(ctx) {
  var name2 = ctx.generateVariable(this.varName);
  var start = ctx.generateTmpVariable();
  if (this.options.length && this.options.zeroTerminated) {
    ctx.pushCode("var {0} = offset;", start);
    ctx.pushCode("while(buffer.readUInt8(offset++) !== 0 && offset - {0}  < {1});", start, this.options.length);
    ctx.pushCode("{0} = buffer.toString('{1}', {2}, offset - {2} < {3} ? offset - 1 : offset);", name2, this.options.encoding, start, this.options.length);
  } else if (this.options.length) {
    ctx.pushCode("{0} = buffer.toString('{1}', offset, offset + {2});", name2, this.options.encoding, ctx.generateOption(this.options.length));
    ctx.pushCode("offset += {0};", ctx.generateOption(this.options.length));
  } else if (this.options.zeroTerminated) {
    ctx.pushCode("var {0} = offset;", start);
    ctx.pushCode("while(buffer.readUInt8(offset++) !== 0);");
    ctx.pushCode("{0} = buffer.toString('{1}', {2}, offset - 1);", name2, this.options.encoding, start);
  } else if (this.options.greedy) {
    ctx.pushCode("var {0} = offset;", start);
    ctx.pushCode("while(buffer.length > offset++);");
    ctx.pushCode("{0} = buffer.toString('{1}', {2}, offset);", name2, this.options.encoding, start);
  }
  if (this.options.stripNull) {
    ctx.pushCode("{0} = {0}.replace(/\\x00+$/g, '')", name2);
  }
};
Parser.prototype.generateBuffer = function(ctx) {
  if (this.options.readUntil === "eof") {
    ctx.pushCode("{0} = buffer.slice(offset);", ctx.generateVariable(this.varName));
  } else {
    ctx.pushCode("{0} = buffer.slice(offset, offset + {1});", ctx.generateVariable(this.varName), ctx.generateOption(this.options.length));
    ctx.pushCode("offset += {0};", ctx.generateOption(this.options.length));
  }
  if (this.options.clone) {
    ctx.pushCode("{0} = Buffer.from({0});", ctx.generateVariable(this.varName));
  }
};
Parser.prototype.generateArray = function(ctx) {
  var length = ctx.generateOption(this.options.length);
  var lengthInBytes = ctx.generateOption(this.options.lengthInBytes);
  var type2 = this.options.type;
  var counter = ctx.generateTmpVariable();
  var lhs = ctx.generateVariable(this.varName);
  var item = ctx.generateTmpVariable();
  var key = this.options.key;
  var isHash = typeof key === "string";
  if (isHash) {
    ctx.pushCode("{0} = {};", lhs);
  } else {
    ctx.pushCode("{0} = [];", lhs);
  }
  if (typeof this.options.readUntil === "function") {
    ctx.pushCode("do {");
  } else if (this.options.readUntil === "eof") {
    ctx.pushCode("for (var {0} = 0; offset < buffer.length; {0}++) {", counter);
  } else if (lengthInBytes !== void 0) {
    ctx.pushCode("for (var {0} = offset; offset - {0} < {1}; ) {", counter, lengthInBytes);
  } else {
    ctx.pushCode("for (var {0} = 0; {0} < {1}; {0}++) {", counter, length);
  }
  if (typeof type2 === "string") {
    if (!aliasRegistry[type2]) {
      ctx.pushCode("var {0} = buffer.read{1}(offset);", item, NAME_MAP[type2]);
      ctx.pushCode("offset += {0};", PRIMITIVE_TYPES[NAME_MAP[type2]]);
    } else {
      var tempVar = ctx.generateTmpVariable();
      ctx.pushCode("var {0} = {1}(offset);", tempVar, FUNCTION_PREFIX + type2);
      ctx.pushCode("var {0} = {1}.result; offset = {1}.offset;", item, tempVar);
      if (type2 !== this.alias)
        ctx.addReference(type2);
    }
  } else if (type2 instanceof Parser) {
    ctx.pushCode("var {0} = {};", item);
    ctx.pushScope(item);
    type2.generate(ctx);
    ctx.popScope();
  }
  if (isHash) {
    ctx.pushCode("{0}[{2}.{1}] = {2};", lhs, key, item);
  } else {
    ctx.pushCode("{0}.push({1});", lhs, item);
  }
  ctx.pushCode("}");
  if (typeof this.options.readUntil === "function") {
    ctx.pushCode(" while (!({0}).call(this, {1}, buffer.slice(offset)));", this.options.readUntil, item);
  }
};
Parser.prototype.generateChoiceCase = function(ctx, varName, type2) {
  if (typeof type2 === "string") {
    if (!aliasRegistry[type2]) {
      ctx.pushCode("{0} = buffer.read{1}(offset);", ctx.generateVariable(this.varName), NAME_MAP[type2]);
      ctx.pushCode("offset += {0};", PRIMITIVE_TYPES[NAME_MAP[type2]]);
    } else {
      var tempVar = ctx.generateTmpVariable();
      ctx.pushCode("var {0} = {1}(offset);", tempVar, FUNCTION_PREFIX + type2);
      ctx.pushCode("{0} = {1}.result; offset = {1}.offset;", ctx.generateVariable(this.varName), tempVar);
      if (type2 !== this.alias)
        ctx.addReference(type2);
    }
  } else if (type2 instanceof Parser) {
    ctx.pushPath(varName);
    type2.generate(ctx);
    ctx.popPath(varName);
  }
};
Parser.prototype.generateChoice = function(ctx) {
  var tag = ctx.generateOption(this.options.tag);
  if (this.varName) {
    ctx.pushCode("{0} = {};", ctx.generateVariable(this.varName));
  }
  ctx.pushCode("switch({0}) {", tag);
  Object.keys(this.options.choices).forEach(function(t) {
    var type2 = this.options.choices[t];
    if (Number.isNaN(parseInt(t, 10))) {
      ctx.pushCode("case '{0}':", t);
    } else {
      ctx.pushCode("case {0}:", t);
    }
    this.generateChoiceCase(ctx, this.varName, type2);
    ctx.pushCode("break;");
  }, this);
  ctx.pushCode("default:");
  if (this.options.defaultChoice) {
    this.generateChoiceCase(ctx, this.varName, this.options.defaultChoice);
  } else {
    ctx.generateError('"Met undefined tag value " + {0} + " at choice"', tag);
  }
  ctx.pushCode("}");
};
Parser.prototype.generateNest = function(ctx) {
  var nestVar = ctx.generateVariable(this.varName);
  if (this.options.type instanceof Parser) {
    if (this.varName) {
      ctx.pushCode("{0} = {};", nestVar);
    }
    ctx.pushPath(this.varName);
    this.options.type.generate(ctx);
    ctx.popPath(this.varName);
  } else if (aliasRegistry[this.options.type]) {
    var tempVar = ctx.generateTmpVariable();
    ctx.pushCode("var {0} = {1}(offset);", tempVar, FUNCTION_PREFIX + this.options.type);
    ctx.pushCode("{0} = {1}.result; offset = {1}.offset;", nestVar, tempVar);
    if (this.options.type !== this.alias)
      ctx.addReference(this.options.type);
  }
};
Parser.prototype.generateFormatter = function(ctx, varName, formatter) {
  if (typeof formatter === "function") {
    ctx.pushCode("{0} = ({1}).call(this, {0});", varName, formatter);
  }
};
Parser.prototype.isInteger = function() {
  return !!this.type.match(/U?Int[8|16|32][BE|LE]?|Bit\d+/);
};
Parser.prototype.itf8 = function(varName, options) {
  return this.setNextParser("itf8", varName, options);
};
Parser.prototype.itf8 = function(varName, options) {
  return this.setNextParser("itf8", varName, options);
};
Parser.prototype.generateItf8 = function(ctx) {
  var name2 = ctx.generateVariable(this.varName);
  var countFlags = ctx.generateTmpVariable();
  ctx.pushCode("\n    var ".concat(countFlags, " = buffer[offset];\n    if (").concat(countFlags, " < 0x80) {\n      ").concat(name2, " = ").concat(countFlags, ";\n      offset += 1;\n    } else if (").concat(countFlags, " < 0xc0) {\n      ").concat(name2, " = ((").concat(countFlags, "<<8) | buffer[offset+1]) & 0x3fff;\n      offset += 2;\n    } else if (").concat(countFlags, " < 0xe0) {\n      ").concat(name2, " = ((").concat(countFlags, "<<16) | (buffer[offset+1]<< 8) |  buffer[offset+2]) & 0x1fffff;\n      offset += 3;\n    } else if (").concat(countFlags, " < 0xf0) {\n      ").concat(name2, " = ((").concat(countFlags, "<<24) | (buffer[offset+1]<<16) | (buffer[offset+2]<<8) | buffer[offset+3]) & 0x0fffffff;\n      offset += 4\n    } else {\n      ").concat(name2, " = ((").concat(countFlags, " & 0x0f)<<28) | (buffer[offset+1]<<20) | (buffer[offset+2]<<12) | (buffer[offset+3]<<4) | (buffer[offset+4] & 0x0f);\n      // x=((0xff & 0x0f)<<28) | (0xff<<20) | (0xff<<12) | (0xff<<4) | (0x0f & 0x0f);\n      // TODO *val_p = uv < 0x80000000UL ? uv : -((int32_t) (0xffffffffUL - uv)) - 1;\n      offset += 5\n    }\n  "));
};
Parser.prototype.ltf8 = function(varName, options) {
  return this.setNextParser("ltf8", varName, options);
};
Parser.prototype.generateLtf8 = function(ctx) {
  var name2 = ctx.generateVariable(this.varName);
  var countFlags = ctx.generateTmpVariable();
  ctx.pushCode("\n  var ".concat(countFlags, " = buffer[offset];\n  if (").concat(countFlags, " < 0x80) {\n    ").concat(name2, " = ").concat(countFlags, ";\n    offset += 1;\n  } else if (").concat(countFlags, " < 0xc0) {\n    ").concat(name2, " = ((buffer[offset]<<8) | buffer[offset+1]) & 0x3fff;\n    offset += 2;\n  } else if (").concat(countFlags, " < 0xe0) {\n    ").concat(name2, " = ((buffer[offset]<<16) | (buffer[offset+1]<<8) | buffer[offset+2]) & 0x1fffff;\n    ").concat(name2, " = (((").concat(countFlags, " & 63) << 16) | buffer.readUInt16LE(offset + 1));\n    offset += 3;\n  } else if (").concat(countFlags, " < 0xf0) {\n    ").concat(name2, " = ((buffer[offset]<<24) | (buffer[offset+1]<<16) | (buffer[offset+2]<<8) | buffer[offset+3]) & 0x0fffffff;\n    offset += 4;\n  } else if (").concat(countFlags, " < 0xf8) {\n    ").concat(name2, " = (((buffer[offset] & 15) * Math.pow(2,32))) +\n      (buffer[offset+1]<<24) | (buffer[offset+2]<<16 | buffer[offset+3]<<8 | buffer[offset+4])\n    // TODO *val_p = uv < 0x80000000UL ? uv : -((int32_t) (0xffffffffUL - uv)) - 1;\n    offset += 5;\n  } else if (").concat(countFlags, " < 0xfc) {\n    ").concat(name2, " = ((((buffer[offset] & 7) << 8) | buffer[offset+1] )) * Math.pow(2,32) +\n      (buffer[offset+2]<<24) | (buffer[offset+3]<<16 | buffer[offset+4]<<8 | buffer[offset+5])\n    offset += 6;\n  } else if (").concat(countFlags, " < 0xfe) {\n    ").concat(name2, " = ((((buffer[offset] & 3) << 16) | buffer[offset+1]<<8 | buffer[offset+2])) * Math.pow(2,32) +\n      (buffer[offset+3]<<24) | (buffer[offset+4]<<16 | buffer[offset+5]<<8 | buffer[offset+6])\n    offset += 7;\n  } else if (").concat(countFlags, " < 0xff) {\n    ").concat(name2, " = Long.fromBytesBE(buffer.slice(offset+1,offset+8));\n    if (").concat(name2, ".greaterThan(Number.MAX_SAFE_INTEGER) || ").concat(name2, ".lessThan(Number.MIN_SAFE_INTEGER))\n      throw new Error('integer overflow')\n    ").concat(name2, " = ").concat(name2, ".toNumber()\n    offset += 8;\n  } else {\n    ").concat(name2, " = Long.fromBytesBE(buffer.slice(offset+1,offset+9));\n    if (").concat(name2, ".greaterThan(Number.MAX_SAFE_INTEGER) || ").concat(name2, ".lessThan(Number.MIN_SAFE_INTEGER))\n      throw new Error('integer overflow')\n    ").concat(name2, " = ").concat(name2, ".toNumber()\n    offset += 9;\n  }\n  "));
};
binary_parser.Parser = Parser;
var dist = {};
var AbortablePromiseCache$1 = {};
var abortcontrollerPonyfill = {};
var cjsPonyfill = {};
Object.defineProperty(cjsPonyfill, "__esModule", { value: true });
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn(self2, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self2);
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null)
      break;
  }
  return object;
}
function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get2(target2, property2, receiver2) {
      var base = _superPropBase(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get(target, property, receiver || target);
}
var Emitter = /* @__PURE__ */ function() {
  function Emitter2() {
    _classCallCheck(this, Emitter2);
    Object.defineProperty(this, "listeners", {
      value: {},
      writable: true,
      configurable: true
    });
  }
  _createClass(Emitter2, [{
    key: "addEventListener",
    value: function addEventListener(type2, callback, options) {
      if (!(type2 in this.listeners)) {
        this.listeners[type2] = [];
      }
      this.listeners[type2].push({
        callback,
        options
      });
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type2, callback) {
      if (!(type2 in this.listeners)) {
        return;
      }
      var stack = this.listeners[type2];
      for (var i = 0, l = stack.length; i < l; i++) {
        if (stack[i].callback === callback) {
          stack.splice(i, 1);
          return;
        }
      }
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      if (!(event.type in this.listeners)) {
        return;
      }
      var stack = this.listeners[event.type];
      var stackToCall = stack.slice();
      for (var i = 0, l = stackToCall.length; i < l; i++) {
        var listener = stackToCall[i];
        try {
          listener.callback.call(this, event);
        } catch (e) {
          Promise.resolve().then(function() {
            throw e;
          });
        }
        if (listener.options && listener.options.once) {
          this.removeEventListener(event.type, listener.callback);
        }
      }
      return !event.defaultPrevented;
    }
  }]);
  return Emitter2;
}();
var AbortSignal$1 = /* @__PURE__ */ function(_Emitter) {
  _inherits(AbortSignal2, _Emitter);
  var _super = _createSuper$3(AbortSignal2);
  function AbortSignal2() {
    var _this;
    _classCallCheck(this, AbortSignal2);
    _this = _super.call(this);
    if (!_this.listeners) {
      Emitter.call(_assertThisInitialized(_this));
    }
    Object.defineProperty(_assertThisInitialized(_this), "aborted", {
      value: false,
      writable: true,
      configurable: true
    });
    Object.defineProperty(_assertThisInitialized(_this), "onabort", {
      value: null,
      writable: true,
      configurable: true
    });
    return _this;
  }
  _createClass(AbortSignal2, [{
    key: "toString",
    value: function toString2() {
      return "[object AbortSignal]";
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      if (event.type === "abort") {
        this.aborted = true;
        if (typeof this.onabort === "function") {
          this.onabort.call(this, event);
        }
      }
      _get(_getPrototypeOf(AbortSignal2.prototype), "dispatchEvent", this).call(this, event);
    }
  }]);
  return AbortSignal2;
}(Emitter);
var AbortController$1 = /* @__PURE__ */ function() {
  function AbortController2() {
    _classCallCheck(this, AbortController2);
    Object.defineProperty(this, "signal", {
      value: new AbortSignal$1(),
      writable: true,
      configurable: true
    });
  }
  _createClass(AbortController2, [{
    key: "abort",
    value: function abort() {
      var event;
      try {
        event = new Event("abort");
      } catch (e) {
        if (typeof document !== "undefined") {
          if (!document.createEvent) {
            event = document.createEventObject();
            event.type = "abort";
          } else {
            event = document.createEvent("Event");
            event.initEvent("abort", false, false);
          }
        } else {
          event = {
            type: "abort",
            bubbles: false,
            cancelable: false
          };
        }
      }
      this.signal.dispatchEvent(event);
    }
  }, {
    key: "toString",
    value: function toString2() {
      return "[object AbortController]";
    }
  }]);
  return AbortController2;
}();
if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
  AbortController$1.prototype[Symbol.toStringTag] = "AbortController";
  AbortSignal$1.prototype[Symbol.toStringTag] = "AbortSignal";
}
function polyfillNeeded(self2) {
  if (self2.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {
    console.log("__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill");
    return true;
  }
  return typeof self2.Request === "function" && !self2.Request.prototype.hasOwnProperty("signal") || !self2.AbortController;
}
function abortableFetchDecorator(patchTargets) {
  if (typeof patchTargets === "function") {
    patchTargets = {
      fetch: patchTargets
    };
  }
  var _patchTargets = patchTargets, fetch2 = _patchTargets.fetch, _patchTargets$Request = _patchTargets.Request, NativeRequest = _patchTargets$Request === void 0 ? fetch2.Request : _patchTargets$Request, NativeAbortController = _patchTargets.AbortController, _patchTargets$__FORCE = _patchTargets.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL, __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL = _patchTargets$__FORCE === void 0 ? false : _patchTargets$__FORCE;
  if (!polyfillNeeded({
    fetch: fetch2,
    Request: NativeRequest,
    AbortController: NativeAbortController,
    __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL
  })) {
    return {
      fetch: fetch2,
      Request
    };
  }
  var Request = NativeRequest;
  if (Request && !Request.prototype.hasOwnProperty("signal") || __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {
    Request = function Request2(input, init2) {
      var signal;
      if (init2 && init2.signal) {
        signal = init2.signal;
        delete init2.signal;
      }
      var request = new NativeRequest(input, init2);
      if (signal) {
        Object.defineProperty(request, "signal", {
          writable: false,
          enumerable: false,
          configurable: true,
          value: signal
        });
      }
      return request;
    };
    Request.prototype = NativeRequest.prototype;
  }
  var realFetch = fetch2;
  var abortableFetch = function abortableFetch2(input, init2) {
    var signal = Request && Request.prototype.isPrototypeOf(input) ? input.signal : init2 ? init2.signal : void 0;
    if (signal) {
      var abortError;
      try {
        abortError = new DOMException("Aborted", "AbortError");
      } catch (err) {
        abortError = new Error("Aborted");
        abortError.name = "AbortError";
      }
      if (signal.aborted) {
        return Promise.reject(abortError);
      }
      var cancellation = new Promise(function(_, reject) {
        signal.addEventListener("abort", function() {
          return reject(abortError);
        }, {
          once: true
        });
      });
      if (init2 && init2.signal) {
        delete init2.signal;
      }
      return Promise.race([cancellation, realFetch(input, init2)]);
    }
    return realFetch(input, init2);
  };
  return {
    fetch: abortableFetch,
    Request
  };
}
cjsPonyfill.AbortController = AbortController$1;
cjsPonyfill.AbortSignal = AbortSignal$1;
cjsPonyfill.abortableFetch = abortableFetchDecorator;
Object.defineProperty(abortcontrollerPonyfill, "__esModule", { value: true });
abortcontrollerPonyfill.AbortSignal = abortcontrollerPonyfill.AbortController = void 0;
var _cjsPonyfill = cjsPonyfill;
var getGlobal = function getGlobal2() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof commonjsGlobal !== "undefined") {
    return commonjsGlobal;
  }
  throw new Error("unable to locate global object");
};
var AbortController = typeof getGlobal().AbortController === "undefined" ? _cjsPonyfill.AbortController : getGlobal().AbortController;
abortcontrollerPonyfill.AbortController = AbortController;
var AbortSignal = typeof getGlobal().AbortController === "undefined" ? _cjsPonyfill.AbortSignal : getGlobal().AbortSignal;
abortcontrollerPonyfill.AbortSignal = AbortSignal;
var AggregateAbortController$1 = {};
var _interopRequireDefault$9 = interopRequireDefault.exports;
Object.defineProperty(AggregateAbortController$1, "__esModule", { value: true });
AggregateAbortController$1.default = void 0;
var _createClass2$7 = _interopRequireDefault$9(createClass.exports);
var _defineProperty2$7 = _interopRequireDefault$9(defineProperty.exports);
var _classCallCheck2$8 = _interopRequireDefault$9(classCallCheck.exports);
var _abortcontrollerPonyfill$1 = abortcontrollerPonyfill;
var NullSignal = function NullSignal2() {
  (0, _classCallCheck2$8.default)(this, NullSignal2);
};
var AggregateAbortController = /* @__PURE__ */ function() {
  function AggregateAbortController2() {
    (0, _classCallCheck2$8.default)(this, AggregateAbortController2);
    (0, _defineProperty2$7.default)(this, "signals", /* @__PURE__ */ new Set());
    (0, _defineProperty2$7.default)(this, "abortController", new _abortcontrollerPonyfill$1.AbortController());
  }
  (0, _createClass2$7.default)(AggregateAbortController2, [{
    key: "addSignal",
    value: function addSignal() {
      var _this = this;
      var signal = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new NullSignal();
      if (this.signal.aborted) {
        throw new Error("cannot add a signal, already aborted!");
      }
      this.signals.add(signal);
      if (signal.aborted) {
        this.handleAborted(signal);
      } else if (typeof signal.addEventListener === "function") {
        signal.addEventListener("abort", function() {
          _this.handleAborted(signal);
        });
      }
    }
  }, { key: "handleAborted", value: function handleAborted(signal) {
    this.signals.delete(signal);
    if (this.signals.size === 0) {
      this.abortController.abort();
    }
  } }, { key: "abort", value: function abort() {
    this.abortController.abort();
  } }, { key: "signal", get: function get() {
    return this.abortController.signal;
  } }]);
  return AggregateAbortController2;
}();
AggregateAbortController$1.default = AggregateAbortController;
var AggregateStatusReporter$1 = {};
var _interopRequireDefault$8 = interopRequireDefault.exports;
Object.defineProperty(AggregateStatusReporter$1, "__esModule", { value: true });
AggregateStatusReporter$1.default = void 0;
var _classCallCheck2$7 = _interopRequireDefault$8(classCallCheck.exports);
var _createClass2$6 = _interopRequireDefault$8(createClass.exports);
var _defineProperty2$6 = _interopRequireDefault$8(defineProperty.exports);
var AggregateStatusReporter = /* @__PURE__ */ function() {
  function AggregateStatusReporter2() {
    (0, _classCallCheck2$7.default)(this, AggregateStatusReporter2);
    (0, _defineProperty2$6.default)(this, "callbacks", /* @__PURE__ */ new Set());
    (0, _defineProperty2$6.default)(this, "currentMessage", void 0);
  }
  (0, _createClass2$6.default)(AggregateStatusReporter2, [{ key: "addCallback", value: function addCallback() {
    var callback = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
    };
    this.callbacks.add(callback);
    callback(this.currentMessage);
  } }, { key: "callback", value: function callback(message) {
    this.currentMessage = message;
    this.callbacks.forEach(function(elt) {
      elt(message);
    });
  } }]);
  return AggregateStatusReporter2;
}();
AggregateStatusReporter$1.default = AggregateStatusReporter;
var _interopRequireDefault$7 = interopRequireDefault.exports;
Object.defineProperty(AbortablePromiseCache$1, "__esModule", { value: true });
AbortablePromiseCache$1.default = void 0;
var _typeof2 = _interopRequireDefault$7(_typeof$2.exports);
var _classCallCheck2$6 = _interopRequireDefault$7(classCallCheck.exports);
var _createClass2$5 = _interopRequireDefault$7(createClass.exports);
var _defineProperty2$5 = _interopRequireDefault$7(defineProperty.exports);
var _abortcontrollerPonyfill = abortcontrollerPonyfill;
var _AggregateAbortController = _interopRequireDefault$7(AggregateAbortController$1);
var _AggregateStatusReporter = _interopRequireDefault$7(AggregateStatusReporter$1);
var AbortablePromiseCache = /* @__PURE__ */ function() {
  function AbortablePromiseCache2(_ref) {
    var fill = _ref.fill, cache2 = _ref.cache;
    (0, _classCallCheck2$6.default)(this, AbortablePromiseCache2);
    (0, _defineProperty2$5.default)(this, "cache", void 0);
    (0, _defineProperty2$5.default)(this, "fillCallback", void 0);
    if (typeof fill !== "function")
      throw new TypeError("must pass a fill function");
    if ((0, _typeof2.default)(cache2) !== "object")
      throw new TypeError("must pass a cache object");
    if (typeof cache2.get !== "function" || typeof cache2.set !== "function" || typeof cache2.delete !== "function")
      throw new TypeError("cache must implement get(key), set(key, val), and and delete(key)");
    this.cache = cache2;
    this.fillCallback = fill;
  }
  (0, _createClass2$5.default)(AbortablePromiseCache2, [{ key: "evict", value: function evict(key, entry) {
    if (this.cache.get(key) === entry)
      this.cache.delete(key);
  } }, { key: "fill", value: function fill(key, data2, signal, statusCallback) {
    var _this = this;
    var aborter = new _AggregateAbortController.default();
    var statusReporter = new _AggregateStatusReporter.default();
    statusReporter.addCallback(statusCallback);
    var newEntry = {
      aborter,
      promise: this.fillCallback(data2, aborter.signal, function(message) {
        statusReporter.callback(message);
      }),
      settled: false,
      statusReporter,
      get aborted() {
        return this.aborter.signal.aborted;
      }
    };
    newEntry.aborter.addSignal(signal);
    newEntry.aborter.signal.addEventListener("abort", function() {
      if (!newEntry.settled) {
        _this.evict(key, newEntry);
      }
    });
    newEntry.promise.then(function() {
      newEntry.settled = true;
    }, function(exception) {
      newEntry.settled = true;
      _this.evict(key, newEntry);
    }).catch(function(e) {
      console.error(e);
      throw e;
    });
    this.cache.set(key, newEntry);
  } }, {
    key: "has",
    value: function has(key) {
      return this.cache.has(key);
    }
  }, {
    key: "get",
    value: function get(key, data2, signal, statusCallback) {
      if (!signal && data2 instanceof _abortcontrollerPonyfill.AbortSignal)
        throw new TypeError("second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?");
      var cacheEntry = this.cache.get(key);
      if (cacheEntry) {
        if (cacheEntry.aborted && !cacheEntry.settled) {
          this.evict(key, cacheEntry);
          return this.get(key, data2, signal, statusCallback);
        }
        if (cacheEntry.settled) {
          return cacheEntry.promise;
        }
        cacheEntry.aborter.addSignal(signal);
        cacheEntry.statusReporter.addCallback(statusCallback);
        return AbortablePromiseCache2.checkSinglePromise(cacheEntry.promise, signal);
      }
      this.fill(key, data2, signal, statusCallback);
      return AbortablePromiseCache2.checkSinglePromise(this.cache.get(key).promise, signal);
    }
  }, {
    key: "delete",
    value: function _delete(key) {
      var cachedEntry = this.cache.get(key);
      if (cachedEntry) {
        if (!cachedEntry.settled)
          cachedEntry.aborter.abort();
        this.cache.delete(key);
      }
    }
  }, { key: "clear", value: function clear() {
    var keyIter = this.cache.keys();
    var deleteCount = 0;
    for (var result = keyIter.next(); !result.done; result = keyIter.next()) {
      this.delete(result.value);
      deleteCount += 1;
    }
    return deleteCount;
  } }], [{ key: "isAbortException", value: function isAbortException(exception) {
    return exception.name === "AbortError" || exception.code === "ERR_ABORTED" || exception.message === "AbortError: aborted" || exception.message === "Error: aborted";
  } }, { key: "checkSinglePromise", value: function checkSinglePromise(promise, signal) {
    function checkForSingleAbort() {
      if (signal && signal.aborted)
        throw Object.assign(new Error("aborted"), { code: "ERR_ABORTED" });
    }
    return promise.then(function(result) {
      checkForSingleAbort();
      return result;
    }, function(error) {
      checkForSingleAbort();
      throw error;
    });
  } }]);
  return AbortablePromiseCache2;
}();
AbortablePromiseCache$1.default = AbortablePromiseCache;
var _interopRequireDefault$6 = interopRequireDefault.exports;
Object.defineProperty(dist, "__esModule", { value: true });
dist.default = void 0;
var _AbortablePromiseCache = _interopRequireDefault$6(AbortablePromiseCache$1);
var _default = _AbortablePromiseCache.default;
dist.default = _default;
function inflateSync(src) {
  return Buffer$2.from(unzlibSync(src));
}
var zlib = { inflateSync };
var zlib$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  inflateSync,
  "default": zlib
}, Symbol.toStringTag, { value: "Module" }));
var require$$8 = /* @__PURE__ */ getAugmentedNamespace(zlib$1);
var range$1 = {};
var _interopRequireDefault$5 = interopRequireDefault.exports;
Object.defineProperty(range$1, "__esModule", {
  value: true
});
range$1.default = void 0;
var _classCallCheck2$5 = _interopRequireDefault$5(classCallCheck.exports);
var _createClass2$4 = _interopRequireDefault$5(createClass.exports);
var _defineProperty2$4 = _interopRequireDefault$5(defineProperty.exports);
var Range = /* @__PURE__ */ function() {
  function Range2(arg1, arg2) {
    (0, _classCallCheck2$5.default)(this, Range2);
    (0, _defineProperty2$4.default)(this, "ranges", void 0);
    this.ranges = arguments.length === 2 ? [{
      min: arg1,
      max: arg2
    }] : 0 in arg1 ? Object.assign({}, arg1) : [arg1];
  }
  (0, _createClass2$4.default)(Range2, [{
    key: "min",
    value: function min2() {
      return this.ranges[0].min;
    }
  }, {
    key: "max",
    value: function max2() {
      return this.ranges[this.ranges.length - 1].max;
    }
  }, {
    key: "contains",
    value: function contains2(pos) {
      for (var s = 0; s < this.ranges.length; s += 1) {
        var r = this.ranges[s];
        if (r.min <= pos && r.max >= pos) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: "isContiguous",
    value: function isContiguous() {
      return this.ranges.length > 1;
    }
  }, {
    key: "getRanges",
    value: function getRanges() {
      return this.ranges.map(function(r) {
        return new Range2(r.min, r.max);
      });
    }
  }, {
    key: "toString",
    value: function toString2() {
      return this.ranges.map(function(r) {
        return "[".concat(r.min, "-").concat(r.max, "]");
      }).join(",");
    }
  }, {
    key: "union",
    value: function union(s1) {
      var ranges = this.getRanges().concat(s1.getRanges()).sort(this.rangeOrder);
      var oranges = [];
      var current = ranges[0];
      for (var i = 1; i < ranges.length; i += 1) {
        var nxt = ranges[i];
        if (nxt.min() > current.max() + 1) {
          oranges.push(current);
          current = nxt;
        } else if (nxt.max() > current.max()) {
          current = new Range2(current.min(), nxt.max());
        }
      }
      oranges.push(current);
      if (oranges.length === 1) {
        return oranges[0];
      }
      return new Range2(oranges);
    }
  }, {
    key: "intersection",
    value: function intersection(arg) {
      var s0 = this;
      var s1 = arg;
      var r0 = this.ranges();
      var r1 = s1.ranges();
      var l0 = r0.length;
      var l1 = r1.length;
      var i0 = 0;
      var i1 = 0;
      var or2 = [];
      while (i0 < l0 && i1 < l1) {
        s0 = r0[i0];
        s1 = r1[i1];
        var lapMin = Math.max(s0.min(), s1.min());
        var lapMax = Math.min(s0.max(), s1.max());
        if (lapMax >= lapMin) {
          or2.push(new Range2(lapMin, lapMax));
        }
        if (s0.max() > s1.max()) {
          i1 += 1;
        } else {
          i0 += 1;
        }
      }
      if (or2.length === 0) {
        throw new Error("found range of length 0");
      }
      if (or2.length === 1) {
        return or2[0];
      }
      return new Range2(or2);
    }
  }, {
    key: "coverage",
    value: function coverage() {
      var tot = 0;
      var rl = this.ranges();
      for (var ri = 0; ri < rl.length; ri += 1) {
        var r = rl[ri];
        tot += r.max() - r.min() + 1;
      }
      return tot;
    }
  }, {
    key: "rangeOrder",
    value: function rangeOrder(tmpa, tmpb) {
      var a = tmpa;
      var b = tmpb;
      if (arguments.length < 2) {
        b = a;
        a = this;
      }
      if (a.min() < b.min()) {
        return -1;
      }
      if (a.min() > b.min()) {
        return 1;
      }
      if (a.max() < b.max()) {
        return -1;
      }
      if (b.max() > a.max()) {
        return 1;
      }
      return 0;
    }
  }]);
  return Range2;
}();
range$1.default = Range;
var util = {};
var wrapNativeSuper = { exports: {} };
var isNativeFunction = { exports: {} };
(function(module) {
  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
  module.exports = _isNativeFunction;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(isNativeFunction);
var construct = { exports: {} };
var isNativeReflectConstruct = { exports: {} };
(function(module) {
  function _isNativeReflectConstruct2() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  module.exports = _isNativeReflectConstruct2;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(isNativeReflectConstruct);
(function(module) {
  var setPrototypeOf$1 = setPrototypeOf.exports;
  var isNativeReflectConstruct$1 = isNativeReflectConstruct.exports;
  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct$1()) {
      module.exports = _construct = Reflect.construct;
      module.exports["default"] = module.exports, module.exports.__esModule = true;
    } else {
      module.exports = _construct = function _construct2(Parent2, args2, Class2) {
        var a = [null];
        a.push.apply(a, args2);
        var Constructor = Function.bind.apply(Parent2, a);
        var instance = new Constructor();
        if (Class2)
          setPrototypeOf$1(instance, Class2.prototype);
        return instance;
      };
      module.exports["default"] = module.exports, module.exports.__esModule = true;
    }
    return _construct.apply(null, arguments);
  }
  module.exports = _construct;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(construct);
(function(module) {
  var getPrototypeOf$1 = getPrototypeOf.exports;
  var setPrototypeOf$1 = setPrototypeOf.exports;
  var isNativeFunction$1 = isNativeFunction.exports;
  var construct$1 = construct.exports;
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
    module.exports = _wrapNativeSuper = function _wrapNativeSuper3(Class2) {
      if (Class2 === null || !isNativeFunction$1(Class2))
        return Class2;
      if (typeof Class2 !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class2))
          return _cache.get(Class2);
        _cache.set(Class2, Wrapper);
      }
      function Wrapper() {
        return construct$1(Class2, arguments, getPrototypeOf$1(this).constructor);
      }
      Wrapper.prototype = Object.create(Class2.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return setPrototypeOf$1(Wrapper, Class2);
    };
    module.exports["default"] = module.exports, module.exports.__esModule = true;
    return _wrapNativeSuper(Class);
  }
  module.exports = _wrapNativeSuper;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(wrapNativeSuper);
var _interopRequireDefault$4 = interopRequireDefault.exports;
Object.defineProperty(util, "__esModule", {
  value: true
});
util.groupBlocks = groupBlocks;
util.checkAbortSignal = checkAbortSignal;
util.abortBreakPoint = abortBreakPoint;
util.AbortError = void 0;
var _regenerator$4 = _interopRequireDefault$4(regenerator);
var _asyncToGenerator2$4 = _interopRequireDefault$4(asyncToGenerator.exports);
var _classCallCheck2$4 = _interopRequireDefault$4(classCallCheck.exports);
var _assertThisInitialized2$1 = _interopRequireDefault$4(assertThisInitialized.exports);
var _inherits2$2 = _interopRequireDefault$4(inherits.exports);
var _possibleConstructorReturn2$2 = _interopRequireDefault$4(possibleConstructorReturn.exports);
var _getPrototypeOf2$2 = _interopRequireDefault$4(getPrototypeOf.exports);
var _wrapNativeSuper2 = _interopRequireDefault$4(wrapNativeSuper.exports);
var _defineProperty2$3 = _interopRequireDefault$4(defineProperty.exports);
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = (0, _getPrototypeOf2$2.default)(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = (0, _getPrototypeOf2$2.default)(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return (0, _possibleConstructorReturn2$2.default)(this, result);
  };
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var AbortError = /* @__PURE__ */ function(_Error) {
  (0, _inherits2$2.default)(AbortError2, _Error);
  var _super = _createSuper$2(AbortError2);
  function AbortError2(message) {
    var _this;
    (0, _classCallCheck2$4.default)(this, AbortError2);
    _this = _super.call(this, message);
    (0, _defineProperty2$3.default)((0, _assertThisInitialized2$1.default)(_this), "code", void 0);
    _this.code = "ERR_ABORTED";
    return _this;
  }
  return AbortError2;
}(/* @__PURE__ */ (0, _wrapNativeSuper2.default)(Error));
util.AbortError = AbortError;
function groupBlocks(blocks) {
  blocks.sort(function(b0, b1) {
    return (b0.offset | 0) - (b1.offset | 0);
  });
  var blockGroups = [];
  var lastBlock;
  var lastBlockEnd;
  for (var i = 0; i < blocks.length; i += 1) {
    if (lastBlock && blocks[i].offset - lastBlockEnd <= 2e3) {
      lastBlock.length += blocks[i].length - lastBlockEnd + blocks[i].offset;
      lastBlock.blocks.push(blocks[i]);
    } else {
      blockGroups.push(lastBlock = {
        blocks: [blocks[i]],
        length: blocks[i].length,
        offset: blocks[i].offset
      });
    }
    lastBlockEnd = lastBlock.offset + lastBlock.length;
  }
  return blockGroups;
}
function checkAbortSignal(signal) {
  if (!signal)
    return;
  if (signal.aborted) {
    if (typeof DOMException !== "undefined") {
      throw new DOMException("aborted", "AbortError");
    } else {
      var e = new AbortError("aborted");
      e.code = "ERR_ABORTED";
      throw e;
    }
  }
}
function abortBreakPoint(_x) {
  return _abortBreakPoint.apply(this, arguments);
}
function _abortBreakPoint() {
  _abortBreakPoint = (0, _asyncToGenerator2$4.default)(/* @__PURE__ */ _regenerator$4.default.mark(function _callee(signal) {
    return _regenerator$4.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return Promise.resolve();
          case 2:
            checkAbortSignal(signal);
          case 3:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _abortBreakPoint.apply(this, arguments);
}
var _interopRequireDefault$3 = interopRequireDefault.exports;
Object.defineProperty(blockView, "__esModule", {
  value: true
});
blockView.BlockView = void 0;
var _regenerator$3 = _interopRequireDefault$3(regenerator);
var _asyncToGenerator2$3 = _interopRequireDefault$3(asyncToGenerator.exports);
var _classCallCheck2$3 = _interopRequireDefault$3(classCallCheck.exports);
var _createClass2$3 = _interopRequireDefault$3(createClass.exports);
var _defineProperty2$2 = _interopRequireDefault$3(defineProperty.exports);
var _binaryParser$2 = binary_parser;
var _abortablePromiseCache$2 = _interopRequireDefault$3(dist);
var _zlib = _interopRequireDefault$3(require$$8);
var _quickLru$2 = _interopRequireDefault$3(require$$9);
var _range = _interopRequireDefault$3(range$1);
var _util = util;
function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        (0, _defineProperty2$2.default)(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var BIG_WIG_TYPE_GRAPH = 1;
var BIG_WIG_TYPE_VSTEP = 2;
var BIG_WIG_TYPE_FSTEP = 3;
function getParsers$1(isBigEndian) {
  var _choices;
  var le = isBigEndian ? "big" : "little";
  var summaryParser = new _binaryParser$2.Parser().endianess(le).uint32("chromId").uint32("start").uint32("end").uint32("validCnt").float("minScore").float("maxScore").float("sumData").float("sumSqData");
  var leafParser = new _binaryParser$2.Parser().endianess(le).uint8("isLeaf").skip(1).uint16("cnt").choice({
    tag: "isLeaf",
    choices: {
      1: new _binaryParser$2.Parser().array("blocksToFetch", {
        length: "cnt",
        type: new _binaryParser$2.Parser().uint32("startChrom").uint32("startBase").uint32("endChrom").uint32("endBase").uint64("blockOffset").uint64("blockSize")
      }),
      0: new _binaryParser$2.Parser().array("recurOffsets", {
        length: "cnt",
        type: new _binaryParser$2.Parser().uint32("startChrom").uint32("startBase").uint32("endChrom").uint32("endBase").uint64("blockOffset")
      })
    }
  });
  var bigBedParser = new _binaryParser$2.Parser().endianess(le).uint32("chromId").int32("start").int32("end").string("rest", {
    zeroTerminated: true
  });
  var bigWigParser = new _binaryParser$2.Parser().endianess(le).skip(4).int32("blockStart").skip(4).uint32("itemStep").uint32("itemSpan").uint8("blockType").skip(1).uint16("itemCount").choice({
    tag: "blockType",
    choices: (_choices = {}, (0, _defineProperty2$2.default)(_choices, BIG_WIG_TYPE_FSTEP, new _binaryParser$2.Parser().array("items", {
      length: "itemCount",
      type: new _binaryParser$2.Parser().float("score")
    })), (0, _defineProperty2$2.default)(_choices, BIG_WIG_TYPE_VSTEP, new _binaryParser$2.Parser().array("items", {
      length: "itemCount",
      type: new _binaryParser$2.Parser().int32("start").float("score")
    })), (0, _defineProperty2$2.default)(_choices, BIG_WIG_TYPE_GRAPH, new _binaryParser$2.Parser().array("items", {
      length: "itemCount",
      type: new _binaryParser$2.Parser().int32("start").int32("end").float("score")
    })), _choices)
  });
  return {
    bigWigParser,
    bigBedParser,
    summaryParser,
    leafParser
  };
}
var BlockView = /* @__PURE__ */ function() {
  function BlockView2(bbi2, refsByName, cirTreeOffset, cirTreeLength, isBigEndian, isCompressed, blockType) {
    var _this = this;
    (0, _classCallCheck2$3.default)(this, BlockView2);
    (0, _defineProperty2$2.default)(this, "cirTreeOffset", void 0);
    (0, _defineProperty2$2.default)(this, "cirTreeLength", void 0);
    (0, _defineProperty2$2.default)(this, "bbi", void 0);
    (0, _defineProperty2$2.default)(this, "isCompressed", void 0);
    (0, _defineProperty2$2.default)(this, "isBigEndian", void 0);
    (0, _defineProperty2$2.default)(this, "refsByName", void 0);
    (0, _defineProperty2$2.default)(this, "blockType", void 0);
    (0, _defineProperty2$2.default)(this, "cirTreePromise", void 0);
    (0, _defineProperty2$2.default)(this, "featureCache", new _abortablePromiseCache$2.default({
      cache: new _quickLru$2.default({
        maxSize: 1e3
      }),
      fill: function() {
        var _fill = (0, _asyncToGenerator2$3.default)(/* @__PURE__ */ _regenerator$3.default.mark(function _callee(requestData, signal) {
          var length, offset, _yield$_this$bbi$read, buffer2;
          return _regenerator$3.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  length = requestData.length, offset = requestData.offset;
                  _context.next = 3;
                  return _this.bbi.read(Buffer.alloc(length), 0, length, offset, {
                    signal
                  });
                case 3:
                  _yield$_this$bbi$read = _context.sent;
                  buffer2 = _yield$_this$bbi$read.buffer;
                  return _context.abrupt("return", buffer2);
                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
        function fill(_x, _x2) {
          return _fill.apply(this, arguments);
        }
        return fill;
      }()
    }));
    (0, _defineProperty2$2.default)(this, "leafParser", void 0);
    (0, _defineProperty2$2.default)(this, "bigWigParser", void 0);
    (0, _defineProperty2$2.default)(this, "bigBedParser", void 0);
    (0, _defineProperty2$2.default)(this, "summaryParser", void 0);
    if (!(cirTreeOffset >= 0))
      throw new Error("invalid cirTreeOffset!");
    if (!(cirTreeLength > 0))
      throw new Error("invalid cirTreeLength!");
    this.cirTreeOffset = cirTreeOffset;
    this.cirTreeLength = cirTreeLength;
    this.isCompressed = isCompressed;
    this.refsByName = refsByName;
    this.isBigEndian = isBigEndian;
    this.bbi = bbi2;
    this.blockType = blockType;
    Object.assign(this, getParsers$1(isBigEndian));
  }
  (0, _createClass2$3.default)(BlockView2, [{
    key: "readWigData",
    value: function() {
      var _readWigData = (0, _asyncToGenerator2$3.default)(/* @__PURE__ */ _regenerator$3.default.mark(function _callee3(chrName, start, end, observer, opts) {
        var _this2 = this;
        var refsByName, bbi2, cirTreeOffset, isBigEndian, signal, chrId, request, _yield$this$cirTreePr, buffer2, cirBlockSize, blocksToFetch, outstanding, cirFobRecur2, filterFeats, cirFobStartFetch, cirFobRecur;
        return _regenerator$3.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                refsByName = this.refsByName, bbi2 = this.bbi, cirTreeOffset = this.cirTreeOffset, isBigEndian = this.isBigEndian;
                signal = opts.signal;
                chrId = refsByName[chrName];
                if (chrId === void 0) {
                  observer.complete();
                }
                request = {
                  chrId,
                  start,
                  end
                };
                if (!this.cirTreePromise) {
                  this.cirTreePromise = bbi2.read(Buffer.alloc(48), 0, 48, cirTreeOffset, {
                    signal
                  });
                }
                _context3.next = 9;
                return this.cirTreePromise;
              case 9:
                _yield$this$cirTreePr = _context3.sent;
                buffer2 = _yield$this$cirTreePr.buffer;
                cirBlockSize = isBigEndian ? buffer2.readUInt32BE(4) : buffer2.readUInt32LE(4);
                blocksToFetch = [];
                outstanding = 0;
                filterFeats = function filterFeats2(b) {
                  return (b.startChrom < chrId || b.startChrom === chrId && b.startBase <= end) && (b.endChrom > chrId || b.endChrom === chrId && b.endBase >= start);
                };
                cirFobStartFetch = /* @__PURE__ */ function() {
                  var _ref = (0, _asyncToGenerator2$3.default)(/* @__PURE__ */ _regenerator$3.default.mark(function _callee2(off, fr, level) {
                    var length, offset, resultBuffer, i;
                    return _regenerator$3.default.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            _context2.prev = 0;
                            length = fr.max() - fr.min();
                            offset = fr.min();
                            _context2.next = 5;
                            return _this2.featureCache.get("".concat(length, "_").concat(offset), {
                              length,
                              offset
                            }, signal);
                          case 5:
                            resultBuffer = _context2.sent;
                            for (i = 0; i < off.length; i += 1) {
                              if (fr.contains(off[i])) {
                                cirFobRecur2(resultBuffer, off[i] - offset, level, observer, opts);
                                outstanding -= 1;
                                if (outstanding === 0) {
                                  _this2.readFeatures(observer, blocksToFetch, _objectSpread$2(_objectSpread$2({}, opts), {}, {
                                    request
                                  }));
                                }
                              }
                            }
                            _context2.next = 12;
                            break;
                          case 9:
                            _context2.prev = 9;
                            _context2.t0 = _context2["catch"](0);
                            observer.error(_context2.t0);
                          case 12:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, null, [[0, 9]]);
                  }));
                  return function cirFobStartFetch2(_x8, _x9, _x10) {
                    return _ref.apply(this, arguments);
                  };
                }();
                cirFobRecur = function cirFobRecur3(offset, level) {
                  try {
                    outstanding += offset.length;
                    var maxCirBlockSpan = 4 + cirBlockSize * 32;
                    var spans = new _range.default(offset[0], offset[0] + maxCirBlockSpan);
                    for (var i = 1; i < offset.length; i += 1) {
                      var blockSpan = new _range.default(offset[i], offset[i] + maxCirBlockSpan);
                      spans = spans.union(blockSpan);
                    }
                    spans.getRanges().map(function(fr) {
                      return cirFobStartFetch(offset, fr, level);
                    });
                  } catch (e) {
                    observer.error(e);
                  }
                };
                cirFobRecur2 = function cirFobRecur22(cirBlockData, offset, level) {
                  try {
                    var data2 = cirBlockData.slice(offset);
                    var p = _this2.leafParser.parse(data2).result;
                    if (p.blocksToFetch) {
                      blocksToFetch = blocksToFetch.concat(p.blocksToFetch.filter(filterFeats).map(function(l) {
                        return {
                          offset: l.blockOffset,
                          length: l.blockSize
                        };
                      }));
                    }
                    if (p.recurOffsets) {
                      var recurOffsets = p.recurOffsets.filter(filterFeats).map(function(l) {
                        return l.blockOffset;
                      });
                      if (recurOffsets.length > 0) {
                        cirFobRecur(recurOffsets, level + 1);
                      }
                    }
                  } catch (e) {
                    observer.error(e);
                  }
                };
                return _context3.abrupt("return", cirFobRecur([cirTreeOffset + 48], 1));
              case 21:
                _context3.prev = 21;
                _context3.t0 = _context3["catch"](0);
                observer.error(_context3.t0);
              case 24:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[0, 21]]);
      }));
      function readWigData(_x3, _x4, _x5, _x6, _x7) {
        return _readWigData.apply(this, arguments);
      }
      return readWigData;
    }()
  }, {
    key: "parseSummaryBlock",
    value: function parseSummaryBlock(data2, startOffset, request) {
      var features = [];
      var currOffset = startOffset;
      while (currOffset < data2.byteLength) {
        var res = this.summaryParser.parse(data2.slice(currOffset));
        features.push(res.result);
        currOffset += res.offset;
      }
      var items2 = features;
      if (request)
        items2 = items2.filter(function(elt) {
          return elt.chromId === request.chrId;
        });
      items2 = items2.map(function(elt) {
        return {
          start: elt.start,
          end: elt.end,
          maxScore: elt.maxScore,
          minScore: elt.minScore,
          score: elt.sumData / (elt.validCnt || 1),
          summary: true
        };
      });
      return request ? items2.filter(function(f2) {
        return BlockView2.coordFilter(f2, request);
      }) : items2;
    }
  }, {
    key: "parseBigBedBlock",
    value: function parseBigBedBlock(data2, startOffset, offset, request) {
      var items2 = [];
      var currOffset = startOffset;
      while (currOffset < data2.byteLength) {
        var res = this.bigBedParser.parse(data2.slice(currOffset));
        res.result.uniqueId = "bb-".concat(offset + currOffset);
        items2.push(res.result);
        currOffset += res.offset;
      }
      return request ? items2.filter(function(f2) {
        return BlockView2.coordFilter(f2, request);
      }) : items2;
    }
  }, {
    key: "parseBigWigBlock",
    value: function parseBigWigBlock(bytes, startOffset, request) {
      var data2 = bytes.slice(startOffset);
      var results = this.bigWigParser.parse(data2).result;
      var items2 = results.items, itemSpan = results.itemSpan, itemStep = results.itemStep, blockStart = results.blockStart, blockType = results.blockType;
      if (blockType === BIG_WIG_TYPE_FSTEP) {
        for (var i = 0; i < items2.length; i++) {
          items2[i].start = blockStart + i * itemStep;
          items2[i].end = blockStart + i * itemStep + itemSpan;
        }
      } else if (blockType === BIG_WIG_TYPE_VSTEP) {
        for (var _i = 0; _i < items2.length; _i++) {
          items2[_i].end = items2[_i].start + itemSpan;
        }
      }
      return request ? items2.filter(function(f2) {
        return BlockView2.coordFilter(f2, request);
      }) : items2;
    }
  }, {
    key: "readFeatures",
    value: function() {
      var _readFeatures = (0, _asyncToGenerator2$3.default)(/* @__PURE__ */ _regenerator$3.default.mark(function _callee5(observer, blocks) {
        var _this3 = this;
        var opts, blockType, isCompressed, signal, request, blockGroupsToFetch, _args5 = arguments;
        return _regenerator$3.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                opts = _args5.length > 2 && _args5[2] !== void 0 ? _args5[2] : {};
                _context5.prev = 1;
                blockType = this.blockType, isCompressed = this.isCompressed;
                signal = opts.signal, request = opts.request;
                blockGroupsToFetch = (0, _util.groupBlocks)(blocks);
                (0, _util.checkAbortSignal)(signal);
                _context5.next = 8;
                return Promise.all(blockGroupsToFetch.map(/* @__PURE__ */ function() {
                  var _ref2 = (0, _asyncToGenerator2$3.default)(/* @__PURE__ */ _regenerator$3.default.mark(function _callee4(blockGroup) {
                    var length, offset, data2;
                    return _regenerator$3.default.wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            (0, _util.checkAbortSignal)(signal);
                            length = blockGroup.length, offset = blockGroup.offset;
                            _context4.next = 4;
                            return _this3.featureCache.get("".concat(length, "_").concat(offset), blockGroup, signal);
                          case 4:
                            data2 = _context4.sent;
                            blockGroup.blocks.forEach(function(block) {
                              (0, _util.checkAbortSignal)(signal);
                              var blockOffset = block.offset - blockGroup.offset;
                              var resultData = data2;
                              if (isCompressed) {
                                resultData = _zlib.default.inflateSync(data2.slice(blockOffset));
                                blockOffset = 0;
                              }
                              (0, _util.checkAbortSignal)(signal);
                              switch (blockType) {
                                case "summary":
                                  observer.next(_this3.parseSummaryBlock(resultData, blockOffset, request));
                                  break;
                                case "bigwig":
                                  observer.next(_this3.parseBigWigBlock(resultData, blockOffset, request));
                                  break;
                                case "bigbed":
                                  observer.next(_this3.parseBigBedBlock(resultData, blockOffset, block.offset * (1 << 8), request));
                                  break;
                                default:
                                  console.warn("Don't know what to do with ".concat(blockType));
                              }
                            });
                          case 6:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  }));
                  return function(_x13) {
                    return _ref2.apply(this, arguments);
                  };
                }()));
              case 8:
                observer.complete();
                _context5.next = 14;
                break;
              case 11:
                _context5.prev = 11;
                _context5.t0 = _context5["catch"](1);
                observer.error(_context5.t0);
              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[1, 11]]);
      }));
      function readFeatures(_x11, _x12) {
        return _readFeatures.apply(this, arguments);
      }
      return readFeatures;
    }()
  }], [{
    key: "coordFilter",
    value: function coordFilter(f2, range2) {
      return f2.start < range2.end && f2.end >= range2.start;
    }
  }]);
  return BlockView2;
}();
blockView.BlockView = BlockView;
var bbi = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function isFunction(x) {
  return typeof x === "function";
}
var _enable_super_gross_mode_that_will_cause_bad_things = false;
var config$1 = {
  Promise: void 0,
  set useDeprecatedSynchronousErrorHandling(value) {
    if (value) {
      var error = /* @__PURE__ */ new Error();
      /* @__PURE__ */ console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + error.stack);
    }
    _enable_super_gross_mode_that_will_cause_bad_things = value;
  },
  get useDeprecatedSynchronousErrorHandling() {
    return _enable_super_gross_mode_that_will_cause_bad_things;
  }
};
function hostReportError(err) {
  setTimeout(function() {
    throw err;
  }, 0);
}
var empty$1 = {
  closed: true,
  next: function(value) {
  },
  error: function(err) {
    if (config$1.useDeprecatedSynchronousErrorHandling) {
      throw err;
    } else {
      hostReportError(err);
    }
  },
  complete: function() {
  }
};
var isArray = /* @__PURE__ */ function() {
  return Array.isArray || function(x) {
    return x && typeof x.length === "number";
  };
}();
function isObject(x) {
  return x !== null && typeof x === "object";
}
var UnsubscriptionErrorImpl = /* @__PURE__ */ function() {
  function UnsubscriptionErrorImpl2(errors) {
    Error.call(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
    return this;
  }
  UnsubscriptionErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return UnsubscriptionErrorImpl2;
}();
var UnsubscriptionError = UnsubscriptionErrorImpl;
var Subscription = /* @__PURE__ */ function() {
  function Subscription2(unsubscribe2) {
    this.closed = false;
    this._parentOrParents = null;
    this._subscriptions = null;
    if (unsubscribe2) {
      this._ctorUnsubscribe = true;
      this._unsubscribe = unsubscribe2;
    }
  }
  Subscription2.prototype.unsubscribe = function() {
    var errors;
    if (this.closed) {
      return;
    }
    var _a = this, _parentOrParents = _a._parentOrParents, _ctorUnsubscribe = _a._ctorUnsubscribe, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
    this.closed = true;
    this._parentOrParents = null;
    this._subscriptions = null;
    if (_parentOrParents instanceof Subscription2) {
      _parentOrParents.remove(this);
    } else if (_parentOrParents !== null) {
      for (var index = 0; index < _parentOrParents.length; ++index) {
        var parent_1 = _parentOrParents[index];
        parent_1.remove(this);
      }
    }
    if (isFunction(_unsubscribe)) {
      if (_ctorUnsubscribe) {
        this._unsubscribe = void 0;
      }
      try {
        _unsubscribe.call(this);
      } catch (e) {
        errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
      }
    }
    if (isArray(_subscriptions)) {
      var index = -1;
      var len = _subscriptions.length;
      while (++index < len) {
        var sub = _subscriptions[index];
        if (isObject(sub)) {
          try {
            sub.unsubscribe();
          } catch (e) {
            errors = errors || [];
            if (e instanceof UnsubscriptionError) {
              errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
            } else {
              errors.push(e);
            }
          }
        }
      }
    }
    if (errors) {
      throw new UnsubscriptionError(errors);
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var subscription = teardown;
    if (!teardown) {
      return Subscription2.EMPTY;
    }
    switch (typeof teardown) {
      case "function":
        subscription = new Subscription2(teardown);
      case "object":
        if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== "function") {
          return subscription;
        } else if (this.closed) {
          subscription.unsubscribe();
          return subscription;
        } else if (!(subscription instanceof Subscription2)) {
          var tmp = subscription;
          subscription = new Subscription2();
          subscription._subscriptions = [tmp];
        }
        break;
      default: {
        throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
      }
    }
    var _parentOrParents = subscription._parentOrParents;
    if (_parentOrParents === null) {
      subscription._parentOrParents = this;
    } else if (_parentOrParents instanceof Subscription2) {
      if (_parentOrParents === this) {
        return subscription;
      }
      subscription._parentOrParents = [_parentOrParents, this];
    } else if (_parentOrParents.indexOf(this) === -1) {
      _parentOrParents.push(this);
    } else {
      return subscription;
    }
    var subscriptions = this._subscriptions;
    if (subscriptions === null) {
      this._subscriptions = [subscription];
    } else {
      subscriptions.push(subscription);
    }
    return subscription;
  };
  Subscription2.prototype.remove = function(subscription) {
    var subscriptions = this._subscriptions;
    if (subscriptions) {
      var subscriptionIndex = subscriptions.indexOf(subscription);
      if (subscriptionIndex !== -1) {
        subscriptions.splice(subscriptionIndex, 1);
      }
    }
  };
  Subscription2.EMPTY = function(empty2) {
    empty2.closed = true;
    return empty2;
  }(new Subscription2());
  return Subscription2;
}();
function flattenUnsubscriptionErrors(errors) {
  return errors.reduce(function(errs, err) {
    return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
  }, []);
}
var rxSubscriber = /* @__PURE__ */ function() {
  return typeof Symbol === "function" ? /* @__PURE__ */ Symbol("rxSubscriber") : "@@rxSubscriber_" + /* @__PURE__ */ Math.random();
}();
var Subscriber = /* @__PURE__ */ function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destinationOrNext, error, complete) {
    var _this = _super.call(this) || this;
    _this.syncErrorValue = null;
    _this.syncErrorThrown = false;
    _this.syncErrorThrowable = false;
    _this.isStopped = false;
    switch (arguments.length) {
      case 0:
        _this.destination = empty$1;
        break;
      case 1:
        if (!destinationOrNext) {
          _this.destination = empty$1;
          break;
        }
        if (typeof destinationOrNext === "object") {
          if (destinationOrNext instanceof Subscriber2) {
            _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
            _this.destination = destinationOrNext;
            destinationOrNext.add(_this);
          } else {
            _this.syncErrorThrowable = true;
            _this.destination = new SafeSubscriber(_this, destinationOrNext);
          }
          break;
        }
      default:
        _this.syncErrorThrowable = true;
        _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
        break;
    }
    return _this;
  }
  Subscriber2.prototype[rxSubscriber] = function() {
    return this;
  };
  Subscriber2.create = function(next, error, complete) {
    var subscriber = new Subscriber2(next, error, complete);
    subscriber.syncErrorThrowable = false;
    return subscriber;
  };
  Subscriber2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (!this.isStopped) {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (this.closed) {
      return;
    }
    this.isStopped = true;
    _super.prototype.unsubscribe.call(this);
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    this.destination.error(err);
    this.unsubscribe();
  };
  Subscriber2.prototype._complete = function() {
    this.destination.complete();
    this.unsubscribe();
  };
  Subscriber2.prototype._unsubscribeAndRecycle = function() {
    var _parentOrParents = this._parentOrParents;
    this._parentOrParents = null;
    this.unsubscribe();
    this.closed = false;
    this.isStopped = false;
    this._parentOrParents = _parentOrParents;
    return this;
  };
  return Subscriber2;
}(Subscription);
var SafeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(_parentSubscriber, observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    _this._parentSubscriber = _parentSubscriber;
    var next;
    var context2 = _this;
    if (isFunction(observerOrNext)) {
      next = observerOrNext;
    } else if (observerOrNext) {
      next = observerOrNext.next;
      error = observerOrNext.error;
      complete = observerOrNext.complete;
      if (observerOrNext !== empty$1) {
        context2 = Object.create(observerOrNext);
        if (isFunction(context2.unsubscribe)) {
          _this.add(context2.unsubscribe.bind(context2));
        }
        context2.unsubscribe = _this.unsubscribe.bind(_this);
      }
    }
    _this._context = context2;
    _this._next = next;
    _this._error = error;
    _this._complete = complete;
    return _this;
  }
  SafeSubscriber2.prototype.next = function(value) {
    if (!this.isStopped && this._next) {
      var _parentSubscriber = this._parentSubscriber;
      if (!config$1.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
        this.__tryOrUnsub(this._next, value);
      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;
      var useDeprecatedSynchronousErrorHandling = config$1.useDeprecatedSynchronousErrorHandling;
      if (this._error) {
        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(this._error, err);
          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, this._error, err);
          this.unsubscribe();
        }
      } else if (!_parentSubscriber.syncErrorThrowable) {
        this.unsubscribe();
        if (useDeprecatedSynchronousErrorHandling) {
          throw err;
        }
        hostReportError(err);
      } else {
        if (useDeprecatedSynchronousErrorHandling) {
          _parentSubscriber.syncErrorValue = err;
          _parentSubscriber.syncErrorThrown = true;
        } else {
          hostReportError(err);
        }
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.complete = function() {
    var _this = this;
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;
      if (this._complete) {
        var wrappedComplete = function() {
          return _this._complete.call(_this._context);
        };
        if (!config$1.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(wrappedComplete);
          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, wrappedComplete);
          this.unsubscribe();
        }
      } else {
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.__tryOrUnsub = function(fn, value) {
    try {
      fn.call(this._context, value);
    } catch (err) {
      this.unsubscribe();
      if (config$1.useDeprecatedSynchronousErrorHandling) {
        throw err;
      } else {
        hostReportError(err);
      }
    }
  };
  SafeSubscriber2.prototype.__tryOrSetError = function(parent, fn, value) {
    if (!config$1.useDeprecatedSynchronousErrorHandling) {
      throw new Error("bad call");
    }
    try {
      fn.call(this._context, value);
    } catch (err) {
      if (config$1.useDeprecatedSynchronousErrorHandling) {
        parent.syncErrorValue = err;
        parent.syncErrorThrown = true;
        return true;
      } else {
        hostReportError(err);
        return true;
      }
    }
    return false;
  };
  SafeSubscriber2.prototype._unsubscribe = function() {
    var _parentSubscriber = this._parentSubscriber;
    this._context = null;
    this._parentSubscriber = null;
    _parentSubscriber.unsubscribe();
  };
  return SafeSubscriber2;
}(Subscriber);
function canReportError(observer) {
  while (observer) {
    var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
    if (closed_1 || isStopped) {
      return false;
    } else if (destination && destination instanceof Subscriber) {
      observer = destination;
    } else {
      observer = null;
    }
  }
  return true;
}
function toSubscriber(nextOrObserver, error, complete) {
  if (nextOrObserver) {
    if (nextOrObserver instanceof Subscriber) {
      return nextOrObserver;
    }
    if (nextOrObserver[rxSubscriber]) {
      return nextOrObserver[rxSubscriber]();
    }
  }
  if (!nextOrObserver && !error && !complete) {
    return new Subscriber(empty$1);
  }
  return new Subscriber(nextOrObserver, error, complete);
}
var observable = /* @__PURE__ */ function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
function identity(x) {
  return x;
}
function pipe() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}
var Observable = /* @__PURE__ */ function() {
  function Observable2(subscribe2) {
    this._isScalar = false;
    if (subscribe2) {
      this._subscribe = subscribe2;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var operator = this.operator;
    var sink = toSubscriber(observerOrNext, error, complete);
    if (operator) {
      sink.add(operator.call(sink, this.source));
    } else {
      sink.add(this.source || config$1.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
    }
    if (config$1.useDeprecatedSynchronousErrorHandling) {
      if (sink.syncErrorThrowable) {
        sink.syncErrorThrowable = false;
        if (sink.syncErrorThrown) {
          throw sink.syncErrorValue;
        }
      }
    }
    return sink;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      if (config$1.useDeprecatedSynchronousErrorHandling) {
        sink.syncErrorThrown = true;
        sink.syncErrorValue = err;
      }
      if (canReportError(sink)) {
        sink.error(err);
      } else {
        console.warn(err);
      }
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var subscription;
      subscription = _this.subscribe(function(value) {
        try {
          next(value);
        } catch (err) {
          reject(err);
          if (subscription) {
            subscription.unsubscribe();
          }
        }
      }, reject, resolve2);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var source = this.source;
    return source && source.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    if (operations.length === 0) {
      return this;
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve2(value);
      });
    });
  };
  Observable2.create = function(subscribe2) {
    return new Observable2(subscribe2);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  if (!promiseCtor) {
    promiseCtor = config$1.Promise || Promise;
  }
  if (!promiseCtor) {
    throw new Error("no Promise impl found");
  }
  return promiseCtor;
}
var ObjectUnsubscribedErrorImpl = /* @__PURE__ */ function() {
  function ObjectUnsubscribedErrorImpl2() {
    Error.call(this);
    this.message = "object unsubscribed";
    this.name = "ObjectUnsubscribedError";
    return this;
  }
  ObjectUnsubscribedErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return ObjectUnsubscribedErrorImpl2;
}();
var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
var SubjectSubscription = /* @__PURE__ */ function(_super) {
  __extends(SubjectSubscription2, _super);
  function SubjectSubscription2(subject, subscriber) {
    var _this = _super.call(this) || this;
    _this.subject = subject;
    _this.subscriber = subscriber;
    _this.closed = false;
    return _this;
  }
  SubjectSubscription2.prototype.unsubscribe = function() {
    if (this.closed) {
      return;
    }
    this.closed = true;
    var subject = this.subject;
    var observers = subject.observers;
    this.subject = null;
    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
      return;
    }
    var subscriberIndex = observers.indexOf(this.subscriber);
    if (subscriberIndex !== -1) {
      observers.splice(subscriberIndex, 1);
    }
  };
  return SubjectSubscription2;
}(Subscription);
var SubjectSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SubjectSubscriber2, _super);
  function SubjectSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    return _this;
  }
  return SubjectSubscriber2;
}(Subscriber);
var Subject = /* @__PURE__ */ function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.observers = [];
    _this.closed = false;
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype[rxSubscriber] = function() {
    return new SubjectSubscriber(this);
  };
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype.next = function(value) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    if (!this.isStopped) {
      var observers = this.observers;
      var len = observers.length;
      var copy2 = observers.slice();
      for (var i = 0; i < len; i++) {
        copy2[i].next(value);
      }
    }
  };
  Subject2.prototype.error = function(err) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    this.hasError = true;
    this.thrownError = err;
    this.isStopped = true;
    var observers = this.observers;
    var len = observers.length;
    var copy2 = observers.slice();
    for (var i = 0; i < len; i++) {
      copy2[i].error(err);
    }
    this.observers.length = 0;
  };
  Subject2.prototype.complete = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    this.isStopped = true;
    var observers = this.observers;
    var len = observers.length;
    var copy2 = observers.slice();
    for (var i = 0; i < len; i++) {
      copy2[i].complete();
    }
    this.observers.length = 0;
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = true;
    this.closed = true;
    this.observers = null;
  };
  Subject2.prototype._trySubscribe = function(subscriber) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else {
      return _super.prototype._trySubscribe.call(this, subscriber);
    }
  };
  Subject2.prototype._subscribe = function(subscriber) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else if (this.hasError) {
      subscriber.error(this.thrownError);
      return Subscription.EMPTY;
    } else if (this.isStopped) {
      subscriber.complete();
      return Subscription.EMPTY;
    } else {
      this.observers.push(subscriber);
      return new SubjectSubscription(this, subscriber);
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = /* @__PURE__ */ function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var destination = this.destination;
    if (destination && destination.next) {
      destination.next(value);
    }
  };
  AnonymousSubject2.prototype.error = function(err) {
    var destination = this.destination;
    if (destination && destination.error) {
      this.destination.error(err);
    }
  };
  AnonymousSubject2.prototype.complete = function() {
    var destination = this.destination;
    if (destination && destination.complete) {
      this.destination.complete();
    }
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var source = this.source;
    if (source) {
      return this.source.subscribe(subscriber);
    } else {
      return Subscription.EMPTY;
    }
  };
  return AnonymousSubject2;
}(Subject);
function refCount() {
  return function refCountOperatorFunction(source) {
    return source.lift(new RefCountOperator(source));
  };
}
var RefCountOperator = /* @__PURE__ */ function() {
  function RefCountOperator2(connectable) {
    this.connectable = connectable;
  }
  RefCountOperator2.prototype.call = function(subscriber, source) {
    var connectable = this.connectable;
    connectable._refCount++;
    var refCounter = new RefCountSubscriber(subscriber, connectable);
    var subscription = source.subscribe(refCounter);
    if (!refCounter.closed) {
      refCounter.connection = connectable.connect();
    }
    return subscription;
  };
  return RefCountOperator2;
}();
var RefCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RefCountSubscriber2, _super);
  function RefCountSubscriber2(destination, connectable) {
    var _this = _super.call(this, destination) || this;
    _this.connectable = connectable;
    return _this;
  }
  RefCountSubscriber2.prototype._unsubscribe = function() {
    var connectable = this.connectable;
    if (!connectable) {
      this.connection = null;
      return;
    }
    this.connectable = null;
    var refCount2 = connectable._refCount;
    if (refCount2 <= 0) {
      this.connection = null;
      return;
    }
    connectable._refCount = refCount2 - 1;
    if (refCount2 > 1) {
      this.connection = null;
      return;
    }
    var connection = this.connection;
    var sharedConnection = connectable._connection;
    this.connection = null;
    if (sharedConnection && (!connection || sharedConnection === connection)) {
      sharedConnection.unsubscribe();
    }
  };
  return RefCountSubscriber2;
}(Subscriber);
var ConnectableObservable = /* @__PURE__ */ function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._refCount = 0;
    _this._isComplete = false;
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype.connect = function() {
    var connection = this._connection;
    if (!connection) {
      this._isComplete = false;
      connection = this._connection = new Subscription();
      connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
}(Observable);
var connectableObservableDescriptor = /* @__PURE__ */ function() {
  var connectableProto = ConnectableObservable.prototype;
  return {
    operator: { value: null },
    _refCount: { value: 0, writable: true },
    _subject: { value: null, writable: true },
    _connection: { value: null, writable: true },
    _subscribe: { value: connectableProto._subscribe },
    _isComplete: { value: connectableProto._isComplete, writable: true },
    getSubject: { value: connectableProto.getSubject },
    connect: { value: connectableProto.connect },
    refCount: { value: connectableProto.refCount }
  };
}();
var ConnectableSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ConnectableSubscriber2, _super);
  function ConnectableSubscriber2(destination, connectable) {
    var _this = _super.call(this, destination) || this;
    _this.connectable = connectable;
    return _this;
  }
  ConnectableSubscriber2.prototype._error = function(err) {
    this._unsubscribe();
    _super.prototype._error.call(this, err);
  };
  ConnectableSubscriber2.prototype._complete = function() {
    this.connectable._isComplete = true;
    this._unsubscribe();
    _super.prototype._complete.call(this);
  };
  ConnectableSubscriber2.prototype._unsubscribe = function() {
    var connectable = this.connectable;
    if (connectable) {
      this.connectable = null;
      var connection = connectable._connection;
      connectable._refCount = 0;
      connectable._subject = null;
      connectable._connection = null;
      if (connection) {
        connection.unsubscribe();
      }
    }
  };
  return ConnectableSubscriber2;
}(SubjectSubscriber);
function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
  return function(source) {
    return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
  };
}
var GroupByOperator = /* @__PURE__ */ function() {
  function GroupByOperator2(keySelector, elementSelector, durationSelector, subjectSelector) {
    this.keySelector = keySelector;
    this.elementSelector = elementSelector;
    this.durationSelector = durationSelector;
    this.subjectSelector = subjectSelector;
  }
  GroupByOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
  };
  return GroupByOperator2;
}();
var GroupBySubscriber = /* @__PURE__ */ function(_super) {
  __extends(GroupBySubscriber2, _super);
  function GroupBySubscriber2(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
    var _this = _super.call(this, destination) || this;
    _this.keySelector = keySelector;
    _this.elementSelector = elementSelector;
    _this.durationSelector = durationSelector;
    _this.subjectSelector = subjectSelector;
    _this.groups = null;
    _this.attemptedToUnsubscribe = false;
    _this.count = 0;
    return _this;
  }
  GroupBySubscriber2.prototype._next = function(value) {
    var key;
    try {
      key = this.keySelector(value);
    } catch (err) {
      this.error(err);
      return;
    }
    this._group(value, key);
  };
  GroupBySubscriber2.prototype._group = function(value, key) {
    var groups = this.groups;
    if (!groups) {
      groups = this.groups = /* @__PURE__ */ new Map();
    }
    var group2 = groups.get(key);
    var element;
    if (this.elementSelector) {
      try {
        element = this.elementSelector(value);
      } catch (err) {
        this.error(err);
      }
    } else {
      element = value;
    }
    if (!group2) {
      group2 = this.subjectSelector ? this.subjectSelector() : new Subject();
      groups.set(key, group2);
      var groupedObservable = new GroupedObservable(key, group2, this);
      this.destination.next(groupedObservable);
      if (this.durationSelector) {
        var duration = void 0;
        try {
          duration = this.durationSelector(new GroupedObservable(key, group2));
        } catch (err) {
          this.error(err);
          return;
        }
        this.add(duration.subscribe(new GroupDurationSubscriber(key, group2, this)));
      }
    }
    if (!group2.closed) {
      group2.next(element);
    }
  };
  GroupBySubscriber2.prototype._error = function(err) {
    var groups = this.groups;
    if (groups) {
      groups.forEach(function(group2, key) {
        group2.error(err);
      });
      groups.clear();
    }
    this.destination.error(err);
  };
  GroupBySubscriber2.prototype._complete = function() {
    var groups = this.groups;
    if (groups) {
      groups.forEach(function(group2, key) {
        group2.complete();
      });
      groups.clear();
    }
    this.destination.complete();
  };
  GroupBySubscriber2.prototype.removeGroup = function(key) {
    this.groups.delete(key);
  };
  GroupBySubscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.attemptedToUnsubscribe = true;
      if (this.count === 0) {
        _super.prototype.unsubscribe.call(this);
      }
    }
  };
  return GroupBySubscriber2;
}(Subscriber);
var GroupDurationSubscriber = /* @__PURE__ */ function(_super) {
  __extends(GroupDurationSubscriber2, _super);
  function GroupDurationSubscriber2(key, group2, parent) {
    var _this = _super.call(this, group2) || this;
    _this.key = key;
    _this.group = group2;
    _this.parent = parent;
    return _this;
  }
  GroupDurationSubscriber2.prototype._next = function(value) {
    this.complete();
  };
  GroupDurationSubscriber2.prototype._unsubscribe = function() {
    var _a = this, parent = _a.parent, key = _a.key;
    this.key = this.parent = null;
    if (parent) {
      parent.removeGroup(key);
    }
  };
  return GroupDurationSubscriber2;
}(Subscriber);
var GroupedObservable = /* @__PURE__ */ function(_super) {
  __extends(GroupedObservable2, _super);
  function GroupedObservable2(key, groupSubject, refCountSubscription) {
    var _this = _super.call(this) || this;
    _this.key = key;
    _this.groupSubject = groupSubject;
    _this.refCountSubscription = refCountSubscription;
    return _this;
  }
  GroupedObservable2.prototype._subscribe = function(subscriber) {
    var subscription = new Subscription();
    var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
    if (refCountSubscription && !refCountSubscription.closed) {
      subscription.add(new InnerRefCountSubscription(refCountSubscription));
    }
    subscription.add(groupSubject.subscribe(subscriber));
    return subscription;
  };
  return GroupedObservable2;
}(Observable);
var InnerRefCountSubscription = /* @__PURE__ */ function(_super) {
  __extends(InnerRefCountSubscription2, _super);
  function InnerRefCountSubscription2(parent) {
    var _this = _super.call(this) || this;
    _this.parent = parent;
    parent.count++;
    return _this;
  }
  InnerRefCountSubscription2.prototype.unsubscribe = function() {
    var parent = this.parent;
    if (!parent.closed && !this.closed) {
      _super.prototype.unsubscribe.call(this);
      parent.count -= 1;
      if (parent.count === 0 && parent.attemptedToUnsubscribe) {
        parent.unsubscribe();
      }
    }
  };
  return InnerRefCountSubscription2;
}(Subscription);
var BehaviorSubject = /* @__PURE__ */ function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: true,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    if (subscription && !subscription.closed) {
      subscriber.next(this._value);
    }
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    if (this.hasError) {
      throw this.thrownError;
    } else if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else {
      return this._value;
    }
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);
var Action = /* @__PURE__ */ function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay2) {
    return this;
  };
  return Action2;
}(Subscription);
var AsyncAction = /* @__PURE__ */ function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return setInterval(scheduler.flush.bind(scheduler, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && this.delay === delay2 && this.pending === false) {
      return id;
    }
    clearInterval(id);
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, delay2) {
    var errored = false;
    var errorValue = void 0;
    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = !!e && e || new Error(e);
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype._unsubscribe = function() {
    var id = this.id;
    var scheduler = this.scheduler;
    var actions = scheduler.actions;
    var index = actions.indexOf(this);
    this.work = null;
    this.state = null;
    this.pending = false;
    this.scheduler = null;
    if (index !== -1) {
      actions.splice(index, 1);
    }
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, null);
    }
    this.delay = null;
  };
  return AsyncAction2;
}(Action);
var QueueAction = /* @__PURE__ */ function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 > 0) {
      return _super.prototype.schedule.call(this, state, delay2);
    }
    this.delay = delay2;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state, delay2) {
    return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) : this._execute(state, delay2);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    return scheduler.flush(this);
  };
  return QueueAction2;
}(AsyncAction);
var Scheduler = /* @__PURE__ */ function() {
  function Scheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.SchedulerAction = SchedulerAction;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay2, state) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.SchedulerAction(this, work).schedule(state, delay2);
  };
  Scheduler2.now = function() {
    return Date.now();
  };
  return Scheduler2;
}();
var AsyncScheduler = /* @__PURE__ */ function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, function() {
      if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== _this) {
        return AsyncScheduler2.delegate.now();
      } else {
        return now();
      }
    }) || this;
    _this.actions = [];
    _this.active = false;
    _this.scheduled = void 0;
    return _this;
  }
  AsyncScheduler2.prototype.schedule = function(work, delay2, state) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== this) {
      return AsyncScheduler2.delegate.schedule(work, delay2, state);
    } else {
      return _super.prototype.schedule.call(this, work, delay2, state);
    }
  };
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this.active) {
      actions.push(action);
      return;
    }
    var error;
    this.active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this.active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);
var QueueScheduler = /* @__PURE__ */ function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler);
var queueScheduler = /* @__PURE__ */ new QueueScheduler(QueueAction);
var queue = queueScheduler;
var EMPTY = /* @__PURE__ */ new Observable(function(subscriber) {
  return subscriber.complete();
});
function empty(scheduler) {
  return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
  return new Observable(function(subscriber) {
    return scheduler.schedule(function() {
      return subscriber.complete();
    });
  });
}
function isScheduler(value) {
  return value && typeof value.schedule === "function";
}
var subscribeToArray = function(array) {
  return function(subscriber) {
    for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  };
};
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    var i = 0;
    sub.add(scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
        return;
      }
      subscriber.next(input[i++]);
      if (!subscriber.closed) {
        sub.add(this.schedule());
      }
    }));
    return sub;
  });
}
function fromArray(input, scheduler) {
  if (!scheduler) {
    return new Observable(subscribeToArray(input));
  } else {
    return scheduleArray(input, scheduler);
  }
}
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = args[args.length - 1];
  if (isScheduler(scheduler)) {
    args.pop();
    return scheduleArray(args, scheduler);
  } else {
    return fromArray(args);
  }
}
function throwError(error, scheduler) {
  if (!scheduler) {
    return new Observable(function(subscriber) {
      return subscriber.error(error);
    });
  } else {
    return new Observable(function(subscriber) {
      return scheduler.schedule(dispatch$7, 0, { error, subscriber });
    });
  }
}
function dispatch$7(_a) {
  var error = _a.error, subscriber = _a.subscriber;
  subscriber.error(error);
}
var NotificationKind;
/* @__PURE__ */ (function(NotificationKind2) {
  NotificationKind2["NEXT"] = "N";
  NotificationKind2["ERROR"] = "E";
  NotificationKind2["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = /* @__PURE__ */ function() {
  function Notification2(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === "N";
  }
  Notification2.prototype.observe = function(observer) {
    switch (this.kind) {
      case "N":
        return observer.next && observer.next(this.value);
      case "E":
        return observer.error && observer.error(this.error);
      case "C":
        return observer.complete && observer.complete();
    }
  };
  Notification2.prototype.do = function(next, error, complete) {
    var kind = this.kind;
    switch (kind) {
      case "N":
        return next && next(this.value);
      case "E":
        return error && error(this.error);
      case "C":
        return complete && complete();
    }
  };
  Notification2.prototype.accept = function(nextOrObserver, error, complete) {
    if (nextOrObserver && typeof nextOrObserver.next === "function") {
      return this.observe(nextOrObserver);
    } else {
      return this.do(nextOrObserver, error, complete);
    }
  };
  Notification2.prototype.toObservable = function() {
    var kind = this.kind;
    switch (kind) {
      case "N":
        return of(this.value);
      case "E":
        return throwError(this.error);
      case "C":
        return empty();
    }
    throw new Error("unexpected notification kind value");
  };
  Notification2.createNext = function(value) {
    if (typeof value !== "undefined") {
      return new Notification2("N", value);
    }
    return Notification2.undefinedValueNotification;
  };
  Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  };
  Notification2.createComplete = function() {
    return Notification2.completeNotification;
  };
  Notification2.completeNotification = new Notification2("C");
  Notification2.undefinedValueNotification = new Notification2("N", void 0);
  return Notification2;
}();
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return function observeOnOperatorFunction(source) {
    return source.lift(new ObserveOnOperator(scheduler, delay2));
  };
}
var ObserveOnOperator = /* @__PURE__ */ function() {
  function ObserveOnOperator2(scheduler, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.scheduler = scheduler;
    this.delay = delay2;
  }
  ObserveOnOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
  };
  return ObserveOnOperator2;
}();
var ObserveOnSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ObserveOnSubscriber2, _super);
  function ObserveOnSubscriber2(destination, scheduler, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    var _this = _super.call(this, destination) || this;
    _this.scheduler = scheduler;
    _this.delay = delay2;
    return _this;
  }
  ObserveOnSubscriber2.dispatch = function(arg) {
    var notification = arg.notification, destination = arg.destination;
    notification.observe(destination);
    this.unsubscribe();
  };
  ObserveOnSubscriber2.prototype.scheduleMessage = function(notification) {
    var destination = this.destination;
    destination.add(this.scheduler.schedule(ObserveOnSubscriber2.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
  };
  ObserveOnSubscriber2.prototype._next = function(value) {
    this.scheduleMessage(Notification.createNext(value));
  };
  ObserveOnSubscriber2.prototype._error = function(err) {
    this.scheduleMessage(Notification.createError(err));
    this.unsubscribe();
  };
  ObserveOnSubscriber2.prototype._complete = function() {
    this.scheduleMessage(Notification.createComplete());
    this.unsubscribe();
  };
  return ObserveOnSubscriber2;
}(Subscriber);
var ObserveOnMessage = /* @__PURE__ */ function() {
  function ObserveOnMessage2(notification, destination) {
    this.notification = notification;
    this.destination = destination;
  }
  return ObserveOnMessage2;
}();
var ReplaySubject = /* @__PURE__ */ function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(bufferSize, windowTime2, scheduler) {
    if (bufferSize === void 0) {
      bufferSize = Number.POSITIVE_INFINITY;
    }
    if (windowTime2 === void 0) {
      windowTime2 = Number.POSITIVE_INFINITY;
    }
    var _this = _super.call(this) || this;
    _this.scheduler = scheduler;
    _this._events = [];
    _this._infiniteTimeWindow = false;
    _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
    _this._windowTime = windowTime2 < 1 ? 1 : windowTime2;
    if (windowTime2 === Number.POSITIVE_INFINITY) {
      _this._infiniteTimeWindow = true;
      _this.next = _this.nextInfiniteTimeWindow;
    } else {
      _this.next = _this.nextTimeWindow;
    }
    return _this;
  }
  ReplaySubject2.prototype.nextInfiniteTimeWindow = function(value) {
    if (!this.isStopped) {
      var _events = this._events;
      _events.push(value);
      if (_events.length > this._bufferSize) {
        _events.shift();
      }
    }
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype.nextTimeWindow = function(value) {
    if (!this.isStopped) {
      this._events.push(new ReplayEvent(this._getNow(), value));
      this._trimBufferThenGetEvents();
    }
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    var _infiniteTimeWindow = this._infiniteTimeWindow;
    var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
    var scheduler = this.scheduler;
    var len = _events.length;
    var subscription;
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else if (this.isStopped || this.hasError) {
      subscription = Subscription.EMPTY;
    } else {
      this.observers.push(subscriber);
      subscription = new SubjectSubscription(this, subscriber);
    }
    if (scheduler) {
      subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
    }
    if (_infiniteTimeWindow) {
      for (var i = 0; i < len && !subscriber.closed; i++) {
        subscriber.next(_events[i]);
      }
    } else {
      for (var i = 0; i < len && !subscriber.closed; i++) {
        subscriber.next(_events[i].value);
      }
    }
    if (this.hasError) {
      subscriber.error(this.thrownError);
    } else if (this.isStopped) {
      subscriber.complete();
    }
    return subscription;
  };
  ReplaySubject2.prototype._getNow = function() {
    return (this.scheduler || queue).now();
  };
  ReplaySubject2.prototype._trimBufferThenGetEvents = function() {
    var now = this._getNow();
    var _bufferSize = this._bufferSize;
    var _windowTime = this._windowTime;
    var _events = this._events;
    var eventsCount = _events.length;
    var spliceCount = 0;
    while (spliceCount < eventsCount) {
      if (now - _events[spliceCount].time < _windowTime) {
        break;
      }
      spliceCount++;
    }
    if (eventsCount > _bufferSize) {
      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
    }
    if (spliceCount > 0) {
      _events.splice(0, spliceCount);
    }
    return _events;
  };
  return ReplaySubject2;
}(Subject);
var ReplayEvent = /* @__PURE__ */ function() {
  function ReplayEvent2(time2, value) {
    this.time = time2;
    this.value = value;
  }
  return ReplayEvent2;
}();
var AsyncSubject = /* @__PURE__ */ function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.value = null;
    _this.hasNext = false;
    _this.hasCompleted = false;
    return _this;
  }
  AsyncSubject2.prototype._subscribe = function(subscriber) {
    if (this.hasError) {
      subscriber.error(this.thrownError);
      return Subscription.EMPTY;
    } else if (this.hasCompleted && this.hasNext) {
      subscriber.next(this.value);
      subscriber.complete();
      return Subscription.EMPTY;
    }
    return _super.prototype._subscribe.call(this, subscriber);
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.hasCompleted) {
      this.value = value;
      this.hasNext = true;
    }
  };
  AsyncSubject2.prototype.error = function(error) {
    if (!this.hasCompleted) {
      _super.prototype.error.call(this, error);
    }
  };
  AsyncSubject2.prototype.complete = function() {
    this.hasCompleted = true;
    if (this.hasNext) {
      _super.prototype.next.call(this, this.value);
    }
    _super.prototype.complete.call(this);
  };
  return AsyncSubject2;
}(Subject);
var nextHandle = 1;
var RESOLVED = /* @__PURE__ */ function() {
  return /* @__PURE__ */ Promise.resolve();
}();
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    RESOLVED.then(function() {
      return findAndClearHandle(handle) && cb();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};
var AsapAction = /* @__PURE__ */ function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    if (scheduler.actions.length === 0) {
      Immediate.clearImmediate(id);
      scheduler.scheduled = void 0;
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction);
var AsapScheduler = /* @__PURE__ */ function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this.active = true;
    this.scheduled = void 0;
    var actions = this.actions;
    var error;
    var index = -1;
    var count2 = actions.length;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (++index < count2 && (action = actions.shift()));
    this.active = false;
    if (error) {
      while (++index < count2 && (action = actions.shift())) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler);
var asapScheduler = /* @__PURE__ */ new AsapScheduler(AsapAction);
var asap = asapScheduler;
var asyncScheduler = /* @__PURE__ */ new AsyncScheduler(AsyncAction);
var async = asyncScheduler;
var AnimationFrameAction = /* @__PURE__ */ function(_super) {
  __extends(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function() {
      return scheduler.flush(null);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    if (scheduler.actions.length === 0) {
      cancelAnimationFrame(id);
      scheduler.scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
}(AsyncAction);
var AnimationFrameScheduler = /* @__PURE__ */ function(_super) {
  __extends(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this.active = true;
    this.scheduled = void 0;
    var actions = this.actions;
    var error;
    var index = -1;
    var count2 = actions.length;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (++index < count2 && (action = actions.shift()));
    this.active = false;
    if (error) {
      while (++index < count2 && (action = actions.shift())) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AnimationFrameScheduler2;
}(AsyncScheduler);
var animationFrameScheduler = /* @__PURE__ */ new AnimationFrameScheduler(AnimationFrameAction);
var animationFrame = animationFrameScheduler;
var VirtualTimeScheduler = /* @__PURE__ */ function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(SchedulerAction, maxFrames) {
    if (SchedulerAction === void 0) {
      SchedulerAction = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Number.POSITIVE_INFINITY;
    }
    var _this = _super.call(this, SchedulerAction, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
    var error, action;
    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
}(AsyncScheduler);
var VirtualAction = /* @__PURE__ */ function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index) {
    if (index === void 0) {
      index = scheduler.index += 1;
    }
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index;
    _this.active = true;
    _this.index = scheduler.index = index;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (!this.id) {
      return _super.prototype.schedule.call(this, state, delay2);
    }
    this.active = false;
    var action = new VirtualAction2(this.scheduler, this.work);
    this.add(action);
    return action.schedule(state, delay2);
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.delay = scheduler.frame + delay2;
    var actions = scheduler.actions;
    actions.push(this);
    actions.sort(VirtualAction2.sortActions);
    return true;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state, delay2) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state, delay2);
    }
  };
  VirtualAction2.sortActions = function(a, b) {
    if (a.delay === b.delay) {
      if (a.index === b.index) {
        return 0;
      } else if (a.index > b.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a.delay > b.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
}(AsyncAction);
function noop() {
}
function isObservable(obj) {
  return !!obj && (obj instanceof Observable || typeof obj.lift === "function" && typeof obj.subscribe === "function");
}
var ArgumentOutOfRangeErrorImpl = /* @__PURE__ */ function() {
  function ArgumentOutOfRangeErrorImpl2() {
    Error.call(this);
    this.message = "argument out of range";
    this.name = "ArgumentOutOfRangeError";
    return this;
  }
  ArgumentOutOfRangeErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return ArgumentOutOfRangeErrorImpl2;
}();
var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
var EmptyErrorImpl = /* @__PURE__ */ function() {
  function EmptyErrorImpl2() {
    Error.call(this);
    this.message = "no elements in sequence";
    this.name = "EmptyError";
    return this;
  }
  EmptyErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return EmptyErrorImpl2;
}();
var EmptyError = EmptyErrorImpl;
var TimeoutErrorImpl = /* @__PURE__ */ function() {
  function TimeoutErrorImpl2() {
    Error.call(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    return this;
  }
  TimeoutErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return TimeoutErrorImpl2;
}();
var TimeoutError = TimeoutErrorImpl;
function map(project, thisArg) {
  return function mapOperation(source) {
    if (typeof project !== "function") {
      throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
    }
    return source.lift(new MapOperator(project, thisArg));
  };
}
var MapOperator = /* @__PURE__ */ function() {
  function MapOperator2(project, thisArg) {
    this.project = project;
    this.thisArg = thisArg;
  }
  MapOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
  };
  return MapOperator2;
}();
var MapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MapSubscriber2, _super);
  function MapSubscriber2(destination, project, thisArg) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.count = 0;
    _this.thisArg = thisArg || _this;
    return _this;
  }
  MapSubscriber2.prototype._next = function(value) {
    var result;
    try {
      result = this.project.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return MapSubscriber2;
}(Subscriber);
function bindCallback(callbackFunc, resultSelector, scheduler) {
  if (resultSelector) {
    if (isScheduler(resultSelector)) {
      scheduler = resultSelector;
    } else {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function(args2) {
          return isArray(args2) ? resultSelector.apply(void 0, args2) : resultSelector(args2);
        }));
      };
    }
  }
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var context2 = this;
    var subject;
    var params = {
      context: context2,
      subject,
      callbackFunc,
      scheduler
    };
    return new Observable(function(subscriber) {
      if (!scheduler) {
        if (!subject) {
          subject = new AsyncSubject();
          var handler = function() {
            var innerArgs = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              innerArgs[_i2] = arguments[_i2];
            }
            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
            subject.complete();
          };
          try {
            callbackFunc.apply(context2, args.concat([handler]));
          } catch (err) {
            if (canReportError(subject)) {
              subject.error(err);
            } else {
              console.warn(err);
            }
          }
        }
        return subject.subscribe(subscriber);
      } else {
        var state = {
          args,
          subscriber,
          params
        };
        return scheduler.schedule(dispatch$6, 0, state);
      }
    });
  };
}
function dispatch$6(state) {
  var _this = this;
  var args = state.args, subscriber = state.subscriber, params = state.params;
  var callbackFunc = params.callbackFunc, context2 = params.context, scheduler = params.scheduler;
  var subject = params.subject;
  if (!subject) {
    subject = params.subject = new AsyncSubject();
    var handler = function() {
      var innerArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        innerArgs[_i] = arguments[_i];
      }
      var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
      _this.add(scheduler.schedule(dispatchNext$3, 0, { value, subject }));
    };
    try {
      callbackFunc.apply(context2, args.concat([handler]));
    } catch (err) {
      subject.error(err);
    }
  }
  this.add(subject.subscribe(subscriber));
}
function dispatchNext$3(state) {
  var value = state.value, subject = state.subject;
  subject.next(value);
  subject.complete();
}
function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
  if (resultSelector) {
    if (isScheduler(resultSelector)) {
      scheduler = resultSelector;
    } else {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function(args2) {
          return isArray(args2) ? resultSelector.apply(void 0, args2) : resultSelector(args2);
        }));
      };
    }
  }
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var params = {
      subject: void 0,
      args,
      callbackFunc,
      scheduler,
      context: this
    };
    return new Observable(function(subscriber) {
      var context2 = params.context;
      var subject = params.subject;
      if (!scheduler) {
        if (!subject) {
          subject = params.subject = new AsyncSubject();
          var handler = function() {
            var innerArgs = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              innerArgs[_i2] = arguments[_i2];
            }
            var err = innerArgs.shift();
            if (err) {
              subject.error(err);
              return;
            }
            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
            subject.complete();
          };
          try {
            callbackFunc.apply(context2, args.concat([handler]));
          } catch (err) {
            if (canReportError(subject)) {
              subject.error(err);
            } else {
              console.warn(err);
            }
          }
        }
        return subject.subscribe(subscriber);
      } else {
        return scheduler.schedule(dispatch$5, 0, { params, subscriber, context: context2 });
      }
    });
  };
}
function dispatch$5(state) {
  var _this = this;
  var params = state.params, subscriber = state.subscriber, context2 = state.context;
  var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;
  var subject = params.subject;
  if (!subject) {
    subject = params.subject = new AsyncSubject();
    var handler = function() {
      var innerArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        innerArgs[_i] = arguments[_i];
      }
      var err = innerArgs.shift();
      if (err) {
        _this.add(scheduler.schedule(dispatchError, 0, { err, subject }));
      } else {
        var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
        _this.add(scheduler.schedule(dispatchNext$2, 0, { value, subject }));
      }
    };
    try {
      callbackFunc.apply(context2, args.concat([handler]));
    } catch (err) {
      this.add(scheduler.schedule(dispatchError, 0, { err, subject }));
    }
  }
  this.add(subject.subscribe(subscriber));
}
function dispatchNext$2(arg) {
  var value = arg.value, subject = arg.subject;
  subject.next(value);
  subject.complete();
}
function dispatchError(arg) {
  var err = arg.err, subject = arg.subject;
  subject.error(err);
}
var OuterSubscriber = /* @__PURE__ */ function(_super) {
  __extends(OuterSubscriber2, _super);
  function OuterSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  OuterSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.destination.next(innerValue);
  };
  OuterSubscriber2.prototype.notifyError = function(error, innerSub) {
    this.destination.error(error);
  };
  OuterSubscriber2.prototype.notifyComplete = function(innerSub) {
    this.destination.complete();
  };
  return OuterSubscriber2;
}(Subscriber);
var InnerSubscriber = /* @__PURE__ */ function(_super) {
  __extends(InnerSubscriber2, _super);
  function InnerSubscriber2(parent, outerValue, outerIndex) {
    var _this = _super.call(this) || this;
    _this.parent = parent;
    _this.outerValue = outerValue;
    _this.outerIndex = outerIndex;
    _this.index = 0;
    return _this;
  }
  InnerSubscriber2.prototype._next = function(value) {
    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
  };
  InnerSubscriber2.prototype._error = function(error) {
    this.parent.notifyError(error, this);
    this.unsubscribe();
  };
  InnerSubscriber2.prototype._complete = function() {
    this.parent.notifyComplete(this);
    this.unsubscribe();
  };
  return InnerSubscriber2;
}(Subscriber);
var subscribeToPromise = function(promise) {
  return function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, hostReportError);
    return subscriber;
  };
};
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = /* @__PURE__ */ getSymbolIterator();
var subscribeToIterable = function(iterable) {
  return function(subscriber) {
    var iterator$1 = iterable[iterator]();
    do {
      var item = void 0;
      try {
        item = iterator$1.next();
      } catch (err) {
        subscriber.error(err);
        return subscriber;
      }
      if (item.done) {
        subscriber.complete();
        break;
      }
      subscriber.next(item.value);
      if (subscriber.closed) {
        break;
      }
    } while (true);
    if (typeof iterator$1.return === "function") {
      subscriber.add(function() {
        if (iterator$1.return) {
          iterator$1.return();
        }
      });
    }
    return subscriber;
  };
};
var subscribeToObservable = function(obj) {
  return function(subscriber) {
    var obs = obj[observable]();
    if (typeof obs.subscribe !== "function") {
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    } else {
      return obs.subscribe(subscriber);
    }
  };
};
var isArrayLike = function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
};
function isPromise(value) {
  return !!value && typeof value.subscribe !== "function" && typeof value.then === "function";
}
var subscribeTo = function(result) {
  if (!!result && typeof result[observable] === "function") {
    return subscribeToObservable(result);
  } else if (isArrayLike(result)) {
    return subscribeToArray(result);
  } else if (isPromise(result)) {
    return subscribeToPromise(result);
  } else if (!!result && typeof result[iterator] === "function") {
    return subscribeToIterable(result);
  } else {
    var value = isObject(result) ? "an invalid object" : "'" + result + "'";
    var msg = "You provided " + value + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
    throw new TypeError(msg);
  }
};
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
  if (innerSubscriber === void 0) {
    innerSubscriber = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
  }
  if (innerSubscriber.closed) {
    return void 0;
  }
  if (result instanceof Observable) {
    return result.subscribe(innerSubscriber);
  }
  return subscribeTo(result)(innerSubscriber);
}
var NONE = {};
function combineLatest$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var resultSelector = void 0;
  var scheduler = void 0;
  if (isScheduler(observables[observables.length - 1])) {
    scheduler = observables.pop();
  }
  if (typeof observables[observables.length - 1] === "function") {
    resultSelector = observables.pop();
  }
  if (observables.length === 1 && isArray(observables[0])) {
    observables = observables[0];
  }
  return fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
var CombineLatestOperator = /* @__PURE__ */ function() {
  function CombineLatestOperator2(resultSelector) {
    this.resultSelector = resultSelector;
  }
  CombineLatestOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
  };
  return CombineLatestOperator2;
}();
var CombineLatestSubscriber = /* @__PURE__ */ function(_super) {
  __extends(CombineLatestSubscriber2, _super);
  function CombineLatestSubscriber2(destination, resultSelector) {
    var _this = _super.call(this, destination) || this;
    _this.resultSelector = resultSelector;
    _this.active = 0;
    _this.values = [];
    _this.observables = [];
    return _this;
  }
  CombineLatestSubscriber2.prototype._next = function(observable2) {
    this.values.push(NONE);
    this.observables.push(observable2);
  };
  CombineLatestSubscriber2.prototype._complete = function() {
    var observables = this.observables;
    var len = observables.length;
    if (len === 0) {
      this.destination.complete();
    } else {
      this.active = len;
      this.toRespond = len;
      for (var i = 0; i < len; i++) {
        var observable2 = observables[i];
        this.add(subscribeToResult(this, observable2, void 0, i));
      }
    }
  };
  CombineLatestSubscriber2.prototype.notifyComplete = function(unused) {
    if ((this.active -= 1) === 0) {
      this.destination.complete();
    }
  };
  CombineLatestSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
    var values = this.values;
    var oldVal = values[outerIndex];
    var toRespond = !this.toRespond ? 0 : oldVal === NONE ? --this.toRespond : this.toRespond;
    values[outerIndex] = innerValue;
    if (toRespond === 0) {
      if (this.resultSelector) {
        this._tryResultSelector(values);
      } else {
        this.destination.next(values.slice());
      }
    }
  };
  CombineLatestSubscriber2.prototype._tryResultSelector = function(values) {
    var result;
    try {
      result = this.resultSelector.apply(this, values);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return CombineLatestSubscriber2;
}(OuterSubscriber);
function scheduleObservable(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    sub.add(scheduler.schedule(function() {
      var observable$1 = input[observable]();
      sub.add(observable$1.subscribe({
        next: function(value) {
          sub.add(scheduler.schedule(function() {
            return subscriber.next(value);
          }));
        },
        error: function(err) {
          sub.add(scheduler.schedule(function() {
            return subscriber.error(err);
          }));
        },
        complete: function() {
          sub.add(scheduler.schedule(function() {
            return subscriber.complete();
          }));
        }
      }));
    }));
    return sub;
  });
}
function schedulePromise(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    sub.add(scheduler.schedule(function() {
      return input.then(function(value) {
        sub.add(scheduler.schedule(function() {
          subscriber.next(value);
          sub.add(scheduler.schedule(function() {
            return subscriber.complete();
          }));
        }));
      }, function(err) {
        sub.add(scheduler.schedule(function() {
          return subscriber.error(err);
        }));
      });
    }));
    return sub;
  });
}
function scheduleIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    var iterator$1;
    sub.add(function() {
      if (iterator$1 && typeof iterator$1.return === "function") {
        iterator$1.return();
      }
    });
    sub.add(scheduler.schedule(function() {
      iterator$1 = input[iterator]();
      sub.add(scheduler.schedule(function() {
        if (subscriber.closed) {
          return;
        }
        var value;
        var done;
        try {
          var result = iterator$1.next();
          value = result.value;
          done = result.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
          this.schedule();
        }
      }));
    }));
    return sub;
  });
}
function isInteropObservable(input) {
  return input && typeof input[observable] === "function";
}
function isIterable(input) {
  return input && typeof input[iterator] === "function";
}
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    } else if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    } else if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    } else if (isIterable(input) || typeof input === "string") {
      return scheduleIterable(input, scheduler);
    }
  }
  throw new TypeError((input !== null && typeof input || input) + " is not observable");
}
function from(input, scheduler) {
  if (!scheduler) {
    if (input instanceof Observable) {
      return input;
    }
    return new Observable(subscribeTo(input));
  } else {
    return scheduled(input, scheduler);
  }
}
var SimpleInnerSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SimpleInnerSubscriber2, _super);
  function SimpleInnerSubscriber2(parent) {
    var _this = _super.call(this) || this;
    _this.parent = parent;
    return _this;
  }
  SimpleInnerSubscriber2.prototype._next = function(value) {
    this.parent.notifyNext(value);
  };
  SimpleInnerSubscriber2.prototype._error = function(error) {
    this.parent.notifyError(error);
    this.unsubscribe();
  };
  SimpleInnerSubscriber2.prototype._complete = function() {
    this.parent.notifyComplete();
    this.unsubscribe();
  };
  return SimpleInnerSubscriber2;
}(Subscriber);
var SimpleOuterSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SimpleOuterSubscriber2, _super);
  function SimpleOuterSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SimpleOuterSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  SimpleOuterSubscriber2.prototype.notifyError = function(err) {
    this.destination.error(err);
  };
  SimpleOuterSubscriber2.prototype.notifyComplete = function() {
    this.destination.complete();
  };
  return SimpleOuterSubscriber2;
}(Subscriber);
function innerSubscribe(result, innerSubscriber) {
  if (innerSubscriber.closed) {
    return void 0;
  }
  if (result instanceof Observable) {
    return result.subscribe(innerSubscriber);
  }
  var subscription;
  try {
    subscription = subscribeTo(result)(innerSubscriber);
  } catch (error) {
    innerSubscriber.error(error);
  }
  return subscription;
}
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  if (typeof resultSelector === "function") {
    return function(source) {
      return source.pipe(mergeMap(function(a, i) {
        return from(project(a, i)).pipe(map(function(b, ii) {
          return resultSelector(a, b, i, ii);
        }));
      }, concurrent));
    };
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return function(source) {
    return source.lift(new MergeMapOperator(project, concurrent));
  };
}
var MergeMapOperator = /* @__PURE__ */ function() {
  function MergeMapOperator2(project, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }
    this.project = project;
    this.concurrent = concurrent;
  }
  MergeMapOperator2.prototype.call = function(observer, source) {
    return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
  };
  return MergeMapOperator2;
}();
var MergeMapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MergeMapSubscriber2, _super);
  function MergeMapSubscriber2(destination, project, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.concurrent = concurrent;
    _this.hasCompleted = false;
    _this.buffer = [];
    _this.active = 0;
    _this.index = 0;
    return _this;
  }
  MergeMapSubscriber2.prototype._next = function(value) {
    if (this.active < this.concurrent) {
      this._tryNext(value);
    } else {
      this.buffer.push(value);
    }
  };
  MergeMapSubscriber2.prototype._tryNext = function(value) {
    var result;
    var index = this.index++;
    try {
      result = this.project(value, index);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.active++;
    this._innerSub(result);
  };
  MergeMapSubscriber2.prototype._innerSub = function(ish) {
    var innerSubscriber = new SimpleInnerSubscriber(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = innerSubscribe(ish, innerSubscriber);
    if (innerSubscription !== innerSubscriber) {
      destination.add(innerSubscription);
    }
  };
  MergeMapSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (this.active === 0 && this.buffer.length === 0) {
      this.destination.complete();
    }
    this.unsubscribe();
  };
  MergeMapSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  MergeMapSubscriber2.prototype.notifyComplete = function() {
    var buffer2 = this.buffer;
    this.active--;
    if (buffer2.length > 0) {
      this._next(buffer2.shift());
    } else if (this.active === 0 && this.hasCompleted) {
      this.destination.complete();
    }
  };
  return MergeMapSubscriber2;
}(SimpleOuterSubscriber);
var flatMap = mergeMap;
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  return mergeMap(identity, concurrent);
}
function concatAll() {
  return mergeAll(1);
}
function concat$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return concatAll()(of.apply(void 0, observables));
}
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    var input;
    try {
      input = observableFactory();
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var source = input ? from(input) : empty();
    return source.subscribe(subscriber);
  });
}
function forkJoin() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  if (sources.length === 1) {
    var first_1 = sources[0];
    if (isArray(first_1)) {
      return forkJoinInternal(first_1, null);
    }
    if (isObject(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {
      var keys = Object.keys(first_1);
      return forkJoinInternal(keys.map(function(key) {
        return first_1[key];
      }), keys);
    }
  }
  if (typeof sources[sources.length - 1] === "function") {
    var resultSelector_1 = sources.pop();
    sources = sources.length === 1 && isArray(sources[0]) ? sources[0] : sources;
    return forkJoinInternal(sources, null).pipe(map(function(args) {
      return resultSelector_1.apply(void 0, args);
    }));
  }
  return forkJoinInternal(sources, null);
}
function forkJoinInternal(sources, keys) {
  return new Observable(function(subscriber) {
    var len = sources.length;
    if (len === 0) {
      subscriber.complete();
      return;
    }
    var values = new Array(len);
    var completed = 0;
    var emitted = 0;
    var _loop_1 = function(i2) {
      var source = from(sources[i2]);
      var hasValue = false;
      subscriber.add(source.subscribe({
        next: function(value) {
          if (!hasValue) {
            hasValue = true;
            emitted++;
          }
          values[i2] = value;
        },
        error: function(err) {
          return subscriber.error(err);
        },
        complete: function() {
          completed++;
          if (completed === len || !hasValue) {
            if (emitted === len) {
              subscriber.next(keys ? keys.reduce(function(result, key, i3) {
                return result[key] = values[i3], result;
              }, {}) : values);
            }
            subscriber.complete();
          }
        }
      }));
    };
    for (var i = 0; i < len; i++) {
      _loop_1(i);
    }
  });
}
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(map(function(args) {
      return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
    }));
  }
  return new Observable(function(subscriber) {
    function handler(e) {
      if (arguments.length > 1) {
        subscriber.next(Array.prototype.slice.call(arguments));
      } else {
        subscriber.next(e);
      }
    }
    setupSubscription(target, eventName, handler, subscriber, options);
  });
}
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
  var unsubscribe2;
  if (isEventTarget(sourceObj)) {
    var source_1 = sourceObj;
    sourceObj.addEventListener(eventName, handler, options);
    unsubscribe2 = function() {
      return source_1.removeEventListener(eventName, handler, options);
    };
  } else if (isJQueryStyleEventEmitter(sourceObj)) {
    var source_2 = sourceObj;
    sourceObj.on(eventName, handler);
    unsubscribe2 = function() {
      return source_2.off(eventName, handler);
    };
  } else if (isNodeStyleEventEmitter(sourceObj)) {
    var source_3 = sourceObj;
    sourceObj.addListener(eventName, handler);
    unsubscribe2 = function() {
      return source_3.removeListener(eventName, handler);
    };
  } else if (sourceObj && sourceObj.length) {
    for (var i = 0, len = sourceObj.length; i < len; i++) {
      setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
    }
  } else {
    throw new TypeError("Invalid event target");
  }
  subscriber.add(unsubscribe2);
}
function isNodeStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.addListener === "function" && typeof sourceObj.removeListener === "function";
}
function isJQueryStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.on === "function" && typeof sourceObj.off === "function";
}
function isEventTarget(sourceObj) {
  return sourceObj && typeof sourceObj.addEventListener === "function" && typeof sourceObj.removeEventListener === "function";
}
function fromEventPattern(addHandler, removeHandler, resultSelector) {
  if (resultSelector) {
    return fromEventPattern(addHandler, removeHandler).pipe(map(function(args) {
      return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
    }));
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var e = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        e[_i] = arguments[_i];
      }
      return subscriber.next(e.length === 1 ? e[0] : e);
    };
    var retValue;
    try {
      retValue = addHandler(handler);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    if (!isFunction(removeHandler)) {
      return void 0;
    }
    return function() {
      return removeHandler(handler, retValue);
    };
  });
}
function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
  var resultSelector;
  var initialState;
  if (arguments.length == 1) {
    var options = initialStateOrOptions;
    initialState = options.initialState;
    condition = options.condition;
    iterate = options.iterate;
    resultSelector = options.resultSelector || identity;
    scheduler = options.scheduler;
  } else if (resultSelectorOrObservable === void 0 || isScheduler(resultSelectorOrObservable)) {
    initialState = initialStateOrOptions;
    resultSelector = identity;
    scheduler = resultSelectorOrObservable;
  } else {
    initialState = initialStateOrOptions;
    resultSelector = resultSelectorOrObservable;
  }
  return new Observable(function(subscriber) {
    var state = initialState;
    if (scheduler) {
      return scheduler.schedule(dispatch$4, 0, {
        subscriber,
        iterate,
        condition,
        resultSelector,
        state
      });
    }
    do {
      if (condition) {
        var conditionResult = void 0;
        try {
          conditionResult = condition(state);
        } catch (err) {
          subscriber.error(err);
          return void 0;
        }
        if (!conditionResult) {
          subscriber.complete();
          break;
        }
      }
      var value = void 0;
      try {
        value = resultSelector(state);
      } catch (err) {
        subscriber.error(err);
        return void 0;
      }
      subscriber.next(value);
      if (subscriber.closed) {
        break;
      }
      try {
        state = iterate(state);
      } catch (err) {
        subscriber.error(err);
        return void 0;
      }
    } while (true);
    return void 0;
  });
}
function dispatch$4(state) {
  var subscriber = state.subscriber, condition = state.condition;
  if (subscriber.closed) {
    return void 0;
  }
  if (state.needIterate) {
    try {
      state.state = state.iterate(state.state);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
  } else {
    state.needIterate = true;
  }
  if (condition) {
    var conditionResult = void 0;
    try {
      conditionResult = condition(state.state);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    if (!conditionResult) {
      subscriber.complete();
      return void 0;
    }
    if (subscriber.closed) {
      return void 0;
    }
  }
  var value;
  try {
    value = state.resultSelector(state.state);
  } catch (err) {
    subscriber.error(err);
    return void 0;
  }
  if (subscriber.closed) {
    return void 0;
  }
  subscriber.next(value);
  if (subscriber.closed) {
    return void 0;
  }
  return this.schedule(state);
}
function iif(condition, trueResult, falseResult) {
  if (trueResult === void 0) {
    trueResult = EMPTY;
  }
  if (falseResult === void 0) {
    falseResult = EMPTY;
  }
  return defer(function() {
    return condition() ? trueResult : falseResult;
  });
}
function isNumeric(val) {
  return !isArray(val) && val - parseFloat(val) + 1 >= 0;
}
function interval(period, scheduler) {
  if (period === void 0) {
    period = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  if (!isNumeric(period) || period < 0) {
    period = 0;
  }
  if (!scheduler || typeof scheduler.schedule !== "function") {
    scheduler = async;
  }
  return new Observable(function(subscriber) {
    subscriber.add(scheduler.schedule(dispatch$3, period, { subscriber, counter: 0, period }));
    return subscriber;
  });
}
function dispatch$3(state) {
  var subscriber = state.subscriber, counter = state.counter, period = state.period;
  subscriber.next(counter);
  this.schedule({ subscriber, counter: counter + 1, period }, period);
}
function merge$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var concurrent = Number.POSITIVE_INFINITY;
  var scheduler = null;
  var last2 = observables[observables.length - 1];
  if (isScheduler(last2)) {
    scheduler = observables.pop();
    if (observables.length > 1 && typeof observables[observables.length - 1] === "number") {
      concurrent = observables.pop();
    }
  } else if (typeof last2 === "number") {
    concurrent = observables.pop();
  }
  if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
    return observables[0];
  }
  return mergeAll(concurrent)(fromArray(observables, scheduler));
}
var NEVER = /* @__PURE__ */ new Observable(noop);
function never() {
  return NEVER;
}
function onErrorResumeNext$1() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  if (sources.length === 0) {
    return EMPTY;
  }
  var first2 = sources[0], remainder = sources.slice(1);
  if (sources.length === 1 && isArray(first2)) {
    return onErrorResumeNext$1.apply(void 0, first2);
  }
  return new Observable(function(subscriber) {
    var subNext = function() {
      return subscriber.add(onErrorResumeNext$1.apply(void 0, remainder).subscribe(subscriber));
    };
    return from(first2).subscribe({
      next: function(value) {
        subscriber.next(value);
      },
      error: subNext,
      complete: subNext
    });
  });
}
function pairs(obj, scheduler) {
  if (!scheduler) {
    return new Observable(function(subscriber) {
      var keys = Object.keys(obj);
      for (var i = 0; i < keys.length && !subscriber.closed; i++) {
        var key = keys[i];
        if (obj.hasOwnProperty(key)) {
          subscriber.next([key, obj[key]]);
        }
      }
      subscriber.complete();
    });
  } else {
    return new Observable(function(subscriber) {
      var keys = Object.keys(obj);
      var subscription = new Subscription();
      subscription.add(scheduler.schedule(dispatch$2, 0, { keys, index: 0, subscriber, subscription, obj }));
      return subscription;
    });
  }
}
function dispatch$2(state) {
  var keys = state.keys, index = state.index, subscriber = state.subscriber, subscription = state.subscription, obj = state.obj;
  if (!subscriber.closed) {
    if (index < keys.length) {
      var key = keys[index];
      subscriber.next([key, obj[key]]);
      subscription.add(this.schedule({ keys, index: index + 1, subscriber, subscription, obj }));
    } else {
      subscriber.complete();
    }
  }
}
function not2(pred, thisArg) {
  function notPred() {
    return !notPred.pred.apply(notPred.thisArg, arguments);
  }
  notPred.pred = pred;
  notPred.thisArg = thisArg;
  return notPred;
}
function filter(predicate, thisArg) {
  return function filterOperatorFunction(source) {
    return source.lift(new FilterOperator(predicate, thisArg));
  };
}
var FilterOperator = /* @__PURE__ */ function() {
  function FilterOperator2(predicate, thisArg) {
    this.predicate = predicate;
    this.thisArg = thisArg;
  }
  FilterOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
  };
  return FilterOperator2;
}();
var FilterSubscriber = /* @__PURE__ */ function(_super) {
  __extends(FilterSubscriber2, _super);
  function FilterSubscriber2(destination, predicate, thisArg) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.thisArg = thisArg;
    _this.count = 0;
    return _this;
  }
  FilterSubscriber2.prototype._next = function(value) {
    var result;
    try {
      result = this.predicate.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    if (result) {
      this.destination.next(value);
    }
  };
  return FilterSubscriber2;
}(Subscriber);
function partition$1(source, predicate, thisArg) {
  return [
    filter(predicate, thisArg)(new Observable(subscribeTo(source))),
    filter(not2(predicate, thisArg))(new Observable(subscribeTo(source)))
  ];
}
function race$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  if (observables.length === 1) {
    if (isArray(observables[0])) {
      observables = observables[0];
    } else {
      return observables[0];
    }
  }
  return fromArray(observables, void 0).lift(new RaceOperator());
}
var RaceOperator = /* @__PURE__ */ function() {
  function RaceOperator2() {
  }
  RaceOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new RaceSubscriber(subscriber));
  };
  return RaceOperator2;
}();
var RaceSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RaceSubscriber2, _super);
  function RaceSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.hasFirst = false;
    _this.observables = [];
    _this.subscriptions = [];
    return _this;
  }
  RaceSubscriber2.prototype._next = function(observable2) {
    this.observables.push(observable2);
  };
  RaceSubscriber2.prototype._complete = function() {
    var observables = this.observables;
    var len = observables.length;
    if (len === 0) {
      this.destination.complete();
    } else {
      for (var i = 0; i < len && !this.hasFirst; i++) {
        var observable2 = observables[i];
        var subscription = subscribeToResult(this, observable2, void 0, i);
        if (this.subscriptions) {
          this.subscriptions.push(subscription);
        }
        this.add(subscription);
      }
      this.observables = null;
    }
  };
  RaceSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
    if (!this.hasFirst) {
      this.hasFirst = true;
      for (var i = 0; i < this.subscriptions.length; i++) {
        if (i !== outerIndex) {
          var subscription = this.subscriptions[i];
          subscription.unsubscribe();
          this.remove(subscription);
        }
      }
      this.subscriptions = null;
    }
    this.destination.next(innerValue);
  };
  return RaceSubscriber2;
}(OuterSubscriber);
function range(start, count2, scheduler) {
  if (start === void 0) {
    start = 0;
  }
  return new Observable(function(subscriber) {
    if (count2 === void 0) {
      count2 = start;
      start = 0;
    }
    var index = 0;
    var current = start;
    if (scheduler) {
      return scheduler.schedule(dispatch$1, 0, {
        index,
        count: count2,
        start,
        subscriber
      });
    } else {
      do {
        if (index++ >= count2) {
          subscriber.complete();
          break;
        }
        subscriber.next(current++);
        if (subscriber.closed) {
          break;
        }
      } while (true);
    }
    return void 0;
  });
}
function dispatch$1(state) {
  var start = state.start, index = state.index, count2 = state.count, subscriber = state.subscriber;
  if (index >= count2) {
    subscriber.complete();
    return;
  }
  subscriber.next(start);
  if (subscriber.closed) {
    return;
  }
  state.index = index + 1;
  state.start = start + 1;
  this.schedule(state);
}
function timer(dueTime, periodOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  var period = -1;
  if (isNumeric(periodOrScheduler)) {
    period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
  } else if (isScheduler(periodOrScheduler)) {
    scheduler = periodOrScheduler;
  }
  if (!isScheduler(scheduler)) {
    scheduler = async;
  }
  return new Observable(function(subscriber) {
    var due = isNumeric(dueTime) ? dueTime : +dueTime - scheduler.now();
    return scheduler.schedule(dispatch, due, {
      index: 0,
      period,
      subscriber
    });
  });
}
function dispatch(state) {
  var index = state.index, period = state.period, subscriber = state.subscriber;
  subscriber.next(index);
  if (subscriber.closed) {
    return;
  } else if (period === -1) {
    return subscriber.complete();
  }
  state.index = index + 1;
  this.schedule(state, period);
}
function using(resourceFactory, observableFactory) {
  return new Observable(function(subscriber) {
    var resource;
    try {
      resource = resourceFactory();
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var result;
    try {
      result = observableFactory(resource);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var source = result ? from(result) : EMPTY;
    var subscription = source.subscribe(subscriber);
    return function() {
      subscription.unsubscribe();
      if (resource) {
        resource.unsubscribe();
      }
    };
  });
}
function zip$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var resultSelector = observables[observables.length - 1];
  if (typeof resultSelector === "function") {
    observables.pop();
  }
  return fromArray(observables, void 0).lift(new ZipOperator(resultSelector));
}
var ZipOperator = /* @__PURE__ */ function() {
  function ZipOperator2(resultSelector) {
    this.resultSelector = resultSelector;
  }
  ZipOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
  };
  return ZipOperator2;
}();
var ZipSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ZipSubscriber2, _super);
  function ZipSubscriber2(destination, resultSelector, values) {
    var _this = _super.call(this, destination) || this;
    _this.resultSelector = resultSelector;
    _this.iterators = [];
    _this.active = 0;
    _this.resultSelector = typeof resultSelector === "function" ? resultSelector : void 0;
    return _this;
  }
  ZipSubscriber2.prototype._next = function(value) {
    var iterators = this.iterators;
    if (isArray(value)) {
      iterators.push(new StaticArrayIterator(value));
    } else if (typeof value[iterator] === "function") {
      iterators.push(new StaticIterator(value[iterator]()));
    } else {
      iterators.push(new ZipBufferIterator(this.destination, this, value));
    }
  };
  ZipSubscriber2.prototype._complete = function() {
    var iterators = this.iterators;
    var len = iterators.length;
    this.unsubscribe();
    if (len === 0) {
      this.destination.complete();
      return;
    }
    this.active = len;
    for (var i = 0; i < len; i++) {
      var iterator2 = iterators[i];
      if (iterator2.stillUnsubscribed) {
        var destination = this.destination;
        destination.add(iterator2.subscribe());
      } else {
        this.active--;
      }
    }
  };
  ZipSubscriber2.prototype.notifyInactive = function() {
    this.active--;
    if (this.active === 0) {
      this.destination.complete();
    }
  };
  ZipSubscriber2.prototype.checkIterators = function() {
    var iterators = this.iterators;
    var len = iterators.length;
    var destination = this.destination;
    for (var i = 0; i < len; i++) {
      var iterator2 = iterators[i];
      if (typeof iterator2.hasValue === "function" && !iterator2.hasValue()) {
        return;
      }
    }
    var shouldComplete = false;
    var args = [];
    for (var i = 0; i < len; i++) {
      var iterator2 = iterators[i];
      var result = iterator2.next();
      if (iterator2.hasCompleted()) {
        shouldComplete = true;
      }
      if (result.done) {
        destination.complete();
        return;
      }
      args.push(result.value);
    }
    if (this.resultSelector) {
      this._tryresultSelector(args);
    } else {
      destination.next(args);
    }
    if (shouldComplete) {
      destination.complete();
    }
  };
  ZipSubscriber2.prototype._tryresultSelector = function(args) {
    var result;
    try {
      result = this.resultSelector.apply(this, args);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return ZipSubscriber2;
}(Subscriber);
var StaticIterator = /* @__PURE__ */ function() {
  function StaticIterator2(iterator2) {
    this.iterator = iterator2;
    this.nextResult = iterator2.next();
  }
  StaticIterator2.prototype.hasValue = function() {
    return true;
  };
  StaticIterator2.prototype.next = function() {
    var result = this.nextResult;
    this.nextResult = this.iterator.next();
    return result;
  };
  StaticIterator2.prototype.hasCompleted = function() {
    var nextResult = this.nextResult;
    return Boolean(nextResult && nextResult.done);
  };
  return StaticIterator2;
}();
var StaticArrayIterator = /* @__PURE__ */ function() {
  function StaticArrayIterator2(array) {
    this.array = array;
    this.index = 0;
    this.length = 0;
    this.length = array.length;
  }
  StaticArrayIterator2.prototype[iterator] = function() {
    return this;
  };
  StaticArrayIterator2.prototype.next = function(value) {
    var i = this.index++;
    var array = this.array;
    return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
  };
  StaticArrayIterator2.prototype.hasValue = function() {
    return this.array.length > this.index;
  };
  StaticArrayIterator2.prototype.hasCompleted = function() {
    return this.array.length === this.index;
  };
  return StaticArrayIterator2;
}();
var ZipBufferIterator = /* @__PURE__ */ function(_super) {
  __extends(ZipBufferIterator2, _super);
  function ZipBufferIterator2(destination, parent, observable2) {
    var _this = _super.call(this, destination) || this;
    _this.parent = parent;
    _this.observable = observable2;
    _this.stillUnsubscribed = true;
    _this.buffer = [];
    _this.isComplete = false;
    return _this;
  }
  ZipBufferIterator2.prototype[iterator] = function() {
    return this;
  };
  ZipBufferIterator2.prototype.next = function() {
    var buffer2 = this.buffer;
    if (buffer2.length === 0 && this.isComplete) {
      return { value: null, done: true };
    } else {
      return { value: buffer2.shift(), done: false };
    }
  };
  ZipBufferIterator2.prototype.hasValue = function() {
    return this.buffer.length > 0;
  };
  ZipBufferIterator2.prototype.hasCompleted = function() {
    return this.buffer.length === 0 && this.isComplete;
  };
  ZipBufferIterator2.prototype.notifyComplete = function() {
    if (this.buffer.length > 0) {
      this.isComplete = true;
      this.parent.notifyInactive();
    } else {
      this.destination.complete();
    }
  };
  ZipBufferIterator2.prototype.notifyNext = function(innerValue) {
    this.buffer.push(innerValue);
    this.parent.checkIterators();
  };
  ZipBufferIterator2.prototype.subscribe = function() {
    return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));
  };
  return ZipBufferIterator2;
}(SimpleOuterSubscriber);
var _esm5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Observable,
  ConnectableObservable,
  GroupedObservable,
  observable,
  Subject,
  BehaviorSubject,
  ReplaySubject,
  AsyncSubject,
  asap,
  asapScheduler,
  async,
  asyncScheduler,
  queue,
  queueScheduler,
  animationFrame,
  animationFrameScheduler,
  VirtualTimeScheduler,
  VirtualAction,
  Scheduler,
  Subscription,
  Subscriber,
  Notification,
  get NotificationKind() {
    return NotificationKind;
  },
  pipe,
  noop,
  identity,
  isObservable,
  ArgumentOutOfRangeError,
  EmptyError,
  ObjectUnsubscribedError,
  UnsubscriptionError,
  TimeoutError,
  bindCallback,
  bindNodeCallback,
  combineLatest: combineLatest$1,
  concat: concat$1,
  defer,
  empty,
  forkJoin,
  from,
  fromEvent,
  fromEventPattern,
  generate,
  iif,
  interval,
  merge: merge$1,
  never,
  of,
  onErrorResumeNext: onErrorResumeNext$1,
  pairs,
  partition: partition$1,
  race: race$1,
  range,
  throwError,
  timer,
  using,
  zip: zip$1,
  scheduled,
  EMPTY,
  NEVER,
  config: config$1
}, Symbol.toStringTag, { value: "Module" }));
var require$$12 = /* @__PURE__ */ getAugmentedNamespace(_esm5);
function audit(durationSelector) {
  return function auditOperatorFunction(source) {
    return source.lift(new AuditOperator(durationSelector));
  };
}
var AuditOperator = /* @__PURE__ */ function() {
  function AuditOperator2(durationSelector) {
    this.durationSelector = durationSelector;
  }
  AuditOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
  };
  return AuditOperator2;
}();
var AuditSubscriber = /* @__PURE__ */ function(_super) {
  __extends(AuditSubscriber2, _super);
  function AuditSubscriber2(destination, durationSelector) {
    var _this = _super.call(this, destination) || this;
    _this.durationSelector = durationSelector;
    _this.hasValue = false;
    return _this;
  }
  AuditSubscriber2.prototype._next = function(value) {
    this.value = value;
    this.hasValue = true;
    if (!this.throttled) {
      var duration = void 0;
      try {
        var durationSelector = this.durationSelector;
        duration = durationSelector(value);
      } catch (err) {
        return this.destination.error(err);
      }
      var innerSubscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
      if (!innerSubscription || innerSubscription.closed) {
        this.clearThrottle();
      } else {
        this.add(this.throttled = innerSubscription);
      }
    }
  };
  AuditSubscriber2.prototype.clearThrottle = function() {
    var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
    if (throttled) {
      this.remove(throttled);
      this.throttled = void 0;
      throttled.unsubscribe();
    }
    if (hasValue) {
      this.value = void 0;
      this.hasValue = false;
      this.destination.next(value);
    }
  };
  AuditSubscriber2.prototype.notifyNext = function() {
    this.clearThrottle();
  };
  AuditSubscriber2.prototype.notifyComplete = function() {
    this.clearThrottle();
  };
  return AuditSubscriber2;
}(SimpleOuterSubscriber);
function auditTime(duration, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return audit(function() {
    return timer(duration, scheduler);
  });
}
function buffer(closingNotifier) {
  return function bufferOperatorFunction(source) {
    return source.lift(new BufferOperator(closingNotifier));
  };
}
var BufferOperator = /* @__PURE__ */ function() {
  function BufferOperator2(closingNotifier) {
    this.closingNotifier = closingNotifier;
  }
  BufferOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
  };
  return BufferOperator2;
}();
var BufferSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferSubscriber2, _super);
  function BufferSubscriber2(destination, closingNotifier) {
    var _this = _super.call(this, destination) || this;
    _this.buffer = [];
    _this.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(_this)));
    return _this;
  }
  BufferSubscriber2.prototype._next = function(value) {
    this.buffer.push(value);
  };
  BufferSubscriber2.prototype.notifyNext = function() {
    var buffer2 = this.buffer;
    this.buffer = [];
    this.destination.next(buffer2);
  };
  return BufferSubscriber2;
}(SimpleOuterSubscriber);
function bufferCount(bufferSize, startBufferEvery) {
  if (startBufferEvery === void 0) {
    startBufferEvery = null;
  }
  return function bufferCountOperatorFunction(source) {
    return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
  };
}
var BufferCountOperator = /* @__PURE__ */ function() {
  function BufferCountOperator2(bufferSize, startBufferEvery) {
    this.bufferSize = bufferSize;
    this.startBufferEvery = startBufferEvery;
    if (!startBufferEvery || bufferSize === startBufferEvery) {
      this.subscriberClass = BufferCountSubscriber;
    } else {
      this.subscriberClass = BufferSkipCountSubscriber;
    }
  }
  BufferCountOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
  };
  return BufferCountOperator2;
}();
var BufferCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferCountSubscriber2, _super);
  function BufferCountSubscriber2(destination, bufferSize) {
    var _this = _super.call(this, destination) || this;
    _this.bufferSize = bufferSize;
    _this.buffer = [];
    return _this;
  }
  BufferCountSubscriber2.prototype._next = function(value) {
    var buffer2 = this.buffer;
    buffer2.push(value);
    if (buffer2.length == this.bufferSize) {
      this.destination.next(buffer2);
      this.buffer = [];
    }
  };
  BufferCountSubscriber2.prototype._complete = function() {
    var buffer2 = this.buffer;
    if (buffer2.length > 0) {
      this.destination.next(buffer2);
    }
    _super.prototype._complete.call(this);
  };
  return BufferCountSubscriber2;
}(Subscriber);
var BufferSkipCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferSkipCountSubscriber2, _super);
  function BufferSkipCountSubscriber2(destination, bufferSize, startBufferEvery) {
    var _this = _super.call(this, destination) || this;
    _this.bufferSize = bufferSize;
    _this.startBufferEvery = startBufferEvery;
    _this.buffers = [];
    _this.count = 0;
    return _this;
  }
  BufferSkipCountSubscriber2.prototype._next = function(value) {
    var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count2 = _a.count;
    this.count++;
    if (count2 % startBufferEvery === 0) {
      buffers.push([]);
    }
    for (var i = buffers.length; i--; ) {
      var buffer2 = buffers[i];
      buffer2.push(value);
      if (buffer2.length === bufferSize) {
        buffers.splice(i, 1);
        this.destination.next(buffer2);
      }
    }
  };
  BufferSkipCountSubscriber2.prototype._complete = function() {
    var _a = this, buffers = _a.buffers, destination = _a.destination;
    while (buffers.length > 0) {
      var buffer2 = buffers.shift();
      if (buffer2.length > 0) {
        destination.next(buffer2);
      }
    }
    _super.prototype._complete.call(this);
  };
  return BufferSkipCountSubscriber2;
}(Subscriber);
function bufferTime(bufferTimeSpan) {
  var length = arguments.length;
  var scheduler = async;
  if (isScheduler(arguments[arguments.length - 1])) {
    scheduler = arguments[arguments.length - 1];
    length--;
  }
  var bufferCreationInterval = null;
  if (length >= 2) {
    bufferCreationInterval = arguments[1];
  }
  var maxBufferSize = Number.POSITIVE_INFINITY;
  if (length >= 3) {
    maxBufferSize = arguments[2];
  }
  return function bufferTimeOperatorFunction(source) {
    return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
  };
}
var BufferTimeOperator = /* @__PURE__ */ function() {
  function BufferTimeOperator2(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
    this.bufferTimeSpan = bufferTimeSpan;
    this.bufferCreationInterval = bufferCreationInterval;
    this.maxBufferSize = maxBufferSize;
    this.scheduler = scheduler;
  }
  BufferTimeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
  };
  return BufferTimeOperator2;
}();
var Context2 = /* @__PURE__ */ function() {
  function Context3() {
    this.buffer = [];
  }
  return Context3;
}();
var BufferTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferTimeSubscriber2, _super);
  function BufferTimeSubscriber2(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.bufferTimeSpan = bufferTimeSpan;
    _this.bufferCreationInterval = bufferCreationInterval;
    _this.maxBufferSize = maxBufferSize;
    _this.scheduler = scheduler;
    _this.contexts = [];
    var context2 = _this.openContext();
    _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
    if (_this.timespanOnly) {
      var timeSpanOnlyState = { subscriber: _this, context: context2, bufferTimeSpan };
      _this.add(context2.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
    } else {
      var closeState = { subscriber: _this, context: context2 };
      var creationState = { bufferTimeSpan, bufferCreationInterval, subscriber: _this, scheduler };
      _this.add(context2.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
      _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
    }
    return _this;
  }
  BufferTimeSubscriber2.prototype._next = function(value) {
    var contexts = this.contexts;
    var len = contexts.length;
    var filledBufferContext;
    for (var i = 0; i < len; i++) {
      var context_1 = contexts[i];
      var buffer2 = context_1.buffer;
      buffer2.push(value);
      if (buffer2.length == this.maxBufferSize) {
        filledBufferContext = context_1;
      }
    }
    if (filledBufferContext) {
      this.onBufferFull(filledBufferContext);
    }
  };
  BufferTimeSubscriber2.prototype._error = function(err) {
    this.contexts.length = 0;
    _super.prototype._error.call(this, err);
  };
  BufferTimeSubscriber2.prototype._complete = function() {
    var _a = this, contexts = _a.contexts, destination = _a.destination;
    while (contexts.length > 0) {
      var context_2 = contexts.shift();
      destination.next(context_2.buffer);
    }
    _super.prototype._complete.call(this);
  };
  BufferTimeSubscriber2.prototype._unsubscribe = function() {
    this.contexts = null;
  };
  BufferTimeSubscriber2.prototype.onBufferFull = function(context2) {
    this.closeContext(context2);
    var closeAction = context2.closeAction;
    closeAction.unsubscribe();
    this.remove(closeAction);
    if (!this.closed && this.timespanOnly) {
      context2 = this.openContext();
      var bufferTimeSpan = this.bufferTimeSpan;
      var timeSpanOnlyState = { subscriber: this, context: context2, bufferTimeSpan };
      this.add(context2.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
    }
  };
  BufferTimeSubscriber2.prototype.openContext = function() {
    var context2 = new Context2();
    this.contexts.push(context2);
    return context2;
  };
  BufferTimeSubscriber2.prototype.closeContext = function(context2) {
    this.destination.next(context2.buffer);
    var contexts = this.contexts;
    var spliceIndex = contexts ? contexts.indexOf(context2) : -1;
    if (spliceIndex >= 0) {
      contexts.splice(contexts.indexOf(context2), 1);
    }
  };
  return BufferTimeSubscriber2;
}(Subscriber);
function dispatchBufferTimeSpanOnly(state) {
  var subscriber = state.subscriber;
  var prevContext = state.context;
  if (prevContext) {
    subscriber.closeContext(prevContext);
  }
  if (!subscriber.closed) {
    state.context = subscriber.openContext();
    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
  }
}
function dispatchBufferCreation(state) {
  var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
  var context2 = subscriber.openContext();
  var action = this;
  if (!subscriber.closed) {
    subscriber.add(context2.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber, context: context2 }));
    action.schedule(state, bufferCreationInterval);
  }
}
function dispatchBufferClose(arg) {
  var subscriber = arg.subscriber, context2 = arg.context;
  subscriber.closeContext(context2);
}
function bufferToggle(openings, closingSelector) {
  return function bufferToggleOperatorFunction(source) {
    return source.lift(new BufferToggleOperator(openings, closingSelector));
  };
}
var BufferToggleOperator = /* @__PURE__ */ function() {
  function BufferToggleOperator2(openings, closingSelector) {
    this.openings = openings;
    this.closingSelector = closingSelector;
  }
  BufferToggleOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
  };
  return BufferToggleOperator2;
}();
var BufferToggleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferToggleSubscriber2, _super);
  function BufferToggleSubscriber2(destination, openings, closingSelector) {
    var _this = _super.call(this, destination) || this;
    _this.closingSelector = closingSelector;
    _this.contexts = [];
    _this.add(subscribeToResult(_this, openings));
    return _this;
  }
  BufferToggleSubscriber2.prototype._next = function(value) {
    var contexts = this.contexts;
    var len = contexts.length;
    for (var i = 0; i < len; i++) {
      contexts[i].buffer.push(value);
    }
  };
  BufferToggleSubscriber2.prototype._error = function(err) {
    var contexts = this.contexts;
    while (contexts.length > 0) {
      var context_1 = contexts.shift();
      context_1.subscription.unsubscribe();
      context_1.buffer = null;
      context_1.subscription = null;
    }
    this.contexts = null;
    _super.prototype._error.call(this, err);
  };
  BufferToggleSubscriber2.prototype._complete = function() {
    var contexts = this.contexts;
    while (contexts.length > 0) {
      var context_2 = contexts.shift();
      this.destination.next(context_2.buffer);
      context_2.subscription.unsubscribe();
      context_2.buffer = null;
      context_2.subscription = null;
    }
    this.contexts = null;
    _super.prototype._complete.call(this);
  };
  BufferToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue) {
    outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
  };
  BufferToggleSubscriber2.prototype.notifyComplete = function(innerSub) {
    this.closeBuffer(innerSub.context);
  };
  BufferToggleSubscriber2.prototype.openBuffer = function(value) {
    try {
      var closingSelector = this.closingSelector;
      var closingNotifier = closingSelector.call(this, value);
      if (closingNotifier) {
        this.trySubscribe(closingNotifier);
      }
    } catch (err) {
      this._error(err);
    }
  };
  BufferToggleSubscriber2.prototype.closeBuffer = function(context2) {
    var contexts = this.contexts;
    if (contexts && context2) {
      var buffer2 = context2.buffer, subscription = context2.subscription;
      this.destination.next(buffer2);
      contexts.splice(contexts.indexOf(context2), 1);
      this.remove(subscription);
      subscription.unsubscribe();
    }
  };
  BufferToggleSubscriber2.prototype.trySubscribe = function(closingNotifier) {
    var contexts = this.contexts;
    var buffer2 = [];
    var subscription = new Subscription();
    var context2 = { buffer: buffer2, subscription };
    contexts.push(context2);
    var innerSubscription = subscribeToResult(this, closingNotifier, context2);
    if (!innerSubscription || innerSubscription.closed) {
      this.closeBuffer(context2);
    } else {
      innerSubscription.context = context2;
      this.add(innerSubscription);
      subscription.add(innerSubscription);
    }
  };
  return BufferToggleSubscriber2;
}(OuterSubscriber);
function bufferWhen(closingSelector) {
  return function(source) {
    return source.lift(new BufferWhenOperator(closingSelector));
  };
}
var BufferWhenOperator = /* @__PURE__ */ function() {
  function BufferWhenOperator2(closingSelector) {
    this.closingSelector = closingSelector;
  }
  BufferWhenOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
  };
  return BufferWhenOperator2;
}();
var BufferWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferWhenSubscriber2, _super);
  function BufferWhenSubscriber2(destination, closingSelector) {
    var _this = _super.call(this, destination) || this;
    _this.closingSelector = closingSelector;
    _this.subscribing = false;
    _this.openBuffer();
    return _this;
  }
  BufferWhenSubscriber2.prototype._next = function(value) {
    this.buffer.push(value);
  };
  BufferWhenSubscriber2.prototype._complete = function() {
    var buffer2 = this.buffer;
    if (buffer2) {
      this.destination.next(buffer2);
    }
    _super.prototype._complete.call(this);
  };
  BufferWhenSubscriber2.prototype._unsubscribe = function() {
    this.buffer = void 0;
    this.subscribing = false;
  };
  BufferWhenSubscriber2.prototype.notifyNext = function() {
    this.openBuffer();
  };
  BufferWhenSubscriber2.prototype.notifyComplete = function() {
    if (this.subscribing) {
      this.complete();
    } else {
      this.openBuffer();
    }
  };
  BufferWhenSubscriber2.prototype.openBuffer = function() {
    var closingSubscription = this.closingSubscription;
    if (closingSubscription) {
      this.remove(closingSubscription);
      closingSubscription.unsubscribe();
    }
    var buffer2 = this.buffer;
    if (this.buffer) {
      this.destination.next(buffer2);
    }
    this.buffer = [];
    var closingNotifier;
    try {
      var closingSelector = this.closingSelector;
      closingNotifier = closingSelector();
    } catch (err) {
      return this.error(err);
    }
    closingSubscription = new Subscription();
    this.closingSubscription = closingSubscription;
    this.add(closingSubscription);
    this.subscribing = true;
    closingSubscription.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(this)));
    this.subscribing = false;
  };
  return BufferWhenSubscriber2;
}(SimpleOuterSubscriber);
function catchError(selector) {
  return function catchErrorOperatorFunction(source) {
    var operator = new CatchOperator(selector);
    var caught = source.lift(operator);
    return operator.caught = caught;
  };
}
var CatchOperator = /* @__PURE__ */ function() {
  function CatchOperator2(selector) {
    this.selector = selector;
  }
  CatchOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
  };
  return CatchOperator2;
}();
var CatchSubscriber = /* @__PURE__ */ function(_super) {
  __extends(CatchSubscriber2, _super);
  function CatchSubscriber2(destination, selector, caught) {
    var _this = _super.call(this, destination) || this;
    _this.selector = selector;
    _this.caught = caught;
    return _this;
  }
  CatchSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var result = void 0;
      try {
        result = this.selector(err, this.caught);
      } catch (err2) {
        _super.prototype.error.call(this, err2);
        return;
      }
      this._unsubscribeAndRecycle();
      var innerSubscriber = new SimpleInnerSubscriber(this);
      this.add(innerSubscriber);
      var innerSubscription = innerSubscribe(result, innerSubscriber);
      if (innerSubscription !== innerSubscriber) {
        this.add(innerSubscription);
      }
    }
  };
  return CatchSubscriber2;
}(SimpleOuterSubscriber);
function combineAll(project) {
  return function(source) {
    return source.lift(new CombineLatestOperator(project));
  };
}
function combineLatest() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var project = null;
  if (typeof observables[observables.length - 1] === "function") {
    project = observables.pop();
  }
  if (observables.length === 1 && isArray(observables[0])) {
    observables = observables[0].slice();
  }
  return function(source) {
    return source.lift.call(from([source].concat(observables)), new CombineLatestOperator(project));
  };
}
function concat() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function(source) {
    return source.lift.call(concat$1.apply(void 0, [source].concat(observables)));
  };
}
function concatMap(project, resultSelector) {
  return mergeMap(project, resultSelector, 1);
}
function concatMapTo(innerObservable, resultSelector) {
  return concatMap(function() {
    return innerObservable;
  }, resultSelector);
}
function count(predicate) {
  return function(source) {
    return source.lift(new CountOperator(predicate, source));
  };
}
var CountOperator = /* @__PURE__ */ function() {
  function CountOperator2(predicate, source) {
    this.predicate = predicate;
    this.source = source;
  }
  CountOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
  };
  return CountOperator2;
}();
var CountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(CountSubscriber2, _super);
  function CountSubscriber2(destination, predicate, source) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.source = source;
    _this.count = 0;
    _this.index = 0;
    return _this;
  }
  CountSubscriber2.prototype._next = function(value) {
    if (this.predicate) {
      this._tryPredicate(value);
    } else {
      this.count++;
    }
  };
  CountSubscriber2.prototype._tryPredicate = function(value) {
    var result;
    try {
      result = this.predicate(value, this.index++, this.source);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    if (result) {
      this.count++;
    }
  };
  CountSubscriber2.prototype._complete = function() {
    this.destination.next(this.count);
    this.destination.complete();
  };
  return CountSubscriber2;
}(Subscriber);
function debounce(durationSelector) {
  return function(source) {
    return source.lift(new DebounceOperator(durationSelector));
  };
}
var DebounceOperator = /* @__PURE__ */ function() {
  function DebounceOperator2(durationSelector) {
    this.durationSelector = durationSelector;
  }
  DebounceOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
  };
  return DebounceOperator2;
}();
var DebounceSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DebounceSubscriber2, _super);
  function DebounceSubscriber2(destination, durationSelector) {
    var _this = _super.call(this, destination) || this;
    _this.durationSelector = durationSelector;
    _this.hasValue = false;
    return _this;
  }
  DebounceSubscriber2.prototype._next = function(value) {
    try {
      var result = this.durationSelector.call(this, value);
      if (result) {
        this._tryNext(value, result);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };
  DebounceSubscriber2.prototype._complete = function() {
    this.emitValue();
    this.destination.complete();
  };
  DebounceSubscriber2.prototype._tryNext = function(value, duration) {
    var subscription = this.durationSubscription;
    this.value = value;
    this.hasValue = true;
    if (subscription) {
      subscription.unsubscribe();
      this.remove(subscription);
    }
    subscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
    if (subscription && !subscription.closed) {
      this.add(this.durationSubscription = subscription);
    }
  };
  DebounceSubscriber2.prototype.notifyNext = function() {
    this.emitValue();
  };
  DebounceSubscriber2.prototype.notifyComplete = function() {
    this.emitValue();
  };
  DebounceSubscriber2.prototype.emitValue = function() {
    if (this.hasValue) {
      var value = this.value;
      var subscription = this.durationSubscription;
      if (subscription) {
        this.durationSubscription = void 0;
        subscription.unsubscribe();
        this.remove(subscription);
      }
      this.value = void 0;
      this.hasValue = false;
      _super.prototype._next.call(this, value);
    }
  };
  return DebounceSubscriber2;
}(SimpleOuterSubscriber);
function debounceTime(dueTime, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    return source.lift(new DebounceTimeOperator(dueTime, scheduler));
  };
}
var DebounceTimeOperator = /* @__PURE__ */ function() {
  function DebounceTimeOperator2(dueTime, scheduler) {
    this.dueTime = dueTime;
    this.scheduler = scheduler;
  }
  DebounceTimeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
  };
  return DebounceTimeOperator2;
}();
var DebounceTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DebounceTimeSubscriber2, _super);
  function DebounceTimeSubscriber2(destination, dueTime, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.dueTime = dueTime;
    _this.scheduler = scheduler;
    _this.debouncedSubscription = null;
    _this.lastValue = null;
    _this.hasValue = false;
    return _this;
  }
  DebounceTimeSubscriber2.prototype._next = function(value) {
    this.clearDebounce();
    this.lastValue = value;
    this.hasValue = true;
    this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$1, this.dueTime, this));
  };
  DebounceTimeSubscriber2.prototype._complete = function() {
    this.debouncedNext();
    this.destination.complete();
  };
  DebounceTimeSubscriber2.prototype.debouncedNext = function() {
    this.clearDebounce();
    if (this.hasValue) {
      var lastValue = this.lastValue;
      this.lastValue = null;
      this.hasValue = false;
      this.destination.next(lastValue);
    }
  };
  DebounceTimeSubscriber2.prototype.clearDebounce = function() {
    var debouncedSubscription = this.debouncedSubscription;
    if (debouncedSubscription !== null) {
      this.remove(debouncedSubscription);
      debouncedSubscription.unsubscribe();
      this.debouncedSubscription = null;
    }
  };
  return DebounceTimeSubscriber2;
}(Subscriber);
function dispatchNext$1(subscriber) {
  subscriber.debouncedNext();
}
function defaultIfEmpty(defaultValue) {
  if (defaultValue === void 0) {
    defaultValue = null;
  }
  return function(source) {
    return source.lift(new DefaultIfEmptyOperator(defaultValue));
  };
}
var DefaultIfEmptyOperator = /* @__PURE__ */ function() {
  function DefaultIfEmptyOperator2(defaultValue) {
    this.defaultValue = defaultValue;
  }
  DefaultIfEmptyOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
  };
  return DefaultIfEmptyOperator2;
}();
var DefaultIfEmptySubscriber = /* @__PURE__ */ function(_super) {
  __extends(DefaultIfEmptySubscriber2, _super);
  function DefaultIfEmptySubscriber2(destination, defaultValue) {
    var _this = _super.call(this, destination) || this;
    _this.defaultValue = defaultValue;
    _this.isEmpty = true;
    return _this;
  }
  DefaultIfEmptySubscriber2.prototype._next = function(value) {
    this.isEmpty = false;
    this.destination.next(value);
  };
  DefaultIfEmptySubscriber2.prototype._complete = function() {
    if (this.isEmpty) {
      this.destination.next(this.defaultValue);
    }
    this.destination.complete();
  };
  return DefaultIfEmptySubscriber2;
}(Subscriber);
function isDate(value) {
  return value instanceof Date && !isNaN(+value);
}
function delay(delay2, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  var absoluteDelay = isDate(delay2);
  var delayFor = absoluteDelay ? +delay2 - scheduler.now() : Math.abs(delay2);
  return function(source) {
    return source.lift(new DelayOperator(delayFor, scheduler));
  };
}
var DelayOperator = /* @__PURE__ */ function() {
  function DelayOperator2(delay2, scheduler) {
    this.delay = delay2;
    this.scheduler = scheduler;
  }
  DelayOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
  };
  return DelayOperator2;
}();
var DelaySubscriber = /* @__PURE__ */ function(_super) {
  __extends(DelaySubscriber2, _super);
  function DelaySubscriber2(destination, delay2, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.delay = delay2;
    _this.scheduler = scheduler;
    _this.queue = [];
    _this.active = false;
    _this.errored = false;
    return _this;
  }
  DelaySubscriber2.dispatch = function(state) {
    var source = state.source;
    var queue2 = source.queue;
    var scheduler = state.scheduler;
    var destination = state.destination;
    while (queue2.length > 0 && queue2[0].time - scheduler.now() <= 0) {
      queue2.shift().notification.observe(destination);
    }
    if (queue2.length > 0) {
      var delay_1 = Math.max(0, queue2[0].time - scheduler.now());
      this.schedule(state, delay_1);
    } else {
      this.unsubscribe();
      source.active = false;
    }
  };
  DelaySubscriber2.prototype._schedule = function(scheduler) {
    this.active = true;
    var destination = this.destination;
    destination.add(scheduler.schedule(DelaySubscriber2.dispatch, this.delay, {
      source: this,
      destination: this.destination,
      scheduler
    }));
  };
  DelaySubscriber2.prototype.scheduleNotification = function(notification) {
    if (this.errored === true) {
      return;
    }
    var scheduler = this.scheduler;
    var message = new DelayMessage(scheduler.now() + this.delay, notification);
    this.queue.push(message);
    if (this.active === false) {
      this._schedule(scheduler);
    }
  };
  DelaySubscriber2.prototype._next = function(value) {
    this.scheduleNotification(Notification.createNext(value));
  };
  DelaySubscriber2.prototype._error = function(err) {
    this.errored = true;
    this.queue = [];
    this.destination.error(err);
    this.unsubscribe();
  };
  DelaySubscriber2.prototype._complete = function() {
    this.scheduleNotification(Notification.createComplete());
    this.unsubscribe();
  };
  return DelaySubscriber2;
}(Subscriber);
var DelayMessage = /* @__PURE__ */ function() {
  function DelayMessage2(time2, notification) {
    this.time = time2;
    this.notification = notification;
  }
  return DelayMessage2;
}();
function delayWhen(delayDurationSelector, subscriptionDelay) {
  if (subscriptionDelay) {
    return function(source) {
      return new SubscriptionDelayObservable(source, subscriptionDelay).lift(new DelayWhenOperator(delayDurationSelector));
    };
  }
  return function(source) {
    return source.lift(new DelayWhenOperator(delayDurationSelector));
  };
}
var DelayWhenOperator = /* @__PURE__ */ function() {
  function DelayWhenOperator2(delayDurationSelector) {
    this.delayDurationSelector = delayDurationSelector;
  }
  DelayWhenOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
  };
  return DelayWhenOperator2;
}();
var DelayWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DelayWhenSubscriber2, _super);
  function DelayWhenSubscriber2(destination, delayDurationSelector) {
    var _this = _super.call(this, destination) || this;
    _this.delayDurationSelector = delayDurationSelector;
    _this.completed = false;
    _this.delayNotifierSubscriptions = [];
    _this.index = 0;
    return _this;
  }
  DelayWhenSubscriber2.prototype.notifyNext = function(outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
    this.destination.next(outerValue);
    this.removeSubscription(innerSub);
    this.tryComplete();
  };
  DelayWhenSubscriber2.prototype.notifyError = function(error, innerSub) {
    this._error(error);
  };
  DelayWhenSubscriber2.prototype.notifyComplete = function(innerSub) {
    var value = this.removeSubscription(innerSub);
    if (value) {
      this.destination.next(value);
    }
    this.tryComplete();
  };
  DelayWhenSubscriber2.prototype._next = function(value) {
    var index = this.index++;
    try {
      var delayNotifier = this.delayDurationSelector(value, index);
      if (delayNotifier) {
        this.tryDelay(delayNotifier, value);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };
  DelayWhenSubscriber2.prototype._complete = function() {
    this.completed = true;
    this.tryComplete();
    this.unsubscribe();
  };
  DelayWhenSubscriber2.prototype.removeSubscription = function(subscription) {
    subscription.unsubscribe();
    var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
    if (subscriptionIdx !== -1) {
      this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
    }
    return subscription.outerValue;
  };
  DelayWhenSubscriber2.prototype.tryDelay = function(delayNotifier, value) {
    var notifierSubscription = subscribeToResult(this, delayNotifier, value);
    if (notifierSubscription && !notifierSubscription.closed) {
      var destination = this.destination;
      destination.add(notifierSubscription);
      this.delayNotifierSubscriptions.push(notifierSubscription);
    }
  };
  DelayWhenSubscriber2.prototype.tryComplete = function() {
    if (this.completed && this.delayNotifierSubscriptions.length === 0) {
      this.destination.complete();
    }
  };
  return DelayWhenSubscriber2;
}(OuterSubscriber);
var SubscriptionDelayObservable = /* @__PURE__ */ function(_super) {
  __extends(SubscriptionDelayObservable2, _super);
  function SubscriptionDelayObservable2(source, subscriptionDelay) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subscriptionDelay = subscriptionDelay;
    return _this;
  }
  SubscriptionDelayObservable2.prototype._subscribe = function(subscriber) {
    this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
  };
  return SubscriptionDelayObservable2;
}(Observable);
var SubscriptionDelaySubscriber = /* @__PURE__ */ function(_super) {
  __extends(SubscriptionDelaySubscriber2, _super);
  function SubscriptionDelaySubscriber2(parent, source) {
    var _this = _super.call(this) || this;
    _this.parent = parent;
    _this.source = source;
    _this.sourceSubscribed = false;
    return _this;
  }
  SubscriptionDelaySubscriber2.prototype._next = function(unused) {
    this.subscribeToSource();
  };
  SubscriptionDelaySubscriber2.prototype._error = function(err) {
    this.unsubscribe();
    this.parent.error(err);
  };
  SubscriptionDelaySubscriber2.prototype._complete = function() {
    this.unsubscribe();
    this.subscribeToSource();
  };
  SubscriptionDelaySubscriber2.prototype.subscribeToSource = function() {
    if (!this.sourceSubscribed) {
      this.sourceSubscribed = true;
      this.unsubscribe();
      this.source.subscribe(this.parent);
    }
  };
  return SubscriptionDelaySubscriber2;
}(Subscriber);
function dematerialize() {
  return function dematerializeOperatorFunction(source) {
    return source.lift(new DeMaterializeOperator());
  };
}
var DeMaterializeOperator = /* @__PURE__ */ function() {
  function DeMaterializeOperator2() {
  }
  DeMaterializeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DeMaterializeSubscriber(subscriber));
  };
  return DeMaterializeOperator2;
}();
var DeMaterializeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DeMaterializeSubscriber2, _super);
  function DeMaterializeSubscriber2(destination) {
    return _super.call(this, destination) || this;
  }
  DeMaterializeSubscriber2.prototype._next = function(value) {
    value.observe(this.destination);
  };
  return DeMaterializeSubscriber2;
}(Subscriber);
function distinct(keySelector, flushes) {
  return function(source) {
    return source.lift(new DistinctOperator(keySelector, flushes));
  };
}
var DistinctOperator = /* @__PURE__ */ function() {
  function DistinctOperator2(keySelector, flushes) {
    this.keySelector = keySelector;
    this.flushes = flushes;
  }
  DistinctOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
  };
  return DistinctOperator2;
}();
var DistinctSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DistinctSubscriber2, _super);
  function DistinctSubscriber2(destination, keySelector, flushes) {
    var _this = _super.call(this, destination) || this;
    _this.keySelector = keySelector;
    _this.values = /* @__PURE__ */ new Set();
    if (flushes) {
      _this.add(innerSubscribe(flushes, new SimpleInnerSubscriber(_this)));
    }
    return _this;
  }
  DistinctSubscriber2.prototype.notifyNext = function() {
    this.values.clear();
  };
  DistinctSubscriber2.prototype.notifyError = function(error) {
    this._error(error);
  };
  DistinctSubscriber2.prototype._next = function(value) {
    if (this.keySelector) {
      this._useKeySelector(value);
    } else {
      this._finalizeNext(value, value);
    }
  };
  DistinctSubscriber2.prototype._useKeySelector = function(value) {
    var key;
    var destination = this.destination;
    try {
      key = this.keySelector(value);
    } catch (err) {
      destination.error(err);
      return;
    }
    this._finalizeNext(key, value);
  };
  DistinctSubscriber2.prototype._finalizeNext = function(key, value) {
    var values = this.values;
    if (!values.has(key)) {
      values.add(key);
      this.destination.next(value);
    }
  };
  return DistinctSubscriber2;
}(SimpleOuterSubscriber);
function distinctUntilChanged(compare2, keySelector) {
  return function(source) {
    return source.lift(new DistinctUntilChangedOperator(compare2, keySelector));
  };
}
var DistinctUntilChangedOperator = /* @__PURE__ */ function() {
  function DistinctUntilChangedOperator2(compare2, keySelector) {
    this.compare = compare2;
    this.keySelector = keySelector;
  }
  DistinctUntilChangedOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
  };
  return DistinctUntilChangedOperator2;
}();
var DistinctUntilChangedSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DistinctUntilChangedSubscriber2, _super);
  function DistinctUntilChangedSubscriber2(destination, compare2, keySelector) {
    var _this = _super.call(this, destination) || this;
    _this.keySelector = keySelector;
    _this.hasKey = false;
    if (typeof compare2 === "function") {
      _this.compare = compare2;
    }
    return _this;
  }
  DistinctUntilChangedSubscriber2.prototype.compare = function(x, y) {
    return x === y;
  };
  DistinctUntilChangedSubscriber2.prototype._next = function(value) {
    var key;
    try {
      var keySelector = this.keySelector;
      key = keySelector ? keySelector(value) : value;
    } catch (err) {
      return this.destination.error(err);
    }
    var result = false;
    if (this.hasKey) {
      try {
        var compare2 = this.compare;
        result = compare2(this.key, key);
      } catch (err) {
        return this.destination.error(err);
      }
    } else {
      this.hasKey = true;
    }
    if (!result) {
      this.key = key;
      this.destination.next(value);
    }
  };
  return DistinctUntilChangedSubscriber2;
}(Subscriber);
function distinctUntilKeyChanged(key, compare2) {
  return distinctUntilChanged(function(x, y) {
    return compare2 ? compare2(x[key], y[key]) : x[key] === y[key];
  });
}
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return function(source) {
    return source.lift(new ThrowIfEmptyOperator(errorFactory));
  };
}
var ThrowIfEmptyOperator = /* @__PURE__ */ function() {
  function ThrowIfEmptyOperator2(errorFactory) {
    this.errorFactory = errorFactory;
  }
  ThrowIfEmptyOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
  };
  return ThrowIfEmptyOperator2;
}();
var ThrowIfEmptySubscriber = /* @__PURE__ */ function(_super) {
  __extends(ThrowIfEmptySubscriber2, _super);
  function ThrowIfEmptySubscriber2(destination, errorFactory) {
    var _this = _super.call(this, destination) || this;
    _this.errorFactory = errorFactory;
    _this.hasValue = false;
    return _this;
  }
  ThrowIfEmptySubscriber2.prototype._next = function(value) {
    this.hasValue = true;
    this.destination.next(value);
  };
  ThrowIfEmptySubscriber2.prototype._complete = function() {
    if (!this.hasValue) {
      var err = void 0;
      try {
        err = this.errorFactory();
      } catch (e) {
        err = e;
      }
      this.destination.error(err);
    } else {
      return this.destination.complete();
    }
  };
  return ThrowIfEmptySubscriber2;
}(Subscriber);
function defaultErrorFactory() {
  return new EmptyError();
}
function take(count2) {
  return function(source) {
    if (count2 === 0) {
      return empty();
    } else {
      return source.lift(new TakeOperator(count2));
    }
  };
}
var TakeOperator = /* @__PURE__ */ function() {
  function TakeOperator2(total) {
    this.total = total;
    if (this.total < 0) {
      throw new ArgumentOutOfRangeError();
    }
  }
  TakeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new TakeSubscriber(subscriber, this.total));
  };
  return TakeOperator2;
}();
var TakeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeSubscriber2, _super);
  function TakeSubscriber2(destination, total) {
    var _this = _super.call(this, destination) || this;
    _this.total = total;
    _this.count = 0;
    return _this;
  }
  TakeSubscriber2.prototype._next = function(value) {
    var total = this.total;
    var count2 = ++this.count;
    if (count2 <= total) {
      this.destination.next(value);
      if (count2 === total) {
        this.destination.complete();
        this.unsubscribe();
      }
    }
  };
  return TakeSubscriber2;
}(Subscriber);
function elementAt(index, defaultValue) {
  if (index < 0) {
    throw new ArgumentOutOfRangeError();
  }
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(filter(function(v, i) {
      return i === index;
    }), take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new ArgumentOutOfRangeError();
    }));
  };
}
function endWith() {
  var array = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    array[_i] = arguments[_i];
  }
  return function(source) {
    return concat$1(source, of.apply(void 0, array));
  };
}
function every(predicate, thisArg) {
  return function(source) {
    return source.lift(new EveryOperator(predicate, thisArg, source));
  };
}
var EveryOperator = /* @__PURE__ */ function() {
  function EveryOperator2(predicate, thisArg, source) {
    this.predicate = predicate;
    this.thisArg = thisArg;
    this.source = source;
  }
  EveryOperator2.prototype.call = function(observer, source) {
    return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
  };
  return EveryOperator2;
}();
var EverySubscriber = /* @__PURE__ */ function(_super) {
  __extends(EverySubscriber2, _super);
  function EverySubscriber2(destination, predicate, thisArg, source) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.thisArg = thisArg;
    _this.source = source;
    _this.index = 0;
    _this.thisArg = thisArg || _this;
    return _this;
  }
  EverySubscriber2.prototype.notifyComplete = function(everyValueMatch) {
    this.destination.next(everyValueMatch);
    this.destination.complete();
  };
  EverySubscriber2.prototype._next = function(value) {
    var result = false;
    try {
      result = this.predicate.call(this.thisArg, value, this.index++, this.source);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    if (!result) {
      this.notifyComplete(false);
    }
  };
  EverySubscriber2.prototype._complete = function() {
    this.notifyComplete(true);
  };
  return EverySubscriber2;
}(Subscriber);
function exhaust() {
  return function(source) {
    return source.lift(new SwitchFirstOperator());
  };
}
var SwitchFirstOperator = /* @__PURE__ */ function() {
  function SwitchFirstOperator2() {
  }
  SwitchFirstOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SwitchFirstSubscriber(subscriber));
  };
  return SwitchFirstOperator2;
}();
var SwitchFirstSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SwitchFirstSubscriber2, _super);
  function SwitchFirstSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.hasCompleted = false;
    _this.hasSubscription = false;
    return _this;
  }
  SwitchFirstSubscriber2.prototype._next = function(value) {
    if (!this.hasSubscription) {
      this.hasSubscription = true;
      this.add(innerSubscribe(value, new SimpleInnerSubscriber(this)));
    }
  };
  SwitchFirstSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (!this.hasSubscription) {
      this.destination.complete();
    }
  };
  SwitchFirstSubscriber2.prototype.notifyComplete = function() {
    this.hasSubscription = false;
    if (this.hasCompleted) {
      this.destination.complete();
    }
  };
  return SwitchFirstSubscriber2;
}(SimpleOuterSubscriber);
function exhaustMap(project, resultSelector) {
  if (resultSelector) {
    return function(source) {
      return source.pipe(exhaustMap(function(a, i) {
        return from(project(a, i)).pipe(map(function(b, ii) {
          return resultSelector(a, b, i, ii);
        }));
      }));
    };
  }
  return function(source) {
    return source.lift(new ExhaustMapOperator(project));
  };
}
var ExhaustMapOperator = /* @__PURE__ */ function() {
  function ExhaustMapOperator2(project) {
    this.project = project;
  }
  ExhaustMapOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
  };
  return ExhaustMapOperator2;
}();
var ExhaustMapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ExhaustMapSubscriber2, _super);
  function ExhaustMapSubscriber2(destination, project) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.hasSubscription = false;
    _this.hasCompleted = false;
    _this.index = 0;
    return _this;
  }
  ExhaustMapSubscriber2.prototype._next = function(value) {
    if (!this.hasSubscription) {
      this.tryNext(value);
    }
  };
  ExhaustMapSubscriber2.prototype.tryNext = function(value) {
    var result;
    var index = this.index++;
    try {
      result = this.project(value, index);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.hasSubscription = true;
    this._innerSub(result);
  };
  ExhaustMapSubscriber2.prototype._innerSub = function(result) {
    var innerSubscriber = new SimpleInnerSubscriber(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = innerSubscribe(result, innerSubscriber);
    if (innerSubscription !== innerSubscriber) {
      destination.add(innerSubscription);
    }
  };
  ExhaustMapSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (!this.hasSubscription) {
      this.destination.complete();
    }
    this.unsubscribe();
  };
  ExhaustMapSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  ExhaustMapSubscriber2.prototype.notifyError = function(err) {
    this.destination.error(err);
  };
  ExhaustMapSubscriber2.prototype.notifyComplete = function() {
    this.hasSubscription = false;
    if (this.hasCompleted) {
      this.destination.complete();
    }
  };
  return ExhaustMapSubscriber2;
}(SimpleOuterSubscriber);
function expand(project, concurrent, scheduler) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
  return function(source) {
    return source.lift(new ExpandOperator(project, concurrent, scheduler));
  };
}
var ExpandOperator = /* @__PURE__ */ function() {
  function ExpandOperator2(project, concurrent, scheduler) {
    this.project = project;
    this.concurrent = concurrent;
    this.scheduler = scheduler;
  }
  ExpandOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
  };
  return ExpandOperator2;
}();
var ExpandSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ExpandSubscriber2, _super);
  function ExpandSubscriber2(destination, project, concurrent, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.concurrent = concurrent;
    _this.scheduler = scheduler;
    _this.index = 0;
    _this.active = 0;
    _this.hasCompleted = false;
    if (concurrent < Number.POSITIVE_INFINITY) {
      _this.buffer = [];
    }
    return _this;
  }
  ExpandSubscriber2.dispatch = function(arg) {
    var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
    subscriber.subscribeToProjection(result, value, index);
  };
  ExpandSubscriber2.prototype._next = function(value) {
    var destination = this.destination;
    if (destination.closed) {
      this._complete();
      return;
    }
    var index = this.index++;
    if (this.active < this.concurrent) {
      destination.next(value);
      try {
        var project = this.project;
        var result = project(value, index);
        if (!this.scheduler) {
          this.subscribeToProjection(result, value, index);
        } else {
          var state = { subscriber: this, result, value, index };
          var destination_1 = this.destination;
          destination_1.add(this.scheduler.schedule(ExpandSubscriber2.dispatch, 0, state));
        }
      } catch (e) {
        destination.error(e);
      }
    } else {
      this.buffer.push(value);
    }
  };
  ExpandSubscriber2.prototype.subscribeToProjection = function(result, value, index) {
    this.active++;
    var destination = this.destination;
    destination.add(innerSubscribe(result, new SimpleInnerSubscriber(this)));
  };
  ExpandSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (this.hasCompleted && this.active === 0) {
      this.destination.complete();
    }
    this.unsubscribe();
  };
  ExpandSubscriber2.prototype.notifyNext = function(innerValue) {
    this._next(innerValue);
  };
  ExpandSubscriber2.prototype.notifyComplete = function() {
    var buffer2 = this.buffer;
    this.active--;
    if (buffer2 && buffer2.length > 0) {
      this._next(buffer2.shift());
    }
    if (this.hasCompleted && this.active === 0) {
      this.destination.complete();
    }
  };
  return ExpandSubscriber2;
}(SimpleOuterSubscriber);
function finalize(callback) {
  return function(source) {
    return source.lift(new FinallyOperator(callback));
  };
}
var FinallyOperator = /* @__PURE__ */ function() {
  function FinallyOperator2(callback) {
    this.callback = callback;
  }
  FinallyOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new FinallySubscriber(subscriber, this.callback));
  };
  return FinallyOperator2;
}();
var FinallySubscriber = /* @__PURE__ */ function(_super) {
  __extends(FinallySubscriber2, _super);
  function FinallySubscriber2(destination, callback) {
    var _this = _super.call(this, destination) || this;
    _this.add(new Subscription(callback));
    return _this;
  }
  return FinallySubscriber2;
}(Subscriber);
function find(predicate, thisArg) {
  if (typeof predicate !== "function") {
    throw new TypeError("predicate is not a function");
  }
  return function(source) {
    return source.lift(new FindValueOperator(predicate, source, false, thisArg));
  };
}
var FindValueOperator = /* @__PURE__ */ function() {
  function FindValueOperator2(predicate, source, yieldIndex, thisArg) {
    this.predicate = predicate;
    this.source = source;
    this.yieldIndex = yieldIndex;
    this.thisArg = thisArg;
  }
  FindValueOperator2.prototype.call = function(observer, source) {
    return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
  };
  return FindValueOperator2;
}();
var FindValueSubscriber = /* @__PURE__ */ function(_super) {
  __extends(FindValueSubscriber2, _super);
  function FindValueSubscriber2(destination, predicate, source, yieldIndex, thisArg) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.source = source;
    _this.yieldIndex = yieldIndex;
    _this.thisArg = thisArg;
    _this.index = 0;
    return _this;
  }
  FindValueSubscriber2.prototype.notifyComplete = function(value) {
    var destination = this.destination;
    destination.next(value);
    destination.complete();
    this.unsubscribe();
  };
  FindValueSubscriber2.prototype._next = function(value) {
    var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
    var index = this.index++;
    try {
      var result = predicate.call(thisArg || this, value, index, this.source);
      if (result) {
        this.notifyComplete(this.yieldIndex ? index : value);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };
  FindValueSubscriber2.prototype._complete = function() {
    this.notifyComplete(this.yieldIndex ? -1 : void 0);
  };
  return FindValueSubscriber2;
}(Subscriber);
function findIndex(predicate, thisArg) {
  return function(source) {
    return source.lift(new FindValueOperator(predicate, source, true, thisArg));
  };
}
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v, i) {
      return predicate(v, i, source);
    }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
function ignoreElements() {
  return function ignoreElementsOperatorFunction(source) {
    return source.lift(new IgnoreElementsOperator());
  };
}
var IgnoreElementsOperator = /* @__PURE__ */ function() {
  function IgnoreElementsOperator2() {
  }
  IgnoreElementsOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new IgnoreElementsSubscriber(subscriber));
  };
  return IgnoreElementsOperator2;
}();
var IgnoreElementsSubscriber = /* @__PURE__ */ function(_super) {
  __extends(IgnoreElementsSubscriber2, _super);
  function IgnoreElementsSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  IgnoreElementsSubscriber2.prototype._next = function(unused) {
  };
  return IgnoreElementsSubscriber2;
}(Subscriber);
function isEmpty() {
  return function(source) {
    return source.lift(new IsEmptyOperator());
  };
}
var IsEmptyOperator = /* @__PURE__ */ function() {
  function IsEmptyOperator2() {
  }
  IsEmptyOperator2.prototype.call = function(observer, source) {
    return source.subscribe(new IsEmptySubscriber(observer));
  };
  return IsEmptyOperator2;
}();
var IsEmptySubscriber = /* @__PURE__ */ function(_super) {
  __extends(IsEmptySubscriber2, _super);
  function IsEmptySubscriber2(destination) {
    return _super.call(this, destination) || this;
  }
  IsEmptySubscriber2.prototype.notifyComplete = function(isEmpty2) {
    var destination = this.destination;
    destination.next(isEmpty2);
    destination.complete();
  };
  IsEmptySubscriber2.prototype._next = function(value) {
    this.notifyComplete(false);
  };
  IsEmptySubscriber2.prototype._complete = function() {
    this.notifyComplete(true);
  };
  return IsEmptySubscriber2;
}(Subscriber);
function takeLast(count2) {
  return function takeLastOperatorFunction(source) {
    if (count2 === 0) {
      return empty();
    } else {
      return source.lift(new TakeLastOperator(count2));
    }
  };
}
var TakeLastOperator = /* @__PURE__ */ function() {
  function TakeLastOperator2(total) {
    this.total = total;
    if (this.total < 0) {
      throw new ArgumentOutOfRangeError();
    }
  }
  TakeLastOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
  };
  return TakeLastOperator2;
}();
var TakeLastSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeLastSubscriber2, _super);
  function TakeLastSubscriber2(destination, total) {
    var _this = _super.call(this, destination) || this;
    _this.total = total;
    _this.ring = new Array();
    _this.count = 0;
    return _this;
  }
  TakeLastSubscriber2.prototype._next = function(value) {
    var ring = this.ring;
    var total = this.total;
    var count2 = this.count++;
    if (ring.length < total) {
      ring.push(value);
    } else {
      var index = count2 % total;
      ring[index] = value;
    }
  };
  TakeLastSubscriber2.prototype._complete = function() {
    var destination = this.destination;
    var count2 = this.count;
    if (count2 > 0) {
      var total = this.count >= this.total ? this.total : this.count;
      var ring = this.ring;
      for (var i = 0; i < total; i++) {
        var idx = count2++ % total;
        destination.next(ring[idx]);
      }
    }
    destination.complete();
  };
  return TakeLastSubscriber2;
}(Subscriber);
function last(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v, i) {
      return predicate(v, i, source);
    }) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
function mapTo(value) {
  return function(source) {
    return source.lift(new MapToOperator(value));
  };
}
var MapToOperator = /* @__PURE__ */ function() {
  function MapToOperator2(value) {
    this.value = value;
  }
  MapToOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new MapToSubscriber(subscriber, this.value));
  };
  return MapToOperator2;
}();
var MapToSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MapToSubscriber2, _super);
  function MapToSubscriber2(destination, value) {
    var _this = _super.call(this, destination) || this;
    _this.value = value;
    return _this;
  }
  MapToSubscriber2.prototype._next = function(x) {
    this.destination.next(this.value);
  };
  return MapToSubscriber2;
}(Subscriber);
function materialize() {
  return function materializeOperatorFunction(source) {
    return source.lift(new MaterializeOperator());
  };
}
var MaterializeOperator = /* @__PURE__ */ function() {
  function MaterializeOperator2() {
  }
  MaterializeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new MaterializeSubscriber(subscriber));
  };
  return MaterializeOperator2;
}();
var MaterializeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MaterializeSubscriber2, _super);
  function MaterializeSubscriber2(destination) {
    return _super.call(this, destination) || this;
  }
  MaterializeSubscriber2.prototype._next = function(value) {
    this.destination.next(Notification.createNext(value));
  };
  MaterializeSubscriber2.prototype._error = function(err) {
    var destination = this.destination;
    destination.next(Notification.createError(err));
    destination.complete();
  };
  MaterializeSubscriber2.prototype._complete = function() {
    var destination = this.destination;
    destination.next(Notification.createComplete());
    destination.complete();
  };
  return MaterializeSubscriber2;
}(Subscriber);
function scan(accumulator, seed) {
  var hasSeed = false;
  if (arguments.length >= 2) {
    hasSeed = true;
  }
  return function scanOperatorFunction(source) {
    return source.lift(new ScanOperator(accumulator, seed, hasSeed));
  };
}
var ScanOperator = /* @__PURE__ */ function() {
  function ScanOperator2(accumulator, seed, hasSeed) {
    if (hasSeed === void 0) {
      hasSeed = false;
    }
    this.accumulator = accumulator;
    this.seed = seed;
    this.hasSeed = hasSeed;
  }
  ScanOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
  };
  return ScanOperator2;
}();
var ScanSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ScanSubscriber2, _super);
  function ScanSubscriber2(destination, accumulator, _seed, hasSeed) {
    var _this = _super.call(this, destination) || this;
    _this.accumulator = accumulator;
    _this._seed = _seed;
    _this.hasSeed = hasSeed;
    _this.index = 0;
    return _this;
  }
  Object.defineProperty(ScanSubscriber2.prototype, "seed", {
    get: function() {
      return this._seed;
    },
    set: function(value) {
      this.hasSeed = true;
      this._seed = value;
    },
    enumerable: true,
    configurable: true
  });
  ScanSubscriber2.prototype._next = function(value) {
    if (!this.hasSeed) {
      this.seed = value;
      this.destination.next(value);
    } else {
      return this._tryNext(value);
    }
  };
  ScanSubscriber2.prototype._tryNext = function(value) {
    var index = this.index++;
    var result;
    try {
      result = this.accumulator(this.seed, value, index);
    } catch (err) {
      this.destination.error(err);
    }
    this.seed = result;
    this.destination.next(result);
  };
  return ScanSubscriber2;
}(Subscriber);
function reduce(accumulator, seed) {
  if (arguments.length >= 2) {
    return function reduceOperatorFunctionWithSeed(source) {
      return pipe(scan(accumulator, seed), takeLast(1), defaultIfEmpty(seed))(source);
    };
  }
  return function reduceOperatorFunction(source) {
    return pipe(scan(function(acc, value, index) {
      return accumulator(acc, value, index + 1);
    }), takeLast(1))(source);
  };
}
function max(comparer) {
  var max2 = typeof comparer === "function" ? function(x, y) {
    return comparer(x, y) > 0 ? x : y;
  } : function(x, y) {
    return x > y ? x : y;
  };
  return reduce(max2);
}
function merge() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function(source) {
    return source.lift.call(merge$1.apply(void 0, [source].concat(observables)));
  };
}
function mergeMapTo(innerObservable, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  if (typeof resultSelector === "function") {
    return mergeMap(function() {
      return innerObservable;
    }, resultSelector, concurrent);
  }
  if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return mergeMap(function() {
    return innerObservable;
  }, concurrent);
}
function mergeScan(accumulator, seed, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  return function(source) {
    return source.lift(new MergeScanOperator(accumulator, seed, concurrent));
  };
}
var MergeScanOperator = /* @__PURE__ */ function() {
  function MergeScanOperator2(accumulator, seed, concurrent) {
    this.accumulator = accumulator;
    this.seed = seed;
    this.concurrent = concurrent;
  }
  MergeScanOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
  };
  return MergeScanOperator2;
}();
var MergeScanSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MergeScanSubscriber2, _super);
  function MergeScanSubscriber2(destination, accumulator, acc, concurrent) {
    var _this = _super.call(this, destination) || this;
    _this.accumulator = accumulator;
    _this.acc = acc;
    _this.concurrent = concurrent;
    _this.hasValue = false;
    _this.hasCompleted = false;
    _this.buffer = [];
    _this.active = 0;
    _this.index = 0;
    return _this;
  }
  MergeScanSubscriber2.prototype._next = function(value) {
    if (this.active < this.concurrent) {
      var index = this.index++;
      var destination = this.destination;
      var ish = void 0;
      try {
        var accumulator = this.accumulator;
        ish = accumulator(this.acc, value, index);
      } catch (e) {
        return destination.error(e);
      }
      this.active++;
      this._innerSub(ish);
    } else {
      this.buffer.push(value);
    }
  };
  MergeScanSubscriber2.prototype._innerSub = function(ish) {
    var innerSubscriber = new SimpleInnerSubscriber(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = innerSubscribe(ish, innerSubscriber);
    if (innerSubscription !== innerSubscriber) {
      destination.add(innerSubscription);
    }
  };
  MergeScanSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (this.active === 0 && this.buffer.length === 0) {
      if (this.hasValue === false) {
        this.destination.next(this.acc);
      }
      this.destination.complete();
    }
    this.unsubscribe();
  };
  MergeScanSubscriber2.prototype.notifyNext = function(innerValue) {
    var destination = this.destination;
    this.acc = innerValue;
    this.hasValue = true;
    destination.next(innerValue);
  };
  MergeScanSubscriber2.prototype.notifyComplete = function() {
    var buffer2 = this.buffer;
    this.active--;
    if (buffer2.length > 0) {
      this._next(buffer2.shift());
    } else if (this.active === 0 && this.hasCompleted) {
      if (this.hasValue === false) {
        this.destination.next(this.acc);
      }
      this.destination.complete();
    }
  };
  return MergeScanSubscriber2;
}(SimpleOuterSubscriber);
function min(comparer) {
  var min2 = typeof comparer === "function" ? function(x, y) {
    return comparer(x, y) < 0 ? x : y;
  } : function(x, y) {
    return x < y ? x : y;
  };
  return reduce(min2);
}
function multicast(subjectOrSubjectFactory, selector) {
  return function multicastOperatorFunction(source) {
    var subjectFactory;
    if (typeof subjectOrSubjectFactory === "function") {
      subjectFactory = subjectOrSubjectFactory;
    } else {
      subjectFactory = function subjectFactory2() {
        return subjectOrSubjectFactory;
      };
    }
    if (typeof selector === "function") {
      return source.lift(new MulticastOperator(subjectFactory, selector));
    }
    var connectable = Object.create(source, connectableObservableDescriptor);
    connectable.source = source;
    connectable.subjectFactory = subjectFactory;
    return connectable;
  };
}
var MulticastOperator = /* @__PURE__ */ function() {
  function MulticastOperator2(subjectFactory, selector) {
    this.subjectFactory = subjectFactory;
    this.selector = selector;
  }
  MulticastOperator2.prototype.call = function(subscriber, source) {
    var selector = this.selector;
    var subject = this.subjectFactory();
    var subscription = selector(subject).subscribe(subscriber);
    subscription.add(source.subscribe(subject));
    return subscription;
  };
  return MulticastOperator2;
}();
function onErrorResumeNext() {
  var nextSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    nextSources[_i] = arguments[_i];
  }
  if (nextSources.length === 1 && isArray(nextSources[0])) {
    nextSources = nextSources[0];
  }
  return function(source) {
    return source.lift(new OnErrorResumeNextOperator(nextSources));
  };
}
var OnErrorResumeNextOperator = /* @__PURE__ */ function() {
  function OnErrorResumeNextOperator2(nextSources) {
    this.nextSources = nextSources;
  }
  OnErrorResumeNextOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
  };
  return OnErrorResumeNextOperator2;
}();
var OnErrorResumeNextSubscriber = /* @__PURE__ */ function(_super) {
  __extends(OnErrorResumeNextSubscriber2, _super);
  function OnErrorResumeNextSubscriber2(destination, nextSources) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.nextSources = nextSources;
    return _this;
  }
  OnErrorResumeNextSubscriber2.prototype.notifyError = function() {
    this.subscribeToNextSource();
  };
  OnErrorResumeNextSubscriber2.prototype.notifyComplete = function() {
    this.subscribeToNextSource();
  };
  OnErrorResumeNextSubscriber2.prototype._error = function(err) {
    this.subscribeToNextSource();
    this.unsubscribe();
  };
  OnErrorResumeNextSubscriber2.prototype._complete = function() {
    this.subscribeToNextSource();
    this.unsubscribe();
  };
  OnErrorResumeNextSubscriber2.prototype.subscribeToNextSource = function() {
    var next = this.nextSources.shift();
    if (!!next) {
      var innerSubscriber = new SimpleInnerSubscriber(this);
      var destination = this.destination;
      destination.add(innerSubscriber);
      var innerSubscription = innerSubscribe(next, innerSubscriber);
      if (innerSubscription !== innerSubscriber) {
        destination.add(innerSubscription);
      }
    } else {
      this.destination.complete();
    }
  };
  return OnErrorResumeNextSubscriber2;
}(SimpleOuterSubscriber);
function pairwise() {
  return function(source) {
    return source.lift(new PairwiseOperator());
  };
}
var PairwiseOperator = /* @__PURE__ */ function() {
  function PairwiseOperator2() {
  }
  PairwiseOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new PairwiseSubscriber(subscriber));
  };
  return PairwiseOperator2;
}();
var PairwiseSubscriber = /* @__PURE__ */ function(_super) {
  __extends(PairwiseSubscriber2, _super);
  function PairwiseSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.hasPrev = false;
    return _this;
  }
  PairwiseSubscriber2.prototype._next = function(value) {
    var pair;
    if (this.hasPrev) {
      pair = [this.prev, value];
    } else {
      this.hasPrev = true;
    }
    this.prev = value;
    if (pair) {
      this.destination.next(pair);
    }
  };
  return PairwiseSubscriber2;
}(Subscriber);
function partition(predicate, thisArg) {
  return function(source) {
    return [
      filter(predicate, thisArg)(source),
      filter(not2(predicate, thisArg))(source)
    ];
  };
}
function pluck() {
  var properties2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    properties2[_i] = arguments[_i];
  }
  var length = properties2.length;
  if (length === 0) {
    throw new Error("list of properties cannot be empty.");
  }
  return function(source) {
    return map(plucker(properties2, length))(source);
  };
}
function plucker(props, length) {
  var mapper = function(x) {
    var currentProp = x;
    for (var i = 0; i < length; i++) {
      var p = currentProp != null ? currentProp[props[i]] : void 0;
      if (p !== void 0) {
        currentProp = p;
      } else {
        return void 0;
      }
    }
    return currentProp;
  };
  return mapper;
}
function publish(selector) {
  return selector ? multicast(function() {
    return new Subject();
  }, selector) : multicast(new Subject());
}
function publishBehavior(value) {
  return function(source) {
    return multicast(new BehaviorSubject(value))(source);
  };
}
function publishLast() {
  return function(source) {
    return multicast(new AsyncSubject())(source);
  };
}
function publishReplay(bufferSize, windowTime2, selectorOrScheduler, scheduler) {
  if (selectorOrScheduler && typeof selectorOrScheduler !== "function") {
    scheduler = selectorOrScheduler;
  }
  var selector = typeof selectorOrScheduler === "function" ? selectorOrScheduler : void 0;
  var subject = new ReplaySubject(bufferSize, windowTime2, scheduler);
  return function(source) {
    return multicast(function() {
      return subject;
    }, selector)(source);
  };
}
function race() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function raceOperatorFunction(source) {
    if (observables.length === 1 && isArray(observables[0])) {
      observables = observables[0];
    }
    return source.lift.call(race$1.apply(void 0, [source].concat(observables)));
  };
}
function repeat(count2) {
  if (count2 === void 0) {
    count2 = -1;
  }
  return function(source) {
    if (count2 === 0) {
      return empty();
    } else if (count2 < 0) {
      return source.lift(new RepeatOperator(-1, source));
    } else {
      return source.lift(new RepeatOperator(count2 - 1, source));
    }
  };
}
var RepeatOperator = /* @__PURE__ */ function() {
  function RepeatOperator2(count2, source) {
    this.count = count2;
    this.source = source;
  }
  RepeatOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
  };
  return RepeatOperator2;
}();
var RepeatSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RepeatSubscriber2, _super);
  function RepeatSubscriber2(destination, count2, source) {
    var _this = _super.call(this, destination) || this;
    _this.count = count2;
    _this.source = source;
    return _this;
  }
  RepeatSubscriber2.prototype.complete = function() {
    if (!this.isStopped) {
      var _a = this, source = _a.source, count2 = _a.count;
      if (count2 === 0) {
        return _super.prototype.complete.call(this);
      } else if (count2 > -1) {
        this.count = count2 - 1;
      }
      source.subscribe(this._unsubscribeAndRecycle());
    }
  };
  return RepeatSubscriber2;
}(Subscriber);
function repeatWhen(notifier) {
  return function(source) {
    return source.lift(new RepeatWhenOperator(notifier));
  };
}
var RepeatWhenOperator = /* @__PURE__ */ function() {
  function RepeatWhenOperator2(notifier) {
    this.notifier = notifier;
  }
  RepeatWhenOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
  };
  return RepeatWhenOperator2;
}();
var RepeatWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RepeatWhenSubscriber2, _super);
  function RepeatWhenSubscriber2(destination, notifier, source) {
    var _this = _super.call(this, destination) || this;
    _this.notifier = notifier;
    _this.source = source;
    _this.sourceIsBeingSubscribedTo = true;
    return _this;
  }
  RepeatWhenSubscriber2.prototype.notifyNext = function() {
    this.sourceIsBeingSubscribedTo = true;
    this.source.subscribe(this);
  };
  RepeatWhenSubscriber2.prototype.notifyComplete = function() {
    if (this.sourceIsBeingSubscribedTo === false) {
      return _super.prototype.complete.call(this);
    }
  };
  RepeatWhenSubscriber2.prototype.complete = function() {
    this.sourceIsBeingSubscribedTo = false;
    if (!this.isStopped) {
      if (!this.retries) {
        this.subscribeToRetries();
      }
      if (!this.retriesSubscription || this.retriesSubscription.closed) {
        return _super.prototype.complete.call(this);
      }
      this._unsubscribeAndRecycle();
      this.notifications.next(void 0);
    }
  };
  RepeatWhenSubscriber2.prototype._unsubscribe = function() {
    var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
    if (notifications) {
      notifications.unsubscribe();
      this.notifications = void 0;
    }
    if (retriesSubscription) {
      retriesSubscription.unsubscribe();
      this.retriesSubscription = void 0;
    }
    this.retries = void 0;
  };
  RepeatWhenSubscriber2.prototype._unsubscribeAndRecycle = function() {
    var _unsubscribe = this._unsubscribe;
    this._unsubscribe = null;
    _super.prototype._unsubscribeAndRecycle.call(this);
    this._unsubscribe = _unsubscribe;
    return this;
  };
  RepeatWhenSubscriber2.prototype.subscribeToRetries = function() {
    this.notifications = new Subject();
    var retries;
    try {
      var notifier = this.notifier;
      retries = notifier(this.notifications);
    } catch (e) {
      return _super.prototype.complete.call(this);
    }
    this.retries = retries;
    this.retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
  };
  return RepeatWhenSubscriber2;
}(SimpleOuterSubscriber);
function retry(count2) {
  if (count2 === void 0) {
    count2 = -1;
  }
  return function(source) {
    return source.lift(new RetryOperator(count2, source));
  };
}
var RetryOperator = /* @__PURE__ */ function() {
  function RetryOperator2(count2, source) {
    this.count = count2;
    this.source = source;
  }
  RetryOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
  };
  return RetryOperator2;
}();
var RetrySubscriber = /* @__PURE__ */ function(_super) {
  __extends(RetrySubscriber2, _super);
  function RetrySubscriber2(destination, count2, source) {
    var _this = _super.call(this, destination) || this;
    _this.count = count2;
    _this.source = source;
    return _this;
  }
  RetrySubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var _a = this, source = _a.source, count2 = _a.count;
      if (count2 === 0) {
        return _super.prototype.error.call(this, err);
      } else if (count2 > -1) {
        this.count = count2 - 1;
      }
      source.subscribe(this._unsubscribeAndRecycle());
    }
  };
  return RetrySubscriber2;
}(Subscriber);
function retryWhen(notifier) {
  return function(source) {
    return source.lift(new RetryWhenOperator(notifier, source));
  };
}
var RetryWhenOperator = /* @__PURE__ */ function() {
  function RetryWhenOperator2(notifier, source) {
    this.notifier = notifier;
    this.source = source;
  }
  RetryWhenOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
  };
  return RetryWhenOperator2;
}();
var RetryWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RetryWhenSubscriber2, _super);
  function RetryWhenSubscriber2(destination, notifier, source) {
    var _this = _super.call(this, destination) || this;
    _this.notifier = notifier;
    _this.source = source;
    return _this;
  }
  RetryWhenSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var errors = this.errors;
      var retries = this.retries;
      var retriesSubscription = this.retriesSubscription;
      if (!retries) {
        errors = new Subject();
        try {
          var notifier = this.notifier;
          retries = notifier(errors);
        } catch (e) {
          return _super.prototype.error.call(this, e);
        }
        retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
      } else {
        this.errors = void 0;
        this.retriesSubscription = void 0;
      }
      this._unsubscribeAndRecycle();
      this.errors = errors;
      this.retries = retries;
      this.retriesSubscription = retriesSubscription;
      errors.next(err);
    }
  };
  RetryWhenSubscriber2.prototype._unsubscribe = function() {
    var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
    if (errors) {
      errors.unsubscribe();
      this.errors = void 0;
    }
    if (retriesSubscription) {
      retriesSubscription.unsubscribe();
      this.retriesSubscription = void 0;
    }
    this.retries = void 0;
  };
  RetryWhenSubscriber2.prototype.notifyNext = function() {
    var _unsubscribe = this._unsubscribe;
    this._unsubscribe = null;
    this._unsubscribeAndRecycle();
    this._unsubscribe = _unsubscribe;
    this.source.subscribe(this);
  };
  return RetryWhenSubscriber2;
}(SimpleOuterSubscriber);
function sample(notifier) {
  return function(source) {
    return source.lift(new SampleOperator(notifier));
  };
}
var SampleOperator = /* @__PURE__ */ function() {
  function SampleOperator2(notifier) {
    this.notifier = notifier;
  }
  SampleOperator2.prototype.call = function(subscriber, source) {
    var sampleSubscriber = new SampleSubscriber(subscriber);
    var subscription = source.subscribe(sampleSubscriber);
    subscription.add(innerSubscribe(this.notifier, new SimpleInnerSubscriber(sampleSubscriber)));
    return subscription;
  };
  return SampleOperator2;
}();
var SampleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SampleSubscriber2, _super);
  function SampleSubscriber2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.hasValue = false;
    return _this;
  }
  SampleSubscriber2.prototype._next = function(value) {
    this.value = value;
    this.hasValue = true;
  };
  SampleSubscriber2.prototype.notifyNext = function() {
    this.emitValue();
  };
  SampleSubscriber2.prototype.notifyComplete = function() {
    this.emitValue();
  };
  SampleSubscriber2.prototype.emitValue = function() {
    if (this.hasValue) {
      this.hasValue = false;
      this.destination.next(this.value);
    }
  };
  return SampleSubscriber2;
}(SimpleOuterSubscriber);
function sampleTime(period, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    return source.lift(new SampleTimeOperator(period, scheduler));
  };
}
var SampleTimeOperator = /* @__PURE__ */ function() {
  function SampleTimeOperator2(period, scheduler) {
    this.period = period;
    this.scheduler = scheduler;
  }
  SampleTimeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
  };
  return SampleTimeOperator2;
}();
var SampleTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SampleTimeSubscriber2, _super);
  function SampleTimeSubscriber2(destination, period, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.period = period;
    _this.scheduler = scheduler;
    _this.hasValue = false;
    _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period }));
    return _this;
  }
  SampleTimeSubscriber2.prototype._next = function(value) {
    this.lastValue = value;
    this.hasValue = true;
  };
  SampleTimeSubscriber2.prototype.notifyNext = function() {
    if (this.hasValue) {
      this.hasValue = false;
      this.destination.next(this.lastValue);
    }
  };
  return SampleTimeSubscriber2;
}(Subscriber);
function dispatchNotification(state) {
  var subscriber = state.subscriber, period = state.period;
  subscriber.notifyNext();
  this.schedule(state, period);
}
function sequenceEqual(compareTo, comparator) {
  return function(source) {
    return source.lift(new SequenceEqualOperator(compareTo, comparator));
  };
}
var SequenceEqualOperator = /* @__PURE__ */ function() {
  function SequenceEqualOperator2(compareTo, comparator) {
    this.compareTo = compareTo;
    this.comparator = comparator;
  }
  SequenceEqualOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
  };
  return SequenceEqualOperator2;
}();
var SequenceEqualSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SequenceEqualSubscriber2, _super);
  function SequenceEqualSubscriber2(destination, compareTo, comparator) {
    var _this = _super.call(this, destination) || this;
    _this.compareTo = compareTo;
    _this.comparator = comparator;
    _this._a = [];
    _this._b = [];
    _this._oneComplete = false;
    _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
    return _this;
  }
  SequenceEqualSubscriber2.prototype._next = function(value) {
    if (this._oneComplete && this._b.length === 0) {
      this.emit(false);
    } else {
      this._a.push(value);
      this.checkValues();
    }
  };
  SequenceEqualSubscriber2.prototype._complete = function() {
    if (this._oneComplete) {
      this.emit(this._a.length === 0 && this._b.length === 0);
    } else {
      this._oneComplete = true;
    }
    this.unsubscribe();
  };
  SequenceEqualSubscriber2.prototype.checkValues = function() {
    var _c = this, _a = _c._a, _b = _c._b, comparator = _c.comparator;
    while (_a.length > 0 && _b.length > 0) {
      var a = _a.shift();
      var b = _b.shift();
      var areEqual = false;
      try {
        areEqual = comparator ? comparator(a, b) : a === b;
      } catch (e) {
        this.destination.error(e);
      }
      if (!areEqual) {
        this.emit(false);
      }
    }
  };
  SequenceEqualSubscriber2.prototype.emit = function(value) {
    var destination = this.destination;
    destination.next(value);
    destination.complete();
  };
  SequenceEqualSubscriber2.prototype.nextB = function(value) {
    if (this._oneComplete && this._a.length === 0) {
      this.emit(false);
    } else {
      this._b.push(value);
      this.checkValues();
    }
  };
  SequenceEqualSubscriber2.prototype.completeB = function() {
    if (this._oneComplete) {
      this.emit(this._a.length === 0 && this._b.length === 0);
    } else {
      this._oneComplete = true;
    }
  };
  return SequenceEqualSubscriber2;
}(Subscriber);
var SequenceEqualCompareToSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SequenceEqualCompareToSubscriber2, _super);
  function SequenceEqualCompareToSubscriber2(destination, parent) {
    var _this = _super.call(this, destination) || this;
    _this.parent = parent;
    return _this;
  }
  SequenceEqualCompareToSubscriber2.prototype._next = function(value) {
    this.parent.nextB(value);
  };
  SequenceEqualCompareToSubscriber2.prototype._error = function(err) {
    this.parent.error(err);
    this.unsubscribe();
  };
  SequenceEqualCompareToSubscriber2.prototype._complete = function() {
    this.parent.completeB();
    this.unsubscribe();
  };
  return SequenceEqualCompareToSubscriber2;
}(Subscriber);
function shareSubjectFactory() {
  return new Subject();
}
function share() {
  return function(source) {
    return refCount()(multicast(shareSubjectFactory)(source));
  };
}
function shareReplay(configOrBufferSize, windowTime2, scheduler) {
  var config2;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    config2 = configOrBufferSize;
  } else {
    config2 = {
      bufferSize: configOrBufferSize,
      windowTime: windowTime2,
      refCount: false,
      scheduler
    };
  }
  return function(source) {
    return source.lift(shareReplayOperator(config2));
  };
}
function shareReplayOperator(_a) {
  var _b = _a.bufferSize, bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b, _c = _a.windowTime, windowTime2 = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a.refCount, scheduler = _a.scheduler;
  var subject;
  var refCount2 = 0;
  var subscription;
  var hasError = false;
  var isComplete = false;
  return function shareReplayOperation(source) {
    refCount2++;
    var innerSub;
    if (!subject || hasError) {
      hasError = false;
      subject = new ReplaySubject(bufferSize, windowTime2, scheduler);
      innerSub = subject.subscribe(this);
      subscription = source.subscribe({
        next: function(value) {
          subject.next(value);
        },
        error: function(err) {
          hasError = true;
          subject.error(err);
        },
        complete: function() {
          isComplete = true;
          subscription = void 0;
          subject.complete();
        }
      });
      if (isComplete) {
        subscription = void 0;
      }
    } else {
      innerSub = subject.subscribe(this);
    }
    this.add(function() {
      refCount2--;
      innerSub.unsubscribe();
      innerSub = void 0;
      if (subscription && !isComplete && useRefCount && refCount2 === 0) {
        subscription.unsubscribe();
        subscription = void 0;
        subject = void 0;
      }
    });
  };
}
function single(predicate) {
  return function(source) {
    return source.lift(new SingleOperator(predicate, source));
  };
}
var SingleOperator = /* @__PURE__ */ function() {
  function SingleOperator2(predicate, source) {
    this.predicate = predicate;
    this.source = source;
  }
  SingleOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
  };
  return SingleOperator2;
}();
var SingleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SingleSubscriber2, _super);
  function SingleSubscriber2(destination, predicate, source) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.source = source;
    _this.seenValue = false;
    _this.index = 0;
    return _this;
  }
  SingleSubscriber2.prototype.applySingleValue = function(value) {
    if (this.seenValue) {
      this.destination.error("Sequence contains more than one element");
    } else {
      this.seenValue = true;
      this.singleValue = value;
    }
  };
  SingleSubscriber2.prototype._next = function(value) {
    var index = this.index++;
    if (this.predicate) {
      this.tryNext(value, index);
    } else {
      this.applySingleValue(value);
    }
  };
  SingleSubscriber2.prototype.tryNext = function(value, index) {
    try {
      if (this.predicate(value, index, this.source)) {
        this.applySingleValue(value);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };
  SingleSubscriber2.prototype._complete = function() {
    var destination = this.destination;
    if (this.index > 0) {
      destination.next(this.seenValue ? this.singleValue : void 0);
      destination.complete();
    } else {
      destination.error(new EmptyError());
    }
  };
  return SingleSubscriber2;
}(Subscriber);
function skip(count2) {
  return function(source) {
    return source.lift(new SkipOperator(count2));
  };
}
var SkipOperator = /* @__PURE__ */ function() {
  function SkipOperator2(total) {
    this.total = total;
  }
  SkipOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SkipSubscriber(subscriber, this.total));
  };
  return SkipOperator2;
}();
var SkipSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipSubscriber2, _super);
  function SkipSubscriber2(destination, total) {
    var _this = _super.call(this, destination) || this;
    _this.total = total;
    _this.count = 0;
    return _this;
  }
  SkipSubscriber2.prototype._next = function(x) {
    if (++this.count > this.total) {
      this.destination.next(x);
    }
  };
  return SkipSubscriber2;
}(Subscriber);
function skipLast(count2) {
  return function(source) {
    return source.lift(new SkipLastOperator(count2));
  };
}
var SkipLastOperator = /* @__PURE__ */ function() {
  function SkipLastOperator2(_skipCount) {
    this._skipCount = _skipCount;
    if (this._skipCount < 0) {
      throw new ArgumentOutOfRangeError();
    }
  }
  SkipLastOperator2.prototype.call = function(subscriber, source) {
    if (this._skipCount === 0) {
      return source.subscribe(new Subscriber(subscriber));
    } else {
      return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
    }
  };
  return SkipLastOperator2;
}();
var SkipLastSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipLastSubscriber2, _super);
  function SkipLastSubscriber2(destination, _skipCount) {
    var _this = _super.call(this, destination) || this;
    _this._skipCount = _skipCount;
    _this._count = 0;
    _this._ring = new Array(_skipCount);
    return _this;
  }
  SkipLastSubscriber2.prototype._next = function(value) {
    var skipCount = this._skipCount;
    var count2 = this._count++;
    if (count2 < skipCount) {
      this._ring[count2] = value;
    } else {
      var currentIndex = count2 % skipCount;
      var ring = this._ring;
      var oldValue = ring[currentIndex];
      ring[currentIndex] = value;
      this.destination.next(oldValue);
    }
  };
  return SkipLastSubscriber2;
}(Subscriber);
function skipUntil(notifier) {
  return function(source) {
    return source.lift(new SkipUntilOperator(notifier));
  };
}
var SkipUntilOperator = /* @__PURE__ */ function() {
  function SkipUntilOperator2(notifier) {
    this.notifier = notifier;
  }
  SkipUntilOperator2.prototype.call = function(destination, source) {
    return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
  };
  return SkipUntilOperator2;
}();
var SkipUntilSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipUntilSubscriber2, _super);
  function SkipUntilSubscriber2(destination, notifier) {
    var _this = _super.call(this, destination) || this;
    _this.hasValue = false;
    var innerSubscriber = new SimpleInnerSubscriber(_this);
    _this.add(innerSubscriber);
    _this.innerSubscription = innerSubscriber;
    var innerSubscription = innerSubscribe(notifier, innerSubscriber);
    if (innerSubscription !== innerSubscriber) {
      _this.add(innerSubscription);
      _this.innerSubscription = innerSubscription;
    }
    return _this;
  }
  SkipUntilSubscriber2.prototype._next = function(value) {
    if (this.hasValue) {
      _super.prototype._next.call(this, value);
    }
  };
  SkipUntilSubscriber2.prototype.notifyNext = function() {
    this.hasValue = true;
    if (this.innerSubscription) {
      this.innerSubscription.unsubscribe();
    }
  };
  SkipUntilSubscriber2.prototype.notifyComplete = function() {
  };
  return SkipUntilSubscriber2;
}(SimpleOuterSubscriber);
function skipWhile(predicate) {
  return function(source) {
    return source.lift(new SkipWhileOperator(predicate));
  };
}
var SkipWhileOperator = /* @__PURE__ */ function() {
  function SkipWhileOperator2(predicate) {
    this.predicate = predicate;
  }
  SkipWhileOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
  };
  return SkipWhileOperator2;
}();
var SkipWhileSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipWhileSubscriber2, _super);
  function SkipWhileSubscriber2(destination, predicate) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.skipping = true;
    _this.index = 0;
    return _this;
  }
  SkipWhileSubscriber2.prototype._next = function(value) {
    var destination = this.destination;
    if (this.skipping) {
      this.tryCallPredicate(value);
    }
    if (!this.skipping) {
      destination.next(value);
    }
  };
  SkipWhileSubscriber2.prototype.tryCallPredicate = function(value) {
    try {
      var result = this.predicate(value, this.index++);
      this.skipping = Boolean(result);
    } catch (err) {
      this.destination.error(err);
    }
  };
  return SkipWhileSubscriber2;
}(Subscriber);
function startWith() {
  var array = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    array[_i] = arguments[_i];
  }
  var scheduler = array[array.length - 1];
  if (isScheduler(scheduler)) {
    array.pop();
    return function(source) {
      return concat$1(array, source, scheduler);
    };
  } else {
    return function(source) {
      return concat$1(array, source);
    };
  }
}
var SubscribeOnObservable = /* @__PURE__ */ function(_super) {
  __extends(SubscribeOnObservable2, _super);
  function SubscribeOnObservable2(source, delayTime, scheduler) {
    if (delayTime === void 0) {
      delayTime = 0;
    }
    if (scheduler === void 0) {
      scheduler = asap;
    }
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.delayTime = delayTime;
    _this.scheduler = scheduler;
    if (!isNumeric(delayTime) || delayTime < 0) {
      _this.delayTime = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== "function") {
      _this.scheduler = asap;
    }
    return _this;
  }
  SubscribeOnObservable2.create = function(source, delay2, scheduler) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (scheduler === void 0) {
      scheduler = asap;
    }
    return new SubscribeOnObservable2(source, delay2, scheduler);
  };
  SubscribeOnObservable2.dispatch = function(arg) {
    var source = arg.source, subscriber = arg.subscriber;
    return this.add(source.subscribe(subscriber));
  };
  SubscribeOnObservable2.prototype._subscribe = function(subscriber) {
    var delay2 = this.delayTime;
    var source = this.source;
    var scheduler = this.scheduler;
    return scheduler.schedule(SubscribeOnObservable2.dispatch, delay2, {
      source,
      subscriber
    });
  };
  return SubscribeOnObservable2;
}(Observable);
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return function subscribeOnOperatorFunction(source) {
    return source.lift(new SubscribeOnOperator(scheduler, delay2));
  };
}
var SubscribeOnOperator = /* @__PURE__ */ function() {
  function SubscribeOnOperator2(scheduler, delay2) {
    this.scheduler = scheduler;
    this.delay = delay2;
  }
  SubscribeOnOperator2.prototype.call = function(subscriber, source) {
    return new SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
  };
  return SubscribeOnOperator2;
}();
function switchMap(project, resultSelector) {
  if (typeof resultSelector === "function") {
    return function(source) {
      return source.pipe(switchMap(function(a, i) {
        return from(project(a, i)).pipe(map(function(b, ii) {
          return resultSelector(a, b, i, ii);
        }));
      }));
    };
  }
  return function(source) {
    return source.lift(new SwitchMapOperator(project));
  };
}
var SwitchMapOperator = /* @__PURE__ */ function() {
  function SwitchMapOperator2(project) {
    this.project = project;
  }
  SwitchMapOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
  };
  return SwitchMapOperator2;
}();
var SwitchMapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SwitchMapSubscriber2, _super);
  function SwitchMapSubscriber2(destination, project) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.index = 0;
    return _this;
  }
  SwitchMapSubscriber2.prototype._next = function(value) {
    var result;
    var index = this.index++;
    try {
      result = this.project(value, index);
    } catch (error) {
      this.destination.error(error);
      return;
    }
    this._innerSub(result);
  };
  SwitchMapSubscriber2.prototype._innerSub = function(result) {
    var innerSubscription = this.innerSubscription;
    if (innerSubscription) {
      innerSubscription.unsubscribe();
    }
    var innerSubscriber = new SimpleInnerSubscriber(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    this.innerSubscription = innerSubscribe(result, innerSubscriber);
    if (this.innerSubscription !== innerSubscriber) {
      destination.add(this.innerSubscription);
    }
  };
  SwitchMapSubscriber2.prototype._complete = function() {
    var innerSubscription = this.innerSubscription;
    if (!innerSubscription || innerSubscription.closed) {
      _super.prototype._complete.call(this);
    }
    this.unsubscribe();
  };
  SwitchMapSubscriber2.prototype._unsubscribe = function() {
    this.innerSubscription = void 0;
  };
  SwitchMapSubscriber2.prototype.notifyComplete = function() {
    this.innerSubscription = void 0;
    if (this.isStopped) {
      _super.prototype._complete.call(this);
    }
  };
  SwitchMapSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  return SwitchMapSubscriber2;
}(SimpleOuterSubscriber);
function switchAll() {
  return switchMap(identity);
}
function switchMapTo(innerObservable, resultSelector) {
  return resultSelector ? switchMap(function() {
    return innerObservable;
  }, resultSelector) : switchMap(function() {
    return innerObservable;
  });
}
function takeUntil(notifier) {
  return function(source) {
    return source.lift(new TakeUntilOperator(notifier));
  };
}
var TakeUntilOperator = /* @__PURE__ */ function() {
  function TakeUntilOperator2(notifier) {
    this.notifier = notifier;
  }
  TakeUntilOperator2.prototype.call = function(subscriber, source) {
    var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
    var notifierSubscription = innerSubscribe(this.notifier, new SimpleInnerSubscriber(takeUntilSubscriber));
    if (notifierSubscription && !takeUntilSubscriber.seenValue) {
      takeUntilSubscriber.add(notifierSubscription);
      return source.subscribe(takeUntilSubscriber);
    }
    return takeUntilSubscriber;
  };
  return TakeUntilOperator2;
}();
var TakeUntilSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeUntilSubscriber2, _super);
  function TakeUntilSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.seenValue = false;
    return _this;
  }
  TakeUntilSubscriber2.prototype.notifyNext = function() {
    this.seenValue = true;
    this.complete();
  };
  TakeUntilSubscriber2.prototype.notifyComplete = function() {
  };
  return TakeUntilSubscriber2;
}(SimpleOuterSubscriber);
function takeWhile(predicate, inclusive) {
  if (inclusive === void 0) {
    inclusive = false;
  }
  return function(source) {
    return source.lift(new TakeWhileOperator(predicate, inclusive));
  };
}
var TakeWhileOperator = /* @__PURE__ */ function() {
  function TakeWhileOperator2(predicate, inclusive) {
    this.predicate = predicate;
    this.inclusive = inclusive;
  }
  TakeWhileOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
  };
  return TakeWhileOperator2;
}();
var TakeWhileSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeWhileSubscriber2, _super);
  function TakeWhileSubscriber2(destination, predicate, inclusive) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.inclusive = inclusive;
    _this.index = 0;
    return _this;
  }
  TakeWhileSubscriber2.prototype._next = function(value) {
    var destination = this.destination;
    var result;
    try {
      result = this.predicate(value, this.index++);
    } catch (err) {
      destination.error(err);
      return;
    }
    this.nextOrComplete(value, result);
  };
  TakeWhileSubscriber2.prototype.nextOrComplete = function(value, predicateResult) {
    var destination = this.destination;
    if (Boolean(predicateResult)) {
      destination.next(value);
    } else {
      if (this.inclusive) {
        destination.next(value);
      }
      destination.complete();
    }
  };
  return TakeWhileSubscriber2;
}(Subscriber);
function tap(nextOrObserver, error, complete) {
  return function tapOperatorFunction(source) {
    return source.lift(new DoOperator(nextOrObserver, error, complete));
  };
}
var DoOperator = /* @__PURE__ */ function() {
  function DoOperator2(nextOrObserver, error, complete) {
    this.nextOrObserver = nextOrObserver;
    this.error = error;
    this.complete = complete;
  }
  DoOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
  };
  return DoOperator2;
}();
var TapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TapSubscriber2, _super);
  function TapSubscriber2(destination, observerOrNext, error, complete) {
    var _this = _super.call(this, destination) || this;
    _this._tapNext = noop;
    _this._tapError = noop;
    _this._tapComplete = noop;
    _this._tapError = error || noop;
    _this._tapComplete = complete || noop;
    if (isFunction(observerOrNext)) {
      _this._context = _this;
      _this._tapNext = observerOrNext;
    } else if (observerOrNext) {
      _this._context = observerOrNext;
      _this._tapNext = observerOrNext.next || noop;
      _this._tapError = observerOrNext.error || noop;
      _this._tapComplete = observerOrNext.complete || noop;
    }
    return _this;
  }
  TapSubscriber2.prototype._next = function(value) {
    try {
      this._tapNext.call(this._context, value);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(value);
  };
  TapSubscriber2.prototype._error = function(err) {
    try {
      this._tapError.call(this._context, err);
    } catch (err2) {
      this.destination.error(err2);
      return;
    }
    this.destination.error(err);
  };
  TapSubscriber2.prototype._complete = function() {
    try {
      this._tapComplete.call(this._context);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    return this.destination.complete();
  };
  return TapSubscriber2;
}(Subscriber);
var defaultThrottleConfig = {
  leading: true,
  trailing: false
};
function throttle(durationSelector, config2) {
  if (config2 === void 0) {
    config2 = defaultThrottleConfig;
  }
  return function(source) {
    return source.lift(new ThrottleOperator(durationSelector, !!config2.leading, !!config2.trailing));
  };
}
var ThrottleOperator = /* @__PURE__ */ function() {
  function ThrottleOperator2(durationSelector, leading, trailing) {
    this.durationSelector = durationSelector;
    this.leading = leading;
    this.trailing = trailing;
  }
  ThrottleOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
  };
  return ThrottleOperator2;
}();
var ThrottleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ThrottleSubscriber2, _super);
  function ThrottleSubscriber2(destination, durationSelector, _leading, _trailing) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.durationSelector = durationSelector;
    _this._leading = _leading;
    _this._trailing = _trailing;
    _this._hasValue = false;
    return _this;
  }
  ThrottleSubscriber2.prototype._next = function(value) {
    this._hasValue = true;
    this._sendValue = value;
    if (!this._throttled) {
      if (this._leading) {
        this.send();
      } else {
        this.throttle(value);
      }
    }
  };
  ThrottleSubscriber2.prototype.send = function() {
    var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;
    if (_hasValue) {
      this.destination.next(_sendValue);
      this.throttle(_sendValue);
    }
    this._hasValue = false;
    this._sendValue = void 0;
  };
  ThrottleSubscriber2.prototype.throttle = function(value) {
    var duration = this.tryDurationSelector(value);
    if (!!duration) {
      this.add(this._throttled = innerSubscribe(duration, new SimpleInnerSubscriber(this)));
    }
  };
  ThrottleSubscriber2.prototype.tryDurationSelector = function(value) {
    try {
      return this.durationSelector(value);
    } catch (err) {
      this.destination.error(err);
      return null;
    }
  };
  ThrottleSubscriber2.prototype.throttlingDone = function() {
    var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;
    if (_throttled) {
      _throttled.unsubscribe();
    }
    this._throttled = void 0;
    if (_trailing) {
      this.send();
    }
  };
  ThrottleSubscriber2.prototype.notifyNext = function() {
    this.throttlingDone();
  };
  ThrottleSubscriber2.prototype.notifyComplete = function() {
    this.throttlingDone();
  };
  return ThrottleSubscriber2;
}(SimpleOuterSubscriber);
function throttleTime(duration, scheduler, config2) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  if (config2 === void 0) {
    config2 = defaultThrottleConfig;
  }
  return function(source) {
    return source.lift(new ThrottleTimeOperator(duration, scheduler, config2.leading, config2.trailing));
  };
}
var ThrottleTimeOperator = /* @__PURE__ */ function() {
  function ThrottleTimeOperator2(duration, scheduler, leading, trailing) {
    this.duration = duration;
    this.scheduler = scheduler;
    this.leading = leading;
    this.trailing = trailing;
  }
  ThrottleTimeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
  };
  return ThrottleTimeOperator2;
}();
var ThrottleTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ThrottleTimeSubscriber2, _super);
  function ThrottleTimeSubscriber2(destination, duration, scheduler, leading, trailing) {
    var _this = _super.call(this, destination) || this;
    _this.duration = duration;
    _this.scheduler = scheduler;
    _this.leading = leading;
    _this.trailing = trailing;
    _this._hasTrailingValue = false;
    _this._trailingValue = null;
    return _this;
  }
  ThrottleTimeSubscriber2.prototype._next = function(value) {
    if (this.throttled) {
      if (this.trailing) {
        this._trailingValue = value;
        this._hasTrailingValue = true;
      }
    } else {
      this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
      if (this.leading) {
        this.destination.next(value);
      } else if (this.trailing) {
        this._trailingValue = value;
        this._hasTrailingValue = true;
      }
    }
  };
  ThrottleTimeSubscriber2.prototype._complete = function() {
    if (this._hasTrailingValue) {
      this.destination.next(this._trailingValue);
      this.destination.complete();
    } else {
      this.destination.complete();
    }
  };
  ThrottleTimeSubscriber2.prototype.clearThrottle = function() {
    var throttled = this.throttled;
    if (throttled) {
      if (this.trailing && this._hasTrailingValue) {
        this.destination.next(this._trailingValue);
        this._trailingValue = null;
        this._hasTrailingValue = false;
      }
      throttled.unsubscribe();
      this.remove(throttled);
      this.throttled = null;
    }
  };
  return ThrottleTimeSubscriber2;
}(Subscriber);
function dispatchNext(arg) {
  var subscriber = arg.subscriber;
  subscriber.clearThrottle();
}
function timeInterval(scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    return defer(function() {
      return source.pipe(scan(function(_a, value) {
        var current = _a.current;
        return { value, current: scheduler.now(), last: current };
      }, { current: scheduler.now(), value: void 0, last: void 0 }), map(function(_a) {
        var current = _a.current, last2 = _a.last, value = _a.value;
        return new TimeInterval(value, current - last2);
      }));
    });
  };
}
var TimeInterval = /* @__PURE__ */ function() {
  function TimeInterval2(value, interval2) {
    this.value = value;
    this.interval = interval2;
  }
  return TimeInterval2;
}();
function timeoutWith(due, withObservable, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    var absoluteTimeout = isDate(due);
    var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
  };
}
var TimeoutWithOperator = /* @__PURE__ */ function() {
  function TimeoutWithOperator2(waitFor, absoluteTimeout, withObservable, scheduler) {
    this.waitFor = waitFor;
    this.absoluteTimeout = absoluteTimeout;
    this.withObservable = withObservable;
    this.scheduler = scheduler;
  }
  TimeoutWithOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
  };
  return TimeoutWithOperator2;
}();
var TimeoutWithSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TimeoutWithSubscriber2, _super);
  function TimeoutWithSubscriber2(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.absoluteTimeout = absoluteTimeout;
    _this.waitFor = waitFor;
    _this.withObservable = withObservable;
    _this.scheduler = scheduler;
    _this.scheduleTimeout();
    return _this;
  }
  TimeoutWithSubscriber2.dispatchTimeout = function(subscriber) {
    var withObservable = subscriber.withObservable;
    subscriber._unsubscribeAndRecycle();
    subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));
  };
  TimeoutWithSubscriber2.prototype.scheduleTimeout = function() {
    var action = this.action;
    if (action) {
      this.action = action.schedule(this, this.waitFor);
    } else {
      this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber2.dispatchTimeout, this.waitFor, this));
    }
  };
  TimeoutWithSubscriber2.prototype._next = function(value) {
    if (!this.absoluteTimeout) {
      this.scheduleTimeout();
    }
    _super.prototype._next.call(this, value);
  };
  TimeoutWithSubscriber2.prototype._unsubscribe = function() {
    this.action = void 0;
    this.scheduler = null;
    this.withObservable = null;
  };
  return TimeoutWithSubscriber2;
}(SimpleOuterSubscriber);
function timeout(due, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return timeoutWith(due, throwError(new TimeoutError()), scheduler);
}
function timestamp(scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return map(function(value) {
    return new Timestamp(value, scheduler.now());
  });
}
var Timestamp = /* @__PURE__ */ function() {
  function Timestamp2(value, timestamp2) {
    this.value = value;
    this.timestamp = timestamp2;
  }
  return Timestamp2;
}();
function toArrayReducer(arr, item, index) {
  if (index === 0) {
    return [item];
  }
  arr.push(item);
  return arr;
}
function toArray() {
  return reduce(toArrayReducer, []);
}
function window$1(windowBoundaries) {
  return function windowOperatorFunction(source) {
    return source.lift(new WindowOperator$1(windowBoundaries));
  };
}
var WindowOperator$1 = /* @__PURE__ */ function() {
  function WindowOperator2(windowBoundaries) {
    this.windowBoundaries = windowBoundaries;
  }
  WindowOperator2.prototype.call = function(subscriber, source) {
    var windowSubscriber = new WindowSubscriber$1(subscriber);
    var sourceSubscription = source.subscribe(windowSubscriber);
    if (!sourceSubscription.closed) {
      windowSubscriber.add(innerSubscribe(this.windowBoundaries, new SimpleInnerSubscriber(windowSubscriber)));
    }
    return sourceSubscription;
  };
  return WindowOperator2;
}();
var WindowSubscriber$1 = /* @__PURE__ */ function(_super) {
  __extends(WindowSubscriber2, _super);
  function WindowSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.window = new Subject();
    destination.next(_this.window);
    return _this;
  }
  WindowSubscriber2.prototype.notifyNext = function() {
    this.openWindow();
  };
  WindowSubscriber2.prototype.notifyError = function(error) {
    this._error(error);
  };
  WindowSubscriber2.prototype.notifyComplete = function() {
    this._complete();
  };
  WindowSubscriber2.prototype._next = function(value) {
    this.window.next(value);
  };
  WindowSubscriber2.prototype._error = function(err) {
    this.window.error(err);
    this.destination.error(err);
  };
  WindowSubscriber2.prototype._complete = function() {
    this.window.complete();
    this.destination.complete();
  };
  WindowSubscriber2.prototype._unsubscribe = function() {
    this.window = null;
  };
  WindowSubscriber2.prototype.openWindow = function() {
    var prevWindow = this.window;
    if (prevWindow) {
      prevWindow.complete();
    }
    var destination = this.destination;
    var newWindow = this.window = new Subject();
    destination.next(newWindow);
  };
  return WindowSubscriber2;
}(SimpleOuterSubscriber);
function windowCount(windowSize, startWindowEvery) {
  if (startWindowEvery === void 0) {
    startWindowEvery = 0;
  }
  return function windowCountOperatorFunction(source) {
    return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
  };
}
var WindowCountOperator = /* @__PURE__ */ function() {
  function WindowCountOperator2(windowSize, startWindowEvery) {
    this.windowSize = windowSize;
    this.startWindowEvery = startWindowEvery;
  }
  WindowCountOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
  };
  return WindowCountOperator2;
}();
var WindowCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowCountSubscriber2, _super);
  function WindowCountSubscriber2(destination, windowSize, startWindowEvery) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.windowSize = windowSize;
    _this.startWindowEvery = startWindowEvery;
    _this.windows = [new Subject()];
    _this.count = 0;
    destination.next(_this.windows[0]);
    return _this;
  }
  WindowCountSubscriber2.prototype._next = function(value) {
    var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;
    var destination = this.destination;
    var windowSize = this.windowSize;
    var windows = this.windows;
    var len = windows.length;
    for (var i = 0; i < len && !this.closed; i++) {
      windows[i].next(value);
    }
    var c = this.count - windowSize + 1;
    if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
      windows.shift().complete();
    }
    if (++this.count % startWindowEvery === 0 && !this.closed) {
      var window_1 = new Subject();
      windows.push(window_1);
      destination.next(window_1);
    }
  };
  WindowCountSubscriber2.prototype._error = function(err) {
    var windows = this.windows;
    if (windows) {
      while (windows.length > 0 && !this.closed) {
        windows.shift().error(err);
      }
    }
    this.destination.error(err);
  };
  WindowCountSubscriber2.prototype._complete = function() {
    var windows = this.windows;
    if (windows) {
      while (windows.length > 0 && !this.closed) {
        windows.shift().complete();
      }
    }
    this.destination.complete();
  };
  WindowCountSubscriber2.prototype._unsubscribe = function() {
    this.count = 0;
    this.windows = null;
  };
  return WindowCountSubscriber2;
}(Subscriber);
function windowTime(windowTimeSpan) {
  var scheduler = async;
  var windowCreationInterval = null;
  var maxWindowSize = Number.POSITIVE_INFINITY;
  if (isScheduler(arguments[3])) {
    scheduler = arguments[3];
  }
  if (isScheduler(arguments[2])) {
    scheduler = arguments[2];
  } else if (isNumeric(arguments[2])) {
    maxWindowSize = Number(arguments[2]);
  }
  if (isScheduler(arguments[1])) {
    scheduler = arguments[1];
  } else if (isNumeric(arguments[1])) {
    windowCreationInterval = Number(arguments[1]);
  }
  return function windowTimeOperatorFunction(source) {
    return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
  };
}
var WindowTimeOperator = /* @__PURE__ */ function() {
  function WindowTimeOperator2(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
    this.windowTimeSpan = windowTimeSpan;
    this.windowCreationInterval = windowCreationInterval;
    this.maxWindowSize = maxWindowSize;
    this.scheduler = scheduler;
  }
  WindowTimeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
  };
  return WindowTimeOperator2;
}();
var CountedSubject = /* @__PURE__ */ function(_super) {
  __extends(CountedSubject2, _super);
  function CountedSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._numberOfNextedValues = 0;
    return _this;
  }
  CountedSubject2.prototype.next = function(value) {
    this._numberOfNextedValues++;
    _super.prototype.next.call(this, value);
  };
  Object.defineProperty(CountedSubject2.prototype, "numberOfNextedValues", {
    get: function() {
      return this._numberOfNextedValues;
    },
    enumerable: true,
    configurable: true
  });
  return CountedSubject2;
}(Subject);
var WindowTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowTimeSubscriber2, _super);
  function WindowTimeSubscriber2(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.windowTimeSpan = windowTimeSpan;
    _this.windowCreationInterval = windowCreationInterval;
    _this.maxWindowSize = maxWindowSize;
    _this.scheduler = scheduler;
    _this.windows = [];
    var window2 = _this.openWindow();
    if (windowCreationInterval !== null && windowCreationInterval >= 0) {
      var closeState = { subscriber: _this, window: window2, context: null };
      var creationState = { windowTimeSpan, windowCreationInterval, subscriber: _this, scheduler };
      _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
      _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
    } else {
      var timeSpanOnlyState = { subscriber: _this, window: window2, windowTimeSpan };
      _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
    }
    return _this;
  }
  WindowTimeSubscriber2.prototype._next = function(value) {
    var windows = this.windows;
    var len = windows.length;
    for (var i = 0; i < len; i++) {
      var window_1 = windows[i];
      if (!window_1.closed) {
        window_1.next(value);
        if (window_1.numberOfNextedValues >= this.maxWindowSize) {
          this.closeWindow(window_1);
        }
      }
    }
  };
  WindowTimeSubscriber2.prototype._error = function(err) {
    var windows = this.windows;
    while (windows.length > 0) {
      windows.shift().error(err);
    }
    this.destination.error(err);
  };
  WindowTimeSubscriber2.prototype._complete = function() {
    var windows = this.windows;
    while (windows.length > 0) {
      var window_2 = windows.shift();
      if (!window_2.closed) {
        window_2.complete();
      }
    }
    this.destination.complete();
  };
  WindowTimeSubscriber2.prototype.openWindow = function() {
    var window2 = new CountedSubject();
    this.windows.push(window2);
    var destination = this.destination;
    destination.next(window2);
    return window2;
  };
  WindowTimeSubscriber2.prototype.closeWindow = function(window2) {
    window2.complete();
    var windows = this.windows;
    windows.splice(windows.indexOf(window2), 1);
  };
  return WindowTimeSubscriber2;
}(Subscriber);
function dispatchWindowTimeSpanOnly(state) {
  var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window2 = state.window;
  if (window2) {
    subscriber.closeWindow(window2);
  }
  state.window = subscriber.openWindow();
  this.schedule(state, windowTimeSpan);
}
function dispatchWindowCreation(state) {
  var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
  var window2 = subscriber.openWindow();
  var action = this;
  var context2 = { action, subscription: null };
  var timeSpanState = { subscriber, window: window2, context: context2 };
  context2.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
  action.add(context2.subscription);
  action.schedule(state, windowCreationInterval);
}
function dispatchWindowClose(state) {
  var subscriber = state.subscriber, window2 = state.window, context2 = state.context;
  if (context2 && context2.action && context2.subscription) {
    context2.action.remove(context2.subscription);
  }
  subscriber.closeWindow(window2);
}
function windowToggle(openings, closingSelector) {
  return function(source) {
    return source.lift(new WindowToggleOperator(openings, closingSelector));
  };
}
var WindowToggleOperator = /* @__PURE__ */ function() {
  function WindowToggleOperator2(openings, closingSelector) {
    this.openings = openings;
    this.closingSelector = closingSelector;
  }
  WindowToggleOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
  };
  return WindowToggleOperator2;
}();
var WindowToggleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowToggleSubscriber2, _super);
  function WindowToggleSubscriber2(destination, openings, closingSelector) {
    var _this = _super.call(this, destination) || this;
    _this.openings = openings;
    _this.closingSelector = closingSelector;
    _this.contexts = [];
    _this.add(_this.openSubscription = subscribeToResult(_this, openings, openings));
    return _this;
  }
  WindowToggleSubscriber2.prototype._next = function(value) {
    var contexts = this.contexts;
    if (contexts) {
      var len = contexts.length;
      for (var i = 0; i < len; i++) {
        contexts[i].window.next(value);
      }
    }
  };
  WindowToggleSubscriber2.prototype._error = function(err) {
    var contexts = this.contexts;
    this.contexts = null;
    if (contexts) {
      var len = contexts.length;
      var index = -1;
      while (++index < len) {
        var context_1 = contexts[index];
        context_1.window.error(err);
        context_1.subscription.unsubscribe();
      }
    }
    _super.prototype._error.call(this, err);
  };
  WindowToggleSubscriber2.prototype._complete = function() {
    var contexts = this.contexts;
    this.contexts = null;
    if (contexts) {
      var len = contexts.length;
      var index = -1;
      while (++index < len) {
        var context_2 = contexts[index];
        context_2.window.complete();
        context_2.subscription.unsubscribe();
      }
    }
    _super.prototype._complete.call(this);
  };
  WindowToggleSubscriber2.prototype._unsubscribe = function() {
    var contexts = this.contexts;
    this.contexts = null;
    if (contexts) {
      var len = contexts.length;
      var index = -1;
      while (++index < len) {
        var context_3 = contexts[index];
        context_3.window.unsubscribe();
        context_3.subscription.unsubscribe();
      }
    }
  };
  WindowToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    if (outerValue === this.openings) {
      var closingNotifier = void 0;
      try {
        var closingSelector = this.closingSelector;
        closingNotifier = closingSelector(innerValue);
      } catch (e) {
        return this.error(e);
      }
      var window_1 = new Subject();
      var subscription = new Subscription();
      var context_4 = { window: window_1, subscription };
      this.contexts.push(context_4);
      var innerSubscription = subscribeToResult(this, closingNotifier, context_4);
      if (innerSubscription.closed) {
        this.closeWindow(this.contexts.length - 1);
      } else {
        innerSubscription.context = context_4;
        subscription.add(innerSubscription);
      }
      this.destination.next(window_1);
    } else {
      this.closeWindow(this.contexts.indexOf(outerValue));
    }
  };
  WindowToggleSubscriber2.prototype.notifyError = function(err) {
    this.error(err);
  };
  WindowToggleSubscriber2.prototype.notifyComplete = function(inner) {
    if (inner !== this.openSubscription) {
      this.closeWindow(this.contexts.indexOf(inner.context));
    }
  };
  WindowToggleSubscriber2.prototype.closeWindow = function(index) {
    if (index === -1) {
      return;
    }
    var contexts = this.contexts;
    var context2 = contexts[index];
    var window2 = context2.window, subscription = context2.subscription;
    contexts.splice(index, 1);
    window2.complete();
    subscription.unsubscribe();
  };
  return WindowToggleSubscriber2;
}(OuterSubscriber);
function windowWhen(closingSelector) {
  return function windowWhenOperatorFunction(source) {
    return source.lift(new WindowOperator(closingSelector));
  };
}
var WindowOperator = /* @__PURE__ */ function() {
  function WindowOperator2(closingSelector) {
    this.closingSelector = closingSelector;
  }
  WindowOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
  };
  return WindowOperator2;
}();
var WindowSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowSubscriber2, _super);
  function WindowSubscriber2(destination, closingSelector) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.closingSelector = closingSelector;
    _this.openWindow();
    return _this;
  }
  WindowSubscriber2.prototype.notifyNext = function(_outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
    this.openWindow(innerSub);
  };
  WindowSubscriber2.prototype.notifyError = function(error) {
    this._error(error);
  };
  WindowSubscriber2.prototype.notifyComplete = function(innerSub) {
    this.openWindow(innerSub);
  };
  WindowSubscriber2.prototype._next = function(value) {
    this.window.next(value);
  };
  WindowSubscriber2.prototype._error = function(err) {
    this.window.error(err);
    this.destination.error(err);
    this.unsubscribeClosingNotification();
  };
  WindowSubscriber2.prototype._complete = function() {
    this.window.complete();
    this.destination.complete();
    this.unsubscribeClosingNotification();
  };
  WindowSubscriber2.prototype.unsubscribeClosingNotification = function() {
    if (this.closingNotification) {
      this.closingNotification.unsubscribe();
    }
  };
  WindowSubscriber2.prototype.openWindow = function(innerSub) {
    if (innerSub === void 0) {
      innerSub = null;
    }
    if (innerSub) {
      this.remove(innerSub);
      innerSub.unsubscribe();
    }
    var prevWindow = this.window;
    if (prevWindow) {
      prevWindow.complete();
    }
    var window2 = this.window = new Subject();
    this.destination.next(window2);
    var closingNotifier;
    try {
      var closingSelector = this.closingSelector;
      closingNotifier = closingSelector();
    } catch (e) {
      this.destination.error(e);
      this.window.error(e);
      return;
    }
    this.add(this.closingNotification = subscribeToResult(this, closingNotifier));
  };
  return WindowSubscriber2;
}(OuterSubscriber);
function withLatestFrom() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return function(source) {
    var project;
    if (typeof args[args.length - 1] === "function") {
      project = args.pop();
    }
    var observables = args;
    return source.lift(new WithLatestFromOperator(observables, project));
  };
}
var WithLatestFromOperator = /* @__PURE__ */ function() {
  function WithLatestFromOperator2(observables, project) {
    this.observables = observables;
    this.project = project;
  }
  WithLatestFromOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
  };
  return WithLatestFromOperator2;
}();
var WithLatestFromSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WithLatestFromSubscriber2, _super);
  function WithLatestFromSubscriber2(destination, observables, project) {
    var _this = _super.call(this, destination) || this;
    _this.observables = observables;
    _this.project = project;
    _this.toRespond = [];
    var len = observables.length;
    _this.values = new Array(len);
    for (var i = 0; i < len; i++) {
      _this.toRespond.push(i);
    }
    for (var i = 0; i < len; i++) {
      var observable2 = observables[i];
      _this.add(subscribeToResult(_this, observable2, void 0, i));
    }
    return _this;
  }
  WithLatestFromSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
    this.values[outerIndex] = innerValue;
    var toRespond = this.toRespond;
    if (toRespond.length > 0) {
      var found = toRespond.indexOf(outerIndex);
      if (found !== -1) {
        toRespond.splice(found, 1);
      }
    }
  };
  WithLatestFromSubscriber2.prototype.notifyComplete = function() {
  };
  WithLatestFromSubscriber2.prototype._next = function(value) {
    if (this.toRespond.length === 0) {
      var args = [value].concat(this.values);
      if (this.project) {
        this._tryProject(args);
      } else {
        this.destination.next(args);
      }
    }
  };
  WithLatestFromSubscriber2.prototype._tryProject = function(args) {
    var result;
    try {
      result = this.project.apply(this, args);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return WithLatestFromSubscriber2;
}(OuterSubscriber);
function zip() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function zipOperatorFunction(source) {
    return source.lift.call(zip$1.apply(void 0, [source].concat(observables)));
  };
}
function zipAll(project) {
  return function(source) {
    return source.lift(new ZipOperator(project));
  };
}
var operators = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  audit,
  auditTime,
  buffer,
  bufferCount,
  bufferTime,
  bufferToggle,
  bufferWhen,
  catchError,
  combineAll,
  combineLatest,
  concat,
  concatAll,
  concatMap,
  concatMapTo,
  count,
  debounce,
  debounceTime,
  defaultIfEmpty,
  delay,
  delayWhen,
  dematerialize,
  distinct,
  distinctUntilChanged,
  distinctUntilKeyChanged,
  elementAt,
  endWith,
  every,
  exhaust,
  exhaustMap,
  expand,
  filter,
  finalize,
  find,
  findIndex,
  first,
  groupBy,
  ignoreElements,
  isEmpty,
  last,
  map,
  mapTo,
  materialize,
  max,
  merge,
  mergeAll,
  mergeMap,
  flatMap,
  mergeMapTo,
  mergeScan,
  min,
  multicast,
  observeOn,
  onErrorResumeNext,
  pairwise,
  partition,
  pluck,
  publish,
  publishBehavior,
  publishLast,
  publishReplay,
  race,
  reduce,
  repeat,
  repeatWhen,
  retry,
  retryWhen,
  refCount,
  sample,
  sampleTime,
  scan,
  sequenceEqual,
  share,
  shareReplay,
  single,
  skip,
  skipLast,
  skipUntil,
  skipWhile,
  startWith,
  subscribeOn,
  switchAll,
  switchMap,
  switchMapTo,
  take,
  takeLast,
  takeUntil,
  takeWhile,
  tap,
  throttle,
  throttleTime,
  throwIfEmpty,
  timeInterval,
  timeout,
  timeoutWith,
  timestamp,
  toArray,
  window: window$1,
  windowCount,
  windowTime,
  windowToggle,
  windowWhen,
  withLatestFrom,
  zip,
  zipAll
}, Symbol.toStringTag, { value: "Module" }));
var require$$13 = /* @__PURE__ */ getAugmentedNamespace(operators);
var _interopRequireDefault$2 = interopRequireDefault.exports;
Object.defineProperty(bbi, "__esModule", {
  value: true
});
bbi.BBI = void 0;
var _regenerator$2 = _interopRequireDefault$2(regenerator);
var _asyncToGenerator2$2 = _interopRequireDefault$2(asyncToGenerator.exports);
var _classCallCheck2$2 = _interopRequireDefault$2(classCallCheck.exports);
var _createClass2$2 = _interopRequireDefault$2(createClass.exports);
var _defineProperty2$1 = _interopRequireDefault$2(defineProperty.exports);
var _binaryParser$1 = binary_parser;
var _genericFilehandle = require$$7;
var _rxjs$1 = require$$12;
var _operators$1 = require$$13;
var _abortablePromiseCache$1 = _interopRequireDefault$2(dist);
var _quickLru$1 = _interopRequireDefault$2(require$$9);
var _blockView$1 = blockView;
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        (0, _defineProperty2$1.default)(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var BIG_WIG_MAGIC = -2003829722;
var BIG_BED_MAGIC = -2021002517;
function getParsers(isBE) {
  var le = isBE ? "big" : "little";
  var headerParser = new _binaryParser$1.Parser().endianess(le).int32("magic").uint16("version").uint16("numZoomLevels").uint64("chromTreeOffset").uint64("unzoomedDataOffset").uint64("unzoomedIndexOffset").uint16("fieldCount").uint16("definedFieldCount").uint64("asOffset").uint64("totalSummaryOffset").uint32("uncompressBufSize").uint64("extHeaderOffset").array("zoomLevels", {
    length: "numZoomLevels",
    type: new _binaryParser$1.Parser().uint32("reductionLevel").uint32("reserved").uint64("dataOffset").uint64("indexOffset")
  });
  var totalSummaryParser = new _binaryParser$1.Parser().endianess(le).uint64("basesCovered").double("scoreMin").double("scoreMax").double("scoreSum").double("scoreSumSquares");
  var chromTreeParser = new _binaryParser$1.Parser().endianess(le).uint32("magic").uint32("blockSize").uint32("keySize").uint32("valSize").uint64("itemCount");
  var isLeafNode = new _binaryParser$1.Parser().endianess(le).uint8("isLeafNode").skip(1).uint16("cnt");
  return {
    chromTreeParser,
    totalSummaryParser,
    headerParser,
    isLeafNode
  };
}
var BBI = /* @__PURE__ */ function() {
  (0, _createClass2$2.default)(BBI2, [{
    key: "getHeader",
    value: function getHeader() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var options = "aborted" in opts ? {
        signal: opts
      } : opts;
      return this.headerCache.get(JSON.stringify(options), options, options.signal);
    }
  }]);
  function BBI2() {
    var _this = this;
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    (0, _classCallCheck2$2.default)(this, BBI2);
    (0, _defineProperty2$1.default)(this, "bbi", void 0);
    (0, _defineProperty2$1.default)(this, "headerCache", new _abortablePromiseCache$1.default({
      cache: new _quickLru$1.default({
        maxSize: 1
      }),
      fill: function() {
        var _fill = (0, _asyncToGenerator2$2.default)(/* @__PURE__ */ _regenerator$2.default.mark(function _callee(params, signal) {
          return _regenerator$2.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt("return", _this._getHeader(_objectSpread$1(_objectSpread$1({}, params), {}, {
                    signal
                  })));
                case 1:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
        function fill(_x, _x2) {
          return _fill.apply(this, arguments);
        }
        return fill;
      }()
    }));
    (0, _defineProperty2$1.default)(this, "renameRefSeqs", void 0);
    var filehandle = options.filehandle, renameRefSeqs = options.renameRefSeqs, path = options.path, url = options.url;
    this.renameRefSeqs = renameRefSeqs || function(s) {
      return s;
    };
    if (filehandle) {
      this.bbi = filehandle;
    } else if (url) {
      this.bbi = new _genericFilehandle.RemoteFile(url);
    } else if (path) {
      this.bbi = new _genericFilehandle.LocalFile(path);
    } else {
      throw new Error("no file given");
    }
  }
  (0, _createClass2$2.default)(BBI2, [{
    key: "_getHeader",
    value: function() {
      var _getHeader2 = (0, _asyncToGenerator2$2.default)(/* @__PURE__ */ _regenerator$2.default.mark(function _callee2(opts) {
        var header, chroms;
        return _regenerator$2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._getMainHeader(opts);
              case 2:
                header = _context2.sent;
                _context2.next = 5;
                return this._readChromTree(header, opts);
              case 5:
                chroms = _context2.sent;
                return _context2.abrupt("return", _objectSpread$1(_objectSpread$1({}, header), chroms));
              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));
      function _getHeader(_x3) {
        return _getHeader2.apply(this, arguments);
      }
      return _getHeader;
    }()
  }, {
    key: "_getMainHeader",
    value: function() {
      var _getMainHeader2 = (0, _asyncToGenerator2$2.default)(/* @__PURE__ */ _regenerator$2.default.mark(function _callee3(opts) {
        var requestSize, _yield$this$bbi$read, buffer2, isBigEndian, ret, header, tail, _args3 = arguments;
        return _regenerator$2.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                requestSize = _args3.length > 1 && _args3[1] !== void 0 ? _args3[1] : 2e3;
                _context3.next = 3;
                return this.bbi.read(Buffer.alloc(requestSize), 0, requestSize, 0, opts);
              case 3:
                _yield$this$bbi$read = _context3.sent;
                buffer2 = _yield$this$bbi$read.buffer;
                isBigEndian = this._isBigEndian(buffer2);
                ret = getParsers(isBigEndian);
                header = ret.headerParser.parse(buffer2).result;
                header.fileType = header.magic === BIG_BED_MAGIC ? "bigbed" : "bigwig";
                if (!(header.asOffset > requestSize || header.totalSummaryOffset > requestSize)) {
                  _context3.next = 11;
                  break;
                }
                return _context3.abrupt("return", this._getMainHeader(opts, requestSize * 2));
              case 11:
                if (header.asOffset) {
                  header.autoSql = buffer2.slice(header.asOffset, buffer2.indexOf(0, header.asOffset)).toString("utf8");
                }
                if (!(header.totalSummaryOffset > requestSize)) {
                  _context3.next = 14;
                  break;
                }
                return _context3.abrupt("return", this._getMainHeader(opts, requestSize * 2));
              case 14:
                if (header.totalSummaryOffset) {
                  tail = buffer2.slice(header.totalSummaryOffset);
                  header.totalSummary = ret.totalSummaryParser.parse(tail).result;
                }
                return _context3.abrupt("return", _objectSpread$1(_objectSpread$1({}, header), {}, {
                  isBigEndian
                }));
              case 16:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));
      function _getMainHeader(_x4) {
        return _getMainHeader2.apply(this, arguments);
      }
      return _getMainHeader;
    }()
  }, {
    key: "_isBigEndian",
    value: function _isBigEndian(buffer2) {
      var ret = buffer2.readInt32LE(0);
      if (ret === BIG_WIG_MAGIC || ret === BIG_BED_MAGIC) {
        return false;
      }
      ret = buffer2.readInt32BE(0);
      if (ret === BIG_WIG_MAGIC || ret === BIG_BED_MAGIC) {
        return true;
      }
      throw new Error("not a BigWig/BigBed file");
    }
  }, {
    key: "_readChromTree",
    value: function() {
      var _readChromTree2 = (0, _asyncToGenerator2$2.default)(/* @__PURE__ */ _regenerator$2.default.mark(function _callee5(header, opts) {
        var _this2 = this;
        var isBE, le, refsByNumber, refsByName, chromTreeOffset, unzoomedDataOffset, _yield$this$bbi$read2, data2, p, keySize, leafNodeParser, nonleafNodeParser, rootNodeOffset, bptReadNode;
        return _regenerator$2.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                isBE = header.isBigEndian;
                le = isBE ? "big" : "little";
                refsByNumber = [];
                refsByName = {};
                chromTreeOffset = header.chromTreeOffset;
                unzoomedDataOffset = header.unzoomedDataOffset;
                while (unzoomedDataOffset % 4 !== 0) {
                  unzoomedDataOffset += 1;
                }
                _context5.next = 9;
                return this.bbi.read(Buffer.alloc(unzoomedDataOffset - chromTreeOffset), 0, unzoomedDataOffset - chromTreeOffset, chromTreeOffset, opts);
              case 9:
                _yield$this$bbi$read2 = _context5.sent;
                data2 = _yield$this$bbi$read2.buffer;
                p = getParsers(isBE);
                keySize = p.chromTreeParser.parse(data2).result.keySize;
                leafNodeParser = new _binaryParser$1.Parser().endianess(le).string("key", {
                  stripNull: true,
                  length: keySize
                }).uint32("refId").uint32("refSize");
                nonleafNodeParser = new _binaryParser$1.Parser().endianess(le).skip(keySize).uint64("childOffset");
                rootNodeOffset = 32;
                bptReadNode = /* @__PURE__ */ function() {
                  var _ref = (0, _asyncToGenerator2$2.default)(/* @__PURE__ */ _regenerator$2.default.mark(function _callee4(currentOffset) {
                    var offset, ret, _ret$result, isLeafNode, cnt, n, leafRet, _leafRet$result, _key, refId, refSize, refRec, nextNodes, _n, nonleafRet, childOffset;
                    return _regenerator$2.default.wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            offset = currentOffset;
                            if (!(offset >= data2.length)) {
                              _context4.next = 3;
                              break;
                            }
                            throw new Error("reading beyond end of buffer");
                          case 3:
                            ret = p.isLeafNode.parse(data2.slice(offset));
                            _ret$result = ret.result, isLeafNode = _ret$result.isLeafNode, cnt = _ret$result.cnt;
                            offset += ret.offset;
                            if (!isLeafNode) {
                              _context4.next = 10;
                              break;
                            }
                            for (n = 0; n < cnt; n += 1) {
                              leafRet = leafNodeParser.parse(data2.slice(offset));
                              offset += leafRet.offset;
                              _leafRet$result = leafRet.result, _key = _leafRet$result.key, refId = _leafRet$result.refId, refSize = _leafRet$result.refSize;
                              refRec = {
                                name: _key,
                                id: refId,
                                length: refSize
                              };
                              refsByName[_this2.renameRefSeqs(_key)] = refId;
                              refsByNumber[refId] = refRec;
                            }
                            _context4.next = 14;
                            break;
                          case 10:
                            nextNodes = [];
                            for (_n = 0; _n < cnt; _n += 1) {
                              nonleafRet = nonleafNodeParser.parse(data2.slice(offset));
                              childOffset = nonleafRet.result.childOffset;
                              offset += nonleafRet.offset;
                              childOffset -= chromTreeOffset;
                              nextNodes.push(bptReadNode(childOffset));
                            }
                            _context4.next = 14;
                            return Promise.all(nextNodes);
                          case 14:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  }));
                  return function bptReadNode2(_x7) {
                    return _ref.apply(this, arguments);
                  };
                }();
                _context5.next = 19;
                return bptReadNode(rootNodeOffset);
              case 19:
                return _context5.abrupt("return", {
                  refsByName,
                  refsByNumber
                });
              case 20:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));
      function _readChromTree(_x5, _x6) {
        return _readChromTree2.apply(this, arguments);
      }
      return _readChromTree;
    }()
  }, {
    key: "getUnzoomedView",
    value: function() {
      var _getUnzoomedView = (0, _asyncToGenerator2$2.default)(/* @__PURE__ */ _regenerator$2.default.mark(function _callee6(opts) {
        var _yield$this$getHeader, unzoomedIndexOffset, zoomLevels, refsByName, uncompressBufSize, isBigEndian, fileType, nzl, cirLen;
        return _regenerator$2.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getHeader(opts);
              case 2:
                _yield$this$getHeader = _context6.sent;
                unzoomedIndexOffset = _yield$this$getHeader.unzoomedIndexOffset;
                zoomLevels = _yield$this$getHeader.zoomLevels;
                refsByName = _yield$this$getHeader.refsByName;
                uncompressBufSize = _yield$this$getHeader.uncompressBufSize;
                isBigEndian = _yield$this$getHeader.isBigEndian;
                fileType = _yield$this$getHeader.fileType;
                nzl = zoomLevels[0];
                cirLen = nzl ? nzl.dataOffset - unzoomedIndexOffset : 4e3;
                return _context6.abrupt("return", new _blockView$1.BlockView(this.bbi, refsByName, unzoomedIndexOffset, cirLen, isBigEndian, uncompressBufSize > 0, fileType));
              case 12:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));
      function getUnzoomedView(_x8) {
        return _getUnzoomedView.apply(this, arguments);
      }
      return getUnzoomedView;
    }()
  }, {
    key: "getFeatureStream",
    value: function() {
      var _getFeatureStream = (0, _asyncToGenerator2$2.default)(/* @__PURE__ */ _regenerator$2.default.mark(function _callee7(refName, start, end) {
        var opts, chrName, view, _args7 = arguments;
        return _regenerator$2.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                opts = _args7.length > 3 && _args7[3] !== void 0 ? _args7[3] : {
                  scale: 1
                };
                _context7.next = 3;
                return this.getHeader(opts);
              case 3:
                chrName = this.renameRefSeqs(refName);
                if (!opts.basesPerSpan) {
                  _context7.next = 10;
                  break;
                }
                _context7.next = 7;
                return this.getView(1 / opts.basesPerSpan, opts);
              case 7:
                view = _context7.sent;
                _context7.next = 19;
                break;
              case 10:
                if (!opts.scale) {
                  _context7.next = 16;
                  break;
                }
                _context7.next = 13;
                return this.getView(opts.scale, opts);
              case 13:
                view = _context7.sent;
                _context7.next = 19;
                break;
              case 16:
                _context7.next = 18;
                return this.getView(1, opts);
              case 18:
                view = _context7.sent;
              case 19:
                if (view) {
                  _context7.next = 21;
                  break;
                }
                throw new Error("unable to get block view for data");
              case 21:
                return _context7.abrupt("return", new _rxjs$1.Observable(function(observer) {
                  view.readWigData(chrName, start, end, observer, opts);
                }));
              case 22:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));
      function getFeatureStream(_x9, _x10, _x11) {
        return _getFeatureStream.apply(this, arguments);
      }
      return getFeatureStream;
    }()
  }, {
    key: "getFeatures",
    value: function() {
      var _getFeatures = (0, _asyncToGenerator2$2.default)(/* @__PURE__ */ _regenerator$2.default.mark(function _callee8(refName, start, end) {
        var opts, ob, ret, _args8 = arguments;
        return _regenerator$2.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                opts = _args8.length > 3 && _args8[3] !== void 0 ? _args8[3] : {
                  scale: 1
                };
                _context8.next = 3;
                return this.getFeatureStream(refName, start, end, opts);
              case 3:
                ob = _context8.sent;
                _context8.next = 6;
                return ob.pipe((0, _operators$1.reduce)(function(acc, curr) {
                  return acc.concat(curr);
                })).toPromise();
              case 6:
                ret = _context8.sent;
                return _context8.abrupt("return", ret || []);
              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));
      function getFeatures(_x12, _x13, _x14) {
        return _getFeatures.apply(this, arguments);
      }
      return getFeatures;
    }()
  }]);
  return BBI2;
}();
bbi.BBI = BBI;
var _interopRequireDefault$1 = interopRequireDefault.exports;
Object.defineProperty(bigwig, "__esModule", {
  value: true
});
bigwig.BigWig = void 0;
var _regenerator$1 = _interopRequireDefault$1(regenerator);
var _asyncToGenerator2$1 = _interopRequireDefault$1(asyncToGenerator.exports);
var _classCallCheck2$1 = _interopRequireDefault$1(classCallCheck.exports);
var _createClass2$1 = _interopRequireDefault$1(createClass.exports);
var _inherits2$1 = _interopRequireDefault$1(inherits.exports);
var _possibleConstructorReturn2$1 = _interopRequireDefault$1(possibleConstructorReturn.exports);
var _getPrototypeOf2$1 = _interopRequireDefault$1(getPrototypeOf.exports);
var _blockView = blockView;
var _bbi$1 = bbi;
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = (0, _getPrototypeOf2$1.default)(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = (0, _getPrototypeOf2$1.default)(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return (0, _possibleConstructorReturn2$1.default)(this, result);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var BigWig = /* @__PURE__ */ function(_BBI) {
  (0, _inherits2$1.default)(BigWig2, _BBI);
  var _super = _createSuper$1(BigWig2);
  function BigWig2() {
    (0, _classCallCheck2$1.default)(this, BigWig2);
    return _super.apply(this, arguments);
  }
  (0, _createClass2$1.default)(BigWig2, [{
    key: "getView",
    value: function() {
      var _getView = (0, _asyncToGenerator2$1.default)(/* @__PURE__ */ _regenerator$1.default.mark(function _callee(scale, opts) {
        var _yield$this$getHeader, zoomLevels, refsByName, fileSize, isBigEndian, uncompressBufSize, basesPerPx, maxLevel, i, zh, indexLength;
        return _regenerator$1.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.getHeader(opts);
              case 2:
                _yield$this$getHeader = _context.sent;
                zoomLevels = _yield$this$getHeader.zoomLevels;
                refsByName = _yield$this$getHeader.refsByName;
                fileSize = _yield$this$getHeader.fileSize;
                isBigEndian = _yield$this$getHeader.isBigEndian;
                uncompressBufSize = _yield$this$getHeader.uncompressBufSize;
                basesPerPx = 1 / scale;
                maxLevel = zoomLevels.length;
                if (!fileSize) {
                  maxLevel -= 1;
                }
                i = maxLevel;
              case 12:
                if (!(i >= 0)) {
                  _context.next = 20;
                  break;
                }
                zh = zoomLevels[i];
                if (!(zh && zh.reductionLevel <= 2 * basesPerPx)) {
                  _context.next = 17;
                  break;
                }
                indexLength = i < zoomLevels.length - 1 ? zoomLevels[i + 1].dataOffset - zh.indexOffset : fileSize - 4 - zh.indexOffset;
                return _context.abrupt("return", new _blockView.BlockView(this.bbi, refsByName, zh.indexOffset, indexLength, isBigEndian, uncompressBufSize > 0, "summary"));
              case 17:
                i -= 1;
                _context.next = 12;
                break;
              case 20:
                return _context.abrupt("return", this.getUnzoomedView(opts));
              case 21:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
      function getView(_x, _x2) {
        return _getView.apply(this, arguments);
      }
      return getView;
    }()
  }]);
  return BigWig2;
}(_bbi$1.BBI);
bigwig.BigWig = BigWig;
var bigbed = {};
var toConsumableArray = { exports: {} };
var arrayWithoutHoles = { exports: {} };
var arrayLikeToArray = { exports: {} };
(function(module) {
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  module.exports = _arrayLikeToArray;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(arrayLikeToArray);
(function(module) {
  var arrayLikeToArray$1 = arrayLikeToArray.exports;
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr))
      return arrayLikeToArray$1(arr);
  }
  module.exports = _arrayWithoutHoles;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(arrayWithoutHoles);
var iterableToArray = { exports: {} };
(function(module) {
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
      return Array.from(iter);
  }
  module.exports = _iterableToArray;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(iterableToArray);
var unsupportedIterableToArray = { exports: {} };
(function(module) {
  var arrayLikeToArray$1 = arrayLikeToArray.exports;
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return arrayLikeToArray$1(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return arrayLikeToArray$1(o, minLen);
  }
  module.exports = _unsupportedIterableToArray;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(unsupportedIterableToArray);
var nonIterableSpread = { exports: {} };
(function(module) {
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  module.exports = _nonIterableSpread;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(nonIterableSpread);
(function(module) {
  var arrayWithoutHoles$1 = arrayWithoutHoles.exports;
  var iterableToArray$1 = iterableToArray.exports;
  var unsupportedIterableToArray$1 = unsupportedIterableToArray.exports;
  var nonIterableSpread$1 = nonIterableSpread.exports;
  function _toConsumableArray(arr) {
    return arrayWithoutHoles$1(arr) || iterableToArray$1(arr) || unsupportedIterableToArray$1(arr) || nonIterableSpread$1();
  }
  module.exports = _toConsumableArray;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(toConsumableArray);
var _interopRequireDefault = interopRequireDefault.exports;
Object.defineProperty(bigbed, "__esModule", {
  value: true
});
bigbed.filterUndef = filterUndef;
bigbed.BigBed = void 0;
var _toConsumableArray2 = _interopRequireDefault(toConsumableArray.exports);
var _regenerator = _interopRequireDefault(regenerator);
var _asyncToGenerator2 = _interopRequireDefault(asyncToGenerator.exports);
var _classCallCheck2 = _interopRequireDefault(classCallCheck.exports);
var _createClass2 = _interopRequireDefault(createClass.exports);
var _assertThisInitialized2 = _interopRequireDefault(assertThisInitialized.exports);
var _inherits2 = _interopRequireDefault(inherits.exports);
var _possibleConstructorReturn2 = _interopRequireDefault(possibleConstructorReturn.exports);
var _getPrototypeOf2 = _interopRequireDefault(getPrototypeOf.exports);
var _defineProperty2 = _interopRequireDefault(defineProperty.exports);
var _binaryParser = binary_parser;
var _rxjs = require$$12;
var _operators = require$$13;
var _abortablePromiseCache = _interopRequireDefault(dist);
var _quickLru = _interopRequireDefault(require$$9);
var _bbi = bbi;
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        (0, _defineProperty2.default)(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = (0, _getPrototypeOf2.default)(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return (0, _possibleConstructorReturn2.default)(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function filterUndef(ts) {
  return ts.filter(function(t) {
    return !!t;
  });
}
var BigBed = /* @__PURE__ */ function(_BBI) {
  (0, _inherits2.default)(BigBed2, _BBI);
  var _super = _createSuper(BigBed2);
  function BigBed2(opts) {
    var _this;
    (0, _classCallCheck2.default)(this, BigBed2);
    _this = _super.call(this, opts);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "readIndicesCache", new _abortablePromiseCache.default({
      cache: new _quickLru.default({
        maxSize: 1
      }),
      fill: function() {
        var _fill = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(args, signal) {
          return _regenerator.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt("return", _this._readIndices(_objectSpread(_objectSpread({}, args), {}, {
                    signal
                  })));
                case 1:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
        function fill(_x, _x2) {
          return _fill.apply(this, arguments);
        }
        return fill;
      }()
    }));
    return _this;
  }
  (0, _createClass2.default)(BigBed2, [{
    key: "readIndices",
    value: function readIndices() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var options = "aborted" in opts ? {
        signal: opts
      } : opts;
      return this.readIndicesCache.get(JSON.stringify(options), options, options.signal);
    }
  }, {
    key: "getView",
    value: function() {
      var _getView = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee2(scale, opts) {
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", this.getUnzoomedView(opts));
              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));
      function getView(_x3, _x4) {
        return _getView.apply(this, arguments);
      }
      return getView;
    }()
  }, {
    key: "_readIndices",
    value: function() {
      var _readIndices2 = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee3(opts) {
        var _yield$this$getHeader, extHeaderOffset, isBigEndian, _yield$this$bbi$read, data2, le, ret, count2, offset, blocklen, len, _yield$this$bbi$read2, buffer2, extParser, indices, i;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.getHeader(opts);
              case 2:
                _yield$this$getHeader = _context3.sent;
                extHeaderOffset = _yield$this$getHeader.extHeaderOffset;
                isBigEndian = _yield$this$getHeader.isBigEndian;
                _context3.next = 7;
                return this.bbi.read(Buffer.alloc(64), 0, 64, extHeaderOffset);
              case 7:
                _yield$this$bbi$read = _context3.sent;
                data2 = _yield$this$bbi$read.buffer;
                le = isBigEndian ? "big" : "little";
                ret = new _binaryParser.Parser().endianess(le).uint16("size").uint16("count").uint64("offset").parse(data2).result;
                count2 = ret.count, offset = ret.offset;
                if (!(count2 === 0)) {
                  _context3.next = 14;
                  break;
                }
                return _context3.abrupt("return", []);
              case 14:
                blocklen = 20;
                len = blocklen * count2;
                _context3.next = 18;
                return this.bbi.read(Buffer.alloc(len), 0, len, offset);
              case 18:
                _yield$this$bbi$read2 = _context3.sent;
                buffer2 = _yield$this$bbi$read2.buffer;
                extParser = new _binaryParser.Parser().endianess(le).int16("type").int16("fieldcount").uint64("offset").skip(4).int16("field");
                indices = [];
                for (i = 0; i < count2; i += 1) {
                  indices.push(extParser.parse(buffer2.slice(i * blocklen)).result);
                }
                return _context3.abrupt("return", indices);
              case 24:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));
      function _readIndices(_x5) {
        return _readIndices2.apply(this, arguments);
      }
      return _readIndices;
    }()
  }, {
    key: "searchExtraIndexBlocks",
    value: function() {
      var _searchExtraIndexBlocks = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee6(name2) {
        var _this2 = this;
        var opts, _yield$this$getHeader2, isBigEndian, indices, locs, _args6 = arguments;
        return _regenerator.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                opts = _args6.length > 1 && _args6[1] !== void 0 ? _args6[1] : {};
                _context6.next = 3;
                return this.getHeader(opts);
              case 3:
                _yield$this$getHeader2 = _context6.sent;
                isBigEndian = _yield$this$getHeader2.isBigEndian;
                _context6.next = 7;
                return this.readIndices(opts);
              case 7:
                indices = _context6.sent;
                if (indices.length) {
                  _context6.next = 10;
                  break;
                }
                return _context6.abrupt("return", []);
              case 10:
                locs = indices.map(/* @__PURE__ */ function() {
                  var _ref = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee5(index) {
                    var offset, field, _yield$_this2$bbi$rea, data2, p, _p$parse$result, blockSize, keySize, valSize, bpt, bptReadNode, rootNodeOffset;
                    return _regenerator.default.wrap(function _callee5$(_context5) {
                      while (1) {
                        switch (_context5.prev = _context5.next) {
                          case 0:
                            offset = index.offset, field = index.field;
                            _context5.next = 3;
                            return _this2.bbi.read(Buffer.alloc(32), 0, 32, offset, opts);
                          case 3:
                            _yield$_this2$bbi$rea = _context5.sent;
                            data2 = _yield$_this2$bbi$rea.buffer;
                            p = new _binaryParser.Parser().endianess(isBigEndian ? "big" : "little").int32("magic").int32("blockSize").int32("keySize").int32("valSize").uint64("itemCount");
                            _p$parse$result = p.parse(data2).result, blockSize = _p$parse$result.blockSize, keySize = _p$parse$result.keySize, valSize = _p$parse$result.valSize;
                            bpt = new _binaryParser.Parser().endianess(isBigEndian ? "big" : "little").int8("nodeType").skip(1).int16("cnt").choice({
                              tag: "nodeType",
                              choices: {
                                0: new _binaryParser.Parser().array("leafkeys", {
                                  length: "cnt",
                                  type: new _binaryParser.Parser().string("key", {
                                    length: keySize,
                                    stripNull: true
                                  }).uint64("offset")
                                }),
                                1: new _binaryParser.Parser().array("keys", {
                                  length: "cnt",
                                  type: new _binaryParser.Parser().string("key", {
                                    length: keySize,
                                    stripNull: true
                                  }).uint64("offset").uint32("length").uint32("reserved")
                                })
                              }
                            });
                            bptReadNode = /* @__PURE__ */ function() {
                              var _ref2 = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee4(nodeOffset) {
                                var len, _yield$_this2$bbi$rea2, buffer2, node, lastOffset, i, key, _i;
                                return _regenerator.default.wrap(function _callee4$(_context4) {
                                  while (1) {
                                    switch (_context4.prev = _context4.next) {
                                      case 0:
                                        len = 4 + blockSize * (keySize + valSize);
                                        _context4.next = 3;
                                        return _this2.bbi.read(Buffer.alloc(len), 0, len, nodeOffset, opts);
                                      case 3:
                                        _yield$_this2$bbi$rea2 = _context4.sent;
                                        buffer2 = _yield$_this2$bbi$rea2.buffer;
                                        node = bpt.parse(buffer2).result;
                                        if (!node.leafkeys) {
                                          _context4.next = 17;
                                          break;
                                        }
                                        i = 0;
                                      case 8:
                                        if (!(i < node.leafkeys.length)) {
                                          _context4.next = 16;
                                          break;
                                        }
                                        key = node.leafkeys[i].key;
                                        if (!(name2.localeCompare(key) < 0 && lastOffset)) {
                                          _context4.next = 12;
                                          break;
                                        }
                                        return _context4.abrupt("return", bptReadNode(lastOffset));
                                      case 12:
                                        lastOffset = node.leafkeys[i].offset;
                                      case 13:
                                        i += 1;
                                        _context4.next = 8;
                                        break;
                                      case 16:
                                        return _context4.abrupt("return", bptReadNode(lastOffset));
                                      case 17:
                                        _i = 0;
                                      case 18:
                                        if (!(_i < node.keys.length)) {
                                          _context4.next = 24;
                                          break;
                                        }
                                        if (!(node.keys[_i].key === name2)) {
                                          _context4.next = 21;
                                          break;
                                        }
                                        return _context4.abrupt("return", _objectSpread(_objectSpread({}, node.keys[_i]), {}, {
                                          field
                                        }));
                                      case 21:
                                        _i += 1;
                                        _context4.next = 18;
                                        break;
                                      case 24:
                                        return _context4.abrupt("return", void 0);
                                      case 25:
                                      case "end":
                                        return _context4.stop();
                                    }
                                  }
                                }, _callee4);
                              }));
                              return function bptReadNode2(_x8) {
                                return _ref2.apply(this, arguments);
                              };
                            }();
                            rootNodeOffset = 32;
                            return _context5.abrupt("return", bptReadNode(offset + rootNodeOffset));
                          case 11:
                          case "end":
                            return _context5.stop();
                        }
                      }
                    }, _callee5);
                  }));
                  return function(_x7) {
                    return _ref.apply(this, arguments);
                  };
                }());
                _context6.t0 = filterUndef;
                _context6.next = 14;
                return Promise.all(locs);
              case 14:
                _context6.t1 = _context6.sent;
                return _context6.abrupt("return", (0, _context6.t0)(_context6.t1));
              case 16:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));
      function searchExtraIndexBlocks(_x6) {
        return _searchExtraIndexBlocks.apply(this, arguments);
      }
      return searchExtraIndexBlocks;
    }()
  }, {
    key: "searchExtraIndex",
    value: function() {
      var _searchExtraIndex = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee7(name2) {
        var opts, blocks, view, res, ret, _args7 = arguments;
        return _regenerator.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                opts = _args7.length > 1 && _args7[1] !== void 0 ? _args7[1] : {};
                _context7.next = 3;
                return this.searchExtraIndexBlocks(name2, opts);
              case 3:
                blocks = _context7.sent;
                if (blocks.length) {
                  _context7.next = 6;
                  break;
                }
                return _context7.abrupt("return", []);
              case 6:
                _context7.next = 8;
                return this.getUnzoomedView(opts);
              case 8:
                view = _context7.sent;
                res = blocks.map(function(block) {
                  return new _rxjs.Observable(function(observer) {
                    view.readFeatures(observer, [block], opts);
                  }).pipe((0, _operators.reduce)(function(acc, curr) {
                    return acc.concat(curr);
                  }), (0, _operators.map)(function(x) {
                    for (var i = 0; i < x.length; i += 1) {
                      x[i].field = block.field;
                    }
                    return x;
                  }));
                });
                _context7.next = 12;
                return _rxjs.merge.apply(void 0, (0, _toConsumableArray2.default)(res)).toPromise();
              case 12:
                ret = _context7.sent;
                return _context7.abrupt("return", ret.filter(function(f2) {
                  return f2.rest.split("	")[f2.field - 3] === name2;
                }));
              case 14:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));
      function searchExtraIndex(_x9) {
        return _searchExtraIndex.apply(this, arguments);
      }
      return searchExtraIndex;
    }()
  }]);
  return BigBed2;
}(_bbi.BBI);
bigbed.BigBed = BigBed;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "BigWig", {
    enumerable: true,
    get: function get() {
      return _bigwig.BigWig;
    }
  });
  Object.defineProperty(exports, "BigBed", {
    enumerable: true,
    get: function get() {
      return _bigbed.BigBed;
    }
  });
  Object.defineProperty(exports, "Feature", {
    enumerable: true,
    get: function get() {
      return _bbi2.Feature;
    }
  });
  Object.defineProperty(exports, "Header", {
    enumerable: true,
    get: function get() {
      return _bbi2.Header;
    }
  });
  Object.defineProperty(exports, "RequestOptions", {
    enumerable: true,
    get: function get() {
      return _bbi2.RequestOptions;
    }
  });
  var _bigwig = bigwig;
  var _bigbed = bigbed;
  var _bbi2 = bbi;
})(dist$1);
function filterUsingGenoPos(data2, [minX, maxX], config2) {
  const { x, xe, x1, x1e } = config2;
  const definedXFields = [x, xe, x1, x1e].filter((f2) => f2);
  return data2.filter((d) => {
    if (definedXFields.length === 0) {
      return true;
    } else if (definedXFields.length === 1) {
      const value = d[definedXFields[0]];
      return minX < value && value <= maxX;
    } else {
      const values = definedXFields.map((f2) => +d[f2]).filter((v) => !isNaN(v));
      const minValue = Math.min(...values);
      const maxValue = Math.max(...values);
      return minX <= maxValue && minValue <= maxX;
    }
  });
}
bisector((d) => d.pos).left;
function sanitizeChrName(chrName, assembly, chromosomePrefix) {
  if (Array.isArray(assembly)) {
    return chrName;
  }
  if (chromosomePrefix) {
    chrName = chrName.replace(chromosomePrefix, "chr");
  } else if (!chrName.includes("chr")) {
    chrName = `chr${chrName}`;
  }
  return chrName;
}
class RemoteFile extends RemoteFile$1 {
  constructor() {
    super(...arguments);
    this.read = async (buffer2, offset = 0, length, position = 0, opts = {}) => {
      const { headers = {}, signal, overrides = {} } = opts;
      if (length < Infinity) {
        headers.range = `bytes=${position}-${position + length}`;
      } else if (length === Infinity && position !== 0) {
        headers.range = `bytes=${position}-`;
      }
      const args = {
        ...this.baseOverrides,
        ...overrides,
        headers: {
          ...headers,
          ...overrides.headers,
          ...this.baseOverrides.headers
        },
        method: "GET",
        redirect: "follow",
        mode: "cors",
        signal
      };
      const response = await this.fetch(this.url, args);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status} ${response.statusText} ${this.url}`);
      }
      if (response.status === 200 || response.status === 206) {
        const responseData = await this.getBufferFromResponse(response);
        const bytesCopied = responseData.copy(buffer2, offset, 0, Math.min(length, responseData.length));
        const res = response.headers.get("content-range");
        const sizeMatch = /\/(\d+)$/.exec(res || "");
        if (sizeMatch && sizeMatch[1]) {
          this._stat = { size: parseInt(sizeMatch[1], 10) };
        }
        return { bytesRead: bytesCopied, buffer: buffer2 };
      }
      throw new Error(`HTTP ${response.status} fetching ${this.url}`);
    };
  }
}
function BigWigDataFetcher(HGC, dataConfig) {
  if (!new.target) {
    throw new Error('Uncaught TypeError: Class constructor cannot be invoked without "new"');
  }
  const cls = class BigWigDataFetcherClass {
    constructor() {
      this.dataConfig = dataConfig;
      this.assembly = this.dataConfig.assembly;
      this.bwFileHeader = null;
      this.bwFile = null;
      this.TILE_SIZE = 1024;
      this.errorTxt = "";
      this.dataPromises = [];
      const chromosomeSizes = computeChromSizes(this.assembly).size;
      const chromosomeCumPositions = [];
      const chromosomePositions = {};
      let prevEndPosition = 0;
      Object.keys(computeChromSizes(this.assembly).size).forEach((chrStr, i) => {
        const positionInfo = {
          id: i,
          chr: chrStr,
          pos: prevEndPosition
        };
        chromosomeCumPositions.push(positionInfo);
        chromosomePositions[chrStr] = positionInfo;
        prevEndPosition += computeChromSizes(this.assembly).size[chrStr];
      });
      this.chromSizes = {
        chrToAbs: (chrom, chromPos) => this.chromSizes.chrPositions[chrom].pos + chromPos,
        cumPositions: chromosomeCumPositions,
        chrPositions: chromosomePositions,
        totalLength: prevEndPosition,
        chromLengths: chromosomeSizes
      };
      this.dataPromises.push(this.loadBBI(dataConfig));
    }
    loadBBI(dataConfig2) {
      if (dataConfig2.url) {
        this.bwFile = new dist$1.BigWig({
          filehandle: new RemoteFile(dataConfig2.url)
        });
        return this.bwFile.getHeader().then((h) => {
          this.bwFileHeader = h;
        });
      } else {
        console.error('Please enter a "url" field to the data config');
        return null;
      }
    }
    tilesetInfo(callback) {
      this.tilesetInfoLoading = true;
      return Promise.all(this.dataPromises).then(() => {
        this.tilesetInfoLoading = false;
        const totalLength = this.chromSizes.totalLength;
        const retVal = {
          tile_size: this.TILE_SIZE,
          max_zoom: Math.ceil(Math.log(totalLength / this.TILE_SIZE) / Math.log(2)),
          max_width: 2 ** Math.ceil(Math.log(totalLength) / Math.log(2)),
          min_pos: [0],
          max_pos: [totalLength]
        };
        if (callback) {
          callback(retVal);
        }
        return retVal;
      }).catch((err) => {
        this.tilesetInfoLoading = false;
        console.error(err);
        if (callback) {
          callback({
            error: `Error parsing bigwig: ${err}`
          });
        }
        return null;
      });
    }
    fetchTilesDebounced(receivedTiles, tileIds) {
      const tiles = {};
      const validTileIds = [];
      const tilePromises = [];
      for (const tileId of tileIds) {
        const parts = tileId.split(".");
        const z = parseInt(parts[0], 10);
        const x = parseInt(parts[1], 10);
        if (Number.isNaN(x) || Number.isNaN(z)) {
          console.warn("Invalid tile zoom or position:", z, x);
          continue;
        }
        validTileIds.push(tileId);
        tilePromises.push(this.tile(z, x));
      }
      Promise.all(tilePromises).then((values) => {
        for (let i = 0; i < values.length; i++) {
          const validTileId = validTileIds[i];
          tiles[validTileId] = values[i];
          tiles[validTileId].tilePositionId = validTileId;
        }
        receivedTiles(tiles);
      });
      return tiles;
    }
    async tile(z, x) {
      const tsInfo = await this.tilesetInfo();
      const tileWidth = +tsInfo.max_width / 2 ** +z;
      const recordPromises = [];
      const tile = {
        tilePos: [x],
        tileId: `bigwig.${z}.${x}`,
        zoomLevel: z
      };
      const minXOriginal = tsInfo.min_pos[0] + x * tileWidth;
      let minX = minXOriginal;
      const maxX = tsInfo.min_pos[0] + (x + 1) * tileWidth;
      const basesPerPixel = this.determineScale(minX, maxX);
      const basesPerBin = (maxX - minX) / this.TILE_SIZE;
      const binStarts = [];
      for (let i = 0; i < this.TILE_SIZE; i++) {
        binStarts.push(minX + i * basesPerBin);
      }
      const { chromLengths, cumPositions } = this.chromSizes;
      cumPositions.forEach((cumPos) => {
        const chromName = cumPos.chr;
        const chromStart = cumPos.pos;
        const chromEnd = cumPos.pos + chromLengths[chromName];
        let startPos, endPos;
        if (chromStart <= minX && minX < chromEnd) {
          if (maxX > chromEnd) {
            startPos = minX - chromStart;
            endPos = chromEnd - chromStart;
            recordPromises.push(this.bwFile.getFeatures(chromName, startPos, endPos, {
              scale: 1 / basesPerPixel
            }).then((values) => {
              values.forEach((v) => {
                v["startAbs"] = HGC.utils.chrToAbs(chromName, v.start, this.chromSizes);
                v["endAbs"] = HGC.utils.chrToAbs(chromName, v.end, this.chromSizes);
              });
              return values;
            }));
            minX = chromEnd;
          } else {
            startPos = Math.floor(minX - chromStart);
            endPos = Math.ceil(maxX - chromStart);
            if (!this.bwFile)
              return;
            recordPromises.push(this.bwFile.getFeatures(chromName, startPos, endPos, {
              scale: 1 / basesPerPixel
            }).then((values) => {
              values.forEach((v) => {
                v["startAbs"] = HGC.utils.chrToAbs(chromName, v.start, this.chromSizes);
                v["endAbs"] = HGC.utils.chrToAbs(chromName, v.end, this.chromSizes);
              });
              return values;
            }));
            return;
          }
        }
      });
      return Promise.all(recordPromises).then((v) => {
        const values = v.flat();
        const dense = [];
        for (let i = 0; i < this.TILE_SIZE; i++) {
          dense.push(null);
        }
        binStarts.forEach((curStart, index) => {
          if (curStart < minXOriginal || curStart > maxX) {
            return;
          }
          const filtered = values.filter((v2) => {
            return curStart >= v2.startAbs && curStart < v2.endAbs;
          }).map((v2) => v2.score);
          dense[index] = filtered.length > 0 ? filtered[0] : null;
        });
        const dde = new HGC.utils.DenseDataExtrema1D(dense);
        tile.min_value = Math.min(...dense);
        tile.max_value = Math.max(...dense);
        tile.dense = dense;
        tile.denseDataExtrema = dde;
        tile.minNonZero = dde.minNonZeroInTile;
        tile.maxNonZero = dde.maxNonZeroInTile;
        return tile;
      });
    }
    determineScale(minX, maxX) {
      const reductionLevels = [1];
      const numRequestedElements = maxX - minX;
      if (!this.bwFileHeader) {
        throw Error("no bigwig header");
      }
      this.bwFileHeader.zoomLevels.forEach((z) => {
        reductionLevels.push(z.reductionLevel);
      });
      let level;
      reductionLevels.forEach((rl) => {
        if (level)
          return;
        const numElementsFromFile = numRequestedElements / rl;
        if (numElementsFromFile <= this.TILE_SIZE * 20) {
          level = rl;
        }
      });
      return level || reductionLevels.slice(-1)[0];
    }
  };
  return new cls();
}
BigWigDataFetcher.config = {
  type: "bigwig"
};
function CsvDataFetcher(HGC, ...args) {
  if (!new.target) {
    throw new Error('Uncaught TypeError: Class constructor cannot be invoked without "new"');
  }
  class CsvDataFetcherClass {
    constructor(params) {
      const [dataConfig] = params;
      this.dataConfig = dataConfig;
      this.tilesetInfoLoading = false;
      this.assembly = this.dataConfig.assembly;
      this.filter = this.dataConfig.filter;
      if (!dataConfig.url) {
        console.error("Please provide the `url` of the data");
        return;
      }
      const chromosomeSizes = computeChromSizes(this.assembly).size;
      const chromosomeCumPositions = [];
      const chromosomePositions = {};
      let prevEndPosition = 0;
      Object.keys(computeChromSizes(this.assembly).size).forEach((chrStr, i) => {
        const positionInfo = {
          id: i,
          chr: chrStr,
          pos: prevEndPosition
        };
        chromosomeCumPositions.push(positionInfo);
        chromosomePositions[chrStr] = positionInfo;
        prevEndPosition += computeChromSizes(this.assembly).size[chrStr];
      });
      this.chromSizes = {
        chrToAbs: (chrom, chromPos) => this.chromSizes.chrPositions[chrom].pos + chromPos,
        cumPositions: chromosomeCumPositions,
        chrPositions: chromosomePositions,
        totalLength: prevEndPosition,
        chromLengths: chromosomeSizes
      };
      if (dataConfig.data) {
        this.values = dataConfig.data;
      } else {
        this.dataPromise = this.fetchCsv();
      }
    }
    fetchCsv() {
      var _a;
      const {
        url,
        chromosomeField,
        genomicFields,
        headerNames,
        chromosomePrefix,
        longToWideId,
        genomicFieldsToConvert
      } = this.dataConfig;
      const separator = (_a = this.dataConfig.separator) != null ? _a : ",";
      return fetch(url).then((response) => {
        return response.ok ? response.text() : Promise.reject(response.status);
      }).then((text) => {
        const textWithHeader = headerNames ? `${headerNames.join(separator)}
${text}` : text;
        return dsvFormat(separator).parse(textWithHeader, (row) => {
          let successfullyGotChrInfo = true;
          if (genomicFieldsToConvert) {
            genomicFieldsToConvert.forEach((d) => {
              const cField = d.chromosomeField;
              d.genomicFields.forEach((g) => {
                try {
                  if (this.assembly !== "unknown") {
                    const chrName = sanitizeChrName(row[cField], this.assembly, chromosomePrefix);
                    row[g] = computeChromSizes(this.assembly).interval[chrName][0] + +row[g];
                  } else {
                  }
                } catch (e) {
                  successfullyGotChrInfo = false;
                }
              });
            });
          } else if (chromosomeField && genomicFields) {
            genomicFields.forEach((g) => {
              if (!row[chromosomeField]) {
                return;
              }
              try {
                if (this.assembly !== "unknown") {
                  const chrName = sanitizeChrName(row[chromosomeField], this.assembly, chromosomePrefix);
                  row[g] = computeChromSizes(this.assembly).interval[chrName][0] + +row[g];
                } else {
                }
              } catch (e) {
                successfullyGotChrInfo = false;
              }
            });
          }
          if (!successfullyGotChrInfo) {
            return void 0;
          }
          return row;
        });
      }).then((json) => {
        var _a2;
        if (longToWideId && ((_a2 = json[0]) == null ? void 0 : _a2[longToWideId])) {
          const keys = Object.keys(json[0]);
          const newJson = {};
          json.forEach((d) => {
            if (!newJson[d[longToWideId]]) {
              newJson[d[longToWideId]] = JSON.parse(JSON.stringify(d));
            } else {
              keys.forEach((k) => {
                newJson[d[longToWideId]][`${k}_2`] = d[k];
              });
            }
          });
          this.values = Object.keys(newJson).map((k) => newJson[k]);
        } else {
          this.values = json;
        }
      }).catch((error) => {
        console.error("[Gosling Data Fetcher] Error fetching data", error);
      });
    }
    generateTilesetInfo(callback) {
      this.tilesetInfoLoading = false;
      const TILE_SIZE = 1024;
      const totalLength = this.chromSizes.totalLength;
      const retVal = {
        tile_size: TILE_SIZE,
        max_zoom: Math.ceil(Math.log(totalLength / TILE_SIZE) / Math.log(2)),
        max_width: totalLength,
        min_pos: [0, 0],
        max_pos: [totalLength, totalLength]
      };
      if (callback) {
        callback(retVal);
      }
      return retVal;
    }
    tilesetInfo(callback) {
      if (!this.dataPromise) {
        return;
      }
      this.tilesetInfoLoading = true;
      return this.dataPromise.then(() => this.generateTilesetInfo(callback)).catch((err) => {
        this.tilesetInfoLoading = false;
        console.error("[Gosling Data Fetcher] Error parsing data:", err);
      });
    }
    fetchTilesDebounced(receivedTiles, tileIds) {
      const tiles = {};
      const validTileIds = [];
      const tilePromises = [];
      for (const tileId of tileIds) {
        const parts = tileId.split(".");
        const z = parseInt(parts[0], 10);
        const x = parseInt(parts[1], 10);
        const y = parseInt(parts[2], 10);
        if (Number.isNaN(x) || Number.isNaN(z)) {
          console.warn("[Gosling Data Fetcher] Invalid tile zoom or position:", z, x, y);
          continue;
        }
        validTileIds.push(tileId);
        tilePromises.push(this.tile(z, x, y));
      }
      Promise.all(tilePromises).then((values) => {
        values.forEach((value, i) => {
          const validTileId = validTileIds[i];
          tiles[validTileId] = value;
          tiles[validTileId].tilePositionId = validTileId;
        });
        receivedTiles(tiles);
      });
      return tiles;
    }
    tile(z, x, y) {
      var _a;
      return (_a = this.tilesetInfo()) == null ? void 0 : _a.then((tsInfo) => {
        var _a2, _b;
        const tileWidth = +tsInfo.max_width / 2 ** +z;
        const minX = tsInfo.min_pos[0] + x * tileWidth;
        const maxX = tsInfo.min_pos[0] + (x + 1) * tileWidth;
        let tabularData = filterUsingGenoPos(this.values, [minX, maxX], this.dataConfig);
        (_a2 = this.filter) == null ? void 0 : _a2.forEach((f2) => {
          tabularData = filterData(f2, tabularData);
        });
        const sizeLimit = (_b = this.dataConfig.sampleLength) != null ? _b : 1e3;
        return {
          tabularData: tabularData.length > sizeLimit ? sampleSize(tabularData, sizeLimit) : tabularData,
          server: null,
          tilePos: [x, y],
          zoomLevel: z
        };
      });
    }
  }
  return new CsvDataFetcherClass(args);
}
CsvDataFetcher.config = {
  type: "csv"
};
function JsonDataFetcher(HGC, ...args) {
  if (!new.target) {
    throw new Error('Uncaught TypeError: Class constructor cannot be invoked without "new"');
  }
  class JsonDataFetcherClass {
    constructor(params) {
      const [dataConfig] = params;
      this.dataConfig = dataConfig;
      this.tilesetInfoLoading = false;
      this.assembly = this.dataConfig.assembly;
      if (!dataConfig.values) {
        console.error("Please provide `values` of the JSON data");
        return;
      }
      const chromosomeSizes = computeChromSizes(this.assembly).size;
      const chromosomeCumPositions = [];
      const chromosomePositions = {};
      let prevEndPosition = 0;
      Object.keys(computeChromSizes(this.assembly).size).forEach((chrStr, i) => {
        const positionInfo = {
          id: i,
          chr: chrStr,
          pos: prevEndPosition
        };
        chromosomeCumPositions.push(positionInfo);
        chromosomePositions[chrStr] = positionInfo;
        prevEndPosition += computeChromSizes(this.assembly).size[chrStr];
      });
      this.chromSizes = {
        chrToAbs: (chrom, chromPos) => this.chromSizes.chrPositions[chrom].pos + chromPos,
        cumPositions: chromosomeCumPositions,
        chrPositions: chromosomePositions,
        totalLength: prevEndPosition,
        chromLengths: chromosomeSizes
      };
      const { chromosomeField, genomicFields } = this.dataConfig;
      this.values = dataConfig.values.map((row) => {
        let successfullyGotChrInfo = true;
        if (genomicFields && chromosomeField) {
          genomicFields.forEach((g) => {
            if (!row[chromosomeField]) {
              return;
            }
            try {
              const chrName = sanitizeChrName(row[chromosomeField], this.assembly);
              row[g] = computeChromSizes(this.assembly).interval[chrName][0] + +row[g];
            } catch (e) {
              successfullyGotChrInfo = false;
            }
          });
        }
        if (!successfullyGotChrInfo) {
          return void 0;
        }
        return row;
      });
    }
    tilesetInfo(callback) {
      this.tilesetInfoLoading = false;
      const TILE_SIZE = 1024;
      const totalLength = this.chromSizes.totalLength;
      const retVal = {
        tile_size: TILE_SIZE,
        max_zoom: Math.ceil(Math.log(totalLength / TILE_SIZE) / Math.log(2)),
        max_width: totalLength,
        min_pos: [0, 0],
        max_pos: [totalLength, totalLength]
      };
      if (callback) {
        callback(retVal);
      }
      return retVal;
    }
    fetchTilesDebounced(receivedTiles, tileIds) {
      const tiles = {};
      const validTileIds = [];
      const tilePromises = [];
      for (const tileId of tileIds) {
        const parts = tileId.split(".");
        const z = parseInt(parts[0], 10);
        const x = parseInt(parts[1], 10);
        const y = parseInt(parts[2], 10);
        if (Number.isNaN(x) || Number.isNaN(z)) {
          console.warn("[Gosling Data Fetcher] Invalid tile zoom or position:", z, x, y);
          continue;
        }
        validTileIds.push(tileId);
        tilePromises.push(this.tile(z, x, y));
      }
      Promise.all(tilePromises).then((values) => {
        values.forEach((value, i) => {
          const validTileId = validTileIds[i];
          tiles[validTileId] = value;
          tiles[validTileId].tilePositionId = validTileId;
        });
        receivedTiles(tiles);
      });
      return tiles;
    }
    tile(z, x, y) {
      var _a;
      const tsInfo = this.tilesetInfo();
      const tileWidth = +tsInfo.max_width / 2 ** +z;
      const minX = tsInfo.min_pos[0] + x * tileWidth;
      const maxX = tsInfo.min_pos[0] + (x + 1) * tileWidth;
      let tabularData = filterUsingGenoPos(this.values, [minX, maxX], this.dataConfig);
      const sizeLimit = (_a = this.dataConfig.sampleLength) != null ? _a : 1e3;
      if (sizeLimit < tabularData.length) {
        tabularData = sampleSize(tabularData, sizeLimit);
      }
      return {
        tabularData,
        server: null,
        tilePos: [x, y],
        zoomLevel: z
      };
    }
  }
  return new JsonDataFetcherClass(args);
}
JsonDataFetcher.config = {
  type: "json"
};
var dataFetchers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BamDataFetcher,
  VcfDataFetcher,
  BigWigDataFetcher,
  CsvDataFetcher,
  JsonDataFetcher
}, Symbol.toStringTag, { value: "Module" }));
const HIDDEN_BRUSH_EDGE_SIZE = 3;
const BRUSH_STYLE_DEFAULT = {
  color: "#777",
  stroke: "#777",
  strokeWidth: 1,
  strokeOpacity: 0.7,
  opacity: 0.3
};
class LinearBrushModel {
  constructor(selection, hgLibraries, style = {}) {
    this.emitter = createNanoEvents();
    this.range = null;
    this.prevExtent = [0, 0];
    this.data = this.rangeToData(0, 0);
    this.offset = [0, 0];
    this.size = 0;
    this.externals = {
      d3Selection: hgLibraries.d3Selection,
      d3Drag: hgLibraries.d3Drag
    };
    this.style = Object.assign({}, BRUSH_STYLE_DEFAULT, style);
    this.brushSelection = selection.selectAll(".genomic-range-brush").data(this.data).enter().append("rect").attr("class", "genomic-range-brush").call(this.onDrag());
  }
  getRange() {
    return this.range;
  }
  setSize(size) {
    this.size = size;
    return this;
  }
  setOffset(offsetX, offsetY) {
    this.offset = [offsetX, offsetY];
    return this;
  }
  updateRange(range2) {
    if (range2) {
      this.range = [Math.min(...range2), Math.max(...range2)];
      this.data = this.rangeToData(...this.range);
    } else {
      this.range = null;
    }
    return this;
  }
  drawBrush(skipApiTrigger = false) {
    const [x, y] = this.offset;
    const height = this.size;
    const getWidth = (d) => Math.abs(d.end - d.start);
    this.brushSelection.data(this.data).attr("transform", (d) => `translate(${x + d.start}, ${y + 1})`).attr("width", (d) => `${getWidth(d)}px`).attr("height", `${height - 2}px`).attr("fill", this.style.color).attr("stroke", this.style.stroke).attr("stroke-width", `${this.style.strokeWidth}px`).attr("fill-opacity", (d) => d.type === "body" ? this.style.opacity : 0).attr("stroke-opacity", (d) => d.type === "body" ? this.style.strokeOpacity : 0).attr("cursor", (d) => d.cursor);
    this.emitter.emit("brush", this.getRange(), skipApiTrigger);
    return this;
  }
  enable() {
    this.brushSelection.attr("pointer-events", "all");
    return this;
  }
  disable() {
    this.brushSelection.attr("pointer-events", "none");
    return this;
  }
  visible() {
    this.brushSelection.attr("visibility", "visible");
    return this;
  }
  hidden() {
    this.brushSelection.attr("visibility", "hidden");
    return this;
  }
  clear() {
    this.updateRange(null).drawBrush().hidden().disable();
    return this;
  }
  remove() {
    this.brushSelection.remove();
    return this;
  }
  rangeToData(start, end) {
    return [
      {
        type: "body",
        cursor: "grab",
        start,
        end
      },
      {
        type: "start",
        cursor: "ew-resize",
        start: start - HIDDEN_BRUSH_EDGE_SIZE,
        end: start
      },
      {
        type: "end",
        cursor: "ew-resize",
        start: end,
        end: end + HIDDEN_BRUSH_EDGE_SIZE
      }
    ];
  }
  onDrag() {
    const started = () => {
      this.startEvent = this.externals.d3Selection.event.sourceEvent;
      this.prevExtent = this.range;
    };
    const dragged = (d) => {
      var _a;
      const delta = this.externals.d3Selection.event.sourceEvent.layerX - this.startEvent.layerX;
      let [s, e] = (_a = this.prevExtent) != null ? _a : [0, 0];
      if (d.type === "body") {
        s += delta;
        e += delta;
      } else if (d.type === "start") {
        s += delta;
      } else if (d.type === "end") {
        e += delta;
      }
      this.updateRange([s, e]).drawBrush();
    };
    return this.externals.d3Drag.drag().on("start", started).on("drag", dragged);
  }
  on(event, callback) {
    this.emitter.on(event, callback);
  }
}
const DEFAULT_MOUSE_EVENT_STYLE = {
  stroke: "black",
  strokeWidth: 1,
  strokeOpacity: 1,
  color: "none",
  opacity: 1,
  arrange: "front"
};
function initProcessedTileInfo() {
  return { goslingModels: [], tabularData: [], skipRendering: false };
}
const config = {
  type: "gosling-track",
  datatype: ["multivec", "epilogos"],
  orientation: "1d-horizontal",
  defaultOptions: {
    theme: getTheme$1("light")
  }
};
const factory = (HGC, context2, options) => {
  const { tileProxy } = HGC.services;
  const loadingTextStyle = getTextStyle({ color: "black", size: 12 });
  class GoslingTrackClass extends HGC.tracks.BarTrack {
    constructor() {
      var _a, _b, _c, _d, _e, _f;
      super(context2, options);
      this.drawnAtScale = HGC.libraries.d3Scale.scaleLinear();
      this.scalableGraphics = {};
      this.extent = { min: Number.MAX_SAFE_INTEGER, max: Number.MIN_SAFE_INTEGER };
      this.gLegend = HGC.libraries.d3Selection.select(context2.svgElement).append("g");
      this.pMouseHover = new HGC.libraries.PIXI.Graphics();
      this.pMouseSelection = new HGC.libraries.PIXI.Graphics();
      this.isRangeBrushActivated = false;
      this.gBrush = HGC.libraries.d3Selection.select(context2.svgElement).append("g");
      this.loadingTextStyleObj = new HGC.libraries.PIXI.TextStyle(loadingTextStyle);
      this.loadingTextBg = new HGC.libraries.PIXI.Graphics();
      this.loadingText = new HGC.libraries.PIXI.Text("", loadingTextStyle);
      this.svgData = [];
      this.textGraphics = [];
      this.textsBeingUsed = 0;
      this.loadingStatus = { loading: 0, processing: 0, rendering: 0 };
      this.mouseDownX = 0;
      this.mouseDownY = 0;
      context2.dataFetcher.track = this;
      this.processedTileInfo = {};
      this.assembly = this.options.spec.assembly;
      if ("overlay" in this.options.spec) {
        this.options.spec.overlay = this.options.spec.overlay.map((o) => {
          return { ...o, _renderingId: v1() };
        });
      } else {
        this.options.spec._renderingId = v1();
      }
      this.fetchedTiles = {};
      this.tileSize = (_b = (_a = this.tilesetInfo) == null ? void 0 : _a.tile_size) != null ? _b : 1024;
      const { valid, errorMessages } = validateTrack(this.options.spec);
      if (!valid) {
        console.warn("The specification of the following track is invalid", errorMessages, this.options.spec);
      }
      this.pMain.addChild(this.pMouseHover);
      this.pMain.addChild(this.pMouseSelection);
      this.pMask.interactive = true;
      this.mRangeBrush = new LinearBrushModel(this.gBrush, HGC.libraries, (_c = this.options.spec.style) == null ? void 0 : _c.brush);
      this.mRangeBrush.on("brush", this.onRangeBrush.bind(this));
      this.pMask.on("mousedown", (e) => {
        const { x, y } = e.data.getLocalPosition(this.pMain);
        this.onMouseDown(x, y, e.data.originalEvent.altKey);
      });
      this.pMask.on("mouseup", (e) => {
        const { x, y } = e.data.getLocalPosition(this.pMain);
        this.onMouseUp(x, y);
      });
      this.pMask.on("mousemove", (e) => {
        const { x } = e.data.getLocalPosition(this.pMain);
        this.onMouseMove(x);
      });
      this.pMask.on("mouseout", this.onMouseOut.bind(this));
      this.flipText = this.options.spec.orientation === "vertical";
      if (this.hideMousePosition) {
        this.hideMousePosition();
        this.hideMousePosition = void 0;
      }
      if (((_d = this.options) == null ? void 0 : _d.showMousePosition) && !this.hideMousePosition) {
        this.hideMousePosition = HGC.utils.showMousePosition(this, Is2DTrack(resolveSuperposedTracks(this.options.spec)[0]), this.isShowGlobalMousePosition());
      }
      this.pLabel.removeChild(this.trackNotFoundText);
      this.loadingText.anchor.x = 1;
      this.loadingText.anchor.y = 1;
      this.pLabel.addChild(this.loadingTextBg);
      this.pLabel.addChild(this.loadingText);
      HGC.libraries.PIXI.GRAPHICS_CURVES.adaptive = (_f = (_e = this.options.spec.style) == null ? void 0 : _e.enableSmoothPath) != null ? _f : false;
      if (HGC.libraries.PIXI.GRAPHICS_CURVES.adaptive) {
        HGC.libraries.PIXI.GRAPHICS_CURVES.maxLength = 1;
        HGC.libraries.PIXI.GRAPHICS_CURVES.maxSegments = 2048 * 10;
      }
    }
    draw() {
      var _a, _b;
      this.clearMouseEventData();
      this.svgData = [];
      this.textsBeingUsed = 0;
      (_a = this.pMouseHover) == null ? void 0 : _a.clear();
      const processTilesAndDraw = () => {
        this.processAllTiles();
        super.draw();
        this.prevVisibleAndFetchedTiles = this.visibleAndFetchedTiles();
      };
      if (isTabularDataFetcher(this.dataFetcher) && !isEqual(this.visibleAndFetchedTiles(), this.prevVisibleAndFetchedTiles)) {
        this.updateTileAsync(this.dataFetcher, processTilesAndDraw);
      } else {
        processTilesAndDraw();
      }
      (_b = this.mRangeBrush) == null ? void 0 : _b.drawBrush(true);
    }
    initTile(tile) {
      this.drawTile(tile);
    }
    updateTile() {
    }
    renderTile() {
    }
    drawTile(tile) {
      var _a, _b;
      tile.drawnAtScale = this._xScale.copy();
      const tileInfo = this.processedTileInfo[tile.tileId];
      if (!tileInfo) {
        return;
      }
      (_a = tile.graphics) == null ? void 0 : _a.clear();
      (_b = tile.graphics) == null ? void 0 : _b.removeChildren();
      tileInfo.goslingModels.forEach((model) => {
        const trackWidth = this.dimensions[0];
        const zoomLevel = this._xScale.invert(trackWidth) - this._xScale.invert(0);
        if (!model.trackVisibility({ zoomLevel })) {
          return;
        }
        drawPreEmbellishment(HGC, this, tile, model, this.options.theme);
        drawMark(HGC, this, tile, model);
        drawPostEmbellishment(HGC, this, tile, model, this.options.theme);
      });
      this.forceDraw();
    }
    rerender(newOptions) {
      this.options = newOptions;
      if (this.options.spec.layout === "circular") {
        this.mRangeBrush.remove();
      }
      this.clearMouseEventData();
      this.svgData = [];
      this.textsBeingUsed = 0;
      this.processAllTiles(true);
      this.draw();
      this.forceDraw();
    }
    clearMouseEventData() {
      this.visibleAndFetchedGoslingModels().forEach((model) => model.getMouseEventModel().clear());
    }
    remove() {
      super.remove();
      if (this.gLegend) {
        this.gLegend.remove();
        this.gLegend = void 0;
      }
      this.mRangeBrush.remove();
    }
    setDimensions(newDimensions) {
      this.oldDimensions = this.dimensions;
      super.setDimensions(newDimensions);
      this.mRangeBrush.setSize(newDimensions[1]);
    }
    setPosition(newPosition) {
      super.setPosition(newPosition);
      [this.pMain.position.x, this.pMain.position.y] = this.position;
      this.mRangeBrush.setOffset(...newPosition);
    }
    forceDraw() {
      this.animate();
    }
    zoomed(newXScale, newYScale) {
      const range2 = this.mRangeBrush.getRange();
      this.mRangeBrush.updateRange(range2 ? [newXScale(this._xScale.invert(range2[0])), newXScale(this._xScale.invert(range2[1]))] : null);
      this.xScale(newXScale);
      this.yScale(newYScale);
      this.refreshTiles();
      this.draw();
      this.forceDraw();
    }
    async updateTileAsync(tabularDataFetcher, callback) {
      if (!this.tilesetInfo)
        return;
      this.xDomain = this._xScale.domain();
      this.xRange = this._xScale.range();
      const tabularData = await tabularDataFetcher.getTabularData(Object.values(this.fetchedTiles).map((x) => x.remoteId));
      const tiles = this.visibleAndFetchedTiles();
      if (tiles == null ? void 0 : tiles[0]) {
        const tile = tiles[0];
        const [refTile] = HGC.utils.trackUtils.calculate1DVisibleTiles(this.tilesetInfo, this._xScale);
        tile.tileData.zoomLevel = refTile[0];
        tile.tileData.tilePos = [refTile[1], refTile[1]];
        tile.tileData.tabularData = tabularData;
      }
      callback();
    }
    scaleScalableGraphics(graphics, xScale, drawnAtScale) {
      const drawnAtScaleExtent = drawnAtScale.domain()[1] - drawnAtScale.domain()[0];
      const xScaleExtent = xScale.domain()[1] - xScale.domain()[0];
      const tileK = drawnAtScaleExtent / xScaleExtent;
      const newRange = xScale.domain().map(drawnAtScale);
      const posOffset = newRange[0];
      graphics.forEach((g) => {
        g.scale.x = tileK;
        g.position.x = -posOffset * tileK;
      });
    }
    visibleAndFetchedGoslingModels() {
      return this.visibleAndFetchedTiles().flatMap((tile) => {
        var _a, _b;
        return (_b = (_a = this.processedTileInfo[tile.tileId]) == null ? void 0 : _a.goslingModels) != null ? _b : [];
      });
    }
    calculateVisibleTiles() {
      var _a, _b, _c;
      if (!this.tilesetInfo)
        return;
      if (isTabularDataFetcher(this.dataFetcher)) {
        const tiles = HGC.utils.trackUtils.calculate1DVisibleTiles(this.tilesetInfo, this._xScale);
        const maxTileWith = (_b = (_a = this.tilesetInfo.max_tile_width) != null ? _a : this.dataFetcher.MAX_TILE_WIDTH) != null ? _b : Number.MAX_SAFE_INTEGER;
        for (const tile of tiles) {
          const { tileWidth } = this.getTilePosAndDimensions(tile[0], [tile[1], tile[1]]);
          this.forceDraw();
          if (tileWidth > maxTileWith) {
            return;
          }
        }
        this.setVisibleTiles(tiles);
      } else {
        if (!this.tilesetInfo) {
          return;
        }
        const zoomLevel = this.calculateZoomLevel();
        if ("resolutions" in this.tilesetInfo) {
          const sortedResolutions = this.tilesetInfo.resolutions.map((x) => +x).sort((a, b) => b - a);
          const xTiles = tileProxy.calculateTilesFromResolution(sortedResolutions[zoomLevel], this._xScale, this.tilesetInfo.min_pos[0], this.tilesetInfo.max_pos[0]);
          let yTiles;
          if (Is2DTrack(resolveSuperposedTracks(this.options.spec)[0])) {
            yTiles = tileProxy.calculateTilesFromResolution(sortedResolutions[zoomLevel], this._yScale, this.tilesetInfo.min_pos[0], this.tilesetInfo.max_pos[0]);
          }
          const tiles = this.tilesToId(xTiles, yTiles, zoomLevel);
          this.setVisibleTiles(tiles);
        } else {
          const xTiles = tileProxy.calculateTiles(zoomLevel, this.relevantScale(), this.tilesetInfo.min_pos[0], this.tilesetInfo.max_pos[0], this.tilesetInfo.max_zoom, this.tilesetInfo.max_width);
          let yTiles;
          if (Is2DTrack(resolveSuperposedTracks(this.options.spec)[0])) {
            yTiles = tileProxy.calculateTiles(zoomLevel, this._yScale, this.tilesetInfo.min_pos[1], this.tilesetInfo.max_pos[1], this.tilesetInfo.max_zoom, (_c = this.tilesetInfo.max_width1) != null ? _c : this.tilesetInfo.max_width);
          }
          const tiles = this.tilesToId(xTiles, yTiles, zoomLevel);
          this.setVisibleTiles(tiles);
        }
      }
    }
    get binsPerTile() {
      let maybeValue;
      if (this.tilesetInfo) {
        maybeValue = "bins_per_dimension" in this.tilesetInfo ? this.tilesetInfo.bins_per_dimension : this.tilesetInfo.tile_size;
      }
      return maybeValue != null ? maybeValue : 256;
    }
    getTilePosAndDimensions(zoomLevel, tilePos) {
      if (!this.tilesetInfo || !tilePos) {
        throw Error("tilesetInfo not parsed");
      }
      if ("resolutions" in this.tilesetInfo) {
        const sortedResolutions = this.tilesetInfo.resolutions.map((x) => +x).sort((a, b) => b - a);
        const chosenResolution = sortedResolutions[zoomLevel];
        const [xTilePos, yTilePos] = tilePos;
        const tileWidth = chosenResolution * this.binsPerTile;
        const tileHeight = tileWidth;
        const tileX = tileWidth * xTilePos;
        const tileY = tileHeight * yTilePos;
        return {
          tileX,
          tileY,
          tileWidth,
          tileHeight
        };
      } else {
        const [xTilePos, yTilePos] = tilePos;
        const minX = this.tilesetInfo.min_pos[0];
        const minY = this.tilesetInfo.min_pos[1];
        const tileWidth = this.tilesetInfo.max_width / 2 ** zoomLevel;
        const tileHeight = this.tilesetInfo.max_width / 2 ** zoomLevel;
        const tileX = minX + xTilePos * tileWidth;
        const tileY = minY + yTilePos * tileHeight;
        return {
          tileX,
          tileY,
          tileWidth,
          tileHeight
        };
      }
    }
    tilesToId(xTiles, yTiles, zoomLevel) {
      if (!yTiles) {
        return xTiles.map((x) => [zoomLevel, x]);
      }
      const tiles = [];
      xTiles.forEach((x) => yTiles.forEach((y) => tiles.push([zoomLevel, x, y])));
      return tiles;
    }
    receivedTiles(loadedTiles) {
      super.receivedTiles(loadedTiles);
      isTabularDataFetcher(this.dataFetcher) && this.drawLoadingCue();
    }
    removeOldTiles() {
      super.removeOldTiles();
      isTabularDataFetcher(this.dataFetcher) && this.drawLoadingCue();
    }
    drawLoadingCue() {
      if (this.fetching.size) {
        const margin = 6;
        const text = `Fetching... ${Array.from(this.fetching).join(" ")}`;
        this.loadingText.text = text;
        this.loadingText.x = this.position[0] + this.dimensions[0] - margin / 2;
        this.loadingText.y = this.position[1] + this.dimensions[1] - margin / 2;
        const metric = HGC.libraries.PIXI.TextMetrics.measureText(text, this.loadingTextStyleObj);
        const { width: w, height: h } = metric;
        this.loadingTextBg.clear();
        this.loadingTextBg.lineStyle(1, colorToHex("grey"), 1, 0.5);
        this.loadingTextBg.beginFill(colorToHex("white"), 0.8);
        this.loadingTextBg.drawRect(this.position[0] + this.dimensions[0] - w - margin - 1, this.position[1] + this.dimensions[1] - h - margin - 1, w + margin, h + margin);
        this.loadingText.visible = true;
        this.loadingTextBg.visible = true;
      } else {
        this.loadingText.visible = false;
        this.loadingTextBg.visible = false;
      }
    }
    updateScaleOffsetFromOriginalSpec(_renderingId, scaleOffset, channelKey) {
      resolveSuperposedTracks(this.options.spec).map((spec) => {
        if (spec._renderingId === _renderingId) {
          const channel = spec[channelKey];
          if (IsChannelDeep(channel)) {
            channel.scaleOffset = scaleOffset;
          }
        }
      });
    }
    shareScaleOffsetAcrossTracksAndTiles(scaleOffset, channelKey) {
      const models = this.visibleAndFetchedGoslingModels();
      models.forEach((d) => {
        const channel = d.spec()[channelKey];
        if (IsChannelDeep(channel)) {
          channel.scaleOffset = scaleOffset;
        }
        const channelOriginal = d.originalSpec()[channelKey];
        if (IsChannelDeep(channelOriginal)) {
          channelOriginal.scaleOffset = scaleOffset;
        }
      });
    }
    shouldCombineTiles() {
      const includesDisplaceTransform = hasDataTransform(this.options.spec, "displace");
      const hasDenseTiles = () => {
        const tiles = this.visibleAndFetchedTiles();
        return tiles.length >= 1 && "dense" in tiles[0].tileData;
      };
      const isBamDataFetcher = this.dataFetcher instanceof BamDataFetcher;
      return includesDisplaceTransform && !hasDenseTiles() || isBamDataFetcher;
    }
    combineAllTilesIfNeeded() {
      var _a, _b, _c;
      if (!this.shouldCombineTiles())
        return;
      const tiles = this.visibleAndFetchedTiles();
      if (!tiles || tiles.length <= 1) {
        return;
      }
      this.tileSize = ((_b = (_a = this.tilesetInfo) == null ? void 0 : _a.tile_size) != null ? _b : 1024) * tiles.length;
      let merged = [];
      tiles.forEach((tile, i) => {
        const tileInfo = this.processedTileInfo[tile.tileId];
        if (tileInfo) {
          merged = [...merged, ...tileInfo.tabularData];
          tileInfo.skipRendering = i !== 0;
        }
      });
      const firstTileInfo = this.processedTileInfo[tiles[0].tileId];
      firstTileInfo.tabularData = merged;
      if ((_c = firstTileInfo.tabularData[0]) == null ? void 0 : _c.uid) {
        firstTileInfo.tabularData = uniqBy(firstTileInfo.tabularData, "uid");
      }
    }
    processAllTiles(force = false) {
      var _a, _b;
      this.tileSize = (_b = (_a = this.tilesetInfo) == null ? void 0 : _a.tile_size) != null ? _b : 1024;
      const tiles = this.visibleAndFetchedTiles();
      tiles.forEach((tile) => this.generateTabularData(tile, force));
      this.combineAllTilesIfNeeded();
      const models = tiles.flatMap((tile) => this.transformDataAndCreateModels(tile));
      shareScaleAcrossTracks(models);
      const flatTileData = [].concat(...models.map((d) => d.data()));
      if (flatTileData.length !== 0) {
        publish$1("rawData", { id: context2.viewUid, data: flatTileData });
      }
    }
    getResolvedTracks() {
      const copy2 = structuredClone(this.options.spec);
      return resolveSuperposedTracks(copy2).filter((t) => t.mark !== "brush");
    }
    generateTabularData(tile, force = false) {
      if (this.processedTileInfo[tile.tileId] && !force) {
        return;
      }
      if (!tile.tileData.tilePos) {
        return;
      }
      const tileInfo = initProcessedTileInfo();
      const resolvedTracks = this.getResolvedTracks();
      if (resolvedTracks.length === 0) {
        return [];
      }
      const firstResolvedTrack = resolvedTracks[0];
      if ("tabularData" in tile.tileData) {
        tileInfo.tabularData = tile.tileData.tabularData;
      } else {
        const { tileX, tileY, tileWidth, tileHeight } = this.getTilePosAndDimensions(tile.tileData.zoomLevel, tile.tileData.tilePos);
        const sparse = "length" in tile.tileData ? Array.from(tile.tileData) : [];
        const tabularData = getTabularData(firstResolvedTrack, {
          ...tile.tileData,
          sparse,
          tileX,
          tileY,
          tileWidth,
          tileHeight,
          tileSize: this.tileSize
        });
        if (tabularData) {
          tileInfo.tabularData = tabularData;
        }
      }
      this.processedTileInfo[tile.tileId] = tileInfo;
    }
    transformDataAndCreateModels(tile) {
      const tileInfo = this.processedTileInfo[tile.tileId];
      if (!tileInfo || tileInfo.skipRendering) {
        return [];
      }
      tileInfo.goslingModels = [];
      const resolvedTracks = this.getResolvedTracks();
      resolvedTracks.forEach((resolvedSpec) => {
        var _a;
        let tabularDataTransformed = Array.from(tileInfo.tabularData);
        (_a = resolvedSpec.dataTransform) == null ? void 0 : _a.forEach((t) => {
          switch (t.type) {
            case "filter":
              tabularDataTransformed = filterData(t, tabularDataTransformed);
              break;
            case "concat":
              tabularDataTransformed = concatString(t, tabularDataTransformed);
              break;
            case "replace":
              tabularDataTransformed = replaceString(t, tabularDataTransformed);
              break;
            case "log":
              tabularDataTransformed = calculateData(t, tabularDataTransformed);
              break;
            case "exonSplit":
              tabularDataTransformed = splitExon(t, tabularDataTransformed, resolvedSpec.assembly);
              break;
            case "genomicLength":
              tabularDataTransformed = calculateGenomicLength(t, tabularDataTransformed);
              break;
            case "svType":
              tabularDataTransformed = inferSvType(t, tabularDataTransformed);
              break;
            case "coverage":
              tabularDataTransformed = aggregateCoverage(t, tabularDataTransformed, this._xScale.copy());
              break;
            case "subjson":
              tabularDataTransformed = parseSubJSON(t, tabularDataTransformed);
              break;
            case "displace":
              tabularDataTransformed = displace(t, tabularDataTransformed, this._xScale.copy());
              break;
          }
        });
        try {
          if (PubSub) {
            const NUM_OF_ROWS_IN_PREVIEW = 100;
            const numOrRows = tabularDataTransformed.length;
            PubSub.publish("data-preview", {
              id: context2.viewUid,
              dataConfig: JSON.stringify({ data: resolvedSpec.data }),
              data: NUM_OF_ROWS_IN_PREVIEW > numOrRows ? tabularDataTransformed : sampleSize(tabularDataTransformed, NUM_OF_ROWS_IN_PREVIEW)
            });
          }
        } catch (e) {
        }
        const [trackWidth, trackHeight] = this.dimensions;
        const axisSize = IsXAxis(resolvedSpec) ? HIGLASS_AXIS_SIZE : 0;
        const [w, h] = [trackWidth, trackHeight + axisSize];
        const circularFactor = Math.min(w, h) / Math.min(resolvedSpec.width, resolvedSpec.height);
        if (resolvedSpec.innerRadius) {
          resolvedSpec.innerRadius = resolvedSpec.innerRadius * circularFactor;
        }
        if (resolvedSpec.outerRadius) {
          resolvedSpec.outerRadius = resolvedSpec.outerRadius * circularFactor;
        }
        resolvedSpec.width = w;
        resolvedSpec.height = h;
        const model = new GoslingTrackModel(resolvedSpec, tabularDataTransformed, this.options.theme);
        tileInfo.goslingModels.push(model);
      });
      return tileInfo.goslingModels;
    }
    getIndicesOfVisibleDataInTile(tile) {
      const visible = this._xScale.range();
      if (!this.tilesetInfo || !tile.tileData.tilePos || !("dense" in tile.tileData)) {
        return [0, 0];
      }
      const { tileX, tileWidth } = this.getTilePosAndDimensions(tile.tileData.zoomLevel, tile.tileData.tilePos);
      const tileXScale = HGC.libraries.d3Scale.scaleLinear().domain([0, this.binsPerTile]).range([tileX, tileX + tileWidth]);
      const start = Math.max(0, Math.round(tileXScale.invert(this._xScale.invert(visible[0]))));
      const end = Math.min(tile.tileData.dense.length, Math.round(tileXScale.invert(this._xScale.invert(visible[1]))));
      return [start, end];
    }
    minVisibleValue() {
      return 0;
    }
    maxVisibleValue() {
      return 0;
    }
    exportSVG() {
      throw new Error("exportSVG() not supported for gosling-track");
    }
    getElementsWithinMouse(mouseX, mouseY) {
      var _a;
      const models = this.visibleAndFetchedGoslingModels();
      const mouseEvents = (_a = this.options.spec.experimental) == null ? void 0 : _a.mouseEvents;
      const multiHovering = IsMouseEventsDeep(mouseEvents) && mouseEvents.enableMouseOverOnMultipleMarks;
      const idField = IsMouseEventsDeep(mouseEvents) && mouseEvents.groupMarksByField;
      const mergedCapturedElements = models.map((model) => model.getMouseEventModel().findAll(mouseX, mouseY, true)).flat();
      if (!multiHovering) {
        mergedCapturedElements.splice(1, mergedCapturedElements.length - 1);
      }
      if (mergedCapturedElements.length !== 0 && idField) {
        const source = Array.from(mergedCapturedElements);
        models.forEach((model) => {
          const siblings = model.getMouseEventModel().getSiblings(source, idField);
          mergedCapturedElements.push(...siblings);
        });
      }
      return mergedCapturedElements;
    }
    highlightMarks(g, marks, style) {
      g.lineStyle(style.strokeWidth, colorToHex(style.stroke), style.strokeOpacity, 0.5);
      g.beginFill(colorToHex(style.color), style.color === "none" ? 0 : style.opacity);
      marks.forEach((d) => {
        if (d.type === "point") {
          const [x, y, r = 3] = d.polygon;
          g.drawCircle(x, y, r);
        } else if (d.type === "line") {
          g.moveTo(d.polygon[0], d.polygon[1]);
          flatArrayToPairArray(d.polygon).map((d2) => g.lineTo(d2[0], d2[1]));
        } else {
          g.drawPolygon(d.polygon);
        }
      });
    }
    publishTrackEvents(eventType, mouseX, mouseY) {
      const [x, y] = this.position;
      const [width, height] = this.dimensions;
      if (this.options.spec.layout === "circular") {
        const cx = x + width / 2;
        const cy = y + height / 2;
        const innerRadius = this.options.spec.innerRadius;
        const outerRadius = this.options.spec.outerRadius;
        const startAngle = this.options.spec.startAngle;
        const endAngle = this.options.spec.endAngle;
        if (isPointInsideDonutSlice([mouseX, mouseY], [width / 2, height / 2], [innerRadius, outerRadius], [startAngle, endAngle])) {
          publish$1(eventType, {
            id: context2.viewUid,
            spec: structuredClone(this.options.spec),
            shape: { cx, cy, innerRadius, outerRadius, startAngle, endAngle }
          });
        }
      } else {
        publish$1(eventType, {
          id: context2.viewUid,
          spec: structuredClone(this.options.spec),
          shape: { x, y, width, height }
        });
      }
    }
    onRangeBrush(range2, skipApiTrigger = false) {
      var _a, _b, _c, _d;
      this.pMouseSelection.clear();
      if (range2 === null) {
        if (!skipApiTrigger) {
          publish$1("rangeSelect", { id: context2.viewUid, genomicRange: null, data: [] });
        }
        return;
      }
      const models = this.visibleAndFetchedGoslingModels();
      const [startX, endX] = range2;
      let capturedElements = models.map((model) => model.getMouseEventModel().findAllWithinRange(startX, endX, true)).flat();
      const mouseEvents = (_a = this.options.spec.experimental) == null ? void 0 : _a.mouseEvents;
      const idField = IsMouseEventsDeep(mouseEvents) && mouseEvents.groupMarksByField;
      if (capturedElements.length !== 0 && idField) {
        models.forEach((model) => {
          const siblings = model.getMouseEventModel().getSiblings(capturedElements, idField);
          const siblingIds = Array.from(new Set(siblings.map((d) => d.value[idField])));
          capturedElements = capturedElements.filter((d) => siblingIds.indexOf(d.value[idField]) === -1);
        });
      }
      if (capturedElements.length !== 0) {
        const g = this.pMouseSelection;
        if (((_c = (_b = this.options.spec.style) == null ? void 0 : _b.select) == null ? void 0 : _c.arrange) !== "behind") {
          this.pMain.removeChild(g);
          this.pMain.addChild(g);
        }
        this.highlightMarks(g, capturedElements, Object.assign({}, DEFAULT_MOUSE_EVENT_STYLE, (_d = this.options.spec.style) == null ? void 0 : _d.select));
      }
      if (!skipApiTrigger) {
        const genomicRange = [
          getRelativeGenomicPosition(Math.floor(this._xScale.invert(startX)), this.assembly),
          getRelativeGenomicPosition(Math.floor(this._xScale.invert(endX)), this.assembly)
        ];
        publish$1("rangeSelect", {
          id: context2.viewUid,
          genomicRange,
          data: capturedElements.map((d) => d.value)
        });
      }
      this.forceDraw();
    }
    onMouseDown(mouseX, mouseY, isAltPressed) {
      var _a;
      this.mouseDownX = mouseX;
      this.mouseDownY = mouseY;
      const mouseEvents = (_a = this.options.spec.experimental) == null ? void 0 : _a.mouseEvents;
      const rangeSelectEnabled = !!mouseEvents || IsMouseEventsDeep(mouseEvents) && !!mouseEvents.rangeSelect;
      this.isRangeBrushActivated = rangeSelectEnabled && isAltPressed;
      this.pMouseHover.clear();
    }
    onMouseMove(mouseX) {
      if (this.options.spec.layout === "circular") {
        return;
      }
      if (this.isRangeBrushActivated) {
        this.mRangeBrush.updateRange([mouseX, this.mouseDownX]).drawBrush().visible().disable();
      }
    }
    onMouseUp(mouseX, mouseY) {
      var _a;
      this.publishTrackEvents("trackClick", mouseX, mouseY);
      const mouseEvents = (_a = this.options.spec.experimental) == null ? void 0 : _a.mouseEvents;
      const clickEnabled = !!mouseEvents || IsMouseEventsDeep(mouseEvents) && !!mouseEvents.click;
      const isDrag = Math.sqrt((this.mouseDownX - mouseX) ** 2 + (this.mouseDownY - mouseY) ** 2) > 1;
      if (!this.isRangeBrushActivated && !isDrag) {
        this.mRangeBrush.clear();
        this.pMouseSelection.clear();
      } else {
        this.mRangeBrush.enable();
      }
      this.isRangeBrushActivated = false;
      if (!this.tilesetInfo) {
        return;
      }
      if (!isDrag && clickEnabled) {
        const genomicPosition = getRelativeGenomicPosition(Math.floor(this._xScale.invert(mouseX)), this.assembly);
        const capturedElements = this.getElementsWithinMouse(mouseX, mouseY);
        if (capturedElements.length !== 0) {
          publish$1("click", {
            id: context2.viewUid,
            genomicPosition,
            data: capturedElements.map((d) => d.value)
          });
        }
      }
    }
    onMouseOut() {
      this.isRangeBrushActivated = false;
      document.body.style.cursor = "default";
      this.pMouseHover.clear();
    }
    getMouseOverHtml(mouseX, mouseY) {
      var _a, _b, _c, _d, _e;
      this.publishTrackEvents("trackMouseOver", mouseX, mouseY);
      if (this.isRangeBrushActivated) {
        return "";
      }
      if (!this.tilesetInfo) {
        return "";
      }
      this.pMouseHover.clear();
      const genomicPosition = getRelativeGenomicPosition(Math.floor(this._xScale.invert(mouseX)), this.assembly);
      const capturedElements = this.getElementsWithinMouse(mouseX, mouseY);
      if (capturedElements.length !== 0) {
        document.body.style.cursor = "pointer";
      } else {
        document.body.style.cursor = "default";
      }
      if (capturedElements.length !== 0) {
        const mouseEvents = (_a = this.options.spec.experimental) == null ? void 0 : _a.mouseEvents;
        const mouseOverEnabled = !!mouseEvents || IsMouseEventsDeep(mouseEvents) && !!mouseEvents.mouseOver;
        if (mouseOverEnabled) {
          const g = this.pMouseHover;
          if (((_c = (_b = this.options.spec.style) == null ? void 0 : _b.mouseOver) == null ? void 0 : _c.arrange) !== "behind") {
            this.pMain.removeChild(g);
            this.pMain.addChild(g);
          }
          this.highlightMarks(g, capturedElements, Object.assign({}, DEFAULT_MOUSE_EVENT_STYLE, (_d = this.options.spec.style) == null ? void 0 : _d.mouseOver));
          publish$1("mouseOver", {
            id: context2.viewUid,
            genomicPosition,
            data: capturedElements.map((d) => d.value)
          });
        }
        const models = this.visibleAndFetchedGoslingModels();
        const firstTooltipSpec = (_e = models.find((m) => {
          var _a2;
          return m.spec().tooltip && ((_a2 = m.spec().tooltip) == null ? void 0 : _a2.length) !== 0;
        })) == null ? void 0 : _e.spec().tooltip;
        if (firstTooltipSpec) {
          let content = firstTooltipSpec.map((d) => {
            var _a2;
            const rawValue = capturedElements[0].value[d.field];
            let value = rawValue;
            if (d.type === "quantitative" && d.format) {
              value = HGC.libraries.d3Format.format(d.format)(+rawValue);
            } else if (d.type === "genomic") {
              const { chromosome, position } = getRelativeGenomicPosition(+rawValue, this.assembly);
              value = `${chromosome}:${HGC.libraries.d3Format.format(",")(position)}`;
            }
            return `<tr><td style='padding: 4px 8px'>${(_a2 = d.alt) != null ? _a2 : d.field}</td><td style='padding: 4px 8px'><b>${value}</b></td></tr>`;
          }).join("");
          content = `<table style='text-align: left; margin-top: 12px'>${content}</table>`;
          if (capturedElements.length > 1) {
            content += `<div style='padding: 4px 8px; margin-top: 4px; text-align: center; color: grey'>${capturedElements.length - 1} Additional Selections...</div>`;
          }
          return `<div>${content}</div>`;
        }
      }
      return "";
    }
  }
  return new GoslingTrackClass();
};
var GoslingTrack = createPluginTrack(config, factory);
let once = false;
function init() {
  if (once)
    return;
  higlassRegister({
    name: "GoslingTrack",
    track: GoslingTrack,
    config: GoslingTrack.config
  });
  higlassRegister({
    name: "Gosling2DTrack",
    track: GoslingTrack,
    config: {
      ...GoslingTrack.config,
      type: "gosling-2d-track",
      orientation: "2d"
    }
  });
  higlassRegister({
    name: "AxisTrack",
    track: AxisTrack,
    config: AxisTrack.config
  });
  higlassRegister({
    name: "TextTrack",
    track: TextTrack,
    config: TextTrack.config
  });
  higlassRegister({
    name: "BrushTrack",
    track: BrushTrack,
    config: BrushTrack.config
  });
  for (const dataFetcher of Object.values(dataFetchers)) {
    const { config: config2 } = dataFetcher;
    higlassRegister({ dataFetcher, config: config2 }, { pluginType: "dataFetcher" });
  }
  once = true;
}
function getBoundingBox(trackInfos) {
  let width = 0;
  let height = 0;
  trackInfos.forEach((_) => {
    const w = _.boundingBox.x + _.boundingBox.width;
    const h = _.boundingBox.y + _.boundingBox.height;
    if (height < h) {
      height = h;
    }
    if (width < w) {
      width = w;
    }
  });
  return { width, height };
}
function getRelativeTrackInfo(spec, theme) {
  var _a, _b;
  let trackInfos = [];
  traverseAndCollectTrackInfo(spec, trackInfos);
  const size = getBoundingBox(trackInfos);
  if (spec.title || spec.subtitle) {
    const titleHeight = (spec.title ? ((_a = theme.root.titleFontSize) != null ? _a : 18) + DEWFAULT_TITLE_PADDING_ON_TOP_AND_BOTTOM : 0) + (spec.subtitle ? ((_b = theme.root.subtitleFontSize) != null ? _b : 14) + DEWFAULT_TITLE_PADDING_ON_TOP_AND_BOTTOM : 0);
    const marginBottom = 4;
    size.height += titleHeight + marginBottom;
    size.height = size.height + (8 - size.height % 8);
    trackInfos.forEach((_) => {
      _.boundingBox.y += titleHeight + marginBottom;
    });
    trackInfos = [
      {
        track: getTextTrack({ width: size.width, height: titleHeight }, spec.title, spec.subtitle),
        boundingBox: { x: 0, y: 0, width: size.width, height: titleHeight },
        layout: { x: 0, y: 0, w: 12, h: titleHeight / size.height * 12 }
      },
      ...trackInfos
    ];
  } else {
    size.height = size.height + (8 - size.height % 8);
  }
  const pixelPreciseMarginPadding = !(typeof spec.responsiveSize !== "object" ? spec.responsiveSize : spec.responsiveSize.height);
  trackInfos.forEach((_) => {
    _.layout.x = _.boundingBox.x / size.width * 12;
    _.layout.w = _.boundingBox.width / size.width * 12;
    _.layout.y = pixelPreciseMarginPadding ? _.boundingBox.y : _.boundingBox.y / size.height * 12;
    _.layout.h = pixelPreciseMarginPadding ? _.boundingBox.height : _.boundingBox.height / size.height * 12;
  });
  return { trackInfos, size };
}
function traverseAndCollectTrackInfo(spec, output, dx = 0, dy = 0, circularRootNotFound = true) {
  let cumWidth = 0;
  let cumHeight = 0;
  let allChildCircularLayout = true;
  let traversedAtLeastOnce = false;
  traverseTracksAndViews(spec, (tv) => {
    traversedAtLeastOnce = true;
    if (tv.layout !== "circular") {
      allChildCircularLayout = false;
    }
  });
  let noChildConcatArrangement = true;
  traverseViewArrangements(spec, (a) => {
    if (a.arrangement === "vertical" || a.arrangement === "horizontal") {
      noChildConcatArrangement = false;
    }
  });
  const isThisCircularRoot = circularRootNotFound && allChildCircularLayout && traversedAtLeastOnce && noChildConcatArrangement && ("views" in spec && (spec.arrangement === "parallel" || spec.arrangement === "serial") || "tracks" in spec);
  const numTracksBeforeInsert = output.length;
  if ("tracks" in spec) {
    const tracks = spec.tracks;
    if (spec.orientation === "vertical") {
      cumHeight = Math.max(...tracks.map((d) => d.height));
      tracks.forEach((track, i, array) => {
        if (getNumOfXAxes([track]) === 1) {
          track.width += HIGLASS_AXIS_SIZE;
        }
        track.height = cumHeight;
        output.push({
          track,
          boundingBox: {
            x: dx + cumWidth,
            y: dy,
            width: track.width,
            height: cumHeight
          },
          layout: { x: 0, y: 0, w: 0, h: 0 }
        });
        if (array[i + 1] && array[i + 1].overlayOnPreviousTrack)
          ;
        else {
          cumWidth += track.width;
          if (i !== array.length - 1) {
            cumWidth += spec.spacing !== void 0 ? spec.spacing : 0;
          }
        }
      });
    } else {
      cumWidth = Math.max(...tracks.map((d) => d.width));
      tracks.forEach((track, i, array) => {
        if (getNumOfXAxes([track]) === 1) {
          track.height += HIGLASS_AXIS_SIZE;
        }
        if (Is2DTrack(resolveSuperposedTracks(track)[0]) && getNumOfYAxes([track]) === 1) {
          cumWidth += HIGLASS_AXIS_SIZE;
        }
        track.width = cumWidth;
        output.push({
          track,
          boundingBox: {
            x: dx,
            y: dy + cumHeight,
            width: cumWidth,
            height: track.height
          },
          layout: { x: 0, y: 0, w: 0, h: 0 }
        });
        if (array[i + 1] && array[i + 1].overlayOnPreviousTrack)
          ;
        else {
          cumHeight += track.height;
          if (i !== array.length - 1) {
            cumHeight += spec.spacing !== void 0 ? spec.spacing : 0;
          }
        }
      });
    }
  } else {
    if (spec.arrangement === "parallel" || spec.arrangement === "vertical") {
      const spacing = spec.spacing !== void 0 ? spec.spacing : DEFAULT_VIEW_SPACING;
      spec.views.forEach((v, i, array) => {
        var _a, _b, _c, _d, _e;
        const viewBB = traverseAndCollectTrackInfo(v, output, dx + ((_a = v.xOffset) != null ? _a : 0), dy + ((_b = v.yOffset) != null ? _b : 0) + cumHeight, !isThisCircularRoot && circularRootNotFound);
        if (cumWidth < ((_c = v.xOffset) != null ? _c : 0) + viewBB.width) {
          cumWidth = ((_d = v.xOffset) != null ? _d : 0) + viewBB.width;
        }
        if (i !== array.length - 1) {
          cumHeight += spacing;
        }
        cumHeight += ((_e = v.yOffset) != null ? _e : 0) + viewBB.height;
      });
    } else if (spec.arrangement === "serial" || spec.arrangement === "horizontal") {
      spec.views.forEach((v, i, array) => {
        var _a, _b, _c, _d, _e;
        const spacing = spec.spacing !== void 0 ? spec.spacing : DEFAULT_VIEW_SPACING;
        const viewBB = traverseAndCollectTrackInfo(v, output, dx + ((_a = v.xOffset) != null ? _a : 0) + cumWidth, dy + ((_b = v.yOffset) != null ? _b : 0), !isThisCircularRoot && circularRootNotFound);
        if (cumHeight < ((_c = v.xOffset) != null ? _c : 0) + viewBB.height) {
          cumHeight = ((_d = v.xOffset) != null ? _d : 0) + viewBB.height;
        }
        if (i !== array.length - 1) {
          cumWidth += spacing;
        }
        cumWidth += ((_e = v.xOffset) != null ? _e : 0) + viewBB.width;
      });
    }
  }
  if (isThisCircularRoot) {
    const cTracks = output.slice(numTracksBeforeInsert);
    const ifMultipleViews = "views" in spec && (spec.arrangement === "parallel" || spec.arrangement === "serial") && spec.views.length > 1;
    const SPACING = spec.spacing !== void 0 ? spec.spacing : DEFAULT_VIEW_SPACING;
    const PADDING = DEFAULT_CIRCULAR_VIEW_PADDING;
    const INNER_RADIUS = spec.centerRadius !== void 0 ? spec.centerRadius : DEFAULT_INNER_RADIUS_PROP;
    const TOTAL_RADIUS = cumWidth / 2 + PADDING;
    const TOTAL_RING_SIZE = TOTAL_RADIUS * (1 - INNER_RADIUS);
    cTracks.forEach((t, i) => {
      var _a, _b;
      t.track.layout = "circular";
      t.track.outerRadius = TOTAL_RADIUS - PADDING - (t.boundingBox.y - dy) / cumHeight * TOTAL_RING_SIZE;
      t.track.innerRadius = TOTAL_RADIUS - PADDING - (t.boundingBox.y + t.boundingBox.height - dy) / cumHeight * TOTAL_RING_SIZE;
      const spacingAngle = SPACING / cumWidth * 360;
      t.track.startAngle = spacingAngle + (t.boundingBox.x - dx) / cumWidth * (cumWidth - SPACING) / cumWidth * 360;
      t.track.endAngle = (t.boundingBox.x + t.boundingBox.width - dx) / cumWidth * (cumWidth - SPACING) / cumWidth * 360;
      t.boundingBox.x = dx + ((_a = t.track.xOffset) != null ? _a : 0);
      t.boundingBox.y = dy + ((_b = t.track.yOffset) != null ? _b : 0);
      t.boundingBox.height = t.track.height = t.boundingBox.width = t.track.width = TOTAL_RADIUS * 2;
      if (i !== 0) {
        t.track.overlayOnPreviousTrack = true;
      }
      if (ifMultipleViews) {
        if (IsOverlaidTrack(t.track)) {
          t.track.overlay = t.track.overlay.filter((o) => o.mark !== "brush");
        }
      }
    });
    cumHeight = TOTAL_RADIUS * 2;
  }
  spec._assignedWidth = cumWidth;
  spec._assignedHeight = cumHeight;
  return { x: dx, y: dy, width: cumWidth, height: cumHeight };
}
function getNumOfXAxes(tracks) {
  return tracks.filter((t) => IsXAxis(t)).length;
}
function getNumOfYAxes(tracks) {
  return tracks.filter((t) => IsYAxis(t)).length;
}
const getTextTrack = (size, title2, subtitle) => {
  return JSON.parse(JSON.stringify({
    mark: "header",
    width: size.width,
    height: size.height,
    title: title2,
    subtitle
  }));
};
function parseServerAndTilesetUidFromUrl(url) {
  if (!url.includes("tileset_info/?d=") || !url.includes("https:") && !url.includes("http:")) {
    return { server: void 0, tilesetUid: void 0 };
  }
  const server = url.split("tileset_info/?d=")[0];
  const tilesetUid = url.split("tileset_info/?d=")[1];
  return { server, tilesetUid };
}
function goslingToHiGlass(hgModel, gosTrack, bb, layout, theme) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  const firstResolvedSpec = resolveSuperposedTracks(gosTrack)[0];
  if (!firstResolvedSpec.id) {
    firstResolvedSpec.id = v4();
  }
  const assembly = firstResolvedSpec.assembly;
  if (IsDataDeep(firstResolvedSpec.data)) {
    let server, tilesetUid;
    if (IsDataDeepTileset(firstResolvedSpec.data)) {
      const parsed = parseServerAndTilesetUidFromUrl(firstResolvedSpec.data.url);
      server = parsed.server;
      tilesetUid = parsed.tilesetUid;
    }
    const genomicChannel = getGenomicChannelFromTrack(firstResolvedSpec);
    const genomicChannelKey = getGenomicChannelKeyFromTrack(firstResolvedSpec);
    const isXGenomic = genomicChannelKey === "x" || genomicChannelKey === "xe";
    const xDomain = isXGenomic && IsChannelDeep(genomicChannel) ? genomicChannel.domain : void 0;
    const yDomain = Is2DTrack(firstResolvedSpec) && IsChannelDeep(firstResolvedSpec.y) ? firstResolvedSpec.y.domain : void 0;
    const width = bb.width - (firstResolvedSpec.layout !== "circular" && firstResolvedSpec.orientation === "vertical" && IsXAxis(firstResolvedSpec) ? HIGLASS_AXIS_SIZE : 0);
    const height = bb.height - (firstResolvedSpec.layout !== "circular" && firstResolvedSpec.orientation === "horizontal" && IsXAxis(firstResolvedSpec) ? HIGLASS_AXIS_SIZE : 0);
    const hgTrack = {
      uid: `${firstResolvedSpec.id}-track`,
      type: Is2DTrack(firstResolvedSpec) ? "gosling-2d-track" : "gosling-track",
      server,
      tilesetUid,
      width,
      height,
      options: {
        showMousePosition: firstResolvedSpec.layout === "circular" ? false : theme.root.showMousePosition,
        mousePositionColor: theme.root.mousePositionColor,
        name: firstResolvedSpec.layout === "linear" ? firstResolvedSpec.title : " ",
        labelPosition: firstResolvedSpec.title ? theme.track.titleAlign === "left" ? "topLeft" : "topRight" : "none",
        labelShowResolution: false,
        labelColor: theme.track.titleColor,
        labelBackgroundColor: theme.track.titleBackground,
        labelBackgroundOpacity: 0.5,
        labelTextOpacity: 1,
        labelLeftMargin: 1,
        labelTopMargin: 1,
        labelRightMargin: 0,
        labelBottomMargin: 0,
        backgroundColor: "transparent",
        spec: { ...gosTrack },
        theme
      }
    };
    if (firstResolvedSpec.data && IsDataDeep(firstResolvedSpec.data) && (firstResolvedSpec.data.type === "csv" || firstResolvedSpec.data.type === "json" || firstResolvedSpec.data.type === "bigwig" || firstResolvedSpec.data.type === "bam" || firstResolvedSpec.data.type === "vcf")) {
      const getFieldName = (c) => {
        const cDef = firstResolvedSpec[c];
        return cDef && IsChannelDeep(cDef) ? cDef.field : void 0;
      };
      const xFields = {
        x: getFieldName("x"),
        xe: getFieldName("xe"),
        x1: getFieldName("x1"),
        x1e: getFieldName("x1e")
      };
      hgTrack.data = {
        ...firstResolvedSpec.data,
        ...xFields,
        assembly
      };
    }
    if (IsHiGlassMatrix(firstResolvedSpec)) {
      hgTrack.type = "heatmap";
      const colorStr = IsChannelDeep(firstResolvedSpec.color) && typeof firstResolvedSpec.color.range === "string" ? firstResolvedSpec.color.range : "viridis";
      hgTrack.options.colorRange = getHiGlassColorRange(colorStr);
      hgTrack.options.trackBorderWidth = (_b = (_a = firstResolvedSpec.style) == null ? void 0 : _a.outlineWidth) != null ? _b : theme.track.outlineWidth;
      hgTrack.options.trackBorderColor = (_d = (_c = firstResolvedSpec.style) == null ? void 0 : _c.outline) != null ? _d : theme.track.outline;
      hgTrack.options.extent = (_f = (_e = firstResolvedSpec.style) == null ? void 0 : _e.matrixExtent) != null ? _f : "full";
      hgTrack.options.colorbarPosition = ((_g = firstResolvedSpec.color) == null ? void 0 : _g.legend) ? hgTrack.options.extent === "lower-left" ? "bottomLeft" : "topRight" : "hidden";
    }
    if (firstResolvedSpec.overlayOnPreviousTrack) {
      hgModel.setViewOrientation(firstResolvedSpec.orientation).addTrackToCombined(hgTrack);
    } else {
      hgModel.setViewOrientation(firstResolvedSpec.orientation).setAssembly(assembly).addDefaultView(firstResolvedSpec.id, assembly).setDomain(xDomain, yDomain != null ? yDomain : xDomain).adjustDomain(firstResolvedSpec.orientation, width, height).setMainTrack(hgTrack).addTrackSourceServers(server).setZoomFixed(firstResolvedSpec.static === true).setZoomLimits((_h = firstResolvedSpec.zoomLimits) != null ? _h : [1, null]).setLayout(layout);
    }
    const getAxisNarrowType = (c, orientation = "horizontal", width2, height2) => {
      const narrowSizeThreshold = 400;
      const narrowerSizeThreshold = 200;
      if (orientation === "horizontal") {
        if (c === "x" && width2 <= narrowerSizeThreshold || c === "y" && height2 <= narrowerSizeThreshold) {
          return "narrower";
        } else if (c === "x" && width2 <= narrowSizeThreshold || c === "y" && height2 <= narrowSizeThreshold) {
          return "narrow";
        } else {
          return "regular";
        }
      } else {
        if (c === "x" && height2 <= narrowerSizeThreshold || c === "y" && width2 <= narrowerSizeThreshold) {
          return "narrower";
        } else if (c === "x" && height2 <= narrowSizeThreshold || c === "y" && width2 <= narrowSizeThreshold) {
          return "narrow";
        } else {
          return "regular";
        }
      }
    };
    ["x", "y"].forEach((c) => {
      const channel = firstResolvedSpec[c];
      if (IsChannelDeep(channel) && "axis" in channel && channel.axis && channel.axis !== "none" && channel.type === "genomic") {
        const narrowType = getAxisNarrowType(c, gosTrack.orientation, bb.width, bb.height);
        hgModel.setAxisTrack(channel.axis, narrowType, {
          id: `${firstResolvedSpec.id}-${channel.axis}-axis`,
          layout: firstResolvedSpec.layout,
          innerRadius: channel.axis === "top" ? firstResolvedSpec.outerRadius - HIGLASS_AXIS_SIZE : firstResolvedSpec.innerRadius,
          outerRadius: channel.axis === "top" ? firstResolvedSpec.outerRadius : firstResolvedSpec.innerRadius + HIGLASS_AXIS_SIZE,
          width: firstResolvedSpec.width,
          height: firstResolvedSpec.height,
          startAngle: firstResolvedSpec.startAngle,
          endAngle: firstResolvedSpec.endAngle,
          theme
        });
      }
    });
    hgModel.validateSpec(true);
  } else if (firstResolvedSpec.mark === "header") {
    hgModel.addDefaultView(`${firstResolvedSpec.id}-title`).setLayout(layout);
    if (typeof firstResolvedSpec.title === "string") {
      hgModel.setTextTrack(bb.width, ((_i = theme.root.titleFontSize) != null ? _i : 18) + DEWFAULT_TITLE_PADDING_ON_TOP_AND_BOTTOM, firstResolvedSpec.title, theme.root.titleColor, (_j = theme.root.titleFontSize) != null ? _j : 18, theme.root.titleFontWeight, theme.root.titleAlign, theme.root.titleBackgroundColor, (_k = theme.root.titleFontFamily) != null ? _k : DEFAULT_TEXT_STYLE.fontFamily);
    }
    if (typeof firstResolvedSpec.subtitle === "string") {
      hgModel.setTextTrack(bb.width, ((_l = theme.root.subtitleFontSize) != null ? _l : 14) + DEWFAULT_TITLE_PADDING_ON_TOP_AND_BOTTOM, firstResolvedSpec.subtitle, theme.root.subtitleColor, (_m = theme.root.subtitleFontSize) != null ? _m : 14, theme.root.subtitleFontWeight, theme.root.subtitleAlign, theme.root.subtitleBackgroundColor, (_n = theme.root.subtitleFontFamily) != null ? _n : DEFAULT_TEXT_STYLE.fontFamily);
    }
  }
  return hgModel;
}
function getLinkingInfo(hgModel) {
  const linkingInfo = [];
  hgModel.spec().views.forEach((v) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
    const viewId = v.uid;
    let spec = (_e = (_d = (_c = (_b = (_a = v.tracks.center) == null ? void 0 : _a[0]) == null ? void 0 : _b.contents) == null ? void 0 : _c[0]) == null ? void 0 : _d.options) == null ? void 0 : _e.spec;
    if (!spec) {
      spec = (_j = (_i = (_h = (_g = (_f = v.tracks.left) == null ? void 0 : _f[0]) == null ? void 0 : _g.contents) == null ? void 0 : _h[0]) == null ? void 0 : _i.options) == null ? void 0 : _j.spec;
      if (!spec) {
        spec = (_o = (_n = (_m = (_l = (_k = v.tracks.left) == null ? void 0 : _k[1]) == null ? void 0 : _l.contents) == null ? void 0 : _m[0]) == null ? void 0 : _n.options) == null ? void 0 : _o.spec;
      }
    }
    if (!viewId || !spec)
      return;
    const resolved = resolveSuperposedTracks(spec);
    resolved.forEach((spec2) => {
      SUPPORTED_CHANNELS.forEach((cKey) => {
        var _a2, _b2, _c2, _d2;
        const channel = spec2[cKey];
        if (IsChannelDeep(channel) && "linkingId" in channel && channel.linkingId) {
          linkingInfo.push({
            layout: spec2.layout === "circular" ? "circular" : "linear",
            viewId,
            linkId: channel.linkingId,
            isBrush: spec2.mark === "brush",
            style: {
              color: (_a2 = spec2.color) == null ? void 0 : _a2.value,
              stroke: (_b2 = spec2.stroke) == null ? void 0 : _b2.value,
              strokeWidth: (_c2 = spec2.strokeWidth) == null ? void 0 : _c2.value,
              opacity: (_d2 = spec2.opacity) == null ? void 0 : _d2.value,
              startAngle: spec2.startAngle,
              endAngle: spec2.endAngle,
              innerRadius: spec2.innerRadius,
              outerRadius: spec2.outerRadius
            }
          });
          return;
        }
      });
    });
  });
  return linkingInfo;
}
function renderHiGlass(spec, trackInfos, callback, theme) {
  if (trackInfos.length === 0) {
    return;
  }
  const hgModel = new HiGlassModel();
  trackInfos.forEach((tb) => {
    const { track, boundingBox: bb, layout } = tb;
    goslingToHiGlass(hgModel, track, bb, layout, theme);
  });
  const linkingInfos = getLinkingInfo(hgModel);
  linkingInfos.filter((d) => d.isBrush).forEach((info) => {
    var _a;
    hgModel.addBrush(info.layout, info.viewId, theme, (_a = linkingInfos.find((d) => !d.isBrush && d.linkId === info.linkId)) == null ? void 0 : _a.viewId, info.style);
  });
  linkingInfos.filter((d) => !d.isBrush).forEach((d) => {
    hgModel.spec().zoomLocks.locksByViewUid[d.viewId] = d.linkId;
    hgModel.spec().locationLocks.locksByViewUid[d.viewId] = d.linkId;
  });
  const uniqueLinkIds = Array.from(new Set(linkingInfos.map((d) => d.linkId)));
  uniqueLinkIds.forEach((linkId) => {
    hgModel.spec().zoomLocks.locksDict[linkId] = { uid: linkId };
    hgModel.spec().locationLocks.locksDict[linkId] = { uid: linkId };
    linkingInfos.filter((d) => !d.isBrush).filter((d) => d.linkId === linkId).forEach((d) => {
      hgModel.spec().zoomLocks.locksDict[linkId][d.viewId] = [1246253105e-1, 1246253105e-1, 249250.621];
      hgModel.spec().locationLocks.locksDict[linkId][d.viewId] = [1246253105e-1, 1246253105e-1, 249250.621];
    });
  });
  const trackInfosWithShapes = trackInfos.map((d) => {
    return {
      id: d.track.id,
      spec: d.track,
      shape: d.track.layout === "linear" ? d.boundingBox : {
        cx: d.boundingBox.x + d.boundingBox.width / 2,
        cy: d.boundingBox.y + d.boundingBox.height / 2,
        innerRadius: d.track.innerRadius,
        outerRadius: d.track.outerRadius,
        startAngle: d.track.startAngle,
        endAngle: d.track.endAngle
      }
    };
  });
  callback(hgModel.spec(), getBoundingBox(trackInfos), spec, trackInfosWithShapes);
}
function manageResponsiveSpecs(spec, wFactor, hFactor, parentWidth, parentHeight) {
  if (typeof spec._assignedWidth === "undefined" || typeof spec._assignedHeight === "undefined") {
    console.warn("Responsive spec cannot be used when width and height of a view is not determined yet.");
    return false;
  }
  let replaced = false;
  const { responsiveSpec } = spec;
  const width = spec._assignedWidth * wFactor;
  const height = spec._assignedHeight * hFactor;
  const dimensions = { width, height, aspectRatio: width / height };
  const parentDimensions = { width: parentWidth, height: parentHeight, aspectRatio: parentWidth / parentHeight };
  if (responsiveSpec) {
    responsiveSpec.forEach((specAndCondition) => {
      const { spec: alternativeSpec, selectivity } = specAndCondition;
      if (isSelectResponsiveSpec(selectivity, dimensions, parentDimensions) && !replaced) {
        Object.keys(alternativeSpec).forEach((k) => {
          spec[k] = alternativeSpec[k];
        });
        delete spec.responsiveSpec;
        replaced = true;
        return;
      }
    });
  }
  if ("views" in spec) {
    spec.views.forEach((view) => {
      replaced = manageResponsiveSpecs(view, wFactor, hFactor, parentWidth, parentHeight) || replaced;
    });
  }
  return replaced;
}
function isSelectResponsiveSpec(conditions, assignedDimensions, parentDimensions) {
  if (conditions.length === 0)
    return false;
  let isSelect = true;
  conditions.forEach((condition) => {
    const { measure, operation, threshold, target } = condition;
    isSelect = isSelect && logicalComparison((target === "container" ? parentDimensions : assignedDimensions)[measure], operation, threshold) === 1;
  });
  return isSelect;
}
function compile(spec, callback, templates, theme, containerStatus) {
  var _a, _b;
  const specCopy = JSON.parse(JSON.stringify(spec));
  overrideDataTemplates(specCopy);
  replaceTrackTemplates(specCopy, templates);
  traverseToFixSpecDownstream(specCopy);
  const trackInfosAndSize = getRelativeTrackInfo(specCopy, theme);
  let { trackInfos } = trackInfosAndSize;
  const { size } = trackInfosAndSize;
  const isResponsiveWidth = typeof spec.responsiveSize === "object" && ((_a = spec.responsiveSize) == null ? void 0 : _a.width) || spec.responsiveSize;
  const isResponsiveHeight = typeof spec.responsiveSize === "object" && ((_b = spec.responsiveSize) == null ? void 0 : _b.height) || spec.responsiveSize;
  const wFactor = isResponsiveWidth && containerStatus.containerSize ? containerStatus.containerSize.width / size.width : 1;
  const hFactor = isResponsiveHeight && containerStatus.containerSize ? containerStatus.containerSize.height / size.height : 1;
  const pWidth = containerStatus.containerParentSize ? containerStatus.containerParentSize.width : Number.MAX_SAFE_INTEGER;
  const pHeight = containerStatus.containerParentSize ? containerStatus.containerParentSize.height : Number.MAX_SAFE_INTEGER;
  const replaced = manageResponsiveSpecs(specCopy, wFactor, hFactor, pWidth, pHeight);
  if (replaced) {
    traverseToFixSpecDownstream(specCopy);
    trackInfos = getRelativeTrackInfo(specCopy, theme).trackInfos;
  }
  renderHiGlass(specCopy, trackInfos, callback, theme);
}
init();
const HiGlassComponentWrapper = forwardRef((props, ref2) => {
  var _a;
  const [wrapperDivId, setWrapperDivId] = useState((_a = props.id) != null ? _a : v4());
  useEffect(() => {
    var _a2;
    setWrapperDivId((_a2 = props.id) != null ? _a2 : v4());
  }, [props.id]);
  const viewConfig = props.viewConfig || {};
  const pixelPreciseMarginPadding = false;
  const higlassComponent = useMemo(() => /* @__PURE__ */ React.createElement(HiGlassComponent, {
    ref: ref2,
    options: {
      pixelPreciseMarginPadding,
      containerPaddingX: 0,
      containerPaddingY: 0,
      viewMarginTop: 0,
      viewMarginBottom: 0,
      viewMarginLeft: 0,
      viewMarginRight: 0,
      viewPaddingTop: 0,
      viewPaddingBottom: 0,
      viewPaddingLeft: 0,
      viewPaddingRight: 0,
      sizeMode: "bounded",
      rangeSelectionOnAlt: true
    },
    viewConfig
  }), [viewConfig, pixelPreciseMarginPadding]);
  const {
    padding = 60,
    margin = 0,
    border = "none",
    background,
    alt = "Gosling visualization"
  } = props.options || {};
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
    id: wrapperDivId,
    className: `gosling-component ${props.className || ""}`,
    style: {
      position: "relative",
      padding,
      margin,
      border,
      background,
      width: props.options.responsiveWidth ? `calc(100% - ${padding * 2}px)` : props.size.width,
      height: props.options.responsiveHeight ? `calc(100% - ${padding * 2}px)` : props.size.height,
      textAlign: "left"
    },
    "aria-label": alt,
    role: "graphics-document",
    "aria-roledescription": "visualization"
  }, /* @__PURE__ */ React.createElement("div", {
    key: JSON.stringify(viewConfig),
    id: "higlass-wrapper",
    className: "higlass-wrapper",
    style: {
      position: "relative",
      display: "block",
      background,
      margin: 0,
      padding: 0,
      width: props.options.responsiveWidth ? "100%" : props.size.width,
      height: props.options.responsiveHeight ? "100%" : props.size.height
    }
  }, higlassComponent)));
});
HiGlassComponentWrapper.displayName = "HiGlassComponentWrapper";
var ResizeSensor$1 = { exports: {} };
(function(module, exports) {
  (function(root, factory2) {
    {
      module.exports = factory2();
    }
  })(typeof window !== "undefined" ? window : commonjsGlobal, function() {
    if (typeof window === "undefined") {
      return null;
    }
    var globalWindow = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
    var requestAnimationFrame2 = globalWindow.requestAnimationFrame || globalWindow.mozRequestAnimationFrame || globalWindow.webkitRequestAnimationFrame || function(fn) {
      return globalWindow.setTimeout(fn, 20);
    };
    var cancelAnimationFrame2 = globalWindow.cancelAnimationFrame || globalWindow.mozCancelAnimationFrame || globalWindow.webkitCancelAnimationFrame || function(timer2) {
      globalWindow.clearTimeout(timer2);
    };
    function forEachElement(elements, callback) {
      var elementsType = Object.prototype.toString.call(elements);
      var isCollectionTyped = elementsType === "[object Array]" || elementsType === "[object NodeList]" || elementsType === "[object HTMLCollection]" || elementsType === "[object Object]" || typeof jQuery !== "undefined" && elements instanceof jQuery || typeof Elements !== "undefined" && elements instanceof Elements;
      var i = 0, j = elements.length;
      if (isCollectionTyped) {
        for (; i < j; i++) {
          callback(elements[i]);
        }
      } else {
        callback(elements);
      }
    }
    function getElementSize(element) {
      if (!element.getBoundingClientRect) {
        return {
          width: element.offsetWidth,
          height: element.offsetHeight
        };
      }
      var rect = element.getBoundingClientRect();
      return {
        width: Math.round(rect.width),
        height: Math.round(rect.height)
      };
    }
    function setStyle(element, style) {
      Object.keys(style).forEach(function(key) {
        element.style[key] = style[key];
      });
    }
    var ResizeSensor2 = function(element, callback) {
      var lastAnimationFrameForInvisibleCheck = 0;
      function EventQueue() {
        var q = [];
        this.add = function(ev) {
          q.push(ev);
        };
        var i, j;
        this.call = function(sizeInfo) {
          for (i = 0, j = q.length; i < j; i++) {
            q[i].call(this, sizeInfo);
          }
        };
        this.remove = function(ev) {
          var newQueue = [];
          for (i = 0, j = q.length; i < j; i++) {
            if (q[i] !== ev)
              newQueue.push(q[i]);
          }
          q = newQueue;
        };
        this.length = function() {
          return q.length;
        };
      }
      function attachResizeEvent(element2, resized) {
        if (!element2)
          return;
        if (element2.resizedAttached) {
          element2.resizedAttached.add(resized);
          return;
        }
        element2.resizedAttached = new EventQueue();
        element2.resizedAttached.add(resized);
        element2.resizeSensor = document.createElement("div");
        element2.resizeSensor.dir = "ltr";
        element2.resizeSensor.className = "resize-sensor";
        var style = {
          pointerEvents: "none",
          position: "absolute",
          left: "0px",
          top: "0px",
          right: "0px",
          bottom: "0px",
          overflow: "hidden",
          zIndex: "-1",
          visibility: "hidden",
          maxWidth: "100%"
        };
        var styleChild = {
          position: "absolute",
          left: "0px",
          top: "0px",
          transition: "0s"
        };
        setStyle(element2.resizeSensor, style);
        var expand2 = document.createElement("div");
        expand2.className = "resize-sensor-expand";
        setStyle(expand2, style);
        var expandChild = document.createElement("div");
        setStyle(expandChild, styleChild);
        expand2.appendChild(expandChild);
        var shrink = document.createElement("div");
        shrink.className = "resize-sensor-shrink";
        setStyle(shrink, style);
        var shrinkChild = document.createElement("div");
        setStyle(shrinkChild, styleChild);
        setStyle(shrinkChild, { width: "200%", height: "200%" });
        shrink.appendChild(shrinkChild);
        element2.resizeSensor.appendChild(expand2);
        element2.resizeSensor.appendChild(shrink);
        element2.appendChild(element2.resizeSensor);
        var computedStyle = window.getComputedStyle(element2);
        var position = computedStyle ? computedStyle.getPropertyValue("position") : null;
        if (position !== "absolute" && position !== "relative" && position !== "fixed" && position !== "sticky") {
          element2.style.position = "relative";
        }
        var dirty = false;
        var rafId = 0;
        var size = getElementSize(element2);
        var lastWidth = 0;
        var lastHeight = 0;
        var initialHiddenCheck = true;
        lastAnimationFrameForInvisibleCheck = 0;
        var resetExpandShrink = function() {
          var width = element2.offsetWidth;
          var height = element2.offsetHeight;
          expandChild.style.width = width + 10 + "px";
          expandChild.style.height = height + 10 + "px";
          expand2.scrollLeft = width + 10;
          expand2.scrollTop = height + 10;
          shrink.scrollLeft = width + 10;
          shrink.scrollTop = height + 10;
        };
        var reset = function() {
          if (initialHiddenCheck) {
            var invisible = element2.offsetWidth === 0 && element2.offsetHeight === 0;
            if (invisible) {
              if (!lastAnimationFrameForInvisibleCheck) {
                lastAnimationFrameForInvisibleCheck = requestAnimationFrame2(function() {
                  lastAnimationFrameForInvisibleCheck = 0;
                  reset();
                });
              }
              return;
            } else {
              initialHiddenCheck = false;
            }
          }
          resetExpandShrink();
        };
        element2.resizeSensor.resetSensor = reset;
        var onResized = function() {
          rafId = 0;
          if (!dirty)
            return;
          lastWidth = size.width;
          lastHeight = size.height;
          if (element2.resizedAttached) {
            element2.resizedAttached.call(size);
          }
        };
        var onScroll = function() {
          size = getElementSize(element2);
          dirty = size.width !== lastWidth || size.height !== lastHeight;
          if (dirty && !rafId) {
            rafId = requestAnimationFrame2(onResized);
          }
          reset();
        };
        var addEvent = function(el, name2, cb) {
          if (el.attachEvent) {
            el.attachEvent("on" + name2, cb);
          } else {
            el.addEventListener(name2, cb);
          }
        };
        addEvent(expand2, "scroll", onScroll);
        addEvent(shrink, "scroll", onScroll);
        lastAnimationFrameForInvisibleCheck = requestAnimationFrame2(function() {
          lastAnimationFrameForInvisibleCheck = 0;
          reset();
        });
      }
      forEachElement(element, function(elem) {
        attachResizeEvent(elem, callback);
      });
      this.detach = function(ev) {
        if (!lastAnimationFrameForInvisibleCheck) {
          cancelAnimationFrame2(lastAnimationFrameForInvisibleCheck);
          lastAnimationFrameForInvisibleCheck = 0;
        }
        ResizeSensor2.detach(element, ev);
      };
      this.reset = function() {
        element.resizeSensor.resetSensor();
      };
    };
    ResizeSensor2.reset = function(element) {
      forEachElement(element, function(elem) {
        elem.resizeSensor.resetSensor();
      });
    };
    ResizeSensor2.detach = function(element, ev) {
      forEachElement(element, function(elem) {
        if (!elem)
          return;
        if (elem.resizedAttached && typeof ev === "function") {
          elem.resizedAttached.remove(ev);
          if (elem.resizedAttached.length())
            return;
        }
        if (elem.resizeSensor) {
          if (elem.contains(elem.resizeSensor)) {
            elem.removeChild(elem.resizeSensor);
          }
          delete elem.resizeSensor;
          delete elem.resizedAttached;
        }
      });
    };
    if (typeof MutationObserver !== "undefined") {
      var observer = new MutationObserver(function(mutations) {
        for (var i in mutations) {
          if (mutations.hasOwnProperty(i)) {
            var items2 = mutations[i].addedNodes;
            for (var j = 0; j < items2.length; j++) {
              if (items2[j].resizeSensor) {
                ResizeSensor2.reset(items2[j]);
              }
            }
          }
        }
      });
      document.addEventListener("DOMContentLoaded", function(event) {
        observer.observe(document.body, {
          childList: true,
          subtree: true
        });
      });
    }
    return ResizeSensor2;
  });
})(ResizeSensor$1);
var ResizeSensor = ResizeSensor$1.exports;
function traverseViewsInViewConfig(viewConf, callback) {
  if (viewConf && viewConf.views && Array.isArray(viewConf.views)) {
    viewConf.views.forEach((view) => {
      if (view && view.uid) {
        callback(view);
      }
    });
  }
}
function createApi(hg, hgSpec, trackInfos, theme) {
  const getTracks = () => {
    return [...trackInfos];
  };
  const getTrack = (trackId) => {
    const trackInfoFound = trackInfos.find((d) => d.id === trackId);
    if (!trackInfoFound) {
      console.warn(`[getTrack()] Unable to find a track using the ID (${trackId})`);
    }
    return trackInfoFound;
  };
  const getCanvas = (options) => {
    var _a, _b;
    const resolution = (_a = options == null ? void 0 : options.resolution) != null ? _a : 4;
    const transparentBackground = (_b = options == null ? void 0 : options.transparentBackground) != null ? _b : false;
    const renderer = hg.pixiRenderer;
    const renderTexture = PIXI.RenderTexture.create({
      width: renderer.width / 2,
      height: renderer.height / 2,
      resolution
    });
    renderer.render(hg.pixiStage, renderTexture);
    const canvas = renderer.plugins.extract.canvas(renderTexture);
    const canvasWithBg = document.createElement("canvas");
    canvasWithBg.width = canvas.width;
    canvasWithBg.height = canvas.height;
    const ctx = canvasWithBg.getContext("2d");
    if (!transparentBackground) {
      ctx.fillStyle = theme.root.background;
      ctx.fillRect(0, 0, canvasWithBg.width, canvasWithBg.height);
    }
    ctx.drawImage(canvas, 0, 0);
    return {
      canvas: canvasWithBg,
      resolution,
      canvasWidth: canvas.width,
      canvasHeight: canvas.height
    };
  };
  return {
    subscribe,
    unsubscribe,
    zoomTo: (viewId, position, padding = 0, duration = 1e3) => {
      var _a;
      const assembly = (_a = getTrack(viewId)) == null ? void 0 : _a.spec.assembly;
      const manager = GenomicPositionHelper.fromString(position);
      const absCoordinates = manager.toAbsoluteCoordinates(assembly, padding);
      hg.api.zoomTo(viewId, ...absCoordinates, ...absCoordinates, duration);
    },
    zoomToExtent: (viewId, duration = 1e3) => {
      var _a;
      const assembly = (_a = getTrack(viewId)) == null ? void 0 : _a.spec.assembly;
      const [start, end] = [0, computeChromSizes(assembly).total];
      hg.api.zoomTo(viewId, start, end, start, end, duration);
    },
    zoomToGene: (viewId, gene, padding = 0, duration = 1e3) => {
      hg.api.zoomToGene(viewId, gene, padding, duration);
    },
    suggestGene: (viewId, keyword2, callback) => {
      hg.api.suggestGene(viewId, keyword2, callback);
    },
    getViewIds: () => {
      if (!hgSpec)
        return [];
      const ids = [];
      traverseViewsInViewConfig(hgSpec, (view) => {
        if (view.uid)
          ids.push(view.uid);
      });
      return ids;
    },
    getTracks,
    getTrack,
    getCanvas,
    exportPng: (transparentBackground) => {
      const { canvas } = getCanvas({ resolution: 4, transparentBackground });
      canvas.toBlob((blob2) => {
        const a = document.createElement("a");
        document.body.append(a);
        a.download = "gosling-visualization";
        a.href = URL.createObjectURL(blob2);
        a.click();
        a.remove();
      }, "image/png");
    },
    exportPdf: async (transparentBackground) => {
      const { jsPDF } = await import("jspdf");
      const { canvas } = getCanvas({ resolution: 4, transparentBackground });
      const imgData = canvas.toDataURL("image/jpeg", 1);
      const pdf = new jsPDF({
        orientation: canvas.width < canvas.height ? "p" : "l",
        unit: "pt",
        format: [canvas.width, canvas.height]
      });
      pdf.addImage(imgData, "JPEG", 0, 0, canvas.width, canvas.height);
      pdf.save("gosling-visualization.pdf");
    }
  };
}
var lodash = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function(module, exports) {
  (function() {
    var undefined$1;
    var VERSION = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index = -1, length = array.length;
      while (++index < length) {
        var current = iteratee(array[index]);
        if (current !== undefined$1) {
          result = result === undefined$1 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache2, key) {
      return cache2.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1, length = strSymbols.length;
      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;
      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object, key) {
      return object == null ? undefined$1 : object[key];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator2) {
      var data2, result = [];
      while (!(data2 = iterator2.next()).done) {
        result.push(data2.value);
      }
      return result;
    }
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index = -1, length = array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }
      return result;
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    function setToPairs(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index = fromIndex + 1;
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return index;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context2) {
      context2 = context2 == null ? root : _.defaults(root.Object(), context2, _.pick(root, contextProps));
      var Array2 = context2.Array, Date2 = context2.Date, Error2 = context2.Error, Function2 = context2.Function, Math2 = context2.Math, Object2 = context2.Object, RegExp2 = context2.RegExp, String2 = context2.String, TypeError2 = context2.TypeError;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context2["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root._;
      var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer2 = moduleExports ? context2.Buffer : undefined$1, Symbol2 = context2.Symbol, Uint8Array2 = context2.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
      var defineProperty2 = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var ctxClearTimeout = context2.clearTimeout !== root.clearTimeout && context2.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context2.setTimeout !== root.setTimeout && context2.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context2.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context2.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView = getNative(context2, "DataView"), Map2 = getNative(context2, "Map"), Promise2 = getNative(context2, "Promise"), Set2 = getNative(context2, "Set"), WeakMap = getNative(context2, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap && new WeakMap();
      var realNames = {};
      var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
      function lodash2(value) {
        if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject2(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result2 = new object();
          object.prototype = undefined$1;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$1;
      }
      lodash2.templateSettings = {
        "escape": reEscape,
        "evaluate": reEvaluate,
        "interpolate": reInterpolate,
        "variable": "",
        "imports": {
          "_": lodash2
        }
      };
      lodash2.prototype = baseLodash.prototype;
      lodash2.prototype.constructor = lodash2;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1, value = array[index];
            while (++iterIndex < iterLength) {
              var data2 = iteratees[iterIndex], iteratee2 = data2.iteratee, type2 = data2.type, computed = iteratee2(value);
              if (type2 == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type2 == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data2 = this.__data__;
        if (nativeCreate) {
          var result2 = data2[key];
          return result2 === HASH_UNDEFINED ? undefined$1 : result2;
        }
        return hasOwnProperty.call(data2, key) ? data2[key] : undefined$1;
      }
      function hashHas(key) {
        var data2 = this.__data__;
        return nativeCreate ? data2[key] !== undefined$1 : hasOwnProperty.call(data2, key);
      }
      function hashSet(key, value) {
        var data2 = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data2[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data2 = this.__data__, index = assocIndexOf(data2, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data2.length - 1;
        if (index == lastIndex) {
          data2.pop();
        } else {
          splice.call(data2, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data2 = this.__data__, index = assocIndexOf(data2, key);
        return index < 0 ? undefined$1 : data2[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data2 = this.__data__, index = assocIndexOf(data2, key);
        if (index < 0) {
          ++this.size;
          data2.push([key, value]);
        } else {
          data2[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data2 = getMapData(this, key), size2 = data2.size;
        data2.set(key, value);
        this.size += data2.size == size2 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values2[index]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data2 = this.__data__ = new ListCache(entries);
        this.size = data2.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data2 = this.__data__, result2 = data2["delete"](key);
        this.size = data2.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data2 = this.__data__;
        if (data2 instanceof ListCache) {
          var pairs2 = data2.__data__;
          if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
            pairs2.push([key, value]);
            this.size = ++data2.size;
            return this;
          }
          data2 = this.__data__ = new MapCache(pairs2);
        }
        data2.set(key, value);
        this.size = data2.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined$1;
      }
      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key, value) {
        if (value !== undefined$1 && !eq(object[key], value) || value === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty2) {
          defineProperty2(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index = -1, length = paths.length, result2 = Array2(length), skip2 = object == null;
        while (++index < length) {
          result2[index] = skip2 ? undefined$1 : get(object, paths[index]);
        }
        return result2;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined$1) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined$1) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result2 !== undefined$1) {
          return result2;
        }
        if (!isObject2(value)) {
          return value;
        }
        var isArr = isArray2(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? undefined$1 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source[key], value = object[key];
          if (value === undefined$1 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined$1, args);
        }, wait);
      }
      function baseDifference(array, values2, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index, collection2) {
          result2 = !!predicate(value, index, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator) {
        var index = -1, length = array.length;
        while (++index < length) {
          var value = array[index], current = iteratee2(value);
          if (current != null && (computed === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed))) {
            var computed = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array, value, start, end) {
        var length = array.length;
        start = toInteger(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined$1 || end > length ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array[start++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index, collection2) {
          if (predicate(value, index, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction2(object[key]);
        });
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : undefined$1;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined$1 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number, start, end) {
        return number >= nativeMin(start, end) && number < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
        }
        array = arrays[0];
        var index = -1, seen = caches[0];
        outer:
          while (++index < length && result2.length < maxLength) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache2 = caches[othIndex];
                if (!(cache2 ? cacheHas(cache2, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey(last2(path))];
        return func == null ? undefined$1 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index--) {
          var data2 = matchData[index];
          if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data2 = matchData[index];
          var key = data2[0], objValue = object[key], srcValue = data2[1];
          if (noCustomizer && data2[2]) {
            if (objValue === undefined$1 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern2 = isFunction2(value) ? reIsNative : reIsHostCtor;
        return pattern2.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity2;
        }
        if (typeof value == "object") {
          return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject2(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index = -1, result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result2[++index] = iteratee2(value, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject2(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined$1;
            if (newValue === undefined$1) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined$1;
        var isCommon = newValue === undefined$1;
        if (isCommon) {
          var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray2(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject2(objValue) || isFunction2(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array, n) {
        var length = array.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex(n, length) ? array[n] : undefined$1;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray2(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity2];
        }
        var index = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { "criteria": criteria, "index": ++index, "value": value };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index = -1, length = paths.length, result2 = {};
        while (++index < length) {
          var path = paths[index], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result2, castPath(path, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function basePullAll(array, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
        if (array === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index < length) {
          var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index = indexes[length];
          if (length == lastIndex || index !== previous) {
            var previous = index;
            if (isIndex(index)) {
              splice.call(array, index, 1);
            } else {
              baseUnset(array, index);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index] = start;
          start += step;
        }
        return result2;
      }
      function baseRepeat(string, n) {
        var result2 = "";
        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n % 2) {
            result2 += string;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string += string;
          }
        } while (n);
        return result2;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity2), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n, 0, array.length));
      }
      function baseSet(object, path, value, customizer) {
        if (!isObject2(object)) {
          return object;
        }
        path = castPath(path, object);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
            if (newValue === undefined$1) {
              newValue = isObject2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity2 : function(func, data2) {
        metaMap.set(func, data2);
        return func;
      };
      var baseSetToString = !defineProperty2 ? identity2 : function(func, string) {
        return defineProperty2(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result2 = Array2(length);
        while (++index < length) {
          result2[index] = array[index + start];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index, collection2) {
          result2 = predicate(value, index, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array[mid];
            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity2, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value : computed < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
          if (!index || !eq(computed, seen)) {
            var seen = computed;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray2(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set2 = iteratee2 ? null : createSet(array);
          if (set2) {
            return setToArray(set2);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed);
              }
              result2.push(value);
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result2) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last2(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index = -1, result2 = Array2(length);
        while (++index < length) {
          var array = arrays[index], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index) {
              result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index = -1, length = props.length, valsLength = values2.length, result2 = {};
        while (++index < length) {
          var value = index < valsLength ? values2[index] : undefined$1;
          assignFunc(result2, props[index], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity2;
      }
      function castPath(value, object) {
        if (isArray2(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString2(value));
      }
      var castRest = baseRest;
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === undefined$1 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root.clearTimeout(id);
      };
      function cloneBuffer(buffer2, isDeep) {
        if (isDeep) {
          return buffer2.slice();
        }
        var length = buffer2.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
        buffer2.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
          var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index < length) {
          var result2 = compareAscending(objCriteria[index], othCriteria[index]);
          if (result2) {
            if (index >= ordersLength) {
              return result2;
            }
            var order = orders[index];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array2(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
          if (newValue === undefined$1) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined$1 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike2(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee2(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString2(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject2(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
          while (index--) {
            args[index] = arguments[index];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined$1, args, holders, undefined$1, undefined$1, arity - length);
          }
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike2(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined$1;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index--) {
            var func = funcs[index];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index = wrapper ? index : length;
          while (++index < length) {
            func = funcs[index];
            var funcName = getFuncName(func), data2 = funcName == "wrapper" ? getData2(func) : undefined$1;
            if (data2 && isLaziable(data2[0]) && data2[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data2[4].length && data2[9] == 1) {
              wrapper = wrapper[getFuncName(data2[0])].apply(wrapper, data2[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray2(value)) {
              return wrapper.plant(value).value();
            }
            var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
            while (++index2 < length) {
              result2 = funcs[index2].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length;
          while (index--) {
            args[index] = arguments[index];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined$1 && other === undefined$1) {
            return defaultValue;
          }
          if (value !== undefined$1) {
            result2 = value;
          }
          if (other !== undefined$1) {
            if (result2 === undefined$1) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined$1 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined$1;
          }
          start = toFinite(start);
          if (end === undefined$1) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber2(value);
            other = toNumber2(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined$1, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          number = toNumber2(number);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString2(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString2(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$1;
        }
        ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined$1 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$1;
        }
        var data2 = isBindKey ? undefined$1 : getData2(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data2) {
          mergeData(newData, data2);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined$1, newData);
        }
        var setter = data2 ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject2(objValue) && isObject2(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject(value) ? undefined$1 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== undefined$1) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined$1, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData2 = !metaMap ? noop2 : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
        while (length--) {
          var data2 = array[length], otherFunc = data2.func;
          if (otherFunc == null || otherFunc == func) {
            return data2.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty.call(lodash2, "placeholder") ? lodash2 : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash2.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map3, key) {
        var data2 = map3.__data__;
        return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
      }
      function getMatchData(object) {
        var result2 = keys(object), length = result2.length;
        while (length--) {
          var key = result2[length], value = object[key];
          result2[length] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined$1;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined$1;
          var unmasked = true;
        } catch (e) {
        }
        var result2 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag = baseGetTag;
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
        getTag = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start, end, transforms) {
        var index = -1, length = transforms.length;
        while (++index < length) {
          var data2 = transforms[index], size2 = data2.size;
          switch (data2.type) {
            case "drop":
              start += size2;
              break;
            case "dropRight":
              end -= size2;
              break;
            case "take":
              end = nativeMin(end, start + size2);
              break;
            case "takeRight":
              start = nativeMax(start, end - size2);
              break;
          }
        }
        return { "start": start, "end": end };
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index = -1, length = path.length, result2 = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type2 = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index, object) {
        if (!isObject2(object)) {
          return false;
        }
        var type2 = typeof index;
        if (type2 == "number" ? isArrayLike2(object) && isIndex(index, object.length) : type2 == "string" && index in object) {
          return eq(object[index], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray2(value)) {
          return false;
        }
        var type2 = typeof value;
        if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable(value) {
        var type2 = typeof value;
        return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data2 = getData2(other);
        return !!data2 && func === data2[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction2 : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache2.size === MAX_MEMOIZE_SIZE) {
            cache2.clear();
          }
          return key;
        });
        var cache2 = result2.cache;
        return result2;
      }
      function mergeData(data2, source) {
        var bitmask = data2[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data2[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data2;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data2[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data2[3];
          data2[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data2[4] = partials ? replaceHolders(data2[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data2[5];
          data2[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data2[6] = partials ? replaceHolders(data2[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data2[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data2[8] = data2[8] == null ? source[8] : nativeMin(data2[8], source[8]);
        }
        if (data2[9] == null) {
          data2[9] = source[9];
        }
        data2[0] = source[0];
        data2[1] = newBitmask;
        return data2;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start, transform2) {
        start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array2(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform2(array);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index = indexes[length];
          array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
        }
        return array;
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count2 = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count2 >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count2 = 0;
          }
          return func.apply(undefined$1, arguments);
        };
      }
      function shuffleSelf(array, size2) {
        var index = -1, length = array.length, lastIndex = length - 1;
        size2 = size2 === undefined$1 ? length : size2;
        while (++index < size2) {
          var rand = baseRandom(index, lastIndex), value = array[rand];
          array[rand] = array[index];
          array[index] = value;
        }
        array.length = size2;
        return array;
      }
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName, function(match, number, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array, size2, guard) {
        if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined$1) {
          size2 = 1;
        } else {
          size2 = nativeMax(toInteger(size2), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size2 < 1) {
          return [];
        }
        var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
        while (index < length) {
          result2[resIndex++] = baseSlice(array, index, index += size2);
        }
        return result2;
      }
      function compact(array) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat2() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index = length;
        while (index--) {
          args[index - 1] = arguments[index];
        }
        return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values2) {
        var iteratee2 = last2(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values2) {
        var comparator = last2(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
      });
      function drop(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function dropRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array, value, start, end);
      }
      function findIndex2(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        if (fromIndex !== undefined$1) {
          index = toInteger(fromIndex);
          index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index, true);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs2) {
        var index = -1, length = pairs2 == null ? 0 : pairs2.length, result2 = {};
        while (++index < length) {
          var pair = pairs2[index];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined$1;
      }
      function indexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseIndexOf(array, value, index);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last2(mapped)) {
          iteratee2 = undefined$1;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
      });
      function join(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last2(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined$1;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length;
        if (fromIndex !== undefined$1) {
          index = toInteger(fromIndex);
          index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
      }
      function nth(array, n) {
        return array && array.length ? baseNth(array, toInteger(n)) : undefined$1;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      function pullAllBy(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values2, comparator) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$1, comparator) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index) {
          return isIndex(index, length) ? +index : index;
        }).sort(compareAscending));
        return result2;
      });
      function remove(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result2.push(value);
            indexes.push(index);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice(array, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger(start);
          end = end === undefined$1 ? length : toInteger(end);
        }
        return baseSlice(array, start, end);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value);
          if (index < length && eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take2(array, n, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function takeRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile2(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last2(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last2(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy2(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return array && array.length ? baseUniq(array, undefined$1, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group2) {
          if (isArrayLikeObject(group2)) {
            length = nativeMax(group2.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index) {
          return arrayMap(array, baseProperty(index));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group2) {
          return apply(iteratee2, undefined$1, group2);
        });
      }
      var without = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      });
      var xor2 = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last2(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last2(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
      });
      var zip2 = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash2(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap2(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({
          "func": thru,
          "args": [interceptor],
          "thisArg": undefined$1
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined$1);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined$1) {
          this.__values__ = toArray2(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
        return { "done": done, "value": value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone2 = wrapperClone(parent2);
          clone2.__index__ = 0;
          clone2.__values__ = undefined$1;
          if (result2) {
            previous.__wrapped__ = clone2;
          } else {
            result2 = clone2;
          }
          var previous = clone2;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            "func": thru,
            "args": [reverse],
            "thisArg": undefined$1
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every2(collection, predicate, guard) {
        var func = isArray2(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter2(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find2 = createFind(findIndex2);
      var findLast = createFind(findLastIndex);
      function flatMap2(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(map2(collection, iteratee2), depth);
      }
      function forEach(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy2 = createAggregator(function(result2, value, key) {
        if (hasOwnProperty.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue(result2, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike2(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index = -1, isFunc = typeof path == "function", result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function map2(collection, iteratee2) {
        var func = isArray2(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray2(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$1 : orders;
        if (!isArray2(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition2 = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce2(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, negate2(getIteratee(predicate, 3)));
      }
      function sample2(collection) {
        var func = isArray2(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize2(collection, n, guard) {
        if (guard ? isIterateeCall(collection, n, guard) : n === undefined$1) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }
      function shuffle(collection) {
        var func = isArray2(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike2(collection)) {
          return isString(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray2(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n, guard) {
        n = guard ? undefined$1 : n;
        n = func && n == null ? func.length : n;
        return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
      }
      function before(n, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined$1;
          }
          return result2;
        };
      }
      var bind = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce2(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber2(wait) || 0;
        if (isObject2(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber2(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time2) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$1;
          lastInvokeTime = time2;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time2) {
          lastInvokeTime = time2;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time2) : result2;
        }
        function remainingWait(time2) {
          var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time2) {
          var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
          return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time2 = now();
          if (shouldInvoke(time2)) {
            return trailingEdge(time2);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time2));
        }
        function trailingEdge(time2) {
          timerId = undefined$1;
          if (trailing && lastArgs) {
            return invokeFunc(time2);
          }
          lastArgs = lastThis = undefined$1;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined$1) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }
        function flush() {
          return timerId === undefined$1 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time2 = now(), isInvoking = shouldInvoke(time2);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time2;
          if (isInvoking) {
            if (timerId === undefined$1) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$1) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer2 = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay2 = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber2(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
          if (cache2.has(key)) {
            return cache2.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache2.set(key, result2) || cache2;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate2(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once2(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index = -1, length = nativeMin(args.length, funcsLength);
          while (++index < length) {
            args[index] = transforms[index].call(this, args[index]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined$1 ? start : toInteger(start);
        return baseRest(func, start);
      }
      function spread(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger(start), 0);
        return baseRest(function(args) {
          var array = args[start], otherArgs = castSlice(args, 0, start);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle2(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject2(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce2(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray2(value) ? value : [value];
      }
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys(source));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt2 = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray2 = Array2.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike2(value) {
        return value != null && isLength(value.length) && !isFunction2(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike2(value);
      }
      function isBoolean(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
      }
      function isEmpty2(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike2(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual2(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        var result2 = customizer ? customizer(value, other) : undefined$1;
        return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction2(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject2(value) {
        var type2 = typeof value;
        return value != null && (type2 == "object" || type2 == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString(value) {
        return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined2(value) {
        return value === undefined$1;
      }
      function isWeakMap(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray2(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike2(value)) {
          return isString(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber2(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber2(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject2(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString2(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike2(source)) {
          copyObject(source, keys(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys(source), object, customizer);
      });
      var at = flatRest(baseAt);
      function create(prototype, properties2) {
        var result2 = baseCreate(prototype);
        return properties2 == null ? result2 : baseAssign(result2, properties2);
      }
      var defaults = baseRest(function(object, sources) {
        object = Object2(object);
        var index = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined$1;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined$1 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined$1, customDefaultsMerge);
        return apply(mergeWith, undefined$1, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get(object, path, defaultValue) {
        var result2 = object == null ? undefined$1 : baseGet(object, path);
        return result2 === undefined$1 ? defaultValue : result2;
      }
      function has(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result2[value] = key;
      }, constant(identity2));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys(object) {
        return isArrayLike2(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, iteratee2(value, key, object2), value);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, key, iteratee2(value, key, object2));
        });
        return result2;
      }
      var merge2 = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate2(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function result(object, path, defaultValue) {
        path = castPath(path, object);
        var index = -1, length = path.length;
        if (!length) {
          length = 1;
          object = undefined$1;
        }
        while (++index < length) {
          var value = object == null ? undefined$1 : object[toKey(path[index])];
          if (value === undefined$1) {
            index = length;
            value = defaultValue;
          }
          object = isFunction2(value) ? value.call(object) : value;
        }
        return object;
      }
      function set(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      function setWith(object, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseSet(object, path, value, customizer);
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      function transform(object, iteratee2, accumulator) {
        var isArr = isArray2(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject2(object)) {
            accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
          return iteratee2(accumulator, value, index, object2);
        });
        return accumulator;
      }
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      function update(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp(number, lower, upper) {
        if (upper === undefined$1) {
          upper = lower;
          lower = undefined$1;
        }
        if (upper !== undefined$1) {
          upper = toNumber2(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined$1) {
          lower = toNumber2(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber2(number), lower, upper);
      }
      function inRange(number, start, end) {
        start = toFinite(start);
        if (end === undefined$1) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number = toNumber2(number);
        return baseInRange(number, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined$1;
        }
        if (floating === undefined$1) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$1;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined$1;
          }
        }
        if (lower === undefined$1 && upper === undefined$1) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined$1) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index) {
        word = word.toLowerCase();
        return result2 + (index ? capitalize(word) : word);
      });
      function capitalize(string) {
        return upperFirst(toString2(string).toLowerCase());
      }
      function deburr(string) {
        string = toString2(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string, target, position) {
        string = toString2(string);
        target = baseToString(target);
        var length = string.length;
        position = position === undefined$1 ? length : baseClamp(toInteger(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end) == target;
      }
      function escape(string) {
        string = toString2(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString2(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length, chars) {
        string = toString2(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length, chars) {
        string = toString2(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart(string, length, chars) {
        string = toString2(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString2(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat2(string, n, guard) {
        if (guard ? isIterateeCall(string, n, guard) : n === undefined$1) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        return baseRepeat(toString2(string), n);
      }
      function replace() {
        var args = arguments, string = toString2(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined$1;
        }
        limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString2(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target, position) {
        string = toString2(string);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }
      function template(string, options, guard) {
        var settings = lodash2.templateSettings;
        if (guard && isIterateeCall(string, options, guard)) {
          options = undefined$1;
        }
        string = toString2(string);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index = offset + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString2(value).toLowerCase();
      }
      function toUpper(value) {
        return toString2(value).toUpperCase();
      }
      function trim(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$1)) {
          return baseTrim(string);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$1)) {
          return string.slice(0, trimmedEndIndex(string) + 1);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$1)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject2(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string = toString2(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
        if (separator === undefined$1) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp(separator)) {
          if (string.slice(end).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end) != end) {
          var index = result2.lastIndexOf(separator);
          if (index > -1) {
            result2 = result2.slice(0, index);
          }
        }
        return result2 + omission;
      }
      function unescape2(string) {
        string = toString2(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern2, guard) {
        string = toString2(string);
        pattern2 = guard ? undefined$1 : pattern2;
        if (pattern2 === undefined$1) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern2) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined$1, args);
        } catch (e) {
          return isError(e) ? e : new Error2(e);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind(object[key], object));
        });
        return object;
      });
      function cond(pairs2) {
        var length = pairs2 == null ? 0 : pairs2.length, toIteratee = getIteratee();
        pairs2 = !length ? [] : arrayMap(pairs2, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index = -1;
          while (++index < length) {
            var pair = pairs2[index];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity2(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source, options) {
        var props = keys(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({ "func": func, "args": arguments, "thisArg": object });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop2() {
      }
      function nthArg(n) {
        n = toInteger(n);
        return baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined$1 : baseGet(object, path);
        };
      }
      var range2 = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n, iteratee2) {
        n = toInteger(n);
        if (n < 1 || n > MAX_SAFE_INTEGER) {
          return [];
        }
        var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index < n) {
          iteratee2(index);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray2(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol(value) ? [value] : copyArray(stringToPath(toString2(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString2(prefix) + id;
      }
      var add2 = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide2 = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max2(array) {
        return array && array.length ? baseExtremum(array, identity2, baseGt) : undefined$1;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
      }
      function mean(array) {
        return baseMean(array, identity2);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min2(array) {
        return array && array.length ? baseExtremum(array, identity2, baseLt) : undefined$1;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
      }
      var multiply2 = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract2 = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum2(array) {
        return array && array.length ? baseSum(array, identity2) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash2.after = after;
      lodash2.ary = ary;
      lodash2.assign = assign;
      lodash2.assignIn = assignIn;
      lodash2.assignInWith = assignInWith;
      lodash2.assignWith = assignWith;
      lodash2.at = at;
      lodash2.before = before;
      lodash2.bind = bind;
      lodash2.bindAll = bindAll;
      lodash2.bindKey = bindKey;
      lodash2.castArray = castArray;
      lodash2.chain = chain;
      lodash2.chunk = chunk;
      lodash2.compact = compact;
      lodash2.concat = concat2;
      lodash2.cond = cond;
      lodash2.conforms = conforms;
      lodash2.constant = constant;
      lodash2.countBy = countBy;
      lodash2.create = create;
      lodash2.curry = curry;
      lodash2.curryRight = curryRight;
      lodash2.debounce = debounce2;
      lodash2.defaults = defaults;
      lodash2.defaultsDeep = defaultsDeep;
      lodash2.defer = defer2;
      lodash2.delay = delay2;
      lodash2.difference = difference;
      lodash2.differenceBy = differenceBy;
      lodash2.differenceWith = differenceWith;
      lodash2.drop = drop;
      lodash2.dropRight = dropRight;
      lodash2.dropRightWhile = dropRightWhile;
      lodash2.dropWhile = dropWhile;
      lodash2.fill = fill;
      lodash2.filter = filter2;
      lodash2.flatMap = flatMap2;
      lodash2.flatMapDeep = flatMapDeep;
      lodash2.flatMapDepth = flatMapDepth;
      lodash2.flatten = flatten;
      lodash2.flattenDeep = flattenDeep;
      lodash2.flattenDepth = flattenDepth;
      lodash2.flip = flip;
      lodash2.flow = flow;
      lodash2.flowRight = flowRight;
      lodash2.fromPairs = fromPairs;
      lodash2.functions = functions;
      lodash2.functionsIn = functionsIn;
      lodash2.groupBy = groupBy2;
      lodash2.initial = initial;
      lodash2.intersection = intersection;
      lodash2.intersectionBy = intersectionBy;
      lodash2.intersectionWith = intersectionWith;
      lodash2.invert = invert;
      lodash2.invertBy = invertBy;
      lodash2.invokeMap = invokeMap;
      lodash2.iteratee = iteratee;
      lodash2.keyBy = keyBy;
      lodash2.keys = keys;
      lodash2.keysIn = keysIn;
      lodash2.map = map2;
      lodash2.mapKeys = mapKeys;
      lodash2.mapValues = mapValues;
      lodash2.matches = matches;
      lodash2.matchesProperty = matchesProperty;
      lodash2.memoize = memoize;
      lodash2.merge = merge2;
      lodash2.mergeWith = mergeWith;
      lodash2.method = method;
      lodash2.methodOf = methodOf;
      lodash2.mixin = mixin;
      lodash2.negate = negate2;
      lodash2.nthArg = nthArg;
      lodash2.omit = omit;
      lodash2.omitBy = omitBy;
      lodash2.once = once2;
      lodash2.orderBy = orderBy;
      lodash2.over = over;
      lodash2.overArgs = overArgs;
      lodash2.overEvery = overEvery;
      lodash2.overSome = overSome;
      lodash2.partial = partial;
      lodash2.partialRight = partialRight;
      lodash2.partition = partition2;
      lodash2.pick = pick;
      lodash2.pickBy = pickBy;
      lodash2.property = property;
      lodash2.propertyOf = propertyOf;
      lodash2.pull = pull;
      lodash2.pullAll = pullAll;
      lodash2.pullAllBy = pullAllBy;
      lodash2.pullAllWith = pullAllWith;
      lodash2.pullAt = pullAt;
      lodash2.range = range2;
      lodash2.rangeRight = rangeRight;
      lodash2.rearg = rearg;
      lodash2.reject = reject;
      lodash2.remove = remove;
      lodash2.rest = rest;
      lodash2.reverse = reverse;
      lodash2.sampleSize = sampleSize2;
      lodash2.set = set;
      lodash2.setWith = setWith;
      lodash2.shuffle = shuffle;
      lodash2.slice = slice;
      lodash2.sortBy = sortBy;
      lodash2.sortedUniq = sortedUniq;
      lodash2.sortedUniqBy = sortedUniqBy;
      lodash2.split = split;
      lodash2.spread = spread;
      lodash2.tail = tail;
      lodash2.take = take2;
      lodash2.takeRight = takeRight;
      lodash2.takeRightWhile = takeRightWhile;
      lodash2.takeWhile = takeWhile2;
      lodash2.tap = tap2;
      lodash2.throttle = throttle2;
      lodash2.thru = thru;
      lodash2.toArray = toArray2;
      lodash2.toPairs = toPairs;
      lodash2.toPairsIn = toPairsIn;
      lodash2.toPath = toPath;
      lodash2.toPlainObject = toPlainObject;
      lodash2.transform = transform;
      lodash2.unary = unary;
      lodash2.union = union;
      lodash2.unionBy = unionBy;
      lodash2.unionWith = unionWith;
      lodash2.uniq = uniq;
      lodash2.uniqBy = uniqBy2;
      lodash2.uniqWith = uniqWith;
      lodash2.unset = unset;
      lodash2.unzip = unzip;
      lodash2.unzipWith = unzipWith;
      lodash2.update = update;
      lodash2.updateWith = updateWith;
      lodash2.values = values;
      lodash2.valuesIn = valuesIn;
      lodash2.without = without;
      lodash2.words = words;
      lodash2.wrap = wrap;
      lodash2.xor = xor2;
      lodash2.xorBy = xorBy;
      lodash2.xorWith = xorWith;
      lodash2.zip = zip2;
      lodash2.zipObject = zipObject;
      lodash2.zipObjectDeep = zipObjectDeep;
      lodash2.zipWith = zipWith;
      lodash2.entries = toPairs;
      lodash2.entriesIn = toPairsIn;
      lodash2.extend = assignIn;
      lodash2.extendWith = assignInWith;
      mixin(lodash2, lodash2);
      lodash2.add = add2;
      lodash2.attempt = attempt;
      lodash2.camelCase = camelCase;
      lodash2.capitalize = capitalize;
      lodash2.ceil = ceil;
      lodash2.clamp = clamp;
      lodash2.clone = clone;
      lodash2.cloneDeep = cloneDeep;
      lodash2.cloneDeepWith = cloneDeepWith;
      lodash2.cloneWith = cloneWith;
      lodash2.conformsTo = conformsTo;
      lodash2.deburr = deburr;
      lodash2.defaultTo = defaultTo;
      lodash2.divide = divide2;
      lodash2.endsWith = endsWith;
      lodash2.eq = eq;
      lodash2.escape = escape;
      lodash2.escapeRegExp = escapeRegExp;
      lodash2.every = every2;
      lodash2.find = find2;
      lodash2.findIndex = findIndex2;
      lodash2.findKey = findKey;
      lodash2.findLast = findLast;
      lodash2.findLastIndex = findLastIndex;
      lodash2.findLastKey = findLastKey;
      lodash2.floor = floor;
      lodash2.forEach = forEach;
      lodash2.forEachRight = forEachRight;
      lodash2.forIn = forIn;
      lodash2.forInRight = forInRight;
      lodash2.forOwn = forOwn;
      lodash2.forOwnRight = forOwnRight;
      lodash2.get = get;
      lodash2.gt = gt2;
      lodash2.gte = gte;
      lodash2.has = has;
      lodash2.hasIn = hasIn;
      lodash2.head = head;
      lodash2.identity = identity2;
      lodash2.includes = includes;
      lodash2.indexOf = indexOf;
      lodash2.inRange = inRange;
      lodash2.invoke = invoke;
      lodash2.isArguments = isArguments;
      lodash2.isArray = isArray2;
      lodash2.isArrayBuffer = isArrayBuffer;
      lodash2.isArrayLike = isArrayLike2;
      lodash2.isArrayLikeObject = isArrayLikeObject;
      lodash2.isBoolean = isBoolean;
      lodash2.isBuffer = isBuffer;
      lodash2.isDate = isDate2;
      lodash2.isElement = isElement;
      lodash2.isEmpty = isEmpty2;
      lodash2.isEqual = isEqual2;
      lodash2.isEqualWith = isEqualWith;
      lodash2.isError = isError;
      lodash2.isFinite = isFinite2;
      lodash2.isFunction = isFunction2;
      lodash2.isInteger = isInteger;
      lodash2.isLength = isLength;
      lodash2.isMap = isMap;
      lodash2.isMatch = isMatch;
      lodash2.isMatchWith = isMatchWith;
      lodash2.isNaN = isNaN2;
      lodash2.isNative = isNative;
      lodash2.isNil = isNil;
      lodash2.isNull = isNull;
      lodash2.isNumber = isNumber;
      lodash2.isObject = isObject2;
      lodash2.isObjectLike = isObjectLike;
      lodash2.isPlainObject = isPlainObject;
      lodash2.isRegExp = isRegExp;
      lodash2.isSafeInteger = isSafeInteger;
      lodash2.isSet = isSet;
      lodash2.isString = isString;
      lodash2.isSymbol = isSymbol;
      lodash2.isTypedArray = isTypedArray;
      lodash2.isUndefined = isUndefined2;
      lodash2.isWeakMap = isWeakMap;
      lodash2.isWeakSet = isWeakSet;
      lodash2.join = join;
      lodash2.kebabCase = kebabCase;
      lodash2.last = last2;
      lodash2.lastIndexOf = lastIndexOf;
      lodash2.lowerCase = lowerCase;
      lodash2.lowerFirst = lowerFirst;
      lodash2.lt = lt;
      lodash2.lte = lte;
      lodash2.max = max2;
      lodash2.maxBy = maxBy;
      lodash2.mean = mean;
      lodash2.meanBy = meanBy;
      lodash2.min = min2;
      lodash2.minBy = minBy;
      lodash2.stubArray = stubArray;
      lodash2.stubFalse = stubFalse;
      lodash2.stubObject = stubObject;
      lodash2.stubString = stubString;
      lodash2.stubTrue = stubTrue;
      lodash2.multiply = multiply2;
      lodash2.nth = nth;
      lodash2.noConflict = noConflict;
      lodash2.noop = noop2;
      lodash2.now = now;
      lodash2.pad = pad;
      lodash2.padEnd = padEnd;
      lodash2.padStart = padStart;
      lodash2.parseInt = parseInt2;
      lodash2.random = random;
      lodash2.reduce = reduce2;
      lodash2.reduceRight = reduceRight;
      lodash2.repeat = repeat2;
      lodash2.replace = replace;
      lodash2.result = result;
      lodash2.round = round;
      lodash2.runInContext = runInContext2;
      lodash2.sample = sample2;
      lodash2.size = size;
      lodash2.snakeCase = snakeCase;
      lodash2.some = some;
      lodash2.sortedIndex = sortedIndex;
      lodash2.sortedIndexBy = sortedIndexBy;
      lodash2.sortedIndexOf = sortedIndexOf;
      lodash2.sortedLastIndex = sortedLastIndex;
      lodash2.sortedLastIndexBy = sortedLastIndexBy;
      lodash2.sortedLastIndexOf = sortedLastIndexOf;
      lodash2.startCase = startCase;
      lodash2.startsWith = startsWith;
      lodash2.subtract = subtract2;
      lodash2.sum = sum2;
      lodash2.sumBy = sumBy;
      lodash2.template = template;
      lodash2.times = times;
      lodash2.toFinite = toFinite;
      lodash2.toInteger = toInteger;
      lodash2.toLength = toLength;
      lodash2.toLower = toLower;
      lodash2.toNumber = toNumber2;
      lodash2.toSafeInteger = toSafeInteger;
      lodash2.toString = toString2;
      lodash2.toUpper = toUpper;
      lodash2.trim = trim;
      lodash2.trimEnd = trimEnd;
      lodash2.trimStart = trimStart;
      lodash2.truncate = truncate;
      lodash2.unescape = unescape2;
      lodash2.uniqueId = uniqueId;
      lodash2.upperCase = upperCase;
      lodash2.upperFirst = upperFirst;
      lodash2.each = forEach;
      lodash2.eachRight = forEachRight;
      lodash2.first = head;
      mixin(lodash2, function() {
        var source = {};
        baseForOwn(lodash2, function(func, methodName) {
          if (!hasOwnProperty.call(lodash2.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { "chain": false });
      lodash2.VERSION = VERSION;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      });
      arrayEach(["drop", "take"], function(methodName, index) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);
          var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
          } else {
            result2.__views__.push({
              "size": nativeMin(n, MAX_ARRAY_LENGTH),
              "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
        var type2 = index + 1, isFilter = type2 == LAZY_FILTER_FLAG || type2 == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            "iteratee": getIteratee(iteratee2, 3),
            "type": type2
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index) {
        var takeName = "take" + (index ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index) {
        var dropName = "drop" + (index ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity2);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate2(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger(start);
        var result2 = this;
        if (result2.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start < 0) {
          result2 = result2.takeRight(-start);
        } else if (start) {
          result2 = result2.drop(start);
        }
        if (end !== undefined$1) {
          end = toInteger(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash2.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray2(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray2(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
        "name": "wrapper",
        "func": undefined$1
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash2.prototype.at = wrapperAt;
      lodash2.prototype.chain = wrapperChain;
      lodash2.prototype.commit = wrapperCommit;
      lodash2.prototype.next = wrapperNext;
      lodash2.prototype.plant = wrapperPlant;
      lodash2.prototype.reverse = wrapperReverse;
      lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
      lodash2.prototype.first = lodash2.prototype.head;
      if (symIterator) {
        lodash2.prototype[symIterator] = wrapperToIterator;
      }
      return lodash2;
    };
    var _ = runInContext();
    if (freeModule) {
      (freeModule.exports = _)._ = _;
      freeExports._ = _;
    } else {
      root._ = _;
    }
  }).call(commonjsGlobal);
})(lodash, lodash.exports);
function omitDeep(spec, omitKeys) {
  return lodash.exports.cloneDeepWith(spec, (value) => {
    if (value && typeof value === "object") {
      omitKeys.forEach((key) => {
        delete value[key];
      });
    }
  });
}
const DELAY_FOR_CONTAINER_RESIZE_BEFORE_RERENDER = 300;
const GoslingComponent = forwardRef((props, ref2) => {
  var _a, _b, _c;
  const [viewConfig, setViewConfig] = useState();
  const [size, setSize] = useState({ width: 200, height: 200 });
  const wrapperSize = useRef();
  const wrapperParentSize = useRef();
  const prevSpec = useRef();
  const trackInfos = useRef([]);
  const hgRef = useRef(null);
  const theme = getTheme(props.theme || "light");
  const wrapperDivId = (_a = props.id) != null ? _a : v4();
  useImperativeHandle(ref2, () => {
    const hgApi = refAsReadonlyProxy(hgRef);
    const infos = refAsReadonlyProxy(trackInfos);
    const api = createApi(hgApi, viewConfig, infos, theme);
    return { api, hgApi };
  }, [viewConfig, theme]);
  const compile$12 = useCallback(() => {
    if (props.spec) {
      const valid = validateGoslingSpec(props.spec);
      if (valid.state === "error") {
        console.warn("Gosling spec is not valid. Please refer to the console message.");
        return;
      }
      compile(props.spec, (newHs, newSize, newGs, newTrackInfos) => {
        var _a2, _b2;
        if (prevSpec.current && lodash.exports.isEqual(omitDeep(prevSpec.current, ["linkingId"]), omitDeep(newGs, ["linkingId"]))) {
          return;
        }
        (_a2 = props.compiled) == null ? void 0 : _a2.call(props, props.spec, newHs);
        setSize(newSize);
        const isMountedOnce = typeof viewConfig !== "undefined";
        if (((_b2 = props.experimental) == null ? void 0 : _b2.reactive) && isMountedOnce) {
          setTimeout(() => {
            var _a3;
            (_a3 = hgRef.current) == null ? void 0 : _a3.api.setViewConfig(newHs);
          }, DELAY_FOR_CONTAINER_RESIZE_BEFORE_RERENDER);
        } else {
          setViewConfig(newHs);
        }
        prevSpec.current = newGs;
        trackInfos.current = newTrackInfos;
      }, [...GoslingTemplates], theme, {
        containerSize: wrapperSize.current,
        containerParentSize: wrapperParentSize.current
      });
    }
  }, [props.spec, theme]);
  useEffect(() => {
    const containerElement = document.getElementById(wrapperDivId);
    if (!containerElement)
      return;
    const resizer = new ResizeSensor(containerElement, (newSize) => {
      if (!wrapperSize.current || wrapperSize.current.height !== newSize.height || wrapperSize.current.width !== newSize.width) {
        wrapperSize.current = newSize;
        compile$12();
      }
    });
    const parentElement = containerElement.parentElement;
    if (!parentElement)
      return;
    const parentResizer = new ResizeSensor(parentElement, (newSize) => {
      if (!wrapperParentSize.current || wrapperParentSize.current.height !== newSize.height || wrapperParentSize.current.width !== newSize.width) {
        wrapperParentSize.current = newSize;
        compile$12();
      }
    });
    return () => {
      resizer.detach();
      parentResizer.detach();
    };
  });
  useEffect(() => {
    compile$12();
  }, [props.spec, theme]);
  const responsiveHeight = typeof ((_b = props.spec) == null ? void 0 : _b.responsiveSize) !== "object" ? (_c = props.spec) == null ? void 0 : _c.responsiveSize : props.spec.responsiveSize.height;
  const higlassComponent = useMemo(() => {
    var _a2, _b2, _c2;
    return /* @__PURE__ */ React.createElement(HiGlassComponentWrapper, {
      ref: hgRef,
      viewConfig,
      size,
      id: wrapperDivId,
      className: props.className,
      options: {
        padding: props.padding,
        border: props.border,
        margin: props.margin,
        responsiveWidth: typeof ((_a2 = props.spec) == null ? void 0 : _a2.responsiveSize) !== "object" ? (_b2 = props.spec) == null ? void 0 : _b2.responsiveSize : props.spec.responsiveSize.width,
        responsiveHeight,
        background: theme.root.background,
        alt: (_c2 = props.spec) == null ? void 0 : _c2.description
      }
    });
  }, [viewConfig, size, theme, responsiveHeight]);
  return higlassComponent;
});
GoslingComponent.displayName = "GoslingComponent";
function refAsReadonlyProxy(ref2) {
  return new Proxy({}, {
    get(_target, prop, reciever) {
      if (!ref2.current)
        throw Error("ref is not set!");
      return Reflect.get(ref2.current, prop, reciever);
    }
  });
}
const MAX_TRIES = 20;
const INTERVAL = 200;
const launchHiglass = (element, viewConfig, size, opts) => {
  const ref2 = React.createRef();
  const component = React.createElement(HiGlassComponentWrapper, {
    ref: ref2,
    viewConfig,
    size,
    id: opts.id,
    className: opts.className,
    options: opts
  });
  ReactDOM.render(component, element);
  return new Promise((resolve2, reject) => {
    let tries = 0;
    const poll = setInterval(() => {
      if (ref2 && ref2.current) {
        clearInterval(poll);
        resolve2(ref2.current);
      }
      if (tries >= MAX_TRIES) {
        reject(new Error("Failed to initialize HiGlassApi."));
      }
      tries++;
    }, INTERVAL);
  });
};
function embed(element, spec, opts = {}) {
  return new Promise((resolve2, reject) => {
    var _a, _b;
    const valid = validateGoslingSpec(spec);
    if (valid.state === "error") {
      reject(new Error("Gosling spec is not valid. Please refer to the console message."));
    }
    const theme = getTheme(opts.theme || "light");
    const options = {
      ...opts,
      background: theme.root.background,
      alt: (_b = (_a = opts.alt) != null ? _a : spec.description) != null ? _b : "Gosling visualization"
    };
    compile(spec, async (hsSpec, size, _, trackInfos) => {
      const hg = await launchHiglass(element, hsSpec, size, options);
      const api = createApi(hg, hsSpec, trackInfos, theme);
      resolve2(api);
    }, [...GoslingTemplates], theme, {});
  });
}
export { GoslingComponent, GoslingSchema, GoslingTemplates, theme_schema as ThemeSchema, compile, embed, init, name, validateGoslingSpec, version };
//# sourceMappingURL=gosling.es.js.map
