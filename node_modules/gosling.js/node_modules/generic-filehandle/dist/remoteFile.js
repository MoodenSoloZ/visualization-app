"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _fileUriToPath = _interopRequireDefault(require("file-uri-to-path"));

var _ = require(".");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var myGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {
  fetch: undefined
};

var RemoteFile = /*#__PURE__*/function () {
  (0, _createClass2.default)(RemoteFile, [{
    key: "getBufferFromResponse",
    value: function () {
      var _getBufferFromResponse = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(response) {
        var resp;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(typeof response.buffer === 'function')) {
                  _context.next = 4;
                  break;
                }

                return _context.abrupt("return", response.buffer());

              case 4:
                if (!(typeof response.arrayBuffer === 'function')) {
                  _context.next = 11;
                  break;
                }

                _context.next = 7;
                return response.arrayBuffer();

              case 7:
                resp = _context.sent;
                return _context.abrupt("return", Buffer.from(resp));

              case 11:
                throw new TypeError('invalid HTTP response object, has no buffer method, and no arrayBuffer method');

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function getBufferFromResponse(_x) {
        return _getBufferFromResponse.apply(this, arguments);
      }

      return getBufferFromResponse;
    }()
  }]);

  function RemoteFile(source) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, RemoteFile);
    (0, _defineProperty2.default)(this, "url", void 0);
    (0, _defineProperty2.default)(this, "_stat", void 0);
    (0, _defineProperty2.default)(this, "fetchImplementation", void 0);
    (0, _defineProperty2.default)(this, "baseOverrides", {});
    this.url = source; // if it is a file URL, monkey-patch ourselves to act like a LocalFile

    if (source.startsWith('file://')) {
      var path = (0, _fileUriToPath.default)(source);

      if (!path) {
        throw new TypeError('invalid file url');
      }

      var localFile = new _.LocalFile(path);
      this.read = localFile.read.bind(localFile);
      this.readFile = localFile.readFile.bind(localFile);
      this.stat = localFile.stat.bind(localFile); // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
      // @ts-ignore

      this.fetchImplementation = function () {
        /* intentionally blank */
      };

      return;
    }

    var fetch = opts.fetch || myGlobal.fetch && myGlobal.fetch.bind(myGlobal);

    if (!fetch) {
      throw new TypeError("no fetch function supplied, and none found in global environment");
    }

    if (opts.overrides) {
      this.baseOverrides = opts.overrides;
    }

    this.fetchImplementation = fetch;
  }

  (0, _createClass2.default)(RemoteFile, [{
    key: "fetch",
    value: function () {
      var _fetch = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(input, init) {
        var response;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                _context2.next = 3;
                return this.fetchImplementation(input, init);

              case 3:
                response = _context2.sent;
                _context2.next = 16;
                break;

              case 6:
                _context2.prev = 6;
                _context2.t0 = _context2["catch"](0);

                if (!(_context2.t0.message === 'Failed to fetch')) {
                  _context2.next = 15;
                  break;
                }

                // refetch to to help work around a chrome bug (discussed in generic-filehandle issue #72) in
                // which the chrome cache returns a CORS error for content in its cache.
                // see also https://github.com/GMOD/jbrowse-components/pull/1511
                console.warn("generic-filehandle: refetching ".concat(input, " to attempt to work around chrome CORS header caching bug"));
                _context2.next = 12;
                return this.fetchImplementation(input, _objectSpread(_objectSpread({}, init), {}, {
                  cache: 'reload'
                }));

              case 12:
                response = _context2.sent;
                _context2.next = 16;
                break;

              case 15:
                throw _context2.t0;

              case 16:
                return _context2.abrupt("return", response);

              case 17:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[0, 6]]);
      }));

      function fetch(_x2, _x3) {
        return _fetch.apply(this, arguments);
      }

      return fetch;
    }()
  }, {
    key: "read",
    value: function () {
      var _read = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(buffer) {
        var offset,
            length,
            position,
            opts,
            _opts$headers,
            headers,
            signal,
            _opts$overrides,
            overrides,
            args,
            response,
            responseData,
            bytesCopied,
            res,
            sizeMatch,
            _args3 = arguments;

        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                offset = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : 0;
                length = _args3.length > 2 ? _args3[2] : undefined;
                position = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : 0;
                opts = _args3.length > 4 && _args3[4] !== undefined ? _args3[4] : {};
                _opts$headers = opts.headers, headers = _opts$headers === void 0 ? {} : _opts$headers, signal = opts.signal, _opts$overrides = opts.overrides, overrides = _opts$overrides === void 0 ? {} : _opts$overrides;

                if (length < Infinity) {
                  headers.range = "bytes=".concat(position, "-").concat(position + length);
                } else if (length === Infinity && position !== 0) {
                  headers.range = "bytes=".concat(position, "-");
                }

                args = _objectSpread(_objectSpread(_objectSpread({}, this.baseOverrides), overrides), {}, {
                  headers: _objectSpread(_objectSpread(_objectSpread({}, headers), overrides.headers), this.baseOverrides.headers),
                  method: 'GET',
                  redirect: 'follow',
                  mode: 'cors',
                  signal: signal
                });
                _context3.next = 9;
                return this.fetch(this.url, args);

              case 9:
                response = _context3.sent;

                if (response.ok) {
                  _context3.next = 12;
                  break;
                }

                throw new Error("HTTP ".concat(response.status, " ").concat(response.statusText));

              case 12:
                if (!(response.status === 200 && position === 0 || response.status === 206)) {
                  _context3.next = 21;
                  break;
                }

                _context3.next = 15;
                return this.getBufferFromResponse(response);

              case 15:
                responseData = _context3.sent;
                bytesCopied = responseData.copy(buffer, offset, 0, Math.min(length, responseData.length)); // try to parse out the size of the remote file

                res = response.headers.get('content-range');
                sizeMatch = /\/(\d+)$/.exec(res || '');

                if (sizeMatch && sizeMatch[1]) {
                  this._stat = {
                    size: parseInt(sizeMatch[1], 10)
                  };
                }

                return _context3.abrupt("return", {
                  bytesRead: bytesCopied,
                  buffer: buffer
                });

              case 21:
                if (!(response.status === 200)) {
                  _context3.next = 23;
                  break;
                }

                throw new Error('${this.url} fetch returned status 200, expected 206');

              case 23:
                throw new Error("HTTP ".concat(response.status, " fetching ").concat(this.url));

              case 24:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function read(_x4) {
        return _read.apply(this, arguments);
      }

      return read;
    }()
  }, {
    key: "readFile",
    value: function () {
      var _readFile = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {
        var options,
            encoding,
            opts,
            _opts,
            _opts$headers2,
            headers,
            signal,
            _opts$overrides2,
            overrides,
            args,
            response,
            _args4 = arguments;

        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                options = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};

                if (typeof options === 'string') {
                  encoding = options;
                  opts = {};
                } else {
                  encoding = options.encoding;
                  opts = options;
                  delete opts.encoding;
                }

                _opts = opts, _opts$headers2 = _opts.headers, headers = _opts$headers2 === void 0 ? {} : _opts$headers2, signal = _opts.signal, _opts$overrides2 = _opts.overrides, overrides = _opts$overrides2 === void 0 ? {} : _opts$overrides2;
                args = _objectSpread(_objectSpread({
                  headers: headers,
                  method: 'GET',
                  redirect: 'follow',
                  mode: 'cors',
                  signal: signal
                }, this.baseOverrides), overrides);
                _context4.next = 6;
                return this.fetch(this.url, args);

              case 6:
                response = _context4.sent;

                if (response) {
                  _context4.next = 9;
                  break;
                }

                throw new Error('generic-filehandle failed to fetch');

              case 9:
                if (!(response.status !== 200)) {
                  _context4.next = 11;
                  break;
                }

                throw Object.assign(new Error("HTTP ".concat(response.status, " fetching ").concat(this.url)), {
                  status: response.status
                });

              case 11:
                if (!(encoding === 'utf8')) {
                  _context4.next = 13;
                  break;
                }

                return _context4.abrupt("return", response.text());

              case 13:
                if (!encoding) {
                  _context4.next = 15;
                  break;
                }

                throw new Error("unsupported encoding: ".concat(encoding));

              case 15:
                return _context4.abrupt("return", this.getBufferFromResponse(response));

              case 16:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function readFile() {
        return _readFile.apply(this, arguments);
      }

      return readFile;
    }()
  }, {
    key: "stat",
    value: function () {
      var _stat = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5() {
        var buf;
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (this._stat) {
                  _context5.next = 6;
                  break;
                }

                buf = Buffer.allocUnsafe(10);
                _context5.next = 4;
                return this.read(buf, 0, 10, 0);

              case 4:
                if (this._stat) {
                  _context5.next = 6;
                  break;
                }

                throw new Error("unable to determine size of file at ".concat(this.url));

              case 6:
                return _context5.abrupt("return", this._stat);

              case 7:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function stat() {
        return _stat.apply(this, arguments);
      }

      return stat;
    }()
  }, {
    key: "close",
    value: function () {
      var _close = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6() {
        return _regenerator.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                return _context6.abrupt("return");

              case 1:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  }]);
  return RemoteFile;
}();

exports.default = RemoteFile;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yZW1vdGVGaWxlLnRzIl0sIm5hbWVzIjpbIm15R2xvYmFsIiwid2luZG93Iiwic2VsZiIsImZldGNoIiwidW5kZWZpbmVkIiwiUmVtb3RlRmlsZSIsInJlc3BvbnNlIiwiYnVmZmVyIiwiYXJyYXlCdWZmZXIiLCJyZXNwIiwiQnVmZmVyIiwiZnJvbSIsIlR5cGVFcnJvciIsInNvdXJjZSIsIm9wdHMiLCJ1cmwiLCJzdGFydHNXaXRoIiwicGF0aCIsImxvY2FsRmlsZSIsIkxvY2FsRmlsZSIsInJlYWQiLCJiaW5kIiwicmVhZEZpbGUiLCJzdGF0IiwiZmV0Y2hJbXBsZW1lbnRhdGlvbiIsIm92ZXJyaWRlcyIsImJhc2VPdmVycmlkZXMiLCJpbnB1dCIsImluaXQiLCJtZXNzYWdlIiwiY29uc29sZSIsIndhcm4iLCJjYWNoZSIsIm9mZnNldCIsImxlbmd0aCIsInBvc2l0aW9uIiwiaGVhZGVycyIsInNpZ25hbCIsIkluZmluaXR5IiwicmFuZ2UiLCJhcmdzIiwibWV0aG9kIiwicmVkaXJlY3QiLCJtb2RlIiwib2siLCJFcnJvciIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJnZXRCdWZmZXJGcm9tUmVzcG9uc2UiLCJyZXNwb25zZURhdGEiLCJieXRlc0NvcGllZCIsImNvcHkiLCJNYXRoIiwibWluIiwicmVzIiwiZ2V0Iiwic2l6ZU1hdGNoIiwiZXhlYyIsIl9zdGF0Iiwic2l6ZSIsInBhcnNlSW50IiwiYnl0ZXNSZWFkIiwib3B0aW9ucyIsImVuY29kaW5nIiwiT2JqZWN0IiwiYXNzaWduIiwidGV4dCIsImJ1ZiIsImFsbG9jVW5zYWZlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBUUE7Ozs7OztBQUVBLElBQU1BLFFBQVEsR0FDWixPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLEdBQ0lBLE1BREosR0FFSSxPQUFPQyxJQUFQLEtBQWdCLFdBQWhCLEdBQ0FBLElBREEsR0FFQTtBQUFFQyxFQUFBQSxLQUFLLEVBQUVDO0FBQVQsQ0FMTjs7SUFPcUJDLFU7Ozs7NEhBTWlCQyxROzs7Ozs7c0JBQzlCLE9BQU9BLFFBQVEsQ0FBQ0MsTUFBaEIsS0FBMkIsVTs7Ozs7aURBQ3RCRCxRQUFRLENBQUNDLE1BQVQsRTs7O3NCQUNFLE9BQU9ELFFBQVEsQ0FBQ0UsV0FBaEIsS0FBZ0MsVTs7Ozs7O3VCQUN0QkYsUUFBUSxDQUFDRSxXQUFULEU7OztBQUFiQyxnQkFBQUEsSTtpREFDQ0MsTUFBTSxDQUFDQyxJQUFQLENBQVlGLElBQVosQzs7O3NCQUVELElBQUlHLFNBQUosQ0FDSiwrRUFESSxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNVixzQkFBbUJDLE1BQW5CLEVBQWlFO0FBQUEsUUFBOUJDLElBQThCLHVFQUFKLEVBQUk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHlEQWZwQyxFQWVvQztBQUMvRCxTQUFLQyxHQUFMLEdBQVdGLE1BQVgsQ0FEK0QsQ0FHL0Q7O0FBQ0EsUUFBSUEsTUFBTSxDQUFDRyxVQUFQLENBQWtCLFNBQWxCLENBQUosRUFBa0M7QUFDaEMsVUFBTUMsSUFBSSxHQUFHLDRCQUFTSixNQUFULENBQWI7O0FBQ0EsVUFBSSxDQUFDSSxJQUFMLEVBQVc7QUFDVCxjQUFNLElBQUlMLFNBQUosQ0FBYyxrQkFBZCxDQUFOO0FBQ0Q7O0FBQ0QsVUFBTU0sU0FBUyxHQUFHLElBQUlDLFdBQUosQ0FBY0YsSUFBZCxDQUFsQjtBQUNBLFdBQUtHLElBQUwsR0FBWUYsU0FBUyxDQUFDRSxJQUFWLENBQWVDLElBQWYsQ0FBb0JILFNBQXBCLENBQVo7QUFDQSxXQUFLSSxRQUFMLEdBQWdCSixTQUFTLENBQUNJLFFBQVYsQ0FBbUJELElBQW5CLENBQXdCSCxTQUF4QixDQUFoQjtBQUNBLFdBQUtLLElBQUwsR0FBWUwsU0FBUyxDQUFDSyxJQUFWLENBQWVGLElBQWYsQ0FBb0JILFNBQXBCLENBQVosQ0FSZ0MsQ0FTaEM7QUFDQTs7QUFDQSxXQUFLTSxtQkFBTCxHQUEyQixZQUFZO0FBQ3JDO0FBQ0QsT0FGRDs7QUFHQTtBQUNEOztBQUVELFFBQU1yQixLQUFLLEdBQUdXLElBQUksQ0FBQ1gsS0FBTCxJQUFlSCxRQUFRLENBQUNHLEtBQVQsSUFBa0JILFFBQVEsQ0FBQ0csS0FBVCxDQUFla0IsSUFBZixDQUFvQnJCLFFBQXBCLENBQS9DOztBQUNBLFFBQUksQ0FBQ0csS0FBTCxFQUFZO0FBQ1YsWUFBTSxJQUFJUyxTQUFKLG9FQUFOO0FBR0Q7O0FBQ0QsUUFBSUUsSUFBSSxDQUFDVyxTQUFULEVBQW9CO0FBQ2xCLFdBQUtDLGFBQUwsR0FBcUJaLElBQUksQ0FBQ1csU0FBMUI7QUFDRDs7QUFDRCxTQUFLRCxtQkFBTCxHQUEyQnJCLEtBQTNCO0FBQ0Q7Ozs7OzZHQUdDd0IsSyxFQUNBQyxJOzs7Ozs7Ozt1QkFJbUIsS0FBS0osbUJBQUwsQ0FBeUJHLEtBQXpCLEVBQWdDQyxJQUFoQyxDOzs7QUFBakJ0QixnQkFBQUEsUTs7Ozs7Ozs7c0JBRUksYUFBRXVCLE9BQUYsS0FBYyxpQjs7Ozs7QUFDaEI7QUFDQTtBQUNBO0FBQ0FDLGdCQUFBQSxPQUFPLENBQUNDLElBQVIsMENBQ29DSixLQURwQzs7dUJBR2lCLEtBQUtILG1CQUFMLENBQXlCRyxLQUF6QixrQ0FBcUNDLElBQXJDO0FBQTJDSSxrQkFBQUEsS0FBSyxFQUFFO0FBQWxELG1COzs7QUFBakIxQixnQkFBQUEsUTs7Ozs7Ozs7a0RBS0dBLFE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NEdBSVBDLE07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTBCLGdCQUFBQSxNLDhEQUFTLEM7QUFDVEMsZ0JBQUFBLE07QUFDQUMsZ0JBQUFBLFEsOERBQVcsQztBQUNYckIsZ0JBQUFBLEksOERBQTBCLEU7Z0NBRXVCQSxJLENBQXpDc0IsTyxFQUFBQSxPLDhCQUFVLEUsa0JBQUlDLE0sR0FBMkJ2QixJLENBQTNCdUIsTSxvQkFBMkJ2QixJLENBQW5CVyxTLEVBQUFBLFMsZ0NBQVksRTs7QUFDMUMsb0JBQUlTLE1BQU0sR0FBR0ksUUFBYixFQUF1QjtBQUNyQkYsa0JBQUFBLE9BQU8sQ0FBQ0csS0FBUixtQkFBeUJKLFFBQXpCLGNBQXFDQSxRQUFRLEdBQUdELE1BQWhEO0FBQ0QsaUJBRkQsTUFFTyxJQUFJQSxNQUFNLEtBQUtJLFFBQVgsSUFBdUJILFFBQVEsS0FBSyxDQUF4QyxFQUEyQztBQUNoREMsa0JBQUFBLE9BQU8sQ0FBQ0csS0FBUixtQkFBeUJKLFFBQXpCO0FBQ0Q7O0FBQ0tLLGdCQUFBQSxJLGlEQUNELEtBQUtkLGEsR0FDTEQsUztBQUNIVyxrQkFBQUEsT0FBTyxnREFBT0EsT0FBUCxHQUFtQlgsU0FBUyxDQUFDVyxPQUE3QixHQUF5QyxLQUFLVixhQUFMLENBQW1CVSxPQUE1RCxDO0FBQ1BLLGtCQUFBQSxNQUFNLEVBQUUsSztBQUNSQyxrQkFBQUEsUUFBUSxFQUFFLFE7QUFDVkMsa0JBQUFBLElBQUksRUFBRSxNO0FBQ05OLGtCQUFBQSxNQUFNLEVBQU5BOzs7dUJBRXFCLEtBQUtsQyxLQUFMLENBQVcsS0FBS1ksR0FBaEIsRUFBcUJ5QixJQUFyQixDOzs7QUFBakJsQyxnQkFBQUEsUTs7b0JBRURBLFFBQVEsQ0FBQ3NDLEU7Ozs7O3NCQUNOLElBQUlDLEtBQUosZ0JBQWtCdkMsUUFBUSxDQUFDd0MsTUFBM0IsY0FBcUN4QyxRQUFRLENBQUN5QyxVQUE5QyxFOzs7c0JBR0h6QyxRQUFRLENBQUN3QyxNQUFULEtBQW9CLEdBQXBCLElBQTJCWCxRQUFRLEtBQUssQ0FBekMsSUFBK0M3QixRQUFRLENBQUN3QyxNQUFULEtBQW9CLEc7Ozs7Ozt1QkFDMUMsS0FBS0UscUJBQUwsQ0FBMkIxQyxRQUEzQixDOzs7QUFBckIyQyxnQkFBQUEsWTtBQUNBQyxnQkFBQUEsVyxHQUFjRCxZQUFZLENBQUNFLElBQWIsQ0FDbEI1QyxNQURrQixFQUVsQjBCLE1BRmtCLEVBR2xCLENBSGtCLEVBSWxCbUIsSUFBSSxDQUFDQyxHQUFMLENBQVNuQixNQUFULEVBQWlCZSxZQUFZLENBQUNmLE1BQTlCLENBSmtCLEMsRUFPcEI7O0FBQ01vQixnQkFBQUEsRyxHQUFNaEQsUUFBUSxDQUFDOEIsT0FBVCxDQUFpQm1CLEdBQWpCLENBQXFCLGVBQXJCLEM7QUFDTkMsZ0JBQUFBLFMsR0FBWSxXQUFXQyxJQUFYLENBQWdCSCxHQUFHLElBQUksRUFBdkIsQzs7QUFDbEIsb0JBQUlFLFNBQVMsSUFBSUEsU0FBUyxDQUFDLENBQUQsQ0FBMUIsRUFBK0I7QUFDN0IsdUJBQUtFLEtBQUwsR0FBYTtBQUFFQyxvQkFBQUEsSUFBSSxFQUFFQyxRQUFRLENBQUNKLFNBQVMsQ0FBQyxDQUFELENBQVYsRUFBZSxFQUFmO0FBQWhCLG1CQUFiO0FBQ0Q7O2tEQUVNO0FBQUVLLGtCQUFBQSxTQUFTLEVBQUVYLFdBQWI7QUFBMEIzQyxrQkFBQUEsTUFBTSxFQUFOQTtBQUExQixpQjs7O3NCQUdMRCxRQUFRLENBQUN3QyxNQUFULEtBQW9CLEc7Ozs7O3NCQUNoQixJQUFJRCxLQUFKLENBQVUscURBQVYsQzs7O3NCQUlGLElBQUlBLEtBQUosZ0JBQWtCdkMsUUFBUSxDQUFDd0MsTUFBM0IsdUJBQThDLEtBQUsvQixHQUFuRCxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSU4rQyxnQkFBQUEsTyw4REFBc0MsRTs7QUFJdEMsb0JBQUksT0FBT0EsT0FBUCxLQUFtQixRQUF2QixFQUFpQztBQUMvQkMsa0JBQUFBLFFBQVEsR0FBR0QsT0FBWDtBQUNBaEQsa0JBQUFBLElBQUksR0FBRyxFQUFQO0FBQ0QsaUJBSEQsTUFHTztBQUNMaUQsa0JBQUFBLFFBQVEsR0FBR0QsT0FBTyxDQUFDQyxRQUFuQjtBQUNBakQsa0JBQUFBLElBQUksR0FBR2dELE9BQVA7QUFDQSx5QkFBT2hELElBQUksQ0FBQ2lELFFBQVo7QUFDRDs7d0JBQ2dEakQsSSx5QkFBekNzQixPLEVBQUFBLE8sK0JBQVUsRSxtQkFBSUMsTSxTQUFBQSxNLDJCQUFRWixTLEVBQUFBLFMsaUNBQVksRTtBQUNwQ2UsZ0JBQUFBLEk7QUFDSkosa0JBQUFBLE9BQU8sRUFBUEEsTztBQUNBSyxrQkFBQUEsTUFBTSxFQUFFLEs7QUFDUkMsa0JBQUFBLFFBQVEsRUFBRSxRO0FBQ1ZDLGtCQUFBQSxJQUFJLEVBQUUsTTtBQUNOTixrQkFBQUEsTUFBTSxFQUFOQTttQkFDRyxLQUFLWCxhLEdBQ0xELFM7O3VCQUVrQixLQUFLdEIsS0FBTCxDQUFXLEtBQUtZLEdBQWhCLEVBQXFCeUIsSUFBckIsQzs7O0FBQWpCbEMsZ0JBQUFBLFE7O29CQUVEQSxROzs7OztzQkFDRyxJQUFJdUMsS0FBSixDQUFVLG9DQUFWLEM7OztzQkFHSnZDLFFBQVEsQ0FBQ3dDLE1BQVQsS0FBb0IsRzs7Ozs7c0JBQ2hCa0IsTUFBTSxDQUFDQyxNQUFQLENBQWMsSUFBSXBCLEtBQUosZ0JBQWtCdkMsUUFBUSxDQUFDd0MsTUFBM0IsdUJBQThDLEtBQUsvQixHQUFuRCxFQUFkLEVBQXlFO0FBQzdFK0Isa0JBQUFBLE1BQU0sRUFBRXhDLFFBQVEsQ0FBQ3dDO0FBRDRELGlCQUF6RSxDOzs7c0JBSUppQixRQUFRLEtBQUssTTs7Ozs7a0RBQ1J6RCxRQUFRLENBQUM0RCxJQUFULEU7OztxQkFFTEgsUTs7Ozs7c0JBQ0ksSUFBSWxCLEtBQUosaUNBQW1Da0IsUUFBbkMsRTs7O2tEQUVELEtBQUtmLHFCQUFMLENBQTJCMUMsUUFBM0IsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFJRixLQUFLb0QsSzs7Ozs7QUFDRlMsZ0JBQUFBLEcsR0FBTXpELE1BQU0sQ0FBQzBELFdBQVAsQ0FBbUIsRUFBbkIsQzs7dUJBQ04sS0FBS2hELElBQUwsQ0FBVStDLEdBQVYsRUFBZSxDQUFmLEVBQWtCLEVBQWxCLEVBQXNCLENBQXRCLEM7OztvQkFDRCxLQUFLVCxLOzs7OztzQkFDRixJQUFJYixLQUFKLCtDQUFpRCxLQUFLOUIsR0FBdEQsRTs7O2tEQUdILEtBQUsyQyxLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHVyaTJwYXRoIGZyb20gJ2ZpbGUtdXJpLXRvLXBhdGgnXG5pbXBvcnQge1xuICBHZW5lcmljRmlsZWhhbmRsZSxcbiAgRmlsZWhhbmRsZU9wdGlvbnMsXG4gIFN0YXRzLFxuICBGZXRjaGVyLFxuICBQb2x5ZmlsbGVkUmVzcG9uc2UsXG59IGZyb20gJy4vZmlsZWhhbmRsZSdcbmltcG9ydCB7IExvY2FsRmlsZSB9IGZyb20gJy4nXG5cbmNvbnN0IG15R2xvYmFsID1cbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IHdpbmRvd1xuICAgIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnXG4gICAgPyBzZWxmXG4gICAgOiB7IGZldGNoOiB1bmRlZmluZWQgfVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW1vdGVGaWxlIGltcGxlbWVudHMgR2VuZXJpY0ZpbGVoYW5kbGUge1xuICBwcm90ZWN0ZWQgdXJsOiBzdHJpbmdcbiAgcHJpdmF0ZSBfc3RhdD86IFN0YXRzXG4gIHByaXZhdGUgZmV0Y2hJbXBsZW1lbnRhdGlvbjogRmV0Y2hlclxuICBwcml2YXRlIGJhc2VPdmVycmlkZXM6IGFueSA9IHt9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRCdWZmZXJGcm9tUmVzcG9uc2UocmVzcG9uc2U6IFBvbHlmaWxsZWRSZXNwb25zZSk6IFByb21pc2U8QnVmZmVyPiB7XG4gICAgaWYgKHR5cGVvZiByZXNwb25zZS5idWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5idWZmZXIoKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlc3BvbnNlLmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCByZXNwID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKVxuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHJlc3ApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdpbnZhbGlkIEhUVFAgcmVzcG9uc2Ugb2JqZWN0LCBoYXMgbm8gYnVmZmVyIG1ldGhvZCwgYW5kIG5vIGFycmF5QnVmZmVyIG1ldGhvZCcsXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNvdXJjZTogc3RyaW5nLCBvcHRzOiBGaWxlaGFuZGxlT3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy51cmwgPSBzb3VyY2VcblxuICAgIC8vIGlmIGl0IGlzIGEgZmlsZSBVUkwsIG1vbmtleS1wYXRjaCBvdXJzZWx2ZXMgdG8gYWN0IGxpa2UgYSBMb2NhbEZpbGVcbiAgICBpZiAoc291cmNlLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSkge1xuICAgICAgY29uc3QgcGF0aCA9IHVyaTJwYXRoKHNvdXJjZSlcbiAgICAgIGlmICghcGF0aCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGZpbGUgdXJsJylcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvY2FsRmlsZSA9IG5ldyBMb2NhbEZpbGUocGF0aClcbiAgICAgIHRoaXMucmVhZCA9IGxvY2FsRmlsZS5yZWFkLmJpbmQobG9jYWxGaWxlKVxuICAgICAgdGhpcy5yZWFkRmlsZSA9IGxvY2FsRmlsZS5yZWFkRmlsZS5iaW5kKGxvY2FsRmlsZSlcbiAgICAgIHRoaXMuc3RhdCA9IGxvY2FsRmlsZS5zdGF0LmJpbmQobG9jYWxGaWxlKVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLmZldGNoSW1wbGVtZW50YXRpb24gPSAoKTogdm9pZCA9PiB7XG4gICAgICAgIC8qIGludGVudGlvbmFsbHkgYmxhbmsgKi9cbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGZldGNoID0gb3B0cy5mZXRjaCB8fCAobXlHbG9iYWwuZmV0Y2ggJiYgbXlHbG9iYWwuZmV0Y2guYmluZChteUdsb2JhbCkpXG4gICAgaWYgKCFmZXRjaCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgYG5vIGZldGNoIGZ1bmN0aW9uIHN1cHBsaWVkLCBhbmQgbm9uZSBmb3VuZCBpbiBnbG9iYWwgZW52aXJvbm1lbnRgLFxuICAgICAgKVxuICAgIH1cbiAgICBpZiAob3B0cy5vdmVycmlkZXMpIHtcbiAgICAgIHRoaXMuYmFzZU92ZXJyaWRlcyA9IG9wdHMub3ZlcnJpZGVzXG4gICAgfVxuICAgIHRoaXMuZmV0Y2hJbXBsZW1lbnRhdGlvbiA9IGZldGNoXG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZmV0Y2goXG4gICAgaW5wdXQ6IFJlcXVlc3RJbmZvLFxuICAgIGluaXQ6IFJlcXVlc3RJbml0IHwgdW5kZWZpbmVkLFxuICApOiBQcm9taXNlPFBvbHlmaWxsZWRSZXNwb25zZT4ge1xuICAgIGxldCByZXNwb25zZVxuICAgIHRyeSB7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hJbXBsZW1lbnRhdGlvbihpbnB1dCwgaW5pdClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5tZXNzYWdlID09PSAnRmFpbGVkIHRvIGZldGNoJykge1xuICAgICAgICAvLyByZWZldGNoIHRvIHRvIGhlbHAgd29yayBhcm91bmQgYSBjaHJvbWUgYnVnIChkaXNjdXNzZWQgaW4gZ2VuZXJpYy1maWxlaGFuZGxlIGlzc3VlICM3MikgaW5cbiAgICAgICAgLy8gd2hpY2ggdGhlIGNocm9tZSBjYWNoZSByZXR1cm5zIGEgQ09SUyBlcnJvciBmb3IgY29udGVudCBpbiBpdHMgY2FjaGUuXG4gICAgICAgIC8vIHNlZSBhbHNvIGh0dHBzOi8vZ2l0aHViLmNvbS9HTU9EL2picm93c2UtY29tcG9uZW50cy9wdWxsLzE1MTFcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBnZW5lcmljLWZpbGVoYW5kbGU6IHJlZmV0Y2hpbmcgJHtpbnB1dH0gdG8gYXR0ZW1wdCB0byB3b3JrIGFyb3VuZCBjaHJvbWUgQ09SUyBoZWFkZXIgY2FjaGluZyBidWdgLFxuICAgICAgICApXG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaEltcGxlbWVudGF0aW9uKGlucHV0LCB7IC4uLmluaXQsIGNhY2hlOiAncmVsb2FkJyB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyByZWFkKFxuICAgIGJ1ZmZlcjogQnVmZmVyLFxuICAgIG9mZnNldCA9IDAsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgcG9zaXRpb24gPSAwLFxuICAgIG9wdHM6IEZpbGVoYW5kbGVPcHRpb25zID0ge30sXG4gICk6IFByb21pc2U8eyBieXRlc1JlYWQ6IG51bWJlcjsgYnVmZmVyOiBCdWZmZXIgfT4ge1xuICAgIGNvbnN0IHsgaGVhZGVycyA9IHt9LCBzaWduYWwsIG92ZXJyaWRlcyA9IHt9IH0gPSBvcHRzXG4gICAgaWYgKGxlbmd0aCA8IEluZmluaXR5KSB7XG4gICAgICBoZWFkZXJzLnJhbmdlID0gYGJ5dGVzPSR7cG9zaXRpb259LSR7cG9zaXRpb24gKyBsZW5ndGh9YFxuICAgIH0gZWxzZSBpZiAobGVuZ3RoID09PSBJbmZpbml0eSAmJiBwb3NpdGlvbiAhPT0gMCkge1xuICAgICAgaGVhZGVycy5yYW5nZSA9IGBieXRlcz0ke3Bvc2l0aW9ufS1gXG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICAuLi50aGlzLmJhc2VPdmVycmlkZXMsXG4gICAgICAuLi5vdmVycmlkZXMsXG4gICAgICBoZWFkZXJzOiB7IC4uLmhlYWRlcnMsIC4uLm92ZXJyaWRlcy5oZWFkZXJzLCAuLi50aGlzLmJhc2VPdmVycmlkZXMuaGVhZGVycyB9LFxuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHJlZGlyZWN0OiAnZm9sbG93JyxcbiAgICAgIG1vZGU6ICdjb3JzJyxcbiAgICAgIHNpZ25hbCxcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoKHRoaXMudXJsLCBhcmdzKVxuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YClcbiAgICB9XG5cbiAgICBpZiAoKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwICYmIHBvc2l0aW9uID09PSAwKSB8fCByZXNwb25zZS5zdGF0dXMgPT09IDIwNikge1xuICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgdGhpcy5nZXRCdWZmZXJGcm9tUmVzcG9uc2UocmVzcG9uc2UpXG4gICAgICBjb25zdCBieXRlc0NvcGllZCA9IHJlc3BvbnNlRGF0YS5jb3B5KFxuICAgICAgICBidWZmZXIsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgMCxcbiAgICAgICAgTWF0aC5taW4obGVuZ3RoLCByZXNwb25zZURhdGEubGVuZ3RoKSxcbiAgICAgIClcblxuICAgICAgLy8gdHJ5IHRvIHBhcnNlIG91dCB0aGUgc2l6ZSBvZiB0aGUgcmVtb3RlIGZpbGVcbiAgICAgIGNvbnN0IHJlcyA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXJhbmdlJylcbiAgICAgIGNvbnN0IHNpemVNYXRjaCA9IC9cXC8oXFxkKykkLy5leGVjKHJlcyB8fCAnJylcbiAgICAgIGlmIChzaXplTWF0Y2ggJiYgc2l6ZU1hdGNoWzFdKSB7XG4gICAgICAgIHRoaXMuX3N0YXQgPSB7IHNpemU6IHBhcnNlSW50KHNpemVNYXRjaFsxXSwgMTApIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgYnl0ZXNSZWFkOiBieXRlc0NvcGllZCwgYnVmZmVyIH1cbiAgICB9XG5cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignJHt0aGlzLnVybH0gZmV0Y2ggcmV0dXJuZWQgc3RhdHVzIDIwMCwgZXhwZWN0ZWQgMjA2JylcbiAgICB9XG5cbiAgICAvLyBUT0RPOiB0cnkgaGFyZGVyIGhlcmUgdG8gZ2F0aGVyIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCB0aGUgcHJvYmxlbSBpc1xuICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c30gZmV0Y2hpbmcgJHt0aGlzLnVybH1gKVxuICB9XG5cbiAgcHVibGljIGFzeW5jIHJlYWRGaWxlKFxuICAgIG9wdGlvbnM6IEZpbGVoYW5kbGVPcHRpb25zIHwgc3RyaW5nID0ge30sXG4gICk6IFByb21pc2U8QnVmZmVyIHwgc3RyaW5nPiB7XG4gICAgbGV0IGVuY29kaW5nXG4gICAgbGV0IG9wdHNcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IG9wdGlvbnNcbiAgICAgIG9wdHMgPSB7fVxuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IG9wdGlvbnMuZW5jb2RpbmdcbiAgICAgIG9wdHMgPSBvcHRpb25zXG4gICAgICBkZWxldGUgb3B0cy5lbmNvZGluZ1xuICAgIH1cbiAgICBjb25zdCB7IGhlYWRlcnMgPSB7fSwgc2lnbmFsLCBvdmVycmlkZXMgPSB7fSB9ID0gb3B0c1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBoZWFkZXJzLFxuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHJlZGlyZWN0OiAnZm9sbG93JyxcbiAgICAgIG1vZGU6ICdjb3JzJyxcbiAgICAgIHNpZ25hbCxcbiAgICAgIC4uLnRoaXMuYmFzZU92ZXJyaWRlcyxcbiAgICAgIC4uLm92ZXJyaWRlcyxcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoKHRoaXMudXJsLCBhcmdzKVxuXG4gICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZW5lcmljLWZpbGVoYW5kbGUgZmFpbGVkIHRvIGZldGNoJylcbiAgICB9XG5cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIHRocm93IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfSBmZXRjaGluZyAke3RoaXMudXJsfWApLCB7XG4gICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgfSlcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nID09PSAndXRmOCcpIHtcbiAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KClcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGVuY29kaW5nOiAke2VuY29kaW5nfWApXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlckZyb21SZXNwb25zZShyZXNwb25zZSlcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzdGF0KCk6IFByb21pc2U8U3RhdHM+IHtcbiAgICBpZiAoIXRoaXMuX3N0YXQpIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxMClcbiAgICAgIGF3YWl0IHRoaXMucmVhZChidWYsIDAsIDEwLCAwKVxuICAgICAgaWYgKCF0aGlzLl9zdGF0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5hYmxlIHRvIGRldGVybWluZSBzaXplIG9mIGZpbGUgYXQgJHt0aGlzLnVybH1gKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc3RhdFxuICB9XG5cbiAgcHVibGljIGFzeW5jIGNsb3NlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVyblxuICB9XG59XG4iXX0=