{"ast":null,"code":"import _slicedToArray from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { array, isArray, isObject, isString } from 'vega-util';\nimport { isBinned } from '../../../bin';\nimport { getMainRangeChannel, isXorY, THETA, RADIUS } from '../../../channel';\nimport { defaultTitle, getFieldDef, getFormatMixins, hasConditionalFieldDef, isFieldDef, isTypedFieldDef, vgField } from '../../../channeldef';\nimport { forEach } from '../../../encoding';\nimport { entries } from '../../../util';\nimport { isSignalRef } from '../../../vega.schema';\nimport { getMarkPropOrConfig } from '../../common';\nimport { binFormatExpression, formatSignalRef } from '../../format';\nimport { wrapCondition } from './conditional';\nimport { textRef } from './text';\nexport function tooltip(model) {\n  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var encoding = model.encoding,\n    markDef = model.markDef,\n    config = model.config,\n    stack = model.stack;\n  var channelDef = encoding.tooltip;\n  if (isArray(channelDef)) {\n    return {\n      tooltip: tooltipRefForEncoding({\n        tooltip: channelDef\n      }, stack, config, opt)\n    };\n  } else {\n    var datum = opt.reactiveGeom ? 'datum.datum' : 'datum';\n    return wrapCondition(model, channelDef, 'tooltip', function (cDef) {\n      // use valueRef based on channelDef first\n      var tooltipRefFromChannelDef = textRef(cDef, config, datum);\n      if (tooltipRefFromChannelDef) {\n        return tooltipRefFromChannelDef;\n      }\n      if (cDef === null) {\n        // Allow using encoding.tooltip = null to disable tooltip\n        return undefined;\n      }\n      var markTooltip = getMarkPropOrConfig('tooltip', markDef, config);\n      if (markTooltip === true) {\n        markTooltip = {\n          content: 'encoding'\n        };\n      }\n      if (isString(markTooltip)) {\n        return {\n          value: markTooltip\n        };\n      } else if (isObject(markTooltip)) {\n        // `tooltip` is `{fields: 'encodings' | 'fields'}`\n        if (isSignalRef(markTooltip)) {\n          return markTooltip;\n        } else if (markTooltip.content === 'encoding') {\n          return tooltipRefForEncoding(encoding, stack, config, opt);\n        } else {\n          return {\n            signal: datum\n          };\n        }\n      }\n      return undefined;\n    });\n  }\n}\nexport function tooltipData(encoding, stack, config) {\n  var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n    reactiveGeom = _ref.reactiveGeom;\n  var toSkip = {};\n  var expr = reactiveGeom ? 'datum.datum' : 'datum';\n  var tuples = [];\n  function add(fDef, channel) {\n    var mainChannel = getMainRangeChannel(channel);\n    var fieldDef = isTypedFieldDef(fDef) ? fDef : Object.assign(Object.assign({}, fDef), {\n      type: encoding[mainChannel].type // for secondary field def, copy type from main channel\n    });\n\n    var title = fieldDef.title || defaultTitle(fieldDef, config);\n    var key = array(title).join(', ');\n    var value;\n    if (isXorY(channel)) {\n      var channel2 = channel === 'x' ? 'x2' : 'y2';\n      var fieldDef2 = getFieldDef(encoding[channel2]);\n      if (isBinned(fieldDef.bin) && fieldDef2) {\n        var startField = vgField(fieldDef, {\n          expr: expr\n        });\n        var endField = vgField(fieldDef2, {\n          expr: expr\n        });\n        var _getFormatMixins = getFormatMixins(fieldDef),\n          format = _getFormatMixins.format,\n          formatType = _getFormatMixins.formatType;\n        value = binFormatExpression(startField, endField, format, formatType, config);\n        toSkip[channel2] = true;\n      }\n    }\n    if ((isXorY(channel) || channel === THETA || channel === RADIUS) && stack && stack.fieldChannel === channel && stack.offset === 'normalize') {\n      var _getFormatMixins2 = getFormatMixins(fieldDef),\n        _format = _getFormatMixins2.format,\n        _formatType = _getFormatMixins2.formatType;\n      value = formatSignalRef({\n        fieldOrDatumDef: fieldDef,\n        format: _format,\n        formatType: _formatType,\n        expr: expr,\n        config: config,\n        normalizeStack: true\n      }).signal;\n    }\n    value !== null && value !== void 0 ? value : value = textRef(fieldDef, config, expr).signal;\n    tuples.push({\n      channel: channel,\n      key: key,\n      value: value\n    });\n  }\n  forEach(encoding, function (channelDef, channel) {\n    if (isFieldDef(channelDef)) {\n      add(channelDef, channel);\n    } else if (hasConditionalFieldDef(channelDef)) {\n      add(channelDef.condition, channel);\n    }\n  });\n  var out = {};\n  for (var _i = 0, _tuples = tuples; _i < _tuples.length; _i++) {\n    var _tuples$_i = _tuples[_i],\n      channel = _tuples$_i.channel,\n      key = _tuples$_i.key,\n      value = _tuples$_i.value;\n    if (!toSkip[channel] && !out[key]) {\n      out[key] = value;\n    }\n  }\n  return out;\n}\nexport function tooltipRefForEncoding(encoding, stack, config) {\n  var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n    reactiveGeom = _ref2.reactiveGeom;\n  var data = tooltipData(encoding, stack, config, {\n    reactiveGeom: reactiveGeom\n  });\n  var keyValues = entries(data).map(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n      key = _ref4[0],\n      value = _ref4[1];\n    return \"\\\"\".concat(key, \"\\\": \").concat(value);\n  });\n  return keyValues.length > 0 ? {\n    signal: \"{\".concat(keyValues.join(', '), \"}\")\n  } : undefined;\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/tooltip.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { array, isArray, isObject, isString } from 'vega-util';\nimport { isBinned } from '../../../bin';\nimport { getMainRangeChannel, isXorY, THETA, RADIUS } from '../../../channel';\nimport { defaultTitle, getFieldDef, getFormatMixins, hasConditionalFieldDef, isFieldDef, isTypedFieldDef, vgField } from '../../../channeldef';\nimport { forEach } from '../../../encoding';\nimport { entries } from '../../../util';\nimport { isSignalRef } from '../../../vega.schema';\nimport { getMarkPropOrConfig } from '../../common';\nimport { binFormatExpression, formatSignalRef } from '../../format';\nimport { wrapCondition } from './conditional';\nimport { textRef } from './text';\nexport function tooltip(model, opt = {}) {\n    const { encoding, markDef, config, stack } = model;\n    const channelDef = encoding.tooltip;\n    if (isArray(channelDef)) {\n        return { tooltip: tooltipRefForEncoding({ tooltip: channelDef }, stack, config, opt) };\n    }\n    else {\n        const datum = opt.reactiveGeom ? 'datum.datum' : 'datum';\n        return wrapCondition(model, channelDef, 'tooltip', cDef => {\n            // use valueRef based on channelDef first\n            const tooltipRefFromChannelDef = textRef(cDef, config, datum);\n            if (tooltipRefFromChannelDef) {\n                return tooltipRefFromChannelDef;\n            }\n            if (cDef === null) {\n                // Allow using encoding.tooltip = null to disable tooltip\n                return undefined;\n            }\n            let markTooltip = getMarkPropOrConfig('tooltip', markDef, config);\n            if (markTooltip === true) {\n                markTooltip = { content: 'encoding' };\n            }\n            if (isString(markTooltip)) {\n                return { value: markTooltip };\n            }\n            else if (isObject(markTooltip)) {\n                // `tooltip` is `{fields: 'encodings' | 'fields'}`\n                if (isSignalRef(markTooltip)) {\n                    return markTooltip;\n                }\n                else if (markTooltip.content === 'encoding') {\n                    return tooltipRefForEncoding(encoding, stack, config, opt);\n                }\n                else {\n                    return { signal: datum };\n                }\n            }\n            return undefined;\n        });\n    }\n}\nexport function tooltipData(encoding, stack, config, { reactiveGeom } = {}) {\n    const toSkip = {};\n    const expr = reactiveGeom ? 'datum.datum' : 'datum';\n    const tuples = [];\n    function add(fDef, channel) {\n        const mainChannel = getMainRangeChannel(channel);\n        const fieldDef = isTypedFieldDef(fDef)\n            ? fDef\n            : Object.assign(Object.assign({}, fDef), { type: encoding[mainChannel].type // for secondary field def, copy type from main channel\n             });\n        const title = fieldDef.title || defaultTitle(fieldDef, config);\n        const key = array(title).join(', ');\n        let value;\n        if (isXorY(channel)) {\n            const channel2 = channel === 'x' ? 'x2' : 'y2';\n            const fieldDef2 = getFieldDef(encoding[channel2]);\n            if (isBinned(fieldDef.bin) && fieldDef2) {\n                const startField = vgField(fieldDef, { expr });\n                const endField = vgField(fieldDef2, { expr });\n                const { format, formatType } = getFormatMixins(fieldDef);\n                value = binFormatExpression(startField, endField, format, formatType, config);\n                toSkip[channel2] = true;\n            }\n        }\n        if ((isXorY(channel) || channel === THETA || channel === RADIUS) &&\n            stack &&\n            stack.fieldChannel === channel &&\n            stack.offset === 'normalize') {\n            const { format, formatType } = getFormatMixins(fieldDef);\n            value = formatSignalRef({\n                fieldOrDatumDef: fieldDef,\n                format,\n                formatType,\n                expr,\n                config,\n                normalizeStack: true\n            }).signal;\n        }\n        value !== null && value !== void 0 ? value : (value = textRef(fieldDef, config, expr).signal);\n        tuples.push({ channel, key, value });\n    }\n    forEach(encoding, (channelDef, channel) => {\n        if (isFieldDef(channelDef)) {\n            add(channelDef, channel);\n        }\n        else if (hasConditionalFieldDef(channelDef)) {\n            add(channelDef.condition, channel);\n        }\n    });\n    const out = {};\n    for (const { channel, key, value } of tuples) {\n        if (!toSkip[channel] && !out[key]) {\n            out[key] = value;\n        }\n    }\n    return out;\n}\nexport function tooltipRefForEncoding(encoding, stack, config, { reactiveGeom } = {}) {\n    const data = tooltipData(encoding, stack, config, { reactiveGeom });\n    const keyValues = entries(data).map(([key, value]) => `\"${key}\": ${value}`);\n    return keyValues.length > 0 ? { signal: `{${keyValues.join(', ')}}` } : undefined;\n}\n//# sourceMappingURL=tooltip.js.map"]},"metadata":{},"sourceType":"module"}