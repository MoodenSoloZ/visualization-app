{"ast":null,"code":"import _classCallCheck from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport * as log from '../log';\nimport { isConcatSpec, isHConcatSpec, isVConcatSpec } from './concat';\nimport { isFacetSpec } from './facet';\nimport { isLayerSpec } from './layer';\nimport { isRepeatSpec } from './repeat';\nimport { isUnitSpec } from './unit';\nexport var SpecMapper = /*#__PURE__*/function () {\n  function SpecMapper() {\n    _classCallCheck(this, SpecMapper);\n  }\n  _createClass(SpecMapper, [{\n    key: \"map\",\n    value: function map(spec, params) {\n      if (isFacetSpec(spec)) {\n        return this.mapFacet(spec, params);\n      } else if (isRepeatSpec(spec)) {\n        return this.mapRepeat(spec, params);\n      } else if (isHConcatSpec(spec)) {\n        return this.mapHConcat(spec, params);\n      } else if (isVConcatSpec(spec)) {\n        return this.mapVConcat(spec, params);\n      } else if (isConcatSpec(spec)) {\n        return this.mapConcat(spec, params);\n      } else {\n        return this.mapLayerOrUnit(spec, params);\n      }\n    }\n  }, {\n    key: \"mapLayerOrUnit\",\n    value: function mapLayerOrUnit(spec, params) {\n      if (isLayerSpec(spec)) {\n        return this.mapLayer(spec, params);\n      } else if (isUnitSpec(spec)) {\n        return this.mapUnit(spec, params);\n      }\n      throw new Error(log.message.invalidSpec(spec));\n    }\n  }, {\n    key: \"mapLayer\",\n    value: function mapLayer(spec, params) {\n      var _this = this;\n      return Object.assign(Object.assign({}, spec), {\n        layer: spec.layer.map(function (subspec) {\n          return _this.mapLayerOrUnit(subspec, params);\n        })\n      });\n    }\n  }, {\n    key: \"mapHConcat\",\n    value: function mapHConcat(spec, params) {\n      var _this2 = this;\n      return Object.assign(Object.assign({}, spec), {\n        hconcat: spec.hconcat.map(function (subspec) {\n          return _this2.map(subspec, params);\n        })\n      });\n    }\n  }, {\n    key: \"mapVConcat\",\n    value: function mapVConcat(spec, params) {\n      var _this3 = this;\n      return Object.assign(Object.assign({}, spec), {\n        vconcat: spec.vconcat.map(function (subspec) {\n          return _this3.map(subspec, params);\n        })\n      });\n    }\n  }, {\n    key: \"mapConcat\",\n    value: function mapConcat(spec, params) {\n      var _this4 = this;\n      var concat = spec.concat,\n        rest = __rest(spec, [\"concat\"]);\n      return Object.assign(Object.assign({}, rest), {\n        concat: concat.map(function (subspec) {\n          return _this4.map(subspec, params);\n        })\n      });\n    }\n  }, {\n    key: \"mapFacet\",\n    value: function mapFacet(spec, params) {\n      return Object.assign(Object.assign({}, spec), {\n        // TODO: remove \"any\" once we support all facet listed in https://github.com/vega/vega-lite/issues/2760\n        spec: this.map(spec.spec, params)\n      });\n    }\n  }, {\n    key: \"mapRepeat\",\n    value: function mapRepeat(spec, params) {\n      return Object.assign(Object.assign({}, spec), {\n        // as any is required here since TS cannot infer that the output type satisfies the input type\n        spec: this.map(spec.spec, params)\n      });\n    }\n  }]);\n  return SpecMapper;\n}();","map":{"version":3,"sources":["../../../src/spec/map.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport * as log from '../log';\nimport { isConcatSpec, isHConcatSpec, isVConcatSpec } from './concat';\nimport { isFacetSpec } from './facet';\nimport { isLayerSpec } from './layer';\nimport { isRepeatSpec } from './repeat';\nimport { isUnitSpec } from './unit';\nexport class SpecMapper {\n    map(spec, params) {\n        if (isFacetSpec(spec)) {\n            return this.mapFacet(spec, params);\n        }\n        else if (isRepeatSpec(spec)) {\n            return this.mapRepeat(spec, params);\n        }\n        else if (isHConcatSpec(spec)) {\n            return this.mapHConcat(spec, params);\n        }\n        else if (isVConcatSpec(spec)) {\n            return this.mapVConcat(spec, params);\n        }\n        else if (isConcatSpec(spec)) {\n            return this.mapConcat(spec, params);\n        }\n        else {\n            return this.mapLayerOrUnit(spec, params);\n        }\n    }\n    mapLayerOrUnit(spec, params) {\n        if (isLayerSpec(spec)) {\n            return this.mapLayer(spec, params);\n        }\n        else if (isUnitSpec(spec)) {\n            return this.mapUnit(spec, params);\n        }\n        throw new Error(log.message.invalidSpec(spec));\n    }\n    mapLayer(spec, params) {\n        return Object.assign(Object.assign({}, spec), { layer: spec.layer.map(subspec => this.mapLayerOrUnit(subspec, params)) });\n    }\n    mapHConcat(spec, params) {\n        return Object.assign(Object.assign({}, spec), { hconcat: spec.hconcat.map(subspec => this.map(subspec, params)) });\n    }\n    mapVConcat(spec, params) {\n        return Object.assign(Object.assign({}, spec), { vconcat: spec.vconcat.map(subspec => this.map(subspec, params)) });\n    }\n    mapConcat(spec, params) {\n        const { concat } = spec, rest = __rest(spec, [\"concat\"]);\n        return Object.assign(Object.assign({}, rest), { concat: concat.map(subspec => this.map(subspec, params)) });\n    }\n    mapFacet(spec, params) {\n        return Object.assign(Object.assign({}, spec), { \n            // TODO: remove \"any\" once we support all facet listed in https://github.com/vega/vega-lite/issues/2760\n            spec: this.map(spec.spec, params) });\n    }\n    mapRepeat(spec, params) {\n        return Object.assign(Object.assign({}, spec), { \n            // as any is required here since TS cannot infer that the output type satisfies the input type\n            spec: this.map(spec.spec, params) });\n    }\n}\n//# sourceMappingURL=map.js.map"]},"metadata":{},"sourceType":"module"}