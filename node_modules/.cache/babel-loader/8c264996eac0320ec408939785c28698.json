{"ast":null,"code":"import _defineProperty from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { parseSelector } from 'vega-event-selector';\nimport { identity, isArray, stringValue } from 'vega-util';\nimport { MODIFY, STORE, unitName, VL_SELECTION_RESOLVE, TUPLE, selectionCompilers } from '.';\nimport { dateTimeToExpr, isDateTime, dateTimeToTimestamp } from '../../datetime';\nimport { hasContinuousDomain } from '../../scale';\nimport { SELECTION_ID } from '../../selection';\nimport { keys, stringify, vals } from '../../util';\nimport { isUnitModel } from '../model';\nimport { parseSelectionExtent } from './parse';\nexport function assembleInit(init) {\n  var isExpr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var wrap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity;\n  if (isArray(init)) {\n    var assembled = init.map(function (v) {\n      return assembleInit(v, isExpr, wrap);\n    });\n    return isExpr ? \"[\".concat(assembled.join(', '), \"]\") : assembled;\n  } else if (isDateTime(init)) {\n    if (isExpr) {\n      return wrap(dateTimeToExpr(init));\n    } else {\n      return wrap(dateTimeToTimestamp(init));\n    }\n  }\n  return isExpr ? wrap(stringify(init)) : init;\n}\nexport function assembleUnitSelectionSignals(model, signals) {\n  var _a;\n  var _iterator = _createForOfIteratorHelper(vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var selCmpt = _step.value;\n      var name = selCmpt.name;\n      var modifyExpr = \"\".concat(name).concat(TUPLE, \", \").concat(selCmpt.resolve === 'global' ? 'true' : \"{unit: \".concat(unitName(model), \"}\"));\n      var _iterator2 = _createForOfIteratorHelper(selectionCompilers),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var c = _step2.value;\n          if (!c.defined(selCmpt)) continue;\n          if (c.signals) signals = c.signals(model, selCmpt, signals);\n          if (c.modifyExpr) modifyExpr = c.modifyExpr(model, selCmpt, modifyExpr);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      signals.push({\n        name: name + MODIFY,\n        on: [{\n          events: {\n            signal: selCmpt.name + TUPLE\n          },\n          update: \"modify(\".concat(stringValue(selCmpt.name + STORE), \", \").concat(modifyExpr, \")\")\n        }]\n      });\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleFacetSignals(model, signals) {\n  if (model.component.selection && keys(model.component.selection).length) {\n    var name = stringValue(model.getName('cell'));\n    signals.unshift({\n      name: 'facet',\n      value: {},\n      on: [{\n        events: parseSelector('mousemove', 'scope'),\n        update: \"isTuple(facet) ? facet : group(\".concat(name, \").datum\")\n      }]\n    });\n  }\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleTopLevelSignals(model, signals) {\n  var _a;\n  var hasSelections = false;\n  var _iterator3 = _createForOfIteratorHelper(vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})),\n    _step3;\n  try {\n    var _loop = function _loop() {\n      var selCmpt = _step3.value;\n      var name = selCmpt.name;\n      var store = stringValue(name + STORE);\n      var hasSg = signals.filter(function (s) {\n        return s.name === name;\n      });\n      if (hasSg.length === 0) {\n        var resolve = selCmpt.resolve === 'global' ? 'union' : selCmpt.resolve;\n        var isPoint = selCmpt.type === 'point' ? ', true, true)' : ')';\n        signals.push({\n          name: selCmpt.name,\n          update: \"\".concat(VL_SELECTION_RESOLVE, \"(\").concat(store, \", \").concat(stringValue(resolve)).concat(isPoint)\n        });\n      }\n      hasSelections = true;\n      var _iterator4 = _createForOfIteratorHelper(selectionCompilers),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var c = _step4.value;\n          if (c.defined(selCmpt) && c.topLevelSignals) {\n            signals = c.topLevelSignals(model, selCmpt, signals);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    };\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  if (hasSelections) {\n    var hasUnit = signals.filter(function (s) {\n      return s.name === 'unit';\n    });\n    if (hasUnit.length === 0) {\n      signals.unshift({\n        name: 'unit',\n        value: {},\n        on: [{\n          events: 'mousemove',\n          update: 'isTuple(group()) ? group() : unit'\n        }]\n      });\n    }\n  }\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleUnitSelectionData(model, data) {\n  var _a;\n  var dataCopy = _toConsumableArray(data);\n  var unit = unitName(model, {\n    escape: false\n  });\n  var _iterator5 = _createForOfIteratorHelper(vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})),\n    _step5;\n  try {\n    var _loop2 = function _loop2() {\n      var selCmpt = _step5.value;\n      var store = {\n        name: selCmpt.name + STORE\n      };\n      if (selCmpt.project.hasSelectionId) {\n        store.transform = [{\n          type: 'collect',\n          sort: {\n            field: SELECTION_ID\n          }\n        }];\n      }\n      if (selCmpt.init) {\n        var fields = selCmpt.project.items.map(function (proj) {\n          var signals = proj.signals,\n            rest = __rest(proj, [\"signals\"]);\n          return rest;\n        });\n        store.values = selCmpt.project.hasSelectionId ? selCmpt.init.map(function (i) {\n          return _defineProperty({\n            unit: unit\n          }, SELECTION_ID, assembleInit(i, false)[0]);\n        }) : selCmpt.init.map(function (i) {\n          return {\n            unit: unit,\n            fields: fields,\n            values: assembleInit(i, false)\n          };\n        });\n      }\n      var contains = dataCopy.filter(function (d) {\n        return d.name === selCmpt.name + STORE;\n      });\n      if (!contains.length) {\n        dataCopy.push(store);\n      }\n    };\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      _loop2();\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  return dataCopy;\n}\nexport function assembleUnitSelectionMarks(model, marks) {\n  var _a;\n  var _iterator6 = _createForOfIteratorHelper(vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var selCmpt = _step6.value;\n      var _iterator7 = _createForOfIteratorHelper(selectionCompilers),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var c = _step7.value;\n          if (c.defined(selCmpt) && c.marks) {\n            marks = c.marks(model, selCmpt, marks);\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  return marks;\n}\nexport function assembleLayerSelectionMarks(model, marks) {\n  var _iterator8 = _createForOfIteratorHelper(model.children),\n    _step8;\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var child = _step8.value;\n      if (isUnitModel(child)) {\n        marks = assembleUnitSelectionMarks(child, marks);\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n  return marks;\n}\nexport function assembleSelectionScaleDomain(model, extent, scaleCmpt, domain) {\n  var parsedExtent = parseSelectionExtent(model, extent.param, extent);\n  return {\n    signal: hasContinuousDomain(scaleCmpt.get('type')) && isArray(domain) && domain[0] > domain[1] ? \"isValid(\".concat(parsedExtent, \") && reverse(\").concat(parsedExtent, \")\") : parsedExtent\n  };\n}\nfunction cleanupEmptyOnArray(signals) {\n  return signals.map(function (s) {\n    if (s.on && !s.on.length) delete s.on;\n    return s;\n  });\n}","map":{"version":3,"sources":["../../../../src/compile/selection/assemble.ts"],"names":[],"mappings":";;;;;;;;;;;;;AACA,SAAQ,aAAa,QAAO,qBAAqB;AACjD,SAAQ,QAAQ,EAAE,OAAO,EAAE,WAAW,QAAO,WAAW;AACxD,SAAQ,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,oBAAoB,EAAE,KAAK,EAAE,kBAAkB,QAAO,GAAG;AAC1F,SAAQ,cAAc,EAAE,UAAU,EAAE,mBAAmB,QAAO,gBAAgB;AAC9E,SAAQ,mBAAmB,QAAO,aAAa;AAC/C,SAA+D,YAAY,QAAO,iBAAiB;AACnG,SAAQ,IAAI,EAAE,SAAS,EAAE,IAAI,QAAO,YAAY;AAIhD,SAAQ,WAAW,QAAc,UAAU;AAG3C,SAAQ,oBAAoB,QAAO,SAAS;AAE5C,OAAM,SAAU,YAAY,CAC1B,IAAmG,EAEzC;EAAA,IAD1D,MAAM,uEAAG,IAAI;EAAA,IACb,IAAA,uEAAkD,QAAQ;EAE1D,IAAI,OAAO,CAAC,IAAI,CAAC,EAAE;IACjB,IAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,UAAA,CAAC;MAAA,OAAI,YAAY,CAAC,CAAC,EAAE,MAAM,EAAE,IAAI,CAAC;IAAA,EAAC;IAC9D,OAAO,MAAM,cAAO,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,SAAM,SAAS;GACxD,MAAM,IAAI,UAAU,CAAC,IAAI,CAAC,EAAE;IAC3B,IAAI,MAAM,EAAE;MACV,OAAO,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;KAClC,MAAM;MACL,OAAO,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;IACvC;EACF;EACD,OAAO,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI;AAC9C;AAEA,OAAM,SAAU,4BAA4B,CAAC,KAAgB,EAAE,OAAiB,EAAA;;6CACxD,IAAI,CAAC,CAAA,EAAA,GAAA,KAAK,CAAC,SAAS,CAAC,SAAS,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,CAAA,CAAE,CAAC;IAAA;EAAA;IAA3D,oDAA6D;MAAA,IAAlD,OAAO;MAChB,IAAM,IAAI,GAAG,OAAO,CAAC,IAAI;MACzB,IAAI,UAAU,aAAM,IAAI,SAAG,KAAK,eAAK,OAAO,CAAC,OAAO,KAAK,QAAQ,GAAG,MAAM,oBAAa,QAAQ,CAAC,KAAK,CAAC,MAAG,CAAE;MAAC,4CAE5F,kBAAkB;QAAA;MAAA;QAAlC,uDAAoC;UAAA,IAAzB,CAAC;UACV,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;UACzB,IAAI,CAAC,CAAC,OAAO,EAAE,OAAO,GAAG,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,OAAO,EAAE,OAAO,CAAC;UAC3D,IAAI,CAAC,CAAC,UAAU,EAAE,UAAU,GAAG,CAAC,CAAC,UAAU,CAAC,KAAK,EAAE,OAAO,EAAE,UAAU,CAAC;;MACxE;QAAA;MAAA;QAAA;MAAA;MAED,OAAO,CAAC,IAAI,CAAC;QACX,IAAI,EAAE,IAAI,GAAG,MAAM;QACnB,EAAE,EAAE,CACF;UACE,MAAM,EAAE;YAAC,MAAM,EAAE,OAAO,CAAC,IAAI,GAAG;UAAK,CAAC;UACtC,MAAM,mBAAY,WAAW,CAAC,OAAO,CAAC,IAAI,GAAG,KAAK,CAAC,eAAK,UAAU;SACnE;OAEJ,CAAC;;EACH;IAAA;EAAA;IAAA;EAAA;EAED,OAAO,mBAAmB,CAAC,OAAO,CAAC;AACrC;AAEA,OAAM,SAAU,oBAAoB,CAAC,KAAiB,EAAE,OAAiB,EAAA;EACvE,IAAI,KAAK,CAAC,SAAS,CAAC,SAAS,IAAI,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,MAAM,EAAE;IACvE,IAAM,IAAI,GAAG,WAAW,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;IAC/C,OAAO,CAAC,OAAO,CAAC;MACd,IAAI,EAAE,OAAO;MACb,KAAK,EAAE,CAAA,CAAE;MACT,EAAE,EAAE,CACF;QACE,MAAM,EAAE,aAAa,CAAC,WAAW,EAAE,OAAO,CAAC;QAC3C,MAAM,2CAAoC,IAAI;OAC/C;KAEJ,CAAC;EACH;EAED,OAAO,mBAAmB,CAAC,OAAO,CAAC;AACrC;AAEA,OAAM,SAAU,uBAAuB,CAAC,KAAgB,EAAE,OAAiB,EAAA;;EACzE,IAAI,aAAa,GAAG,KAAK;EAAC,4CACJ,IAAI,CAAC,CAAA,EAAA,GAAA,KAAK,CAAC,SAAS,CAAC,SAAS,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,CAAA,CAAE,CAAC;IAAA;EAAA;IAAA;MAAA,IAAhD,OAAO;MAChB,IAAM,IAAI,GAAG,OAAO,CAAC,IAAI;MACzB,IAAM,KAAK,GAAG,WAAW,CAAC,IAAI,GAAG,KAAK,CAAC;MACvC,IAAM,KAAK,GAAG,OAAO,CAAC,MAAM,CAAC,UAAA,CAAC;QAAA,OAAI,CAAC,CAAC,IAAI,KAAK,IAAI;MAAA,EAAC;MAClD,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;QACtB,IAAM,OAAO,GAAG,OAAO,CAAC,OAAO,KAAK,QAAQ,GAAG,OAAO,GAAG,OAAO,CAAC,OAAO;QACxE,IAAM,OAAO,GAAG,OAAO,CAAC,IAAI,KAAK,OAAO,GAAG,eAAe,GAAG,GAAG;QAChE,OAAO,CAAC,IAAI,CAAC;UACX,IAAI,EAAE,OAAO,CAAC,IAAI;UAClB,MAAM,YAAK,oBAAoB,cAAI,KAAK,eAAK,WAAW,CAAC,OAAO,CAAC,SAAG,OAAO;SAC5E,CAAC;MACH;MACD,aAAa,GAAG,IAAI;MAAC,4CAEL,kBAAkB;QAAA;MAAA;QAAlC,uDAAoC;UAAA,IAAzB,CAAC;UACV,IAAI,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,eAAe,EAAE;YAC3C,OAAO,GAAG,CAAC,CAAC,eAAe,CAAC,KAAK,EAAE,OAAO,EAAE,OAAO,CAAC;UACrD;;MACF;QAAA;MAAA;QAAA;MAAA;IAAA;IAlBH,uDAA6D;MAAA;;EAmB5D;IAAA;EAAA;IAAA;EAAA;EAED,IAAI,aAAa,EAAE;IACjB,IAAM,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC,UAAA,CAAC;MAAA,OAAI,CAAC,CAAC,IAAI,KAAK,MAAM;IAAA,EAAC;IACtD,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;MACxB,OAAO,CAAC,OAAO,CAAC;QACd,IAAI,EAAE,MAAM;QACZ,KAAK,EAAE,CAAA,CAAE;QACT,EAAE,EAAE,CAAC;UAAC,MAAM,EAAE,WAAW;UAAE,MAAM,EAAE;QAAmC,CAAC;OACxE,CAAC;IACH;EACF;EAED,OAAO,mBAAmB,CAAC,OAAO,CAAC;AACrC;AAEA,OAAM,SAAU,yBAAyB,CAAC,KAAgB,EAAE,IAAuB,EAAA;;EACjF,IAAM,QAAQ,sBAAO,IAAI,CAAC;EAC1B,IAAM,IAAI,GAAG,QAAQ,CAAC,KAAK,EAAE;IAAC,MAAM,EAAE;EAAK,CAAC,CAAC;EAAC,4CAExB,IAAI,CAAC,CAAA,EAAA,GAAA,KAAK,CAAC,SAAS,CAAC,SAAS,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,CAAA,CAAE,CAAC;IAAA;EAAA;IAAA;MAAA,IAAhD,OAAO;MAChB,IAAM,KAAK,GAAW;QAAC,IAAI,EAAE,OAAO,CAAC,IAAI,GAAG;MAAK,CAAC;MAElD,IAAI,OAAO,CAAC,OAAO,CAAC,cAAc,EAAE;QAClC,KAAK,CAAC,SAAS,GAAG,CAAC;UAAC,IAAI,EAAE,SAAS;UAAE,IAAI,EAAE;YAAC,KAAK,EAAE;UAAY;QAAC,CAAC,CAAC;MACnE;MAED,IAAI,OAAO,CAAC,IAAI,EAAE;QAChB,IAAM,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,UAAA,IAAI,EAAG;UACxC,IAAC,OAAO,GAAa,IAAI,CAAxB,OAAO;YAAK,IAAI,GAAA,MAAA,CAAI,IAAI,EAAzB,CAAA,SAAA,CAAkB,CAAO;UAC/B,OAAO,IAAI;QACb,CAAC,CAAC;QAEF,KAAK,CAAC,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,cAAc,GACzC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,UAAA,CAAC;UAAA;YAAM,IAAI,EAAJ;UAAI,GAAG,YAAY,EAAG,YAAY,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC;QAAA,CAAE,CAAC,GAC1E,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,UAAA,CAAC;UAAA,OAAK;YAAC,IAAI,EAAJ,IAAI;YAAE,MAAM,EAAN,MAAM;YAAE,MAAM,EAAE,YAAY,CAAC,CAAC,EAAE,KAAK;UAAC,CAAC;QAAA,CAAC,CAAC;MAC5E;MAED,IAAM,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,UAAA,CAAC;QAAA,OAAI,CAAC,CAAC,IAAI,KAAK,OAAO,CAAC,IAAI,GAAG,KAAK;MAAA,EAAC;MACtE,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;QACpB,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC;;IACrB;IArBH,uDAA6D;MAAA;;EAsB5D;IAAA;EAAA;IAAA;EAAA;EAED,OAAO,QAAQ;AACjB;AAEA,OAAM,SAAU,0BAA0B,CAAC,KAAgB,EAAE,KAAY,EAAA;;8CACjD,IAAI,CAAC,CAAA,EAAA,GAAA,KAAK,CAAC,SAAS,CAAC,SAAS,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,CAAA,CAAE,CAAC;IAAA;EAAA;IAA3D,uDAA6D;MAAA,IAAlD,OAAO;MAAA,4CACA,kBAAkB;QAAA;MAAA;QAAlC,uDAAoC;UAAA,IAAzB,CAAC;UACV,IAAI,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE;YACjC,KAAK,GAAG,CAAC,CAAC,KAAK,CAAC,KAAK,EAAE,OAAO,EAAE,KAAK,CAAC;UACvC;;MACF;QAAA;MAAA;QAAA;MAAA;;EACF;IAAA;EAAA;IAAA;EAAA;EAED,OAAO,KAAK;AACd;AAEA,OAAM,SAAU,2BAA2B,CAAC,KAAiB,EAAE,KAAY,EAAA;EAAA,4CACrD,KAAK,CAAC,QAAQ;IAAA;EAAA;IAAlC,uDAAoC;MAAA,IAAzB,KAAK;MACd,IAAI,WAAW,CAAC,KAAK,CAAC,EAAE;QACtB,KAAK,GAAG,0BAA0B,CAAC,KAAK,EAAE,KAAK,CAAC;MACjD;;EACF;IAAA;EAAA;IAAA;EAAA;EAED,OAAO,KAAK;AACd;AAEA,OAAM,SAAU,4BAA4B,CAC1C,KAAY,EACZ,MAAuB,EACvB,SAAyB,EACzB,MAAgB,EAAA;EAEhB,IAAM,YAAY,GAAG,oBAAoB,CAAC,KAAK,EAAE,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC;EAEtE,OAAO;IACL,MAAM,EACJ,mBAAmB,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,IAAI,OAAO,CAAC,MAAM,CAAC,IAAI,MAAM,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,qBACvE,YAAY,0BAAgB,YAAY,SACnD;GACP;AACH;AAEA,SAAS,mBAAmB,CAAC,OAAiB,EAAA;EAC5C,OAAO,OAAO,CAAC,GAAG,CAAC,UAAA,CAAC,EAAG;IACrB,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,EAAE;IACrC,OAAO,CAAC;EACV,CAAC,CAAC;AACJ","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { parseSelector } from 'vega-event-selector';\nimport { identity, isArray, stringValue } from 'vega-util';\nimport { MODIFY, STORE, unitName, VL_SELECTION_RESOLVE, TUPLE, selectionCompilers } from '.';\nimport { dateTimeToExpr, isDateTime, dateTimeToTimestamp } from '../../datetime';\nimport { hasContinuousDomain } from '../../scale';\nimport { SELECTION_ID } from '../../selection';\nimport { keys, stringify, vals } from '../../util';\nimport { isUnitModel } from '../model';\nimport { parseSelectionExtent } from './parse';\nexport function assembleInit(init, isExpr = true, wrap = identity) {\n    if (isArray(init)) {\n        const assembled = init.map(v => assembleInit(v, isExpr, wrap));\n        return isExpr ? `[${assembled.join(', ')}]` : assembled;\n    }\n    else if (isDateTime(init)) {\n        if (isExpr) {\n            return wrap(dateTimeToExpr(init));\n        }\n        else {\n            return wrap(dateTimeToTimestamp(init));\n        }\n    }\n    return isExpr ? wrap(stringify(init)) : init;\n}\nexport function assembleUnitSelectionSignals(model, signals) {\n    var _a;\n    for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {\n        const name = selCmpt.name;\n        let modifyExpr = `${name}${TUPLE}, ${selCmpt.resolve === 'global' ? 'true' : `{unit: ${unitName(model)}}`}`;\n        for (const c of selectionCompilers) {\n            if (!c.defined(selCmpt))\n                continue;\n            if (c.signals)\n                signals = c.signals(model, selCmpt, signals);\n            if (c.modifyExpr)\n                modifyExpr = c.modifyExpr(model, selCmpt, modifyExpr);\n        }\n        signals.push({\n            name: name + MODIFY,\n            on: [\n                {\n                    events: { signal: selCmpt.name + TUPLE },\n                    update: `modify(${stringValue(selCmpt.name + STORE)}, ${modifyExpr})`\n                }\n            ]\n        });\n    }\n    return cleanupEmptyOnArray(signals);\n}\nexport function assembleFacetSignals(model, signals) {\n    if (model.component.selection && keys(model.component.selection).length) {\n        const name = stringValue(model.getName('cell'));\n        signals.unshift({\n            name: 'facet',\n            value: {},\n            on: [\n                {\n                    events: parseSelector('mousemove', 'scope'),\n                    update: `isTuple(facet) ? facet : group(${name}).datum`\n                }\n            ]\n        });\n    }\n    return cleanupEmptyOnArray(signals);\n}\nexport function assembleTopLevelSignals(model, signals) {\n    var _a;\n    let hasSelections = false;\n    for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {\n        const name = selCmpt.name;\n        const store = stringValue(name + STORE);\n        const hasSg = signals.filter(s => s.name === name);\n        if (hasSg.length === 0) {\n            const resolve = selCmpt.resolve === 'global' ? 'union' : selCmpt.resolve;\n            const isPoint = selCmpt.type === 'point' ? ', true, true)' : ')';\n            signals.push({\n                name: selCmpt.name,\n                update: `${VL_SELECTION_RESOLVE}(${store}, ${stringValue(resolve)}${isPoint}`\n            });\n        }\n        hasSelections = true;\n        for (const c of selectionCompilers) {\n            if (c.defined(selCmpt) && c.topLevelSignals) {\n                signals = c.topLevelSignals(model, selCmpt, signals);\n            }\n        }\n    }\n    if (hasSelections) {\n        const hasUnit = signals.filter(s => s.name === 'unit');\n        if (hasUnit.length === 0) {\n            signals.unshift({\n                name: 'unit',\n                value: {},\n                on: [{ events: 'mousemove', update: 'isTuple(group()) ? group() : unit' }]\n            });\n        }\n    }\n    return cleanupEmptyOnArray(signals);\n}\nexport function assembleUnitSelectionData(model, data) {\n    var _a;\n    const dataCopy = [...data];\n    const unit = unitName(model, { escape: false });\n    for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {\n        const store = { name: selCmpt.name + STORE };\n        if (selCmpt.project.hasSelectionId) {\n            store.transform = [{ type: 'collect', sort: { field: SELECTION_ID } }];\n        }\n        if (selCmpt.init) {\n            const fields = selCmpt.project.items.map(proj => {\n                const { signals } = proj, rest = __rest(proj, [\"signals\"]);\n                return rest;\n            });\n            store.values = selCmpt.project.hasSelectionId\n                ? selCmpt.init.map(i => ({ unit, [SELECTION_ID]: assembleInit(i, false)[0] }))\n                : selCmpt.init.map(i => ({ unit, fields, values: assembleInit(i, false) }));\n        }\n        const contains = dataCopy.filter(d => d.name === selCmpt.name + STORE);\n        if (!contains.length) {\n            dataCopy.push(store);\n        }\n    }\n    return dataCopy;\n}\nexport function assembleUnitSelectionMarks(model, marks) {\n    var _a;\n    for (const selCmpt of vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {\n        for (const c of selectionCompilers) {\n            if (c.defined(selCmpt) && c.marks) {\n                marks = c.marks(model, selCmpt, marks);\n            }\n        }\n    }\n    return marks;\n}\nexport function assembleLayerSelectionMarks(model, marks) {\n    for (const child of model.children) {\n        if (isUnitModel(child)) {\n            marks = assembleUnitSelectionMarks(child, marks);\n        }\n    }\n    return marks;\n}\nexport function assembleSelectionScaleDomain(model, extent, scaleCmpt, domain) {\n    const parsedExtent = parseSelectionExtent(model, extent.param, extent);\n    return {\n        signal: hasContinuousDomain(scaleCmpt.get('type')) && isArray(domain) && domain[0] > domain[1]\n            ? `isValid(${parsedExtent}) && reverse(${parsedExtent})`\n            : parsedExtent\n    };\n}\nfunction cleanupEmptyOnArray(signals) {\n    return signals.map(s => {\n        if (s.on && !s.on.length)\n            delete s.on;\n        return s;\n    });\n}\n//# sourceMappingURL=assemble.js.map"]},"metadata":{},"sourceType":"module"}