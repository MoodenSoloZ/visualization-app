{"ast":null,"code":"import { parseSelector } from 'vega-event-selector';\nimport { X, Y } from '../../channel';\nimport { BRUSH as INTERVAL_BRUSH } from './interval';\nimport scalesCompiler, { domain } from './scales';\nvar ANCHOR = '_translate_anchor';\nvar DELTA = '_translate_delta';\nvar translate = {\n  defined: function defined(selCmpt) {\n    return selCmpt.type === 'interval' && selCmpt.translate;\n  },\n  signals: function signals(model, selCmpt, _signals) {\n    var name = selCmpt.name;\n    var hasScales = scalesCompiler.defined(selCmpt);\n    var anchor = name + ANCHOR;\n    var _selCmpt$project$hasC = selCmpt.project.hasChannel,\n      x = _selCmpt$project$hasC.x,\n      y = _selCmpt$project$hasC.y;\n    var events = parseSelector(selCmpt.translate, 'scope');\n    if (!hasScales) {\n      events = events.map(function (e) {\n        return e.between[0].markname = name + INTERVAL_BRUSH, e;\n      });\n    }\n    _signals.push({\n      name: anchor,\n      value: {},\n      on: [{\n        events: events.map(function (e) {\n          return e.between[0];\n        }),\n        update: '{x: x(unit), y: y(unit)' + (x !== undefined ? \", extent_x: \".concat(hasScales ? domain(model, X) : \"slice(\".concat(x.signals.visual, \")\")) : '') + (y !== undefined ? \", extent_y: \".concat(hasScales ? domain(model, Y) : \"slice(\".concat(y.signals.visual, \")\")) : '') + '}'\n      }]\n    }, {\n      name: name + DELTA,\n      value: {},\n      on: [{\n        events: events,\n        update: \"{x: \".concat(anchor, \".x - x(unit), y: \").concat(anchor, \".y - y(unit)}\")\n      }]\n    });\n    if (x !== undefined) {\n      onDelta(model, selCmpt, x, 'width', _signals);\n    }\n    if (y !== undefined) {\n      onDelta(model, selCmpt, y, 'height', _signals);\n    }\n    return _signals;\n  }\n};\nexport default translate;\nfunction onDelta(model, selCmpt, proj, size, signals) {\n  var _a, _b;\n  var name = selCmpt.name;\n  var anchor = name + ANCHOR;\n  var delta = name + DELTA;\n  var channel = proj.channel;\n  var hasScales = scalesCompiler.defined(selCmpt);\n  var signal = signals.filter(function (s) {\n    return s.name === proj.signals[hasScales ? 'data' : 'visual'];\n  })[0];\n  var sizeSg = model.getSizeSignalRef(size).signal;\n  var scaleCmpt = model.getScaleComponent(channel);\n  var scaleType = scaleCmpt.get('type');\n  var reversed = scaleCmpt.get('reverse'); // scale parsing sets this flag for fieldDef.sort\n  var sign = !hasScales ? '' : channel === X ? reversed ? '' : '-' : reversed ? '-' : '';\n  var extent = \"\".concat(anchor, \".extent_\").concat(channel);\n  var offset = \"\".concat(sign).concat(delta, \".\").concat(channel, \" / \").concat(hasScales ? \"\".concat(sizeSg) : \"span(\".concat(extent, \")\"));\n  var panFn = !hasScales ? 'panLinear' : scaleType === 'log' ? 'panLog' : scaleType === 'symlog' ? 'panSymlog' : scaleType === 'pow' ? 'panPow' : 'panLinear';\n  var arg = !hasScales ? '' : scaleType === 'pow' ? \", \".concat((_a = scaleCmpt.get('exponent')) !== null && _a !== void 0 ? _a : 1) : scaleType === 'symlog' ? \", \".concat((_b = scaleCmpt.get('constant')) !== null && _b !== void 0 ? _b : 1) : '';\n  var update = \"\".concat(panFn, \"(\").concat(extent, \", \").concat(offset).concat(arg, \")\");\n  signal.on.push({\n    events: {\n      signal: delta\n    },\n    update: hasScales ? update : \"clampRange(\".concat(update, \", 0, \").concat(sizeSg, \")\")\n  });\n}","map":{"version":3,"sources":["../../../../src/compile/selection/translate.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { parseSelector } from 'vega-event-selector';\nimport { X, Y } from '../../channel';\nimport { BRUSH as INTERVAL_BRUSH } from './interval';\nimport scalesCompiler, { domain } from './scales';\nconst ANCHOR = '_translate_anchor';\nconst DELTA = '_translate_delta';\nconst translate = {\n    defined: selCmpt => {\n        return selCmpt.type === 'interval' && selCmpt.translate;\n    },\n    signals: (model, selCmpt, signals) => {\n        const name = selCmpt.name;\n        const hasScales = scalesCompiler.defined(selCmpt);\n        const anchor = name + ANCHOR;\n        const { x, y } = selCmpt.project.hasChannel;\n        let events = parseSelector(selCmpt.translate, 'scope');\n        if (!hasScales) {\n            events = events.map(e => ((e.between[0].markname = name + INTERVAL_BRUSH), e));\n        }\n        signals.push({\n            name: anchor,\n            value: {},\n            on: [\n                {\n                    events: events.map(e => e.between[0]),\n                    update: '{x: x(unit), y: y(unit)' +\n                        (x !== undefined ? `, extent_x: ${hasScales ? domain(model, X) : `slice(${x.signals.visual})`}` : '') +\n                        (y !== undefined ? `, extent_y: ${hasScales ? domain(model, Y) : `slice(${y.signals.visual})`}` : '') +\n                        '}'\n                }\n            ]\n        }, {\n            name: name + DELTA,\n            value: {},\n            on: [\n                {\n                    events,\n                    update: `{x: ${anchor}.x - x(unit), y: ${anchor}.y - y(unit)}`\n                }\n            ]\n        });\n        if (x !== undefined) {\n            onDelta(model, selCmpt, x, 'width', signals);\n        }\n        if (y !== undefined) {\n            onDelta(model, selCmpt, y, 'height', signals);\n        }\n        return signals;\n    }\n};\nexport default translate;\nfunction onDelta(model, selCmpt, proj, size, signals) {\n    var _a, _b;\n    const name = selCmpt.name;\n    const anchor = name + ANCHOR;\n    const delta = name + DELTA;\n    const channel = proj.channel;\n    const hasScales = scalesCompiler.defined(selCmpt);\n    const signal = signals.filter(s => s.name === proj.signals[hasScales ? 'data' : 'visual'])[0];\n    const sizeSg = model.getSizeSignalRef(size).signal;\n    const scaleCmpt = model.getScaleComponent(channel);\n    const scaleType = scaleCmpt.get('type');\n    const reversed = scaleCmpt.get('reverse'); // scale parsing sets this flag for fieldDef.sort\n    const sign = !hasScales ? '' : channel === X ? (reversed ? '' : '-') : reversed ? '-' : '';\n    const extent = `${anchor}.extent_${channel}`;\n    const offset = `${sign}${delta}.${channel} / ${hasScales ? `${sizeSg}` : `span(${extent})`}`;\n    const panFn = !hasScales\n        ? 'panLinear'\n        : scaleType === 'log'\n            ? 'panLog'\n            : scaleType === 'symlog'\n                ? 'panSymlog'\n                : scaleType === 'pow'\n                    ? 'panPow'\n                    : 'panLinear';\n    const arg = !hasScales\n        ? ''\n        : scaleType === 'pow'\n            ? `, ${(_a = scaleCmpt.get('exponent')) !== null && _a !== void 0 ? _a : 1}`\n            : scaleType === 'symlog'\n                ? `, ${(_b = scaleCmpt.get('constant')) !== null && _b !== void 0 ? _b : 1}`\n                : '';\n    const update = `${panFn}(${extent}, ${offset}${arg})`;\n    signal.on.push({\n        events: { signal: delta },\n        update: hasScales ? update : `clampRange(${update}, 0, ${sizeSg})`\n    });\n}\n//# sourceMappingURL=translate.js.map"]},"metadata":{},"sourceType":"module"}