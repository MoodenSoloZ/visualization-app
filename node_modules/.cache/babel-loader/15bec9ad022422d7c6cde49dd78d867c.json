{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { getMainChannelFromOffsetChannel, isXorYOffset, SCALE_CHANNELS, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef } from '../../channeldef';\nimport { channelHasNestedOffsetScale } from '../../encoding';\nimport * as log from '../../log';\nimport { GEOSHAPE } from '../../mark';\nimport { NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES, scaleCompatible, scaleTypePrecedence } from '../../scale';\nimport { GEOJSON } from '../../type';\nimport { keys } from '../../util';\nimport { isUnitModel } from '../model';\nimport { defaultScaleResolve } from '../resolve';\nimport { mergeValuesWithExplicit, tieBreakByComparing } from '../split';\nimport { ScaleComponent } from './component';\nimport { parseScaleDomain } from './domain';\nimport { parseScaleProperty, parseScaleRange } from './properties';\nimport { scaleType } from './type';\nexport function parseScales(model) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    ignoreRange = _ref.ignoreRange;\n  parseScaleCore(model);\n  parseScaleDomain(model);\n  var _iterator = _createForOfIteratorHelper(NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var prop = _step.value;\n      parseScaleProperty(model, prop);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  if (!ignoreRange) {\n    // range depends on zero\n    parseScaleRange(model);\n  }\n}\nexport function parseScaleCore(model) {\n  if (isUnitModel(model)) {\n    model.component.scales = parseUnitScaleCore(model);\n  } else {\n    model.component.scales = parseNonUnitScaleCore(model);\n  }\n}\n/**\n * Parse scales for all channels of a model.\n */\nfunction parseUnitScaleCore(model) {\n  var encoding = model.encoding,\n    mark = model.mark,\n    markDef = model.markDef;\n  var scaleComponents = {};\n  var _iterator2 = _createForOfIteratorHelper(SCALE_CHANNELS),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var channel = _step2.value;\n      var fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]); // must be typed def to have scale\n      // Don't generate scale for shape of geoshape\n      if (fieldOrDatumDef && mark === GEOSHAPE && channel === SHAPE && fieldOrDatumDef.type === GEOJSON) {\n        continue;\n      }\n      var specifiedScale = fieldOrDatumDef && fieldOrDatumDef['scale'];\n      if (isXorYOffset(channel)) {\n        var mainChannel = getMainChannelFromOffsetChannel(channel);\n        if (!channelHasNestedOffsetScale(encoding, mainChannel)) {\n          // Don't generate scale when the offset encoding shouldn't yield a nested scale\n          if (specifiedScale) {\n            log.warn(log.message.offsetEncodingScaleIgnored(channel));\n          }\n          continue;\n        }\n      }\n      if (fieldOrDatumDef && specifiedScale !== null && specifiedScale !== false) {\n        specifiedScale !== null && specifiedScale !== void 0 ? specifiedScale : specifiedScale = {};\n        var hasNestedOffsetScale = channelHasNestedOffsetScale(encoding, channel);\n        var sType = scaleType(specifiedScale, channel, fieldOrDatumDef, markDef, hasNestedOffsetScale);\n        scaleComponents[channel] = new ScaleComponent(model.scaleName(\"\".concat(channel), true), {\n          value: sType,\n          explicit: specifiedScale.type === sType\n        });\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return scaleComponents;\n}\nvar scaleTypeTieBreaker = tieBreakByComparing(function (st1, st2) {\n  return scaleTypePrecedence(st1) - scaleTypePrecedence(st2);\n});\nfunction parseNonUnitScaleCore(model) {\n  var _a;\n  var _b;\n  var scaleComponents = model.component.scales = {};\n  var scaleTypeWithExplicitIndex = {};\n  var resolve = model.component.resolve;\n  // Parse each child scale and determine if a particular channel can be merged.\n  var _iterator3 = _createForOfIteratorHelper(model.children),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var child = _step3.value;\n      parseScaleCore(child);\n      // Instead of always merging right away -- check if it is compatible to merge first!\n      var _iterator5 = _createForOfIteratorHelper(keys(child.component.scales)),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var channel = _step5.value;\n          // if resolve is undefined, set default first\n          (_a = (_b = resolve.scale)[channel]) !== null && _a !== void 0 ? _a : _b[channel] = defaultScaleResolve(channel, model);\n          if (resolve.scale[channel] === 'shared') {\n            var explicitScaleType = scaleTypeWithExplicitIndex[channel];\n            var childScaleType = child.component.scales[channel].getWithExplicit('type');\n            if (explicitScaleType) {\n              if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {\n                // merge scale component if type are compatible\n                scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit(explicitScaleType, childScaleType, 'type', 'scale', scaleTypeTieBreaker);\n              } else {\n                // Otherwise, update conflicting channel to be independent\n                resolve.scale[channel] = 'independent';\n                // Remove from the index so they don't get merged\n                delete scaleTypeWithExplicitIndex[channel];\n              }\n            } else {\n              scaleTypeWithExplicitIndex[channel] = childScaleType;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n    // Merge each channel listed in the index\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  var _iterator4 = _createForOfIteratorHelper(keys(scaleTypeWithExplicitIndex)),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var _channel = _step4.value;\n      // Create new merged scale component\n      var name = model.scaleName(_channel, true);\n      var typeWithExplicit = scaleTypeWithExplicitIndex[_channel];\n      scaleComponents[_channel] = new ScaleComponent(name, typeWithExplicit);\n      // rename each child and mark them as merged\n      var _iterator6 = _createForOfIteratorHelper(model.children),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _child = _step6.value;\n          var childScale = _child.component.scales[_channel];\n          if (childScale) {\n            _child.renameScale(childScale.get('name'), name);\n            childScale.merged = true;\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return scaleComponents;\n}","map":{"version":3,"sources":["../../../../src/compile/scale/parse.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { getMainChannelFromOffsetChannel, isXorYOffset, SCALE_CHANNELS, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef } from '../../channeldef';\nimport { channelHasNestedOffsetScale } from '../../encoding';\nimport * as log from '../../log';\nimport { GEOSHAPE } from '../../mark';\nimport { NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES, scaleCompatible, scaleTypePrecedence } from '../../scale';\nimport { GEOJSON } from '../../type';\nimport { keys } from '../../util';\nimport { isUnitModel } from '../model';\nimport { defaultScaleResolve } from '../resolve';\nimport { mergeValuesWithExplicit, tieBreakByComparing } from '../split';\nimport { ScaleComponent } from './component';\nimport { parseScaleDomain } from './domain';\nimport { parseScaleProperty, parseScaleRange } from './properties';\nimport { scaleType } from './type';\nexport function parseScales(model, { ignoreRange } = {}) {\n    parseScaleCore(model);\n    parseScaleDomain(model);\n    for (const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES) {\n        parseScaleProperty(model, prop);\n    }\n    if (!ignoreRange) {\n        // range depends on zero\n        parseScaleRange(model);\n    }\n}\nexport function parseScaleCore(model) {\n    if (isUnitModel(model)) {\n        model.component.scales = parseUnitScaleCore(model);\n    }\n    else {\n        model.component.scales = parseNonUnitScaleCore(model);\n    }\n}\n/**\n * Parse scales for all channels of a model.\n */\nfunction parseUnitScaleCore(model) {\n    const { encoding, mark, markDef } = model;\n    const scaleComponents = {};\n    for (const channel of SCALE_CHANNELS) {\n        const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]); // must be typed def to have scale\n        // Don't generate scale for shape of geoshape\n        if (fieldOrDatumDef && mark === GEOSHAPE && channel === SHAPE && fieldOrDatumDef.type === GEOJSON) {\n            continue;\n        }\n        let specifiedScale = fieldOrDatumDef && fieldOrDatumDef['scale'];\n        if (isXorYOffset(channel)) {\n            const mainChannel = getMainChannelFromOffsetChannel(channel);\n            if (!channelHasNestedOffsetScale(encoding, mainChannel)) {\n                // Don't generate scale when the offset encoding shouldn't yield a nested scale\n                if (specifiedScale) {\n                    log.warn(log.message.offsetEncodingScaleIgnored(channel));\n                }\n                continue;\n            }\n        }\n        if (fieldOrDatumDef && specifiedScale !== null && specifiedScale !== false) {\n            specifiedScale !== null && specifiedScale !== void 0 ? specifiedScale : (specifiedScale = {});\n            const hasNestedOffsetScale = channelHasNestedOffsetScale(encoding, channel);\n            const sType = scaleType(specifiedScale, channel, fieldOrDatumDef, markDef, hasNestedOffsetScale);\n            scaleComponents[channel] = new ScaleComponent(model.scaleName(`${channel}`, true), {\n                value: sType,\n                explicit: specifiedScale.type === sType\n            });\n        }\n    }\n    return scaleComponents;\n}\nconst scaleTypeTieBreaker = tieBreakByComparing((st1, st2) => scaleTypePrecedence(st1) - scaleTypePrecedence(st2));\nfunction parseNonUnitScaleCore(model) {\n    var _a;\n    var _b;\n    const scaleComponents = (model.component.scales = {});\n    const scaleTypeWithExplicitIndex = {};\n    const resolve = model.component.resolve;\n    // Parse each child scale and determine if a particular channel can be merged.\n    for (const child of model.children) {\n        parseScaleCore(child);\n        // Instead of always merging right away -- check if it is compatible to merge first!\n        for (const channel of keys(child.component.scales)) {\n            // if resolve is undefined, set default first\n            (_a = (_b = resolve.scale)[channel]) !== null && _a !== void 0 ? _a : (_b[channel] = defaultScaleResolve(channel, model));\n            if (resolve.scale[channel] === 'shared') {\n                const explicitScaleType = scaleTypeWithExplicitIndex[channel];\n                const childScaleType = child.component.scales[channel].getWithExplicit('type');\n                if (explicitScaleType) {\n                    if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {\n                        // merge scale component if type are compatible\n                        scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit(explicitScaleType, childScaleType, 'type', 'scale', scaleTypeTieBreaker);\n                    }\n                    else {\n                        // Otherwise, update conflicting channel to be independent\n                        resolve.scale[channel] = 'independent';\n                        // Remove from the index so they don't get merged\n                        delete scaleTypeWithExplicitIndex[channel];\n                    }\n                }\n                else {\n                    scaleTypeWithExplicitIndex[channel] = childScaleType;\n                }\n            }\n        }\n    }\n    // Merge each channel listed in the index\n    for (const channel of keys(scaleTypeWithExplicitIndex)) {\n        // Create new merged scale component\n        const name = model.scaleName(channel, true);\n        const typeWithExplicit = scaleTypeWithExplicitIndex[channel];\n        scaleComponents[channel] = new ScaleComponent(name, typeWithExplicit);\n        // rename each child and mark them as merged\n        for (const child of model.children) {\n            const childScale = child.component.scales[channel];\n            if (childScale) {\n                child.renameScale(childScale.get('name'), name);\n                childScale.merged = true;\n            }\n        }\n    }\n    return scaleComponents;\n}\n//# sourceMappingURL=parse.js.map"]},"metadata":{},"sourceType":"module"}