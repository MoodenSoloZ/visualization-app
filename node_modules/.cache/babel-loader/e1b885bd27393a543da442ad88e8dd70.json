{"ast":null,"code":"import _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { isFieldDef } from '../../channeldef';\nimport { pathGroupingFields } from '../../encoding';\nimport { isImputeSequence } from '../../transform';\nimport { duplicate, hash as _hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport var ImputeNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(ImputeNode, _DataFlowNode);\n  var _super = _createSuper(ImputeNode);\n  function ImputeNode(parent, transform) {\n    var _this;\n    _classCallCheck(this, ImputeNode);\n    _this = _super.call(this, parent);\n    _this.transform = transform;\n    return _this;\n  }\n  _createClass(ImputeNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new ImputeNode(null, duplicate(this.transform));\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      var _a;\n      return new Set([this.transform.impute, this.transform.key].concat(_toConsumableArray((_a = this.transform.groupby) !== null && _a !== void 0 ? _a : [])));\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set([this.transform.impute]);\n    }\n  }, {\n    key: \"processSequence\",\n    value: function processSequence(keyvals) {\n      var _keyvals$start = keyvals.start,\n        start = _keyvals$start === void 0 ? 0 : _keyvals$start,\n        stop = keyvals.stop,\n        step = keyvals.step;\n      var result = [start, stop].concat(_toConsumableArray(step ? [step] : [])).join(',');\n      return {\n        signal: \"sequence(\".concat(result, \")\")\n      };\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"Impute \".concat(_hash(this.transform));\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      var _this$transform = this.transform,\n        impute = _this$transform.impute,\n        key = _this$transform.key,\n        keyvals = _this$transform.keyvals,\n        method = _this$transform.method,\n        groupby = _this$transform.groupby,\n        value = _this$transform.value,\n        _this$transform$frame = _this$transform.frame,\n        frame = _this$transform$frame === void 0 ? [null, null] : _this$transform$frame;\n      var imputeTransform = Object.assign(Object.assign(Object.assign(Object.assign({\n        type: 'impute',\n        field: impute,\n        key: key\n      }, keyvals ? {\n        keyvals: isImputeSequence(keyvals) ? this.processSequence(keyvals) : keyvals\n      } : {}), {\n        method: 'value'\n      }), groupby ? {\n        groupby: groupby\n      } : {}), {\n        value: !method || method === 'value' ? value : null\n      });\n      if (method && method !== 'value') {\n        var deriveNewField = Object.assign({\n          type: 'window',\n          as: [\"imputed_\".concat(impute, \"_value\")],\n          ops: [method],\n          fields: [impute],\n          frame: frame,\n          ignorePeers: false\n        }, groupby ? {\n          groupby: groupby\n        } : {});\n        var replaceOriginal = {\n          type: 'formula',\n          expr: \"datum.\".concat(impute, \" === null ? datum.imputed_\").concat(impute, \"_value : datum.\").concat(impute),\n          as: impute\n        };\n        return [imputeTransform, deriveNewField, replaceOriginal];\n      } else {\n        return [imputeTransform];\n      }\n    }\n  }], [{\n    key: \"makeFromTransform\",\n    value: function makeFromTransform(parent, imputeTransform) {\n      return new ImputeNode(parent, imputeTransform);\n    }\n  }, {\n    key: \"makeFromEncoding\",\n    value: function makeFromEncoding(parent, model) {\n      var encoding = model.encoding;\n      var xDef = encoding.x;\n      var yDef = encoding.y;\n      if (isFieldDef(xDef) && isFieldDef(yDef)) {\n        var imputedChannel = xDef.impute ? xDef : yDef.impute ? yDef : undefined;\n        if (imputedChannel === undefined) {\n          return undefined;\n        }\n        var keyChannel = xDef.impute ? yDef : yDef.impute ? xDef : undefined;\n        var _imputedChannel$imput = imputedChannel.impute,\n          method = _imputedChannel$imput.method,\n          value = _imputedChannel$imput.value,\n          frame = _imputedChannel$imput.frame,\n          keyvals = _imputedChannel$imput.keyvals;\n        var groupbyFields = pathGroupingFields(model.mark, encoding);\n        return new ImputeNode(parent, Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n          impute: imputedChannel.field,\n          key: keyChannel.field\n        }, method ? {\n          method: method\n        } : {}), value !== undefined ? {\n          value: value\n        } : {}), frame ? {\n          frame: frame\n        } : {}), keyvals !== undefined ? {\n          keyvals: keyvals\n        } : {}), groupbyFields.length ? {\n          groupby: groupbyFields\n        } : {}));\n      }\n      return null;\n    }\n  }]);\n  return ImputeNode;\n}(DataFlowNode);","map":{"version":3,"sources":["../../../../src/compile/data/impute.ts"],"names":[],"mappings":";;;;;AAMA,SAAQ,UAAU,QAAO,kBAAkB;AAC3C,SAAQ,kBAAkB,QAAO,gBAAgB;AACjD,SAAyC,gBAAgB,QAAO,iBAAiB;AACjF,SAAQ,SAAS,EAAE,IAAI,IAAJ,KAAI,QAAO,YAAY;AAE1C,SAAQ,YAAY,QAAO,YAAY;AAEvC,WAAa,UAAW;EAAA;EAAA;EAKtB,oBAAY,MAAoB,EAAmB,SAA0B,EAAA;IAAA;IAAA;IAC3E,0BAAM,MAAM;IADqC,MAAA,SAAS,GAAT,SAAS;IAAiB;EAE7E;EAAC;IAAA;IAAA,OANM,iBAAK;MACV,OAAO,IAAI,UAAU,CAAC,IAAI,EAAE,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;IACxD;EAAC;IAAA;IAAA,OAMM,2BAAe;;MACpB,OAAO,IAAI,GAAG,EAAE,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC,GAAG,4BAAM,CAAA,EAAA,GAAA,IAAI,CAAC,SAAS,CAAC,OAAO,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,EAAE,GAAG;IAChG;EAAC;IAAA;IAAA,OAEM,0BAAc;MACnB,OAAO,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;IACzC;EAAC;IAAA;IAAA,OAEO,yBAAgB,OAAuB,EAAA;MAC7C,qBAAgC,OAAO,CAAhC,KAAK;QAAL,KAAK,+BAAG,CAAC;QAAE,IAAI,GAAU,OAAO,CAArB,IAAI;QAAE,IAAI,GAAI,OAAO,CAAf,IAAI;MAC5B,IAAM,MAAM,GAAG,CAAC,KAAK,EAAE,IAAI,4BAAM,IAAI,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC;MAE/D,OAAO;QAAC,MAAM,qBAAc,MAAM;MAAG,CAAC;IACxC;EAAC;IAAA;IAAA,OAiCM,gBAAI;MACT,wBAAiB,KAAI,CAAC,IAAI,CAAC,SAAS,CAAC;IACvC;EAAC;IAAA;IAAA,OAEM,oBAAQ;MACb,sBAA6F,IAAI,CAAC,SAAS;QAApG,MAAM,mBAAN,MAAM;QAAE,GAAG,mBAAH,GAAG;QAAE,OAAO,mBAAP,OAAO;QAAE,MAAM,mBAAN,MAAM;QAAE,OAAO,mBAAP,OAAO;QAAE,KAAK,mBAAL,KAAK;QAAA,wCAAE,KAAK;QAAL,KAAK,sCAAG,CAAC,IAAI,EAAE,IAAI,CAAiB;MAEzF,IAAM,eAAe,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA;QACnB,IAAI,EAAE,QAAQ;QACd,KAAK,EAAE,MAAM;QACb,GAAG,EAAH;MAAG,CAAA,EACC,OAAO,GAAG;QAAC,OAAO,EAAE,gBAAgB,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,GAAG;MAAO,CAAC,GAAG,CAAA,CAAE,CAAC,EAAA;QAClG,MAAM,EAAE;MAAO,CAAA,CAAA,EACX,OAAO,GAAG;QAAC,OAAO,EAAP;MAAO,CAAC,GAAG,CAAA,CAAE,CAAC,EAAA;QAC7B,KAAK,EAAE,CAAC,MAAM,IAAI,MAAM,KAAK,OAAO,GAAG,KAAK,GAAG;MAAI,CAAA,CACpD;MAED,IAAI,MAAM,IAAI,MAAM,KAAK,OAAO,EAAE;QAChC,IAAM,cAAc,GAAA,MAAA,CAAA,MAAA,CAAA;UAClB,IAAI,EAAE,QAAQ;UACd,EAAE,EAAE,mBAAY,MAAM,YAAS;UAC/B,GAAG,EAAE,CAAC,MAAM,CAAC;UACb,MAAM,EAAE,CAAC,MAAM,CAAC;UAChB,KAAK,EAAL,KAAK;UACL,WAAW,EAAE;QAAK,CAAA,EACd,OAAO,GAAG;UAAC,OAAO,EAAP;QAAO,CAAC,GAAG,CAAA,CAAE,CAC7B;QACD,IAAM,eAAe,GAAuB;UAC1C,IAAI,EAAE,SAAS;UACf,IAAI,kBAAW,MAAM,uCAA6B,MAAM,4BAAkB,MAAM,CAAE;UAClF,EAAE,EAAE;SACL;QACD,OAAO,CAAC,eAAe,EAAE,cAAc,EAAE,eAAe,CAAC;OAC1D,MAAM;QACL,OAAO,CAAC,eAAe,CAAC;MACzB;IACH;EAAC;IAAA;IAAA,OAnEM,2BAAyB,MAAoB,EAAE,eAAgC,EAAA;MACpF,OAAO,IAAI,UAAU,CAAC,MAAM,EAAE,eAAe,CAAC;IAChD;EAAC;IAAA;IAAA,OAEM,0BAAwB,MAAoB,EAAE,KAAgB,EAAA;MACnE,IAAM,QAAQ,GAAG,KAAK,CAAC,QAAQ;MAC/B,IAAM,IAAI,GAAG,QAAQ,CAAC,CAAC;MACvB,IAAM,IAAI,GAAG,QAAQ,CAAC,CAAC;MAEvB,IAAI,UAAU,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC,EAAE;QACxC,IAAM,cAAc,GAAG,IAAI,CAAC,MAAM,GAAG,IAAI,GAAG,IAAI,CAAC,MAAM,GAAG,IAAI,GAAG,SAAS;QAC1E,IAAI,cAAc,KAAK,SAAS,EAAE;UAChC,OAAO,SAAS;QACjB;QACD,IAAM,UAAU,GAAG,IAAI,CAAC,MAAM,GAAG,IAAI,GAAG,IAAI,CAAC,MAAM,GAAG,IAAI,GAAG,SAAS;QACtE,4BAAwC,cAAc,CAAC,MAAM;UAAtD,MAAM,yBAAN,MAAM;UAAE,KAAK,yBAAL,KAAK;UAAE,KAAK,yBAAL,KAAK;UAAE,OAAO,yBAAP,OAAO;QACpC,IAAM,aAAa,GAAG,kBAAkB,CAAC,KAAK,CAAC,IAAI,EAAE,QAAQ,CAAC;QAE9D,OAAO,IAAI,UAAU,CAAC,MAAM,EAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA;UAC1B,MAAM,EAAE,cAAc,CAAC,KAAK;UAC5B,GAAG,EAAE,UAAU,CAAC;QAAK,CAAA,EACjB,MAAM,GAAG;UAAC,MAAM,EAAN;QAAM,CAAC,GAAG,CAAA,CAAE,CAAC,EACvB,KAAK,KAAK,SAAS,GAAG;UAAC,KAAK,EAAL;QAAK,CAAC,GAAG,CAAA,CAAE,CAAC,EACnC,KAAK,GAAG;UAAC,KAAK,EAAL;QAAK,CAAC,GAAG,CAAA,CAAE,CAAC,EACrB,OAAO,KAAK,SAAS,GAAG;UAAC,OAAO,EAAP;QAAO,CAAC,GAAG,CAAA,CAAE,CAAC,EACvC,aAAa,CAAC,MAAM,GAAG;UAAC,OAAO,EAAE;QAAa,CAAC,GAAG,CAAA,CAAE,CAAC,CACzD;MACH;MACD,OAAO,IAAI;IACb;EAAC;EAAA;AAAA,EArD6B,YAAY","sourceRoot":"","sourcesContent":["import { isFieldDef } from '../../channeldef';\nimport { pathGroupingFields } from '../../encoding';\nimport { isImputeSequence } from '../../transform';\nimport { duplicate, hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class ImputeNode extends DataFlowNode {\n    constructor(parent, transform) {\n        super(parent);\n        this.transform = transform;\n    }\n    clone() {\n        return new ImputeNode(null, duplicate(this.transform));\n    }\n    dependentFields() {\n        var _a;\n        return new Set([this.transform.impute, this.transform.key, ...((_a = this.transform.groupby) !== null && _a !== void 0 ? _a : [])]);\n    }\n    producedFields() {\n        return new Set([this.transform.impute]);\n    }\n    processSequence(keyvals) {\n        const { start = 0, stop, step } = keyvals;\n        const result = [start, stop, ...(step ? [step] : [])].join(',');\n        return { signal: `sequence(${result})` };\n    }\n    static makeFromTransform(parent, imputeTransform) {\n        return new ImputeNode(parent, imputeTransform);\n    }\n    static makeFromEncoding(parent, model) {\n        const encoding = model.encoding;\n        const xDef = encoding.x;\n        const yDef = encoding.y;\n        if (isFieldDef(xDef) && isFieldDef(yDef)) {\n            const imputedChannel = xDef.impute ? xDef : yDef.impute ? yDef : undefined;\n            if (imputedChannel === undefined) {\n                return undefined;\n            }\n            const keyChannel = xDef.impute ? yDef : yDef.impute ? xDef : undefined;\n            const { method, value, frame, keyvals } = imputedChannel.impute;\n            const groupbyFields = pathGroupingFields(model.mark, encoding);\n            return new ImputeNode(parent, Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ impute: imputedChannel.field, key: keyChannel.field }, (method ? { method } : {})), (value !== undefined ? { value } : {})), (frame ? { frame } : {})), (keyvals !== undefined ? { keyvals } : {})), (groupbyFields.length ? { groupby: groupbyFields } : {})));\n        }\n        return null;\n    }\n    hash() {\n        return `Impute ${hash(this.transform)}`;\n    }\n    assemble() {\n        const { impute, key, keyvals, method, groupby, value, frame = [null, null] } = this.transform;\n        const imputeTransform = Object.assign(Object.assign(Object.assign(Object.assign({ type: 'impute', field: impute, key }, (keyvals ? { keyvals: isImputeSequence(keyvals) ? this.processSequence(keyvals) : keyvals } : {})), { method: 'value' }), (groupby ? { groupby } : {})), { value: !method || method === 'value' ? value : null });\n        if (method && method !== 'value') {\n            const deriveNewField = Object.assign({ type: 'window', as: [`imputed_${impute}_value`], ops: [method], fields: [impute], frame, ignorePeers: false }, (groupby ? { groupby } : {}));\n            const replaceOriginal = {\n                type: 'formula',\n                expr: `datum.${impute} === null ? datum.imputed_${impute}_value : datum.${impute}`,\n                as: impute\n            };\n            return [imputeTransform, deriveNewField, replaceOriginal];\n        }\n        else {\n            return [imputeTransform];\n        }\n    }\n}\n//# sourceMappingURL=impute.js.map"]},"metadata":{},"sourceType":"module"}