{"ast":null,"code":"import _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { isArray } from 'vega-util';\nimport { COLUMN, FACET, ROW } from '../channel';\nimport { hasConditionalFieldOrDatumDef, isFieldOrDatumDef, isValueDef } from '../channeldef';\nimport { boxPlotNormalizer } from '../compositemark/boxplot';\nimport { errorBandNormalizer } from '../compositemark/errorband';\nimport { errorBarNormalizer } from '../compositemark/errorbar';\nimport { channelHasField } from '../encoding';\nimport * as log from '../log';\nimport { isFacetMapping } from '../spec/facet';\nimport { SpecMapper } from '../spec/map';\nimport { isLayerRepeatSpec } from '../spec/repeat';\nimport { isUnitSpec } from '../spec/unit';\nimport { isEmpty, keys, omit, varName } from '../util';\nimport { isSignalRef } from '../vega.schema';\nimport { PathOverlayNormalizer } from './pathoverlay';\nimport { replaceRepeaterInEncoding, replaceRepeaterInFacet } from './repeater';\nimport { RuleForRangedLineNormalizer } from './ruleforrangedline';\nexport var CoreNormalizer = /*#__PURE__*/function (_SpecMapper) {\n  _inherits(CoreNormalizer, _SpecMapper);\n  var _super = _createSuper(CoreNormalizer);\n  function CoreNormalizer() {\n    var _this;\n    _classCallCheck(this, CoreNormalizer);\n    _this = _super.apply(this, arguments);\n    _this.nonFacetUnitNormalizers = [boxPlotNormalizer, errorBarNormalizer, errorBandNormalizer, new PathOverlayNormalizer(), new RuleForRangedLineNormalizer()];\n    return _this;\n  }\n  _createClass(CoreNormalizer, [{\n    key: \"map\",\n    value: function map(spec, params) {\n      // Special handling for a faceted unit spec as it can return a facet spec, not just a layer or unit spec like a normal unit spec.\n      if (isUnitSpec(spec)) {\n        var hasRow = channelHasField(spec.encoding, ROW);\n        var hasColumn = channelHasField(spec.encoding, COLUMN);\n        var hasFacet = channelHasField(spec.encoding, FACET);\n        if (hasRow || hasColumn || hasFacet) {\n          return this.mapFacetedUnit(spec, params);\n        }\n      }\n      return _get(_getPrototypeOf(CoreNormalizer.prototype), \"map\", this).call(this, spec, params);\n    }\n    // This is for normalizing non-facet unit\n  }, {\n    key: \"mapUnit\",\n    value: function mapUnit(spec, params) {\n      var parentEncoding = params.parentEncoding,\n        parentProjection = params.parentProjection;\n      var encoding = replaceRepeaterInEncoding(spec.encoding, params.repeater);\n      var specWithReplacedEncoding = Object.assign(Object.assign({}, spec), encoding ? {\n        encoding: encoding\n      } : {});\n      if (parentEncoding || parentProjection) {\n        return this.mapUnitWithParentEncodingOrProjection(specWithReplacedEncoding, params);\n      }\n      var normalizeLayerOrUnit = this.mapLayerOrUnit.bind(this);\n      var _iterator = _createForOfIteratorHelper(this.nonFacetUnitNormalizers),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var unitNormalizer = _step.value;\n          if (unitNormalizer.hasMatchingType(specWithReplacedEncoding, params.config)) {\n            return unitNormalizer.run(specWithReplacedEncoding, params, normalizeLayerOrUnit);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return specWithReplacedEncoding;\n    }\n  }, {\n    key: \"mapRepeat\",\n    value: function mapRepeat(spec, params) {\n      if (isLayerRepeatSpec(spec)) {\n        return this.mapLayerRepeat(spec, params);\n      } else {\n        return this.mapNonLayerRepeat(spec, params);\n      }\n    }\n  }, {\n    key: \"mapLayerRepeat\",\n    value: function mapLayerRepeat(spec, params) {\n      var _this2 = this;\n      var repeat = spec.repeat,\n        childSpec = spec.spec,\n        rest = __rest(spec, [\"repeat\", \"spec\"]);\n      var row = repeat.row,\n        column = repeat.column,\n        layer = repeat.layer;\n      var _params$repeater = params.repeater,\n        repeater = _params$repeater === void 0 ? {} : _params$repeater,\n        _params$repeaterPrefi = params.repeaterPrefix,\n        repeaterPrefix = _params$repeaterPrefi === void 0 ? '' : _params$repeaterPrefi;\n      if (row || column) {\n        return this.mapRepeat(Object.assign(Object.assign({}, spec), {\n          repeat: Object.assign(Object.assign({}, row ? {\n            row: row\n          } : {}), column ? {\n            column: column\n          } : {}),\n          spec: {\n            repeat: {\n              layer: layer\n            },\n            spec: childSpec\n          }\n        }), params);\n      } else {\n        return Object.assign(Object.assign({}, rest), {\n          layer: layer.map(function (layerValue) {\n            var childRepeater = Object.assign(Object.assign({}, repeater), {\n              layer: layerValue\n            });\n            var childName = \"\".concat((childSpec.name || '') + repeaterPrefix, \"child__layer_\").concat(varName(layerValue));\n            var child = _this2.mapLayerOrUnit(childSpec, Object.assign(Object.assign({}, params), {\n              repeater: childRepeater,\n              repeaterPrefix: childName\n            }));\n            child.name = childName;\n            return child;\n          })\n        });\n      }\n    }\n  }, {\n    key: \"mapNonLayerRepeat\",\n    value: function mapNonLayerRepeat(spec, params) {\n      var _a;\n      var _spec = spec,\n        repeat = _spec.repeat,\n        childSpec = _spec.spec,\n        data = _spec.data,\n        remainingProperties = __rest(spec, [\"repeat\", \"spec\", \"data\"]);\n      if (!isArray(repeat) && spec.columns) {\n        // is repeat with row/column\n        spec = omit(spec, ['columns']);\n        log.warn(log.message.columnsNotSupportByRowCol('repeat'));\n      }\n      var concat = [];\n      var _params$repeater2 = params.repeater,\n        repeater = _params$repeater2 === void 0 ? {} : _params$repeater2,\n        _params$repeaterPrefi2 = params.repeaterPrefix,\n        repeaterPrefix = _params$repeaterPrefi2 === void 0 ? '' : _params$repeaterPrefi2;\n      var row = !isArray(repeat) && repeat.row || [repeater ? repeater.row : null];\n      var column = !isArray(repeat) && repeat.column || [repeater ? repeater.column : null];\n      var repeatValues = isArray(repeat) && repeat || [repeater ? repeater.repeat : null];\n      // cross product\n      var _iterator2 = _createForOfIteratorHelper(repeatValues),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var repeatValue = _step2.value;\n          var _iterator3 = _createForOfIteratorHelper(row),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var rowValue = _step3.value;\n              var _iterator4 = _createForOfIteratorHelper(column),\n                _step4;\n              try {\n                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                  var columnValue = _step4.value;\n                  var childRepeater = {\n                    repeat: repeatValue,\n                    row: rowValue,\n                    column: columnValue,\n                    layer: repeater.layer\n                  };\n                  var childName = (childSpec.name || '') + repeaterPrefix + 'child__' + (isArray(repeat) ? \"\".concat(varName(repeatValue)) : (repeat.row ? \"row_\".concat(varName(rowValue)) : '') + (repeat.column ? \"column_\".concat(varName(columnValue)) : ''));\n                  var child = this.map(childSpec, Object.assign(Object.assign({}, params), {\n                    repeater: childRepeater,\n                    repeaterPrefix: childName\n                  }));\n                  child.name = childName;\n                  // we move data up\n                  concat.push(omit(child, ['data']));\n                }\n              } catch (err) {\n                _iterator4.e(err);\n              } finally {\n                _iterator4.f();\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var columns = isArray(repeat) ? spec.columns : repeat.column ? repeat.column.length : 1;\n      return Object.assign(Object.assign({\n        data: (_a = childSpec.data) !== null && _a !== void 0 ? _a : data,\n        align: 'all'\n      }, remainingProperties), {\n        columns: columns,\n        concat: concat\n      });\n    }\n  }, {\n    key: \"mapFacet\",\n    value: function mapFacet(spec, params) {\n      var _spec2 = spec,\n        facet = _spec2.facet;\n      if (isFacetMapping(facet) && spec.columns) {\n        // is facet with row/column\n        spec = omit(spec, ['columns']);\n        log.warn(log.message.columnsNotSupportByRowCol('facet'));\n      }\n      return _get(_getPrototypeOf(CoreNormalizer.prototype), \"mapFacet\", this).call(this, spec, params);\n    }\n  }, {\n    key: \"mapUnitWithParentEncodingOrProjection\",\n    value: function mapUnitWithParentEncodingOrProjection(spec, params) {\n      var encoding = spec.encoding,\n        projection = spec.projection;\n      var parentEncoding = params.parentEncoding,\n        parentProjection = params.parentProjection,\n        config = params.config;\n      var mergedProjection = mergeProjection({\n        parentProjection: parentProjection,\n        projection: projection\n      });\n      var mergedEncoding = mergeEncoding({\n        parentEncoding: parentEncoding,\n        encoding: replaceRepeaterInEncoding(encoding, params.repeater)\n      });\n      return this.mapUnit(Object.assign(Object.assign(Object.assign({}, spec), mergedProjection ? {\n        projection: mergedProjection\n      } : {}), mergedEncoding ? {\n        encoding: mergedEncoding\n      } : {}), {\n        config: config\n      });\n    }\n  }, {\n    key: \"mapFacetedUnit\",\n    value: function mapFacetedUnit(spec, normParams) {\n      // New encoding in the inside spec should not contain row / column\n      // as row/column should be moved to facet\n      var _a = spec.encoding,\n        row = _a.row,\n        column = _a.column,\n        facet = _a.facet,\n        encoding = __rest(_a, [\"row\", \"column\", \"facet\"]);\n      // Mark and encoding should be moved into the inner spec\n      var mark = spec.mark,\n        width = spec.width,\n        projection = spec.projection,\n        height = spec.height,\n        view = spec.view,\n        params = spec.params,\n        _ = spec.encoding,\n        outerSpec = __rest(spec, [\"mark\", \"width\", \"projection\", \"height\", \"view\", \"params\", \"encoding\"]);\n      var _this$getFacetMapping = this.getFacetMappingAndLayout({\n          row: row,\n          column: column,\n          facet: facet\n        }, normParams),\n        facetMapping = _this$getFacetMapping.facetMapping,\n        layout = _this$getFacetMapping.layout;\n      var newEncoding = replaceRepeaterInEncoding(encoding, normParams.repeater);\n      return this.mapFacet(Object.assign(Object.assign(Object.assign({}, outerSpec), layout), {\n        // row / column has higher precedence than facet\n        facet: facetMapping,\n        spec: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, width ? {\n          width: width\n        } : {}), height ? {\n          height: height\n        } : {}), view ? {\n          view: view\n        } : {}), projection ? {\n          projection: projection\n        } : {}), {\n          mark: mark,\n          encoding: newEncoding\n        }), params ? {\n          params: params\n        } : {})\n      }), normParams);\n    }\n  }, {\n    key: \"getFacetMappingAndLayout\",\n    value: function getFacetMappingAndLayout(facets, params) {\n      var _a;\n      var row = facets.row,\n        column = facets.column,\n        facet = facets.facet;\n      if (row || column) {\n        if (facet) {\n          log.warn(log.message.facetChannelDropped([].concat(_toConsumableArray(row ? [ROW] : []), _toConsumableArray(column ? [COLUMN] : []))));\n        }\n        var facetMapping = {};\n        var layout = {};\n        for (var _i = 0, _arr = [ROW, COLUMN]; _i < _arr.length; _i++) {\n          var channel = _arr[_i];\n          var def = facets[channel];\n          if (def) {\n            var align = def.align,\n              center = def.center,\n              spacing = def.spacing,\n              columns = def.columns,\n              defWithoutLayout = __rest(def, [\"align\", \"center\", \"spacing\", \"columns\"]);\n            facetMapping[channel] = defWithoutLayout;\n            for (var _i2 = 0, _arr2 = ['align', 'center', 'spacing']; _i2 < _arr2.length; _i2++) {\n              var prop = _arr2[_i2];\n              if (def[prop] !== undefined) {\n                (_a = layout[prop]) !== null && _a !== void 0 ? _a : layout[prop] = {};\n                layout[prop][channel] = def[prop];\n              }\n            }\n          }\n        }\n        return {\n          facetMapping: facetMapping,\n          layout: layout\n        };\n      } else {\n        var _align = facet.align,\n          _center = facet.center,\n          _spacing = facet.spacing,\n          _columns = facet.columns,\n          _facetMapping = __rest(facet, [\"align\", \"center\", \"spacing\", \"columns\"]);\n        return {\n          facetMapping: replaceRepeaterInFacet(_facetMapping, params.repeater),\n          layout: Object.assign(Object.assign(Object.assign(Object.assign({}, _align ? {\n            align: _align\n          } : {}), _center ? {\n            center: _center\n          } : {}), _spacing ? {\n            spacing: _spacing\n          } : {}), _columns ? {\n            columns: _columns\n          } : {})\n        };\n      }\n    }\n  }, {\n    key: \"mapLayer\",\n    value: function mapLayer(spec, _a) {\n      // Special handling for extended layer spec\n      var parentEncoding = _a.parentEncoding,\n        parentProjection = _a.parentProjection,\n        otherParams = __rest(_a, [\"parentEncoding\", \"parentProjection\"]);\n      var encoding = spec.encoding,\n        projection = spec.projection,\n        rest = __rest(spec, [\"encoding\", \"projection\"]);\n      var params = Object.assign(Object.assign({}, otherParams), {\n        parentEncoding: mergeEncoding({\n          parentEncoding: parentEncoding,\n          encoding: encoding,\n          layer: true\n        }),\n        parentProjection: mergeProjection({\n          parentProjection: parentProjection,\n          projection: projection\n        })\n      });\n      return _get(_getPrototypeOf(CoreNormalizer.prototype), \"mapLayer\", this).call(this, rest, params);\n    }\n  }]);\n  return CoreNormalizer;\n}(SpecMapper);\nfunction mergeEncoding(_ref) {\n  var parentEncoding = _ref.parentEncoding,\n    _ref$encoding = _ref.encoding,\n    encoding = _ref$encoding === void 0 ? {} : _ref$encoding,\n    layer = _ref.layer;\n  var merged = {};\n  if (parentEncoding) {\n    var channels = new Set([].concat(_toConsumableArray(keys(parentEncoding)), _toConsumableArray(keys(encoding))));\n    var _iterator5 = _createForOfIteratorHelper(channels),\n      _step5;\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var channel = _step5.value;\n        var channelDef = encoding[channel];\n        var parentChannelDef = parentEncoding[channel];\n        if (isFieldOrDatumDef(channelDef)) {\n          // Field/Datum Def can inherit properties from its parent\n          // Note that parentChannelDef doesn't have to be a field/datum def if the channelDef is already one.\n          var mergedChannelDef = Object.assign(Object.assign({}, parentChannelDef), channelDef);\n          merged[channel] = mergedChannelDef;\n        } else if (hasConditionalFieldOrDatumDef(channelDef)) {\n          merged[channel] = Object.assign(Object.assign({}, channelDef), {\n            condition: Object.assign(Object.assign({}, parentChannelDef), channelDef.condition)\n          });\n        } else if (channelDef || channelDef === null) {\n          merged[channel] = channelDef;\n        } else if (layer || isValueDef(parentChannelDef) || isSignalRef(parentChannelDef) || isFieldOrDatumDef(parentChannelDef) || isArray(parentChannelDef)) {\n          merged[channel] = parentChannelDef;\n        }\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n  } else {\n    merged = encoding;\n  }\n  return !merged || isEmpty(merged) ? undefined : merged;\n}\nfunction mergeProjection(opt) {\n  var parentProjection = opt.parentProjection,\n    projection = opt.projection;\n  if (parentProjection && projection) {\n    log.warn(log.message.projectionOverridden({\n      parentProjection: parentProjection,\n      projection: projection\n    }));\n  }\n  return projection !== null && projection !== void 0 ? projection : parentProjection;\n}","map":{"version":3,"sources":["../../../src/normalize/core.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AACA,SAAQ,OAAO,QAAO,WAAW;AACjC,SAAQ,MAAM,EAAE,KAAK,EAAE,GAAG,QAAO,YAAY;AAC7C,SAA0B,6BAA6B,EAAE,iBAAiB,EAAE,UAAU,QAAO,eAAe;AAE5G,SAAQ,iBAAiB,QAAO,0BAA0B;AAC1D,SAAQ,mBAAmB,QAAO,4BAA4B;AAC9D,SAAQ,kBAAkB,QAAO,2BAA2B;AAC5D,SAAQ,eAAe,QAAiB,aAAa;AAErD,OAAO,KAAK,GAAG,MAAM,QAAQ;AAK7B,SAKE,cAAc,QAET,eAAe;AAGtB,SAAQ,UAAU,QAAO,aAAa;AACtC,SAAQ,iBAAiB,QAAwD,gBAAgB;AACjG,SAAQ,UAAU,QAA2B,cAAc;AAC3D,SAAQ,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,OAAO,QAAO,SAAS;AACpD,SAAQ,WAAW,QAAO,gBAAgB;AAE1C,SAAQ,qBAAqB,QAAO,eAAe;AACnD,SAAQ,yBAAyB,EAAE,sBAAsB,QAAO,YAAY;AAC5E,SAAQ,2BAA2B,QAAO,qBAAqB;AAE/D,WAAa,cAAe;EAAA;EAAA;EAA5B,0BAAA;IAAA;IAAA;;IACU,MAAA,uBAAuB,GAAkC,CAC/D,iBAAiB,EACjB,kBAAkB,EAClB,mBAAmB,EACnB,IAAI,qBAAqB,EAAE,EAC3B,IAAI,2BAA2B,EAAE,CAClC;IAAC;EA+RJ;EAAC;IAAA;IAAA,OA7RQ,aAAI,IAA8E,EAAE,MAAwB,EAAA;MACjH;MACA,IAAI,UAAU,CAAC,IAAI,CAAC,EAAE;QACpB,IAAM,MAAM,GAAG,eAAe,CAAC,IAAI,CAAC,QAAQ,EAAE,GAAG,CAAC;QAClD,IAAM,SAAS,GAAG,eAAe,CAAC,IAAI,CAAC,QAAQ,EAAE,MAAM,CAAC;QACxD,IAAM,QAAQ,GAAG,eAAe,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAC;QAEtD,IAAI,MAAM,IAAI,SAAS,IAAI,QAAQ,EAAE;UACnC,OAAO,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,MAAM,CAAC;QACzC;MACF;MAED,+EAAiB,IAAI,EAAE,MAAM;IAC/B;IAEA;EAAA;IAAA;IAAA,OACO,iBAAQ,IAAqB,EAAE,MAAwB,EAAA;MAC5D,IAAO,cAAc,GAAsB,MAAM,CAA1C,cAAc;QAAE,gBAAgB,GAAI,MAAM,CAA1B,gBAAgB;MAEvC,IAAM,QAAQ,GAAG,yBAAyB,CAAC,IAAI,CAAC,QAAQ,EAAE,MAAM,CAAC,QAAQ,CAAC;MAE1E,IAAM,wBAAwB,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EACzB,IAAI,CAAA,EACH,QAAQ,GAAG;QAAC,QAAQ,EAAR;MAAQ,CAAC,GAAG,CAAA,CAAE,CAC/B;MAED,IAAI,cAAc,IAAI,gBAAgB,EAAE;QACtC,OAAO,IAAI,CAAC,qCAAqC,CAAC,wBAAwB,EAAE,MAAM,CAAC;MACpF;MAED,IAAM,oBAAoB,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC;MAAC,2CAE/B,IAAI,CAAC,uBAAuB;QAAA;MAAA;QAAzD,oDAA2D;UAAA,IAAhD,cAAc;UACvB,IAAI,cAAc,CAAC,eAAe,CAAC,wBAAwB,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE;YAC3E,OAAO,cAAc,CAAC,GAAG,CAAC,wBAAwB,EAAE,MAAM,EAAE,oBAAoB,CAAC;UAClF;;MACF;QAAA;MAAA;QAAA;MAAA;MAED,OAAO,wBAA8C;IACvD;EAAC;IAAA;IAAA,OAES,mBACR,IAAgB,EAChB,MAAwB,EAAA;MAExB,IAAI,iBAAiB,CAAC,IAAI,CAAC,EAAE;QAC3B,OAAO,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,MAAM,CAAC;OACzC,MAAM;QACL,OAAO,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,MAAM,CAAC;MAC5C;IACH;EAAC;IAAA;IAAA,OAEO,wBACN,IAAqB,EACrB,MAAwB,EAAA;MAAA;MAExB,IAAO,MAAM,GAA8B,IAAI,CAAxC,MAAM;QAAQ,SAAS,GAAa,IAAI,CAAhC,IAAI;QAAgB,IAAI,GAAA,MAAA,CAAI,IAAI,EAAzC,CAAA,QAAA,EAAA,MAAA,CAAkC,CAAO;MAC/C,IAAO,GAAG,GAAmB,MAAM,CAA5B,GAAG;QAAE,MAAM,GAAW,MAAM,CAAvB,MAAM;QAAE,KAAK,GAAI,MAAM,CAAf,KAAK;MAEzB,uBAA6C,MAAM,CAA5C,QAAQ;QAAR,QAAQ,iCAAG,CAAA,CAAE;QAAA,wBAAyB,MAAM,CAA7B,cAAc;QAAd,cAAc,sCAAG,EAAE;MAEzC,IAAI,GAAG,IAAI,MAAM,EAAE;QACjB,OAAO,IAAI,CAAC,SAAS,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAEd,IAAI,CAAA,EAAA;UACP,MAAM,EAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EACA,GAAG,GAAG;YAAC,GAAG,EAAH;UAAG,CAAC,GAAG,CAAA,CAAE,CAAC,EACjB,MAAM,GAAG;YAAC,MAAM,EAAN;UAAM,CAAC,GAAG,CAAA,CAAE,CAAC;UAE7B,IAAI,EAAE;YACJ,MAAM,EAAE;cAAC,KAAK,EAAL;YAAK,CAAC;YACf,IAAI,EAAE;UACP;QAAA,CAAA,CAAA,EAEH,MAAM,CACP;OACF,MAAM;QACL,OAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EACK,IAAI,CAAA,EAAA;UACP,KAAK,EAAE,KAAK,CAAC,GAAG,CAAC,UAAA,UAAU,EAAG;YAC5B,IAAM,aAAa,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EACd,QAAQ,CAAA,EAAA;cACX,KAAK,EAAE;YAAU,CAAA,CAClB;YAED,IAAM,SAAS,aAAM,CAAC,SAAS,CAAC,IAAI,IAAI,EAAE,IAAI,cAAc,0BAAgB,OAAO,CAAC,UAAU,CAAC,CAAE;YAEjG,IAAM,KAAK,GAAG,MAAI,CAAC,cAAc,CAAC,SAAS,EAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAM,MAAM,CAAA,EAAA;cAAE,QAAQ,EAAE,aAAa;cAAE,cAAc,EAAE;YAAS,CAAA,CAAA,CAAE;YAC7G,KAAK,CAAC,IAAI,GAAG,SAAS;YAEtB,OAAO,KAAK;UACd,CAAC;QAAC,CAAA,CAAA;MAEL;IACH;EAAC;IAAA;IAAA,OAEO,2BAAkB,IAAwB,EAAE,MAAwB,EAAA;;MAC1E,YAAgE,IAAI;QAA7D,MAAM,SAAN,MAAM;QAAQ,SAAS,SAAf,IAAI;QAAa,IAAI,SAAJ,IAAI;QAAK,mBAAmB,GAAA,MAAA,CAAI,IAAI,EAA9D,CAAA,QAAA,EAAA,MAAA,EAAA,MAAA,CAAuD,CAAO;MAEpE,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,OAAO,EAAE;QACpC;QACA,IAAI,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC,SAAS,CAAC,CAAC;QAC9B,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,yBAAyB,CAAC,QAAQ,CAAC,CAAC;MAC1D;MAED,IAAM,MAAM,GAAqB,EAAE;MAEnC,wBAA6C,MAAM,CAA5C,QAAQ;QAAR,QAAQ,kCAAG,CAAA,CAAE;QAAA,yBAAyB,MAAM,CAA7B,cAAc;QAAd,cAAc,uCAAG,EAAE;MAEzC,IAAM,GAAG,GAAI,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,MAAM,CAAC,GAAG,IAAK,CAAC,QAAQ,GAAG,QAAQ,CAAC,GAAG,GAAG,IAAI,CAAC;MAChF,IAAM,MAAM,GAAI,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,MAAM,CAAC,MAAM,IAAK,CAAC,QAAQ,GAAG,QAAQ,CAAC,MAAM,GAAG,IAAI,CAAC;MAEzF,IAAM,YAAY,GAAI,OAAO,CAAC,MAAM,CAAC,IAAI,MAAM,IAAK,CAAC,QAAQ,GAAG,QAAQ,CAAC,MAAM,GAAG,IAAI,CAAC;MAEvF;MAAA,4CAC0B,YAAY;QAAA;MAAA;QAAtC,uDAAwC;UAAA,IAA7B,WAAW;UAAA,4CACG,GAAG;YAAA;UAAA;YAA1B,uDAA4B;cAAA,IAAjB,QAAQ;cAAA,4CACS,MAAM;gBAAA;cAAA;gBAAhC,uDAAkC;kBAAA,IAAvB,WAAW;kBACpB,IAAM,aAAa,GAAG;oBACpB,MAAM,EAAE,WAAW;oBACnB,GAAG,EAAE,QAAQ;oBACb,MAAM,EAAE,WAAW;oBACnB,KAAK,EAAE,QAAQ,CAAC;mBACjB;kBAED,IAAM,SAAS,GACb,CAAC,SAAS,CAAC,IAAI,IAAI,EAAE,IACrB,cAAc,GACd,SAAS,IACR,OAAO,CAAC,MAAM,CAAC,aACT,OAAO,CAAC,WAAW,CAAC,IACvB,CAAC,MAAM,CAAC,GAAG,iBAAU,OAAO,CAAC,QAAQ,CAAC,IAAK,EAAE,KAC5C,MAAM,CAAC,MAAM,oBAAa,OAAO,CAAC,WAAW,CAAC,IAAK,EAAE,CAAC,CAAC;kBAE9D,IAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,EAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAM,MAAM,CAAA,EAAA;oBAAE,QAAQ,EAAE,aAAa;oBAAE,cAAc,EAAE;kBAAS,CAAA,CAAA,CAAE;kBAClG,KAAK,CAAC,IAAI,GAAG,SAAS;kBAEtB;kBACA,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,MAAM,CAAC,CAAmB,CAAC;;cACrD;gBAAA;cAAA;gBAAA;cAAA;;UACF;YAAA;UAAA;YAAA;UAAA;;MACF;QAAA;MAAA;QAAA;MAAA;MAED,IAAM,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC;MACzF,OAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA;QACE,IAAI,EAAE,CAAA,EAAA,GAAA,SAAS,CAAC,IAAI,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,IAAI;QAC5B,KAAK,EAAE;MAAK,CAAA,EACT,mBAAmB,CAAA,EAAA;QACtB,OAAO,EAAP,OAAO;QACP,MAAM,EAAN;MAAM,CAAA,CAAA;IAEV;EAAC;IAAA;IAAA,OAES,kBACR,IAAgE,EAChE,MAAwB,EAAA;MAExB,aAAgB,IAAI;QAAb,KAAK,UAAL,KAAK;MAEZ,IAAI,cAAc,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,OAAO,EAAE;QACzC;QACA,IAAI,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC,SAAS,CAAC,CAAC;QAC9B,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,yBAAyB,CAAC,OAAO,CAAC,CAAC;MACzD;MAED,oFAAsB,IAAI,EAAE,MAAM;IACpC;EAAC;IAAA;IAAA,OAEO,+CACN,IAA4B,EAC5B,MAAwB,EAAA;MAExB,IAAO,QAAQ,GAAgB,IAAI,CAA5B,QAAQ;QAAE,UAAU,GAAI,IAAI,CAAlB,UAAU;MAC3B,IAAO,cAAc,GAA8B,MAAM,CAAlD,cAAc;QAAE,gBAAgB,GAAY,MAAM,CAAlC,gBAAgB;QAAE,MAAM,GAAI,MAAM,CAAhB,MAAM;MAC/C,IAAM,gBAAgB,GAAG,eAAe,CAAC;QAAC,gBAAgB,EAAhB,gBAAgB;QAAE,UAAU,EAAV;MAAU,CAAC,CAAC;MACxE,IAAM,cAAc,GAAG,aAAa,CAAC;QACnC,cAAc,EAAd,cAAc;QACd,QAAQ,EAAE,yBAAyB,CAAC,QAAQ,EAAE,MAAM,CAAC,QAAQ;OAC9D,CAAC;MAEF,OAAO,IAAI,CAAC,OAAO,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAEZ,IAAI,CAAA,EACH,gBAAgB,GAAG;QAAC,UAAU,EAAE;MAAgB,CAAC,GAAG,CAAA,CAAE,CAAC,EACvD,cAAc,GAAG;QAAC,QAAQ,EAAE;MAAc,CAAC,GAAG,CAAA,CAAE,CAAC,EAEvD;QAAC,MAAM,EAAN;MAAM,CAAC,CACT;IACH;EAAC;IAAA;IAAA,OAEO,wBAAe,IAA4B,EAAE,UAA4B,EAAA;MAC/E;MACA;MACM,IAAA,EAAA,GAAoC,IAAI,CAAC,QAAzC;QAAC,GAAG,GAAe,EAA8B,CAAhD,GAAG;QAAE,MAAM,GAAO,EAA8B,CAA3C,MAAM;QAAE,KAAK,GAAA,EAA8B,CAAnC,KAAK;QAAK,QAAQ,GAAA,MAAA,CAAA,EAAA,EAAhC,CAAA,KAAA,EAAA,QAAA,EAAA,OAAA,CAAiC,CAAgB;MAEvD;MACA,IAAO,IAAI,GAAwE,IAAI,CAAhF,IAAI;QAAE,KAAK,GAAiE,IAAI,CAA1E,KAAK;QAAE,UAAU,GAAqD,IAAI,CAAnE,UAAU;QAAE,MAAM,GAA6C,IAAI,CAAvD,MAAM;QAAE,IAAI,GAAuC,IAAI,CAA/C,IAAI;QAAE,MAAM,GAA+B,IAAI,CAAzC,MAAM;QAAY,CAAC,GAAkB,IAAI,CAAjC,QAAQ;QAAQ,SAAS,GAAA,MAAA,CAAI,IAAI,EAAjF,CAAA,MAAA,EAAA,OAAA,EAAA,YAAA,EAAA,QAAA,EAAA,MAAA,EAAA,QAAA,EAAA,UAAA,CAA0E,CAAO;MAEvF,4BAA+B,IAAI,CAAC,wBAAwB,CAAC;UAAC,GAAG,EAAH,GAAG;UAAE,MAAM,EAAN,MAAM;UAAE,KAAK,EAAL;QAAK,CAAC,EAAE,UAAU,CAAC;QAAvF,YAAY,yBAAZ,YAAY;QAAE,MAAM,yBAAN,MAAM;MAE3B,IAAM,WAAW,GAAG,yBAAyB,CAAC,QAAQ,EAAE,UAAU,CAAC,QAAQ,CAAC;MAE5E,OAAO,IAAI,CAAC,QAAQ,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAEb,SAAS,CAAA,EACT,MAAM,CAAA,EAAA;QAET;QACA,KAAK,EAAE,YAAY;QACnB,IAAI,EAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EACE,KAAK,GAAG;UAAC,KAAK,EAAL;QAAK,CAAC,GAAG,CAAA,CAAE,CAAC,EACrB,MAAM,GAAG;UAAC,MAAM,EAAN;QAAM,CAAC,GAAG,CAAA,CAAE,CAAC,EACvB,IAAI,GAAG;UAAC,IAAI,EAAJ;QAAI,CAAC,GAAG,CAAA,CAAE,CAAC,EACnB,UAAU,GAAG;UAAC,UAAU,EAAV;QAAU,CAAC,GAAG,CAAA,CAAE,CAAC,EAAA;UACnC,IAAI,EAAJ,IAAI;UACJ,QAAQ,EAAE;QAAW,CAAA,CAAA,EACjB,MAAM,GAAG;UAAC,MAAM,EAAN;QAAM,CAAC,GAAG,CAAA,CAAE;MAAC,CAAA,CAAA,EAG/B,UAAU,CACX;IACH;EAAC;IAAA;IAAA,OAEO,kCACN,MAIC,EACD,MAAwB,EAAA;;MAExB,IAAO,GAAG,GAAmB,MAAM,CAA5B,GAAG;QAAE,MAAM,GAAW,MAAM,CAAvB,MAAM;QAAE,KAAK,GAAI,MAAM,CAAf,KAAK;MAEzB,IAAI,GAAG,IAAI,MAAM,EAAE;QACjB,IAAI,KAAK,EAAE;UACT,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,mBAAmB,8BAAM,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,sBAAO,MAAM,GAAG,CAAC,MAAM,CAAC,GAAG,EAAE,GAAG,CAAC;QAChG;QAED,IAAM,YAAY,GAAG,CAAA,CAAE;QACvB,IAAM,MAAM,GAAG,CAAA,CAAE;QAEjB,wBAAsB,CAAC,GAAG,EAAE,MAAM,CAAC,0BAAE;UAAhC,IAAM,OAAO;UAChB,IAAM,GAAG,GAAG,MAAM,CAAC,OAAO,CAAC;UAC3B,IAAI,GAAG,EAAE;YACP,IAAO,KAAK,GAAmD,GAAG,CAA3D,KAAK;cAAE,MAAM,GAA2C,GAAG,CAApD,MAAM;cAAE,OAAO,GAAkC,GAAG,CAA5C,OAAO;cAAE,OAAO,GAAyB,GAAG,CAAnC,OAAO;cAAK,gBAAgB,GAAA,MAAA,CAAI,GAAG,EAA5D,CAAA,OAAA,EAAA,QAAA,EAAA,SAAA,EAAA,SAAA,CAAsD,CAAM;YAClE,YAAY,CAAC,OAAO,CAAC,GAAG,gBAAgB;YAExC,0BAAmB,CAAC,OAAO,EAAE,QAAQ,EAAE,SAAS,CAAU,6BAAE;cAAvD,IAAM,IAAI;cACb,IAAI,GAAG,CAAC,IAAI,CAAC,KAAK,SAAS,EAAE;gBAC3B,CAAA,EAAA,GAAA,MAAM,CAAC,IAAI,CAAA,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAX,MAAM,CAAC,IAAI,CAAA,GAAM,CAAA,CAAE;gBACnB,MAAM,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC;cAClC;YACF;UACF;QACF;QAED,OAAO;UAAC,YAAY,EAAZ,YAAY;UAAE,MAAM,EAAN;QAAM,CAAC;OAC9B,MAAM;QACL,IAAO,MAAK,GAA+C,KAAK,CAAzD,KAAK;UAAE,OAAM,GAAuC,KAAK,CAAlD,MAAM;UAAE,QAAO,GAA8B,KAAK,CAA1C,OAAO;UAAE,QAAO,GAAqB,KAAK,CAAjC,OAAO;UAAK,aAAY,GAAA,MAAA,CAAI,KAAK,EAA1D,CAAA,OAAA,EAAA,QAAA,EAAA,SAAA,EAAA,SAAA,CAAkD,CAAQ;QAChE,OAAO;UACL,YAAY,EAAE,sBAAsB,CAAC,aAAY,EAAE,MAAM,CAAC,QAAQ,CAAC;UACnE,MAAM,EAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EACA,MAAK,GAAG;YAAC,KAAK,EAAL;UAAK,CAAC,GAAG,CAAA,CAAE,CAAC,EACrB,OAAM,GAAG;YAAC,MAAM,EAAN;UAAM,CAAC,GAAG,CAAA,CAAE,CAAC,EACvB,QAAO,GAAG;YAAC,OAAO,EAAP;UAAO,CAAC,GAAG,CAAA,CAAE,CAAC,EACzB,QAAO,GAAG;YAAC,OAAO,EAAP;UAAO,CAAC,GAAG,CAAA,CAAE;SAE/B;MACF;IACH;EAAC;IAAA;IAAA,OAEM,kBACL,IAAsB,EACtB,EAAoE,EAAA;MAEpE;MAFA,IAAC,cAAc,GAAkB,EAAmC,CAAnE,cAAc;QAAE,gBAAgB,GAAA,EAAmC,CAAnD,gBAAgB;QAAK,WAAW,GAAA,MAAA,CAAA,EAAA,EAAjD,CAAA,gBAAA,EAAA,kBAAA,CAAkD,CAAD;MAIjD,IAAO,QAAQ,GAAyB,IAAI,CAArC,QAAQ;QAAE,UAAU,GAAa,IAAI,CAA3B,UAAU;QAAK,IAAI,GAAA,MAAA,CAAI,IAAI,EAAtC,CAAA,UAAA,EAAA,YAAA,CAA+B,CAAO;MAC5C,IAAM,MAAM,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EACP,WAAW,CAAA,EAAA;QACd,cAAc,EAAE,aAAa,CAAC;UAAC,cAAc,EAAd,cAAc;UAAE,QAAQ,EAAR,QAAQ;UAAE,KAAK,EAAE;QAAI,CAAC,CAAC;QACtE,gBAAgB,EAAE,eAAe,CAAC;UAAC,gBAAgB,EAAhB,gBAAgB;UAAE,UAAU,EAAV;QAAU,CAAC;MAAC,CAAA,CAClE;MACD,oFAAsB,IAAI,EAAE,MAAM;IACpC;EAAC;EAAA;AAAA,EArSiC,UAAsE;AAwS1G,SAAS,aAAa,OAQrB;EAAA,IAPC,cAAc,QAAd,cAAc;IAAA,qBACd,QAAQ;IAAR,QAAQ,8BAAG,CAAA,CAAE;IACb,KAAK,QAAL,KAAK;EAML,IAAI,MAAM,GAAQ,CAAA,CAAE;EACpB,IAAI,cAAc,EAAE;IAClB,IAAM,QAAQ,GAAG,IAAI,GAAG,8BAAK,IAAI,CAAC,cAAc,CAAC,sBAAK,IAAI,CAAC,QAAQ,CAAC,GAAE;IAAC,4CACjD,QAAQ;MAAA;IAAA;MAA9B,uDAAgC;QAAA,IAArB,OAAO;QAChB,IAAM,UAAU,GAAG,QAAQ,CAAC,OAAO,CAAC;QACpC,IAAM,gBAAgB,GAAG,cAAc,CAAC,OAAO,CAAC;QAEhD,IAAI,iBAAiB,CAAC,UAAU,CAAC,EAAE;UACjC;UACA;UACA,IAAM,gBAAgB,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EACjB,gBAAgB,CAAA,EAChB,UAAU,CACd;UACD,MAAM,CAAC,OAAO,CAAC,GAAG,gBAAgB;SACnC,MAAM,IAAI,6BAA6B,CAAC,UAAU,CAAC,EAAE;UACpD,MAAM,CAAC,OAAO,CAAC,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EACV,UAAU,CAAA,EAAA;YACb,SAAS,EAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EACJ,gBAAgB,CAAA,EAChB,UAAU,CAAC,SAAS;UAAA,CAAA,CAE1B;SACF,MAAM,IAAI,UAAU,IAAI,UAAU,KAAK,IAAI,EAAE;UAC5C,MAAM,CAAC,OAAO,CAAC,GAAG,UAAU;SAC7B,MAAM,IACL,KAAK,IACL,UAAU,CAAC,gBAAgB,CAAC,IAC5B,WAAW,CAAC,gBAAgB,CAAC,IAC7B,iBAAiB,CAAC,gBAAgB,CAAC,IACnC,OAAO,CAAC,gBAAgB,CAAC,EACzB;UACA,MAAM,CAAC,OAAO,CAAC,GAAG,gBAAgB;QACnC;;IACF;MAAA;IAAA;MAAA;IAAA;GACF,MAAM;IACL,MAAM,GAAG,QAAQ;EAClB;EACD,OAAO,CAAC,MAAM,IAAI,OAAO,CAAC,MAAM,CAAC,GAAG,SAAS,GAAG,MAAM;AACxD;AAEA,SAAS,eAAe,CAAiC,GAGxD,EAAA;EACC,IAAO,gBAAgB,GAAgB,GAAG,CAAnC,gBAAgB;IAAE,UAAU,GAAI,GAAG,CAAjB,UAAU;EACnC,IAAI,gBAAgB,IAAI,UAAU,EAAE;IAClC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,oBAAoB,CAAC;MAAC,gBAAgB,EAAhB,gBAAgB;MAAE,UAAU,EAAV;IAAU,CAAC,CAAC,CAAC;EAC3E;EACD,OAAO,UAAU,KAAA,IAAA,IAAV,UAAU,KAAA,KAAA,CAAA,GAAV,UAAU,GAAI,gBAAgB;AACvC","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isArray } from 'vega-util';\nimport { COLUMN, FACET, ROW } from '../channel';\nimport { hasConditionalFieldOrDatumDef, isFieldOrDatumDef, isValueDef } from '../channeldef';\nimport { boxPlotNormalizer } from '../compositemark/boxplot';\nimport { errorBandNormalizer } from '../compositemark/errorband';\nimport { errorBarNormalizer } from '../compositemark/errorbar';\nimport { channelHasField } from '../encoding';\nimport * as log from '../log';\nimport { isFacetMapping } from '../spec/facet';\nimport { SpecMapper } from '../spec/map';\nimport { isLayerRepeatSpec } from '../spec/repeat';\nimport { isUnitSpec } from '../spec/unit';\nimport { isEmpty, keys, omit, varName } from '../util';\nimport { isSignalRef } from '../vega.schema';\nimport { PathOverlayNormalizer } from './pathoverlay';\nimport { replaceRepeaterInEncoding, replaceRepeaterInFacet } from './repeater';\nimport { RuleForRangedLineNormalizer } from './ruleforrangedline';\nexport class CoreNormalizer extends SpecMapper {\n    constructor() {\n        super(...arguments);\n        this.nonFacetUnitNormalizers = [\n            boxPlotNormalizer,\n            errorBarNormalizer,\n            errorBandNormalizer,\n            new PathOverlayNormalizer(),\n            new RuleForRangedLineNormalizer()\n        ];\n    }\n    map(spec, params) {\n        // Special handling for a faceted unit spec as it can return a facet spec, not just a layer or unit spec like a normal unit spec.\n        if (isUnitSpec(spec)) {\n            const hasRow = channelHasField(spec.encoding, ROW);\n            const hasColumn = channelHasField(spec.encoding, COLUMN);\n            const hasFacet = channelHasField(spec.encoding, FACET);\n            if (hasRow || hasColumn || hasFacet) {\n                return this.mapFacetedUnit(spec, params);\n            }\n        }\n        return super.map(spec, params);\n    }\n    // This is for normalizing non-facet unit\n    mapUnit(spec, params) {\n        const { parentEncoding, parentProjection } = params;\n        const encoding = replaceRepeaterInEncoding(spec.encoding, params.repeater);\n        const specWithReplacedEncoding = Object.assign(Object.assign({}, spec), (encoding ? { encoding } : {}));\n        if (parentEncoding || parentProjection) {\n            return this.mapUnitWithParentEncodingOrProjection(specWithReplacedEncoding, params);\n        }\n        const normalizeLayerOrUnit = this.mapLayerOrUnit.bind(this);\n        for (const unitNormalizer of this.nonFacetUnitNormalizers) {\n            if (unitNormalizer.hasMatchingType(specWithReplacedEncoding, params.config)) {\n                return unitNormalizer.run(specWithReplacedEncoding, params, normalizeLayerOrUnit);\n            }\n        }\n        return specWithReplacedEncoding;\n    }\n    mapRepeat(spec, params) {\n        if (isLayerRepeatSpec(spec)) {\n            return this.mapLayerRepeat(spec, params);\n        }\n        else {\n            return this.mapNonLayerRepeat(spec, params);\n        }\n    }\n    mapLayerRepeat(spec, params) {\n        const { repeat, spec: childSpec } = spec, rest = __rest(spec, [\"repeat\", \"spec\"]);\n        const { row, column, layer } = repeat;\n        const { repeater = {}, repeaterPrefix = '' } = params;\n        if (row || column) {\n            return this.mapRepeat(Object.assign(Object.assign({}, spec), { repeat: Object.assign(Object.assign({}, (row ? { row } : {})), (column ? { column } : {})), spec: {\n                    repeat: { layer },\n                    spec: childSpec\n                } }), params);\n        }\n        else {\n            return Object.assign(Object.assign({}, rest), { layer: layer.map(layerValue => {\n                    const childRepeater = Object.assign(Object.assign({}, repeater), { layer: layerValue });\n                    const childName = `${(childSpec.name || '') + repeaterPrefix}child__layer_${varName(layerValue)}`;\n                    const child = this.mapLayerOrUnit(childSpec, Object.assign(Object.assign({}, params), { repeater: childRepeater, repeaterPrefix: childName }));\n                    child.name = childName;\n                    return child;\n                }) });\n        }\n    }\n    mapNonLayerRepeat(spec, params) {\n        var _a;\n        const { repeat, spec: childSpec, data } = spec, remainingProperties = __rest(spec, [\"repeat\", \"spec\", \"data\"]);\n        if (!isArray(repeat) && spec.columns) {\n            // is repeat with row/column\n            spec = omit(spec, ['columns']);\n            log.warn(log.message.columnsNotSupportByRowCol('repeat'));\n        }\n        const concat = [];\n        const { repeater = {}, repeaterPrefix = '' } = params;\n        const row = (!isArray(repeat) && repeat.row) || [repeater ? repeater.row : null];\n        const column = (!isArray(repeat) && repeat.column) || [repeater ? repeater.column : null];\n        const repeatValues = (isArray(repeat) && repeat) || [repeater ? repeater.repeat : null];\n        // cross product\n        for (const repeatValue of repeatValues) {\n            for (const rowValue of row) {\n                for (const columnValue of column) {\n                    const childRepeater = {\n                        repeat: repeatValue,\n                        row: rowValue,\n                        column: columnValue,\n                        layer: repeater.layer\n                    };\n                    const childName = (childSpec.name || '') +\n                        repeaterPrefix +\n                        'child__' +\n                        (isArray(repeat)\n                            ? `${varName(repeatValue)}`\n                            : (repeat.row ? `row_${varName(rowValue)}` : '') +\n                                (repeat.column ? `column_${varName(columnValue)}` : ''));\n                    const child = this.map(childSpec, Object.assign(Object.assign({}, params), { repeater: childRepeater, repeaterPrefix: childName }));\n                    child.name = childName;\n                    // we move data up\n                    concat.push(omit(child, ['data']));\n                }\n            }\n        }\n        const columns = isArray(repeat) ? spec.columns : repeat.column ? repeat.column.length : 1;\n        return Object.assign(Object.assign({ data: (_a = childSpec.data) !== null && _a !== void 0 ? _a : data, align: 'all' }, remainingProperties), { columns,\n            concat });\n    }\n    mapFacet(spec, params) {\n        const { facet } = spec;\n        if (isFacetMapping(facet) && spec.columns) {\n            // is facet with row/column\n            spec = omit(spec, ['columns']);\n            log.warn(log.message.columnsNotSupportByRowCol('facet'));\n        }\n        return super.mapFacet(spec, params);\n    }\n    mapUnitWithParentEncodingOrProjection(spec, params) {\n        const { encoding, projection } = spec;\n        const { parentEncoding, parentProjection, config } = params;\n        const mergedProjection = mergeProjection({ parentProjection, projection });\n        const mergedEncoding = mergeEncoding({\n            parentEncoding,\n            encoding: replaceRepeaterInEncoding(encoding, params.repeater)\n        });\n        return this.mapUnit(Object.assign(Object.assign(Object.assign({}, spec), (mergedProjection ? { projection: mergedProjection } : {})), (mergedEncoding ? { encoding: mergedEncoding } : {})), { config });\n    }\n    mapFacetedUnit(spec, normParams) {\n        // New encoding in the inside spec should not contain row / column\n        // as row/column should be moved to facet\n        const _a = spec.encoding, { row, column, facet } = _a, encoding = __rest(_a, [\"row\", \"column\", \"facet\"]);\n        // Mark and encoding should be moved into the inner spec\n        const { mark, width, projection, height, view, params, encoding: _ } = spec, outerSpec = __rest(spec, [\"mark\", \"width\", \"projection\", \"height\", \"view\", \"params\", \"encoding\"]);\n        const { facetMapping, layout } = this.getFacetMappingAndLayout({ row, column, facet }, normParams);\n        const newEncoding = replaceRepeaterInEncoding(encoding, normParams.repeater);\n        return this.mapFacet(Object.assign(Object.assign(Object.assign({}, outerSpec), layout), { \n            // row / column has higher precedence than facet\n            facet: facetMapping, spec: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (width ? { width } : {})), (height ? { height } : {})), (view ? { view } : {})), (projection ? { projection } : {})), { mark, encoding: newEncoding }), (params ? { params } : {})) }), normParams);\n    }\n    getFacetMappingAndLayout(facets, params) {\n        var _a;\n        const { row, column, facet } = facets;\n        if (row || column) {\n            if (facet) {\n                log.warn(log.message.facetChannelDropped([...(row ? [ROW] : []), ...(column ? [COLUMN] : [])]));\n            }\n            const facetMapping = {};\n            const layout = {};\n            for (const channel of [ROW, COLUMN]) {\n                const def = facets[channel];\n                if (def) {\n                    const { align, center, spacing, columns } = def, defWithoutLayout = __rest(def, [\"align\", \"center\", \"spacing\", \"columns\"]);\n                    facetMapping[channel] = defWithoutLayout;\n                    for (const prop of ['align', 'center', 'spacing']) {\n                        if (def[prop] !== undefined) {\n                            (_a = layout[prop]) !== null && _a !== void 0 ? _a : (layout[prop] = {});\n                            layout[prop][channel] = def[prop];\n                        }\n                    }\n                }\n            }\n            return { facetMapping, layout };\n        }\n        else {\n            const { align, center, spacing, columns } = facet, facetMapping = __rest(facet, [\"align\", \"center\", \"spacing\", \"columns\"]);\n            return {\n                facetMapping: replaceRepeaterInFacet(facetMapping, params.repeater),\n                layout: Object.assign(Object.assign(Object.assign(Object.assign({}, (align ? { align } : {})), (center ? { center } : {})), (spacing ? { spacing } : {})), (columns ? { columns } : {}))\n            };\n        }\n    }\n    mapLayer(spec, _a) {\n        // Special handling for extended layer spec\n        var { parentEncoding, parentProjection } = _a, otherParams = __rest(_a, [\"parentEncoding\", \"parentProjection\"]);\n        const { encoding, projection } = spec, rest = __rest(spec, [\"encoding\", \"projection\"]);\n        const params = Object.assign(Object.assign({}, otherParams), { parentEncoding: mergeEncoding({ parentEncoding, encoding, layer: true }), parentProjection: mergeProjection({ parentProjection, projection }) });\n        return super.mapLayer(rest, params);\n    }\n}\nfunction mergeEncoding({ parentEncoding, encoding = {}, layer }) {\n    let merged = {};\n    if (parentEncoding) {\n        const channels = new Set([...keys(parentEncoding), ...keys(encoding)]);\n        for (const channel of channels) {\n            const channelDef = encoding[channel];\n            const parentChannelDef = parentEncoding[channel];\n            if (isFieldOrDatumDef(channelDef)) {\n                // Field/Datum Def can inherit properties from its parent\n                // Note that parentChannelDef doesn't have to be a field/datum def if the channelDef is already one.\n                const mergedChannelDef = Object.assign(Object.assign({}, parentChannelDef), channelDef);\n                merged[channel] = mergedChannelDef;\n            }\n            else if (hasConditionalFieldOrDatumDef(channelDef)) {\n                merged[channel] = Object.assign(Object.assign({}, channelDef), { condition: Object.assign(Object.assign({}, parentChannelDef), channelDef.condition) });\n            }\n            else if (channelDef || channelDef === null) {\n                merged[channel] = channelDef;\n            }\n            else if (layer ||\n                isValueDef(parentChannelDef) ||\n                isSignalRef(parentChannelDef) ||\n                isFieldOrDatumDef(parentChannelDef) ||\n                isArray(parentChannelDef)) {\n                merged[channel] = parentChannelDef;\n            }\n        }\n    }\n    else {\n        merged = encoding;\n    }\n    return !merged || isEmpty(merged) ? undefined : merged;\n}\nfunction mergeProjection(opt) {\n    const { parentProjection, projection } = opt;\n    if (parentProjection && projection) {\n        log.warn(log.message.projectionOverridden({ parentProjection, projection }));\n    }\n    return projection !== null && projection !== void 0 ? projection : parentProjection;\n}\n//# sourceMappingURL=core.js.map"]},"metadata":{},"sourceType":"module"}