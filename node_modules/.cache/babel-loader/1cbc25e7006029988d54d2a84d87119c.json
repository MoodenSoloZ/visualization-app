{"ast":null,"code":"import _defineProperty from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { isArray } from 'vega-util';\nimport { FACET_CHANNELS } from '../../channel';\nimport { title as fieldDefTitle } from '../../channeldef';\nimport { contains, getFirstDefined } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { assembleAxis } from '../axis/assemble';\nimport { parseGuideResolve } from '../resolve';\nimport { getHeaderProperty } from './common';\nexport function getHeaderType(orient) {\n  if (orient === 'top' || orient === 'left' || isSignalRef(orient)) {\n    // we always use header for orient signal since we can't dynamically make header becomes footer\n    return 'header';\n  }\n  return 'footer';\n}\nexport function parseFacetHeaders(model) {\n  var _iterator = _createForOfIteratorHelper(FACET_CHANNELS),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var channel = _step.value;\n      parseFacetHeader(model, channel);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  mergeChildAxis(model, 'x');\n  mergeChildAxis(model, 'y');\n}\nfunction parseFacetHeader(model, channel) {\n  var _a;\n  var facet = model.facet,\n    config = model.config,\n    child = model.child,\n    component = model.component;\n  if (model.channelHasField(channel)) {\n    var fieldDef = facet[channel];\n    var titleConfig = getHeaderProperty('title', null, config, channel);\n    var title = fieldDefTitle(fieldDef, config, {\n      allowDisabling: true,\n      includeDefault: titleConfig === undefined || !!titleConfig\n    });\n    if (child.component.layoutHeaders[channel].title) {\n      // TODO: better handle multiline titles\n      title = isArray(title) ? title.join(', ') : title;\n      // merge title with child to produce \"Title / Subtitle / Sub-subtitle\"\n      title += \" / \".concat(child.component.layoutHeaders[channel].title);\n      child.component.layoutHeaders[channel].title = null;\n    }\n    var labelOrient = getHeaderProperty('labelOrient', fieldDef.header, config, channel);\n    var labels = fieldDef.header !== null ? getFirstDefined((_a = fieldDef.header) === null || _a === void 0 ? void 0 : _a.labels, config.header.labels, true) : false;\n    var headerType = contains(['bottom', 'right'], labelOrient) ? 'footer' : 'header';\n    component.layoutHeaders[channel] = _defineProperty({\n      title: fieldDef.header !== null ? title : null,\n      facetFieldDef: fieldDef\n    }, headerType, channel === 'facet' ? [] : [makeHeaderComponent(model, channel, labels)]);\n  }\n}\nfunction makeHeaderComponent(model, channel, labels) {\n  var sizeType = channel === 'row' ? 'height' : 'width';\n  return {\n    labels: labels,\n    sizeSignal: model.child.component.layoutSize.get(sizeType) ? model.child.getSizeSignalRef(sizeType) : undefined,\n    axes: []\n  };\n}\nfunction mergeChildAxis(model, channel) {\n  var _a;\n  var child = model.child;\n  if (child.component.axes[channel]) {\n    var _model$component = model.component,\n      layoutHeaders = _model$component.layoutHeaders,\n      resolve = _model$component.resolve;\n    resolve.axis[channel] = parseGuideResolve(resolve, channel);\n    if (resolve.axis[channel] === 'shared') {\n      // For shared axis, move the axes to facet's header or footer\n      var headerChannel = channel === 'x' ? 'column' : 'row';\n      var layoutHeader = layoutHeaders[headerChannel];\n      var _iterator2 = _createForOfIteratorHelper(child.component.axes[channel]),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var axisComponent = _step2.value;\n          var headerType = getHeaderType(axisComponent.get('orient'));\n          (_a = layoutHeader[headerType]) !== null && _a !== void 0 ? _a : layoutHeader[headerType] = [makeHeaderComponent(model, headerChannel, false)];\n          // FIXME: assemble shouldn't be called here, but we do it this way so we only extract the main part of the axes\n          var mainAxis = assembleAxis(axisComponent, 'main', model.config, {\n            header: true\n          });\n          if (mainAxis) {\n            // LayoutHeader no longer keep track of property precedence, thus let's combine.\n            layoutHeader[headerType][0].axes.push(mainAxis);\n          }\n          axisComponent.mainExtracted = true;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    } else {\n      // Otherwise do nothing for independent axes\n    }\n  }\n}","map":{"version":3,"sources":["../../../../src/compile/header/parse.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray } from 'vega-util';\nimport { FACET_CHANNELS } from '../../channel';\nimport { title as fieldDefTitle } from '../../channeldef';\nimport { contains, getFirstDefined } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { assembleAxis } from '../axis/assemble';\nimport { parseGuideResolve } from '../resolve';\nimport { getHeaderProperty } from './common';\nexport function getHeaderType(orient) {\n    if (orient === 'top' || orient === 'left' || isSignalRef(orient)) {\n        // we always use header for orient signal since we can't dynamically make header becomes footer\n        return 'header';\n    }\n    return 'footer';\n}\nexport function parseFacetHeaders(model) {\n    for (const channel of FACET_CHANNELS) {\n        parseFacetHeader(model, channel);\n    }\n    mergeChildAxis(model, 'x');\n    mergeChildAxis(model, 'y');\n}\nfunction parseFacetHeader(model, channel) {\n    var _a;\n    const { facet, config, child, component } = model;\n    if (model.channelHasField(channel)) {\n        const fieldDef = facet[channel];\n        const titleConfig = getHeaderProperty('title', null, config, channel);\n        let title = fieldDefTitle(fieldDef, config, {\n            allowDisabling: true,\n            includeDefault: titleConfig === undefined || !!titleConfig\n        });\n        if (child.component.layoutHeaders[channel].title) {\n            // TODO: better handle multiline titles\n            title = isArray(title) ? title.join(', ') : title;\n            // merge title with child to produce \"Title / Subtitle / Sub-subtitle\"\n            title += ` / ${child.component.layoutHeaders[channel].title}`;\n            child.component.layoutHeaders[channel].title = null;\n        }\n        const labelOrient = getHeaderProperty('labelOrient', fieldDef.header, config, channel);\n        const labels = fieldDef.header !== null ? getFirstDefined((_a = fieldDef.header) === null || _a === void 0 ? void 0 : _a.labels, config.header.labels, true) : false;\n        const headerType = contains(['bottom', 'right'], labelOrient) ? 'footer' : 'header';\n        component.layoutHeaders[channel] = {\n            title: fieldDef.header !== null ? title : null,\n            facetFieldDef: fieldDef,\n            [headerType]: channel === 'facet' ? [] : [makeHeaderComponent(model, channel, labels)]\n        };\n    }\n}\nfunction makeHeaderComponent(model, channel, labels) {\n    const sizeType = channel === 'row' ? 'height' : 'width';\n    return {\n        labels,\n        sizeSignal: model.child.component.layoutSize.get(sizeType) ? model.child.getSizeSignalRef(sizeType) : undefined,\n        axes: []\n    };\n}\nfunction mergeChildAxis(model, channel) {\n    var _a;\n    const { child } = model;\n    if (child.component.axes[channel]) {\n        const { layoutHeaders, resolve } = model.component;\n        resolve.axis[channel] = parseGuideResolve(resolve, channel);\n        if (resolve.axis[channel] === 'shared') {\n            // For shared axis, move the axes to facet's header or footer\n            const headerChannel = channel === 'x' ? 'column' : 'row';\n            const layoutHeader = layoutHeaders[headerChannel];\n            for (const axisComponent of child.component.axes[channel]) {\n                const headerType = getHeaderType(axisComponent.get('orient'));\n                (_a = layoutHeader[headerType]) !== null && _a !== void 0 ? _a : (layoutHeader[headerType] = [makeHeaderComponent(model, headerChannel, false)]);\n                // FIXME: assemble shouldn't be called here, but we do it this way so we only extract the main part of the axes\n                const mainAxis = assembleAxis(axisComponent, 'main', model.config, { header: true });\n                if (mainAxis) {\n                    // LayoutHeader no longer keep track of property precedence, thus let's combine.\n                    layoutHeader[headerType][0].axes.push(mainAxis);\n                }\n                axisComponent.mainExtracted = true;\n            }\n        }\n        else {\n            // Otherwise do nothing for independent axes\n        }\n    }\n}\n//# sourceMappingURL=parse.js.map"]},"metadata":{},"sourceType":"module"}