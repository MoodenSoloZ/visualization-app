{"ast":null,"code":"import _defineProperty from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { POSITION_SCALE_CHANNELS } from '../../../channel';\nimport { hasContinuousDomain } from '../../../scale';\nimport { keys } from '../../../util';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { fieldInvalidPredicate } from './valueref';\nexport function defined(model) {\n  var config = model.config,\n    markDef = model.markDef;\n  var invalid = getMarkPropOrConfig('invalid', markDef, config);\n  if (invalid) {\n    var signal = allFieldsInvalidPredicate(model, {\n      channels: POSITION_SCALE_CHANNELS\n    });\n    if (signal) {\n      return {\n        defined: {\n          signal: signal\n        }\n      };\n    }\n  }\n  return {};\n}\nfunction allFieldsInvalidPredicate(model, _ref) {\n  var _ref$invalid = _ref.invalid,\n    invalid = _ref$invalid === void 0 ? false : _ref$invalid,\n    channels = _ref.channels;\n  var filterIndex = channels.reduce(function (aggregator, channel) {\n    var _a;\n    var scaleComponent = model.getScaleComponent(channel);\n    if (scaleComponent) {\n      var scaleType = scaleComponent.get('type');\n      var field = model.vgField(channel, {\n        expr: 'datum',\n        binSuffix: ((_a = model.stack) === null || _a === void 0 ? void 0 : _a.impute) ? 'mid' : undefined\n      });\n      // While discrete domain scales can handle invalid values, continuous scales can't.\n      if (field && hasContinuousDomain(scaleType)) {\n        aggregator[field] = true;\n      }\n    }\n    return aggregator;\n  }, {});\n  var fields = keys(filterIndex);\n  if (fields.length > 0) {\n    var op = invalid ? '||' : '&&';\n    return fields.map(function (field) {\n      return fieldInvalidPredicate(field, invalid);\n    }).join(\" \".concat(op, \" \"));\n  }\n  return undefined;\n}\nexport function valueIfDefined(prop, value) {\n  if (value !== undefined) {\n    return _defineProperty({}, prop, signalOrValueRef(value));\n  }\n  return undefined;\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/defined.ts"],"names":[],"mappings":";AAAA,SAAQ,uBAAuB,QAAO,kBAAkB;AAGxD,SAAQ,mBAAmB,QAAO,gBAAgB;AAClD,SAAc,IAAI,QAAO,eAAe;AAExC,SAAQ,mBAAmB,EAAE,gBAAgB,QAAO,cAAc;AAElE,SAAQ,qBAAqB,QAAO,YAAY;AAEhD,OAAM,SAAU,OAAO,CAAC,KAAgB,EAAA;EACtC,IAAO,MAAM,GAAa,KAAK,CAAxB,MAAM;IAAE,OAAO,GAAI,KAAK,CAAhB,OAAO;EAEtB,IAAM,OAAO,GAAG,mBAAmB,CAAC,SAAS,EAAE,OAAO,EAAE,MAAM,CAAC;EAC/D,IAAI,OAAO,EAAE;IACX,IAAM,MAAM,GAAG,yBAAyB,CAAC,KAAK,EAAE;MAAC,QAAQ,EAAE;IAAuB,CAAC,CAAC;IAEpF,IAAI,MAAM,EAAE;MACV,OAAO;QAAC,OAAO,EAAE;UAAC,MAAM,EAAN;QAAM;MAAC,CAAC;IAC3B;EACF;EACD,OAAO,CAAA,CAAE;AACX;AAEA,SAAS,yBAAyB,CAChC,KAAgB,QAC0D;EAAA,wBAAzE,OAAO;IAAP,OAAO,6BAAG,KAAK;IAAE,QAAQ,QAAR,QAAQ;EAE1B,IAAM,WAAW,GAAG,QAAQ,CAAC,MAAM,CAAC,UAAC,UAAsB,EAAE,OAAO,EAAI;;IACtE,IAAM,cAAc,GAAG,KAAK,CAAC,iBAAiB,CAAC,OAAO,CAAC;IACvD,IAAI,cAAc,EAAE;MAClB,IAAM,SAAS,GAAG,cAAc,CAAC,GAAG,CAAC,MAAM,CAAC;MAC5C,IAAM,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,OAAO,EAAE;QAAC,IAAI,EAAE,OAAO;QAAE,SAAS,EAAE,CAAA,CAAA,EAAA,GAAA,KAAK,CAAC,KAAK,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,MAAM,IAAG,KAAK,GAAG;MAAS,CAAC,CAAC;MAEzG;MACA,IAAI,KAAK,IAAI,mBAAmB,CAAC,SAAS,CAAC,EAAE;QAC3C,UAAU,CAAC,KAAK,CAAC,GAAG,IAAI;MACzB;IACF;IACD,OAAO,UAAU;EACnB,CAAC,EAAE,CAAA,CAAE,CAAC;EAEN,IAAM,MAAM,GAAG,IAAI,CAAC,WAAW,CAAC;EAChC,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;IACrB,IAAM,EAAE,GAAG,OAAO,GAAG,IAAI,GAAG,IAAI;IAChC,OAAO,MAAM,CAAC,GAAG,CAAC,UAAA,KAAK;MAAA,OAAI,qBAAqB,CAAC,KAAK,EAAE,OAAO,CAAC;IAAA,EAAC,CAAC,IAAI,YAAK,EAAE,OAAI;EAClF;EACD,OAAO,SAAS;AAClB;AAEA,OAAM,SAAU,cAAc,CAAC,IAAY,EAAE,KAAY,EAAA;EACvD,IAAI,KAAK,KAAK,SAAS,EAAE;IACvB,2BAAS,IAAI,EAAG,gBAAgB,CAAC,KAAK,CAAC;EACxC;EACD,OAAO,SAAS;AAClB","sourceRoot":"","sourcesContent":["import { POSITION_SCALE_CHANNELS } from '../../../channel';\nimport { hasContinuousDomain } from '../../../scale';\nimport { keys } from '../../../util';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { fieldInvalidPredicate } from './valueref';\nexport function defined(model) {\n    const { config, markDef } = model;\n    const invalid = getMarkPropOrConfig('invalid', markDef, config);\n    if (invalid) {\n        const signal = allFieldsInvalidPredicate(model, { channels: POSITION_SCALE_CHANNELS });\n        if (signal) {\n            return { defined: { signal } };\n        }\n    }\n    return {};\n}\nfunction allFieldsInvalidPredicate(model, { invalid = false, channels }) {\n    const filterIndex = channels.reduce((aggregator, channel) => {\n        var _a;\n        const scaleComponent = model.getScaleComponent(channel);\n        if (scaleComponent) {\n            const scaleType = scaleComponent.get('type');\n            const field = model.vgField(channel, { expr: 'datum', binSuffix: ((_a = model.stack) === null || _a === void 0 ? void 0 : _a.impute) ? 'mid' : undefined });\n            // While discrete domain scales can handle invalid values, continuous scales can't.\n            if (field && hasContinuousDomain(scaleType)) {\n                aggregator[field] = true;\n            }\n        }\n        return aggregator;\n    }, {});\n    const fields = keys(filterIndex);\n    if (fields.length > 0) {\n        const op = invalid ? '||' : '&&';\n        return fields.map(field => fieldInvalidPredicate(field, invalid)).join(` ${op} `);\n    }\n    return undefined;\n}\nexport function valueIfDefined(prop, value) {\n    if (value !== undefined) {\n        return { [prop]: signalOrValueRef(value) };\n    }\n    return undefined;\n}\n//# sourceMappingURL=defined.js.map"]},"metadata":{},"sourceType":"module"}