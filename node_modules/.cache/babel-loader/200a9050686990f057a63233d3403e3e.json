{"ast":null,"code":"import _defineProperty from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { isArray, isBoolean, isString } from 'vega-util';\nimport { isContinuousFieldOrDatumDef, isFieldDef, isFieldOrDatumDefForTimeFormat } from '../channeldef';\nimport { fieldDefs } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { getFirstDefined, hash, unique } from '../util';\nimport { isSignalRef } from '../vega.schema';\nimport { toStringFieldDef } from './../channeldef';\nexport function filterTooltipWithAggregatedField(oldEncoding) {\n  var tooltip = oldEncoding.tooltip,\n    filteredEncoding = __rest(oldEncoding, [\"tooltip\"]);\n  if (!tooltip) {\n    return {\n      filteredEncoding: filteredEncoding\n    };\n  }\n  var customTooltipWithAggregatedField;\n  var customTooltipWithoutAggregatedField;\n  if (isArray(tooltip)) {\n    var _iterator = _createForOfIteratorHelper(tooltip),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var t = _step.value;\n        if (t.aggregate) {\n          if (!customTooltipWithAggregatedField) {\n            customTooltipWithAggregatedField = [];\n          }\n          customTooltipWithAggregatedField.push(t);\n        } else {\n          if (!customTooltipWithoutAggregatedField) {\n            customTooltipWithoutAggregatedField = [];\n          }\n          customTooltipWithoutAggregatedField.push(t);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    if (customTooltipWithAggregatedField) {\n      filteredEncoding.tooltip = customTooltipWithAggregatedField;\n    }\n  } else {\n    if (tooltip['aggregate']) {\n      filteredEncoding.tooltip = tooltip;\n    } else {\n      customTooltipWithoutAggregatedField = tooltip;\n    }\n  }\n  if (isArray(customTooltipWithoutAggregatedField) && customTooltipWithoutAggregatedField.length === 1) {\n    customTooltipWithoutAggregatedField = customTooltipWithoutAggregatedField[0];\n  }\n  return {\n    customTooltipWithoutAggregatedField: customTooltipWithoutAggregatedField,\n    filteredEncoding: filteredEncoding\n  };\n}\nexport function getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis) {\n  var withFieldName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  if ('tooltip' in encodingWithoutContinuousAxis) {\n    return {\n      tooltip: encodingWithoutContinuousAxis.tooltip\n    };\n  }\n  var fiveSummaryTooltip = tooltipSummary.map(function (_ref) {\n    var fieldPrefix = _ref.fieldPrefix,\n      titlePrefix = _ref.titlePrefix;\n    var mainTitle = withFieldName ? \" of \".concat(getTitle(continuousAxisChannelDef)) : '';\n    return {\n      field: fieldPrefix + continuousAxisChannelDef.field,\n      type: continuousAxisChannelDef.type,\n      title: isSignalRef(titlePrefix) ? {\n        signal: \"\".concat(titlePrefix, \"\\\"\").concat(escape(mainTitle), \"\\\"\")\n      } : titlePrefix + mainTitle\n    };\n  });\n  var tooltipFieldDefs = fieldDefs(encodingWithoutContinuousAxis).map(toStringFieldDef);\n  return {\n    tooltip: [].concat(_toConsumableArray(fiveSummaryTooltip), _toConsumableArray(unique(tooltipFieldDefs, hash)))\n  };\n}\nexport function getTitle(continuousAxisChannelDef) {\n  var title = continuousAxisChannelDef.title,\n    field = continuousAxisChannelDef.field;\n  return getFirstDefined(title, field);\n}\nexport function makeCompositeAggregatePartFactory(compositeMarkDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, compositeMarkConfig) {\n  var scale = continuousAxisChannelDef.scale,\n    axis = continuousAxisChannelDef.axis;\n  return function (_ref2) {\n    var partName = _ref2.partName,\n      mark = _ref2.mark,\n      positionPrefix = _ref2.positionPrefix,\n      _ref2$endPositionPref = _ref2.endPositionPrefix,\n      endPositionPrefix = _ref2$endPositionPref === void 0 ? undefined : _ref2$endPositionPref,\n      _ref2$extraEncoding = _ref2.extraEncoding,\n      extraEncoding = _ref2$extraEncoding === void 0 ? {} : _ref2$extraEncoding;\n    var title = getTitle(continuousAxisChannelDef);\n    return partLayerMixins(compositeMarkDef, partName, compositeMarkConfig, {\n      mark: mark,\n      encoding: Object.assign(Object.assign(Object.assign(_defineProperty({}, continuousAxis, Object.assign(Object.assign(Object.assign({\n        field: \"\".concat(positionPrefix, \"_\").concat(continuousAxisChannelDef.field),\n        type: continuousAxisChannelDef.type\n      }, title !== undefined ? {\n        title: title\n      } : {}), scale !== undefined ? {\n        scale: scale\n      } : {}), axis !== undefined ? {\n        axis: axis\n      } : {})), isString(endPositionPrefix) ? _defineProperty({}, \"\".concat(continuousAxis, \"2\"), {\n        field: \"\".concat(endPositionPrefix, \"_\").concat(continuousAxisChannelDef.field)\n      }) : {}), sharedEncoding), extraEncoding)\n    });\n  };\n}\nexport function partLayerMixins(markDef, part, compositeMarkConfig, partBaseSpec) {\n  var clip = markDef.clip,\n    color = markDef.color,\n    opacity = markDef.opacity;\n  var mark = markDef.type;\n  if (markDef[part] || markDef[part] === undefined && compositeMarkConfig[part]) {\n    return [Object.assign(Object.assign({}, partBaseSpec), {\n      mark: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, compositeMarkConfig[part]), clip ? {\n        clip: clip\n      } : {}), color ? {\n        color: color\n      } : {}), opacity ? {\n        opacity: opacity\n      } : {}), isMarkDef(partBaseSpec.mark) ? partBaseSpec.mark : {\n        type: partBaseSpec.mark\n      }), {\n        style: \"\".concat(mark, \"-\").concat(String(part))\n      }), isBoolean(markDef[part]) ? {} : markDef[part])\n    })];\n  }\n  return [];\n}\nexport function compositeMarkContinuousAxis(spec, orient, compositeMark) {\n  var encoding = spec.encoding;\n  var continuousAxis = orient === 'vertical' ? 'y' : 'x';\n  var continuousAxisChannelDef = encoding[continuousAxis]; // Safe to cast because if x is not continuous fielddef, the orient would not be horizontal.\n  var continuousAxisChannelDef2 = encoding[\"\".concat(continuousAxis, \"2\")];\n  var continuousAxisChannelDefError = encoding[\"\".concat(continuousAxis, \"Error\")];\n  var continuousAxisChannelDefError2 = encoding[\"\".concat(continuousAxis, \"Error2\")];\n  return {\n    continuousAxisChannelDef: filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark),\n    continuousAxisChannelDef2: filterAggregateFromChannelDef(continuousAxisChannelDef2, compositeMark),\n    continuousAxisChannelDefError: filterAggregateFromChannelDef(continuousAxisChannelDefError, compositeMark),\n    continuousAxisChannelDefError2: filterAggregateFromChannelDef(continuousAxisChannelDefError2, compositeMark),\n    continuousAxis: continuousAxis\n  };\n}\nfunction filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark) {\n  if (continuousAxisChannelDef === null || continuousAxisChannelDef === void 0 ? void 0 : continuousAxisChannelDef.aggregate) {\n    var aggregate = continuousAxisChannelDef.aggregate,\n      continuousAxisWithoutAggregate = __rest(continuousAxisChannelDef, [\"aggregate\"]);\n    if (aggregate !== compositeMark) {\n      log.warn(log.message.errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));\n    }\n    return continuousAxisWithoutAggregate;\n  } else {\n    return continuousAxisChannelDef;\n  }\n}\nexport function compositeMarkOrient(spec, compositeMark) {\n  var mark = spec.mark,\n    encoding = spec.encoding;\n  var x = encoding.x,\n    y = encoding.y;\n  if (isMarkDef(mark) && mark.orient) {\n    return mark.orient;\n  }\n  if (isContinuousFieldOrDatumDef(x)) {\n    // x is continuous\n    if (isContinuousFieldOrDatumDef(y)) {\n      // both x and y are continuous\n      var xAggregate = isFieldDef(x) && x.aggregate;\n      var yAggregate = isFieldDef(y) && y.aggregate;\n      if (!xAggregate && yAggregate === compositeMark) {\n        return 'vertical';\n      } else if (!yAggregate && xAggregate === compositeMark) {\n        return 'horizontal';\n      } else if (xAggregate === compositeMark && yAggregate === compositeMark) {\n        throw new Error('Both x and y cannot have aggregate');\n      } else {\n        if (isFieldOrDatumDefForTimeFormat(y) && !isFieldOrDatumDefForTimeFormat(x)) {\n          // y is temporal but x is not\n          return 'horizontal';\n        }\n        // default orientation for two continuous\n        return 'vertical';\n      }\n    }\n    return 'horizontal';\n  } else if (isContinuousFieldOrDatumDef(y)) {\n    // y is continuous but x is not\n    return 'vertical';\n  } else {\n    // Neither x nor y is continuous.\n    throw new Error(\"Need a valid continuous axis for \".concat(compositeMark, \"s\"));\n  }\n}","map":{"version":3,"sources":["../../../src/compositemark/common.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isArray, isBoolean, isString } from 'vega-util';\nimport { isContinuousFieldOrDatumDef, isFieldDef, isFieldOrDatumDefForTimeFormat } from '../channeldef';\nimport { fieldDefs } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { getFirstDefined, hash, unique } from '../util';\nimport { isSignalRef } from '../vega.schema';\nimport { toStringFieldDef } from './../channeldef';\nexport function filterTooltipWithAggregatedField(oldEncoding) {\n    const { tooltip } = oldEncoding, filteredEncoding = __rest(oldEncoding, [\"tooltip\"]);\n    if (!tooltip) {\n        return { filteredEncoding };\n    }\n    let customTooltipWithAggregatedField;\n    let customTooltipWithoutAggregatedField;\n    if (isArray(tooltip)) {\n        for (const t of tooltip) {\n            if (t.aggregate) {\n                if (!customTooltipWithAggregatedField) {\n                    customTooltipWithAggregatedField = [];\n                }\n                customTooltipWithAggregatedField.push(t);\n            }\n            else {\n                if (!customTooltipWithoutAggregatedField) {\n                    customTooltipWithoutAggregatedField = [];\n                }\n                customTooltipWithoutAggregatedField.push(t);\n            }\n        }\n        if (customTooltipWithAggregatedField) {\n            filteredEncoding.tooltip = customTooltipWithAggregatedField;\n        }\n    }\n    else {\n        if (tooltip['aggregate']) {\n            filteredEncoding.tooltip = tooltip;\n        }\n        else {\n            customTooltipWithoutAggregatedField = tooltip;\n        }\n    }\n    if (isArray(customTooltipWithoutAggregatedField) && customTooltipWithoutAggregatedField.length === 1) {\n        customTooltipWithoutAggregatedField = customTooltipWithoutAggregatedField[0];\n    }\n    return { customTooltipWithoutAggregatedField, filteredEncoding };\n}\nexport function getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, withFieldName = true) {\n    if ('tooltip' in encodingWithoutContinuousAxis) {\n        return { tooltip: encodingWithoutContinuousAxis.tooltip };\n    }\n    const fiveSummaryTooltip = tooltipSummary.map(({ fieldPrefix, titlePrefix }) => {\n        const mainTitle = withFieldName ? ` of ${getTitle(continuousAxisChannelDef)}` : '';\n        return {\n            field: fieldPrefix + continuousAxisChannelDef.field,\n            type: continuousAxisChannelDef.type,\n            title: isSignalRef(titlePrefix) ? { signal: `${titlePrefix}\"${escape(mainTitle)}\"` } : titlePrefix + mainTitle\n        };\n    });\n    const tooltipFieldDefs = fieldDefs(encodingWithoutContinuousAxis).map(toStringFieldDef);\n    return {\n        tooltip: [\n            ...fiveSummaryTooltip,\n            // need to cast because TextFieldDef supports fewer types of bin\n            ...unique(tooltipFieldDefs, hash)\n        ]\n    };\n}\nexport function getTitle(continuousAxisChannelDef) {\n    const { title, field } = continuousAxisChannelDef;\n    return getFirstDefined(title, field);\n}\nexport function makeCompositeAggregatePartFactory(compositeMarkDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, compositeMarkConfig) {\n    const { scale, axis } = continuousAxisChannelDef;\n    return ({ partName, mark, positionPrefix, endPositionPrefix = undefined, extraEncoding = {} }) => {\n        const title = getTitle(continuousAxisChannelDef);\n        return partLayerMixins(compositeMarkDef, partName, compositeMarkConfig, {\n            mark,\n            encoding: Object.assign(Object.assign(Object.assign({ [continuousAxis]: Object.assign(Object.assign(Object.assign({ field: `${positionPrefix}_${continuousAxisChannelDef.field}`, type: continuousAxisChannelDef.type }, (title !== undefined ? { title } : {})), (scale !== undefined ? { scale } : {})), (axis !== undefined ? { axis } : {})) }, (isString(endPositionPrefix)\n                ? {\n                    [`${continuousAxis}2`]: {\n                        field: `${endPositionPrefix}_${continuousAxisChannelDef.field}`\n                    }\n                }\n                : {})), sharedEncoding), extraEncoding)\n        });\n    };\n}\nexport function partLayerMixins(markDef, part, compositeMarkConfig, partBaseSpec) {\n    const { clip, color, opacity } = markDef;\n    const mark = markDef.type;\n    if (markDef[part] || (markDef[part] === undefined && compositeMarkConfig[part])) {\n        return [\n            Object.assign(Object.assign({}, partBaseSpec), { mark: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, compositeMarkConfig[part]), (clip ? { clip } : {})), (color ? { color } : {})), (opacity ? { opacity } : {})), (isMarkDef(partBaseSpec.mark) ? partBaseSpec.mark : { type: partBaseSpec.mark })), { style: `${mark}-${String(part)}` }), (isBoolean(markDef[part]) ? {} : markDef[part])) })\n        ];\n    }\n    return [];\n}\nexport function compositeMarkContinuousAxis(spec, orient, compositeMark) {\n    const { encoding } = spec;\n    const continuousAxis = orient === 'vertical' ? 'y' : 'x';\n    const continuousAxisChannelDef = encoding[continuousAxis]; // Safe to cast because if x is not continuous fielddef, the orient would not be horizontal.\n    const continuousAxisChannelDef2 = encoding[`${continuousAxis}2`];\n    const continuousAxisChannelDefError = encoding[`${continuousAxis}Error`];\n    const continuousAxisChannelDefError2 = encoding[`${continuousAxis}Error2`];\n    return {\n        continuousAxisChannelDef: filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark),\n        continuousAxisChannelDef2: filterAggregateFromChannelDef(continuousAxisChannelDef2, compositeMark),\n        continuousAxisChannelDefError: filterAggregateFromChannelDef(continuousAxisChannelDefError, compositeMark),\n        continuousAxisChannelDefError2: filterAggregateFromChannelDef(continuousAxisChannelDefError2, compositeMark),\n        continuousAxis\n    };\n}\nfunction filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark) {\n    if (continuousAxisChannelDef === null || continuousAxisChannelDef === void 0 ? void 0 : continuousAxisChannelDef.aggregate) {\n        const { aggregate } = continuousAxisChannelDef, continuousAxisWithoutAggregate = __rest(continuousAxisChannelDef, [\"aggregate\"]);\n        if (aggregate !== compositeMark) {\n            log.warn(log.message.errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));\n        }\n        return continuousAxisWithoutAggregate;\n    }\n    else {\n        return continuousAxisChannelDef;\n    }\n}\nexport function compositeMarkOrient(spec, compositeMark) {\n    const { mark, encoding } = spec;\n    const { x, y } = encoding;\n    if (isMarkDef(mark) && mark.orient) {\n        return mark.orient;\n    }\n    if (isContinuousFieldOrDatumDef(x)) {\n        // x is continuous\n        if (isContinuousFieldOrDatumDef(y)) {\n            // both x and y are continuous\n            const xAggregate = isFieldDef(x) && x.aggregate;\n            const yAggregate = isFieldDef(y) && y.aggregate;\n            if (!xAggregate && yAggregate === compositeMark) {\n                return 'vertical';\n            }\n            else if (!yAggregate && xAggregate === compositeMark) {\n                return 'horizontal';\n            }\n            else if (xAggregate === compositeMark && yAggregate === compositeMark) {\n                throw new Error('Both x and y cannot have aggregate');\n            }\n            else {\n                if (isFieldOrDatumDefForTimeFormat(y) && !isFieldOrDatumDefForTimeFormat(x)) {\n                    // y is temporal but x is not\n                    return 'horizontal';\n                }\n                // default orientation for two continuous\n                return 'vertical';\n            }\n        }\n        return 'horizontal';\n    }\n    else if (isContinuousFieldOrDatumDef(y)) {\n        // y is continuous but x is not\n        return 'vertical';\n    }\n    else {\n        // Neither x nor y is continuous.\n        throw new Error(`Need a valid continuous axis for ${compositeMark}s`);\n    }\n}\n//# sourceMappingURL=common.js.map"]},"metadata":{},"sourceType":"module"}