{"ast":null,"code":"import { isString } from 'vega-util';\nimport { contains } from './util';\nvar AGGREGATE_OP_INDEX = {\n  argmax: 1,\n  argmin: 1,\n  average: 1,\n  count: 1,\n  distinct: 1,\n  product: 1,\n  max: 1,\n  mean: 1,\n  median: 1,\n  min: 1,\n  missing: 1,\n  q1: 1,\n  q3: 1,\n  ci0: 1,\n  ci1: 1,\n  stderr: 1,\n  stdev: 1,\n  stdevp: 1,\n  sum: 1,\n  valid: 1,\n  values: 1,\n  variance: 1,\n  variancep: 1\n};\nexport var MULTIDOMAIN_SORT_OP_INDEX = {\n  count: 1,\n  min: 1,\n  max: 1\n};\nexport function isArgminDef(a) {\n  return !!a && !!a['argmin'];\n}\nexport function isArgmaxDef(a) {\n  return !!a && !!a['argmax'];\n}\nexport function isAggregateOp(a) {\n  return isString(a) && !!AGGREGATE_OP_INDEX[a];\n}\nexport var COUNTING_OPS = new Set(['count', 'valid', 'missing', 'distinct']);\nexport function isCountingAggregateOp(aggregate) {\n  return isString(aggregate) && COUNTING_OPS.has(aggregate);\n}\nexport function isMinMaxOp(aggregate) {\n  return isString(aggregate) && contains(['min', 'max'], aggregate);\n}\n/** Additive-based aggregation operations. These can be applied to stack. */\nexport var SUM_OPS = new Set(['count', 'sum', 'distinct', 'valid', 'missing']);\n/**\n * Aggregation operators that always produce values within the range [domainMin, domainMax].\n */\nexport var SHARED_DOMAIN_OPS = new Set(['mean', 'average', 'median', 'q1', 'q3', 'min', 'max']);","map":{"version":3,"sources":["../../src/aggregate.ts"],"names":[],"mappings":"AACA,SAAQ,QAAQ,QAAO,WAAW;AAElC,SAAQ,QAAQ,QAAa,QAAQ;AAErC,IAAM,kBAAkB,GAAsB;EAC5C,MAAM,EAAE,CAAC;EACT,MAAM,EAAE,CAAC;EACT,OAAO,EAAE,CAAC;EACV,KAAK,EAAE,CAAC;EACR,QAAQ,EAAE,CAAC;EACX,OAAO,EAAE,CAAC;EACV,GAAG,EAAE,CAAC;EACN,IAAI,EAAE,CAAC;EACP,MAAM,EAAE,CAAC;EACT,GAAG,EAAE,CAAC;EACN,OAAO,EAAE,CAAC;EACV,EAAE,EAAE,CAAC;EACL,EAAE,EAAE,CAAC;EACL,GAAG,EAAE,CAAC;EACN,GAAG,EAAE,CAAC;EACN,MAAM,EAAE,CAAC;EACT,KAAK,EAAE,CAAC;EACR,MAAM,EAAE,CAAC;EACT,GAAG,EAAE,CAAC;EACN,KAAK,EAAE,CAAC;EACR,MAAM,EAAE,CAAC;EACT,QAAQ,EAAE,CAAC;EACX,SAAS,EAAE;CACZ;AAED,OAAO,IAAM,yBAAyB,GAAG;EACvC,KAAK,EAAE,CAAC;EACR,GAAG,EAAE,CAAC;EACN,GAAG,EAAE;CACN;AAcD,OAAM,SAAU,WAAW,CAAC,CAAqB,EAAA;EAC/C,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;AAC7B;AAEA,OAAM,SAAU,WAAW,CAAC,CAAqB,EAAA;EAC/C,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;AAC7B;AAEA,OAAM,SAAU,aAAa,CAAC,CAAiC,EAAA;EAC7D,OAAO,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,kBAAkB,CAAC,CAAC,CAAC;AAC/C;AAEA,OAAO,IAAM,YAAY,GAAG,IAAI,GAAG,CAAoB,CACrD,OAAO,EACP,OAAO,EACP,SAAS,EACT,UAAU,CACX,CAAmC;AAEpC,OAAM,SAAU,qBAAqB,CAAC,SAA8B,EAAA;EAClE,OAAO,QAAQ,CAAC,SAAS,CAAC,IAAI,YAAY,CAAC,GAAG,CAAC,SAAgB,CAAC;AAClE;AAEA,OAAM,SAAU,UAAU,CAAC,SAA8B,EAAA;EACvD,OAAO,QAAQ,CAAC,SAAS,CAAC,IAAI,QAAQ,CAAC,CAAC,KAAK,EAAE,KAAK,CAAC,EAAE,SAAS,CAAC;AACnE;AAEA;AACA,OAAO,IAAM,OAAO,GAAG,IAAI,GAAG,CAAoB,CAChD,OAAO,EACP,KAAK,EACL,UAAU,EACV,OAAO,EACP,SAAS,CACV,CAAmC;AAEpC;;AAEG;AACH,OAAO,IAAM,iBAAiB,GAAG,IAAI,GAAG,CAAc,CACpD,MAAM,EACN,SAAS,EACT,QAAQ,EACR,IAAI,EACJ,IAAI,EACJ,KAAK,EACL,KAAK,CACN,CAA6B","sourceRoot":"","sourcesContent":["import { isString } from 'vega-util';\nimport { contains } from './util';\nconst AGGREGATE_OP_INDEX = {\n    argmax: 1,\n    argmin: 1,\n    average: 1,\n    count: 1,\n    distinct: 1,\n    product: 1,\n    max: 1,\n    mean: 1,\n    median: 1,\n    min: 1,\n    missing: 1,\n    q1: 1,\n    q3: 1,\n    ci0: 1,\n    ci1: 1,\n    stderr: 1,\n    stdev: 1,\n    stdevp: 1,\n    sum: 1,\n    valid: 1,\n    values: 1,\n    variance: 1,\n    variancep: 1\n};\nexport const MULTIDOMAIN_SORT_OP_INDEX = {\n    count: 1,\n    min: 1,\n    max: 1\n};\nexport function isArgminDef(a) {\n    return !!a && !!a['argmin'];\n}\nexport function isArgmaxDef(a) {\n    return !!a && !!a['argmax'];\n}\nexport function isAggregateOp(a) {\n    return isString(a) && !!AGGREGATE_OP_INDEX[a];\n}\nexport const COUNTING_OPS = new Set([\n    'count',\n    'valid',\n    'missing',\n    'distinct'\n]);\nexport function isCountingAggregateOp(aggregate) {\n    return isString(aggregate) && COUNTING_OPS.has(aggregate);\n}\nexport function isMinMaxOp(aggregate) {\n    return isString(aggregate) && contains(['min', 'max'], aggregate);\n}\n/** Additive-based aggregation operations. These can be applied to stack. */\nexport const SUM_OPS = new Set([\n    'count',\n    'sum',\n    'distinct',\n    'valid',\n    'missing'\n]);\n/**\n * Aggregation operators that always produce values within the range [domainMin, domainMax].\n */\nexport const SHARED_DOMAIN_OPS = new Set([\n    'mean',\n    'average',\n    'median',\n    'q1',\n    'q3',\n    'min',\n    'max'\n]);\n//# sourceMappingURL=aggregate.js.map"]},"metadata":{},"sourceType":"module"}