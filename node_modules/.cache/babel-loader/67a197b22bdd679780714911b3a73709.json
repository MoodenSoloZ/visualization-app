{"ast":null,"code":"import { isArray, isObject } from 'vega-util';\nimport { isBinned, isBinning } from '../../bin';\nimport { X } from '../../channel';\nimport { isDiscrete, isFieldDef, toFieldDefBase, valueArray } from '../../channeldef';\nimport { hasDiscreteDomain } from '../../scale';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport { NOMINAL, ORDINAL } from '../../type';\nimport { contains, normalizeAngle } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { mergeTitle, mergeTitleFieldDefs } from '../common';\nimport { guideFormat, guideFormatType } from '../format';\nimport { getAxisConfig } from './config';\nexport var axisRules = {\n  scale: function scale(_ref) {\n    var model = _ref.model,\n      channel = _ref.channel;\n    return model.scaleName(channel);\n  },\n  format: function format(_ref2) {\n    var fieldOrDatumDef = _ref2.fieldOrDatumDef,\n      config = _ref2.config,\n      axis = _ref2.axis;\n    var format = axis.format,\n      formatType = axis.formatType;\n    return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format, formatType, config, true);\n  },\n  formatType: function formatType(_ref3) {\n    var axis = _ref3.axis,\n      fieldOrDatumDef = _ref3.fieldOrDatumDef,\n      scaleType = _ref3.scaleType;\n    var formatType = axis.formatType;\n    return guideFormatType(formatType, fieldOrDatumDef, scaleType);\n  },\n  grid: function grid(_ref4) {\n    var fieldOrDatumDef = _ref4.fieldOrDatumDef,\n      axis = _ref4.axis,\n      scaleType = _ref4.scaleType;\n    var _a;\n    return (_a = axis.grid) !== null && _a !== void 0 ? _a : defaultGrid(scaleType, fieldOrDatumDef);\n  },\n  gridScale: function gridScale(_ref5) {\n    var model = _ref5.model,\n      channel = _ref5.channel;\n    return _gridScale(model, channel);\n  },\n  labelAlign: function labelAlign(_ref6) {\n    var axis = _ref6.axis,\n      labelAngle = _ref6.labelAngle,\n      orient = _ref6.orient,\n      channel = _ref6.channel;\n    return axis.labelAlign || defaultLabelAlign(labelAngle, orient, channel);\n  },\n  labelAngle: function labelAngle(_ref7) {\n    var _labelAngle = _ref7.labelAngle;\n    return _labelAngle;\n  },\n  labelBaseline: function labelBaseline(_ref8) {\n    var axis = _ref8.axis,\n      labelAngle = _ref8.labelAngle,\n      orient = _ref8.orient,\n      channel = _ref8.channel;\n    return axis.labelBaseline || defaultLabelBaseline(labelAngle, orient, channel);\n  },\n  labelFlush: function labelFlush(_ref9) {\n    var axis = _ref9.axis,\n      fieldOrDatumDef = _ref9.fieldOrDatumDef,\n      channel = _ref9.channel;\n    var _a;\n    return (_a = axis.labelFlush) !== null && _a !== void 0 ? _a : defaultLabelFlush(fieldOrDatumDef.type, channel);\n  },\n  labelOverlap: function labelOverlap(_ref10) {\n    var axis = _ref10.axis,\n      fieldOrDatumDef = _ref10.fieldOrDatumDef,\n      scaleType = _ref10.scaleType;\n    var _a;\n    return (_a = axis.labelOverlap) !== null && _a !== void 0 ? _a : defaultLabelOverlap(fieldOrDatumDef.type, scaleType, isFieldDef(fieldOrDatumDef) && !!fieldOrDatumDef.timeUnit, isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : undefined);\n  },\n  // we already calculate orient in parse\n  orient: function orient(_ref11) {\n    var _orient = _ref11.orient;\n    return _orient;\n  },\n  tickCount: function tickCount(_ref12) {\n    var channel = _ref12.channel,\n      model = _ref12.model,\n      axis = _ref12.axis,\n      fieldOrDatumDef = _ref12.fieldOrDatumDef,\n      scaleType = _ref12.scaleType;\n    var _a;\n    var sizeType = channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;\n    var size = sizeType ? model.getSizeSignalRef(sizeType) : undefined;\n    return (_a = axis.tickCount) !== null && _a !== void 0 ? _a : defaultTickCount({\n      fieldOrDatumDef: fieldOrDatumDef,\n      scaleType: scaleType,\n      size: size,\n      values: axis.values\n    });\n  },\n  title: function title(_ref13) {\n    var axis = _ref13.axis,\n      model = _ref13.model,\n      channel = _ref13.channel;\n    if (axis.title !== undefined) {\n      return axis.title;\n    }\n    var fieldDefTitle = getFieldDefTitle(model, channel);\n    if (fieldDefTitle !== undefined) {\n      return fieldDefTitle;\n    }\n    var fieldDef = model.typedFieldDef(channel);\n    var channel2 = channel === 'x' ? 'x2' : 'y2';\n    var fieldDef2 = model.fieldDef(channel2);\n    // If title not specified, store base parts of fieldDef (and fieldDef2 if exists)\n    return mergeTitleFieldDefs(fieldDef ? [toFieldDefBase(fieldDef)] : [], isFieldDef(fieldDef2) ? [toFieldDefBase(fieldDef2)] : []);\n  },\n  values: function values(_ref14) {\n    var axis = _ref14.axis,\n      fieldOrDatumDef = _ref14.fieldOrDatumDef;\n    return _values(axis, fieldOrDatumDef);\n  },\n  zindex: function zindex(_ref15) {\n    var axis = _ref15.axis,\n      fieldOrDatumDef = _ref15.fieldOrDatumDef,\n      mark = _ref15.mark;\n    var _a;\n    return (_a = axis.zindex) !== null && _a !== void 0 ? _a : defaultZindex(mark, fieldOrDatumDef);\n  }\n};\n// TODO: we need to refactor this method after we take care of config refactoring\n/**\n * Default rules for whether to show a grid should be shown for a channel.\n * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned\n */\nexport function defaultGrid(scaleType, fieldDef) {\n  return !hasDiscreteDomain(scaleType) && isFieldDef(fieldDef) && !isBinning(fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) && !isBinned(fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin);\n}\nfunction _gridScale(model, channel) {\n  var gridChannel = channel === 'x' ? 'y' : 'x';\n  if (model.getScaleComponent(gridChannel)) {\n    return model.scaleName(gridChannel);\n  }\n  return undefined;\n}\nexport { _gridScale as gridScale };\nexport function getLabelAngle(fieldOrDatumDef, axis, channel, styleConfig, axisConfigs) {\n  var labelAngle = axis === null || axis === void 0 ? void 0 : axis.labelAngle;\n  // try axis value\n  if (labelAngle !== undefined) {\n    return isSignalRef(labelAngle) ? labelAngle : normalizeAngle(labelAngle);\n  } else {\n    // try axis config value\n    var _getAxisConfig = getAxisConfig('labelAngle', styleConfig, axis === null || axis === void 0 ? void 0 : axis.style, axisConfigs),\n      angle = _getAxisConfig.configValue;\n    if (angle !== undefined) {\n      return normalizeAngle(angle);\n    } else {\n      // get default value\n      if (channel === X && contains([NOMINAL, ORDINAL], fieldOrDatumDef.type) && !(isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit)) {\n        return 270;\n      }\n      // no default\n      return undefined;\n    }\n  }\n}\nexport function normalizeAngleExpr(angle) {\n  return \"(((\".concat(angle.signal, \" % 360) + 360) % 360)\");\n}\nexport function defaultLabelBaseline(angle, orient, channel, alwaysIncludeMiddle) {\n  if (angle !== undefined) {\n    if (channel === 'x') {\n      if (isSignalRef(angle)) {\n        var a = normalizeAngleExpr(angle);\n        var orientIsTop = isSignalRef(orient) ? \"(\".concat(orient.signal, \" === \\\"top\\\")\") : orient === 'top';\n        return {\n          signal: \"(45 < \".concat(a, \" && \").concat(a, \" < 135) || (225 < \").concat(a, \" && \").concat(a, \" < 315) ? \\\"middle\\\" :\") + \"(\".concat(a, \" <= 45 || 315 <= \").concat(a, \") === \").concat(orientIsTop, \" ? \\\"bottom\\\" : \\\"top\\\"\")\n        };\n      }\n      if (45 < angle && angle < 135 || 225 < angle && angle < 315) {\n        return 'middle';\n      }\n      if (isSignalRef(orient)) {\n        var op = angle <= 45 || 315 <= angle ? '===' : '!==';\n        return {\n          signal: \"\".concat(orient.signal, \" \").concat(op, \" \\\"top\\\" ? \\\"bottom\\\" : \\\"top\\\"\")\n        };\n      }\n      return (angle <= 45 || 315 <= angle) === (orient === 'top') ? 'bottom' : 'top';\n    } else {\n      if (isSignalRef(angle)) {\n        var _a2 = normalizeAngleExpr(angle);\n        var orientIsLeft = isSignalRef(orient) ? \"(\".concat(orient.signal, \" === \\\"left\\\")\") : orient === 'left';\n        var middle = alwaysIncludeMiddle ? '\"middle\"' : 'null';\n        return {\n          signal: \"\".concat(_a2, \" <= 45 || 315 <= \").concat(_a2, \" || (135 <= \").concat(_a2, \" && \").concat(_a2, \" <= 225) ? \").concat(middle, \" : (45 <= \").concat(_a2, \" && \").concat(_a2, \" <= 135) === \").concat(orientIsLeft, \" ? \\\"top\\\" : \\\"bottom\\\"\")\n        };\n      }\n      if (angle <= 45 || 315 <= angle || 135 <= angle && angle <= 225) {\n        return alwaysIncludeMiddle ? 'middle' : null;\n      }\n      if (isSignalRef(orient)) {\n        var _op = 45 <= angle && angle <= 135 ? '===' : '!==';\n        return {\n          signal: \"\".concat(orient.signal, \" \").concat(_op, \" \\\"left\\\" ? \\\"top\\\" : \\\"bottom\\\"\")\n        };\n      }\n      return (45 <= angle && angle <= 135) === (orient === 'left') ? 'top' : 'bottom';\n    }\n  }\n  return undefined;\n}\nexport function defaultLabelAlign(angle, orient, channel) {\n  if (angle === undefined) {\n    return undefined;\n  }\n  var isX = channel === 'x';\n  var startAngle = isX ? 0 : 90;\n  var mainOrient = isX ? 'bottom' : 'left';\n  if (isSignalRef(angle)) {\n    var a = normalizeAngleExpr(angle);\n    var orientIsMain = isSignalRef(orient) ? \"(\".concat(orient.signal, \" === \\\"\").concat(mainOrient, \"\\\")\") : orient === mainOrient;\n    return {\n      signal: \"(\".concat(startAngle ? \"(\".concat(a, \" + 90)\") : a, \" % 180 === 0) ? \").concat(isX ? null : '\"center\"', \" :\") + \"(\".concat(startAngle, \" < \").concat(a, \" && \").concat(a, \" < \").concat(180 + startAngle, \") === \").concat(orientIsMain, \" ? \\\"left\\\" : \\\"right\\\"\")\n    };\n  }\n  if ((angle + startAngle) % 180 === 0) {\n    // For bottom, use default label align so label flush still works\n    return isX ? null : 'center';\n  }\n  if (isSignalRef(orient)) {\n    var op = startAngle < angle && angle < 180 + startAngle ? '===' : '!==';\n    var _orientIsMain = \"\".concat(orient.signal, \" \").concat(op, \" \\\"\").concat(mainOrient, \"\\\"\");\n    return {\n      signal: \"\".concat(_orientIsMain, \" ? \\\"left\\\" : \\\"right\\\"\")\n    };\n  }\n  if ((startAngle < angle && angle < 180 + startAngle) === (orient === mainOrient)) {\n    return 'left';\n  }\n  return 'right';\n}\nexport function defaultLabelFlush(type, channel) {\n  if (channel === 'x' && contains(['quantitative', 'temporal'], type)) {\n    return true;\n  }\n  return undefined;\n}\nexport function defaultLabelOverlap(type, scaleType, hasTimeUnit, sort) {\n  // do not prevent overlap for nominal data because there is no way to infer what the missing labels are\n  if (hasTimeUnit && !isObject(sort) || type !== 'nominal' && type !== 'ordinal') {\n    if (scaleType === 'log' || scaleType === 'symlog') {\n      return 'greedy';\n    }\n    return true;\n  }\n  return undefined;\n}\nexport function defaultOrient(channel) {\n  return channel === 'x' ? 'bottom' : 'left';\n}\nexport function defaultTickCount(_ref16) {\n  var fieldOrDatumDef = _ref16.fieldOrDatumDef,\n    scaleType = _ref16.scaleType,\n    size = _ref16.size,\n    vals = _ref16.values;\n  var _a;\n  if (!vals && !hasDiscreteDomain(scaleType) && scaleType !== 'log') {\n    if (isFieldDef(fieldOrDatumDef)) {\n      if (isBinning(fieldOrDatumDef.bin)) {\n        // for binned data, we don't want more ticks than maxbins\n        return {\n          signal: \"ceil(\".concat(size.signal, \"/10)\")\n        };\n      }\n      if (fieldOrDatumDef.timeUnit && contains(['month', 'hours', 'day', 'quarter'], (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit)) {\n        return undefined;\n      }\n    }\n    return {\n      signal: \"ceil(\".concat(size.signal, \"/40)\")\n    };\n  }\n  return undefined;\n}\nexport function getFieldDefTitle(model, channel) {\n  var channel2 = channel === 'x' ? 'x2' : 'y2';\n  var fieldDef = model.fieldDef(channel);\n  var fieldDef2 = model.fieldDef(channel2);\n  var title1 = fieldDef ? fieldDef.title : undefined;\n  var title2 = fieldDef2 ? fieldDef2.title : undefined;\n  if (title1 && title2) {\n    return mergeTitle(title1, title2);\n  } else if (title1) {\n    return title1;\n  } else if (title2) {\n    return title2;\n  } else if (title1 !== undefined) {\n    // falsy value to disable config\n    return title1;\n  } else if (title2 !== undefined) {\n    // falsy value to disable config\n    return title2;\n  }\n  return undefined;\n}\nfunction _values(axis, fieldOrDatumDef) {\n  var vals = axis.values;\n  if (isArray(vals)) {\n    return valueArray(fieldOrDatumDef, vals);\n  } else if (isSignalRef(vals)) {\n    return vals;\n  }\n  return undefined;\n}\nexport { _values as values };\nexport function defaultZindex(mark, fieldDef) {\n  if (mark === 'rect' && isDiscrete(fieldDef)) {\n    return 1;\n  }\n  return 0;\n}","map":{"version":3,"sources":["../../../../src/compile/axis/properties.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray, isObject } from 'vega-util';\nimport { isBinned, isBinning } from '../../bin';\nimport { X } from '../../channel';\nimport { isDiscrete, isFieldDef, toFieldDefBase, valueArray } from '../../channeldef';\nimport { hasDiscreteDomain } from '../../scale';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport { NOMINAL, ORDINAL } from '../../type';\nimport { contains, normalizeAngle } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { mergeTitle, mergeTitleFieldDefs } from '../common';\nimport { guideFormat, guideFormatType } from '../format';\nimport { getAxisConfig } from './config';\nexport const axisRules = {\n    scale: ({ model, channel }) => model.scaleName(channel),\n    format: ({ fieldOrDatumDef, config, axis }) => {\n        const { format, formatType } = axis;\n        return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format, formatType, config, true);\n    },\n    formatType: ({ axis, fieldOrDatumDef, scaleType }) => {\n        const { formatType } = axis;\n        return guideFormatType(formatType, fieldOrDatumDef, scaleType);\n    },\n    grid: ({ fieldOrDatumDef, axis, scaleType }) => { var _a; return (_a = axis.grid) !== null && _a !== void 0 ? _a : defaultGrid(scaleType, fieldOrDatumDef); },\n    gridScale: ({ model, channel }) => gridScale(model, channel),\n    labelAlign: ({ axis, labelAngle, orient, channel }) => axis.labelAlign || defaultLabelAlign(labelAngle, orient, channel),\n    labelAngle: ({ labelAngle }) => labelAngle,\n    labelBaseline: ({ axis, labelAngle, orient, channel }) => axis.labelBaseline || defaultLabelBaseline(labelAngle, orient, channel),\n    labelFlush: ({ axis, fieldOrDatumDef, channel }) => { var _a; return (_a = axis.labelFlush) !== null && _a !== void 0 ? _a : defaultLabelFlush(fieldOrDatumDef.type, channel); },\n    labelOverlap: ({ axis, fieldOrDatumDef, scaleType }) => {\n        var _a;\n        return (_a = axis.labelOverlap) !== null && _a !== void 0 ? _a : defaultLabelOverlap(fieldOrDatumDef.type, scaleType, isFieldDef(fieldOrDatumDef) && !!fieldOrDatumDef.timeUnit, isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : undefined);\n    },\n    // we already calculate orient in parse\n    orient: ({ orient }) => orient,\n    tickCount: ({ channel, model, axis, fieldOrDatumDef, scaleType }) => {\n        var _a;\n        const sizeType = channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;\n        const size = sizeType ? model.getSizeSignalRef(sizeType) : undefined;\n        return (_a = axis.tickCount) !== null && _a !== void 0 ? _a : defaultTickCount({ fieldOrDatumDef, scaleType, size, values: axis.values });\n    },\n    title: ({ axis, model, channel }) => {\n        if (axis.title !== undefined) {\n            return axis.title;\n        }\n        const fieldDefTitle = getFieldDefTitle(model, channel);\n        if (fieldDefTitle !== undefined) {\n            return fieldDefTitle;\n        }\n        const fieldDef = model.typedFieldDef(channel);\n        const channel2 = channel === 'x' ? 'x2' : 'y2';\n        const fieldDef2 = model.fieldDef(channel2);\n        // If title not specified, store base parts of fieldDef (and fieldDef2 if exists)\n        return mergeTitleFieldDefs(fieldDef ? [toFieldDefBase(fieldDef)] : [], isFieldDef(fieldDef2) ? [toFieldDefBase(fieldDef2)] : []);\n    },\n    values: ({ axis, fieldOrDatumDef }) => values(axis, fieldOrDatumDef),\n    zindex: ({ axis, fieldOrDatumDef, mark }) => { var _a; return (_a = axis.zindex) !== null && _a !== void 0 ? _a : defaultZindex(mark, fieldOrDatumDef); }\n};\n// TODO: we need to refactor this method after we take care of config refactoring\n/**\n * Default rules for whether to show a grid should be shown for a channel.\n * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned\n */\nexport function defaultGrid(scaleType, fieldDef) {\n    return !hasDiscreteDomain(scaleType) && isFieldDef(fieldDef) && !isBinning(fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) && !isBinned(fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin);\n}\nexport function gridScale(model, channel) {\n    const gridChannel = channel === 'x' ? 'y' : 'x';\n    if (model.getScaleComponent(gridChannel)) {\n        return model.scaleName(gridChannel);\n    }\n    return undefined;\n}\nexport function getLabelAngle(fieldOrDatumDef, axis, channel, styleConfig, axisConfigs) {\n    const labelAngle = axis === null || axis === void 0 ? void 0 : axis.labelAngle;\n    // try axis value\n    if (labelAngle !== undefined) {\n        return isSignalRef(labelAngle) ? labelAngle : normalizeAngle(labelAngle);\n    }\n    else {\n        // try axis config value\n        const { configValue: angle } = getAxisConfig('labelAngle', styleConfig, axis === null || axis === void 0 ? void 0 : axis.style, axisConfigs);\n        if (angle !== undefined) {\n            return normalizeAngle(angle);\n        }\n        else {\n            // get default value\n            if (channel === X &&\n                contains([NOMINAL, ORDINAL], fieldOrDatumDef.type) &&\n                !(isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit)) {\n                return 270;\n            }\n            // no default\n            return undefined;\n        }\n    }\n}\nexport function normalizeAngleExpr(angle) {\n    return `(((${angle.signal} % 360) + 360) % 360)`;\n}\nexport function defaultLabelBaseline(angle, orient, channel, alwaysIncludeMiddle) {\n    if (angle !== undefined) {\n        if (channel === 'x') {\n            if (isSignalRef(angle)) {\n                const a = normalizeAngleExpr(angle);\n                const orientIsTop = isSignalRef(orient) ? `(${orient.signal} === \"top\")` : orient === 'top';\n                return {\n                    signal: `(45 < ${a} && ${a} < 135) || (225 < ${a} && ${a} < 315) ? \"middle\" :` +\n                        `(${a} <= 45 || 315 <= ${a}) === ${orientIsTop} ? \"bottom\" : \"top\"`\n                };\n            }\n            if ((45 < angle && angle < 135) || (225 < angle && angle < 315)) {\n                return 'middle';\n            }\n            if (isSignalRef(orient)) {\n                const op = angle <= 45 || 315 <= angle ? '===' : '!==';\n                return { signal: `${orient.signal} ${op} \"top\" ? \"bottom\" : \"top\"` };\n            }\n            return (angle <= 45 || 315 <= angle) === (orient === 'top') ? 'bottom' : 'top';\n        }\n        else {\n            if (isSignalRef(angle)) {\n                const a = normalizeAngleExpr(angle);\n                const orientIsLeft = isSignalRef(orient) ? `(${orient.signal} === \"left\")` : orient === 'left';\n                const middle = alwaysIncludeMiddle ? '\"middle\"' : 'null';\n                return {\n                    signal: `${a} <= 45 || 315 <= ${a} || (135 <= ${a} && ${a} <= 225) ? ${middle} : (45 <= ${a} && ${a} <= 135) === ${orientIsLeft} ? \"top\" : \"bottom\"`\n                };\n            }\n            if (angle <= 45 || 315 <= angle || (135 <= angle && angle <= 225)) {\n                return alwaysIncludeMiddle ? 'middle' : null;\n            }\n            if (isSignalRef(orient)) {\n                const op = 45 <= angle && angle <= 135 ? '===' : '!==';\n                return { signal: `${orient.signal} ${op} \"left\" ? \"top\" : \"bottom\"` };\n            }\n            return (45 <= angle && angle <= 135) === (orient === 'left') ? 'top' : 'bottom';\n        }\n    }\n    return undefined;\n}\nexport function defaultLabelAlign(angle, orient, channel) {\n    if (angle === undefined) {\n        return undefined;\n    }\n    const isX = channel === 'x';\n    const startAngle = isX ? 0 : 90;\n    const mainOrient = isX ? 'bottom' : 'left';\n    if (isSignalRef(angle)) {\n        const a = normalizeAngleExpr(angle);\n        const orientIsMain = isSignalRef(orient) ? `(${orient.signal} === \"${mainOrient}\")` : orient === mainOrient;\n        return {\n            signal: `(${startAngle ? `(${a} + 90)` : a} % 180 === 0) ? ${isX ? null : '\"center\"'} :` +\n                `(${startAngle} < ${a} && ${a} < ${180 + startAngle}) === ${orientIsMain} ? \"left\" : \"right\"`\n        };\n    }\n    if ((angle + startAngle) % 180 === 0) {\n        // For bottom, use default label align so label flush still works\n        return isX ? null : 'center';\n    }\n    if (isSignalRef(orient)) {\n        const op = startAngle < angle && angle < 180 + startAngle ? '===' : '!==';\n        const orientIsMain = `${orient.signal} ${op} \"${mainOrient}\"`;\n        return {\n            signal: `${orientIsMain} ? \"left\" : \"right\"`\n        };\n    }\n    if ((startAngle < angle && angle < 180 + startAngle) === (orient === mainOrient)) {\n        return 'left';\n    }\n    return 'right';\n}\nexport function defaultLabelFlush(type, channel) {\n    if (channel === 'x' && contains(['quantitative', 'temporal'], type)) {\n        return true;\n    }\n    return undefined;\n}\nexport function defaultLabelOverlap(type, scaleType, hasTimeUnit, sort) {\n    // do not prevent overlap for nominal data because there is no way to infer what the missing labels are\n    if ((hasTimeUnit && !isObject(sort)) || (type !== 'nominal' && type !== 'ordinal')) {\n        if (scaleType === 'log' || scaleType === 'symlog') {\n            return 'greedy';\n        }\n        return true;\n    }\n    return undefined;\n}\nexport function defaultOrient(channel) {\n    return channel === 'x' ? 'bottom' : 'left';\n}\nexport function defaultTickCount({ fieldOrDatumDef, scaleType, size, values: vals }) {\n    var _a;\n    if (!vals && !hasDiscreteDomain(scaleType) && scaleType !== 'log') {\n        if (isFieldDef(fieldOrDatumDef)) {\n            if (isBinning(fieldOrDatumDef.bin)) {\n                // for binned data, we don't want more ticks than maxbins\n                return { signal: `ceil(${size.signal}/10)` };\n            }\n            if (fieldOrDatumDef.timeUnit &&\n                contains(['month', 'hours', 'day', 'quarter'], (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit)) {\n                return undefined;\n            }\n        }\n        return { signal: `ceil(${size.signal}/40)` };\n    }\n    return undefined;\n}\nexport function getFieldDefTitle(model, channel) {\n    const channel2 = channel === 'x' ? 'x2' : 'y2';\n    const fieldDef = model.fieldDef(channel);\n    const fieldDef2 = model.fieldDef(channel2);\n    const title1 = fieldDef ? fieldDef.title : undefined;\n    const title2 = fieldDef2 ? fieldDef2.title : undefined;\n    if (title1 && title2) {\n        return mergeTitle(title1, title2);\n    }\n    else if (title1) {\n        return title1;\n    }\n    else if (title2) {\n        return title2;\n    }\n    else if (title1 !== undefined) {\n        // falsy value to disable config\n        return title1;\n    }\n    else if (title2 !== undefined) {\n        // falsy value to disable config\n        return title2;\n    }\n    return undefined;\n}\nexport function values(axis, fieldOrDatumDef) {\n    const vals = axis.values;\n    if (isArray(vals)) {\n        return valueArray(fieldOrDatumDef, vals);\n    }\n    else if (isSignalRef(vals)) {\n        return vals;\n    }\n    return undefined;\n}\nexport function defaultZindex(mark, fieldDef) {\n    if (mark === 'rect' && isDiscrete(fieldDef)) {\n        return 1;\n    }\n    return 0;\n}\n//# sourceMappingURL=properties.js.map"]},"metadata":{},"sourceType":"module"}