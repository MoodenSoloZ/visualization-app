{"ast":null,"code":"import { Transform, isTuple, ingest, tupleid, stableCompare } from 'vega-dataflow';\nimport { inherits, error, array, one, truthy, hasOwnProperty } from 'vega-util';\nimport { hierarchy, pack, partition, stratify, tree, cluster, treemap, treemapBinary, treemapDice, treemapSlice, treemapSliceDice, treemapSquarify, treemapResquarify } from 'd3-hierarchy';\n\n// Build lookup table mapping tuple keys to tree node instances\nfunction lookup(tree, key, filter) {\n  var map = {};\n  tree.each(function (node) {\n    var t = node.data;\n    if (filter(t)) map[key(t)] = node;\n  });\n  tree.lookup = map;\n  return tree;\n}\n\n/**\n * Nest tuples into a tree structure, grouped by key values.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.keys - The key fields to nest by, in order.\n * @param {boolean} [params.generate=false] - A boolean flag indicating if\n *   non-leaf nodes generated by this transform should be included in the\n *   output. The default (false) includes only the input data (leaf nodes)\n *   in the data stream.\n */\n\nfunction Nest(params) {\n  Transform.call(this, null, params);\n}\nNest.Definition = {\n  'type': 'Nest',\n  'metadata': {\n    'treesource': true,\n    'changes': true\n  },\n  'params': [{\n    'name': 'keys',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'generate',\n    'type': 'boolean'\n  }]\n};\nvar children = function children(n) {\n  return n.values;\n};\ninherits(Nest, Transform, {\n  transform: function transform(_, pulse) {\n    if (!pulse.source) {\n      error('Nest transform requires an upstream data source.');\n    }\n    var gen = _.generate,\n      mod = _.modified(),\n      out = pulse.clone(),\n      tree = this.value;\n    if (!tree || mod || pulse.changed()) {\n      // collect nodes to remove\n      if (tree) {\n        tree.each(function (node) {\n          if (node.children && isTuple(node.data)) {\n            out.rem.push(node.data);\n          }\n        });\n      } // generate new tree structure\n\n      this.value = tree = hierarchy({\n        values: array(_.keys).reduce(function (n, k) {\n          n.key(k);\n          return n;\n        }, nest()).entries(out.source)\n      }, children); // collect nodes to add\n\n      if (gen) {\n        tree.each(function (node) {\n          if (node.children) {\n            node = ingest(node.data);\n            out.add.push(node);\n            out.source.push(node);\n          }\n        });\n      } // build lookup table\n\n      lookup(tree, tupleid, tupleid);\n    }\n    out.source.root = tree;\n    return out;\n  }\n});\nfunction nest() {\n  var keys = [],\n    nest = {\n      entries: function entries(array) {\n        return _entries(apply(array, 0), 0);\n      },\n      key: function key(d) {\n        return keys.push(d), nest;\n      }\n    };\n  function apply(array, depth) {\n    if (depth >= keys.length) {\n      return array;\n    }\n    var n = array.length,\n      key = keys[depth++],\n      valuesByKey = {},\n      result = {};\n    var i = -1,\n      keyValue,\n      value,\n      values;\n    while (++i < n) {\n      keyValue = key(value = array[i]) + '';\n      if (values = valuesByKey[keyValue]) {\n        values.push(value);\n      } else {\n        valuesByKey[keyValue] = [value];\n      }\n    }\n    for (keyValue in valuesByKey) {\n      result[keyValue] = apply(valuesByKey[keyValue], depth);\n    }\n    return result;\n  }\n  function _entries(map, depth) {\n    if (++depth > keys.length) return map;\n    var array = [];\n    for (var key in map) {\n      array.push({\n        key: key,\n        values: _entries(map[key], depth)\n      });\n    }\n    return array;\n  }\n  return nest;\n}\n\n/**\n * Abstract class for tree layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction HierarchyLayout(params) {\n  Transform.call(this, null, params);\n}\nvar defaultSeparation = function defaultSeparation(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n};\ninherits(HierarchyLayout, Transform, {\n  transform: function transform(_, pulse) {\n    if (!pulse.source || !pulse.source.root) {\n      error(this.constructor.name + ' transform requires a backing tree data source.');\n    }\n    var layout = this.layout(_.method),\n      fields = this.fields,\n      root = pulse.source.root,\n      as = _.as || fields;\n    if (_.field) root.sum(_.field);else root.count();\n    if (_.sort) root.sort(stableCompare(_.sort, function (d) {\n      return d.data;\n    }));\n    setParams(layout, this.params, _);\n    if (layout.separation) {\n      layout.separation(_.separation !== false ? defaultSeparation : one);\n    }\n    try {\n      this.value = layout(root);\n    } catch (err) {\n      error(err);\n    }\n    root.each(function (node) {\n      return setFields(node, fields, as);\n    });\n    return pulse.reflow(_.modified()).modifies(as).modifies('leaf');\n  }\n});\nfunction setParams(layout, params, _) {\n  for (var p, i = 0, n = params.length; i < n; ++i) {\n    p = params[i];\n    if (p in _) layout[p](_[p]);\n  }\n}\nfunction setFields(node, fields, as) {\n  var t = node.data,\n    n = fields.length - 1;\n  for (var i = 0; i < n; ++i) {\n    t[as[i]] = node[fields[i]];\n  }\n  t[as[n]] = node.children ? node.children.length : 0;\n}\nvar Output$3 = ['x', 'y', 'r', 'depth', 'children'];\n/**\n * Packed circle tree layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size nodes.\n */\n\nfunction Pack(params) {\n  HierarchyLayout.call(this, params);\n}\nPack.Definition = {\n  'type': 'Pack',\n  'metadata': {\n    'tree': true,\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'padding',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'radius',\n    'type': 'field',\n    'default': null\n  }, {\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': Output$3.length,\n    'default': Output$3\n  }]\n};\ninherits(Pack, HierarchyLayout, {\n  layout: pack,\n  params: ['radius', 'size', 'padding'],\n  fields: Output$3\n});\nvar Output$2 = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];\n/**\n * Partition tree layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size nodes.\n */\n\nfunction Partition(params) {\n  HierarchyLayout.call(this, params);\n}\nPartition.Definition = {\n  'type': 'Partition',\n  'metadata': {\n    'tree': true,\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'padding',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'round',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': Output$2.length,\n    'default': Output$2\n  }]\n};\ninherits(Partition, HierarchyLayout, {\n  layout: partition,\n  params: ['size', 'round', 'padding'],\n  fields: Output$2\n});\n\n/**\n * Stratify a collection of tuples into a tree structure based on\n * id and parent id fields.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.key - Unique key field for each tuple.\n * @param {function(object): *} params.parentKey - Field with key for parent tuple.\n */\n\nfunction Stratify(params) {\n  Transform.call(this, null, params);\n}\nStratify.Definition = {\n  'type': 'Stratify',\n  'metadata': {\n    'treesource': true\n  },\n  'params': [{\n    'name': 'key',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'parentKey',\n    'type': 'field',\n    'required': true\n  }]\n};\ninherits(Stratify, Transform, {\n  transform: function transform(_, pulse) {\n    if (!pulse.source) {\n      error('Stratify transform requires an upstream data source.');\n    }\n    var tree = this.value;\n    var mod = _.modified(),\n      out = pulse.fork(pulse.ALL).materialize(pulse.SOURCE),\n      run = !tree || mod || pulse.changed(pulse.ADD_REM) || pulse.modified(_.key.fields) || pulse.modified(_.parentKey.fields); // prevent upstream source pollution\n\n    out.source = out.source.slice();\n    if (run) {\n      tree = out.source.length ? lookup(stratify().id(_.key).parentId(_.parentKey)(out.source), _.key, truthy) : lookup(stratify()([{}]), _.key, _.key);\n    }\n    out.source.root = this.value = tree;\n    return out;\n  }\n});\nvar Layouts = {\n  tidy: tree,\n  cluster: cluster\n};\nvar Output$1 = ['x', 'y', 'depth', 'children'];\n/**\n * Tree layout. Depending on the method parameter, performs either\n * Reingold-Tilford 'tidy' layout or dendrogram 'cluster' layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction Tree(params) {\n  HierarchyLayout.call(this, params);\n}\nTree.Definition = {\n  'type': 'Tree',\n  'metadata': {\n    'tree': true,\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'method',\n    'type': 'enum',\n    'default': 'tidy',\n    'values': ['tidy', 'cluster']\n  }, {\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'nodeSize',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'separation',\n    'type': 'boolean',\n    'default': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': Output$1.length,\n    'default': Output$1\n  }]\n};\ninherits(Tree, HierarchyLayout, {\n  /**\n   * Tree layout generator. Supports both 'tidy' and 'cluster' layouts.\n   */\n  layout: function layout(method) {\n    var m = method || 'tidy';\n    if (hasOwnProperty(Layouts, m)) return Layouts[m]();else error('Unrecognized Tree layout method: ' + m);\n  },\n  params: ['size', 'nodeSize'],\n  fields: Output$1\n});\n\n/**\n * Generate tuples representing links between tree nodes.\n * The resulting tuples will contain 'source' and 'target' fields,\n * which point to parent and child node tuples, respectively.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction TreeLinks(params) {\n  Transform.call(this, [], params);\n}\nTreeLinks.Definition = {\n  'type': 'TreeLinks',\n  'metadata': {\n    'tree': true,\n    'generates': true,\n    'changes': true\n  },\n  'params': []\n};\ninherits(TreeLinks, Transform, {\n  transform: function transform(_, pulse) {\n    var links = this.value,\n      tree = pulse.source && pulse.source.root,\n      out = pulse.fork(pulse.NO_SOURCE),\n      lut = {};\n    if (!tree) error('TreeLinks transform requires a tree data source.');\n    if (pulse.changed(pulse.ADD_REM)) {\n      // remove previous links\n      out.rem = links; // build lookup table of valid tuples\n\n      pulse.visit(pulse.SOURCE, function (t) {\n        return lut[tupleid(t)] = 1;\n      }); // generate links for all edges incident on valid tuples\n\n      tree.each(function (node) {\n        var t = node.data,\n          p = node.parent && node.parent.data;\n        if (p && lut[tupleid(t)] && lut[tupleid(p)]) {\n          out.add.push(ingest({\n            source: p,\n            target: t\n          }));\n        }\n      });\n      this.value = out.add;\n    } else if (pulse.changed(pulse.MOD)) {\n      // build lookup table of modified tuples\n      pulse.visit(pulse.MOD, function (t) {\n        return lut[tupleid(t)] = 1;\n      }); // gather links incident on modified tuples\n\n      links.forEach(function (link) {\n        if (lut[tupleid(link.source)] || lut[tupleid(link.target)]) {\n          out.mod.push(link);\n        }\n      });\n    }\n    return out;\n  }\n});\nvar Tiles = {\n  binary: treemapBinary,\n  dice: treemapDice,\n  slice: treemapSlice,\n  slicedice: treemapSliceDice,\n  squarify: treemapSquarify,\n  resquarify: treemapResquarify\n};\nvar Output = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];\n/**\n * Treemap layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size nodes.\n */\n\nfunction Treemap(params) {\n  HierarchyLayout.call(this, params);\n}\nTreemap.Definition = {\n  'type': 'Treemap',\n  'metadata': {\n    'tree': true,\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'method',\n    'type': 'enum',\n    'default': 'squarify',\n    'values': ['squarify', 'resquarify', 'binary', 'dice', 'slice', 'slicedice']\n  }, {\n    'name': 'padding',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingInner',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingOuter',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingTop',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingRight',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingBottom',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingLeft',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'ratio',\n    'type': 'number',\n    'default': 1.618033988749895\n  }, {\n    'name': 'round',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': Output.length,\n    'default': Output\n  }]\n};\ninherits(Treemap, HierarchyLayout, {\n  /**\n   * Treemap layout generator. Adds 'method' and 'ratio' parameters\n   * to configure the underlying tile method.\n   */\n  layout: function layout() {\n    var x = treemap();\n    x.ratio = function (_) {\n      var t = x.tile();\n      if (t.ratio) x.tile(t.ratio(_));\n    };\n    x.method = function (_) {\n      if (hasOwnProperty(Tiles, _)) x.tile(Tiles[_]);else error('Unrecognized Treemap layout method: ' + _);\n    };\n    return x;\n  },\n  params: ['method', 'ratio', 'size', 'round', 'padding', 'paddingInner', 'paddingOuter', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft'],\n  fields: Output\n});\nexport { Nest as nest, Pack as pack, Partition as partition, Stratify as stratify, Tree as tree, TreeLinks as treelinks, Treemap as treemap };","map":{"version":3,"names":["Transform","isTuple","ingest","tupleid","stableCompare","inherits","error","array","one","truthy","hasOwnProperty","hierarchy","pack","partition","stratify","tree","cluster","treemap","treemapBinary","treemapDice","treemapSlice","treemapSliceDice","treemapSquarify","treemapResquarify","lookup","key","filter","map","each","node","t","data","Nest","params","call","Definition","children","n","values","transform","_","pulse","source","gen","generate","mod","modified","out","clone","value","changed","rem","push","keys","reduce","k","nest","entries","add","root","apply","d","depth","length","valuesByKey","result","i","keyValue","HierarchyLayout","defaultSeparation","a","b","parent","constructor","name","layout","method","fields","as","field","sum","count","sort","setParams","separation","err","setFields","reflow","modifies","p","Output$3","Pack","Output$2","Partition","Stratify","fork","ALL","materialize","SOURCE","run","ADD_REM","parentKey","slice","id","parentId","Layouts","tidy","Output$1","Tree","m","TreeLinks","links","NO_SOURCE","lut","visit","target","MOD","forEach","link","Tiles","binary","dice","slicedice","squarify","resquarify","Output","Treemap","x","ratio","tile","treelinks"],"sources":["/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/vega-hierarchy/build/vega-hierarchy.module.js"],"sourcesContent":["import { Transform, isTuple, ingest, tupleid, stableCompare } from 'vega-dataflow';\nimport { inherits, error, array, one, truthy, hasOwnProperty } from 'vega-util';\nimport { hierarchy, pack, partition, stratify, tree, cluster, treemap, treemapBinary, treemapDice, treemapSlice, treemapSliceDice, treemapSquarify, treemapResquarify } from 'd3-hierarchy';\n\n// Build lookup table mapping tuple keys to tree node instances\nfunction lookup (tree, key, filter) {\n  const map = {};\n  tree.each(node => {\n    const t = node.data;\n    if (filter(t)) map[key(t)] = node;\n  });\n  tree.lookup = map;\n  return tree;\n}\n\n/**\n * Nest tuples into a tree structure, grouped by key values.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.keys - The key fields to nest by, in order.\n * @param {boolean} [params.generate=false] - A boolean flag indicating if\n *   non-leaf nodes generated by this transform should be included in the\n *   output. The default (false) includes only the input data (leaf nodes)\n *   in the data stream.\n */\n\nfunction Nest(params) {\n  Transform.call(this, null, params);\n}\nNest.Definition = {\n  'type': 'Nest',\n  'metadata': {\n    'treesource': true,\n    'changes': true\n  },\n  'params': [{\n    'name': 'keys',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'generate',\n    'type': 'boolean'\n  }]\n};\n\nconst children = n => n.values;\n\ninherits(Nest, Transform, {\n  transform(_, pulse) {\n    if (!pulse.source) {\n      error('Nest transform requires an upstream data source.');\n    }\n\n    var gen = _.generate,\n        mod = _.modified(),\n        out = pulse.clone(),\n        tree = this.value;\n\n    if (!tree || mod || pulse.changed()) {\n      // collect nodes to remove\n      if (tree) {\n        tree.each(node => {\n          if (node.children && isTuple(node.data)) {\n            out.rem.push(node.data);\n          }\n        });\n      } // generate new tree structure\n\n\n      this.value = tree = hierarchy({\n        values: array(_.keys).reduce((n, k) => {\n          n.key(k);\n          return n;\n        }, nest()).entries(out.source)\n      }, children); // collect nodes to add\n\n      if (gen) {\n        tree.each(node => {\n          if (node.children) {\n            node = ingest(node.data);\n            out.add.push(node);\n            out.source.push(node);\n          }\n        });\n      } // build lookup table\n\n\n      lookup(tree, tupleid, tupleid);\n    }\n\n    out.source.root = tree;\n    return out;\n  }\n\n});\n\nfunction nest() {\n  const keys = [],\n        nest = {\n    entries: array => entries(apply(array, 0), 0),\n    key: d => (keys.push(d), nest)\n  };\n\n  function apply(array, depth) {\n    if (depth >= keys.length) {\n      return array;\n    }\n\n    const n = array.length,\n          key = keys[depth++],\n          valuesByKey = {},\n          result = {};\n    let i = -1,\n        keyValue,\n        value,\n        values;\n\n    while (++i < n) {\n      keyValue = key(value = array[i]) + '';\n\n      if (values = valuesByKey[keyValue]) {\n        values.push(value);\n      } else {\n        valuesByKey[keyValue] = [value];\n      }\n    }\n\n    for (keyValue in valuesByKey) {\n      result[keyValue] = apply(valuesByKey[keyValue], depth);\n    }\n\n    return result;\n  }\n\n  function entries(map, depth) {\n    if (++depth > keys.length) return map;\n    const array = [];\n\n    for (const key in map) {\n      array.push({\n        key,\n        values: entries(map[key], depth)\n      });\n    }\n\n    return array;\n  }\n\n  return nest;\n}\n\n/**\n * Abstract class for tree layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction HierarchyLayout(params) {\n  Transform.call(this, null, params);\n}\n\nconst defaultSeparation = (a, b) => a.parent === b.parent ? 1 : 2;\n\ninherits(HierarchyLayout, Transform, {\n  transform(_, pulse) {\n    if (!pulse.source || !pulse.source.root) {\n      error(this.constructor.name + ' transform requires a backing tree data source.');\n    }\n\n    const layout = this.layout(_.method),\n          fields = this.fields,\n          root = pulse.source.root,\n          as = _.as || fields;\n    if (_.field) root.sum(_.field);else root.count();\n    if (_.sort) root.sort(stableCompare(_.sort, d => d.data));\n    setParams(layout, this.params, _);\n\n    if (layout.separation) {\n      layout.separation(_.separation !== false ? defaultSeparation : one);\n    }\n\n    try {\n      this.value = layout(root);\n    } catch (err) {\n      error(err);\n    }\n\n    root.each(node => setFields(node, fields, as));\n    return pulse.reflow(_.modified()).modifies(as).modifies('leaf');\n  }\n\n});\n\nfunction setParams(layout, params, _) {\n  for (let p, i = 0, n = params.length; i < n; ++i) {\n    p = params[i];\n    if (p in _) layout[p](_[p]);\n  }\n}\n\nfunction setFields(node, fields, as) {\n  const t = node.data,\n        n = fields.length - 1;\n\n  for (let i = 0; i < n; ++i) {\n    t[as[i]] = node[fields[i]];\n  }\n\n  t[as[n]] = node.children ? node.children.length : 0;\n}\n\nconst Output$3 = ['x', 'y', 'r', 'depth', 'children'];\n/**\n * Packed circle tree layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size nodes.\n */\n\nfunction Pack(params) {\n  HierarchyLayout.call(this, params);\n}\nPack.Definition = {\n  'type': 'Pack',\n  'metadata': {\n    'tree': true,\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'padding',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'radius',\n    'type': 'field',\n    'default': null\n  }, {\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': Output$3.length,\n    'default': Output$3\n  }]\n};\ninherits(Pack, HierarchyLayout, {\n  layout: pack,\n  params: ['radius', 'size', 'padding'],\n  fields: Output$3\n});\n\nconst Output$2 = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];\n/**\n * Partition tree layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size nodes.\n */\n\nfunction Partition(params) {\n  HierarchyLayout.call(this, params);\n}\nPartition.Definition = {\n  'type': 'Partition',\n  'metadata': {\n    'tree': true,\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'padding',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'round',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': Output$2.length,\n    'default': Output$2\n  }]\n};\ninherits(Partition, HierarchyLayout, {\n  layout: partition,\n  params: ['size', 'round', 'padding'],\n  fields: Output$2\n});\n\n/**\n * Stratify a collection of tuples into a tree structure based on\n * id and parent id fields.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.key - Unique key field for each tuple.\n * @param {function(object): *} params.parentKey - Field with key for parent tuple.\n */\n\nfunction Stratify(params) {\n  Transform.call(this, null, params);\n}\nStratify.Definition = {\n  'type': 'Stratify',\n  'metadata': {\n    'treesource': true\n  },\n  'params': [{\n    'name': 'key',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'parentKey',\n    'type': 'field',\n    'required': true\n  }]\n};\ninherits(Stratify, Transform, {\n  transform(_, pulse) {\n    if (!pulse.source) {\n      error('Stratify transform requires an upstream data source.');\n    }\n\n    let tree = this.value;\n\n    const mod = _.modified(),\n          out = pulse.fork(pulse.ALL).materialize(pulse.SOURCE),\n          run = !tree || mod || pulse.changed(pulse.ADD_REM) || pulse.modified(_.key.fields) || pulse.modified(_.parentKey.fields); // prevent upstream source pollution\n\n\n    out.source = out.source.slice();\n\n    if (run) {\n      tree = out.source.length ? lookup(stratify().id(_.key).parentId(_.parentKey)(out.source), _.key, truthy) : lookup(stratify()([{}]), _.key, _.key);\n    }\n\n    out.source.root = this.value = tree;\n    return out;\n  }\n\n});\n\nconst Layouts = {\n  tidy: tree,\n  cluster: cluster\n};\nconst Output$1 = ['x', 'y', 'depth', 'children'];\n/**\n * Tree layout. Depending on the method parameter, performs either\n * Reingold-Tilford 'tidy' layout or dendrogram 'cluster' layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction Tree(params) {\n  HierarchyLayout.call(this, params);\n}\nTree.Definition = {\n  'type': 'Tree',\n  'metadata': {\n    'tree': true,\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'method',\n    'type': 'enum',\n    'default': 'tidy',\n    'values': ['tidy', 'cluster']\n  }, {\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'nodeSize',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'separation',\n    'type': 'boolean',\n    'default': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': Output$1.length,\n    'default': Output$1\n  }]\n};\ninherits(Tree, HierarchyLayout, {\n  /**\n   * Tree layout generator. Supports both 'tidy' and 'cluster' layouts.\n   */\n  layout(method) {\n    const m = method || 'tidy';\n    if (hasOwnProperty(Layouts, m)) return Layouts[m]();else error('Unrecognized Tree layout method: ' + m);\n  },\n\n  params: ['size', 'nodeSize'],\n  fields: Output$1\n});\n\n/**\n * Generate tuples representing links between tree nodes.\n * The resulting tuples will contain 'source' and 'target' fields,\n * which point to parent and child node tuples, respectively.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction TreeLinks(params) {\n  Transform.call(this, [], params);\n}\nTreeLinks.Definition = {\n  'type': 'TreeLinks',\n  'metadata': {\n    'tree': true,\n    'generates': true,\n    'changes': true\n  },\n  'params': []\n};\ninherits(TreeLinks, Transform, {\n  transform(_, pulse) {\n    const links = this.value,\n          tree = pulse.source && pulse.source.root,\n          out = pulse.fork(pulse.NO_SOURCE),\n          lut = {};\n    if (!tree) error('TreeLinks transform requires a tree data source.');\n\n    if (pulse.changed(pulse.ADD_REM)) {\n      // remove previous links\n      out.rem = links; // build lookup table of valid tuples\n\n      pulse.visit(pulse.SOURCE, t => lut[tupleid(t)] = 1); // generate links for all edges incident on valid tuples\n\n      tree.each(node => {\n        const t = node.data,\n              p = node.parent && node.parent.data;\n\n        if (p && lut[tupleid(t)] && lut[tupleid(p)]) {\n          out.add.push(ingest({\n            source: p,\n            target: t\n          }));\n        }\n      });\n      this.value = out.add;\n    } else if (pulse.changed(pulse.MOD)) {\n      // build lookup table of modified tuples\n      pulse.visit(pulse.MOD, t => lut[tupleid(t)] = 1); // gather links incident on modified tuples\n\n      links.forEach(link => {\n        if (lut[tupleid(link.source)] || lut[tupleid(link.target)]) {\n          out.mod.push(link);\n        }\n      });\n    }\n\n    return out;\n  }\n\n});\n\nconst Tiles = {\n  binary: treemapBinary,\n  dice: treemapDice,\n  slice: treemapSlice,\n  slicedice: treemapSliceDice,\n  squarify: treemapSquarify,\n  resquarify: treemapResquarify\n};\nconst Output = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];\n/**\n * Treemap layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size nodes.\n */\n\nfunction Treemap(params) {\n  HierarchyLayout.call(this, params);\n}\nTreemap.Definition = {\n  'type': 'Treemap',\n  'metadata': {\n    'tree': true,\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'method',\n    'type': 'enum',\n    'default': 'squarify',\n    'values': ['squarify', 'resquarify', 'binary', 'dice', 'slice', 'slicedice']\n  }, {\n    'name': 'padding',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingInner',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingOuter',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingTop',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingRight',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingBottom',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'paddingLeft',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'ratio',\n    'type': 'number',\n    'default': 1.618033988749895\n  }, {\n    'name': 'round',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': Output.length,\n    'default': Output\n  }]\n};\ninherits(Treemap, HierarchyLayout, {\n  /**\n   * Treemap layout generator. Adds 'method' and 'ratio' parameters\n   * to configure the underlying tile method.\n   */\n  layout() {\n    const x = treemap();\n\n    x.ratio = _ => {\n      const t = x.tile();\n      if (t.ratio) x.tile(t.ratio(_));\n    };\n\n    x.method = _ => {\n      if (hasOwnProperty(Tiles, _)) x.tile(Tiles[_]);else error('Unrecognized Treemap layout method: ' + _);\n    };\n\n    return x;\n  },\n\n  params: ['method', 'ratio', 'size', 'round', 'padding', 'paddingInner', 'paddingOuter', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft'],\n  fields: Output\n});\n\nexport { Nest as nest, Pack as pack, Partition as partition, Stratify as stratify, Tree as tree, TreeLinks as treelinks, Treemap as treemap };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}