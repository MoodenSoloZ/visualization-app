{"ast":null,"code":"import _defineProperty from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { isArray } from 'vega-util';\nimport { isFieldDef, isValueDef, vgField } from '../../channeldef';\nimport { DataSourceType } from '../../data';\nimport { isAggregate, pathGroupingFields } from '../../encoding';\nimport { AREA, BAR, isPathMark, LINE, TRAIL } from '../../mark';\nimport { isSortByEncoding, isSortField } from '../../sort';\nimport { contains, getFirstDefined, isNullOrFalse, keys, omit, pick } from '../../util';\nimport { VG_CORNERRADIUS_CHANNELS } from '../../vega.schema';\nimport { getMarkConfig, getMarkPropOrConfig, getStyles, signalOrValueRef, sortParams } from '../common';\nimport { arc } from './arc';\nimport { area } from './area';\nimport { bar } from './bar';\nimport { geoshape } from './geoshape';\nimport { image } from './image';\nimport { line, trail } from './line';\nimport { circle, point, square } from './point';\nimport { rect } from './rect';\nimport { rule } from './rule';\nimport { text } from './text';\nimport { tick } from './tick';\nvar markCompiler = {\n  arc: arc,\n  area: area,\n  bar: bar,\n  circle: circle,\n  geoshape: geoshape,\n  image: image,\n  line: line,\n  point: point,\n  rect: rect,\n  rule: rule,\n  square: square,\n  text: text,\n  tick: tick,\n  trail: trail\n};\nexport function parseMarkGroups(model) {\n  if (contains([LINE, AREA, TRAIL], model.mark)) {\n    var details = pathGroupingFields(model.mark, model.encoding);\n    if (details.length > 0) {\n      return getPathGroups(model, details);\n    }\n    // otherwise use standard mark groups\n  } else if (model.mark === BAR) {\n    var hasCornerRadius = VG_CORNERRADIUS_CHANNELS.some(function (prop) {\n      return getMarkPropOrConfig(prop, model.markDef, model.config);\n    });\n    if (model.stack && !model.fieldDef('size') && hasCornerRadius) {\n      return getGroupsForStackedBarWithCornerRadius(model);\n    }\n  }\n  return getMarkGroup(model);\n}\nvar FACETED_PATH_PREFIX = 'faceted_path_';\nfunction getPathGroups(model, details) {\n  // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)\n  return [{\n    name: model.getName('pathgroup'),\n    type: 'group',\n    from: {\n      facet: {\n        name: FACETED_PATH_PREFIX + model.requestDataName(DataSourceType.Main),\n        data: model.requestDataName(DataSourceType.Main),\n        groupby: details\n      }\n    },\n    encode: {\n      update: {\n        width: {\n          field: {\n            group: 'width'\n          }\n        },\n        height: {\n          field: {\n            group: 'height'\n          }\n        }\n      }\n    },\n    // With subfacet for line/area group, need to use faceted data from above.\n    marks: getMarkGroup(model, {\n      fromPrefix: FACETED_PATH_PREFIX\n    })\n  }];\n}\nvar STACK_GROUP_PREFIX = 'stack_group_';\n/**\n * We need to put stacked bars into groups in order to enable cornerRadius for stacks.\n * If stack is used and the model doesn't have size encoding, we put the mark into groups,\n * and apply cornerRadius properties at the group.\n */\nfunction getGroupsForStackedBarWithCornerRadius(model) {\n  var _a;\n  // Generate the mark\n  var _getMarkGroup = getMarkGroup(model, {\n      fromPrefix: STACK_GROUP_PREFIX\n    }),\n    _getMarkGroup2 = _slicedToArray(_getMarkGroup, 1),\n    mark = _getMarkGroup2[0];\n  // Get the scale for the stacked field\n  var fieldScale = model.scaleName(model.stack.fieldChannel);\n  var stackField = function stackField() {\n    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return model.vgField(model.stack.fieldChannel, opt);\n  };\n  // Find the min/max of the pixel value on the stacked direction\n  var stackFieldGroup = function stackFieldGroup(func, expr) {\n    var vgFieldMinMax = [stackField({\n      prefix: 'min',\n      suffix: 'start',\n      expr: expr\n    }), stackField({\n      prefix: 'max',\n      suffix: 'start',\n      expr: expr\n    }), stackField({\n      prefix: 'min',\n      suffix: 'end',\n      expr: expr\n    }), stackField({\n      prefix: 'max',\n      suffix: 'end',\n      expr: expr\n    })];\n    return \"\".concat(func, \"(\").concat(vgFieldMinMax.map(function (field) {\n      return \"scale('\".concat(fieldScale, \"',\").concat(field, \")\");\n    }).join(','), \")\");\n  };\n  var groupUpdate;\n  var innerGroupUpdate;\n  // Build the encoding for group and an inner group\n  if (model.stack.fieldChannel === 'x') {\n    // Move cornerRadius, y/yc/y2/height properties to group\n    // Group x/x2 should be the min/max of the marks within\n    groupUpdate = Object.assign(Object.assign({}, pick(mark.encode.update, ['y', 'yc', 'y2', 'height'].concat(_toConsumableArray(VG_CORNERRADIUS_CHANNELS)))), {\n      x: {\n        signal: stackFieldGroup('min', 'datum')\n      },\n      x2: {\n        signal: stackFieldGroup('max', 'datum')\n      },\n      clip: {\n        value: true\n      }\n    });\n    // Inner group should revert the x translation, and pass height through\n    innerGroupUpdate = {\n      x: {\n        field: {\n          group: 'x'\n        },\n        mult: -1\n      },\n      height: {\n        field: {\n          group: 'height'\n        }\n      }\n    };\n    // The marks should use the same height as group, without y/yc/y2 properties (because it's already done by group)\n    // This is why size encoding is not supported yet\n    mark.encode.update = Object.assign(Object.assign({}, omit(mark.encode.update, ['y', 'yc', 'y2'])), {\n      height: {\n        field: {\n          group: 'height'\n        }\n      }\n    });\n  } else {\n    groupUpdate = Object.assign(Object.assign({}, pick(mark.encode.update, ['x', 'xc', 'x2', 'width'])), {\n      y: {\n        signal: stackFieldGroup('min', 'datum')\n      },\n      y2: {\n        signal: stackFieldGroup('max', 'datum')\n      },\n      clip: {\n        value: true\n      }\n    });\n    innerGroupUpdate = {\n      y: {\n        field: {\n          group: 'y'\n        },\n        mult: -1\n      },\n      width: {\n        field: {\n          group: 'width'\n        }\n      }\n    };\n    mark.encode.update = Object.assign(Object.assign({}, omit(mark.encode.update, ['x', 'xc', 'x2'])), {\n      width: {\n        field: {\n          group: 'width'\n        }\n      }\n    });\n  }\n  // Deal with cornerRadius properties\n  var _iterator = _createForOfIteratorHelper(VG_CORNERRADIUS_CHANNELS),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var key = _step.value;\n      var configValue = getMarkConfig(key, model.markDef, model.config);\n      // Move from mark to group\n      if (mark.encode.update[key]) {\n        groupUpdate[key] = mark.encode.update[key];\n        delete mark.encode.update[key];\n      } else if (configValue) {\n        groupUpdate[key] = signalOrValueRef(configValue);\n      }\n      // Overwrite any cornerRadius on mark set by config --- they are already moved to the group\n      if (configValue) {\n        mark.encode.update[key] = {\n          value: 0\n        };\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var groupby = [];\n  if (((_a = model.stack.groupbyChannels) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n    var _iterator2 = _createForOfIteratorHelper(model.stack.groupbyChannels),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var groupbyChannel = _step2.value;\n        // For bin and time unit, we have to add bin/timeunit -end channels.\n        var groupByField = model.fieldDef(groupbyChannel);\n        var field = vgField(groupByField);\n        if (field) {\n          groupby.push(field);\n        }\n        if ((groupByField === null || groupByField === void 0 ? void 0 : groupByField.bin) || (groupByField === null || groupByField === void 0 ? void 0 : groupByField.timeUnit)) {\n          groupby.push(vgField(groupByField, {\n            binSuffix: 'end'\n          }));\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n  var strokeProperties = ['stroke', 'strokeWidth', 'strokeJoin', 'strokeCap', 'strokeDash', 'strokeDashOffset', 'strokeMiterLimit', 'strokeOpacity'];\n  // Generate stroke properties for the group\n  groupUpdate = strokeProperties.reduce(function (encode, prop) {\n    if (mark.encode.update[prop]) {\n      return Object.assign(Object.assign({}, encode), _defineProperty({}, prop, mark.encode.update[prop]));\n    } else {\n      var configValue = getMarkConfig(prop, model.markDef, model.config);\n      if (configValue !== undefined) {\n        return Object.assign(Object.assign({}, encode), _defineProperty({}, prop, signalOrValueRef(configValue)));\n      } else {\n        return encode;\n      }\n    }\n  }, groupUpdate);\n  // Apply strokeForeground and strokeOffset if stroke is used\n  if (groupUpdate.stroke) {\n    groupUpdate.strokeForeground = {\n      value: true\n    };\n    groupUpdate.strokeOffset = {\n      value: 0\n    };\n  }\n  return [{\n    type: 'group',\n    from: {\n      facet: {\n        data: model.requestDataName(DataSourceType.Main),\n        name: STACK_GROUP_PREFIX + model.requestDataName(DataSourceType.Main),\n        groupby: groupby,\n        aggregate: {\n          fields: [stackField({\n            suffix: 'start'\n          }), stackField({\n            suffix: 'start'\n          }), stackField({\n            suffix: 'end'\n          }), stackField({\n            suffix: 'end'\n          })],\n          ops: ['min', 'max', 'min', 'max']\n        }\n      }\n    },\n    encode: {\n      update: groupUpdate\n    },\n    marks: [{\n      type: 'group',\n      encode: {\n        update: innerGroupUpdate\n      },\n      marks: [mark]\n    }]\n  }];\n}\nexport function getSort(model) {\n  var _a;\n  var encoding = model.encoding,\n    stack = model.stack,\n    mark = model.mark,\n    markDef = model.markDef,\n    config = model.config;\n  var order = encoding.order;\n  if (!isArray(order) && isValueDef(order) && isNullOrFalse(order.value) || !order && isNullOrFalse(getMarkPropOrConfig('order', markDef, config))) {\n    return undefined;\n  } else if ((isArray(order) || isFieldDef(order)) && !stack) {\n    // Sort by the order field if it is specified and the field is not stacked. (For stacked field, order specify stack order.)\n    return sortParams(order, {\n      expr: 'datum'\n    });\n  } else if (isPathMark(mark)) {\n    // For both line and area, we sort values based on dimension by default\n    var dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n    var dimensionChannelDef = encoding[dimensionChannel];\n    if (isFieldDef(dimensionChannelDef)) {\n      var s = dimensionChannelDef.sort;\n      if (isArray(s)) {\n        return {\n          field: vgField(dimensionChannelDef, {\n            prefix: dimensionChannel,\n            suffix: 'sort_index',\n            expr: 'datum'\n          })\n        };\n      } else if (isSortField(s)) {\n        return {\n          field: vgField({\n            // FIXME: this op might not already exist?\n            // FIXME: what if dimensionChannel (x or y) contains custom domain?\n            aggregate: isAggregate(model.encoding) ? s.op : undefined,\n            field: s.field\n          }, {\n            expr: 'datum'\n          })\n        };\n      } else if (isSortByEncoding(s)) {\n        var fieldDefToSort = model.fieldDef(s.encoding);\n        return {\n          field: vgField(fieldDefToSort, {\n            expr: 'datum'\n          }),\n          order: s.order\n        };\n      } else if (s === null) {\n        return undefined;\n      } else {\n        return {\n          field: vgField(dimensionChannelDef, {\n            // For stack with imputation, we only have bin_mid\n            binSuffix: ((_a = model.stack) === null || _a === void 0 ? void 0 : _a.impute) ? 'mid' : undefined,\n            expr: 'datum'\n          })\n        };\n      }\n    }\n    return undefined;\n  }\n  return undefined;\n}\nfunction getMarkGroup(model) {\n  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    fromPrefix: ''\n  };\n  var mark = model.mark,\n    markDef = model.markDef,\n    encoding = model.encoding,\n    config = model.config;\n  var clip = getFirstDefined(markDef.clip, scaleClip(model), projectionClip(model));\n  var style = getStyles(markDef);\n  var key = encoding.key;\n  var sort = getSort(model);\n  var interactive = interactiveFlag(model);\n  var aria = getMarkPropOrConfig('aria', markDef, config);\n  var postEncodingTransform = markCompiler[mark].postEncodingTransform ? markCompiler[mark].postEncodingTransform(model) : null;\n  return [Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n    name: model.getName('marks'),\n    type: markCompiler[mark].vgMark\n  }, clip ? {\n    clip: true\n  } : {}), style ? {\n    style: style\n  } : {}), key ? {\n    key: key.field\n  } : {}), sort ? {\n    sort: sort\n  } : {}), interactive ? interactive : {}), aria === false ? {\n    aria: aria\n  } : {}), {\n    from: {\n      data: opt.fromPrefix + model.requestDataName(DataSourceType.Main)\n    },\n    encode: {\n      update: markCompiler[mark].encodeEntry(model)\n    }\n  }), postEncodingTransform ? {\n    transform: postEncodingTransform\n  } : {})];\n}\n/**\n * If scales are bound to interval selections, we want to automatically clip\n * marks to account for panning/zooming interactions. We identify bound scales\n * by the selectionExtent property, which gets added during scale parsing.\n */\nfunction scaleClip(model) {\n  var xScale = model.getScaleComponent('x');\n  var yScale = model.getScaleComponent('y');\n  return (xScale === null || xScale === void 0 ? void 0 : xScale.get('selectionExtent')) || (yScale === null || yScale === void 0 ? void 0 : yScale.get('selectionExtent')) ? true : undefined;\n}\n/**\n * If we use a custom projection with auto-fitting to the geodata extent,\n * we need to clip to ensure the chart size doesn't explode.\n */\nfunction projectionClip(model) {\n  var projection = model.component.projection;\n  return projection && !projection.isFit ? true : undefined;\n}\n/**\n * Only output interactive flags if we have selections defined somewhere in our model hierarchy.\n */\nfunction interactiveFlag(model) {\n  if (!model.component.selection) return null;\n  var unitCount = keys(model.component.selection).length;\n  var parentCount = unitCount;\n  var parent = model.parent;\n  while (parent && parentCount === 0) {\n    parentCount = keys(parent.component.selection).length;\n    parent = parent.parent;\n  }\n  return parentCount ? {\n    interactive: unitCount > 0 || !!model.encoding.tooltip\n  } : null;\n}","map":{"version":3,"sources":["../../../../src/compile/mark/mark.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray } from 'vega-util';\nimport { isFieldDef, isValueDef, vgField } from '../../channeldef';\nimport { DataSourceType } from '../../data';\nimport { isAggregate, pathGroupingFields } from '../../encoding';\nimport { AREA, BAR, isPathMark, LINE, TRAIL } from '../../mark';\nimport { isSortByEncoding, isSortField } from '../../sort';\nimport { contains, getFirstDefined, isNullOrFalse, keys, omit, pick } from '../../util';\nimport { VG_CORNERRADIUS_CHANNELS } from '../../vega.schema';\nimport { getMarkConfig, getMarkPropOrConfig, getStyles, signalOrValueRef, sortParams } from '../common';\nimport { arc } from './arc';\nimport { area } from './area';\nimport { bar } from './bar';\nimport { geoshape } from './geoshape';\nimport { image } from './image';\nimport { line, trail } from './line';\nimport { circle, point, square } from './point';\nimport { rect } from './rect';\nimport { rule } from './rule';\nimport { text } from './text';\nimport { tick } from './tick';\nconst markCompiler = {\n    arc,\n    area,\n    bar,\n    circle,\n    geoshape,\n    image,\n    line,\n    point,\n    rect,\n    rule,\n    square,\n    text,\n    tick,\n    trail\n};\nexport function parseMarkGroups(model) {\n    if (contains([LINE, AREA, TRAIL], model.mark)) {\n        const details = pathGroupingFields(model.mark, model.encoding);\n        if (details.length > 0) {\n            return getPathGroups(model, details);\n        }\n        // otherwise use standard mark groups\n    }\n    else if (model.mark === BAR) {\n        const hasCornerRadius = VG_CORNERRADIUS_CHANNELS.some(prop => getMarkPropOrConfig(prop, model.markDef, model.config));\n        if (model.stack && !model.fieldDef('size') && hasCornerRadius) {\n            return getGroupsForStackedBarWithCornerRadius(model);\n        }\n    }\n    return getMarkGroup(model);\n}\nconst FACETED_PATH_PREFIX = 'faceted_path_';\nfunction getPathGroups(model, details) {\n    // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)\n    return [\n        {\n            name: model.getName('pathgroup'),\n            type: 'group',\n            from: {\n                facet: {\n                    name: FACETED_PATH_PREFIX + model.requestDataName(DataSourceType.Main),\n                    data: model.requestDataName(DataSourceType.Main),\n                    groupby: details\n                }\n            },\n            encode: {\n                update: {\n                    width: { field: { group: 'width' } },\n                    height: { field: { group: 'height' } }\n                }\n            },\n            // With subfacet for line/area group, need to use faceted data from above.\n            marks: getMarkGroup(model, { fromPrefix: FACETED_PATH_PREFIX })\n        }\n    ];\n}\nconst STACK_GROUP_PREFIX = 'stack_group_';\n/**\n * We need to put stacked bars into groups in order to enable cornerRadius for stacks.\n * If stack is used and the model doesn't have size encoding, we put the mark into groups,\n * and apply cornerRadius properties at the group.\n */\nfunction getGroupsForStackedBarWithCornerRadius(model) {\n    var _a;\n    // Generate the mark\n    const [mark] = getMarkGroup(model, { fromPrefix: STACK_GROUP_PREFIX });\n    // Get the scale for the stacked field\n    const fieldScale = model.scaleName(model.stack.fieldChannel);\n    const stackField = (opt = {}) => model.vgField(model.stack.fieldChannel, opt);\n    // Find the min/max of the pixel value on the stacked direction\n    const stackFieldGroup = (func, expr) => {\n        const vgFieldMinMax = [\n            stackField({ prefix: 'min', suffix: 'start', expr }),\n            stackField({ prefix: 'max', suffix: 'start', expr }),\n            stackField({ prefix: 'min', suffix: 'end', expr }),\n            stackField({ prefix: 'max', suffix: 'end', expr })\n        ];\n        return `${func}(${vgFieldMinMax.map(field => `scale('${fieldScale}',${field})`).join(',')})`;\n    };\n    let groupUpdate;\n    let innerGroupUpdate;\n    // Build the encoding for group and an inner group\n    if (model.stack.fieldChannel === 'x') {\n        // Move cornerRadius, y/yc/y2/height properties to group\n        // Group x/x2 should be the min/max of the marks within\n        groupUpdate = Object.assign(Object.assign({}, pick(mark.encode.update, ['y', 'yc', 'y2', 'height', ...VG_CORNERRADIUS_CHANNELS])), { x: { signal: stackFieldGroup('min', 'datum') }, x2: { signal: stackFieldGroup('max', 'datum') }, clip: { value: true } });\n        // Inner group should revert the x translation, and pass height through\n        innerGroupUpdate = {\n            x: { field: { group: 'x' }, mult: -1 },\n            height: { field: { group: 'height' } }\n        };\n        // The marks should use the same height as group, without y/yc/y2 properties (because it's already done by group)\n        // This is why size encoding is not supported yet\n        mark.encode.update = Object.assign(Object.assign({}, omit(mark.encode.update, ['y', 'yc', 'y2'])), { height: { field: { group: 'height' } } });\n    }\n    else {\n        groupUpdate = Object.assign(Object.assign({}, pick(mark.encode.update, ['x', 'xc', 'x2', 'width'])), { y: { signal: stackFieldGroup('min', 'datum') }, y2: { signal: stackFieldGroup('max', 'datum') }, clip: { value: true } });\n        innerGroupUpdate = {\n            y: { field: { group: 'y' }, mult: -1 },\n            width: { field: { group: 'width' } }\n        };\n        mark.encode.update = Object.assign(Object.assign({}, omit(mark.encode.update, ['x', 'xc', 'x2'])), { width: { field: { group: 'width' } } });\n    }\n    // Deal with cornerRadius properties\n    for (const key of VG_CORNERRADIUS_CHANNELS) {\n        const configValue = getMarkConfig(key, model.markDef, model.config);\n        // Move from mark to group\n        if (mark.encode.update[key]) {\n            groupUpdate[key] = mark.encode.update[key];\n            delete mark.encode.update[key];\n        }\n        else if (configValue) {\n            groupUpdate[key] = signalOrValueRef(configValue);\n        }\n        // Overwrite any cornerRadius on mark set by config --- they are already moved to the group\n        if (configValue) {\n            mark.encode.update[key] = { value: 0 };\n        }\n    }\n    const groupby = [];\n    if (((_a = model.stack.groupbyChannels) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n        for (const groupbyChannel of model.stack.groupbyChannels) {\n            // For bin and time unit, we have to add bin/timeunit -end channels.\n            const groupByField = model.fieldDef(groupbyChannel);\n            const field = vgField(groupByField);\n            if (field) {\n                groupby.push(field);\n            }\n            if ((groupByField === null || groupByField === void 0 ? void 0 : groupByField.bin) || (groupByField === null || groupByField === void 0 ? void 0 : groupByField.timeUnit)) {\n                groupby.push(vgField(groupByField, { binSuffix: 'end' }));\n            }\n        }\n    }\n    const strokeProperties = [\n        'stroke',\n        'strokeWidth',\n        'strokeJoin',\n        'strokeCap',\n        'strokeDash',\n        'strokeDashOffset',\n        'strokeMiterLimit',\n        'strokeOpacity'\n    ];\n    // Generate stroke properties for the group\n    groupUpdate = strokeProperties.reduce((encode, prop) => {\n        if (mark.encode.update[prop]) {\n            return Object.assign(Object.assign({}, encode), { [prop]: mark.encode.update[prop] });\n        }\n        else {\n            const configValue = getMarkConfig(prop, model.markDef, model.config);\n            if (configValue !== undefined) {\n                return Object.assign(Object.assign({}, encode), { [prop]: signalOrValueRef(configValue) });\n            }\n            else {\n                return encode;\n            }\n        }\n    }, groupUpdate);\n    // Apply strokeForeground and strokeOffset if stroke is used\n    if (groupUpdate.stroke) {\n        groupUpdate.strokeForeground = { value: true };\n        groupUpdate.strokeOffset = { value: 0 };\n    }\n    return [\n        {\n            type: 'group',\n            from: {\n                facet: {\n                    data: model.requestDataName(DataSourceType.Main),\n                    name: STACK_GROUP_PREFIX + model.requestDataName(DataSourceType.Main),\n                    groupby,\n                    aggregate: {\n                        fields: [\n                            stackField({ suffix: 'start' }),\n                            stackField({ suffix: 'start' }),\n                            stackField({ suffix: 'end' }),\n                            stackField({ suffix: 'end' })\n                        ],\n                        ops: ['min', 'max', 'min', 'max']\n                    }\n                }\n            },\n            encode: {\n                update: groupUpdate\n            },\n            marks: [\n                {\n                    type: 'group',\n                    encode: { update: innerGroupUpdate },\n                    marks: [mark]\n                }\n            ]\n        }\n    ];\n}\nexport function getSort(model) {\n    var _a;\n    const { encoding, stack, mark, markDef, config } = model;\n    const order = encoding.order;\n    if ((!isArray(order) && isValueDef(order) && isNullOrFalse(order.value)) ||\n        (!order && isNullOrFalse(getMarkPropOrConfig('order', markDef, config)))) {\n        return undefined;\n    }\n    else if ((isArray(order) || isFieldDef(order)) && !stack) {\n        // Sort by the order field if it is specified and the field is not stacked. (For stacked field, order specify stack order.)\n        return sortParams(order, { expr: 'datum' });\n    }\n    else if (isPathMark(mark)) {\n        // For both line and area, we sort values based on dimension by default\n        const dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n        const dimensionChannelDef = encoding[dimensionChannel];\n        if (isFieldDef(dimensionChannelDef)) {\n            const s = dimensionChannelDef.sort;\n            if (isArray(s)) {\n                return {\n                    field: vgField(dimensionChannelDef, { prefix: dimensionChannel, suffix: 'sort_index', expr: 'datum' })\n                };\n            }\n            else if (isSortField(s)) {\n                return {\n                    field: vgField({\n                        // FIXME: this op might not already exist?\n                        // FIXME: what if dimensionChannel (x or y) contains custom domain?\n                        aggregate: isAggregate(model.encoding) ? s.op : undefined,\n                        field: s.field\n                    }, { expr: 'datum' })\n                };\n            }\n            else if (isSortByEncoding(s)) {\n                const fieldDefToSort = model.fieldDef(s.encoding);\n                return {\n                    field: vgField(fieldDefToSort, { expr: 'datum' }),\n                    order: s.order\n                };\n            }\n            else if (s === null) {\n                return undefined;\n            }\n            else {\n                return {\n                    field: vgField(dimensionChannelDef, {\n                        // For stack with imputation, we only have bin_mid\n                        binSuffix: ((_a = model.stack) === null || _a === void 0 ? void 0 : _a.impute) ? 'mid' : undefined,\n                        expr: 'datum'\n                    })\n                };\n            }\n        }\n        return undefined;\n    }\n    return undefined;\n}\nfunction getMarkGroup(model, opt = { fromPrefix: '' }) {\n    const { mark, markDef, encoding, config } = model;\n    const clip = getFirstDefined(markDef.clip, scaleClip(model), projectionClip(model));\n    const style = getStyles(markDef);\n    const key = encoding.key;\n    const sort = getSort(model);\n    const interactive = interactiveFlag(model);\n    const aria = getMarkPropOrConfig('aria', markDef, config);\n    const postEncodingTransform = markCompiler[mark].postEncodingTransform\n        ? markCompiler[mark].postEncodingTransform(model)\n        : null;\n    return [\n        Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ name: model.getName('marks'), type: markCompiler[mark].vgMark }, (clip ? { clip: true } : {})), (style ? { style } : {})), (key ? { key: key.field } : {})), (sort ? { sort } : {})), (interactive ? interactive : {})), (aria === false ? { aria } : {})), { from: { data: opt.fromPrefix + model.requestDataName(DataSourceType.Main) }, encode: {\n                update: markCompiler[mark].encodeEntry(model)\n            } }), (postEncodingTransform\n            ? {\n                transform: postEncodingTransform\n            }\n            : {}))\n    ];\n}\n/**\n * If scales are bound to interval selections, we want to automatically clip\n * marks to account for panning/zooming interactions. We identify bound scales\n * by the selectionExtent property, which gets added during scale parsing.\n */\nfunction scaleClip(model) {\n    const xScale = model.getScaleComponent('x');\n    const yScale = model.getScaleComponent('y');\n    return (xScale === null || xScale === void 0 ? void 0 : xScale.get('selectionExtent')) || (yScale === null || yScale === void 0 ? void 0 : yScale.get('selectionExtent')) ? true : undefined;\n}\n/**\n * If we use a custom projection with auto-fitting to the geodata extent,\n * we need to clip to ensure the chart size doesn't explode.\n */\nfunction projectionClip(model) {\n    const projection = model.component.projection;\n    return projection && !projection.isFit ? true : undefined;\n}\n/**\n * Only output interactive flags if we have selections defined somewhere in our model hierarchy.\n */\nfunction interactiveFlag(model) {\n    if (!model.component.selection)\n        return null;\n    const unitCount = keys(model.component.selection).length;\n    let parentCount = unitCount;\n    let parent = model.parent;\n    while (parent && parentCount === 0) {\n        parentCount = keys(parent.component.selection).length;\n        parent = parent.parent;\n    }\n    return parentCount\n        ? {\n            interactive: unitCount > 0 || !!model.encoding.tooltip\n        }\n        : null;\n}\n//# sourceMappingURL=mark.js.map"]},"metadata":{},"sourceType":"module"}