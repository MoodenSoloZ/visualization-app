{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { isArray, isString } from 'vega-util';\nimport { getFieldDef, isFieldDef, vgField } from '../../channeldef';\nimport { duplicate, getFirstDefined, hash as _hash } from '../../util';\nimport { sortParams } from '../common';\nimport { DataFlowNode } from './dataflow';\nfunction getStackByFields(model) {\n  return model.stack.stackBy.reduce(function (fields, by) {\n    var fieldDef = by.fieldDef;\n    var _field = vgField(fieldDef);\n    if (_field) {\n      fields.push(_field);\n    }\n    return fields;\n  }, []);\n}\nfunction isValidAsArray(as) {\n  return isArray(as) && as.every(function (s) {\n    return isString(s);\n  }) && as.length > 1;\n}\nexport var StackNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(StackNode, _DataFlowNode);\n  var _super = _createSuper(StackNode);\n  function StackNode(parent, stack) {\n    var _this;\n    _classCallCheck(this, StackNode);\n    _this = _super.call(this, parent);\n    _this._stack = stack;\n    return _this;\n  }\n  _createClass(StackNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new StackNode(null, duplicate(this._stack));\n    }\n  }, {\n    key: \"stack\",\n    get: function get() {\n      return this._stack;\n    }\n  }, {\n    key: \"addDimensions\",\n    value: function addDimensions(fields) {\n      var _this$_stack$facetby;\n      (_this$_stack$facetby = this._stack.facetby).push.apply(_this$_stack$facetby, _toConsumableArray(fields));\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      var out = new Set();\n      out.add(this._stack.stackField);\n      this.getGroupbyFields().forEach(out.add, out);\n      this._stack.facetby.forEach(out.add, out);\n      this._stack.sort.field.forEach(out.add, out);\n      return out;\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set(this._stack.as);\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"Stack \".concat(_hash(this._stack));\n    }\n  }, {\n    key: \"getGroupbyFields\",\n    value: function getGroupbyFields() {\n      var _this$_stack = this._stack,\n        dimensionFieldDefs = _this$_stack.dimensionFieldDefs,\n        impute = _this$_stack.impute,\n        groupby = _this$_stack.groupby;\n      if (dimensionFieldDefs.length > 0) {\n        return dimensionFieldDefs.map(function (dimensionFieldDef) {\n          if (dimensionFieldDef.bin) {\n            if (impute) {\n              // For binned group by field with impute, we calculate bin_mid\n              // as we cannot impute two fields simultaneously\n              return [vgField(dimensionFieldDef, {\n                binSuffix: 'mid'\n              })];\n            }\n            return [\n            // For binned group by field without impute, we need both bin (start) and bin_end\n            vgField(dimensionFieldDef, {}), vgField(dimensionFieldDef, {\n              binSuffix: 'end'\n            })];\n          }\n          return [vgField(dimensionFieldDef)];\n        }).flat();\n      }\n      return groupby !== null && groupby !== void 0 ? groupby : [];\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      var transform = [];\n      var _this$_stack2 = this._stack,\n        facetby = _this$_stack2.facetby,\n        dimensionFieldDefs = _this$_stack2.dimensionFieldDefs,\n        field = _this$_stack2.stackField,\n        stackby = _this$_stack2.stackby,\n        sort = _this$_stack2.sort,\n        offset = _this$_stack2.offset,\n        impute = _this$_stack2.impute,\n        as = _this$_stack2.as;\n      // Impute\n      if (impute) {\n        var _iterator = _createForOfIteratorHelper(dimensionFieldDefs),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var dimensionFieldDef = _step.value;\n            var _dimensionFieldDef$ba = dimensionFieldDef.bandPosition,\n              bandPosition = _dimensionFieldDef$ba === void 0 ? 0.5 : _dimensionFieldDef$ba,\n              bin = dimensionFieldDef.bin;\n            if (bin) {\n              // As we can only impute one field at a time, we need to calculate\n              // mid point for a binned field\n              var binStart = vgField(dimensionFieldDef, {\n                expr: 'datum'\n              });\n              var binEnd = vgField(dimensionFieldDef, {\n                expr: 'datum',\n                binSuffix: 'end'\n              });\n              transform.push({\n                type: 'formula',\n                expr: \"\".concat(bandPosition, \"*\").concat(binStart, \"+\").concat(1 - bandPosition, \"*\").concat(binEnd),\n                as: vgField(dimensionFieldDef, {\n                  binSuffix: 'mid',\n                  forAs: true\n                })\n              });\n            }\n            transform.push({\n              type: 'impute',\n              field: field,\n              groupby: [].concat(_toConsumableArray(stackby), _toConsumableArray(facetby)),\n              key: vgField(dimensionFieldDef, {\n                binSuffix: 'mid'\n              }),\n              method: 'value',\n              value: 0\n            });\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      // Stack\n      transform.push({\n        type: 'stack',\n        groupby: [].concat(_toConsumableArray(this.getGroupbyFields()), _toConsumableArray(facetby)),\n        field: field,\n        sort: sort,\n        as: as,\n        offset: offset\n      });\n      return transform;\n    }\n  }], [{\n    key: \"makeFromTransform\",\n    value: function makeFromTransform(parent, stackTransform) {\n      var stack = stackTransform.stack,\n        groupby = stackTransform.groupby,\n        as = stackTransform.as,\n        _stackTransform$offse = stackTransform.offset,\n        offset = _stackTransform$offse === void 0 ? 'zero' : _stackTransform$offse;\n      var sortFields = [];\n      var sortOrder = [];\n      if (stackTransform.sort !== undefined) {\n        var _iterator2 = _createForOfIteratorHelper(stackTransform.sort),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var sortField = _step2.value;\n            sortFields.push(sortField.field);\n            sortOrder.push(getFirstDefined(sortField.order, 'ascending'));\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      var sort = {\n        field: sortFields,\n        order: sortOrder\n      };\n      var normalizedAs;\n      if (isValidAsArray(as)) {\n        normalizedAs = as;\n      } else if (isString(as)) {\n        normalizedAs = [as, \"\".concat(as, \"_end\")];\n      } else {\n        normalizedAs = [\"\".concat(stackTransform.stack, \"_start\"), \"\".concat(stackTransform.stack, \"_end\")];\n      }\n      return new StackNode(parent, {\n        dimensionFieldDefs: [],\n        stackField: stack,\n        groupby: groupby,\n        offset: offset,\n        sort: sort,\n        facetby: [],\n        as: normalizedAs\n      });\n    }\n  }, {\n    key: \"makeFromEncoding\",\n    value: function makeFromEncoding(parent, model) {\n      var stackProperties = model.stack;\n      var encoding = model.encoding;\n      if (!stackProperties) {\n        return null;\n      }\n      var groupbyChannels = stackProperties.groupbyChannels,\n        fieldChannel = stackProperties.fieldChannel,\n        offset = stackProperties.offset,\n        impute = stackProperties.impute;\n      var dimensionFieldDefs = groupbyChannels.map(function (groupbyChannel) {\n        var cDef = encoding[groupbyChannel];\n        return getFieldDef(cDef);\n      }).filter(function (def) {\n        return !!def;\n      });\n      var stackby = getStackByFields(model);\n      var orderDef = model.encoding.order;\n      var sort;\n      if (isArray(orderDef) || isFieldDef(orderDef)) {\n        sort = sortParams(orderDef);\n      } else {\n        // default = descending by stackFields\n        // FIXME is the default here correct for binned fields?\n        sort = stackby.reduce(function (s, field) {\n          s.field.push(field);\n          s.order.push(fieldChannel === 'y' ? 'descending' : 'ascending');\n          return s;\n        }, {\n          field: [],\n          order: []\n        });\n      }\n      return new StackNode(parent, {\n        dimensionFieldDefs: dimensionFieldDefs,\n        stackField: model.vgField(fieldChannel),\n        facetby: [],\n        stackby: stackby,\n        sort: sort,\n        offset: offset,\n        impute: impute,\n        as: [model.vgField(fieldChannel, {\n          suffix: 'start',\n          forAs: true\n        }), model.vgField(fieldChannel, {\n          suffix: 'end',\n          forAs: true\n        })]\n      });\n    }\n  }]);\n  return StackNode;\n}(DataFlowNode);","map":{"version":3,"sources":["../../../../src/compile/data/stack.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray, isString } from 'vega-util';\nimport { getFieldDef, isFieldDef, vgField } from '../../channeldef';\nimport { duplicate, getFirstDefined, hash } from '../../util';\nimport { sortParams } from '../common';\nimport { DataFlowNode } from './dataflow';\nfunction getStackByFields(model) {\n    return model.stack.stackBy.reduce((fields, by) => {\n        const fieldDef = by.fieldDef;\n        const _field = vgField(fieldDef);\n        if (_field) {\n            fields.push(_field);\n        }\n        return fields;\n    }, []);\n}\nfunction isValidAsArray(as) {\n    return isArray(as) && as.every(s => isString(s)) && as.length > 1;\n}\nexport class StackNode extends DataFlowNode {\n    constructor(parent, stack) {\n        super(parent);\n        this._stack = stack;\n    }\n    clone() {\n        return new StackNode(null, duplicate(this._stack));\n    }\n    static makeFromTransform(parent, stackTransform) {\n        const { stack, groupby, as, offset = 'zero' } = stackTransform;\n        const sortFields = [];\n        const sortOrder = [];\n        if (stackTransform.sort !== undefined) {\n            for (const sortField of stackTransform.sort) {\n                sortFields.push(sortField.field);\n                sortOrder.push(getFirstDefined(sortField.order, 'ascending'));\n            }\n        }\n        const sort = {\n            field: sortFields,\n            order: sortOrder\n        };\n        let normalizedAs;\n        if (isValidAsArray(as)) {\n            normalizedAs = as;\n        }\n        else if (isString(as)) {\n            normalizedAs = [as, `${as}_end`];\n        }\n        else {\n            normalizedAs = [`${stackTransform.stack}_start`, `${stackTransform.stack}_end`];\n        }\n        return new StackNode(parent, {\n            dimensionFieldDefs: [],\n            stackField: stack,\n            groupby,\n            offset,\n            sort,\n            facetby: [],\n            as: normalizedAs\n        });\n    }\n    static makeFromEncoding(parent, model) {\n        const stackProperties = model.stack;\n        const { encoding } = model;\n        if (!stackProperties) {\n            return null;\n        }\n        const { groupbyChannels, fieldChannel, offset, impute } = stackProperties;\n        const dimensionFieldDefs = groupbyChannels\n            .map(groupbyChannel => {\n            const cDef = encoding[groupbyChannel];\n            return getFieldDef(cDef);\n        })\n            .filter(def => !!def);\n        const stackby = getStackByFields(model);\n        const orderDef = model.encoding.order;\n        let sort;\n        if (isArray(orderDef) || isFieldDef(orderDef)) {\n            sort = sortParams(orderDef);\n        }\n        else {\n            // default = descending by stackFields\n            // FIXME is the default here correct for binned fields?\n            sort = stackby.reduce((s, field) => {\n                s.field.push(field);\n                s.order.push(fieldChannel === 'y' ? 'descending' : 'ascending');\n                return s;\n            }, { field: [], order: [] });\n        }\n        return new StackNode(parent, {\n            dimensionFieldDefs,\n            stackField: model.vgField(fieldChannel),\n            facetby: [],\n            stackby,\n            sort,\n            offset,\n            impute,\n            as: [\n                model.vgField(fieldChannel, { suffix: 'start', forAs: true }),\n                model.vgField(fieldChannel, { suffix: 'end', forAs: true })\n            ]\n        });\n    }\n    get stack() {\n        return this._stack;\n    }\n    addDimensions(fields) {\n        this._stack.facetby.push(...fields);\n    }\n    dependentFields() {\n        const out = new Set();\n        out.add(this._stack.stackField);\n        this.getGroupbyFields().forEach(out.add, out);\n        this._stack.facetby.forEach(out.add, out);\n        this._stack.sort.field.forEach(out.add, out);\n        return out;\n    }\n    producedFields() {\n        return new Set(this._stack.as);\n    }\n    hash() {\n        return `Stack ${hash(this._stack)}`;\n    }\n    getGroupbyFields() {\n        const { dimensionFieldDefs, impute, groupby } = this._stack;\n        if (dimensionFieldDefs.length > 0) {\n            return dimensionFieldDefs\n                .map(dimensionFieldDef => {\n                if (dimensionFieldDef.bin) {\n                    if (impute) {\n                        // For binned group by field with impute, we calculate bin_mid\n                        // as we cannot impute two fields simultaneously\n                        return [vgField(dimensionFieldDef, { binSuffix: 'mid' })];\n                    }\n                    return [\n                        // For binned group by field without impute, we need both bin (start) and bin_end\n                        vgField(dimensionFieldDef, {}),\n                        vgField(dimensionFieldDef, { binSuffix: 'end' })\n                    ];\n                }\n                return [vgField(dimensionFieldDef)];\n            })\n                .flat();\n        }\n        return groupby !== null && groupby !== void 0 ? groupby : [];\n    }\n    assemble() {\n        const transform = [];\n        const { facetby, dimensionFieldDefs, stackField: field, stackby, sort, offset, impute, as } = this._stack;\n        // Impute\n        if (impute) {\n            for (const dimensionFieldDef of dimensionFieldDefs) {\n                const { bandPosition = 0.5, bin } = dimensionFieldDef;\n                if (bin) {\n                    // As we can only impute one field at a time, we need to calculate\n                    // mid point for a binned field\n                    const binStart = vgField(dimensionFieldDef, { expr: 'datum' });\n                    const binEnd = vgField(dimensionFieldDef, { expr: 'datum', binSuffix: 'end' });\n                    transform.push({\n                        type: 'formula',\n                        expr: `${bandPosition}*${binStart}+${1 - bandPosition}*${binEnd}`,\n                        as: vgField(dimensionFieldDef, { binSuffix: 'mid', forAs: true })\n                    });\n                }\n                transform.push({\n                    type: 'impute',\n                    field,\n                    groupby: [...stackby, ...facetby],\n                    key: vgField(dimensionFieldDef, { binSuffix: 'mid' }),\n                    method: 'value',\n                    value: 0\n                });\n            }\n        }\n        // Stack\n        transform.push({\n            type: 'stack',\n            groupby: [...this.getGroupbyFields(), ...facetby],\n            field,\n            sort,\n            as,\n            offset\n        });\n        return transform;\n    }\n}\n//# sourceMappingURL=stack.js.map"]},"metadata":{},"sourceType":"module"}