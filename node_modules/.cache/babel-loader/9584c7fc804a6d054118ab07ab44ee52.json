{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { isObject } from 'vega-util';\nimport { isXorY } from '../../channel';\nimport { keys } from '../../util';\nimport { isDataRefDomain, isVgRangeStep } from '../../vega.schema';\nimport { isConcatModel, isLayerModel } from '../model';\nimport { assembleSelectionScaleDomain } from '../selection/assemble';\nimport { assembleDomain } from './domain';\nexport function assembleScales(model) {\n  if (isLayerModel(model) || isConcatModel(model)) {\n    // For concat and layer, include scales of children too\n    return model.children.reduce(function (scales, child) {\n      return scales.concat(assembleScales(child));\n    }, assembleScalesForModel(model));\n  } else {\n    // For facet, child scales would not be included in the parent's scope.\n    // For unit, there is no child.\n    return assembleScalesForModel(model);\n  }\n}\nexport function assembleScalesForModel(model) {\n  return keys(model.component.scales).reduce(function (scales, channel) {\n    var scaleComponent = model.component.scales[channel];\n    if (scaleComponent.merged) {\n      // Skipped merged scales\n      return scales;\n    }\n    var scale = scaleComponent.combine();\n    var name = scale.name,\n      type = scale.type,\n      selectionExtent = scale.selectionExtent,\n      _d = scale.domains,\n      _r = scale.range,\n      reverse = scale.reverse,\n      otherScaleProps = __rest(scale, [\"name\", \"type\", \"selectionExtent\", \"domains\", \"range\", \"reverse\"]);\n    var range = assembleScaleRange(scale.range, name, channel, model);\n    var domain = assembleDomain(model, channel);\n    var domainRaw = selectionExtent ? assembleSelectionScaleDomain(model, selectionExtent, scaleComponent, domain) : null;\n    scales.push(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n      name: name,\n      type: type\n    }, domain ? {\n      domain: domain\n    } : {}), domainRaw ? {\n      domainRaw: domainRaw\n    } : {}), {\n      range: range\n    }), reverse !== undefined ? {\n      reverse: reverse\n    } : {}), otherScaleProps));\n    return scales;\n  }, []);\n}\nexport function assembleScaleRange(scaleRange, scaleName, channel, model) {\n  // add signals to x/y range\n  if (isXorY(channel)) {\n    if (isVgRangeStep(scaleRange)) {\n      // For width/height step, use a signal created in layout assemble instead of a constant step.\n      return {\n        step: {\n          signal: \"\".concat(scaleName, \"_step\")\n        }\n      };\n    }\n  } else if (isObject(scaleRange) && isDataRefDomain(scaleRange)) {\n    return Object.assign(Object.assign({}, scaleRange), {\n      data: model.lookupDataSource(scaleRange.data)\n    });\n  }\n  return scaleRange;\n}","map":{"version":3,"sources":["../../../../src/compile/scale/assemble.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isObject } from 'vega-util';\nimport { isXorY } from '../../channel';\nimport { keys } from '../../util';\nimport { isDataRefDomain, isVgRangeStep } from '../../vega.schema';\nimport { isConcatModel, isLayerModel } from '../model';\nimport { assembleSelectionScaleDomain } from '../selection/assemble';\nimport { assembleDomain } from './domain';\nexport function assembleScales(model) {\n    if (isLayerModel(model) || isConcatModel(model)) {\n        // For concat and layer, include scales of children too\n        return model.children.reduce((scales, child) => {\n            return scales.concat(assembleScales(child));\n        }, assembleScalesForModel(model));\n    }\n    else {\n        // For facet, child scales would not be included in the parent's scope.\n        // For unit, there is no child.\n        return assembleScalesForModel(model);\n    }\n}\nexport function assembleScalesForModel(model) {\n    return keys(model.component.scales).reduce((scales, channel) => {\n        const scaleComponent = model.component.scales[channel];\n        if (scaleComponent.merged) {\n            // Skipped merged scales\n            return scales;\n        }\n        const scale = scaleComponent.combine();\n        const { name, type, selectionExtent, domains: _d, range: _r, reverse } = scale, otherScaleProps = __rest(scale, [\"name\", \"type\", \"selectionExtent\", \"domains\", \"range\", \"reverse\"]);\n        const range = assembleScaleRange(scale.range, name, channel, model);\n        const domain = assembleDomain(model, channel);\n        const domainRaw = selectionExtent\n            ? assembleSelectionScaleDomain(model, selectionExtent, scaleComponent, domain)\n            : null;\n        scales.push(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ name,\n            type }, (domain ? { domain } : {})), (domainRaw ? { domainRaw } : {})), { range }), (reverse !== undefined ? { reverse: reverse } : {})), otherScaleProps));\n        return scales;\n    }, []);\n}\nexport function assembleScaleRange(scaleRange, scaleName, channel, model) {\n    // add signals to x/y range\n    if (isXorY(channel)) {\n        if (isVgRangeStep(scaleRange)) {\n            // For width/height step, use a signal created in layout assemble instead of a constant step.\n            return {\n                step: { signal: `${scaleName}_step` }\n            };\n        }\n    }\n    else if (isObject(scaleRange) && isDataRefDomain(scaleRange)) {\n        return Object.assign(Object.assign({}, scaleRange), { data: model.lookupDataSource(scaleRange.data) });\n    }\n    return scaleRange;\n}\n//# sourceMappingURL=assemble.js.map"]},"metadata":{},"sourceType":"module"}