{"ast":null,"code":"import _defineProperty from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { AncestorParse } from '.';\nimport { isGenerator, isGraticuleGenerator, isInlineData, isNamedData, isSequenceGenerator, isUrlData, DataSourceType } from '../../data';\nimport * as log from '../../log';\nimport { isAggregate, isBin, isCalculate, isDensity, isFilter, isFlatten, isFold, isImpute, isJoinAggregate, isLoess, isLookup, isPivot, isQuantile, isRegression, isSample, isStack, isTimeUnit, isWindow } from '../../transform';\nimport { deepEqual, mergeDeep } from '../../util';\nimport { isFacetModel, isLayerModel, isUnitModel } from '../model';\nimport { requiresSelectionId } from '../selection';\nimport { materializeSelections } from '../selection/parse';\nimport { AggregateNode } from './aggregate';\nimport { BinNode } from './bin';\nimport { CalculateNode } from './calculate';\nimport { OutputNode } from './dataflow';\nimport { DensityTransformNode } from './density';\nimport { FacetNode } from './facet';\nimport { FilterNode } from './filter';\nimport { FilterInvalidNode } from './filterinvalid';\nimport { FlattenTransformNode } from './flatten';\nimport { FoldTransformNode } from './fold';\nimport { getImplicitFromEncoding, getImplicitFromFilterTransform, getImplicitFromSelection, ParseNode } from './formatparse';\nimport { GeoJSONNode } from './geojson';\nimport { GeoPointNode } from './geopoint';\nimport { GraticuleNode } from './graticule';\nimport { IdentifierNode } from './identifier';\nimport { ImputeNode } from './impute';\nimport { JoinAggregateTransformNode } from './joinaggregate';\nimport { makeJoinAggregateFromFacet } from './joinaggregatefacet';\nimport { LoessTransformNode } from './loess';\nimport { LookupNode } from './lookup';\nimport { PivotTransformNode } from './pivot';\nimport { QuantileTransformNode } from './quantile';\nimport { RegressionTransformNode } from './regression';\nimport { SampleTransformNode } from './sample';\nimport { SequenceNode } from './sequence';\nimport { SourceNode } from './source';\nimport { StackNode } from './stack';\nimport { TimeUnitNode } from './timeunit';\nimport { WindowTransformNode } from './window';\nexport function findSource(data, sources) {\n  var _a, _b, _c, _d;\n  var _iterator = _createForOfIteratorHelper(sources),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var other = _step.value;\n      var otherData = other.data;\n      // if both datasets have a name defined, we cannot merge\n      if (data.name && other.hasName() && data.name !== other.dataName) {\n        continue;\n      }\n      var formatMesh = (_a = data['format']) === null || _a === void 0 ? void 0 : _a.mesh;\n      var otherFeature = (_b = otherData.format) === null || _b === void 0 ? void 0 : _b.feature;\n      // feature and mesh are mutually exclusive\n      if (formatMesh && otherFeature) {\n        continue;\n      }\n      // we have to extract the same feature or mesh\n      var formatFeature = (_c = data['format']) === null || _c === void 0 ? void 0 : _c.feature;\n      if ((formatFeature || otherFeature) && formatFeature !== otherFeature) {\n        continue;\n      }\n      var otherMesh = (_d = otherData.format) === null || _d === void 0 ? void 0 : _d.mesh;\n      if ((formatMesh || otherMesh) && formatMesh !== otherMesh) {\n        continue;\n      }\n      if (isInlineData(data) && isInlineData(otherData)) {\n        if (deepEqual(data.values, otherData.values)) {\n          return other;\n        }\n      } else if (isUrlData(data) && isUrlData(otherData)) {\n        if (data.url === otherData.url) {\n          return other;\n        }\n      } else if (isNamedData(data)) {\n        if (data.name === other.dataName) {\n          return other;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return null;\n}\nfunction parseRoot(model, sources) {\n  if (model.data || !model.parent) {\n    // if the model defines a data source or is the root, create a source node\n    if (model.data === null) {\n      // data: null means we should ignore the parent's data so we just create a new data source\n      var source = new SourceNode({\n        values: []\n      });\n      sources.push(source);\n      return source;\n    }\n    var existingSource = findSource(model.data, sources);\n    if (existingSource) {\n      if (!isGenerator(model.data)) {\n        existingSource.data.format = mergeDeep({}, model.data.format, existingSource.data.format);\n      }\n      // if the new source has a name but the existing one does not, we can set it\n      if (!existingSource.hasName() && model.data.name) {\n        existingSource.dataName = model.data.name;\n      }\n      return existingSource;\n    } else {\n      var _source = new SourceNode(model.data);\n      sources.push(_source);\n      return _source;\n    }\n  } else {\n    // If we don't have a source defined (overriding parent's data), use the parent's facet root or main.\n    return model.parent.component.data.facetRoot ? model.parent.component.data.facetRoot : model.parent.component.data.main;\n  }\n}\n/**\n * Parses a transform array into a chain of connected dataflow nodes.\n */\nexport function parseTransformArray(head, model, ancestorParse) {\n  var _a, _b;\n  var lookupCounter = 0;\n  var _iterator2 = _createForOfIteratorHelper(model.transforms),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var t = _step2.value;\n      var derivedType = undefined;\n      var transformNode = void 0;\n      if (isCalculate(t)) {\n        transformNode = head = new CalculateNode(head, t);\n        derivedType = 'derived';\n      } else if (isFilter(t)) {\n        var implicit = getImplicitFromFilterTransform(t);\n        transformNode = head = (_a = ParseNode.makeWithAncestors(head, {}, implicit, ancestorParse)) !== null && _a !== void 0 ? _a : head;\n        head = new FilterNode(head, model, t.filter);\n      } else if (isBin(t)) {\n        transformNode = head = BinNode.makeFromTransform(head, t, model);\n        derivedType = 'number';\n      } else if (isTimeUnit(t)) {\n        derivedType = 'date';\n        var parsedAs = ancestorParse.getWithExplicit(t.field);\n        // Create parse node because the input to time unit is always date.\n        if (parsedAs.value === undefined) {\n          head = new ParseNode(head, _defineProperty({}, t.field, derivedType));\n          ancestorParse.set(t.field, derivedType, false);\n        }\n        transformNode = head = TimeUnitNode.makeFromTransform(head, t);\n      } else if (isAggregate(t)) {\n        transformNode = head = AggregateNode.makeFromTransform(head, t);\n        derivedType = 'number';\n        if (requiresSelectionId(model)) {\n          head = new IdentifierNode(head);\n        }\n      } else if (isLookup(t)) {\n        transformNode = head = LookupNode.make(head, model, t, lookupCounter++);\n        derivedType = 'derived';\n      } else if (isWindow(t)) {\n        transformNode = head = new WindowTransformNode(head, t);\n        derivedType = 'number';\n      } else if (isJoinAggregate(t)) {\n        transformNode = head = new JoinAggregateTransformNode(head, t);\n        derivedType = 'number';\n      } else if (isStack(t)) {\n        transformNode = head = StackNode.makeFromTransform(head, t);\n        derivedType = 'derived';\n      } else if (isFold(t)) {\n        transformNode = head = new FoldTransformNode(head, t);\n        derivedType = 'derived';\n      } else if (isFlatten(t)) {\n        transformNode = head = new FlattenTransformNode(head, t);\n        derivedType = 'derived';\n      } else if (isPivot(t)) {\n        transformNode = head = new PivotTransformNode(head, t);\n        derivedType = 'derived';\n      } else if (isSample(t)) {\n        head = new SampleTransformNode(head, t);\n      } else if (isImpute(t)) {\n        transformNode = head = ImputeNode.makeFromTransform(head, t);\n        derivedType = 'derived';\n      } else if (isDensity(t)) {\n        transformNode = head = new DensityTransformNode(head, t);\n        derivedType = 'derived';\n      } else if (isQuantile(t)) {\n        transformNode = head = new QuantileTransformNode(head, t);\n        derivedType = 'derived';\n      } else if (isRegression(t)) {\n        transformNode = head = new RegressionTransformNode(head, t);\n        derivedType = 'derived';\n      } else if (isLoess(t)) {\n        transformNode = head = new LoessTransformNode(head, t);\n        derivedType = 'derived';\n      } else {\n        log.warn(log.message.invalidTransformIgnored(t));\n        continue;\n      }\n      if (transformNode && derivedType !== undefined) {\n        var _iterator3 = _createForOfIteratorHelper((_b = transformNode.producedFields()) !== null && _b !== void 0 ? _b : []),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var field = _step3.value;\n            ancestorParse.set(field, derivedType, false);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return head;\n}\n/*\nDescription of the dataflow (http://asciiflow.com/):\n     +--------+\n     | Source |\n     +---+----+\n         |\n         v\n     FormatParse\n     (explicit)\n         |\n         v\n     Transforms\n(Filter, Calculate, Binning, TimeUnit, Aggregate, Window, ...)\n         |\n         v\n     FormatParse\n     (implicit)\n         |\n         v\n Binning (in `encoding`)\n         |\n         v\n Timeunit (in `encoding`)\n         |\n         v\nFormula From Sort Array\n         |\n         v\n      +--+--+\n      | Raw |\n      +-----+\n         |\n         v\n  Aggregate (in `encoding`)\n         |\n         v\n  Stack (in `encoding`)\n         |\n         v\n  Invalid Filter\n         |\n         v\n   +----------+\n   |   Main   |\n   +----------+\n         |\n         v\n     +-------+\n     | Facet |----> \"column\", \"column-layout\", and \"row\"\n     +-------+\n         |\n         v\n  ...Child data...\n*/\nexport function parseData(model) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n  var head = parseRoot(model, model.component.data.sources);\n  var _model$component$data = model.component.data,\n    outputNodes = _model$component$data.outputNodes,\n    outputNodeRefCounts = _model$component$data.outputNodeRefCounts;\n  var data = model.data;\n  var newData = data && (isGenerator(data) || isUrlData(data) || isInlineData(data));\n  var ancestorParse = !newData && model.parent ? model.parent.component.data.ancestorParse.clone() : new AncestorParse();\n  if (isGenerator(data)) {\n    // insert generator transform\n    if (isSequenceGenerator(data)) {\n      head = new SequenceNode(head, data.sequence);\n    } else if (isGraticuleGenerator(data)) {\n      head = new GraticuleNode(head, data.graticule);\n    }\n    // no parsing necessary for generator\n    ancestorParse.parseNothing = true;\n  } else if (((_a = data === null || data === void 0 ? void 0 : data.format) === null || _a === void 0 ? void 0 : _a.parse) === null) {\n    // format.parse: null means disable parsing\n    ancestorParse.parseNothing = true;\n  }\n  head = (_b = ParseNode.makeExplicit(head, model, ancestorParse)) !== null && _b !== void 0 ? _b : head;\n  // Default discrete selections require an identifer transform to\n  // uniquely identify data points. Add this transform at the head of\n  // the pipeline such that the identifier field is available for all\n  // subsequent datasets. During optimization, we will remove this\n  // transform if it proves to be unnecessary. Additional identifier\n  // transforms will be necessary when new tuples are constructed\n  // (e.g., post-aggregation).\n  head = new IdentifierNode(head);\n  // HACK: This is equivalent for merging bin extent for union scale.\n  // FIXME(https://github.com/vega/vega-lite/issues/2270): Correctly merge extent / bin node for shared bin scale\n  var parentIsLayer = model.parent && isLayerModel(model.parent);\n  if (isUnitModel(model) || isFacetModel(model)) {\n    if (parentIsLayer) {\n      head = (_c = BinNode.makeFromEncoding(head, model)) !== null && _c !== void 0 ? _c : head;\n    }\n  }\n  if (model.transforms.length > 0) {\n    head = parseTransformArray(head, model, ancestorParse);\n  }\n  // create parse nodes for fields that need to be parsed (or flattened) implicitly\n  var implicitSelection = getImplicitFromSelection(model);\n  var implicitEncoding = getImplicitFromEncoding(model);\n  head = (_d = ParseNode.makeWithAncestors(head, {}, Object.assign(Object.assign({}, implicitSelection), implicitEncoding), ancestorParse)) !== null && _d !== void 0 ? _d : head;\n  if (isUnitModel(model)) {\n    head = GeoJSONNode.parseAll(head, model);\n    head = GeoPointNode.parseAll(head, model);\n  }\n  if (isUnitModel(model) || isFacetModel(model)) {\n    if (!parentIsLayer) {\n      head = (_e = BinNode.makeFromEncoding(head, model)) !== null && _e !== void 0 ? _e : head;\n    }\n    head = (_f = TimeUnitNode.makeFromEncoding(head, model)) !== null && _f !== void 0 ? _f : head;\n    head = CalculateNode.parseAllForSortIndex(head, model);\n  }\n  // add an output node pre aggregation\n  var rawName = model.getDataName(DataSourceType.Raw);\n  var raw = new OutputNode(head, rawName, DataSourceType.Raw, outputNodeRefCounts);\n  outputNodes[rawName] = raw;\n  head = raw;\n  if (isUnitModel(model)) {\n    var agg = AggregateNode.makeFromEncoding(head, model);\n    if (agg) {\n      head = agg;\n      if (requiresSelectionId(model)) {\n        head = new IdentifierNode(head);\n      }\n    }\n    head = (_g = ImputeNode.makeFromEncoding(head, model)) !== null && _g !== void 0 ? _g : head;\n    head = (_h = StackNode.makeFromEncoding(head, model)) !== null && _h !== void 0 ? _h : head;\n  }\n  if (isUnitModel(model)) {\n    head = (_j = FilterInvalidNode.make(head, model)) !== null && _j !== void 0 ? _j : head;\n  }\n  // output node for marks\n  var mainName = model.getDataName(DataSourceType.Main);\n  var main = new OutputNode(head, mainName, DataSourceType.Main, outputNodeRefCounts);\n  outputNodes[mainName] = main;\n  head = main;\n  if (isUnitModel(model)) {\n    materializeSelections(model, main);\n  }\n  // add facet marker\n  var facetRoot = null;\n  if (isFacetModel(model)) {\n    var facetName = model.getName('facet');\n    // Derive new aggregate for facet's sort field\n    // augment data source with new fields for crossed facet\n    head = (_k = makeJoinAggregateFromFacet(head, model.facet)) !== null && _k !== void 0 ? _k : head;\n    facetRoot = new FacetNode(head, model, facetName, main.getSource());\n    outputNodes[facetName] = facetRoot;\n  }\n  return Object.assign(Object.assign({}, model.component.data), {\n    outputNodes: outputNodes,\n    outputNodeRefCounts: outputNodeRefCounts,\n    raw: raw,\n    main: main,\n    facetRoot: facetRoot,\n    ancestorParse: ancestorParse\n  });\n}","map":{"version":3,"sources":["../../../../src/compile/data/parse.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { AncestorParse } from '.';\nimport { isGenerator, isGraticuleGenerator, isInlineData, isNamedData, isSequenceGenerator, isUrlData, DataSourceType } from '../../data';\nimport * as log from '../../log';\nimport { isAggregate, isBin, isCalculate, isDensity, isFilter, isFlatten, isFold, isImpute, isJoinAggregate, isLoess, isLookup, isPivot, isQuantile, isRegression, isSample, isStack, isTimeUnit, isWindow } from '../../transform';\nimport { deepEqual, mergeDeep } from '../../util';\nimport { isFacetModel, isLayerModel, isUnitModel } from '../model';\nimport { requiresSelectionId } from '../selection';\nimport { materializeSelections } from '../selection/parse';\nimport { AggregateNode } from './aggregate';\nimport { BinNode } from './bin';\nimport { CalculateNode } from './calculate';\nimport { OutputNode } from './dataflow';\nimport { DensityTransformNode } from './density';\nimport { FacetNode } from './facet';\nimport { FilterNode } from './filter';\nimport { FilterInvalidNode } from './filterinvalid';\nimport { FlattenTransformNode } from './flatten';\nimport { FoldTransformNode } from './fold';\nimport { getImplicitFromEncoding, getImplicitFromFilterTransform, getImplicitFromSelection, ParseNode } from './formatparse';\nimport { GeoJSONNode } from './geojson';\nimport { GeoPointNode } from './geopoint';\nimport { GraticuleNode } from './graticule';\nimport { IdentifierNode } from './identifier';\nimport { ImputeNode } from './impute';\nimport { JoinAggregateTransformNode } from './joinaggregate';\nimport { makeJoinAggregateFromFacet } from './joinaggregatefacet';\nimport { LoessTransformNode } from './loess';\nimport { LookupNode } from './lookup';\nimport { PivotTransformNode } from './pivot';\nimport { QuantileTransformNode } from './quantile';\nimport { RegressionTransformNode } from './regression';\nimport { SampleTransformNode } from './sample';\nimport { SequenceNode } from './sequence';\nimport { SourceNode } from './source';\nimport { StackNode } from './stack';\nimport { TimeUnitNode } from './timeunit';\nimport { WindowTransformNode } from './window';\nexport function findSource(data, sources) {\n    var _a, _b, _c, _d;\n    for (const other of sources) {\n        const otherData = other.data;\n        // if both datasets have a name defined, we cannot merge\n        if (data.name && other.hasName() && data.name !== other.dataName) {\n            continue;\n        }\n        const formatMesh = (_a = data['format']) === null || _a === void 0 ? void 0 : _a.mesh;\n        const otherFeature = (_b = otherData.format) === null || _b === void 0 ? void 0 : _b.feature;\n        // feature and mesh are mutually exclusive\n        if (formatMesh && otherFeature) {\n            continue;\n        }\n        // we have to extract the same feature or mesh\n        const formatFeature = (_c = data['format']) === null || _c === void 0 ? void 0 : _c.feature;\n        if ((formatFeature || otherFeature) && formatFeature !== otherFeature) {\n            continue;\n        }\n        const otherMesh = (_d = otherData.format) === null || _d === void 0 ? void 0 : _d.mesh;\n        if ((formatMesh || otherMesh) && formatMesh !== otherMesh) {\n            continue;\n        }\n        if (isInlineData(data) && isInlineData(otherData)) {\n            if (deepEqual(data.values, otherData.values)) {\n                return other;\n            }\n        }\n        else if (isUrlData(data) && isUrlData(otherData)) {\n            if (data.url === otherData.url) {\n                return other;\n            }\n        }\n        else if (isNamedData(data)) {\n            if (data.name === other.dataName) {\n                return other;\n            }\n        }\n    }\n    return null;\n}\nfunction parseRoot(model, sources) {\n    if (model.data || !model.parent) {\n        // if the model defines a data source or is the root, create a source node\n        if (model.data === null) {\n            // data: null means we should ignore the parent's data so we just create a new data source\n            const source = new SourceNode({ values: [] });\n            sources.push(source);\n            return source;\n        }\n        const existingSource = findSource(model.data, sources);\n        if (existingSource) {\n            if (!isGenerator(model.data)) {\n                existingSource.data.format = mergeDeep({}, model.data.format, existingSource.data.format);\n            }\n            // if the new source has a name but the existing one does not, we can set it\n            if (!existingSource.hasName() && model.data.name) {\n                existingSource.dataName = model.data.name;\n            }\n            return existingSource;\n        }\n        else {\n            const source = new SourceNode(model.data);\n            sources.push(source);\n            return source;\n        }\n    }\n    else {\n        // If we don't have a source defined (overriding parent's data), use the parent's facet root or main.\n        return model.parent.component.data.facetRoot\n            ? model.parent.component.data.facetRoot\n            : model.parent.component.data.main;\n    }\n}\n/**\n * Parses a transform array into a chain of connected dataflow nodes.\n */\nexport function parseTransformArray(head, model, ancestorParse) {\n    var _a, _b;\n    let lookupCounter = 0;\n    for (const t of model.transforms) {\n        let derivedType = undefined;\n        let transformNode;\n        if (isCalculate(t)) {\n            transformNode = head = new CalculateNode(head, t);\n            derivedType = 'derived';\n        }\n        else if (isFilter(t)) {\n            const implicit = getImplicitFromFilterTransform(t);\n            transformNode = head = (_a = ParseNode.makeWithAncestors(head, {}, implicit, ancestorParse)) !== null && _a !== void 0 ? _a : head;\n            head = new FilterNode(head, model, t.filter);\n        }\n        else if (isBin(t)) {\n            transformNode = head = BinNode.makeFromTransform(head, t, model);\n            derivedType = 'number';\n        }\n        else if (isTimeUnit(t)) {\n            derivedType = 'date';\n            const parsedAs = ancestorParse.getWithExplicit(t.field);\n            // Create parse node because the input to time unit is always date.\n            if (parsedAs.value === undefined) {\n                head = new ParseNode(head, { [t.field]: derivedType });\n                ancestorParse.set(t.field, derivedType, false);\n            }\n            transformNode = head = TimeUnitNode.makeFromTransform(head, t);\n        }\n        else if (isAggregate(t)) {\n            transformNode = head = AggregateNode.makeFromTransform(head, t);\n            derivedType = 'number';\n            if (requiresSelectionId(model)) {\n                head = new IdentifierNode(head);\n            }\n        }\n        else if (isLookup(t)) {\n            transformNode = head = LookupNode.make(head, model, t, lookupCounter++);\n            derivedType = 'derived';\n        }\n        else if (isWindow(t)) {\n            transformNode = head = new WindowTransformNode(head, t);\n            derivedType = 'number';\n        }\n        else if (isJoinAggregate(t)) {\n            transformNode = head = new JoinAggregateTransformNode(head, t);\n            derivedType = 'number';\n        }\n        else if (isStack(t)) {\n            transformNode = head = StackNode.makeFromTransform(head, t);\n            derivedType = 'derived';\n        }\n        else if (isFold(t)) {\n            transformNode = head = new FoldTransformNode(head, t);\n            derivedType = 'derived';\n        }\n        else if (isFlatten(t)) {\n            transformNode = head = new FlattenTransformNode(head, t);\n            derivedType = 'derived';\n        }\n        else if (isPivot(t)) {\n            transformNode = head = new PivotTransformNode(head, t);\n            derivedType = 'derived';\n        }\n        else if (isSample(t)) {\n            head = new SampleTransformNode(head, t);\n        }\n        else if (isImpute(t)) {\n            transformNode = head = ImputeNode.makeFromTransform(head, t);\n            derivedType = 'derived';\n        }\n        else if (isDensity(t)) {\n            transformNode = head = new DensityTransformNode(head, t);\n            derivedType = 'derived';\n        }\n        else if (isQuantile(t)) {\n            transformNode = head = new QuantileTransformNode(head, t);\n            derivedType = 'derived';\n        }\n        else if (isRegression(t)) {\n            transformNode = head = new RegressionTransformNode(head, t);\n            derivedType = 'derived';\n        }\n        else if (isLoess(t)) {\n            transformNode = head = new LoessTransformNode(head, t);\n            derivedType = 'derived';\n        }\n        else {\n            log.warn(log.message.invalidTransformIgnored(t));\n            continue;\n        }\n        if (transformNode && derivedType !== undefined) {\n            for (const field of (_b = transformNode.producedFields()) !== null && _b !== void 0 ? _b : []) {\n                ancestorParse.set(field, derivedType, false);\n            }\n        }\n    }\n    return head;\n}\n/*\nDescription of the dataflow (http://asciiflow.com/):\n     +--------+\n     | Source |\n     +---+----+\n         |\n         v\n     FormatParse\n     (explicit)\n         |\n         v\n     Transforms\n(Filter, Calculate, Binning, TimeUnit, Aggregate, Window, ...)\n         |\n         v\n     FormatParse\n     (implicit)\n         |\n         v\n Binning (in `encoding`)\n         |\n         v\n Timeunit (in `encoding`)\n         |\n         v\nFormula From Sort Array\n         |\n         v\n      +--+--+\n      | Raw |\n      +-----+\n         |\n         v\n  Aggregate (in `encoding`)\n         |\n         v\n  Stack (in `encoding`)\n         |\n         v\n  Invalid Filter\n         |\n         v\n   +----------+\n   |   Main   |\n   +----------+\n         |\n         v\n     +-------+\n     | Facet |----> \"column\", \"column-layout\", and \"row\"\n     +-------+\n         |\n         v\n  ...Child data...\n*/\nexport function parseData(model) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    let head = parseRoot(model, model.component.data.sources);\n    const { outputNodes, outputNodeRefCounts } = model.component.data;\n    const data = model.data;\n    const newData = data && (isGenerator(data) || isUrlData(data) || isInlineData(data));\n    const ancestorParse = !newData && model.parent ? model.parent.component.data.ancestorParse.clone() : new AncestorParse();\n    if (isGenerator(data)) {\n        // insert generator transform\n        if (isSequenceGenerator(data)) {\n            head = new SequenceNode(head, data.sequence);\n        }\n        else if (isGraticuleGenerator(data)) {\n            head = new GraticuleNode(head, data.graticule);\n        }\n        // no parsing necessary for generator\n        ancestorParse.parseNothing = true;\n    }\n    else if (((_a = data === null || data === void 0 ? void 0 : data.format) === null || _a === void 0 ? void 0 : _a.parse) === null) {\n        // format.parse: null means disable parsing\n        ancestorParse.parseNothing = true;\n    }\n    head = (_b = ParseNode.makeExplicit(head, model, ancestorParse)) !== null && _b !== void 0 ? _b : head;\n    // Default discrete selections require an identifer transform to\n    // uniquely identify data points. Add this transform at the head of\n    // the pipeline such that the identifier field is available for all\n    // subsequent datasets. During optimization, we will remove this\n    // transform if it proves to be unnecessary. Additional identifier\n    // transforms will be necessary when new tuples are constructed\n    // (e.g., post-aggregation).\n    head = new IdentifierNode(head);\n    // HACK: This is equivalent for merging bin extent for union scale.\n    // FIXME(https://github.com/vega/vega-lite/issues/2270): Correctly merge extent / bin node for shared bin scale\n    const parentIsLayer = model.parent && isLayerModel(model.parent);\n    if (isUnitModel(model) || isFacetModel(model)) {\n        if (parentIsLayer) {\n            head = (_c = BinNode.makeFromEncoding(head, model)) !== null && _c !== void 0 ? _c : head;\n        }\n    }\n    if (model.transforms.length > 0) {\n        head = parseTransformArray(head, model, ancestorParse);\n    }\n    // create parse nodes for fields that need to be parsed (or flattened) implicitly\n    const implicitSelection = getImplicitFromSelection(model);\n    const implicitEncoding = getImplicitFromEncoding(model);\n    head = (_d = ParseNode.makeWithAncestors(head, {}, Object.assign(Object.assign({}, implicitSelection), implicitEncoding), ancestorParse)) !== null && _d !== void 0 ? _d : head;\n    if (isUnitModel(model)) {\n        head = GeoJSONNode.parseAll(head, model);\n        head = GeoPointNode.parseAll(head, model);\n    }\n    if (isUnitModel(model) || isFacetModel(model)) {\n        if (!parentIsLayer) {\n            head = (_e = BinNode.makeFromEncoding(head, model)) !== null && _e !== void 0 ? _e : head;\n        }\n        head = (_f = TimeUnitNode.makeFromEncoding(head, model)) !== null && _f !== void 0 ? _f : head;\n        head = CalculateNode.parseAllForSortIndex(head, model);\n    }\n    // add an output node pre aggregation\n    const rawName = model.getDataName(DataSourceType.Raw);\n    const raw = new OutputNode(head, rawName, DataSourceType.Raw, outputNodeRefCounts);\n    outputNodes[rawName] = raw;\n    head = raw;\n    if (isUnitModel(model)) {\n        const agg = AggregateNode.makeFromEncoding(head, model);\n        if (agg) {\n            head = agg;\n            if (requiresSelectionId(model)) {\n                head = new IdentifierNode(head);\n            }\n        }\n        head = (_g = ImputeNode.makeFromEncoding(head, model)) !== null && _g !== void 0 ? _g : head;\n        head = (_h = StackNode.makeFromEncoding(head, model)) !== null && _h !== void 0 ? _h : head;\n    }\n    if (isUnitModel(model)) {\n        head = (_j = FilterInvalidNode.make(head, model)) !== null && _j !== void 0 ? _j : head;\n    }\n    // output node for marks\n    const mainName = model.getDataName(DataSourceType.Main);\n    const main = new OutputNode(head, mainName, DataSourceType.Main, outputNodeRefCounts);\n    outputNodes[mainName] = main;\n    head = main;\n    if (isUnitModel(model)) {\n        materializeSelections(model, main);\n    }\n    // add facet marker\n    let facetRoot = null;\n    if (isFacetModel(model)) {\n        const facetName = model.getName('facet');\n        // Derive new aggregate for facet's sort field\n        // augment data source with new fields for crossed facet\n        head = (_k = makeJoinAggregateFromFacet(head, model.facet)) !== null && _k !== void 0 ? _k : head;\n        facetRoot = new FacetNode(head, model, facetName, main.getSource());\n        outputNodes[facetName] = facetRoot;\n    }\n    return Object.assign(Object.assign({}, model.component.data), { outputNodes,\n        outputNodeRefCounts,\n        raw,\n        main,\n        facetRoot,\n        ancestorParse });\n}\n//# sourceMappingURL=parse.js.map"]},"metadata":{},"sourceType":"module"}