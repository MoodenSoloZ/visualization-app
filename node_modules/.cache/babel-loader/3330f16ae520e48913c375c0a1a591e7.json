{"ast":null,"code":"import _classCallCheck from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { isScaleChannel } from '../../channel';\nimport { vgField as fieldRef } from '../../channeldef';\nimport { isPathMark } from '../../mark';\nimport { hasContinuousDomain } from '../../scale';\nimport { hash as _hash, keys } from '../../util';\nimport { getMarkPropOrConfig } from '../common';\nimport { DataFlowNode } from './dataflow';\nexport var FilterInvalidNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(FilterInvalidNode, _DataFlowNode);\n  var _super = _createSuper(FilterInvalidNode);\n  function FilterInvalidNode(parent, filter) {\n    var _this;\n    _classCallCheck(this, FilterInvalidNode);\n    _this = _super.call(this, parent);\n    _this.filter = filter;\n    return _this;\n  }\n  _createClass(FilterInvalidNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new FilterInvalidNode(null, Object.assign({}, this.filter));\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return new Set(keys(this.filter));\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set(); // filter does not produce any new fields\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"FilterInvalid \".concat(_hash(this.filter));\n    }\n    /**\n     * Create the VgTransforms for each of the filtered fields.\n     */\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      var _this2 = this;\n      var filters = keys(this.filter).reduce(function (vegaFilters, field) {\n        var fieldDef = _this2.filter[field];\n        var ref = fieldRef(fieldDef, {\n          expr: 'datum'\n        });\n        if (fieldDef !== null) {\n          if (fieldDef.type === 'temporal') {\n            vegaFilters.push(\"(isDate(\".concat(ref, \") || (isValid(\").concat(ref, \") && isFinite(+\").concat(ref, \")))\"));\n          } else if (fieldDef.type === 'quantitative') {\n            vegaFilters.push(\"isValid(\".concat(ref, \")\"));\n            vegaFilters.push(\"isFinite(+\".concat(ref, \")\"));\n          } else {\n            // should never get here\n          }\n        }\n        return vegaFilters;\n      }, []);\n      return filters.length > 0 ? {\n        type: 'filter',\n        expr: filters.join(' && ')\n      } : null;\n    }\n  }], [{\n    key: \"make\",\n    value: function make(parent, model) {\n      var config = model.config,\n        mark = model.mark,\n        markDef = model.markDef;\n      var invalid = getMarkPropOrConfig('invalid', markDef, config);\n      if (invalid !== 'filter') {\n        return null;\n      }\n      var filter = model.reduceFieldDef(function (aggregator, fieldDef, channel) {\n        var scaleComponent = isScaleChannel(channel) && model.getScaleComponent(channel);\n        if (scaleComponent) {\n          var scaleType = scaleComponent.get('type');\n          // While discrete domain scales can handle invalid values, continuous scales can't.\n          // Thus, for non-path marks, we have to filter null for scales with continuous domains.\n          // (For path marks, we will use \"defined\" property and skip these values instead.)\n          if (hasContinuousDomain(scaleType) && fieldDef.aggregate !== 'count' && !isPathMark(mark)) {\n            aggregator[fieldDef.field] = fieldDef; // we know that the fieldDef is a typed field def\n          }\n        }\n\n        return aggregator;\n      }, {});\n      if (!keys(filter).length) {\n        return null;\n      }\n      return new FilterInvalidNode(parent, filter);\n    }\n  }]);\n  return FilterInvalidNode;\n}(DataFlowNode);","map":{"version":3,"sources":["../../../../src/compile/data/filterinvalid.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isScaleChannel } from '../../channel';\nimport { vgField as fieldRef } from '../../channeldef';\nimport { isPathMark } from '../../mark';\nimport { hasContinuousDomain } from '../../scale';\nimport { hash, keys } from '../../util';\nimport { getMarkPropOrConfig } from '../common';\nimport { DataFlowNode } from './dataflow';\nexport class FilterInvalidNode extends DataFlowNode {\n    constructor(parent, filter) {\n        super(parent);\n        this.filter = filter;\n    }\n    clone() {\n        return new FilterInvalidNode(null, Object.assign({}, this.filter));\n    }\n    static make(parent, model) {\n        const { config, mark, markDef } = model;\n        const invalid = getMarkPropOrConfig('invalid', markDef, config);\n        if (invalid !== 'filter') {\n            return null;\n        }\n        const filter = model.reduceFieldDef((aggregator, fieldDef, channel) => {\n            const scaleComponent = isScaleChannel(channel) && model.getScaleComponent(channel);\n            if (scaleComponent) {\n                const scaleType = scaleComponent.get('type');\n                // While discrete domain scales can handle invalid values, continuous scales can't.\n                // Thus, for non-path marks, we have to filter null for scales with continuous domains.\n                // (For path marks, we will use \"defined\" property and skip these values instead.)\n                if (hasContinuousDomain(scaleType) && fieldDef.aggregate !== 'count' && !isPathMark(mark)) {\n                    aggregator[fieldDef.field] = fieldDef; // we know that the fieldDef is a typed field def\n                }\n            }\n            return aggregator;\n        }, {});\n        if (!keys(filter).length) {\n            return null;\n        }\n        return new FilterInvalidNode(parent, filter);\n    }\n    dependentFields() {\n        return new Set(keys(this.filter));\n    }\n    producedFields() {\n        return new Set(); // filter does not produce any new fields\n    }\n    hash() {\n        return `FilterInvalid ${hash(this.filter)}`;\n    }\n    /**\n     * Create the VgTransforms for each of the filtered fields.\n     */\n    assemble() {\n        const filters = keys(this.filter).reduce((vegaFilters, field) => {\n            const fieldDef = this.filter[field];\n            const ref = fieldRef(fieldDef, { expr: 'datum' });\n            if (fieldDef !== null) {\n                if (fieldDef.type === 'temporal') {\n                    vegaFilters.push(`(isDate(${ref}) || (isValid(${ref}) && isFinite(+${ref})))`);\n                }\n                else if (fieldDef.type === 'quantitative') {\n                    vegaFilters.push(`isValid(${ref})`);\n                    vegaFilters.push(`isFinite(+${ref})`);\n                }\n                else {\n                    // should never get here\n                }\n            }\n            return vegaFilters;\n        }, []);\n        return filters.length > 0\n            ? {\n                type: 'filter',\n                expr: filters.join(' && ')\n            }\n            : null;\n    }\n}\n//# sourceMappingURL=filterinvalid.js.map"]},"metadata":{},"sourceType":"module"}