{"ast":null,"code":"import _defineProperty from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n/**\n * Utility for generating row / column headers\n */\nimport { isArray } from 'vega-util';\nimport { FACET_CHANNELS } from '../../channel';\nimport { vgField } from '../../channeldef';\nimport { HEADER_LABEL_PROPERTIES, HEADER_LABEL_PROPERTIES_MAP, HEADER_TITLE_PROPERTIES, HEADER_TITLE_PROPERTIES_MAP } from '../../header';\nimport { isSortField } from '../../sort';\nimport { isFacetMapping } from '../../spec/facet';\nimport { contains, isEmpty, normalizeAngle, replaceAll } from '../../util';\nimport { defaultLabelAlign, defaultLabelBaseline } from '../axis/properties';\nimport { sortArrayIndexField } from '../data/calculate';\nimport { formatSignalRef } from '../format';\nimport { isFacetModel } from '../model';\nimport { getHeaderChannel, getHeaderProperties, getHeaderProperty } from './common';\nimport { HEADER_TYPES } from './component';\n// TODO: rename to assembleHeaderTitleGroup\nexport function assembleTitleGroup(model, channel) {\n  var title = model.component.layoutHeaders[channel].title;\n  var config = model.config ? model.config : undefined;\n  var facetFieldDef = model.component.layoutHeaders[channel].facetFieldDef ? model.component.layoutHeaders[channel].facetFieldDef : undefined;\n  var _getHeaderProperties = getHeaderProperties(['titleAnchor', 'titleAngle', 'titleOrient'], facetFieldDef.header, config, channel),\n    titleAnchor = _getHeaderProperties.titleAnchor,\n    ta = _getHeaderProperties.titleAngle,\n    titleOrient = _getHeaderProperties.titleOrient;\n  var headerChannel = getHeaderChannel(channel, titleOrient);\n  var titleAngle = normalizeAngle(ta);\n  return {\n    name: \"\".concat(channel, \"-title\"),\n    type: 'group',\n    role: \"\".concat(headerChannel, \"-title\"),\n    title: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n      text: title\n    }, channel === 'row' ? {\n      orient: 'left'\n    } : {}), {\n      style: 'guide-title'\n    }), defaultHeaderGuideBaseline(titleAngle, headerChannel)), defaultHeaderGuideAlign(headerChannel, titleAngle, titleAnchor)), assembleHeaderProperties(config, facetFieldDef, channel, HEADER_TITLE_PROPERTIES, HEADER_TITLE_PROPERTIES_MAP))\n  };\n}\nexport function defaultHeaderGuideAlign(headerChannel, angle) {\n  var anchor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'middle';\n  switch (anchor) {\n    case 'start':\n      return {\n        align: 'left'\n      };\n    case 'end':\n      return {\n        align: 'right'\n      };\n  }\n  var align = defaultLabelAlign(angle, headerChannel === 'row' ? 'left' : 'top', headerChannel === 'row' ? 'y' : 'x');\n  return align ? {\n    align: align\n  } : {};\n}\nexport function defaultHeaderGuideBaseline(angle, channel) {\n  var baseline = defaultLabelBaseline(angle, channel === 'row' ? 'left' : 'top', channel === 'row' ? 'y' : 'x', true);\n  return baseline ? {\n    baseline: baseline\n  } : {};\n}\nexport function assembleHeaderGroups(model, channel) {\n  var layoutHeader = model.component.layoutHeaders[channel];\n  var groups = [];\n  var _iterator = _createForOfIteratorHelper(HEADER_TYPES),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var headerType = _step.value;\n      if (layoutHeader[headerType]) {\n        var _iterator2 = _createForOfIteratorHelper(layoutHeader[headerType]),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var headerComponent = _step2.value;\n            var group = assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent);\n            if (group != null) {\n              groups.push(group);\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return groups;\n}\nfunction getSort(facetFieldDef, channel) {\n  var _a;\n  var sort = facetFieldDef.sort;\n  if (isSortField(sort)) {\n    return {\n      field: vgField(sort, {\n        expr: 'datum'\n      }),\n      order: (_a = sort.order) !== null && _a !== void 0 ? _a : 'ascending'\n    };\n  } else if (isArray(sort)) {\n    return {\n      field: sortArrayIndexField(facetFieldDef, channel, {\n        expr: 'datum'\n      }),\n      order: 'ascending'\n    };\n  } else {\n    return {\n      field: vgField(facetFieldDef, {\n        expr: 'datum'\n      }),\n      order: sort !== null && sort !== void 0 ? sort : 'ascending'\n    };\n  }\n}\nexport function assembleLabelTitle(facetFieldDef, channel, config) {\n  var _getHeaderProperties2 = getHeaderProperties(['format', 'formatType', 'labelAngle', 'labelAnchor', 'labelOrient', 'labelExpr'], facetFieldDef.header, config, channel),\n    format = _getHeaderProperties2.format,\n    formatType = _getHeaderProperties2.formatType,\n    labelAngle = _getHeaderProperties2.labelAngle,\n    labelAnchor = _getHeaderProperties2.labelAnchor,\n    labelOrient = _getHeaderProperties2.labelOrient,\n    labelExpr = _getHeaderProperties2.labelExpr;\n  var titleTextExpr = formatSignalRef({\n    fieldOrDatumDef: facetFieldDef,\n    format: format,\n    formatType: formatType,\n    expr: 'parent',\n    config: config\n  }).signal;\n  var headerChannel = getHeaderChannel(channel, labelOrient);\n  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n    text: {\n      signal: labelExpr ? replaceAll(replaceAll(labelExpr, 'datum.label', titleTextExpr), 'datum.value', vgField(facetFieldDef, {\n        expr: 'parent'\n      })) : titleTextExpr\n    }\n  }, channel === 'row' ? {\n    orient: 'left'\n  } : {}), {\n    style: 'guide-label',\n    frame: 'group'\n  }), defaultHeaderGuideBaseline(labelAngle, headerChannel)), defaultHeaderGuideAlign(headerChannel, labelAngle, labelAnchor)), assembleHeaderProperties(config, facetFieldDef, channel, HEADER_LABEL_PROPERTIES, HEADER_LABEL_PROPERTIES_MAP));\n}\nexport function assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent) {\n  if (headerComponent) {\n    var title = null;\n    var facetFieldDef = layoutHeader.facetFieldDef;\n    var config = model.config ? model.config : undefined;\n    if (facetFieldDef && headerComponent.labels) {\n      var _getHeaderProperties3 = getHeaderProperties(['labelOrient'], facetFieldDef.header, config, channel),\n        labelOrient = _getHeaderProperties3.labelOrient;\n      // Include label title in the header if orient aligns with the channel\n      if (channel === 'row' && !contains(['top', 'bottom'], labelOrient) || channel === 'column' && !contains(['left', 'right'], labelOrient)) {\n        title = assembleLabelTitle(facetFieldDef, channel, config);\n      }\n    }\n    var isFacetWithoutRowCol = isFacetModel(model) && !isFacetMapping(model.facet);\n    var axes = headerComponent.axes;\n    var hasAxes = (axes === null || axes === void 0 ? void 0 : axes.length) > 0;\n    if (title || hasAxes) {\n      var sizeChannel = channel === 'row' ? 'height' : 'width';\n      return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n        name: model.getName(\"\".concat(channel, \"_\").concat(headerType)),\n        type: 'group',\n        role: \"\".concat(channel, \"-\").concat(headerType)\n      }, layoutHeader.facetFieldDef ? {\n        from: {\n          data: model.getName(\"\".concat(channel, \"_domain\"))\n        },\n        sort: getSort(facetFieldDef, channel)\n      } : {}), hasAxes && isFacetWithoutRowCol ? {\n        from: {\n          data: model.getName(\"facet_domain_\".concat(channel))\n        }\n      } : {}), title ? {\n        title: title\n      } : {}), headerComponent.sizeSignal ? {\n        encode: {\n          update: _defineProperty({}, sizeChannel, headerComponent.sizeSignal)\n        }\n      } : {}), hasAxes ? {\n        axes: axes\n      } : {});\n    }\n  }\n  return null;\n}\nvar LAYOUT_TITLE_BAND = {\n  column: {\n    start: 0,\n    end: 1\n  },\n  row: {\n    start: 1,\n    end: 0\n  }\n};\nexport function getLayoutTitleBand(titleAnchor, headerChannel) {\n  return LAYOUT_TITLE_BAND[headerChannel][titleAnchor];\n}\nexport function assembleLayoutTitleBand(headerComponentIndex, config) {\n  var titleBand = {};\n  var _iterator3 = _createForOfIteratorHelper(FACET_CHANNELS),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var channel = _step3.value;\n      var headerComponent = headerComponentIndex[channel];\n      if (headerComponent === null || headerComponent === void 0 ? void 0 : headerComponent.facetFieldDef) {\n        var _getHeaderProperties4 = getHeaderProperties(['titleAnchor', 'titleOrient'], headerComponent.facetFieldDef.header, config, channel),\n          titleAnchor = _getHeaderProperties4.titleAnchor,\n          titleOrient = _getHeaderProperties4.titleOrient;\n        var headerChannel = getHeaderChannel(channel, titleOrient);\n        var band = getLayoutTitleBand(titleAnchor, headerChannel);\n        if (band !== undefined) {\n          titleBand[headerChannel] = band;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return isEmpty(titleBand) ? undefined : titleBand;\n}\nexport function assembleHeaderProperties(config, facetFieldDef, channel, properties, propertiesMap) {\n  var props = {};\n  var _iterator4 = _createForOfIteratorHelper(properties),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var prop = _step4.value;\n      if (!propertiesMap[prop]) {\n        continue;\n      }\n      var value = getHeaderProperty(prop, facetFieldDef === null || facetFieldDef === void 0 ? void 0 : facetFieldDef.header, config, channel);\n      if (value !== undefined) {\n        props[propertiesMap[prop]] = value;\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return props;\n}","map":{"version":3,"sources":["../../../../src/compile/header/assemble.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * Utility for generating row / column headers\n */\nimport { isArray } from 'vega-util';\nimport { FACET_CHANNELS } from '../../channel';\nimport { vgField } from '../../channeldef';\nimport { HEADER_LABEL_PROPERTIES, HEADER_LABEL_PROPERTIES_MAP, HEADER_TITLE_PROPERTIES, HEADER_TITLE_PROPERTIES_MAP } from '../../header';\nimport { isSortField } from '../../sort';\nimport { isFacetMapping } from '../../spec/facet';\nimport { contains, isEmpty, normalizeAngle, replaceAll } from '../../util';\nimport { defaultLabelAlign, defaultLabelBaseline } from '../axis/properties';\nimport { sortArrayIndexField } from '../data/calculate';\nimport { formatSignalRef } from '../format';\nimport { isFacetModel } from '../model';\nimport { getHeaderChannel, getHeaderProperties, getHeaderProperty } from './common';\nimport { HEADER_TYPES } from './component';\n// TODO: rename to assembleHeaderTitleGroup\nexport function assembleTitleGroup(model, channel) {\n    const title = model.component.layoutHeaders[channel].title;\n    const config = model.config ? model.config : undefined;\n    const facetFieldDef = model.component.layoutHeaders[channel].facetFieldDef\n        ? model.component.layoutHeaders[channel].facetFieldDef\n        : undefined;\n    const { titleAnchor, titleAngle: ta, titleOrient } = getHeaderProperties(['titleAnchor', 'titleAngle', 'titleOrient'], facetFieldDef.header, config, channel);\n    const headerChannel = getHeaderChannel(channel, titleOrient);\n    const titleAngle = normalizeAngle(ta);\n    return {\n        name: `${channel}-title`,\n        type: 'group',\n        role: `${headerChannel}-title`,\n        title: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ text: title }, (channel === 'row' ? { orient: 'left' } : {})), { style: 'guide-title' }), defaultHeaderGuideBaseline(titleAngle, headerChannel)), defaultHeaderGuideAlign(headerChannel, titleAngle, titleAnchor)), assembleHeaderProperties(config, facetFieldDef, channel, HEADER_TITLE_PROPERTIES, HEADER_TITLE_PROPERTIES_MAP))\n    };\n}\nexport function defaultHeaderGuideAlign(headerChannel, angle, anchor = 'middle') {\n    switch (anchor) {\n        case 'start':\n            return { align: 'left' };\n        case 'end':\n            return { align: 'right' };\n    }\n    const align = defaultLabelAlign(angle, headerChannel === 'row' ? 'left' : 'top', headerChannel === 'row' ? 'y' : 'x');\n    return align ? { align } : {};\n}\nexport function defaultHeaderGuideBaseline(angle, channel) {\n    const baseline = defaultLabelBaseline(angle, channel === 'row' ? 'left' : 'top', channel === 'row' ? 'y' : 'x', true);\n    return baseline ? { baseline } : {};\n}\nexport function assembleHeaderGroups(model, channel) {\n    const layoutHeader = model.component.layoutHeaders[channel];\n    const groups = [];\n    for (const headerType of HEADER_TYPES) {\n        if (layoutHeader[headerType]) {\n            for (const headerComponent of layoutHeader[headerType]) {\n                const group = assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent);\n                if (group != null) {\n                    groups.push(group);\n                }\n            }\n        }\n    }\n    return groups;\n}\nfunction getSort(facetFieldDef, channel) {\n    var _a;\n    const { sort } = facetFieldDef;\n    if (isSortField(sort)) {\n        return {\n            field: vgField(sort, { expr: 'datum' }),\n            order: (_a = sort.order) !== null && _a !== void 0 ? _a : 'ascending'\n        };\n    }\n    else if (isArray(sort)) {\n        return {\n            field: sortArrayIndexField(facetFieldDef, channel, { expr: 'datum' }),\n            order: 'ascending'\n        };\n    }\n    else {\n        return {\n            field: vgField(facetFieldDef, { expr: 'datum' }),\n            order: sort !== null && sort !== void 0 ? sort : 'ascending'\n        };\n    }\n}\nexport function assembleLabelTitle(facetFieldDef, channel, config) {\n    const { format, formatType, labelAngle, labelAnchor, labelOrient, labelExpr } = getHeaderProperties(['format', 'formatType', 'labelAngle', 'labelAnchor', 'labelOrient', 'labelExpr'], facetFieldDef.header, config, channel);\n    const titleTextExpr = formatSignalRef({\n        fieldOrDatumDef: facetFieldDef,\n        format,\n        formatType,\n        expr: 'parent',\n        config\n    }).signal;\n    const headerChannel = getHeaderChannel(channel, labelOrient);\n    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ text: {\n            signal: labelExpr\n                ? replaceAll(replaceAll(labelExpr, 'datum.label', titleTextExpr), 'datum.value', vgField(facetFieldDef, { expr: 'parent' }))\n                : titleTextExpr\n        } }, (channel === 'row' ? { orient: 'left' } : {})), { style: 'guide-label', frame: 'group' }), defaultHeaderGuideBaseline(labelAngle, headerChannel)), defaultHeaderGuideAlign(headerChannel, labelAngle, labelAnchor)), assembleHeaderProperties(config, facetFieldDef, channel, HEADER_LABEL_PROPERTIES, HEADER_LABEL_PROPERTIES_MAP));\n}\nexport function assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent) {\n    if (headerComponent) {\n        let title = null;\n        const { facetFieldDef } = layoutHeader;\n        const config = model.config ? model.config : undefined;\n        if (facetFieldDef && headerComponent.labels) {\n            const { labelOrient } = getHeaderProperties(['labelOrient'], facetFieldDef.header, config, channel);\n            // Include label title in the header if orient aligns with the channel\n            if ((channel === 'row' && !contains(['top', 'bottom'], labelOrient)) ||\n                (channel === 'column' && !contains(['left', 'right'], labelOrient))) {\n                title = assembleLabelTitle(facetFieldDef, channel, config);\n            }\n        }\n        const isFacetWithoutRowCol = isFacetModel(model) && !isFacetMapping(model.facet);\n        const axes = headerComponent.axes;\n        const hasAxes = (axes === null || axes === void 0 ? void 0 : axes.length) > 0;\n        if (title || hasAxes) {\n            const sizeChannel = channel === 'row' ? 'height' : 'width';\n            return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ name: model.getName(`${channel}_${headerType}`), type: 'group', role: `${channel}-${headerType}` }, (layoutHeader.facetFieldDef\n                ? {\n                    from: { data: model.getName(`${channel}_domain`) },\n                    sort: getSort(facetFieldDef, channel)\n                }\n                : {})), (hasAxes && isFacetWithoutRowCol\n                ? {\n                    from: { data: model.getName(`facet_domain_${channel}`) }\n                }\n                : {})), (title ? { title } : {})), (headerComponent.sizeSignal\n                ? {\n                    encode: {\n                        update: {\n                            [sizeChannel]: headerComponent.sizeSignal\n                        }\n                    }\n                }\n                : {})), (hasAxes ? { axes } : {}));\n        }\n    }\n    return null;\n}\nconst LAYOUT_TITLE_BAND = {\n    column: {\n        start: 0,\n        end: 1\n    },\n    row: {\n        start: 1,\n        end: 0\n    }\n};\nexport function getLayoutTitleBand(titleAnchor, headerChannel) {\n    return LAYOUT_TITLE_BAND[headerChannel][titleAnchor];\n}\nexport function assembleLayoutTitleBand(headerComponentIndex, config) {\n    const titleBand = {};\n    for (const channel of FACET_CHANNELS) {\n        const headerComponent = headerComponentIndex[channel];\n        if (headerComponent === null || headerComponent === void 0 ? void 0 : headerComponent.facetFieldDef) {\n            const { titleAnchor, titleOrient } = getHeaderProperties(['titleAnchor', 'titleOrient'], headerComponent.facetFieldDef.header, config, channel);\n            const headerChannel = getHeaderChannel(channel, titleOrient);\n            const band = getLayoutTitleBand(titleAnchor, headerChannel);\n            if (band !== undefined) {\n                titleBand[headerChannel] = band;\n            }\n        }\n    }\n    return isEmpty(titleBand) ? undefined : titleBand;\n}\nexport function assembleHeaderProperties(config, facetFieldDef, channel, properties, propertiesMap) {\n    const props = {};\n    for (const prop of properties) {\n        if (!propertiesMap[prop]) {\n            continue;\n        }\n        const value = getHeaderProperty(prop, facetFieldDef === null || facetFieldDef === void 0 ? void 0 : facetFieldDef.header, config, channel);\n        if (value !== undefined) {\n            props[propertiesMap[prop]] = value;\n        }\n    }\n    return props;\n}\n//# sourceMappingURL=assemble.js.map"]},"metadata":{},"sourceType":"module"}