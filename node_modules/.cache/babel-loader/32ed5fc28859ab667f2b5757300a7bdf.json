{"ast":null,"code":"import _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { hasOwnProperty } from 'vega-util';\nimport { LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef } from '../../channeldef';\nimport { DataSourceType } from '../../data';\nimport { replaceExprRef } from '../../expr';\nimport { PROJECTION_PROPERTIES } from '../../projection';\nimport { GEOJSON } from '../../type';\nimport { deepEqual, duplicate, every } from '../../util';\nimport { isUnitModel } from '../model';\nimport { ProjectionComponent } from './component';\nexport function parseProjection(model) {\n  model.component.projection = isUnitModel(model) ? parseUnitProjection(model) : parseNonUnitProjections(model);\n}\nfunction parseUnitProjection(model) {\n  var _a;\n  if (model.hasProjection) {\n    var proj = replaceExprRef(model.specifiedProjection);\n    var fit = !(proj && (proj.scale != null || proj.translate != null));\n    var size = fit ? [model.getSizeSignalRef('width'), model.getSizeSignalRef('height')] : undefined;\n    var data = fit ? gatherFitData(model) : undefined;\n    var projComp = new ProjectionComponent(model.projectionName(true), Object.assign(Object.assign({}, (_a = replaceExprRef(model.config.projection)) !== null && _a !== void 0 ? _a : {}), proj !== null && proj !== void 0 ? proj : {}), size, data);\n    if (!projComp.get('type')) {\n      projComp.set('type', 'equalEarth', false);\n    }\n    return projComp;\n  }\n  return undefined;\n}\nfunction gatherFitData(model) {\n  var data = [];\n  var encoding = model.encoding;\n  for (var _i = 0, _arr = [[LONGITUDE, LATITUDE], [LONGITUDE2, LATITUDE2]]; _i < _arr.length; _i++) {\n    var posssiblePair = _arr[_i];\n    if (getFieldOrDatumDef(encoding[posssiblePair[0]]) || getFieldOrDatumDef(encoding[posssiblePair[1]])) {\n      data.push({\n        signal: model.getName(\"geojson_\".concat(data.length))\n      });\n    }\n  }\n  if (model.channelHasField(SHAPE) && model.typedFieldDef(SHAPE).type === GEOJSON) {\n    data.push({\n      signal: model.getName(\"geojson_\".concat(data.length))\n    });\n  }\n  if (data.length === 0) {\n    // main source is geojson, so we can just use that\n    data.push(model.requestDataName(DataSourceType.Main));\n  }\n  return data;\n}\nfunction mergeIfNoConflict(first, second) {\n  var allPropertiesShared = every(PROJECTION_PROPERTIES, function (prop) {\n    // neither has the property\n    if (!hasOwnProperty(first.explicit, prop) && !hasOwnProperty(second.explicit, prop)) {\n      return true;\n    }\n    // both have property and an equal value for property\n    if (hasOwnProperty(first.explicit, prop) && hasOwnProperty(second.explicit, prop) &&\n    // some properties might be signals or objects and require hashing for comparison\n    deepEqual(first.get(prop), second.get(prop))) {\n      return true;\n    }\n    return false;\n  });\n  var size = deepEqual(first.size, second.size);\n  if (size) {\n    if (allPropertiesShared) {\n      return first;\n    } else if (deepEqual(first.explicit, {})) {\n      return second;\n    } else if (deepEqual(second.explicit, {})) {\n      return first;\n    }\n  }\n  // if all properties don't match, let each unit spec have its own projection\n  return null;\n}\nfunction parseNonUnitProjections(model) {\n  if (model.children.length === 0) {\n    return undefined;\n  }\n  var nonUnitProjection;\n  // parse all children first\n  var _iterator = _createForOfIteratorHelper(model.children),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _child = _step.value;\n      parseProjection(_child);\n    }\n    // analyze parsed projections, attempt to merge\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var mergable = every(model.children, function (child) {\n    var projection = child.component.projection;\n    if (!projection) {\n      // child layer does not use a projection\n      return true;\n    } else if (!nonUnitProjection) {\n      // cached 'projection' is null, cache this one\n      nonUnitProjection = projection;\n      return true;\n    } else {\n      var merge = mergeIfNoConflict(nonUnitProjection, projection);\n      if (merge) {\n        nonUnitProjection = merge;\n      }\n      return !!merge;\n    }\n  });\n  // if cached one and all other children share the same projection,\n  if (nonUnitProjection && mergable) {\n    // so we can elevate it to the layer level\n    var name = model.projectionName(true);\n    var modelProjection = new ProjectionComponent(name, nonUnitProjection.specifiedProjection, nonUnitProjection.size, duplicate(nonUnitProjection.data));\n    // rename and assign all others as merged\n    var _iterator2 = _createForOfIteratorHelper(model.children),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var child = _step2.value;\n        var projection = child.component.projection;\n        if (projection) {\n          if (projection.isFit) {\n            var _modelProjection$data;\n            (_modelProjection$data = modelProjection.data).push.apply(_modelProjection$data, _toConsumableArray(child.component.projection.data));\n          }\n          child.renameProjection(projection.get('name'), name);\n          projection.merged = true;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    return modelProjection;\n  }\n  return undefined;\n}","map":{"version":3,"sources":["../../../../src/compile/projection/parse.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { hasOwnProperty } from 'vega-util';\nimport { LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef } from '../../channeldef';\nimport { DataSourceType } from '../../data';\nimport { replaceExprRef } from '../../expr';\nimport { PROJECTION_PROPERTIES } from '../../projection';\nimport { GEOJSON } from '../../type';\nimport { deepEqual, duplicate, every } from '../../util';\nimport { isUnitModel } from '../model';\nimport { ProjectionComponent } from './component';\nexport function parseProjection(model) {\n    model.component.projection = isUnitModel(model) ? parseUnitProjection(model) : parseNonUnitProjections(model);\n}\nfunction parseUnitProjection(model) {\n    var _a;\n    if (model.hasProjection) {\n        const proj = replaceExprRef(model.specifiedProjection);\n        const fit = !(proj && (proj.scale != null || proj.translate != null));\n        const size = fit ? [model.getSizeSignalRef('width'), model.getSizeSignalRef('height')] : undefined;\n        const data = fit ? gatherFitData(model) : undefined;\n        const projComp = new ProjectionComponent(model.projectionName(true), Object.assign(Object.assign({}, ((_a = replaceExprRef(model.config.projection)) !== null && _a !== void 0 ? _a : {})), (proj !== null && proj !== void 0 ? proj : {})), size, data);\n        if (!projComp.get('type')) {\n            projComp.set('type', 'equalEarth', false);\n        }\n        return projComp;\n    }\n    return undefined;\n}\nfunction gatherFitData(model) {\n    const data = [];\n    const { encoding } = model;\n    for (const posssiblePair of [\n        [LONGITUDE, LATITUDE],\n        [LONGITUDE2, LATITUDE2]\n    ]) {\n        if (getFieldOrDatumDef(encoding[posssiblePair[0]]) || getFieldOrDatumDef(encoding[posssiblePair[1]])) {\n            data.push({\n                signal: model.getName(`geojson_${data.length}`)\n            });\n        }\n    }\n    if (model.channelHasField(SHAPE) && model.typedFieldDef(SHAPE).type === GEOJSON) {\n        data.push({\n            signal: model.getName(`geojson_${data.length}`)\n        });\n    }\n    if (data.length === 0) {\n        // main source is geojson, so we can just use that\n        data.push(model.requestDataName(DataSourceType.Main));\n    }\n    return data;\n}\nfunction mergeIfNoConflict(first, second) {\n    const allPropertiesShared = every(PROJECTION_PROPERTIES, prop => {\n        // neither has the property\n        if (!hasOwnProperty(first.explicit, prop) && !hasOwnProperty(second.explicit, prop)) {\n            return true;\n        }\n        // both have property and an equal value for property\n        if (hasOwnProperty(first.explicit, prop) &&\n            hasOwnProperty(second.explicit, prop) &&\n            // some properties might be signals or objects and require hashing for comparison\n            deepEqual(first.get(prop), second.get(prop))) {\n            return true;\n        }\n        return false;\n    });\n    const size = deepEqual(first.size, second.size);\n    if (size) {\n        if (allPropertiesShared) {\n            return first;\n        }\n        else if (deepEqual(first.explicit, {})) {\n            return second;\n        }\n        else if (deepEqual(second.explicit, {})) {\n            return first;\n        }\n    }\n    // if all properties don't match, let each unit spec have its own projection\n    return null;\n}\nfunction parseNonUnitProjections(model) {\n    if (model.children.length === 0) {\n        return undefined;\n    }\n    let nonUnitProjection;\n    // parse all children first\n    for (const child of model.children) {\n        parseProjection(child);\n    }\n    // analyze parsed projections, attempt to merge\n    const mergable = every(model.children, child => {\n        const projection = child.component.projection;\n        if (!projection) {\n            // child layer does not use a projection\n            return true;\n        }\n        else if (!nonUnitProjection) {\n            // cached 'projection' is null, cache this one\n            nonUnitProjection = projection;\n            return true;\n        }\n        else {\n            const merge = mergeIfNoConflict(nonUnitProjection, projection);\n            if (merge) {\n                nonUnitProjection = merge;\n            }\n            return !!merge;\n        }\n    });\n    // if cached one and all other children share the same projection,\n    if (nonUnitProjection && mergable) {\n        // so we can elevate it to the layer level\n        const name = model.projectionName(true);\n        const modelProjection = new ProjectionComponent(name, nonUnitProjection.specifiedProjection, nonUnitProjection.size, duplicate(nonUnitProjection.data));\n        // rename and assign all others as merged\n        for (const child of model.children) {\n            const projection = child.component.projection;\n            if (projection) {\n                if (projection.isFit) {\n                    modelProjection.data.push(...child.component.projection.data);\n                }\n                child.renameProjection(projection.get('name'), name);\n                projection.merged = true;\n            }\n        }\n        return modelProjection;\n    }\n    return undefined;\n}\n//# sourceMappingURL=parse.js.map"]},"metadata":{},"sourceType":"module"}