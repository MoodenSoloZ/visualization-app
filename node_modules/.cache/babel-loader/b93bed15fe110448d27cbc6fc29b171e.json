{"ast":null,"code":"import _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { Marks, textMetrics } from 'vega-scenegraph';\nimport { canvas } from 'vega-canvas';\nimport { rederive, Transform } from 'vega-dataflow';\nimport { inherits, isFunction, error, array } from 'vega-util';\nvar ALPHA_MASK = 0xff000000;\nfunction baseBitmaps($, data) {\n  var bitmap = $.bitmap(); // when there is no base mark but data points are to be avoided\n\n  (data || []).forEach(function (d) {\n    return bitmap.set($(d.boundary[0]), $(d.boundary[3]));\n  });\n  return [bitmap, undefined];\n}\nfunction markBitmaps($, baseMark, avoidMarks, labelInside, isGroupArea) {\n  // create canvas\n  var width = $.width,\n    height = $.height,\n    border = labelInside || isGroupArea,\n    context = canvas(width, height).getContext('2d'),\n    baseMarkContext = canvas(width, height).getContext('2d'),\n    strokeContext = border && canvas(width, height).getContext('2d'); // render all marks to be avoided into canvas\n\n  avoidMarks.forEach(function (items) {\n    return draw(context, items, false);\n  });\n  draw(baseMarkContext, baseMark, false);\n  if (border) {\n    draw(strokeContext, baseMark, true);\n  } // get canvas buffer, create bitmaps\n\n  var buffer = getBuffer(context, width, height),\n    baseMarkBuffer = getBuffer(baseMarkContext, width, height),\n    strokeBuffer = border && getBuffer(strokeContext, width, height),\n    layer1 = $.bitmap(),\n    layer2 = border && $.bitmap(); // populate bitmap layers\n\n  var x, y, u, v, index, alpha, strokeAlpha, baseMarkAlpha;\n  for (y = 0; y < height; ++y) {\n    for (x = 0; x < width; ++x) {\n      index = y * width + x;\n      alpha = buffer[index] & ALPHA_MASK;\n      baseMarkAlpha = baseMarkBuffer[index] & ALPHA_MASK;\n      strokeAlpha = border && strokeBuffer[index] & ALPHA_MASK;\n      if (alpha || strokeAlpha || baseMarkAlpha) {\n        u = $(x);\n        v = $(y);\n        if (!isGroupArea && (alpha || baseMarkAlpha)) layer1.set(u, v); // update interior bitmap\n\n        if (border && (alpha || strokeAlpha)) layer2.set(u, v); // update border bitmap\n      }\n    }\n  }\n\n  return [layer1, layer2];\n}\nfunction getBuffer(context, width, height) {\n  return new Uint32Array(context.getImageData(0, 0, width, height).data.buffer);\n}\nfunction draw(context, items, interior) {\n  if (!items.length) return;\n  var type = items[0].mark.marktype;\n  if (type === 'group') {\n    items.forEach(function (group) {\n      group.items.forEach(function (mark) {\n        return draw(context, mark.items, interior);\n      });\n    });\n  } else {\n    Marks[type].draw(context, {\n      items: interior ? items.map(prepare) : items\n    });\n  }\n}\n/**\n * Prepare item before drawing into canvas (setting stroke and opacity)\n * @param {object} source item to be prepared\n * @returns prepared item\n */\n\nfunction prepare(source) {\n  var item = rederive(source, {});\n  if (item.stroke && item.strokeOpacity !== 0 || item.fill && item.fillOpacity !== 0) {\n    return _objectSpread(_objectSpread({}, item), {}, {\n      strokeOpacity: 1,\n      stroke: '#000',\n      fillOpacity: 0\n    });\n  }\n  return item;\n}\nvar DIV = 5,\n  // bit shift from x, y index to bit vector array index\n  MOD = 31,\n  // bit mask for index lookup within a bit vector\n  SIZE = 32,\n  // individual bit vector size\n  RIGHT0 = new Uint32Array(SIZE + 1),\n  // left-anchored bit vectors, full -> 0\n  RIGHT1 = new Uint32Array(SIZE + 1); // right-anchored bit vectors, 0 -> full\n\nRIGHT1[0] = 0;\nRIGHT0[0] = ~RIGHT1[0];\nfor (var i = 1; i <= SIZE; ++i) {\n  RIGHT1[i] = RIGHT1[i - 1] << 1 | 1;\n  RIGHT0[i] = ~RIGHT1[i];\n}\nfunction Bitmap(w, h) {\n  var array = new Uint32Array(~~((w * h + SIZE) / SIZE));\n  function _set(index, mask) {\n    array[index] |= mask;\n  }\n  function _clear(index, mask) {\n    array[index] &= mask;\n  }\n  return {\n    array: array,\n    get: function get(x, y) {\n      var index = y * w + x;\n      return array[index >>> DIV] & 1 << (index & MOD);\n    },\n    set: function set(x, y) {\n      var index = y * w + x;\n      _set(index >>> DIV, 1 << (index & MOD));\n    },\n    clear: function clear(x, y) {\n      var index = y * w + x;\n      _clear(index >>> DIV, ~(1 << (index & MOD)));\n    },\n    getRange: function getRange(x, y, x2, y2) {\n      var r = y2,\n        start,\n        end,\n        indexStart,\n        indexEnd;\n      for (; r >= y; --r) {\n        start = r * w + x;\n        end = r * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n        if (indexStart === indexEnd) {\n          if (array[indexStart] & RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]) {\n            return true;\n          }\n        } else {\n          if (array[indexStart] & RIGHT0[start & MOD]) return true;\n          if (array[indexEnd] & RIGHT1[(end & MOD) + 1]) return true;\n          for (var _i = indexStart + 1; _i < indexEnd; ++_i) {\n            if (array[_i]) return true;\n          }\n        }\n      }\n      return false;\n    },\n    setRange: function setRange(x, y, x2, y2) {\n      var start, end, indexStart, indexEnd, i;\n      for (; y <= y2; ++y) {\n        start = y * w + x;\n        end = y * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n        if (indexStart === indexEnd) {\n          _set(indexStart, RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]);\n        } else {\n          _set(indexStart, RIGHT0[start & MOD]);\n          _set(indexEnd, RIGHT1[(end & MOD) + 1]);\n          for (i = indexStart + 1; i < indexEnd; ++i) {\n            _set(i, 0xffffffff);\n          }\n        }\n      }\n    },\n    clearRange: function clearRange(x, y, x2, y2) {\n      var start, end, indexStart, indexEnd, i;\n      for (; y <= y2; ++y) {\n        start = y * w + x;\n        end = y * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n        if (indexStart === indexEnd) {\n          _clear(indexStart, RIGHT1[start & MOD] | RIGHT0[(end & MOD) + 1]);\n        } else {\n          _clear(indexStart, RIGHT1[start & MOD]);\n          _clear(indexEnd, RIGHT0[(end & MOD) + 1]);\n          for (i = indexStart + 1; i < indexEnd; ++i) {\n            _clear(i, 0);\n          }\n        }\n      }\n    },\n    outOfBounds: function outOfBounds(x, y, x2, y2) {\n      return x < 0 || y < 0 || y2 >= h || x2 >= w;\n    }\n  };\n}\nfunction scaler(width, height, padding) {\n  var ratio = Math.max(1, Math.sqrt(width * height / 1e6)),\n    w = ~~((width + 2 * padding + ratio) / ratio),\n    h = ~~((height + 2 * padding + ratio) / ratio),\n    scale = function scale(_) {\n      return ~~((_ + padding) / ratio);\n    };\n  scale.invert = function (_) {\n    return _ * ratio - padding;\n  };\n  scale.bitmap = function () {\n    return Bitmap(w, h);\n  };\n  scale.ratio = ratio;\n  scale.padding = padding;\n  scale.width = width;\n  scale.height = height;\n  return scale;\n}\nfunction placeAreaLabelNaive($, bitmaps, avoidBaseMark, markIndex) {\n  var width = $.width,\n    height = $.height; // try to place a label within an input area mark\n\n  return function (d) {\n    var items = d.datum.datum.items[markIndex].items,\n      // area points\n      n = items.length,\n      // number of points\n      textHeight = d.datum.fontSize,\n      // label width\n      textWidth = textMetrics.width(d.datum, d.datum.text); // label height\n\n    var maxAreaWidth = 0,\n      x1,\n      x2,\n      y1,\n      y2,\n      x,\n      y,\n      areaWidth; // for each area sample point\n\n    for (var _i2 = 0; _i2 < n; ++_i2) {\n      x1 = items[_i2].x;\n      y1 = items[_i2].y;\n      x2 = items[_i2].x2 === undefined ? x1 : items[_i2].x2;\n      y2 = items[_i2].y2 === undefined ? y1 : items[_i2].y2;\n      x = (x1 + x2) / 2;\n      y = (y1 + y2) / 2;\n      areaWidth = Math.abs(x2 - x1 + y2 - y1);\n      if (areaWidth >= maxAreaWidth) {\n        maxAreaWidth = areaWidth;\n        d.x = x;\n        d.y = y;\n      }\n    }\n    x = textWidth / 2;\n    y = textHeight / 2;\n    x1 = d.x - x;\n    x2 = d.x + x;\n    y1 = d.y - y;\n    y2 = d.y + y;\n    d.align = 'center';\n    if (x1 < 0 && x2 <= width) {\n      d.align = 'left';\n    } else if (0 <= x1 && width < x2) {\n      d.align = 'right';\n    }\n    d.baseline = 'middle';\n    if (y1 < 0 && y2 <= height) {\n      d.baseline = 'top';\n    } else if (0 <= y1 && height < y2) {\n      d.baseline = 'bottom';\n    }\n    return true;\n  };\n}\nfunction outOfBounds(x, y, textWidth, textHeight, width, height) {\n  var r = textWidth / 2;\n  return x - r < 0 || x + r > width || y - (r = textHeight / 2) < 0 || y + r > height;\n}\nfunction collision($, x, y, textHeight, textWidth, h, bm0, bm1) {\n  var w = textWidth * h / (textHeight * 2),\n    x1 = $(x - w),\n    x2 = $(x + w),\n    y1 = $(y - (h = h / 2)),\n    y2 = $(y + h);\n  return bm0.outOfBounds(x1, y1, x2, y2) || bm0.getRange(x1, y1, x2, y2) || bm1 && bm1.getRange(x1, y1, x2, y2);\n}\nfunction placeAreaLabelReducedSearch($, bitmaps, avoidBaseMark, markIndex) {\n  var width = $.width,\n    height = $.height,\n    bm0 = bitmaps[0],\n    // where labels have been placed\n    bm1 = bitmaps[1]; // area outlines\n\n  function tryLabel(_x, _y, maxSize, textWidth, textHeight) {\n    var x = $.invert(_x),\n      y = $.invert(_y);\n    var lo = maxSize,\n      hi = height,\n      mid;\n    if (!outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n      // if the label fits at the current sample point,\n      // perform binary search to find the largest font size that fits\n      while (hi - lo >= 1) {\n        mid = (lo + hi) / 2;\n        if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {\n          hi = mid;\n        } else {\n          lo = mid;\n        }\n      } // place label if current lower bound exceeds prior max font size\n\n      if (lo > maxSize) {\n        return [x, y, lo, true];\n      }\n    }\n  } // try to place a label within an input area mark\n\n  return function (d) {\n    var items = d.datum.datum.items[markIndex].items,\n      // area points\n      n = items.length,\n      // number of points\n      textHeight = d.datum.fontSize,\n      // label width\n      textWidth = textMetrics.width(d.datum, d.datum.text); // label height\n\n    var maxSize = avoidBaseMark ? textHeight : 0,\n      labelPlaced = false,\n      labelPlaced2 = false,\n      maxAreaWidth = 0,\n      x1,\n      x2,\n      y1,\n      y2,\n      x,\n      y,\n      _x,\n      _y,\n      _x1,\n      _xMid,\n      _x2,\n      _y1,\n      _yMid,\n      _y2,\n      areaWidth,\n      result,\n      swapTmp; // for each area sample point\n\n    for (var _i3 = 0; _i3 < n; ++_i3) {\n      x1 = items[_i3].x;\n      y1 = items[_i3].y;\n      x2 = items[_i3].x2 === undefined ? x1 : items[_i3].x2;\n      y2 = items[_i3].y2 === undefined ? y1 : items[_i3].y2;\n      if (x1 > x2) {\n        swapTmp = x1;\n        x1 = x2;\n        x2 = swapTmp;\n      }\n      if (y1 > y2) {\n        swapTmp = y1;\n        y1 = y2;\n        y2 = swapTmp;\n      }\n      _x1 = $(x1);\n      _x2 = $(x2);\n      _xMid = ~~((_x1 + _x2) / 2);\n      _y1 = $(y1);\n      _y2 = $(y2);\n      _yMid = ~~((_y1 + _y2) / 2); // search along the line from mid point between the 2 border to lower border\n\n      for (_x = _xMid; _x >= _x1; --_x) {\n        for (_y = _yMid; _y >= _y1; --_y) {\n          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);\n          if (result) {\n            var _result = result;\n            var _result2 = _slicedToArray(_result, 4);\n            d.x = _result2[0];\n            d.y = _result2[1];\n            maxSize = _result2[2];\n            labelPlaced = _result2[3];\n          }\n        }\n      } // search along the line from mid point between the 2 border to upper border\n\n      for (_x = _xMid; _x <= _x2; ++_x) {\n        for (_y = _yMid; _y <= _y2; ++_y) {\n          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);\n          if (result) {\n            var _result3 = result;\n            var _result4 = _slicedToArray(_result3, 4);\n            d.x = _result4[0];\n            d.y = _result4[1];\n            maxSize = _result4[2];\n            labelPlaced = _result4[3];\n          }\n        }\n      } // place label at slice center if not placed through other means\n      // and if we're not avoiding overlap with other areas\n\n      if (!labelPlaced && !avoidBaseMark) {\n        // one span is zero, hence we can add\n        areaWidth = Math.abs(x2 - x1 + y2 - y1);\n        x = (x1 + x2) / 2;\n        y = (y1 + y2) / 2; // place label if it fits and improves the max area width\n\n        if (areaWidth >= maxAreaWidth && !outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n          maxAreaWidth = areaWidth;\n          d.x = x;\n          d.y = y;\n          labelPlaced2 = true;\n        }\n      }\n    } // record current label placement information, update label bitmap\n\n    if (labelPlaced || labelPlaced2) {\n      x = textWidth / 2;\n      y = textHeight / 2;\n      bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));\n      d.align = 'center';\n      d.baseline = 'middle';\n      return true;\n    } else {\n      return false;\n    }\n  };\n}\nvar X_DIR = [-1, -1, 1, 1];\nvar Y_DIR = [-1, 1, -1, 1];\nfunction placeAreaLabelFloodFill($, bitmaps, avoidBaseMark, markIndex) {\n  var width = $.width,\n    height = $.height,\n    bm0 = bitmaps[0],\n    // where labels have been placed\n    bm1 = bitmaps[1],\n    // area outlines\n    bm2 = $.bitmap(); // flood-fill visitations\n  // try to place a label within an input area mark\n\n  return function (d) {\n    var items = d.datum.datum.items[markIndex].items,\n      // area points\n      n = items.length,\n      // number of points\n      textHeight = d.datum.fontSize,\n      // label width\n      textWidth = textMetrics.width(d.datum, d.datum.text),\n      // label height\n      stack = []; // flood fill stack\n\n    var maxSize = avoidBaseMark ? textHeight : 0,\n      labelPlaced = false,\n      labelPlaced2 = false,\n      maxAreaWidth = 0,\n      x1,\n      x2,\n      y1,\n      y2,\n      x,\n      y,\n      _x,\n      _y,\n      lo,\n      hi,\n      mid,\n      areaWidth; // for each area sample point\n\n    for (var _i4 = 0; _i4 < n; ++_i4) {\n      x1 = items[_i4].x;\n      y1 = items[_i4].y;\n      x2 = items[_i4].x2 === undefined ? x1 : items[_i4].x2;\n      y2 = items[_i4].y2 === undefined ? y1 : items[_i4].y2; // add scaled center point to stack\n\n      stack.push([$((x1 + x2) / 2), $((y1 + y2) / 2)]); // perform flood fill, visit points\n\n      while (stack.length) {\n        var _stack$pop = stack.pop();\n        var _stack$pop2 = _slicedToArray(_stack$pop, 2);\n        _x = _stack$pop2[0];\n        _y = _stack$pop2[1];\n        // exit if point already marked\n\n        if (bm0.get(_x, _y) || bm1.get(_x, _y) || bm2.get(_x, _y)) continue; // mark point in flood fill bitmap\n        // add search points for all (in bound) directions\n\n        bm2.set(_x, _y);\n        for (var j = 0; j < 4; ++j) {\n          x = _x + X_DIR[j];\n          y = _y + Y_DIR[j];\n          if (!bm2.outOfBounds(x, y, x, y)) stack.push([x, y]);\n        } // unscale point back to x, y space\n\n        x = $.invert(_x);\n        y = $.invert(_y);\n        lo = maxSize;\n        hi = height; // TODO: make this bound smaller\n\n        if (!outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n          // if the label fits at the current sample point,\n          // perform binary search to find the largest font size that fits\n          while (hi - lo >= 1) {\n            mid = (lo + hi) / 2;\n            if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {\n              hi = mid;\n            } else {\n              lo = mid;\n            }\n          } // place label if current lower bound exceeds prior max font size\n\n          if (lo > maxSize) {\n            d.x = x;\n            d.y = y;\n            maxSize = lo;\n            labelPlaced = true;\n          }\n        }\n      } // place label at slice center if not placed through other means\n      // and if we're not avoiding overlap with other areas\n\n      if (!labelPlaced && !avoidBaseMark) {\n        // one span is zero, hence we can add\n        areaWidth = Math.abs(x2 - x1 + y2 - y1);\n        x = (x1 + x2) / 2;\n        y = (y1 + y2) / 2; // place label if it fits and improves the max area width\n\n        if (areaWidth >= maxAreaWidth && !outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n          maxAreaWidth = areaWidth;\n          d.x = x;\n          d.y = y;\n          labelPlaced2 = true;\n        }\n      }\n    } // record current label placement information, update label bitmap\n\n    if (labelPlaced || labelPlaced2) {\n      x = textWidth / 2;\n      y = textHeight / 2;\n      bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));\n      d.align = 'center';\n      d.baseline = 'middle';\n      return true;\n    } else {\n      return false;\n    }\n  };\n}\nvar Aligns = ['right', 'center', 'left'],\n  Baselines = ['bottom', 'middle', 'top'];\nfunction placeMarkLabel($, bitmaps, anchors, offsets) {\n  var width = $.width,\n    height = $.height,\n    bm0 = bitmaps[0],\n    bm1 = bitmaps[1],\n    n = offsets.length;\n  return function (d) {\n    var _d$textWidth;\n    var boundary = d.boundary,\n      textHeight = d.datum.fontSize; // can not be placed if the mark is not visible in the graph bound\n\n    if (boundary[2] < 0 || boundary[5] < 0 || boundary[0] > width || boundary[3] > height) {\n      return false;\n    }\n    var textWidth = (_d$textWidth = d.textWidth) !== null && _d$textWidth !== void 0 ? _d$textWidth : 0,\n      dx,\n      dy,\n      isInside,\n      sizeFactor,\n      insideFactor,\n      x1,\n      x2,\n      y1,\n      y2,\n      xc,\n      yc,\n      _x1,\n      _x2,\n      _y1,\n      _y2; // for each anchor and offset\n\n    for (var _i5 = 0; _i5 < n; ++_i5) {\n      dx = (anchors[_i5] & 0x3) - 1;\n      dy = (anchors[_i5] >>> 0x2 & 0x3) - 1;\n      isInside = dx === 0 && dy === 0 || offsets[_i5] < 0;\n      sizeFactor = dx && dy ? Math.SQRT1_2 : 1;\n      insideFactor = offsets[_i5] < 0 ? -1 : 1;\n      x1 = boundary[1 + dx] + offsets[_i5] * dx * sizeFactor;\n      yc = boundary[4 + dy] + insideFactor * textHeight * dy / 2 + offsets[_i5] * dy * sizeFactor;\n      y1 = yc - textHeight / 2;\n      y2 = yc + textHeight / 2;\n      _x1 = $(x1);\n      _y1 = $(y1);\n      _y2 = $(y2);\n      if (!textWidth) {\n        // to avoid finding width of text label,\n        if (!test(_x1, _x1, _y1, _y2, bm0, bm1, x1, x1, y1, y2, boundary, isInside)) {\n          // skip this anchor/offset option if we fail to place a label with 1px width\n          continue;\n        } else {\n          // Otherwise, find the label width\n          textWidth = textMetrics.width(d.datum, d.datum.text);\n        }\n      }\n      xc = x1 + insideFactor * textWidth * dx / 2;\n      x1 = xc - textWidth / 2;\n      x2 = xc + textWidth / 2;\n      _x1 = $(x1);\n      _x2 = $(x2);\n      if (test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside)) {\n        // place label if the position is placeable\n        d.x = !dx ? xc : dx * insideFactor < 0 ? x2 : x1;\n        d.y = !dy ? yc : dy * insideFactor < 0 ? y2 : y1;\n        d.align = Aligns[dx * insideFactor + 1];\n        d.baseline = Baselines[dy * insideFactor + 1];\n        bm0.setRange(_x1, _y1, _x2, _y2);\n        return true;\n      }\n    }\n    return false;\n  };\n} // Test if a label with the given dimensions can be added without overlap\n\nfunction test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside) {\n  return !(bm0.outOfBounds(_x1, _y1, _x2, _y2) || (isInside && bm1 || bm0).getRange(_x1, _y1, _x2, _y2));\n}\nvar TOP = 0x0,\n  MIDDLE = 0x4,\n  BOTTOM = 0x8,\n  LEFT = 0x0,\n  CENTER = 0x1,\n  RIGHT = 0x2; // Mapping from text anchor to number representation\n\nvar anchorCode = {\n  'top-left': TOP + LEFT,\n  'top': TOP + CENTER,\n  'top-right': TOP + RIGHT,\n  'left': MIDDLE + LEFT,\n  'middle': MIDDLE + CENTER,\n  'right': MIDDLE + RIGHT,\n  'bottom-left': BOTTOM + LEFT,\n  'bottom': BOTTOM + CENTER,\n  'bottom-right': BOTTOM + RIGHT\n};\nvar placeAreaLabel = {\n  'naive': placeAreaLabelNaive,\n  'reduced-search': placeAreaLabelReducedSearch,\n  'floodfill': placeAreaLabelFloodFill\n};\nfunction labelLayout(texts, size, compare, offset, anchor, avoidMarks, avoidBaseMark, lineAnchor, markIndex, padding, method) {\n  // early exit for empty data\n  if (!texts.length) return texts;\n  var positions = Math.max(offset.length, anchor.length),\n    offsets = getOffsets(offset, positions),\n    anchors = getAnchors(anchor, positions),\n    marktype = markType(texts[0].datum),\n    grouptype = marktype === 'group' && texts[0].datum.items[markIndex].marktype,\n    isGroupArea = grouptype === 'area',\n    boundary = markBoundary(marktype, grouptype, lineAnchor, markIndex),\n    infPadding = padding === null || padding === Infinity,\n    isNaiveGroupArea = isGroupArea && method === 'naive';\n  var maxTextWidth = -1,\n    maxTextHeight = -1; // prepare text mark data for placing\n\n  var data = texts.map(function (d) {\n    var textWidth = infPadding ? textMetrics.width(d, d.text) : undefined;\n    maxTextWidth = Math.max(maxTextWidth, textWidth);\n    maxTextHeight = Math.max(maxTextHeight, d.fontSize);\n    return {\n      datum: d,\n      opacity: 0,\n      x: undefined,\n      y: undefined,\n      align: undefined,\n      baseline: undefined,\n      boundary: boundary(d),\n      textWidth: textWidth\n    };\n  });\n  padding = padding === null || padding === Infinity ? Math.max(maxTextWidth, maxTextHeight) + Math.max.apply(Math, _toConsumableArray(offset)) : padding;\n  var $ = scaler(size[0], size[1], padding);\n  var bitmaps;\n  if (!isNaiveGroupArea) {\n    // sort labels in priority order, if comparator is provided\n    if (compare) {\n      data.sort(function (a, b) {\n        return compare(a.datum, b.datum);\n      });\n    } // flag indicating if label can be placed inside its base mark\n\n    var labelInside = false;\n    for (var _i6 = 0; _i6 < anchors.length && !labelInside; ++_i6) {\n      // label inside if anchor is at center\n      // label inside if offset to be inside the mark bound\n      labelInside = anchors[_i6] === 0x5 || offsets[_i6] < 0;\n    } // extract data information from base mark when base mark is to be avoided\n    // base mark is implicitly avoided if it is a group area\n\n    var baseMark = (marktype && avoidBaseMark || isGroupArea) && texts.map(function (d) {\n      return d.datum;\n    }); // generate bitmaps for layout calculation\n\n    bitmaps = avoidMarks.length || baseMark ? markBitmaps($, baseMark || [], avoidMarks, labelInside, isGroupArea) : baseBitmaps($, avoidBaseMark && data);\n  } // generate label placement function\n\n  var place = isGroupArea ? placeAreaLabel[method]($, bitmaps, avoidBaseMark, markIndex) : placeMarkLabel($, bitmaps, anchors, offsets); // place all labels\n\n  data.forEach(function (d) {\n    return d.opacity = +place(d);\n  });\n  return data;\n}\nfunction getOffsets(_, count) {\n  var offsets = new Float64Array(count),\n    n = _.length;\n  for (var _i7 = 0; _i7 < n; ++_i7) {\n    offsets[_i7] = _[_i7] || 0;\n  }\n  for (var _i8 = n; _i8 < count; ++_i8) {\n    offsets[_i8] = offsets[n - 1];\n  }\n  return offsets;\n}\nfunction getAnchors(_, count) {\n  var anchors = new Int8Array(count),\n    n = _.length;\n  for (var _i9 = 0; _i9 < n; ++_i9) {\n    anchors[_i9] |= anchorCode[_[_i9]];\n  }\n  for (var _i10 = n; _i10 < count; ++_i10) {\n    anchors[_i10] = anchors[n - 1];\n  }\n  return anchors;\n}\nfunction markType(item) {\n  return item && item.mark && item.mark.marktype;\n}\n/**\n * Factory function for function for getting base mark boundary, depending\n * on mark and group type. When mark type is undefined, line or area: boundary\n * is the coordinate of each data point. When base mark is grouped line,\n * boundary is either at the start or end of the line depending on the\n * value of lineAnchor. Otherwise, use bounds of base mark.\n */\n\nfunction markBoundary(marktype, grouptype, lineAnchor, markIndex) {\n  var xy = function xy(d) {\n    return [d.x, d.x, d.x, d.y, d.y, d.y];\n  };\n  if (!marktype) {\n    return xy; // no reactive geometry\n  } else if (marktype === 'line' || marktype === 'area') {\n    return function (d) {\n      return xy(d.datum);\n    };\n  } else if (grouptype === 'line') {\n    return function (d) {\n      var items = d.datum.items[markIndex].items;\n      return xy(items.length ? items[lineAnchor === 'start' ? 0 : items.length - 1] : {\n        x: NaN,\n        y: NaN\n      });\n    };\n  } else {\n    return function (d) {\n      var b = d.datum.bounds;\n      return [b.x1, (b.x1 + b.x2) / 2, b.x2, b.y1, (b.y1 + b.y2) / 2, b.y2];\n    };\n  }\n}\nvar Output = ['x', 'y', 'opacity', 'align', 'baseline'];\nvar Anchors = ['top-left', 'left', 'bottom-left', 'top', 'bottom', 'top-right', 'right', 'bottom-right'];\n/**\n * Compute text label layout to annotate marks.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The size of the layout, provided as a [width, height] array.\n * @param {function(*,*): number} [params.sort] - An optional\n *   comparator function for sorting label data in priority order.\n * @param {Array<string>} [params.anchor] - Label anchor points relative to the base mark bounding box.\n *   The available options are 'top-left', 'left', 'bottom-left', 'top',\n *   'bottom', 'top-right', 'right', 'bottom-right', 'middle'.\n * @param {Array<number>} [params.offset] - Label offsets (in pixels) from the base mark bounding box.\n *   This parameter is parallel to the list of anchor points.\n * @param {number | null} [params.padding=0] - The amount (in pixels) that a label may exceed the layout size.\n *   If this parameter is null, a label may exceed the layout size without any boundary.\n * @param {string} [params.lineAnchor='end'] - For group line mark labels only, indicates the anchor\n *   position for labels. One of 'start' or 'end'.\n * @param {string} [params.markIndex=0] - For group mark labels only, an index indicating\n *   which mark within the group should be labeled.\n * @param {Array<number>} [params.avoidMarks] - A list of additional mark names for which the label\n *   layout should avoid overlap.\n * @param {boolean} [params.avoidBaseMark=true] - Boolean flag indicating if labels should avoid\n *   overlap with the underlying base mark being labeled.\n * @param {string} [params.method='naive'] - For area make labels only, a method for\n *   place labels. One of 'naive', 'reduced-search', or 'floodfill'.\n * @param {Array<string>} [params.as] - The output fields written by the transform.\n *   The default is ['x', 'y', 'opacity', 'align', 'baseline'].\n */\n\nfunction Label(params) {\n  Transform.call(this, null, params);\n}\nLabel.Definition = {\n  type: 'Label',\n  metadata: {\n    modifies: true\n  },\n  params: [{\n    name: 'size',\n    type: 'number',\n    array: true,\n    length: 2,\n    required: true\n  }, {\n    name: 'sort',\n    type: 'compare'\n  }, {\n    name: 'anchor',\n    type: 'string',\n    array: true,\n    default: Anchors\n  }, {\n    name: 'offset',\n    type: 'number',\n    array: true,\n    default: [1]\n  }, {\n    name: 'padding',\n    type: 'number',\n    default: 0,\n    null: true\n  }, {\n    name: 'lineAnchor',\n    type: 'string',\n    values: ['start', 'end'],\n    default: 'end'\n  }, {\n    name: 'markIndex',\n    type: 'number',\n    default: 0\n  }, {\n    name: 'avoidBaseMark',\n    type: 'boolean',\n    default: true\n  }, {\n    name: 'avoidMarks',\n    type: 'data',\n    array: true\n  }, {\n    name: 'method',\n    type: 'string',\n    default: 'naive'\n  }, {\n    name: 'as',\n    type: 'string',\n    array: true,\n    length: Output.length,\n    default: Output\n  }]\n};\ninherits(Label, Transform, {\n  transform: function transform(_, pulse) {\n    function modp(param) {\n      var p = _[param];\n      return isFunction(p) && pulse.modified(p.fields);\n    }\n    var mod = _.modified();\n    if (!(mod || pulse.changed(pulse.ADD_REM) || modp('sort'))) return;\n    if (!_.size || _.size.length !== 2) {\n      error('Size parameter should be specified as a [width, height] array.');\n    }\n    var as = _.as || Output; // run label layout\n\n    labelLayout(pulse.materialize(pulse.SOURCE).source || [], _.size, _.sort, array(_.offset == null ? 1 : _.offset), array(_.anchor || Anchors), _.avoidMarks || [], _.avoidBaseMark !== false, _.lineAnchor || 'end', _.markIndex || 0, _.padding === undefined ? 0 : _.padding, _.method || 'naive').forEach(function (l) {\n      // write layout results to data stream\n      var t = l.datum;\n      t[as[0]] = l.x;\n      t[as[1]] = l.y;\n      t[as[2]] = l.opacity;\n      t[as[3]] = l.align;\n      t[as[4]] = l.baseline;\n    });\n    return pulse.reflow(mod).modifies(as);\n  }\n});\nexport { Label as label };","map":{"version":3,"names":["Marks","textMetrics","canvas","rederive","Transform","inherits","isFunction","error","array","ALPHA_MASK","baseBitmaps","$","data","bitmap","forEach","d","set","boundary","undefined","markBitmaps","baseMark","avoidMarks","labelInside","isGroupArea","width","height","border","context","getContext","baseMarkContext","strokeContext","items","draw","buffer","getBuffer","baseMarkBuffer","strokeBuffer","layer1","layer2","x","y","u","v","index","alpha","strokeAlpha","baseMarkAlpha","Uint32Array","getImageData","interior","length","type","mark","marktype","group","map","prepare","source","item","stroke","strokeOpacity","fill","fillOpacity","DIV","MOD","SIZE","RIGHT0","RIGHT1","i","Bitmap","w","h","_set","mask","_clear","get","clear","getRange","x2","y2","r","start","end","indexStart","indexEnd","setRange","clearRange","outOfBounds","scaler","padding","ratio","Math","max","sqrt","scale","_","invert","placeAreaLabelNaive","bitmaps","avoidBaseMark","markIndex","datum","n","textHeight","fontSize","textWidth","text","maxAreaWidth","x1","y1","areaWidth","abs","align","baseline","collision","bm0","bm1","placeAreaLabelReducedSearch","tryLabel","_x","_y","maxSize","lo","hi","mid","labelPlaced","labelPlaced2","_x1","_xMid","_x2","_y1","_yMid","_y2","result","swapTmp","X_DIR","Y_DIR","placeAreaLabelFloodFill","bm2","stack","push","pop","j","Aligns","Baselines","placeMarkLabel","anchors","offsets","_d$textWidth","dx","dy","isInside","sizeFactor","insideFactor","xc","yc","SQRT1_2","test","TOP","MIDDLE","BOTTOM","LEFT","CENTER","RIGHT","anchorCode","placeAreaLabel","labelLayout","texts","size","compare","offset","anchor","lineAnchor","method","positions","getOffsets","getAnchors","markType","grouptype","markBoundary","infPadding","Infinity","isNaiveGroupArea","maxTextWidth","maxTextHeight","opacity","sort","a","b","place","count","Float64Array","Int8Array","xy","NaN","bounds","Output","Anchors","Label","params","call","Definition","metadata","modifies","name","required","default","null","values","transform","pulse","modp","param","p","modified","fields","mod","changed","ADD_REM","as","materialize","SOURCE","l","t","reflow","label"],"sources":["/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/vega-label/build/vega-label.module.js"],"sourcesContent":["import { Marks, textMetrics } from 'vega-scenegraph';\nimport { canvas } from 'vega-canvas';\nimport { rederive, Transform } from 'vega-dataflow';\nimport { inherits, isFunction, error, array } from 'vega-util';\n\nconst ALPHA_MASK = 0xff000000;\nfunction baseBitmaps($, data) {\n  const bitmap = $.bitmap(); // when there is no base mark but data points are to be avoided\n\n  (data || []).forEach(d => bitmap.set($(d.boundary[0]), $(d.boundary[3])));\n  return [bitmap, undefined];\n}\nfunction markBitmaps($, baseMark, avoidMarks, labelInside, isGroupArea) {\n  // create canvas\n  const width = $.width,\n        height = $.height,\n        border = labelInside || isGroupArea,\n        context = canvas(width, height).getContext('2d'),\n        baseMarkContext = canvas(width, height).getContext('2d'),\n        strokeContext = border && canvas(width, height).getContext('2d'); // render all marks to be avoided into canvas\n\n  avoidMarks.forEach(items => draw(context, items, false));\n  draw(baseMarkContext, baseMark, false);\n\n  if (border) {\n    draw(strokeContext, baseMark, true);\n  } // get canvas buffer, create bitmaps\n\n\n  const buffer = getBuffer(context, width, height),\n        baseMarkBuffer = getBuffer(baseMarkContext, width, height),\n        strokeBuffer = border && getBuffer(strokeContext, width, height),\n        layer1 = $.bitmap(),\n        layer2 = border && $.bitmap(); // populate bitmap layers\n\n  let x, y, u, v, index, alpha, strokeAlpha, baseMarkAlpha;\n\n  for (y = 0; y < height; ++y) {\n    for (x = 0; x < width; ++x) {\n      index = y * width + x;\n      alpha = buffer[index] & ALPHA_MASK;\n      baseMarkAlpha = baseMarkBuffer[index] & ALPHA_MASK;\n      strokeAlpha = border && strokeBuffer[index] & ALPHA_MASK;\n\n      if (alpha || strokeAlpha || baseMarkAlpha) {\n        u = $(x);\n        v = $(y);\n        if (!isGroupArea && (alpha || baseMarkAlpha)) layer1.set(u, v); // update interior bitmap\n\n        if (border && (alpha || strokeAlpha)) layer2.set(u, v); // update border bitmap\n      }\n    }\n  }\n\n  return [layer1, layer2];\n}\n\nfunction getBuffer(context, width, height) {\n  return new Uint32Array(context.getImageData(0, 0, width, height).data.buffer);\n}\n\nfunction draw(context, items, interior) {\n  if (!items.length) return;\n  const type = items[0].mark.marktype;\n\n  if (type === 'group') {\n    items.forEach(group => {\n      group.items.forEach(mark => draw(context, mark.items, interior));\n    });\n  } else {\n    Marks[type].draw(context, {\n      items: interior ? items.map(prepare) : items\n    });\n  }\n}\n/**\n * Prepare item before drawing into canvas (setting stroke and opacity)\n * @param {object} source item to be prepared\n * @returns prepared item\n */\n\n\nfunction prepare(source) {\n  const item = rederive(source, {});\n\n  if (item.stroke && item.strokeOpacity !== 0 || item.fill && item.fillOpacity !== 0) {\n    return { ...item,\n      strokeOpacity: 1,\n      stroke: '#000',\n      fillOpacity: 0\n    };\n  }\n\n  return item;\n}\n\nconst DIV = 5,\n      // bit shift from x, y index to bit vector array index\nMOD = 31,\n      // bit mask for index lookup within a bit vector\nSIZE = 32,\n      // individual bit vector size\nRIGHT0 = new Uint32Array(SIZE + 1),\n      // left-anchored bit vectors, full -> 0\nRIGHT1 = new Uint32Array(SIZE + 1); // right-anchored bit vectors, 0 -> full\n\nRIGHT1[0] = 0;\nRIGHT0[0] = ~RIGHT1[0];\n\nfor (let i = 1; i <= SIZE; ++i) {\n  RIGHT1[i] = RIGHT1[i - 1] << 1 | 1;\n  RIGHT0[i] = ~RIGHT1[i];\n}\n\nfunction Bitmap (w, h) {\n  const array = new Uint32Array(~~((w * h + SIZE) / SIZE));\n\n  function _set(index, mask) {\n    array[index] |= mask;\n  }\n\n  function _clear(index, mask) {\n    array[index] &= mask;\n  }\n\n  return {\n    array: array,\n    get: (x, y) => {\n      const index = y * w + x;\n      return array[index >>> DIV] & 1 << (index & MOD);\n    },\n    set: (x, y) => {\n      const index = y * w + x;\n\n      _set(index >>> DIV, 1 << (index & MOD));\n    },\n    clear: (x, y) => {\n      const index = y * w + x;\n\n      _clear(index >>> DIV, ~(1 << (index & MOD)));\n    },\n    getRange: (x, y, x2, y2) => {\n      let r = y2,\n          start,\n          end,\n          indexStart,\n          indexEnd;\n\n      for (; r >= y; --r) {\n        start = r * w + x;\n        end = r * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n\n        if (indexStart === indexEnd) {\n          if (array[indexStart] & RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]) {\n            return true;\n          }\n        } else {\n          if (array[indexStart] & RIGHT0[start & MOD]) return true;\n          if (array[indexEnd] & RIGHT1[(end & MOD) + 1]) return true;\n\n          for (let i = indexStart + 1; i < indexEnd; ++i) {\n            if (array[i]) return true;\n          }\n        }\n      }\n\n      return false;\n    },\n    setRange: (x, y, x2, y2) => {\n      let start, end, indexStart, indexEnd, i;\n\n      for (; y <= y2; ++y) {\n        start = y * w + x;\n        end = y * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n\n        if (indexStart === indexEnd) {\n          _set(indexStart, RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]);\n        } else {\n          _set(indexStart, RIGHT0[start & MOD]);\n\n          _set(indexEnd, RIGHT1[(end & MOD) + 1]);\n\n          for (i = indexStart + 1; i < indexEnd; ++i) _set(i, 0xffffffff);\n        }\n      }\n    },\n    clearRange: (x, y, x2, y2) => {\n      let start, end, indexStart, indexEnd, i;\n\n      for (; y <= y2; ++y) {\n        start = y * w + x;\n        end = y * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n\n        if (indexStart === indexEnd) {\n          _clear(indexStart, RIGHT1[start & MOD] | RIGHT0[(end & MOD) + 1]);\n        } else {\n          _clear(indexStart, RIGHT1[start & MOD]);\n\n          _clear(indexEnd, RIGHT0[(end & MOD) + 1]);\n\n          for (i = indexStart + 1; i < indexEnd; ++i) _clear(i, 0);\n        }\n      }\n    },\n    outOfBounds: (x, y, x2, y2) => x < 0 || y < 0 || y2 >= h || x2 >= w\n  };\n}\n\nfunction scaler (width, height, padding) {\n  const ratio = Math.max(1, Math.sqrt(width * height / 1e6)),\n        w = ~~((width + 2 * padding + ratio) / ratio),\n        h = ~~((height + 2 * padding + ratio) / ratio),\n        scale = _ => ~~((_ + padding) / ratio);\n\n  scale.invert = _ => _ * ratio - padding;\n\n  scale.bitmap = () => Bitmap(w, h);\n\n  scale.ratio = ratio;\n  scale.padding = padding;\n  scale.width = width;\n  scale.height = height;\n  return scale;\n}\n\nfunction placeAreaLabelNaive ($, bitmaps, avoidBaseMark, markIndex) {\n  const width = $.width,\n        height = $.height; // try to place a label within an input area mark\n\n  return function (d) {\n    const items = d.datum.datum.items[markIndex].items,\n          // area points\n    n = items.length,\n          // number of points\n    textHeight = d.datum.fontSize,\n          // label width\n    textWidth = textMetrics.width(d.datum, d.datum.text); // label height\n\n    let maxAreaWidth = 0,\n        x1,\n        x2,\n        y1,\n        y2,\n        x,\n        y,\n        areaWidth; // for each area sample point\n\n    for (let i = 0; i < n; ++i) {\n      x1 = items[i].x;\n      y1 = items[i].y;\n      x2 = items[i].x2 === undefined ? x1 : items[i].x2;\n      y2 = items[i].y2 === undefined ? y1 : items[i].y2;\n      x = (x1 + x2) / 2;\n      y = (y1 + y2) / 2;\n      areaWidth = Math.abs(x2 - x1 + y2 - y1);\n\n      if (areaWidth >= maxAreaWidth) {\n        maxAreaWidth = areaWidth;\n        d.x = x;\n        d.y = y;\n      }\n    }\n\n    x = textWidth / 2;\n    y = textHeight / 2;\n    x1 = d.x - x;\n    x2 = d.x + x;\n    y1 = d.y - y;\n    y2 = d.y + y;\n    d.align = 'center';\n\n    if (x1 < 0 && x2 <= width) {\n      d.align = 'left';\n    } else if (0 <= x1 && width < x2) {\n      d.align = 'right';\n    }\n\n    d.baseline = 'middle';\n\n    if (y1 < 0 && y2 <= height) {\n      d.baseline = 'top';\n    } else if (0 <= y1 && height < y2) {\n      d.baseline = 'bottom';\n    }\n\n    return true;\n  };\n}\n\nfunction outOfBounds(x, y, textWidth, textHeight, width, height) {\n  let r = textWidth / 2;\n  return x - r < 0 || x + r > width || y - (r = textHeight / 2) < 0 || y + r > height;\n}\nfunction collision($, x, y, textHeight, textWidth, h, bm0, bm1) {\n  const w = textWidth * h / (textHeight * 2),\n        x1 = $(x - w),\n        x2 = $(x + w),\n        y1 = $(y - (h = h / 2)),\n        y2 = $(y + h);\n  return bm0.outOfBounds(x1, y1, x2, y2) || bm0.getRange(x1, y1, x2, y2) || bm1 && bm1.getRange(x1, y1, x2, y2);\n}\n\nfunction placeAreaLabelReducedSearch ($, bitmaps, avoidBaseMark, markIndex) {\n  const width = $.width,\n        height = $.height,\n        bm0 = bitmaps[0],\n        // where labels have been placed\n  bm1 = bitmaps[1]; // area outlines\n\n  function tryLabel(_x, _y, maxSize, textWidth, textHeight) {\n    const x = $.invert(_x),\n          y = $.invert(_y);\n    let lo = maxSize,\n        hi = height,\n        mid;\n\n    if (!outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n      // if the label fits at the current sample point,\n      // perform binary search to find the largest font size that fits\n      while (hi - lo >= 1) {\n        mid = (lo + hi) / 2;\n\n        if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {\n          hi = mid;\n        } else {\n          lo = mid;\n        }\n      } // place label if current lower bound exceeds prior max font size\n\n\n      if (lo > maxSize) {\n        return [x, y, lo, true];\n      }\n    }\n  } // try to place a label within an input area mark\n\n\n  return function (d) {\n    const items = d.datum.datum.items[markIndex].items,\n          // area points\n    n = items.length,\n          // number of points\n    textHeight = d.datum.fontSize,\n          // label width\n    textWidth = textMetrics.width(d.datum, d.datum.text); // label height\n\n    let maxSize = avoidBaseMark ? textHeight : 0,\n        labelPlaced = false,\n        labelPlaced2 = false,\n        maxAreaWidth = 0,\n        x1,\n        x2,\n        y1,\n        y2,\n        x,\n        y,\n        _x,\n        _y,\n        _x1,\n        _xMid,\n        _x2,\n        _y1,\n        _yMid,\n        _y2,\n        areaWidth,\n        result,\n        swapTmp; // for each area sample point\n\n\n    for (let i = 0; i < n; ++i) {\n      x1 = items[i].x;\n      y1 = items[i].y;\n      x2 = items[i].x2 === undefined ? x1 : items[i].x2;\n      y2 = items[i].y2 === undefined ? y1 : items[i].y2;\n\n      if (x1 > x2) {\n        swapTmp = x1;\n        x1 = x2;\n        x2 = swapTmp;\n      }\n\n      if (y1 > y2) {\n        swapTmp = y1;\n        y1 = y2;\n        y2 = swapTmp;\n      }\n\n      _x1 = $(x1);\n      _x2 = $(x2);\n      _xMid = ~~((_x1 + _x2) / 2);\n      _y1 = $(y1);\n      _y2 = $(y2);\n      _yMid = ~~((_y1 + _y2) / 2); // search along the line from mid point between the 2 border to lower border\n\n      for (_x = _xMid; _x >= _x1; --_x) {\n        for (_y = _yMid; _y >= _y1; --_y) {\n          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);\n\n          if (result) {\n            [d.x, d.y, maxSize, labelPlaced] = result;\n          }\n        }\n      } // search along the line from mid point between the 2 border to upper border\n\n\n      for (_x = _xMid; _x <= _x2; ++_x) {\n        for (_y = _yMid; _y <= _y2; ++_y) {\n          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);\n\n          if (result) {\n            [d.x, d.y, maxSize, labelPlaced] = result;\n          }\n        }\n      } // place label at slice center if not placed through other means\n      // and if we're not avoiding overlap with other areas\n\n\n      if (!labelPlaced && !avoidBaseMark) {\n        // one span is zero, hence we can add\n        areaWidth = Math.abs(x2 - x1 + y2 - y1);\n        x = (x1 + x2) / 2;\n        y = (y1 + y2) / 2; // place label if it fits and improves the max area width\n\n        if (areaWidth >= maxAreaWidth && !outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n          maxAreaWidth = areaWidth;\n          d.x = x;\n          d.y = y;\n          labelPlaced2 = true;\n        }\n      }\n    } // record current label placement information, update label bitmap\n\n\n    if (labelPlaced || labelPlaced2) {\n      x = textWidth / 2;\n      y = textHeight / 2;\n      bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));\n      d.align = 'center';\n      d.baseline = 'middle';\n      return true;\n    } else {\n      return false;\n    }\n  };\n}\n\nconst X_DIR = [-1, -1, 1, 1];\nconst Y_DIR = [-1, 1, -1, 1];\nfunction placeAreaLabelFloodFill ($, bitmaps, avoidBaseMark, markIndex) {\n  const width = $.width,\n        height = $.height,\n        bm0 = bitmaps[0],\n        // where labels have been placed\n  bm1 = bitmaps[1],\n        // area outlines\n  bm2 = $.bitmap(); // flood-fill visitations\n  // try to place a label within an input area mark\n\n  return function (d) {\n    const items = d.datum.datum.items[markIndex].items,\n          // area points\n    n = items.length,\n          // number of points\n    textHeight = d.datum.fontSize,\n          // label width\n    textWidth = textMetrics.width(d.datum, d.datum.text),\n          // label height\n    stack = []; // flood fill stack\n\n    let maxSize = avoidBaseMark ? textHeight : 0,\n        labelPlaced = false,\n        labelPlaced2 = false,\n        maxAreaWidth = 0,\n        x1,\n        x2,\n        y1,\n        y2,\n        x,\n        y,\n        _x,\n        _y,\n        lo,\n        hi,\n        mid,\n        areaWidth; // for each area sample point\n\n\n    for (let i = 0; i < n; ++i) {\n      x1 = items[i].x;\n      y1 = items[i].y;\n      x2 = items[i].x2 === undefined ? x1 : items[i].x2;\n      y2 = items[i].y2 === undefined ? y1 : items[i].y2; // add scaled center point to stack\n\n      stack.push([$((x1 + x2) / 2), $((y1 + y2) / 2)]); // perform flood fill, visit points\n\n      while (stack.length) {\n        [_x, _y] = stack.pop(); // exit if point already marked\n\n        if (bm0.get(_x, _y) || bm1.get(_x, _y) || bm2.get(_x, _y)) continue; // mark point in flood fill bitmap\n        // add search points for all (in bound) directions\n\n        bm2.set(_x, _y);\n\n        for (let j = 0; j < 4; ++j) {\n          x = _x + X_DIR[j];\n          y = _y + Y_DIR[j];\n          if (!bm2.outOfBounds(x, y, x, y)) stack.push([x, y]);\n        } // unscale point back to x, y space\n\n\n        x = $.invert(_x);\n        y = $.invert(_y);\n        lo = maxSize;\n        hi = height; // TODO: make this bound smaller\n\n        if (!outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n          // if the label fits at the current sample point,\n          // perform binary search to find the largest font size that fits\n          while (hi - lo >= 1) {\n            mid = (lo + hi) / 2;\n\n            if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {\n              hi = mid;\n            } else {\n              lo = mid;\n            }\n          } // place label if current lower bound exceeds prior max font size\n\n\n          if (lo > maxSize) {\n            d.x = x;\n            d.y = y;\n            maxSize = lo;\n            labelPlaced = true;\n          }\n        }\n      } // place label at slice center if not placed through other means\n      // and if we're not avoiding overlap with other areas\n\n\n      if (!labelPlaced && !avoidBaseMark) {\n        // one span is zero, hence we can add\n        areaWidth = Math.abs(x2 - x1 + y2 - y1);\n        x = (x1 + x2) / 2;\n        y = (y1 + y2) / 2; // place label if it fits and improves the max area width\n\n        if (areaWidth >= maxAreaWidth && !outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n          maxAreaWidth = areaWidth;\n          d.x = x;\n          d.y = y;\n          labelPlaced2 = true;\n        }\n      }\n    } // record current label placement information, update label bitmap\n\n\n    if (labelPlaced || labelPlaced2) {\n      x = textWidth / 2;\n      y = textHeight / 2;\n      bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));\n      d.align = 'center';\n      d.baseline = 'middle';\n      return true;\n    } else {\n      return false;\n    }\n  };\n}\n\nconst Aligns = ['right', 'center', 'left'],\n      Baselines = ['bottom', 'middle', 'top'];\nfunction placeMarkLabel ($, bitmaps, anchors, offsets) {\n  const width = $.width,\n        height = $.height,\n        bm0 = bitmaps[0],\n        bm1 = bitmaps[1],\n        n = offsets.length;\n  return function (d) {\n    var _d$textWidth;\n\n    const boundary = d.boundary,\n          textHeight = d.datum.fontSize; // can not be placed if the mark is not visible in the graph bound\n\n    if (boundary[2] < 0 || boundary[5] < 0 || boundary[0] > width || boundary[3] > height) {\n      return false;\n    }\n\n    let textWidth = (_d$textWidth = d.textWidth) !== null && _d$textWidth !== void 0 ? _d$textWidth : 0,\n        dx,\n        dy,\n        isInside,\n        sizeFactor,\n        insideFactor,\n        x1,\n        x2,\n        y1,\n        y2,\n        xc,\n        yc,\n        _x1,\n        _x2,\n        _y1,\n        _y2; // for each anchor and offset\n\n\n    for (let i = 0; i < n; ++i) {\n      dx = (anchors[i] & 0x3) - 1;\n      dy = (anchors[i] >>> 0x2 & 0x3) - 1;\n      isInside = dx === 0 && dy === 0 || offsets[i] < 0;\n      sizeFactor = dx && dy ? Math.SQRT1_2 : 1;\n      insideFactor = offsets[i] < 0 ? -1 : 1;\n      x1 = boundary[1 + dx] + offsets[i] * dx * sizeFactor;\n      yc = boundary[4 + dy] + insideFactor * textHeight * dy / 2 + offsets[i] * dy * sizeFactor;\n      y1 = yc - textHeight / 2;\n      y2 = yc + textHeight / 2;\n      _x1 = $(x1);\n      _y1 = $(y1);\n      _y2 = $(y2);\n\n      if (!textWidth) {\n        // to avoid finding width of text label,\n        if (!test(_x1, _x1, _y1, _y2, bm0, bm1, x1, x1, y1, y2, boundary, isInside)) {\n          // skip this anchor/offset option if we fail to place a label with 1px width\n          continue;\n        } else {\n          // Otherwise, find the label width\n          textWidth = textMetrics.width(d.datum, d.datum.text);\n        }\n      }\n\n      xc = x1 + insideFactor * textWidth * dx / 2;\n      x1 = xc - textWidth / 2;\n      x2 = xc + textWidth / 2;\n      _x1 = $(x1);\n      _x2 = $(x2);\n\n      if (test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside)) {\n        // place label if the position is placeable\n        d.x = !dx ? xc : dx * insideFactor < 0 ? x2 : x1;\n        d.y = !dy ? yc : dy * insideFactor < 0 ? y2 : y1;\n        d.align = Aligns[dx * insideFactor + 1];\n        d.baseline = Baselines[dy * insideFactor + 1];\n        bm0.setRange(_x1, _y1, _x2, _y2);\n        return true;\n      }\n    }\n\n    return false;\n  };\n} // Test if a label with the given dimensions can be added without overlap\n\nfunction test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside) {\n  return !(bm0.outOfBounds(_x1, _y1, _x2, _y2) || (isInside && bm1 || bm0).getRange(_x1, _y1, _x2, _y2));\n}\n\nconst TOP = 0x0,\n      MIDDLE = 0x4,\n      BOTTOM = 0x8,\n      LEFT = 0x0,\n      CENTER = 0x1,\n      RIGHT = 0x2; // Mapping from text anchor to number representation\n\nconst anchorCode = {\n  'top-left': TOP + LEFT,\n  'top': TOP + CENTER,\n  'top-right': TOP + RIGHT,\n  'left': MIDDLE + LEFT,\n  'middle': MIDDLE + CENTER,\n  'right': MIDDLE + RIGHT,\n  'bottom-left': BOTTOM + LEFT,\n  'bottom': BOTTOM + CENTER,\n  'bottom-right': BOTTOM + RIGHT\n};\nconst placeAreaLabel = {\n  'naive': placeAreaLabelNaive,\n  'reduced-search': placeAreaLabelReducedSearch,\n  'floodfill': placeAreaLabelFloodFill\n};\nfunction labelLayout (texts, size, compare, offset, anchor, avoidMarks, avoidBaseMark, lineAnchor, markIndex, padding, method) {\n  // early exit for empty data\n  if (!texts.length) return texts;\n  const positions = Math.max(offset.length, anchor.length),\n        offsets = getOffsets(offset, positions),\n        anchors = getAnchors(anchor, positions),\n        marktype = markType(texts[0].datum),\n        grouptype = marktype === 'group' && texts[0].datum.items[markIndex].marktype,\n        isGroupArea = grouptype === 'area',\n        boundary = markBoundary(marktype, grouptype, lineAnchor, markIndex),\n        infPadding = padding === null || padding === Infinity,\n        isNaiveGroupArea = isGroupArea && method === 'naive';\n  let maxTextWidth = -1,\n      maxTextHeight = -1; // prepare text mark data for placing\n\n  const data = texts.map(d => {\n    const textWidth = infPadding ? textMetrics.width(d, d.text) : undefined;\n    maxTextWidth = Math.max(maxTextWidth, textWidth);\n    maxTextHeight = Math.max(maxTextHeight, d.fontSize);\n    return {\n      datum: d,\n      opacity: 0,\n      x: undefined,\n      y: undefined,\n      align: undefined,\n      baseline: undefined,\n      boundary: boundary(d),\n      textWidth\n    };\n  });\n  padding = padding === null || padding === Infinity ? Math.max(maxTextWidth, maxTextHeight) + Math.max(...offset) : padding;\n  const $ = scaler(size[0], size[1], padding);\n  let bitmaps;\n\n  if (!isNaiveGroupArea) {\n    // sort labels in priority order, if comparator is provided\n    if (compare) {\n      data.sort((a, b) => compare(a.datum, b.datum));\n    } // flag indicating if label can be placed inside its base mark\n\n\n    let labelInside = false;\n\n    for (let i = 0; i < anchors.length && !labelInside; ++i) {\n      // label inside if anchor is at center\n      // label inside if offset to be inside the mark bound\n      labelInside = anchors[i] === 0x5 || offsets[i] < 0;\n    } // extract data information from base mark when base mark is to be avoided\n    // base mark is implicitly avoided if it is a group area\n\n\n    const baseMark = (marktype && avoidBaseMark || isGroupArea) && texts.map(d => d.datum); // generate bitmaps for layout calculation\n\n    bitmaps = avoidMarks.length || baseMark ? markBitmaps($, baseMark || [], avoidMarks, labelInside, isGroupArea) : baseBitmaps($, avoidBaseMark && data);\n  } // generate label placement function\n\n\n  const place = isGroupArea ? placeAreaLabel[method]($, bitmaps, avoidBaseMark, markIndex) : placeMarkLabel($, bitmaps, anchors, offsets); // place all labels\n\n  data.forEach(d => d.opacity = +place(d));\n  return data;\n}\n\nfunction getOffsets(_, count) {\n  const offsets = new Float64Array(count),\n        n = _.length;\n\n  for (let i = 0; i < n; ++i) offsets[i] = _[i] || 0;\n\n  for (let i = n; i < count; ++i) offsets[i] = offsets[n - 1];\n\n  return offsets;\n}\n\nfunction getAnchors(_, count) {\n  const anchors = new Int8Array(count),\n        n = _.length;\n\n  for (let i = 0; i < n; ++i) anchors[i] |= anchorCode[_[i]];\n\n  for (let i = n; i < count; ++i) anchors[i] = anchors[n - 1];\n\n  return anchors;\n}\n\nfunction markType(item) {\n  return item && item.mark && item.mark.marktype;\n}\n/**\n * Factory function for function for getting base mark boundary, depending\n * on mark and group type. When mark type is undefined, line or area: boundary\n * is the coordinate of each data point. When base mark is grouped line,\n * boundary is either at the start or end of the line depending on the\n * value of lineAnchor. Otherwise, use bounds of base mark.\n */\n\n\nfunction markBoundary(marktype, grouptype, lineAnchor, markIndex) {\n  const xy = d => [d.x, d.x, d.x, d.y, d.y, d.y];\n\n  if (!marktype) {\n    return xy; // no reactive geometry\n  } else if (marktype === 'line' || marktype === 'area') {\n    return d => xy(d.datum);\n  } else if (grouptype === 'line') {\n    return d => {\n      const items = d.datum.items[markIndex].items;\n      return xy(items.length ? items[lineAnchor === 'start' ? 0 : items.length - 1] : {\n        x: NaN,\n        y: NaN\n      });\n    };\n  } else {\n    return d => {\n      const b = d.datum.bounds;\n      return [b.x1, (b.x1 + b.x2) / 2, b.x2, b.y1, (b.y1 + b.y2) / 2, b.y2];\n    };\n  }\n}\n\nconst Output = ['x', 'y', 'opacity', 'align', 'baseline'];\nconst Anchors = ['top-left', 'left', 'bottom-left', 'top', 'bottom', 'top-right', 'right', 'bottom-right'];\n/**\n * Compute text label layout to annotate marks.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The size of the layout, provided as a [width, height] array.\n * @param {function(*,*): number} [params.sort] - An optional\n *   comparator function for sorting label data in priority order.\n * @param {Array<string>} [params.anchor] - Label anchor points relative to the base mark bounding box.\n *   The available options are 'top-left', 'left', 'bottom-left', 'top',\n *   'bottom', 'top-right', 'right', 'bottom-right', 'middle'.\n * @param {Array<number>} [params.offset] - Label offsets (in pixels) from the base mark bounding box.\n *   This parameter is parallel to the list of anchor points.\n * @param {number | null} [params.padding=0] - The amount (in pixels) that a label may exceed the layout size.\n *   If this parameter is null, a label may exceed the layout size without any boundary.\n * @param {string} [params.lineAnchor='end'] - For group line mark labels only, indicates the anchor\n *   position for labels. One of 'start' or 'end'.\n * @param {string} [params.markIndex=0] - For group mark labels only, an index indicating\n *   which mark within the group should be labeled.\n * @param {Array<number>} [params.avoidMarks] - A list of additional mark names for which the label\n *   layout should avoid overlap.\n * @param {boolean} [params.avoidBaseMark=true] - Boolean flag indicating if labels should avoid\n *   overlap with the underlying base mark being labeled.\n * @param {string} [params.method='naive'] - For area make labels only, a method for\n *   place labels. One of 'naive', 'reduced-search', or 'floodfill'.\n * @param {Array<string>} [params.as] - The output fields written by the transform.\n *   The default is ['x', 'y', 'opacity', 'align', 'baseline'].\n */\n\nfunction Label(params) {\n  Transform.call(this, null, params);\n}\nLabel.Definition = {\n  type: 'Label',\n  metadata: {\n    modifies: true\n  },\n  params: [{\n    name: 'size',\n    type: 'number',\n    array: true,\n    length: 2,\n    required: true\n  }, {\n    name: 'sort',\n    type: 'compare'\n  }, {\n    name: 'anchor',\n    type: 'string',\n    array: true,\n    default: Anchors\n  }, {\n    name: 'offset',\n    type: 'number',\n    array: true,\n    default: [1]\n  }, {\n    name: 'padding',\n    type: 'number',\n    default: 0,\n    null: true\n  }, {\n    name: 'lineAnchor',\n    type: 'string',\n    values: ['start', 'end'],\n    default: 'end'\n  }, {\n    name: 'markIndex',\n    type: 'number',\n    default: 0\n  }, {\n    name: 'avoidBaseMark',\n    type: 'boolean',\n    default: true\n  }, {\n    name: 'avoidMarks',\n    type: 'data',\n    array: true\n  }, {\n    name: 'method',\n    type: 'string',\n    default: 'naive'\n  }, {\n    name: 'as',\n    type: 'string',\n    array: true,\n    length: Output.length,\n    default: Output\n  }]\n};\ninherits(Label, Transform, {\n  transform(_, pulse) {\n    function modp(param) {\n      const p = _[param];\n      return isFunction(p) && pulse.modified(p.fields);\n    }\n\n    const mod = _.modified();\n\n    if (!(mod || pulse.changed(pulse.ADD_REM) || modp('sort'))) return;\n\n    if (!_.size || _.size.length !== 2) {\n      error('Size parameter should be specified as a [width, height] array.');\n    }\n\n    const as = _.as || Output; // run label layout\n\n    labelLayout(pulse.materialize(pulse.SOURCE).source || [], _.size, _.sort, array(_.offset == null ? 1 : _.offset), array(_.anchor || Anchors), _.avoidMarks || [], _.avoidBaseMark !== false, _.lineAnchor || 'end', _.markIndex || 0, _.padding === undefined ? 0 : _.padding, _.method || 'naive').forEach(l => {\n      // write layout results to data stream\n      const t = l.datum;\n      t[as[0]] = l.x;\n      t[as[1]] = l.y;\n      t[as[2]] = l.opacity;\n      t[as[3]] = l.align;\n      t[as[4]] = l.baseline;\n    });\n    return pulse.reflow(mod).modifies(as);\n  }\n\n});\n\nexport { Label as label };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}