{"ast":null,"code":"import _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { array, isArray, stringValue } from 'vega-util';\nimport { vgField } from '../channeldef';\nimport { isExprRef } from '../expr';\nimport { isText } from '../title';\nimport { deepEqual, getFirstDefined } from '../util';\nimport { isSignalRef } from '../vega.schema';\nexport var BIN_RANGE_DELIMITER = \" \\u2013 \";\nexport function signalOrValueRefWithCondition(val) {\n  var condition = isArray(val.condition) ? val.condition.map(conditionalSignalRefOrValue) : conditionalSignalRefOrValue(val.condition);\n  return Object.assign(Object.assign({}, signalRefOrValue(val)), {\n    condition: condition\n  });\n}\nexport function signalRefOrValue(value) {\n  if (isExprRef(value)) {\n    var expr = value.expr,\n      rest = __rest(value, [\"expr\"]);\n    return Object.assign({\n      signal: expr\n    }, rest);\n  }\n  return value;\n}\nexport function conditionalSignalRefOrValue(value) {\n  if (isExprRef(value)) {\n    var expr = value.expr,\n      rest = __rest(value, [\"expr\"]);\n    return Object.assign({\n      signal: expr\n    }, rest);\n  }\n  return value;\n}\nexport function signalOrValueRef(value) {\n  if (isExprRef(value)) {\n    var expr = value.expr,\n      rest = __rest(value, [\"expr\"]);\n    return Object.assign({\n      signal: expr\n    }, rest);\n  }\n  if (isSignalRef(value)) {\n    return value;\n  }\n  return value !== undefined ? {\n    value: value\n  } : undefined;\n}\nexport function exprFromSignalRefOrValue(ref) {\n  if (isSignalRef(ref)) {\n    return ref.signal;\n  }\n  return stringValue(ref);\n}\nexport function exprFromValueRefOrSignalRef(ref) {\n  if (isSignalRef(ref)) {\n    return ref.signal;\n  }\n  return stringValue(ref.value);\n}\nexport function signalOrStringValue(v) {\n  if (isSignalRef(v)) {\n    return v.signal;\n  }\n  return v == null ? null : stringValue(v);\n}\nexport function applyMarkConfig(e, model, propsList) {\n  var _iterator = _createForOfIteratorHelper(propsList),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var property = _step.value;\n      var value = getMarkConfig(property, model.markDef, model.config);\n      if (value !== undefined) {\n        e[property] = signalOrValueRef(value);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return e;\n}\nexport function getStyles(mark) {\n  var _a;\n  return [].concat(mark.type, (_a = mark.style) !== null && _a !== void 0 ? _a : []);\n}\nexport function getMarkPropOrConfig(channel, mark, config) {\n  var opt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var vgChannel = opt.vgChannel,\n    ignoreVgConfig = opt.ignoreVgConfig;\n  if (vgChannel && mark[vgChannel] !== undefined) {\n    return mark[vgChannel];\n  } else if (mark[channel] !== undefined) {\n    return mark[channel];\n  } else if (ignoreVgConfig && (!vgChannel || vgChannel === channel)) {\n    return undefined;\n  }\n  return getMarkConfig(channel, mark, config, opt);\n}\n/**\n * Return property value from style or mark specific config property if exists.\n * Otherwise, return general mark specific config.\n */\nexport function getMarkConfig(channel, mark, config) {\n  var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n    vgChannel = _ref.vgChannel;\n  return getFirstDefined(\n  // style config has highest precedence\n  vgChannel ? getMarkStyleConfig(channel, mark, config.style) : undefined, getMarkStyleConfig(channel, mark, config.style),\n  // then mark-specific config\n  vgChannel ? config[mark.type][vgChannel] : undefined, config[mark.type][channel],\n  // Need to cast because MarkDef doesn't perfectly match with AnyMarkConfig, but if the type isn't available, we'll get nothing here, which is fine\n  // If there is vgChannel, skip vl channel.\n  // For example, vl size for text is vg fontSize, but config.mark.size is only for point size.\n  vgChannel ? config.mark[vgChannel] : config.mark[channel] // Need to cast for the same reason as above\n  );\n}\n\nexport function getMarkStyleConfig(prop, mark, styleConfigIndex) {\n  return getStyleConfig(prop, getStyles(mark), styleConfigIndex);\n}\nexport function getStyleConfig(p, styles, styleConfigIndex) {\n  styles = array(styles);\n  var value;\n  var _iterator2 = _createForOfIteratorHelper(styles),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var style = _step2.value;\n      var styleConfig = styleConfigIndex[style];\n      if (styleConfig && styleConfig[p] !== undefined) {\n        value = styleConfig[p];\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return value;\n}\n/**\n * Return Vega sort parameters (tuple of field and order).\n */\nexport function sortParams(orderDef, fieldRefOption) {\n  return array(orderDef).reduce(function (s, orderChannelDef) {\n    var _a;\n    s.field.push(vgField(orderChannelDef, fieldRefOption));\n    s.order.push((_a = orderChannelDef.sort) !== null && _a !== void 0 ? _a : 'ascending');\n    return s;\n  }, {\n    field: [],\n    order: []\n  });\n}\nexport function mergeTitleFieldDefs(f1, f2) {\n  var merged = _toConsumableArray(f1);\n  f2.forEach(function (fdToMerge) {\n    var _iterator3 = _createForOfIteratorHelper(merged),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var fieldDef1 = _step3.value;\n        // If already exists, no need to append to merged array\n        if (deepEqual(fieldDef1, fdToMerge)) {\n          return;\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    merged.push(fdToMerge);\n  });\n  return merged;\n}\nexport function mergeTitle(title1, title2) {\n  if (deepEqual(title1, title2) || !title2) {\n    // if titles are the same or title2 is falsy\n    return title1;\n  } else if (!title1) {\n    // if title1 is falsy\n    return title2;\n  } else {\n    return [].concat(_toConsumableArray(array(title1)), _toConsumableArray(array(title2))).join(', ');\n  }\n}\nexport function mergeTitleComponent(v1, v2) {\n  var v1Val = v1.value;\n  var v2Val = v2.value;\n  if (v1Val == null || v2Val === null) {\n    return {\n      explicit: v1.explicit,\n      value: null\n    };\n  } else if ((isText(v1Val) || isSignalRef(v1Val)) && (isText(v2Val) || isSignalRef(v2Val))) {\n    return {\n      explicit: v1.explicit,\n      value: mergeTitle(v1Val, v2Val)\n    };\n  } else if (isText(v1Val) || isSignalRef(v1Val)) {\n    return {\n      explicit: v1.explicit,\n      value: v1Val\n    };\n  } else if (isText(v2Val) || isSignalRef(v2Val)) {\n    return {\n      explicit: v1.explicit,\n      value: v2Val\n    };\n  } else if (!isText(v1Val) && !isSignalRef(v1Val) && !isText(v2Val) && !isSignalRef(v2Val)) {\n    return {\n      explicit: v1.explicit,\n      value: mergeTitleFieldDefs(v1Val, v2Val)\n    };\n  }\n  /* istanbul ignore next: Condition should not happen -- only for warning in development. */\n  throw new Error('It should never reach here');\n}","map":{"version":3,"sources":["../../../src/compile/common.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { array, isArray, stringValue } from 'vega-util';\nimport { vgField } from '../channeldef';\nimport { isExprRef } from '../expr';\nimport { isText } from '../title';\nimport { deepEqual, getFirstDefined } from '../util';\nimport { isSignalRef } from '../vega.schema';\nexport const BIN_RANGE_DELIMITER = ' \\u2013 ';\nexport function signalOrValueRefWithCondition(val) {\n    const condition = isArray(val.condition)\n        ? val.condition.map(conditionalSignalRefOrValue)\n        : conditionalSignalRefOrValue(val.condition);\n    return Object.assign(Object.assign({}, signalRefOrValue(val)), { condition });\n}\nexport function signalRefOrValue(value) {\n    if (isExprRef(value)) {\n        const { expr } = value, rest = __rest(value, [\"expr\"]);\n        return Object.assign({ signal: expr }, rest);\n    }\n    return value;\n}\nexport function conditionalSignalRefOrValue(value) {\n    if (isExprRef(value)) {\n        const { expr } = value, rest = __rest(value, [\"expr\"]);\n        return Object.assign({ signal: expr }, rest);\n    }\n    return value;\n}\nexport function signalOrValueRef(value) {\n    if (isExprRef(value)) {\n        const { expr } = value, rest = __rest(value, [\"expr\"]);\n        return Object.assign({ signal: expr }, rest);\n    }\n    if (isSignalRef(value)) {\n        return value;\n    }\n    return value !== undefined ? { value } : undefined;\n}\nexport function exprFromSignalRefOrValue(ref) {\n    if (isSignalRef(ref)) {\n        return ref.signal;\n    }\n    return stringValue(ref);\n}\nexport function exprFromValueRefOrSignalRef(ref) {\n    if (isSignalRef(ref)) {\n        return ref.signal;\n    }\n    return stringValue(ref.value);\n}\nexport function signalOrStringValue(v) {\n    if (isSignalRef(v)) {\n        return v.signal;\n    }\n    return v == null ? null : stringValue(v);\n}\nexport function applyMarkConfig(e, model, propsList) {\n    for (const property of propsList) {\n        const value = getMarkConfig(property, model.markDef, model.config);\n        if (value !== undefined) {\n            e[property] = signalOrValueRef(value);\n        }\n    }\n    return e;\n}\nexport function getStyles(mark) {\n    var _a;\n    return [].concat(mark.type, (_a = mark.style) !== null && _a !== void 0 ? _a : []);\n}\nexport function getMarkPropOrConfig(channel, mark, config, opt = {}) {\n    const { vgChannel, ignoreVgConfig } = opt;\n    if (vgChannel && mark[vgChannel] !== undefined) {\n        return mark[vgChannel];\n    }\n    else if (mark[channel] !== undefined) {\n        return mark[channel];\n    }\n    else if (ignoreVgConfig && (!vgChannel || vgChannel === channel)) {\n        return undefined;\n    }\n    return getMarkConfig(channel, mark, config, opt);\n}\n/**\n * Return property value from style or mark specific config property if exists.\n * Otherwise, return general mark specific config.\n */\nexport function getMarkConfig(channel, mark, config, { vgChannel } = {}) {\n    return getFirstDefined(\n    // style config has highest precedence\n    vgChannel ? getMarkStyleConfig(channel, mark, config.style) : undefined, getMarkStyleConfig(channel, mark, config.style), \n    // then mark-specific config\n    vgChannel ? config[mark.type][vgChannel] : undefined, config[mark.type][channel], // Need to cast because MarkDef doesn't perfectly match with AnyMarkConfig, but if the type isn't available, we'll get nothing here, which is fine\n    // If there is vgChannel, skip vl channel.\n    // For example, vl size for text is vg fontSize, but config.mark.size is only for point size.\n    vgChannel ? config.mark[vgChannel] : config.mark[channel] // Need to cast for the same reason as above\n    );\n}\nexport function getMarkStyleConfig(prop, mark, styleConfigIndex) {\n    return getStyleConfig(prop, getStyles(mark), styleConfigIndex);\n}\nexport function getStyleConfig(p, styles, styleConfigIndex) {\n    styles = array(styles);\n    let value;\n    for (const style of styles) {\n        const styleConfig = styleConfigIndex[style];\n        if (styleConfig && styleConfig[p] !== undefined) {\n            value = styleConfig[p];\n        }\n    }\n    return value;\n}\n/**\n * Return Vega sort parameters (tuple of field and order).\n */\nexport function sortParams(orderDef, fieldRefOption) {\n    return array(orderDef).reduce((s, orderChannelDef) => {\n        var _a;\n        s.field.push(vgField(orderChannelDef, fieldRefOption));\n        s.order.push((_a = orderChannelDef.sort) !== null && _a !== void 0 ? _a : 'ascending');\n        return s;\n    }, { field: [], order: [] });\n}\nexport function mergeTitleFieldDefs(f1, f2) {\n    const merged = [...f1];\n    f2.forEach(fdToMerge => {\n        for (const fieldDef1 of merged) {\n            // If already exists, no need to append to merged array\n            if (deepEqual(fieldDef1, fdToMerge)) {\n                return;\n            }\n        }\n        merged.push(fdToMerge);\n    });\n    return merged;\n}\nexport function mergeTitle(title1, title2) {\n    if (deepEqual(title1, title2) || !title2) {\n        // if titles are the same or title2 is falsy\n        return title1;\n    }\n    else if (!title1) {\n        // if title1 is falsy\n        return title2;\n    }\n    else {\n        return [...array(title1), ...array(title2)].join(', ');\n    }\n}\nexport function mergeTitleComponent(v1, v2) {\n    const v1Val = v1.value;\n    const v2Val = v2.value;\n    if (v1Val == null || v2Val === null) {\n        return {\n            explicit: v1.explicit,\n            value: null\n        };\n    }\n    else if ((isText(v1Val) || isSignalRef(v1Val)) && (isText(v2Val) || isSignalRef(v2Val))) {\n        return {\n            explicit: v1.explicit,\n            value: mergeTitle(v1Val, v2Val)\n        };\n    }\n    else if (isText(v1Val) || isSignalRef(v1Val)) {\n        return {\n            explicit: v1.explicit,\n            value: v1Val\n        };\n    }\n    else if (isText(v2Val) || isSignalRef(v2Val)) {\n        return {\n            explicit: v1.explicit,\n            value: v2Val\n        };\n    }\n    else if (!isText(v1Val) && !isSignalRef(v1Val) && !isText(v2Val) && !isSignalRef(v2Val)) {\n        return {\n            explicit: v1.explicit,\n            value: mergeTitleFieldDefs(v1Val, v2Val)\n        };\n    }\n    /* istanbul ignore next: Condition should not happen -- only for warning in development. */\n    throw new Error('It should never reach here');\n}\n//# sourceMappingURL=common.js.map"]},"metadata":{},"sourceType":"module"}