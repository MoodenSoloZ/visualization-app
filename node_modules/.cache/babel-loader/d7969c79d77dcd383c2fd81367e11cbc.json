{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { isArray } from 'vega-util';\nimport { isBinning } from '../bin';\nimport { COLUMN, FACET_CHANNELS, POSITION_SCALE_CHANNELS, ROW } from '../channel';\nimport { initFieldDef, vgField } from '../channeldef';\nimport { replaceExprRef } from '../expr';\nimport * as log from '../log';\nimport { hasDiscreteDomain } from '../scale';\nimport { DEFAULT_SORT_OP, isSortField } from '../sort';\nimport { isFacetMapping } from '../spec/facet';\nimport { keys } from '../util';\nimport { isVgRangeStep } from '../vega.schema';\nimport { buildModel } from './buildmodel';\nimport { assembleFacetData } from './data/assemble';\nimport { sortArrayIndexField } from './data/calculate';\nimport { parseData as _parseData } from './data/parse';\nimport { assembleLabelTitle as _assembleLabelTitle } from './header/assemble';\nimport { getHeaderChannel, getHeaderProperty } from './header/common';\nimport { HEADER_CHANNELS, HEADER_TYPES } from './header/component';\nimport { parseFacetHeaders } from './header/parse';\nimport { parseChildrenLayoutSize } from './layoutsize/parse';\nimport { ModelWithField } from './model';\nimport { assembleDomain, getFieldFromDomain } from './scale/domain';\nimport { assembleFacetSignals } from './selection/assemble';\nexport function facetSortFieldName(fieldDef, sort, opt) {\n  return vgField(sort, Object.assign({\n    suffix: \"by_\".concat(vgField(fieldDef))\n  }, opt !== null && opt !== void 0 ? opt : {}));\n}\nexport var FacetModel = /*#__PURE__*/function (_ModelWithField) {\n  _inherits(FacetModel, _ModelWithField);\n  var _super = _createSuper(FacetModel);\n  function FacetModel(spec, parent, parentGivenName, config) {\n    var _this;\n    _classCallCheck(this, FacetModel);\n    _this = _super.call(this, spec, 'facet', parent, parentGivenName, config, spec.resolve);\n    _this.child = buildModel(spec.spec, _assertThisInitialized(_this), _this.getName('child'), undefined, config);\n    _this.children = [_this.child];\n    _this.facet = _this.initFacet(spec.facet);\n    return _this;\n  }\n  _createClass(FacetModel, [{\n    key: \"initFacet\",\n    value: function initFacet(facet) {\n      // clone to prevent side effect to the original spec\n      if (!isFacetMapping(facet)) {\n        return {\n          facet: this.initFacetFieldDef(facet, 'facet')\n        };\n      }\n      var channels = keys(facet);\n      var normalizedFacet = {};\n      var _iterator = _createForOfIteratorHelper(channels),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var channel = _step.value;\n          if (![ROW, COLUMN].includes(channel)) {\n            // Drop unsupported channel\n            log.warn(log.message.incompatibleChannel(channel, 'facet'));\n            break;\n          }\n          var fieldDef = facet[channel];\n          if (fieldDef.field === undefined) {\n            log.warn(log.message.emptyFieldDef(fieldDef, channel));\n            break;\n          }\n          normalizedFacet[channel] = this.initFacetFieldDef(fieldDef, channel);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return normalizedFacet;\n    }\n  }, {\n    key: \"initFacetFieldDef\",\n    value: function initFacetFieldDef(fieldDef, channel) {\n      // Cast because we call initFieldDef, which assumes general FieldDef.\n      // However, FacetFieldDef is a bit more constrained than the general FieldDef\n      var facetFieldDef = initFieldDef(fieldDef, channel);\n      if (facetFieldDef.header) {\n        facetFieldDef.header = replaceExprRef(facetFieldDef.header);\n      } else if (facetFieldDef.header === null) {\n        facetFieldDef.header = null;\n      }\n      return facetFieldDef;\n    }\n  }, {\n    key: \"channelHasField\",\n    value: function channelHasField(channel) {\n      return !!this.facet[channel];\n    }\n  }, {\n    key: \"fieldDef\",\n    value: function fieldDef(channel) {\n      return this.facet[channel];\n    }\n  }, {\n    key: \"parseData\",\n    value: function parseData() {\n      this.component.data = _parseData(this);\n      this.child.parseData();\n    }\n  }, {\n    key: \"parseLayoutSize\",\n    value: function parseLayoutSize() {\n      parseChildrenLayoutSize(this);\n    }\n  }, {\n    key: \"parseSelections\",\n    value: function parseSelections() {\n      // As a facet has a single child, the selection components are the same.\n      // The child maintains its selections to assemble signals, which remain\n      // within its unit.\n      this.child.parseSelections();\n      this.component.selection = this.child.component.selection;\n    }\n  }, {\n    key: \"parseMarkGroup\",\n    value: function parseMarkGroup() {\n      this.child.parseMarkGroup();\n    }\n  }, {\n    key: \"parseAxesAndHeaders\",\n    value: function parseAxesAndHeaders() {\n      this.child.parseAxesAndHeaders();\n      parseFacetHeaders(this);\n    }\n  }, {\n    key: \"assembleSelectionTopLevelSignals\",\n    value: function assembleSelectionTopLevelSignals(signals) {\n      return this.child.assembleSelectionTopLevelSignals(signals);\n    }\n  }, {\n    key: \"assembleSignals\",\n    value: function assembleSignals() {\n      this.child.assembleSignals();\n      return [];\n    }\n  }, {\n    key: \"assembleSelectionData\",\n    value: function assembleSelectionData(data) {\n      return this.child.assembleSelectionData(data);\n    }\n  }, {\n    key: \"getHeaderLayoutMixins\",\n    value: function getHeaderLayoutMixins() {\n      var _a, _b, _c;\n      var layoutMixins = {};\n      var _iterator2 = _createForOfIteratorHelper(FACET_CHANNELS),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var channel = _step2.value;\n          var _iterator3 = _createForOfIteratorHelper(HEADER_TYPES),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var headerType = _step3.value;\n              var layoutHeaderComponent = this.component.layoutHeaders[channel];\n              var headerComponent = layoutHeaderComponent[headerType];\n              var facetFieldDef = layoutHeaderComponent.facetFieldDef;\n              if (facetFieldDef) {\n                var titleOrient = getHeaderProperty('titleOrient', facetFieldDef.header, this.config, channel);\n                if (['right', 'bottom'].includes(titleOrient)) {\n                  var headerChannel = getHeaderChannel(channel, titleOrient);\n                  (_a = layoutMixins.titleAnchor) !== null && _a !== void 0 ? _a : layoutMixins.titleAnchor = {};\n                  layoutMixins.titleAnchor[headerChannel] = 'end';\n                }\n              }\n              if (headerComponent === null || headerComponent === void 0 ? void 0 : headerComponent[0]) {\n                // set header/footerBand\n                var sizeType = channel === 'row' ? 'height' : 'width';\n                var bandType = headerType === 'header' ? 'headerBand' : 'footerBand';\n                if (channel !== 'facet' && !this.child.component.layoutSize.get(sizeType)) {\n                  // If facet child does not have size signal, then apply headerBand\n                  (_b = layoutMixins[bandType]) !== null && _b !== void 0 ? _b : layoutMixins[bandType] = {};\n                  layoutMixins[bandType][channel] = 0.5;\n                }\n                if (layoutHeaderComponent.title) {\n                  (_c = layoutMixins.offset) !== null && _c !== void 0 ? _c : layoutMixins.offset = {};\n                  layoutMixins.offset[channel === 'row' ? 'rowTitle' : 'columnTitle'] = 10;\n                }\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return layoutMixins;\n    }\n  }, {\n    key: \"assembleDefaultLayout\",\n    value: function assembleDefaultLayout() {\n      var _this$facet = this.facet,\n        column = _this$facet.column,\n        row = _this$facet.row;\n      var columns = column ? this.columnDistinctSignal() : row ? 1 : undefined;\n      var align = 'all';\n      // Do not align the cells if the scale corresponding to the direction is indepent.\n      // We always align when we facet into both row and column.\n      if (!row && this.component.resolve.scale.x === 'independent') {\n        align = 'none';\n      } else if (!column && this.component.resolve.scale.y === 'independent') {\n        align = 'none';\n      }\n      return Object.assign(Object.assign(Object.assign({}, this.getHeaderLayoutMixins()), columns ? {\n        columns: columns\n      } : {}), {\n        bounds: 'full',\n        align: align\n      });\n    }\n  }, {\n    key: \"assembleLayoutSignals\",\n    value: function assembleLayoutSignals() {\n      // FIXME(https://github.com/vega/vega-lite/issues/1193): this can be incorrect if we have independent scales.\n      return this.child.assembleLayoutSignals();\n    }\n  }, {\n    key: \"columnDistinctSignal\",\n    value: function columnDistinctSignal() {\n      if (this.parent && this.parent instanceof FacetModel) {\n        // For nested facet, we will add columns to group mark instead\n        // See discussion in https://github.com/vega/vega/issues/952\n        // and https://github.com/vega/vega-view/releases/tag/v1.2.6\n        return undefined;\n      } else {\n        // In facetNode.assemble(), the name is always this.getName('column') + '_layout'.\n        var facetLayoutDataName = this.getName('column_domain');\n        return {\n          signal: \"length(data('\".concat(facetLayoutDataName, \"'))\")\n        };\n      }\n    }\n  }, {\n    key: \"assembleGroupStyle\",\n    value: function assembleGroupStyle() {\n      return undefined;\n    }\n  }, {\n    key: \"assembleGroup\",\n    value: function assembleGroup(signals) {\n      if (this.parent && this.parent instanceof FacetModel) {\n        // Provide number of columns for layout.\n        // See discussion in https://github.com/vega/vega/issues/952\n        // and https://github.com/vega/vega-view/releases/tag/v1.2.6\n        return Object.assign(Object.assign({}, this.channelHasField('column') ? {\n          encode: {\n            update: {\n              // TODO(https://github.com/vega/vega-lite/issues/2759):\n              // Correct the signal for facet of concat of facet_column\n              columns: {\n                field: vgField(this.facet.column, {\n                  prefix: 'distinct'\n                })\n              }\n            }\n          }\n        } : {}), _get(_getPrototypeOf(FacetModel.prototype), \"assembleGroup\", this).call(this, signals));\n      }\n      return _get(_getPrototypeOf(FacetModel.prototype), \"assembleGroup\", this).call(this, signals);\n    }\n    /**\n     * Aggregate cardinality for calculating size\n     */\n  }, {\n    key: \"getCardinalityAggregateForChild\",\n    value: function getCardinalityAggregateForChild() {\n      var fields = [];\n      var ops = [];\n      var as = [];\n      if (this.child instanceof FacetModel) {\n        if (this.child.channelHasField('column')) {\n          var field = vgField(this.child.facet.column);\n          fields.push(field);\n          ops.push('distinct');\n          as.push(\"distinct_\".concat(field));\n        }\n      } else {\n        var _iterator4 = _createForOfIteratorHelper(POSITION_SCALE_CHANNELS),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var channel = _step4.value;\n            var childScaleComponent = this.child.component.scales[channel];\n            if (childScaleComponent && !childScaleComponent.merged) {\n              var type = childScaleComponent.get('type');\n              var range = childScaleComponent.get('range');\n              if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n                var domain = assembleDomain(this.child, channel);\n                var _field = getFieldFromDomain(domain);\n                if (_field) {\n                  fields.push(_field);\n                  ops.push('distinct');\n                  as.push(\"distinct_\".concat(_field));\n                } else {\n                  log.warn(log.message.unknownField(channel));\n                }\n              }\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n      return {\n        fields: fields,\n        ops: ops,\n        as: as\n      };\n    }\n  }, {\n    key: \"assembleFacet\",\n    value: function assembleFacet() {\n      var _this$component$data$ = this.component.data.facetRoot,\n        name = _this$component$data$.name,\n        data = _this$component$data$.data;\n      var _this$facet2 = this.facet,\n        row = _this$facet2.row,\n        column = _this$facet2.column;\n      var _this$getCardinalityA = this.getCardinalityAggregateForChild(),\n        fields = _this$getCardinalityA.fields,\n        ops = _this$getCardinalityA.ops,\n        as = _this$getCardinalityA.as;\n      var groupby = [];\n      var _iterator5 = _createForOfIteratorHelper(FACET_CHANNELS),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var channel = _step5.value;\n          var fieldDef = this.facet[channel];\n          if (fieldDef) {\n            groupby.push(vgField(fieldDef));\n            var bin = fieldDef.bin,\n              sort = fieldDef.sort;\n            if (isBinning(bin)) {\n              groupby.push(vgField(fieldDef, {\n                binSuffix: 'end'\n              }));\n            }\n            if (isSortField(sort)) {\n              var field = sort.field,\n                _sort$op = sort.op,\n                op = _sort$op === void 0 ? DEFAULT_SORT_OP : _sort$op;\n              var outputName = facetSortFieldName(fieldDef, sort);\n              if (row && column) {\n                // For crossed facet, use pre-calculate field as it requires a different groupby\n                // For each calculated field, apply max and assign them to the same name as\n                // all values of the same group should be the same anyway.\n                fields.push(outputName);\n                ops.push('max');\n                as.push(outputName);\n              } else {\n                fields.push(field);\n                ops.push(op);\n                as.push(outputName);\n              }\n            } else if (isArray(sort)) {\n              var _outputName = sortArrayIndexField(fieldDef, channel);\n              fields.push(_outputName);\n              ops.push('max');\n              as.push(_outputName);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      var cross = !!row && !!column;\n      return Object.assign({\n        name: name,\n        data: data,\n        groupby: groupby\n      }, cross || fields.length > 0 ? {\n        aggregate: Object.assign(Object.assign({}, cross ? {\n          cross: cross\n        } : {}), fields.length ? {\n          fields: fields,\n          ops: ops,\n          as: as\n        } : {})\n      } : {});\n    }\n  }, {\n    key: \"facetSortFields\",\n    value: function facetSortFields(channel) {\n      var facet = this.facet;\n      var fieldDef = facet[channel];\n      if (fieldDef) {\n        if (isSortField(fieldDef.sort)) {\n          return [facetSortFieldName(fieldDef, fieldDef.sort, {\n            expr: 'datum'\n          })];\n        } else if (isArray(fieldDef.sort)) {\n          return [sortArrayIndexField(fieldDef, channel, {\n            expr: 'datum'\n          })];\n        }\n        return [vgField(fieldDef, {\n          expr: 'datum'\n        })];\n      }\n      return [];\n    }\n  }, {\n    key: \"facetSortOrder\",\n    value: function facetSortOrder(channel) {\n      var facet = this.facet;\n      var fieldDef = facet[channel];\n      if (fieldDef) {\n        var sort = fieldDef.sort;\n        var order = (isSortField(sort) ? sort.order : !isArray(sort) && sort) || 'ascending';\n        return [order];\n      }\n      return [];\n    }\n  }, {\n    key: \"assembleLabelTitle\",\n    value: function assembleLabelTitle() {\n      var _a;\n      var facet = this.facet,\n        config = this.config;\n      if (facet.facet) {\n        // Facet always uses title to display labels\n        return _assembleLabelTitle(facet.facet, 'facet', config);\n      }\n      var ORTHOGONAL_ORIENT = {\n        row: ['top', 'bottom'],\n        column: ['left', 'right']\n      };\n      var _iterator6 = _createForOfIteratorHelper(HEADER_CHANNELS),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var channel = _step6.value;\n          if (facet[channel]) {\n            var labelOrient = getHeaderProperty('labelOrient', (_a = facet[channel]) === null || _a === void 0 ? void 0 : _a.header, config, channel);\n            if (ORTHOGONAL_ORIENT[channel].includes(labelOrient)) {\n              // Row/Column with orthogonal labelOrient must use title to display labels\n              return _assembleLabelTitle(facet[channel], channel, config);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      return undefined;\n    }\n  }, {\n    key: \"assembleMarks\",\n    value: function assembleMarks() {\n      var _this2 = this;\n      var child = this.child;\n      // If we facet by two dimensions, we need to add a cross operator to the aggregation\n      // so that we create all groups\n      var facetRoot = this.component.data.facetRoot;\n      var data = assembleFacetData(facetRoot);\n      var encodeEntry = child.assembleGroupEncodeEntry(false);\n      var title = this.assembleLabelTitle() || child.assembleTitle();\n      var style = child.assembleGroupStyle();\n      var markGroup = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n        name: this.getName('cell'),\n        type: 'group'\n      }, title ? {\n        title: title\n      } : {}), style ? {\n        style: style\n      } : {}), {\n        from: {\n          facet: this.assembleFacet()\n        },\n        // TODO: move this to after data\n        sort: {\n          field: FACET_CHANNELS.map(function (c) {\n            return _this2.facetSortFields(c);\n          }).flat(),\n          order: FACET_CHANNELS.map(function (c) {\n            return _this2.facetSortOrder(c);\n          }).flat()\n        }\n      }), data.length > 0 ? {\n        data: data\n      } : {}), encodeEntry ? {\n        encode: {\n          update: encodeEntry\n        }\n      } : {}), child.assembleGroup(assembleFacetSignals(this, [])));\n      return [markGroup];\n    }\n  }, {\n    key: \"getMapping\",\n    value: function getMapping() {\n      return this.facet;\n    }\n  }]);\n  return FacetModel;\n}(ModelWithField);","map":{"version":3,"sources":["../../../src/compile/facet.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray } from 'vega-util';\nimport { isBinning } from '../bin';\nimport { COLUMN, FACET_CHANNELS, POSITION_SCALE_CHANNELS, ROW } from '../channel';\nimport { initFieldDef, vgField } from '../channeldef';\nimport { replaceExprRef } from '../expr';\nimport * as log from '../log';\nimport { hasDiscreteDomain } from '../scale';\nimport { DEFAULT_SORT_OP, isSortField } from '../sort';\nimport { isFacetMapping } from '../spec/facet';\nimport { keys } from '../util';\nimport { isVgRangeStep } from '../vega.schema';\nimport { buildModel } from './buildmodel';\nimport { assembleFacetData } from './data/assemble';\nimport { sortArrayIndexField } from './data/calculate';\nimport { parseData } from './data/parse';\nimport { assembleLabelTitle } from './header/assemble';\nimport { getHeaderChannel, getHeaderProperty } from './header/common';\nimport { HEADER_CHANNELS, HEADER_TYPES } from './header/component';\nimport { parseFacetHeaders } from './header/parse';\nimport { parseChildrenLayoutSize } from './layoutsize/parse';\nimport { ModelWithField } from './model';\nimport { assembleDomain, getFieldFromDomain } from './scale/domain';\nimport { assembleFacetSignals } from './selection/assemble';\nexport function facetSortFieldName(fieldDef, sort, opt) {\n    return vgField(sort, Object.assign({ suffix: `by_${vgField(fieldDef)}` }, (opt !== null && opt !== void 0 ? opt : {})));\n}\nexport class FacetModel extends ModelWithField {\n    constructor(spec, parent, parentGivenName, config) {\n        super(spec, 'facet', parent, parentGivenName, config, spec.resolve);\n        this.child = buildModel(spec.spec, this, this.getName('child'), undefined, config);\n        this.children = [this.child];\n        this.facet = this.initFacet(spec.facet);\n    }\n    initFacet(facet) {\n        // clone to prevent side effect to the original spec\n        if (!isFacetMapping(facet)) {\n            return { facet: this.initFacetFieldDef(facet, 'facet') };\n        }\n        const channels = keys(facet);\n        const normalizedFacet = {};\n        for (const channel of channels) {\n            if (![ROW, COLUMN].includes(channel)) {\n                // Drop unsupported channel\n                log.warn(log.message.incompatibleChannel(channel, 'facet'));\n                break;\n            }\n            const fieldDef = facet[channel];\n            if (fieldDef.field === undefined) {\n                log.warn(log.message.emptyFieldDef(fieldDef, channel));\n                break;\n            }\n            normalizedFacet[channel] = this.initFacetFieldDef(fieldDef, channel);\n        }\n        return normalizedFacet;\n    }\n    initFacetFieldDef(fieldDef, channel) {\n        // Cast because we call initFieldDef, which assumes general FieldDef.\n        // However, FacetFieldDef is a bit more constrained than the general FieldDef\n        const facetFieldDef = initFieldDef(fieldDef, channel);\n        if (facetFieldDef.header) {\n            facetFieldDef.header = replaceExprRef(facetFieldDef.header);\n        }\n        else if (facetFieldDef.header === null) {\n            facetFieldDef.header = null;\n        }\n        return facetFieldDef;\n    }\n    channelHasField(channel) {\n        return !!this.facet[channel];\n    }\n    fieldDef(channel) {\n        return this.facet[channel];\n    }\n    parseData() {\n        this.component.data = parseData(this);\n        this.child.parseData();\n    }\n    parseLayoutSize() {\n        parseChildrenLayoutSize(this);\n    }\n    parseSelections() {\n        // As a facet has a single child, the selection components are the same.\n        // The child maintains its selections to assemble signals, which remain\n        // within its unit.\n        this.child.parseSelections();\n        this.component.selection = this.child.component.selection;\n    }\n    parseMarkGroup() {\n        this.child.parseMarkGroup();\n    }\n    parseAxesAndHeaders() {\n        this.child.parseAxesAndHeaders();\n        parseFacetHeaders(this);\n    }\n    assembleSelectionTopLevelSignals(signals) {\n        return this.child.assembleSelectionTopLevelSignals(signals);\n    }\n    assembleSignals() {\n        this.child.assembleSignals();\n        return [];\n    }\n    assembleSelectionData(data) {\n        return this.child.assembleSelectionData(data);\n    }\n    getHeaderLayoutMixins() {\n        var _a, _b, _c;\n        const layoutMixins = {};\n        for (const channel of FACET_CHANNELS) {\n            for (const headerType of HEADER_TYPES) {\n                const layoutHeaderComponent = this.component.layoutHeaders[channel];\n                const headerComponent = layoutHeaderComponent[headerType];\n                const { facetFieldDef } = layoutHeaderComponent;\n                if (facetFieldDef) {\n                    const titleOrient = getHeaderProperty('titleOrient', facetFieldDef.header, this.config, channel);\n                    if (['right', 'bottom'].includes(titleOrient)) {\n                        const headerChannel = getHeaderChannel(channel, titleOrient);\n                        (_a = layoutMixins.titleAnchor) !== null && _a !== void 0 ? _a : (layoutMixins.titleAnchor = {});\n                        layoutMixins.titleAnchor[headerChannel] = 'end';\n                    }\n                }\n                if (headerComponent === null || headerComponent === void 0 ? void 0 : headerComponent[0]) {\n                    // set header/footerBand\n                    const sizeType = channel === 'row' ? 'height' : 'width';\n                    const bandType = headerType === 'header' ? 'headerBand' : 'footerBand';\n                    if (channel !== 'facet' && !this.child.component.layoutSize.get(sizeType)) {\n                        // If facet child does not have size signal, then apply headerBand\n                        (_b = layoutMixins[bandType]) !== null && _b !== void 0 ? _b : (layoutMixins[bandType] = {});\n                        layoutMixins[bandType][channel] = 0.5;\n                    }\n                    if (layoutHeaderComponent.title) {\n                        (_c = layoutMixins.offset) !== null && _c !== void 0 ? _c : (layoutMixins.offset = {});\n                        layoutMixins.offset[channel === 'row' ? 'rowTitle' : 'columnTitle'] = 10;\n                    }\n                }\n            }\n        }\n        return layoutMixins;\n    }\n    assembleDefaultLayout() {\n        const { column, row } = this.facet;\n        const columns = column ? this.columnDistinctSignal() : row ? 1 : undefined;\n        let align = 'all';\n        // Do not align the cells if the scale corresponding to the direction is indepent.\n        // We always align when we facet into both row and column.\n        if (!row && this.component.resolve.scale.x === 'independent') {\n            align = 'none';\n        }\n        else if (!column && this.component.resolve.scale.y === 'independent') {\n            align = 'none';\n        }\n        return Object.assign(Object.assign(Object.assign({}, this.getHeaderLayoutMixins()), (columns ? { columns } : {})), { bounds: 'full', align });\n    }\n    assembleLayoutSignals() {\n        // FIXME(https://github.com/vega/vega-lite/issues/1193): this can be incorrect if we have independent scales.\n        return this.child.assembleLayoutSignals();\n    }\n    columnDistinctSignal() {\n        if (this.parent && this.parent instanceof FacetModel) {\n            // For nested facet, we will add columns to group mark instead\n            // See discussion in https://github.com/vega/vega/issues/952\n            // and https://github.com/vega/vega-view/releases/tag/v1.2.6\n            return undefined;\n        }\n        else {\n            // In facetNode.assemble(), the name is always this.getName('column') + '_layout'.\n            const facetLayoutDataName = this.getName('column_domain');\n            return { signal: `length(data('${facetLayoutDataName}'))` };\n        }\n    }\n    assembleGroupStyle() {\n        return undefined;\n    }\n    assembleGroup(signals) {\n        if (this.parent && this.parent instanceof FacetModel) {\n            // Provide number of columns for layout.\n            // See discussion in https://github.com/vega/vega/issues/952\n            // and https://github.com/vega/vega-view/releases/tag/v1.2.6\n            return Object.assign(Object.assign({}, (this.channelHasField('column')\n                ? {\n                    encode: {\n                        update: {\n                            // TODO(https://github.com/vega/vega-lite/issues/2759):\n                            // Correct the signal for facet of concat of facet_column\n                            columns: { field: vgField(this.facet.column, { prefix: 'distinct' }) }\n                        }\n                    }\n                }\n                : {})), super.assembleGroup(signals));\n        }\n        return super.assembleGroup(signals);\n    }\n    /**\n     * Aggregate cardinality for calculating size\n     */\n    getCardinalityAggregateForChild() {\n        const fields = [];\n        const ops = [];\n        const as = [];\n        if (this.child instanceof FacetModel) {\n            if (this.child.channelHasField('column')) {\n                const field = vgField(this.child.facet.column);\n                fields.push(field);\n                ops.push('distinct');\n                as.push(`distinct_${field}`);\n            }\n        }\n        else {\n            for (const channel of POSITION_SCALE_CHANNELS) {\n                const childScaleComponent = this.child.component.scales[channel];\n                if (childScaleComponent && !childScaleComponent.merged) {\n                    const type = childScaleComponent.get('type');\n                    const range = childScaleComponent.get('range');\n                    if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n                        const domain = assembleDomain(this.child, channel);\n                        const field = getFieldFromDomain(domain);\n                        if (field) {\n                            fields.push(field);\n                            ops.push('distinct');\n                            as.push(`distinct_${field}`);\n                        }\n                        else {\n                            log.warn(log.message.unknownField(channel));\n                        }\n                    }\n                }\n            }\n        }\n        return { fields, ops, as };\n    }\n    assembleFacet() {\n        const { name, data } = this.component.data.facetRoot;\n        const { row, column } = this.facet;\n        const { fields, ops, as } = this.getCardinalityAggregateForChild();\n        const groupby = [];\n        for (const channel of FACET_CHANNELS) {\n            const fieldDef = this.facet[channel];\n            if (fieldDef) {\n                groupby.push(vgField(fieldDef));\n                const { bin, sort } = fieldDef;\n                if (isBinning(bin)) {\n                    groupby.push(vgField(fieldDef, { binSuffix: 'end' }));\n                }\n                if (isSortField(sort)) {\n                    const { field, op = DEFAULT_SORT_OP } = sort;\n                    const outputName = facetSortFieldName(fieldDef, sort);\n                    if (row && column) {\n                        // For crossed facet, use pre-calculate field as it requires a different groupby\n                        // For each calculated field, apply max and assign them to the same name as\n                        // all values of the same group should be the same anyway.\n                        fields.push(outputName);\n                        ops.push('max');\n                        as.push(outputName);\n                    }\n                    else {\n                        fields.push(field);\n                        ops.push(op);\n                        as.push(outputName);\n                    }\n                }\n                else if (isArray(sort)) {\n                    const outputName = sortArrayIndexField(fieldDef, channel);\n                    fields.push(outputName);\n                    ops.push('max');\n                    as.push(outputName);\n                }\n            }\n        }\n        const cross = !!row && !!column;\n        return Object.assign({ name,\n            data,\n            groupby }, (cross || fields.length > 0\n            ? {\n                aggregate: Object.assign(Object.assign({}, (cross ? { cross } : {})), (fields.length ? { fields, ops, as } : {}))\n            }\n            : {}));\n    }\n    facetSortFields(channel) {\n        const { facet } = this;\n        const fieldDef = facet[channel];\n        if (fieldDef) {\n            if (isSortField(fieldDef.sort)) {\n                return [facetSortFieldName(fieldDef, fieldDef.sort, { expr: 'datum' })];\n            }\n            else if (isArray(fieldDef.sort)) {\n                return [sortArrayIndexField(fieldDef, channel, { expr: 'datum' })];\n            }\n            return [vgField(fieldDef, { expr: 'datum' })];\n        }\n        return [];\n    }\n    facetSortOrder(channel) {\n        const { facet } = this;\n        const fieldDef = facet[channel];\n        if (fieldDef) {\n            const { sort } = fieldDef;\n            const order = (isSortField(sort) ? sort.order : !isArray(sort) && sort) || 'ascending';\n            return [order];\n        }\n        return [];\n    }\n    assembleLabelTitle() {\n        var _a;\n        const { facet, config } = this;\n        if (facet.facet) {\n            // Facet always uses title to display labels\n            return assembleLabelTitle(facet.facet, 'facet', config);\n        }\n        const ORTHOGONAL_ORIENT = {\n            row: ['top', 'bottom'],\n            column: ['left', 'right']\n        };\n        for (const channel of HEADER_CHANNELS) {\n            if (facet[channel]) {\n                const labelOrient = getHeaderProperty('labelOrient', (_a = facet[channel]) === null || _a === void 0 ? void 0 : _a.header, config, channel);\n                if (ORTHOGONAL_ORIENT[channel].includes(labelOrient)) {\n                    // Row/Column with orthogonal labelOrient must use title to display labels\n                    return assembleLabelTitle(facet[channel], channel, config);\n                }\n            }\n        }\n        return undefined;\n    }\n    assembleMarks() {\n        const { child } = this;\n        // If we facet by two dimensions, we need to add a cross operator to the aggregation\n        // so that we create all groups\n        const facetRoot = this.component.data.facetRoot;\n        const data = assembleFacetData(facetRoot);\n        const encodeEntry = child.assembleGroupEncodeEntry(false);\n        const title = this.assembleLabelTitle() || child.assembleTitle();\n        const style = child.assembleGroupStyle();\n        const markGroup = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ name: this.getName('cell'), type: 'group' }, (title ? { title } : {})), (style ? { style } : {})), { from: {\n                facet: this.assembleFacet()\n            }, \n            // TODO: move this to after data\n            sort: {\n                field: FACET_CHANNELS.map(c => this.facetSortFields(c)).flat(),\n                order: FACET_CHANNELS.map(c => this.facetSortOrder(c)).flat()\n            } }), (data.length > 0 ? { data } : {})), (encodeEntry ? { encode: { update: encodeEntry } } : {})), child.assembleGroup(assembleFacetSignals(this, [])));\n        return [markGroup];\n    }\n    getMapping() {\n        return this.facet;\n    }\n}\n//# sourceMappingURL=facet.js.map"]},"metadata":{},"sourceType":"module"}