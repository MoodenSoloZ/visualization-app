{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { AXIS_PARTS, isAxisProperty, isConditionalAxisValue } from '../../axis';\nimport { POSITION_SCALE_CHANNELS } from '../../channel';\nimport { getFieldOrDatumDef } from '../../channeldef';\nimport { getFirstDefined, isEmpty, keys, normalizeAngle } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { mergeTitleComponent } from '../common';\nimport { guideEncodeEntry } from '../guide';\nimport { parseGuideResolve } from '../resolve';\nimport { defaultTieBreaker, mergeValuesWithExplicit } from '../split';\nimport { AxisComponent, AXIS_COMPONENT_PROPERTIES } from './component';\nimport { getAxisConfig, getAxisConfigs } from './config';\nimport * as encode from './encode';\nimport { axisRules, defaultOrient, getFieldDefTitle, getLabelAngle } from './properties';\nexport function parseUnitAxes(model) {\n  return POSITION_SCALE_CHANNELS.reduce(function (axis, channel) {\n    if (model.component.scales[channel]) {\n      axis[channel] = [parseAxis(channel, model)];\n    }\n    return axis;\n  }, {});\n}\nvar OPPOSITE_ORIENT = {\n  bottom: 'top',\n  top: 'bottom',\n  left: 'right',\n  right: 'left'\n};\nexport function parseLayerAxes(model) {\n  var _a;\n  var _model$component = model.component,\n    axes = _model$component.axes,\n    resolve = _model$component.resolve;\n  var axisCount = {\n    top: 0,\n    bottom: 0,\n    right: 0,\n    left: 0\n  };\n  var _iterator = _createForOfIteratorHelper(model.children),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var child = _step.value;\n      child.parseAxesAndHeaders();\n      var _iterator3 = _createForOfIteratorHelper(keys(child.component.axes)),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var channel = _step3.value;\n          resolve.axis[channel] = parseGuideResolve(model.component.resolve, channel);\n          if (resolve.axis[channel] === 'shared') {\n            // If the resolve says shared (and has not been overridden)\n            // We will try to merge and see if there is a conflict\n            axes[channel] = mergeAxisComponents(axes[channel], child.component.axes[channel]);\n            if (!axes[channel]) {\n              // If merge returns nothing, there is a conflict so we cannot make the axis shared.\n              // Thus, mark axis as independent and remove the axis component.\n              resolve.axis[channel] = 'independent';\n              delete axes[channel];\n            }\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n    // Move axes to layer's axis component and merge shared axes\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var _iterator2 = _createForOfIteratorHelper(POSITION_SCALE_CHANNELS),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _channel = _step2.value;\n      var _iterator4 = _createForOfIteratorHelper(model.children),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _child = _step4.value;\n          if (!_child.component.axes[_channel]) {\n            // skip if the child does not have a particular axis\n            continue;\n          }\n          if (resolve.axis[_channel] === 'independent') {\n            // If axes are independent, concat the axisComponent array.\n            axes[_channel] = ((_a = axes[_channel]) !== null && _a !== void 0 ? _a : []).concat(_child.component.axes[_channel]);\n            // Automatically adjust orient\n            var _iterator6 = _createForOfIteratorHelper(_child.component.axes[_channel]),\n              _step6;\n            try {\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                var axisComponent = _step6.value;\n                var _axisComponent$getWit = axisComponent.getWithExplicit('orient'),\n                  orient = _axisComponent$getWit.value,\n                  explicit = _axisComponent$getWit.explicit;\n                if (isSignalRef(orient)) {\n                  continue;\n                }\n                if (axisCount[orient] > 0 && !explicit) {\n                  // Change axis orient if the number do not match\n                  var oppositeOrient = OPPOSITE_ORIENT[orient];\n                  if (axisCount[orient] > axisCount[oppositeOrient]) {\n                    axisComponent.set('orient', oppositeOrient, false);\n                  }\n                }\n                axisCount[orient]++;\n                // TODO(https://github.com/vega/vega-lite/issues/2634): automatically add extra offset?\n              }\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n          }\n          // After merging, make sure to remove axes from child\n          delete _child.component.axes[_channel];\n        }\n        // Suppress grid lines for dual axis charts (https://github.com/vega/vega-lite/issues/4676)\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      if (resolve.axis[_channel] === 'independent' && axes[_channel] && axes[_channel].length > 1) {\n        var _iterator5 = _createForOfIteratorHelper(axes[_channel]),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var axisCmpt = _step5.value;\n            if (!!axisCmpt.get('grid') && !axisCmpt.explicit.grid) {\n              axisCmpt.implicit.grid = false;\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n}\nfunction mergeAxisComponents(mergedAxisCmpts, childAxisCmpts) {\n  if (mergedAxisCmpts) {\n    // FIXME: this is a bit wrong once we support multiple axes\n    if (mergedAxisCmpts.length !== childAxisCmpts.length) {\n      return undefined; // Cannot merge axis component with different number of axes.\n    }\n\n    var length = mergedAxisCmpts.length;\n    for (var i = 0; i < length; i++) {\n      var merged = mergedAxisCmpts[i];\n      var child = childAxisCmpts[i];\n      if (!!merged !== !!child) {\n        return undefined;\n      } else if (merged && child) {\n        var mergedOrient = merged.getWithExplicit('orient');\n        var childOrient = child.getWithExplicit('orient');\n        if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n          // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n          // Cannot merge due to inconsistent orient\n          return undefined;\n        } else {\n          mergedAxisCmpts[i] = mergeAxisComponent(merged, child);\n        }\n      }\n    }\n  } else {\n    // For first one, return a copy of the child\n    return childAxisCmpts.map(function (axisComponent) {\n      return axisComponent.clone();\n    });\n  }\n  return mergedAxisCmpts;\n}\nfunction mergeAxisComponent(merged, child) {\n  var _iterator7 = _createForOfIteratorHelper(AXIS_COMPONENT_PROPERTIES),\n    _step7;\n  try {\n    var _loop = function _loop() {\n      var prop = _step7.value;\n      var mergedValueWithExplicit = mergeValuesWithExplicit(merged.getWithExplicit(prop), child.getWithExplicit(prop), prop, 'axis',\n      // Tie breaker function\n      function (v1, v2) {\n        switch (prop) {\n          case 'title':\n            return mergeTitleComponent(v1, v2);\n          case 'gridScale':\n            return {\n              explicit: v1.explicit,\n              value: getFirstDefined(v1.value, v2.value)\n            };\n        }\n        return defaultTieBreaker(v1, v2, prop, 'axis');\n      });\n      merged.setWithExplicit(prop, mergedValueWithExplicit);\n    };\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n  return merged;\n}\nfunction isExplicit(value, property, axis, model, channel) {\n  if (property === 'disable') {\n    return axis !== undefined; // if axis is specified or null/false, then its enable/disable state is explicit\n  }\n\n  axis = axis || {};\n  switch (property) {\n    case 'titleAngle':\n    case 'labelAngle':\n      return value === (isSignalRef(axis.labelAngle) ? axis.labelAngle : normalizeAngle(axis.labelAngle));\n    case 'values':\n      return !!axis.values;\n    // specified axis.values is already respected, but may get transformed.\n    case 'encode':\n      // both VL axis.encoding and axis.labelAngle affect VG axis.encode\n      return !!axis.encoding || !!axis.labelAngle;\n    case 'title':\n      // title can be explicit if fieldDef.title is set\n      if (value === getFieldDefTitle(model, channel)) {\n        return true;\n      }\n  }\n  // Otherwise, things are explicit if the returned value matches the specified property\n  return value === axis[property];\n}\n/**\n * Properties to always include values from config\n */\nvar propsToAlwaysIncludeConfig = new Set(['grid', 'translate',\n// the rest are not axis configs in Vega, but are in VL, so we need to set too.\n'format', 'formatType', 'orient', 'labelExpr', 'tickCount', 'position', 'tickMinStep']);\nfunction parseAxis(channel, model) {\n  var _a, _b, _c;\n  var axis = model.axis(channel);\n  var axisComponent = new AxisComponent();\n  var fieldOrDatumDef = getFieldOrDatumDef(model.encoding[channel]);\n  var mark = model.mark,\n    config = model.config;\n  var orient = (axis === null || axis === void 0 ? void 0 : axis.orient) || ((_a = config[channel === 'x' ? 'axisX' : 'axisY']) === null || _a === void 0 ? void 0 : _a.orient) || ((_b = config.axis) === null || _b === void 0 ? void 0 : _b.orient) || defaultOrient(channel);\n  var scaleType = model.getScaleComponent(channel).get('type');\n  var axisConfigs = getAxisConfigs(channel, scaleType, orient, model.config);\n  var disable = axis !== undefined ? !axis : getAxisConfig('disable', config.style, axis === null || axis === void 0 ? void 0 : axis.style, axisConfigs).configValue;\n  axisComponent.set('disable', disable, axis !== undefined);\n  if (disable) {\n    return axisComponent;\n  }\n  axis = axis || {};\n  var labelAngle = getLabelAngle(fieldOrDatumDef, axis, channel, config.style, axisConfigs);\n  var ruleParams = {\n    fieldOrDatumDef: fieldOrDatumDef,\n    axis: axis,\n    channel: channel,\n    model: model,\n    scaleType: scaleType,\n    orient: orient,\n    labelAngle: labelAngle,\n    mark: mark,\n    config: config\n  };\n  // 1.2. Add properties\n  var _iterator8 = _createForOfIteratorHelper(AXIS_COMPONENT_PROPERTIES),\n    _step8;\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var property = _step8.value;\n      var value = property in axisRules ? axisRules[property](ruleParams) : isAxisProperty(property) ? axis[property] : undefined;\n      var hasValue = value !== undefined;\n      var explicit = isExplicit(value, property, axis, model, channel);\n      if (hasValue && explicit) {\n        axisComponent.set(property, value, explicit);\n      } else {\n        var _ref = isAxisProperty(property) && property !== 'values' ? getAxisConfig(property, config.style, axis.style, axisConfigs) : {},\n          _ref$configValue = _ref.configValue,\n          configValue = _ref$configValue === void 0 ? undefined : _ref$configValue,\n          _ref$configFrom = _ref.configFrom,\n          configFrom = _ref$configFrom === void 0 ? undefined : _ref$configFrom;\n        var hasConfigValue = configValue !== undefined;\n        if (hasValue && !hasConfigValue) {\n          // only set property if it is explicitly set or has no config value (otherwise we will accidentally override config)\n          axisComponent.set(property, value, explicit);\n        } else if (\n        // Cases need implicit values\n        // 1. Axis config that aren't available in Vega\n        !(configFrom === 'vgAxisConfig') ||\n        // 2. Certain properties are always included (see `propsToAlwaysIncludeConfig`'s declaration for more details)\n        propsToAlwaysIncludeConfig.has(property) && hasConfigValue ||\n        // 3. Conditional axis values and signals\n        isConditionalAxisValue(configValue) || isSignalRef(configValue)) {\n          // If a config is specified and is conditional, copy conditional value from axis config\n          axisComponent.set(property, configValue, false);\n        }\n      }\n    }\n    // 2) Add guide encode definition groups\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n  var axisEncoding = (_c = axis.encoding) !== null && _c !== void 0 ? _c : {};\n  var axisEncode = AXIS_PARTS.reduce(function (e, part) {\n    var _a;\n    if (!axisComponent.hasAxisPart(part)) {\n      // No need to create encode for a disabled part.\n      return e;\n    }\n    var axisEncodingPart = guideEncodeEntry((_a = axisEncoding[part]) !== null && _a !== void 0 ? _a : {}, model);\n    var value = part === 'labels' ? encode.labels(model, channel, axisEncodingPart) : axisEncodingPart;\n    if (value !== undefined && !isEmpty(value)) {\n      e[part] = {\n        update: value\n      };\n    }\n    return e;\n  }, {});\n  // FIXME: By having encode as one property, we won't have fine grained encode merging.\n  if (!isEmpty(axisEncode)) {\n    axisComponent.set('encode', axisEncode, !!axis.encoding || axis.labelAngle !== undefined);\n  }\n  return axisComponent;\n}","map":{"version":3,"sources":["../../../../src/compile/axis/parse.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { AXIS_PARTS, isAxisProperty, isConditionalAxisValue } from '../../axis';\nimport { POSITION_SCALE_CHANNELS } from '../../channel';\nimport { getFieldOrDatumDef } from '../../channeldef';\nimport { getFirstDefined, isEmpty, keys, normalizeAngle } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { mergeTitleComponent } from '../common';\nimport { guideEncodeEntry } from '../guide';\nimport { parseGuideResolve } from '../resolve';\nimport { defaultTieBreaker, mergeValuesWithExplicit } from '../split';\nimport { AxisComponent, AXIS_COMPONENT_PROPERTIES } from './component';\nimport { getAxisConfig, getAxisConfigs } from './config';\nimport * as encode from './encode';\nimport { axisRules, defaultOrient, getFieldDefTitle, getLabelAngle } from './properties';\nexport function parseUnitAxes(model) {\n    return POSITION_SCALE_CHANNELS.reduce((axis, channel) => {\n        if (model.component.scales[channel]) {\n            axis[channel] = [parseAxis(channel, model)];\n        }\n        return axis;\n    }, {});\n}\nconst OPPOSITE_ORIENT = {\n    bottom: 'top',\n    top: 'bottom',\n    left: 'right',\n    right: 'left'\n};\nexport function parseLayerAxes(model) {\n    var _a;\n    const { axes, resolve } = model.component;\n    const axisCount = { top: 0, bottom: 0, right: 0, left: 0 };\n    for (const child of model.children) {\n        child.parseAxesAndHeaders();\n        for (const channel of keys(child.component.axes)) {\n            resolve.axis[channel] = parseGuideResolve(model.component.resolve, channel);\n            if (resolve.axis[channel] === 'shared') {\n                // If the resolve says shared (and has not been overridden)\n                // We will try to merge and see if there is a conflict\n                axes[channel] = mergeAxisComponents(axes[channel], child.component.axes[channel]);\n                if (!axes[channel]) {\n                    // If merge returns nothing, there is a conflict so we cannot make the axis shared.\n                    // Thus, mark axis as independent and remove the axis component.\n                    resolve.axis[channel] = 'independent';\n                    delete axes[channel];\n                }\n            }\n        }\n    }\n    // Move axes to layer's axis component and merge shared axes\n    for (const channel of POSITION_SCALE_CHANNELS) {\n        for (const child of model.children) {\n            if (!child.component.axes[channel]) {\n                // skip if the child does not have a particular axis\n                continue;\n            }\n            if (resolve.axis[channel] === 'independent') {\n                // If axes are independent, concat the axisComponent array.\n                axes[channel] = ((_a = axes[channel]) !== null && _a !== void 0 ? _a : []).concat(child.component.axes[channel]);\n                // Automatically adjust orient\n                for (const axisComponent of child.component.axes[channel]) {\n                    const { value: orient, explicit } = axisComponent.getWithExplicit('orient');\n                    if (isSignalRef(orient)) {\n                        continue;\n                    }\n                    if (axisCount[orient] > 0 && !explicit) {\n                        // Change axis orient if the number do not match\n                        const oppositeOrient = OPPOSITE_ORIENT[orient];\n                        if (axisCount[orient] > axisCount[oppositeOrient]) {\n                            axisComponent.set('orient', oppositeOrient, false);\n                        }\n                    }\n                    axisCount[orient]++;\n                    // TODO(https://github.com/vega/vega-lite/issues/2634): automatically add extra offset?\n                }\n            }\n            // After merging, make sure to remove axes from child\n            delete child.component.axes[channel];\n        }\n        // Suppress grid lines for dual axis charts (https://github.com/vega/vega-lite/issues/4676)\n        if (resolve.axis[channel] === 'independent' && axes[channel] && axes[channel].length > 1) {\n            for (const axisCmpt of axes[channel]) {\n                if (!!axisCmpt.get('grid') && !axisCmpt.explicit.grid) {\n                    axisCmpt.implicit.grid = false;\n                }\n            }\n        }\n    }\n}\nfunction mergeAxisComponents(mergedAxisCmpts, childAxisCmpts) {\n    if (mergedAxisCmpts) {\n        // FIXME: this is a bit wrong once we support multiple axes\n        if (mergedAxisCmpts.length !== childAxisCmpts.length) {\n            return undefined; // Cannot merge axis component with different number of axes.\n        }\n        const length = mergedAxisCmpts.length;\n        for (let i = 0; i < length; i++) {\n            const merged = mergedAxisCmpts[i];\n            const child = childAxisCmpts[i];\n            if (!!merged !== !!child) {\n                return undefined;\n            }\n            else if (merged && child) {\n                const mergedOrient = merged.getWithExplicit('orient');\n                const childOrient = child.getWithExplicit('orient');\n                if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n                    // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n                    // Cannot merge due to inconsistent orient\n                    return undefined;\n                }\n                else {\n                    mergedAxisCmpts[i] = mergeAxisComponent(merged, child);\n                }\n            }\n        }\n    }\n    else {\n        // For first one, return a copy of the child\n        return childAxisCmpts.map(axisComponent => axisComponent.clone());\n    }\n    return mergedAxisCmpts;\n}\nfunction mergeAxisComponent(merged, child) {\n    for (const prop of AXIS_COMPONENT_PROPERTIES) {\n        const mergedValueWithExplicit = mergeValuesWithExplicit(merged.getWithExplicit(prop), child.getWithExplicit(prop), prop, 'axis', \n        // Tie breaker function\n        (v1, v2) => {\n            switch (prop) {\n                case 'title':\n                    return mergeTitleComponent(v1, v2);\n                case 'gridScale':\n                    return {\n                        explicit: v1.explicit,\n                        value: getFirstDefined(v1.value, v2.value)\n                    };\n            }\n            return defaultTieBreaker(v1, v2, prop, 'axis');\n        });\n        merged.setWithExplicit(prop, mergedValueWithExplicit);\n    }\n    return merged;\n}\nfunction isExplicit(value, property, axis, model, channel) {\n    if (property === 'disable') {\n        return axis !== undefined; // if axis is specified or null/false, then its enable/disable state is explicit\n    }\n    axis = axis || {};\n    switch (property) {\n        case 'titleAngle':\n        case 'labelAngle':\n            return value === (isSignalRef(axis.labelAngle) ? axis.labelAngle : normalizeAngle(axis.labelAngle));\n        case 'values':\n            return !!axis.values;\n        // specified axis.values is already respected, but may get transformed.\n        case 'encode':\n            // both VL axis.encoding and axis.labelAngle affect VG axis.encode\n            return !!axis.encoding || !!axis.labelAngle;\n        case 'title':\n            // title can be explicit if fieldDef.title is set\n            if (value === getFieldDefTitle(model, channel)) {\n                return true;\n            }\n    }\n    // Otherwise, things are explicit if the returned value matches the specified property\n    return value === axis[property];\n}\n/**\n * Properties to always include values from config\n */\nconst propsToAlwaysIncludeConfig = new Set([\n    'grid',\n    'translate',\n    // the rest are not axis configs in Vega, but are in VL, so we need to set too.\n    'format',\n    'formatType',\n    'orient',\n    'labelExpr',\n    'tickCount',\n    'position',\n    'tickMinStep'\n]);\nfunction parseAxis(channel, model) {\n    var _a, _b, _c;\n    let axis = model.axis(channel);\n    const axisComponent = new AxisComponent();\n    const fieldOrDatumDef = getFieldOrDatumDef(model.encoding[channel]);\n    const { mark, config } = model;\n    const orient = (axis === null || axis === void 0 ? void 0 : axis.orient) ||\n        ((_a = config[channel === 'x' ? 'axisX' : 'axisY']) === null || _a === void 0 ? void 0 : _a.orient) ||\n        ((_b = config.axis) === null || _b === void 0 ? void 0 : _b.orient) ||\n        defaultOrient(channel);\n    const scaleType = model.getScaleComponent(channel).get('type');\n    const axisConfigs = getAxisConfigs(channel, scaleType, orient, model.config);\n    const disable = axis !== undefined ? !axis : getAxisConfig('disable', config.style, axis === null || axis === void 0 ? void 0 : axis.style, axisConfigs).configValue;\n    axisComponent.set('disable', disable, axis !== undefined);\n    if (disable) {\n        return axisComponent;\n    }\n    axis = axis || {};\n    const labelAngle = getLabelAngle(fieldOrDatumDef, axis, channel, config.style, axisConfigs);\n    const ruleParams = {\n        fieldOrDatumDef,\n        axis,\n        channel,\n        model,\n        scaleType,\n        orient,\n        labelAngle,\n        mark,\n        config\n    };\n    // 1.2. Add properties\n    for (const property of AXIS_COMPONENT_PROPERTIES) {\n        const value = property in axisRules ? axisRules[property](ruleParams) : isAxisProperty(property) ? axis[property] : undefined;\n        const hasValue = value !== undefined;\n        const explicit = isExplicit(value, property, axis, model, channel);\n        if (hasValue && explicit) {\n            axisComponent.set(property, value, explicit);\n        }\n        else {\n            const { configValue = undefined, configFrom = undefined } = isAxisProperty(property) && property !== 'values'\n                ? getAxisConfig(property, config.style, axis.style, axisConfigs)\n                : {};\n            const hasConfigValue = configValue !== undefined;\n            if (hasValue && !hasConfigValue) {\n                // only set property if it is explicitly set or has no config value (otherwise we will accidentally override config)\n                axisComponent.set(property, value, explicit);\n            }\n            else if (\n            // Cases need implicit values\n            // 1. Axis config that aren't available in Vega\n            !(configFrom === 'vgAxisConfig') ||\n                // 2. Certain properties are always included (see `propsToAlwaysIncludeConfig`'s declaration for more details)\n                (propsToAlwaysIncludeConfig.has(property) && hasConfigValue) ||\n                // 3. Conditional axis values and signals\n                isConditionalAxisValue(configValue) ||\n                isSignalRef(configValue)) {\n                // If a config is specified and is conditional, copy conditional value from axis config\n                axisComponent.set(property, configValue, false);\n            }\n        }\n    }\n    // 2) Add guide encode definition groups\n    const axisEncoding = (_c = axis.encoding) !== null && _c !== void 0 ? _c : {};\n    const axisEncode = AXIS_PARTS.reduce((e, part) => {\n        var _a;\n        if (!axisComponent.hasAxisPart(part)) {\n            // No need to create encode for a disabled part.\n            return e;\n        }\n        const axisEncodingPart = guideEncodeEntry((_a = axisEncoding[part]) !== null && _a !== void 0 ? _a : {}, model);\n        const value = part === 'labels' ? encode.labels(model, channel, axisEncodingPart) : axisEncodingPart;\n        if (value !== undefined && !isEmpty(value)) {\n            e[part] = { update: value };\n        }\n        return e;\n    }, {});\n    // FIXME: By having encode as one property, we won't have fine grained encode merging.\n    if (!isEmpty(axisEncode)) {\n        axisComponent.set('encode', axisEncode, !!axis.encoding || axis.labelAngle !== undefined);\n    }\n    return axisComponent;\n}\n//# sourceMappingURL=parse.js.map"]},"metadata":{},"sourceType":"module"}