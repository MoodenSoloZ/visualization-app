{"ast":null,"code":"import { contains } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { isConcatModel, isLayerModel } from '../model';\nexport function assembleProjections(model) {\n  if (isLayerModel(model) || isConcatModel(model)) {\n    return assembleProjectionsForModelAndChildren(model);\n  } else {\n    return assembleProjectionForModel(model);\n  }\n}\nexport function assembleProjectionsForModelAndChildren(model) {\n  return model.children.reduce(function (projections, child) {\n    return projections.concat(child.assembleProjections());\n  }, assembleProjectionForModel(model));\n}\nexport function assembleProjectionForModel(model) {\n  var component = model.component.projection;\n  if (!component || component.merged) {\n    return [];\n  }\n  var projection = component.combine();\n  var name = projection.name; // we need to extract name so that it is always present in the output and pass TS type validation\n  if (!component.data) {\n    // generate custom projection, no automatic fitting\n    return [Object.assign(Object.assign({\n      name: name\n    }, {\n      translate: {\n        signal: '[width / 2, height / 2]'\n      }\n    }), projection)];\n  } else {\n    // generate projection that uses extent fitting\n    var size = {\n      signal: \"[\".concat(component.size.map(function (ref) {\n        return ref.signal;\n      }).join(', '), \"]\")\n    };\n    var fits = component.data.reduce(function (sources, data) {\n      var source = isSignalRef(data) ? data.signal : \"data('\".concat(model.lookupDataSource(data), \"')\");\n      if (!contains(sources, source)) {\n        // build a unique list of sources\n        sources.push(source);\n      }\n      return sources;\n    }, []);\n    if (fits.length <= 0) {\n      throw new Error(\"Projection's fit didn't find any data sources\");\n    }\n    return [Object.assign({\n      name: name,\n      size: size,\n      fit: {\n        signal: fits.length > 1 ? \"[\".concat(fits.join(', '), \"]\") : fits[0]\n      }\n    }, projection)];\n  }\n}","map":{"version":3,"sources":["../../../../src/compile/projection/assemble.ts"],"names":[],"mappings":"AACA,SAAQ,QAAQ,QAAO,YAAY;AACnC,SAAQ,WAAW,QAAO,mBAAmB;AAC7C,SAAQ,aAAa,EAAE,YAAY,QAAc,UAAU;AAE3D,OAAM,SAAU,mBAAmB,CAAC,KAAY,EAAA;EAC9C,IAAI,YAAY,CAAC,KAAK,CAAC,IAAI,aAAa,CAAC,KAAK,CAAC,EAAE;IAC/C,OAAO,sCAAsC,CAAC,KAAK,CAAC;GACrD,MAAM;IACL,OAAO,0BAA0B,CAAC,KAAK,CAAC;EACzC;AACH;AAEA,OAAM,SAAU,sCAAsC,CAAC,KAAY,EAAA;EACjE,OAAO,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC,UAAC,WAAW,EAAE,KAAK,EAAI;IAClD,OAAO,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC,mBAAmB,EAAE,CAAC;EACxD,CAAC,EAAE,0BAA0B,CAAC,KAAK,CAAC,CAAC;AACvC;AAEA,OAAM,SAAU,0BAA0B,CAAC,KAAY,EAAA;EACrD,IAAM,SAAS,GAAG,KAAK,CAAC,SAAS,CAAC,UAAU;EAC5C,IAAI,CAAC,SAAS,IAAI,SAAS,CAAC,MAAM,EAAE;IAClC,OAAO,EAAE;EACV;EAED,IAAM,UAAU,GAAG,SAAS,CAAC,OAAO,EAAE;EACtC,IAAO,IAAI,GAAI,UAAU,CAAlB,IAAI,CAAe,CAAC;EAE3B,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE;IACnB;IACA,OAAO,C;MAEH,IAAI,EAAJ;IAAI,CAAA,EAED;MAAC,SAAS,EAAE;QAAC,MAAM,EAAE;MAAyB;IAAC,CAAC,CAAA,EAEhD,UAAU,CAAA,CAEhB;GACF,MAAM;IACL;IACA,IAAM,IAAI,GAAc;MACtB,MAAM,aAAM,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,UAAA,GAAG;QAAA,OAAI,GAAG,CAAC,MAAM;MAAA,EAAC,CAAC,IAAI,CAAC,IAAI,CAAC;KAC7D;IAED,IAAM,IAAI,GAAa,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,UAAC,OAAO,EAAE,IAAI,EAAI;MAC7D,IAAM,MAAM,GAAW,WAAW,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,MAAM,mBAAY,KAAK,CAAC,gBAAgB,CAAC,IAAI,CAAC,OAAI;MAClG,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,MAAM,CAAC,EAAE;QAC9B;QACA,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC;MACrB;MACD,OAAO,OAAO;IAChB,CAAC,EAAE,EAAE,CAAC;IAEN,IAAI,IAAI,CAAC,MAAM,IAAI,CAAC,EAAE;MACpB,MAAM,IAAI,KAAK,CAAC,+CAA+C,CAAC;IACjE;IAED,OAAO,C;MAEH,IAAI,EAAJ,IAAI;MACJ,IAAI,EAAJ,IAAI;MACJ,GAAG,EAAE;QACH,MAAM,EAAE,IAAI,CAAC,MAAM,GAAG,CAAC,cAAO,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,SAAM,IAAI,CAAC,CAAC;MAC1D;IAAA,CAAA,EACE,UAAU,CAAA,CAEhB;EACF;AACH","sourceRoot":"","sourcesContent":["import { contains } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { isConcatModel, isLayerModel } from '../model';\nexport function assembleProjections(model) {\n    if (isLayerModel(model) || isConcatModel(model)) {\n        return assembleProjectionsForModelAndChildren(model);\n    }\n    else {\n        return assembleProjectionForModel(model);\n    }\n}\nexport function assembleProjectionsForModelAndChildren(model) {\n    return model.children.reduce((projections, child) => {\n        return projections.concat(child.assembleProjections());\n    }, assembleProjectionForModel(model));\n}\nexport function assembleProjectionForModel(model) {\n    const component = model.component.projection;\n    if (!component || component.merged) {\n        return [];\n    }\n    const projection = component.combine();\n    const { name } = projection; // we need to extract name so that it is always present in the output and pass TS type validation\n    if (!component.data) {\n        // generate custom projection, no automatic fitting\n        return [\n            Object.assign(Object.assign({ name }, { translate: { signal: '[width / 2, height / 2]' } }), projection)\n        ];\n    }\n    else {\n        // generate projection that uses extent fitting\n        const size = {\n            signal: `[${component.size.map(ref => ref.signal).join(', ')}]`\n        };\n        const fits = component.data.reduce((sources, data) => {\n            const source = isSignalRef(data) ? data.signal : `data('${model.lookupDataSource(data)}')`;\n            if (!contains(sources, source)) {\n                // build a unique list of sources\n                sources.push(source);\n            }\n            return sources;\n        }, []);\n        if (fits.length <= 0) {\n            throw new Error(\"Projection's fit didn't find any data sources\");\n        }\n        return [\n            Object.assign({ name,\n                size, fit: {\n                    signal: fits.length > 1 ? `[${fits.join(', ')}]` : fits[0]\n                } }, projection)\n        ];\n    }\n}\n//# sourceMappingURL=assemble.js.map"]},"metadata":{},"sourceType":"module"}