{"ast":null,"code":"import _classCallCheck from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { isObject } from 'vega-util';\nimport { normalizeEncoding } from '../encoding';\nimport { isMarkDef } from '../mark';\nimport { isUnitSpec } from '../spec/unit';\nimport { stack } from '../stack';\nimport { keys, omit, pick } from '../util';\nfunction dropLineAndPoint(markDef) {\n  var _point = markDef.point,\n    _line = markDef.line,\n    mark = __rest(markDef, [\"point\", \"line\"]);\n  return keys(mark).length > 1 ? mark : mark.type;\n}\nfunction dropLineAndPointFromConfig(config) {\n  for (var _i = 0, _arr = ['line', 'area', 'rule', 'trail']; _i < _arr.length; _i++) {\n    var mark = _arr[_i];\n    if (config[mark]) {\n      config = Object.assign(Object.assign({}, config), _defineProperty({}, mark, omit(config[mark], ['point', 'line'])));\n    }\n  }\n  return config;\n}\nfunction getPointOverlay(markDef) {\n  var markConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var encoding = arguments.length > 2 ? arguments[2] : undefined;\n  if (markDef.point === 'transparent') {\n    return {\n      opacity: 0\n    };\n  } else if (markDef.point) {\n    // truthy : true or object\n    return isObject(markDef.point) ? markDef.point : {};\n  } else if (markDef.point !== undefined) {\n    // false or null\n    return null;\n  } else {\n    // undefined (not disabled)\n    if (markConfig.point || encoding.shape) {\n      // enable point overlay if config[mark].point is truthy or if encoding.shape is provided\n      return isObject(markConfig.point) ? markConfig.point : {};\n    }\n    // markDef.point is defined as falsy\n    return undefined;\n  }\n}\nfunction getLineOverlay(markDef) {\n  var markConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (markDef.line) {\n    // true or object\n    return markDef.line === true ? {} : markDef.line;\n  } else if (markDef.line !== undefined) {\n    // false or null\n    return null;\n  } else {\n    // undefined (not disabled)\n    if (markConfig.line) {\n      // enable line overlay if config[mark].line is truthy\n      return markConfig.line === true ? {} : markConfig.line;\n    }\n    // markDef.point is defined as falsy\n    return undefined;\n  }\n}\nexport var PathOverlayNormalizer = /*#__PURE__*/function () {\n  function PathOverlayNormalizer() {\n    _classCallCheck(this, PathOverlayNormalizer);\n    this.name = 'path-overlay';\n  }\n  _createClass(PathOverlayNormalizer, [{\n    key: \"hasMatchingType\",\n    value: function hasMatchingType(spec, config) {\n      if (isUnitSpec(spec)) {\n        var mark = spec.mark,\n          encoding = spec.encoding;\n        var markDef = isMarkDef(mark) ? mark : {\n          type: mark\n        };\n        switch (markDef.type) {\n          case 'line':\n          case 'rule':\n          case 'trail':\n            return !!getPointOverlay(markDef, config[markDef.type], encoding);\n          case 'area':\n            return (\n              // false / null are also included as we want to remove the properties\n              !!getPointOverlay(markDef, config[markDef.type], encoding) || !!getLineOverlay(markDef, config[markDef.type])\n            );\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"run\",\n    value: function run(spec, normParams, normalize) {\n      var config = normParams.config;\n      var params = spec.params,\n        projection = spec.projection,\n        mark = spec.mark,\n        e = spec.encoding,\n        outerSpec = __rest(spec, [\"params\", \"projection\", \"mark\", \"encoding\"]);\n      // Need to call normalizeEncoding because we need the inferred types to correctly determine stack\n      var encoding = normalizeEncoding(e, config);\n      var markDef = isMarkDef(mark) ? mark : {\n        type: mark\n      };\n      var pointOverlay = getPointOverlay(markDef, config[markDef.type], encoding);\n      var lineOverlay = markDef.type === 'area' && getLineOverlay(markDef, config[markDef.type]);\n      var layer = [Object.assign(Object.assign({}, params ? {\n        params: params\n      } : {}), {\n        mark: dropLineAndPoint(Object.assign(Object.assign({}, markDef.type === 'area' && markDef.opacity === undefined && markDef.fillOpacity === undefined ? {\n          opacity: 0.7\n        } : {}), markDef)),\n        // drop shape from encoding as this might be used to trigger point overlay\n        encoding: omit(encoding, ['shape'])\n      })];\n      // FIXME: determine rules for applying selections.\n      // Need to copy stack config to overlayed layer\n      var stackProps = stack(markDef, encoding);\n      var overlayEncoding = encoding;\n      if (stackProps) {\n        var stackFieldChannel = stackProps.fieldChannel,\n          offset = stackProps.offset;\n        overlayEncoding = Object.assign(Object.assign({}, encoding), _defineProperty({}, stackFieldChannel, Object.assign(Object.assign({}, encoding[stackFieldChannel]), offset ? {\n          stack: offset\n        } : {})));\n      }\n      // overlay line layer should be on the edge of area but passing y2/x2 makes\n      // it as \"rule\" mark so that it draws unwanted vertical/horizontal lines.\n      // point overlay also should not have y2/x2 as it does not support.\n      overlayEncoding = omit(overlayEncoding, ['y2', 'x2']);\n      if (lineOverlay) {\n        layer.push(Object.assign(Object.assign({}, projection ? {\n          projection: projection\n        } : {}), {\n          mark: Object.assign(Object.assign({\n            type: 'line'\n          }, pick(markDef, ['clip', 'interpolate', 'tension', 'tooltip'])), lineOverlay),\n          encoding: overlayEncoding\n        }));\n      }\n      if (pointOverlay) {\n        layer.push(Object.assign(Object.assign({}, projection ? {\n          projection: projection\n        } : {}), {\n          mark: Object.assign(Object.assign({\n            type: 'point',\n            opacity: 1,\n            filled: true\n          }, pick(markDef, ['clip', 'tooltip'])), pointOverlay),\n          encoding: overlayEncoding\n        }));\n      }\n      return normalize(Object.assign(Object.assign({}, outerSpec), {\n        layer: layer\n      }), Object.assign(Object.assign({}, normParams), {\n        config: dropLineAndPointFromConfig(config)\n      }));\n    }\n  }]);\n  return PathOverlayNormalizer;\n}();","map":{"version":3,"sources":["../../../src/normalize/pathoverlay.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isObject } from 'vega-util';\nimport { normalizeEncoding } from '../encoding';\nimport { isMarkDef } from '../mark';\nimport { isUnitSpec } from '../spec/unit';\nimport { stack } from '../stack';\nimport { keys, omit, pick } from '../util';\nfunction dropLineAndPoint(markDef) {\n    const { point: _point, line: _line } = markDef, mark = __rest(markDef, [\"point\", \"line\"]);\n    return keys(mark).length > 1 ? mark : mark.type;\n}\nfunction dropLineAndPointFromConfig(config) {\n    for (const mark of ['line', 'area', 'rule', 'trail']) {\n        if (config[mark]) {\n            config = Object.assign(Object.assign({}, config), { \n                // TODO: remove as any\n                [mark]: omit(config[mark], ['point', 'line']) });\n        }\n    }\n    return config;\n}\nfunction getPointOverlay(markDef, markConfig = {}, encoding) {\n    if (markDef.point === 'transparent') {\n        return { opacity: 0 };\n    }\n    else if (markDef.point) {\n        // truthy : true or object\n        return isObject(markDef.point) ? markDef.point : {};\n    }\n    else if (markDef.point !== undefined) {\n        // false or null\n        return null;\n    }\n    else {\n        // undefined (not disabled)\n        if (markConfig.point || encoding.shape) {\n            // enable point overlay if config[mark].point is truthy or if encoding.shape is provided\n            return isObject(markConfig.point) ? markConfig.point : {};\n        }\n        // markDef.point is defined as falsy\n        return undefined;\n    }\n}\nfunction getLineOverlay(markDef, markConfig = {}) {\n    if (markDef.line) {\n        // true or object\n        return markDef.line === true ? {} : markDef.line;\n    }\n    else if (markDef.line !== undefined) {\n        // false or null\n        return null;\n    }\n    else {\n        // undefined (not disabled)\n        if (markConfig.line) {\n            // enable line overlay if config[mark].line is truthy\n            return markConfig.line === true ? {} : markConfig.line;\n        }\n        // markDef.point is defined as falsy\n        return undefined;\n    }\n}\nexport class PathOverlayNormalizer {\n    constructor() {\n        this.name = 'path-overlay';\n    }\n    hasMatchingType(spec, config) {\n        if (isUnitSpec(spec)) {\n            const { mark, encoding } = spec;\n            const markDef = isMarkDef(mark) ? mark : { type: mark };\n            switch (markDef.type) {\n                case 'line':\n                case 'rule':\n                case 'trail':\n                    return !!getPointOverlay(markDef, config[markDef.type], encoding);\n                case 'area':\n                    return (\n                    // false / null are also included as we want to remove the properties\n                    !!getPointOverlay(markDef, config[markDef.type], encoding) ||\n                        !!getLineOverlay(markDef, config[markDef.type]));\n            }\n        }\n        return false;\n    }\n    run(spec, normParams, normalize) {\n        const { config } = normParams;\n        const { params, projection, mark, encoding: e } = spec, outerSpec = __rest(spec, [\"params\", \"projection\", \"mark\", \"encoding\"]);\n        // Need to call normalizeEncoding because we need the inferred types to correctly determine stack\n        const encoding = normalizeEncoding(e, config);\n        const markDef = isMarkDef(mark) ? mark : { type: mark };\n        const pointOverlay = getPointOverlay(markDef, config[markDef.type], encoding);\n        const lineOverlay = markDef.type === 'area' && getLineOverlay(markDef, config[markDef.type]);\n        const layer = [\n            Object.assign(Object.assign({}, (params ? { params } : {})), { mark: dropLineAndPoint(Object.assign(Object.assign({}, (markDef.type === 'area' && markDef.opacity === undefined && markDef.fillOpacity === undefined\n                    ? { opacity: 0.7 }\n                    : {})), markDef)), \n                // drop shape from encoding as this might be used to trigger point overlay\n                encoding: omit(encoding, ['shape']) })\n        ];\n        // FIXME: determine rules for applying selections.\n        // Need to copy stack config to overlayed layer\n        const stackProps = stack(markDef, encoding);\n        let overlayEncoding = encoding;\n        if (stackProps) {\n            const { fieldChannel: stackFieldChannel, offset } = stackProps;\n            overlayEncoding = Object.assign(Object.assign({}, encoding), { [stackFieldChannel]: Object.assign(Object.assign({}, encoding[stackFieldChannel]), (offset ? { stack: offset } : {})) });\n        }\n        // overlay line layer should be on the edge of area but passing y2/x2 makes\n        // it as \"rule\" mark so that it draws unwanted vertical/horizontal lines.\n        // point overlay also should not have y2/x2 as it does not support.\n        overlayEncoding = omit(overlayEncoding, ['y2', 'x2']);\n        if (lineOverlay) {\n            layer.push(Object.assign(Object.assign({}, (projection ? { projection } : {})), { mark: Object.assign(Object.assign({ type: 'line' }, pick(markDef, ['clip', 'interpolate', 'tension', 'tooltip'])), lineOverlay), encoding: overlayEncoding }));\n        }\n        if (pointOverlay) {\n            layer.push(Object.assign(Object.assign({}, (projection ? { projection } : {})), { mark: Object.assign(Object.assign({ type: 'point', opacity: 1, filled: true }, pick(markDef, ['clip', 'tooltip'])), pointOverlay), encoding: overlayEncoding }));\n        }\n        return normalize(Object.assign(Object.assign({}, outerSpec), { layer }), Object.assign(Object.assign({}, normParams), { config: dropLineAndPointFromConfig(config) }));\n    }\n}\n//# sourceMappingURL=pathoverlay.js.map"]},"metadata":{},"sourceType":"module"}