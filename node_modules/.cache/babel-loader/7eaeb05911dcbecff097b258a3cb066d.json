{"ast":null,"code":"import { normalizeLogicalComposition } from './logical';\nimport { normalizePredicate } from './predicate';\nexport function isFilter(t) {\n  return 'filter' in t;\n}\nexport function isImputeSequence(t) {\n  return (t === null || t === void 0 ? void 0 : t['stop']) !== undefined;\n}\nexport function isLookup(t) {\n  return 'lookup' in t;\n}\nexport function isLookupData(from) {\n  return 'data' in from;\n}\nexport function isLookupSelection(from) {\n  return 'param' in from;\n}\nexport function isPivot(t) {\n  return 'pivot' in t;\n}\nexport function isDensity(t) {\n  return 'density' in t;\n}\nexport function isQuantile(t) {\n  return 'quantile' in t;\n}\nexport function isRegression(t) {\n  return 'regression' in t;\n}\nexport function isLoess(t) {\n  return 'loess' in t;\n}\nexport function isSample(t) {\n  return 'sample' in t;\n}\nexport function isWindow(t) {\n  return 'window' in t;\n}\nexport function isJoinAggregate(t) {\n  return 'joinaggregate' in t;\n}\nexport function isFlatten(t) {\n  return 'flatten' in t;\n}\nexport function isCalculate(t) {\n  return 'calculate' in t;\n}\nexport function isBin(t) {\n  return 'bin' in t;\n}\nexport function isImpute(t) {\n  return 'impute' in t;\n}\nexport function isTimeUnit(t) {\n  return 'timeUnit' in t;\n}\nexport function isAggregate(t) {\n  return 'aggregate' in t;\n}\nexport function isStack(t) {\n  return 'stack' in t;\n}\nexport function isFold(t) {\n  return 'fold' in t;\n}\nexport function normalizeTransform(transform) {\n  return transform.map(function (t) {\n    if (isFilter(t)) {\n      return {\n        filter: normalizeLogicalComposition(t.filter, normalizePredicate)\n      };\n    }\n    return t;\n  });\n}","map":{"version":3,"sources":["../../src/transform.ts"],"names":[],"mappings":"AAKA,SAA4B,2BAA2B,QAAO,WAAW;AAEzE,SAAQ,kBAAkB,QAAkB,aAAa;AA6BzD,OAAM,SAAU,QAAQ,CAAC,CAAY,EAAA;EACnC,OAAO,QAAQ,IAAI,CAAC;AACtB;AA8NA,OAAM,SAAU,gBAAgB,CAAC,CAAqC,EAAA;EACpE,OAAO,CAAA,CAAC,KAAA,IAAA,IAAD,CAAC,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAD,CAAC,CAAG,MAAM,CAAC,MAAK,SAAS;AAClC;AAyGA,OAAM,SAAU,QAAQ,CAAC,CAAY,EAAA;EACnC,OAAO,QAAQ,IAAI,CAAC;AACtB;AAEA,OAAM,SAAU,YAAY,CAAC,IAAkC,EAAA;EAC7D,OAAO,MAAM,IAAI,IAAI;AACvB;AAEA,OAAM,SAAU,iBAAiB,CAAC,IAAkC,EAAA;EAClE,OAAO,OAAO,IAAI,IAAI;AACxB;AA6CA,OAAM,SAAU,OAAO,CAAC,CAAY,EAAA;EAClC,OAAO,OAAO,IAAI,CAAC;AACrB;AAgEA,OAAM,SAAU,SAAS,CAAC,CAAY,EAAA;EACpC,OAAO,SAAS,IAAI,CAAC;AACvB;AA+BA,OAAM,SAAU,UAAU,CAAC,CAAY,EAAA;EACrC,OAAO,UAAU,IAAI,CAAC;AACxB;AAsDA,OAAM,SAAU,YAAY,CAAC,CAAY,EAAA;EACvC,OAAO,YAAY,IAAI,CAAC;AAC1B;AAiCA,OAAM,SAAU,OAAO,CAAC,CAAY,EAAA;EAClC,OAAO,OAAO,IAAI,CAAC;AACrB;AAEA,OAAM,SAAU,QAAQ,CAAC,CAAY,EAAA;EACnC,OAAO,QAAQ,IAAI,CAAC;AACtB;AAEA,OAAM,SAAU,QAAQ,CAAC,CAAY,EAAA;EACnC,OAAO,QAAQ,IAAI,CAAC;AACtB;AAEA,OAAM,SAAU,eAAe,CAAC,CAAY,EAAA;EAC1C,OAAO,eAAe,IAAI,CAAC;AAC7B;AAEA,OAAM,SAAU,SAAS,CAAC,CAAY,EAAA;EACpC,OAAO,SAAS,IAAI,CAAC;AACvB;AACA,OAAM,SAAU,WAAW,CAAC,CAAY,EAAA;EACtC,OAAO,WAAW,IAAI,CAAC;AACzB;AAEA,OAAM,SAAU,KAAK,CAAC,CAAY,EAAA;EAChC,OAAO,KAAK,IAAI,CAAC;AACnB;AAEA,OAAM,SAAU,QAAQ,CAAC,CAAY,EAAA;EACnC,OAAO,QAAQ,IAAI,CAAC;AACtB;AAEA,OAAM,SAAU,UAAU,CAAC,CAAY,EAAA;EACrC,OAAO,UAAU,IAAI,CAAC;AACxB;AAEA,OAAM,SAAU,WAAW,CAAC,CAAY,EAAA;EACtC,OAAO,WAAW,IAAI,CAAC;AACzB;AAEA,OAAM,SAAU,OAAO,CAAC,CAAY,EAAA;EAClC,OAAO,OAAO,IAAI,CAAC;AACrB;AAEA,OAAM,SAAU,MAAM,CAAC,CAAY,EAAA;EACjC,OAAO,MAAM,IAAI,CAAC;AACpB;AAsBA,OAAM,SAAU,kBAAkB,CAAC,SAAsB,EAAA;EACvD,OAAO,SAAS,CAAC,GAAG,CAAC,UAAA,CAAC,EAAG;IACvB,IAAI,QAAQ,CAAC,CAAC,CAAC,EAAE;MACf,OAAO;QACL,MAAM,EAAE,2BAA2B,CAAC,CAAC,CAAC,MAAM,EAAE,kBAAkB;OACjE;IACF;IACD,OAAO,CAAC;EACV,CAAC,CAAC;AACJ","sourceRoot":"","sourcesContent":["import { normalizeLogicalComposition } from './logical';\nimport { normalizePredicate } from './predicate';\nexport function isFilter(t) {\n    return 'filter' in t;\n}\nexport function isImputeSequence(t) {\n    return (t === null || t === void 0 ? void 0 : t['stop']) !== undefined;\n}\nexport function isLookup(t) {\n    return 'lookup' in t;\n}\nexport function isLookupData(from) {\n    return 'data' in from;\n}\nexport function isLookupSelection(from) {\n    return 'param' in from;\n}\nexport function isPivot(t) {\n    return 'pivot' in t;\n}\nexport function isDensity(t) {\n    return 'density' in t;\n}\nexport function isQuantile(t) {\n    return 'quantile' in t;\n}\nexport function isRegression(t) {\n    return 'regression' in t;\n}\nexport function isLoess(t) {\n    return 'loess' in t;\n}\nexport function isSample(t) {\n    return 'sample' in t;\n}\nexport function isWindow(t) {\n    return 'window' in t;\n}\nexport function isJoinAggregate(t) {\n    return 'joinaggregate' in t;\n}\nexport function isFlatten(t) {\n    return 'flatten' in t;\n}\nexport function isCalculate(t) {\n    return 'calculate' in t;\n}\nexport function isBin(t) {\n    return 'bin' in t;\n}\nexport function isImpute(t) {\n    return 'impute' in t;\n}\nexport function isTimeUnit(t) {\n    return 'timeUnit' in t;\n}\nexport function isAggregate(t) {\n    return 'aggregate' in t;\n}\nexport function isStack(t) {\n    return 'stack' in t;\n}\nexport function isFold(t) {\n    return 'fold' in t;\n}\nexport function normalizeTransform(transform) {\n    return transform.map(t => {\n        if (isFilter(t)) {\n            return {\n                filter: normalizeLogicalComposition(t.filter, normalizePredicate)\n            };\n        }\n        return t;\n    });\n}\n//# sourceMappingURL=transform.js.map"]},"metadata":{},"sourceType":"module"}