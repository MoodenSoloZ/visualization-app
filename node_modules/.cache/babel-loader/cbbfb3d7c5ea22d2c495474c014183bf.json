{"ast":null,"code":"import _slicedToArray from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { parseSelector } from 'vega-event-selector';\nimport { array, isObject, isString, stringValue } from 'vega-util';\nimport { selectionCompilers, STORE } from '.';\nimport { warn } from '../../log';\nimport { duplicate, entries, replacePathInField, varName } from '../../util';\nimport { OutputNode } from '../data/dataflow';\nimport { FilterNode } from '../data/filter';\nimport { DataSourceType } from '../../data';\nexport function parseUnitSelection(model, selDefs) {\n  var _a;\n  var selCmpts = {};\n  var selectionConfig = model.config.selection;\n  if (!selDefs || !selDefs.length) return selCmpts;\n  var _iterator = _createForOfIteratorHelper(selDefs),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var def = _step.value;\n      var name = varName(def.name);\n      var selDef = def.select;\n      var type = isString(selDef) ? selDef : selDef.type;\n      var defaults = isObject(selDef) ? duplicate(selDef) : {\n        type: type\n      };\n      // Set default values from config if a property hasn't been specified,\n      // or if it is true. E.g., \"translate\": true should use the default\n      // event handlers for translate. However, true may be a valid value for\n      // a property (e.g., \"nearest\": true).\n      var cfg = selectionConfig[type];\n      for (var key in cfg) {\n        // Project transform applies its defaults.\n        if (key === 'fields' || key === 'encodings') {\n          continue;\n        }\n        if (key === 'mark') {\n          defaults[key] = Object.assign(Object.assign({}, cfg[key]), defaults[key]);\n        }\n        if (defaults[key] === undefined || defaults[key] === true) {\n          defaults[key] = (_a = cfg[key]) !== null && _a !== void 0 ? _a : defaults[key];\n        }\n      }\n      var selCmpt = selCmpts[name] = Object.assign(Object.assign({}, defaults), {\n        name: name,\n        type: type,\n        init: def.value,\n        bind: def.bind,\n        events: isString(defaults.on) ? parseSelector(defaults.on, 'scope') : array(duplicate(defaults.on))\n      });\n      var _iterator2 = _createForOfIteratorHelper(selectionCompilers),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var c = _step2.value;\n          if (c.defined(selCmpt) && c.parse) {\n            c.parse(model, selCmpt, def);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return selCmpts;\n}\nexport function parseSelectionPredicate(model, pred, dfnode) {\n  var datum = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'datum';\n  var name = isString(pred) ? pred : pred.param;\n  var vname = varName(name);\n  var store = stringValue(vname + STORE);\n  var selCmpt;\n  try {\n    selCmpt = model.getSelectionComponent(vname, name);\n  } catch (e) {\n    // If a selection isn't found, treat as a variable parameter and coerce to boolean.\n    return \"!!\".concat(vname);\n  }\n  if (selCmpt.project.timeUnit) {\n    var child = dfnode !== null && dfnode !== void 0 ? dfnode : model.component.data.raw;\n    var tunode = selCmpt.project.timeUnit.clone();\n    if (child.parent) {\n      tunode.insertAsParentOf(child);\n    } else {\n      child.parent = tunode;\n    }\n  }\n  var fn = selCmpt.project.hasSelectionId ? 'vlSelectionIdTest(' : 'vlSelectionTest(';\n  var resolve = selCmpt.resolve === 'global' ? ')' : \", \".concat(stringValue(selCmpt.resolve), \")\");\n  var test = \"\".concat(fn).concat(store, \", \").concat(datum).concat(resolve);\n  var length = \"length(data(\".concat(store, \"))\");\n  return pred.empty === false ? \"\".concat(length, \" && \").concat(test) : \"!\".concat(length, \" || \").concat(test);\n}\nexport function parseSelectionExtent(model, name, extent) {\n  var vname = varName(name);\n  var encoding = extent['encoding'];\n  var field = extent['field'];\n  var selCmpt;\n  try {\n    selCmpt = model.getSelectionComponent(vname, name);\n  } catch (e) {\n    // If a selection isn't found, treat it as a variable parameter.\n    return vname;\n  }\n  if (!encoding && !field) {\n    field = selCmpt.project.items[0].field;\n    if (selCmpt.project.items.length > 1) {\n      warn('A \"field\" or \"encoding\" must be specified when using a selection as a scale domain. ' + \"Using \\\"field\\\": \".concat(stringValue(field), \".\"));\n    }\n  } else if (encoding && !field) {\n    var encodings = selCmpt.project.items.filter(function (p) {\n      return p.channel === encoding;\n    });\n    if (!encodings.length || encodings.length > 1) {\n      field = selCmpt.project.items[0].field;\n      warn((!encodings.length ? 'No ' : 'Multiple ') + \"matching \".concat(stringValue(encoding), \" encoding found for selection \").concat(stringValue(extent.param), \". \") + \"Using \\\"field\\\": \".concat(stringValue(field), \".\"));\n    } else {\n      field = encodings[0].field;\n    }\n  }\n  return \"\".concat(selCmpt.name, \"[\").concat(stringValue(replacePathInField(field)), \"]\");\n}\nexport function materializeSelections(model, main) {\n  var _a;\n  var _iterator3 = _createForOfIteratorHelper(entries((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _step3$value = _slicedToArray(_step3.value, 2),\n        selection = _step3$value[0],\n        selCmpt = _step3$value[1];\n      var lookupName = model.getName(\"lookup_\".concat(selection));\n      model.component.data.outputNodes[lookupName] = selCmpt.materialized = new OutputNode(new FilterNode(main, model, {\n        param: selection\n      }), lookupName, DataSourceType.Lookup, model.component.data.outputNodeRefCounts);\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n}","map":{"version":3,"sources":["../../../../src/compile/selection/parse.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { parseSelector } from 'vega-event-selector';\nimport { array, isObject, isString, stringValue } from 'vega-util';\nimport { selectionCompilers, STORE } from '.';\nimport { warn } from '../../log';\nimport { duplicate, entries, replacePathInField, varName } from '../../util';\nimport { OutputNode } from '../data/dataflow';\nimport { FilterNode } from '../data/filter';\nimport { DataSourceType } from '../../data';\nexport function parseUnitSelection(model, selDefs) {\n    var _a;\n    const selCmpts = {};\n    const selectionConfig = model.config.selection;\n    if (!selDefs || !selDefs.length)\n        return selCmpts;\n    for (const def of selDefs) {\n        const name = varName(def.name);\n        const selDef = def.select;\n        const type = isString(selDef) ? selDef : selDef.type;\n        const defaults = isObject(selDef) ? duplicate(selDef) : { type };\n        // Set default values from config if a property hasn't been specified,\n        // or if it is true. E.g., \"translate\": true should use the default\n        // event handlers for translate. However, true may be a valid value for\n        // a property (e.g., \"nearest\": true).\n        const cfg = selectionConfig[type];\n        for (const key in cfg) {\n            // Project transform applies its defaults.\n            if (key === 'fields' || key === 'encodings') {\n                continue;\n            }\n            if (key === 'mark') {\n                defaults[key] = Object.assign(Object.assign({}, cfg[key]), defaults[key]);\n            }\n            if (defaults[key] === undefined || defaults[key] === true) {\n                defaults[key] = (_a = cfg[key]) !== null && _a !== void 0 ? _a : defaults[key];\n            }\n        }\n        const selCmpt = (selCmpts[name] = Object.assign(Object.assign({}, defaults), { name,\n            type, init: def.value, bind: def.bind, events: isString(defaults.on) ? parseSelector(defaults.on, 'scope') : array(duplicate(defaults.on)) }));\n        for (const c of selectionCompilers) {\n            if (c.defined(selCmpt) && c.parse) {\n                c.parse(model, selCmpt, def);\n            }\n        }\n    }\n    return selCmpts;\n}\nexport function parseSelectionPredicate(model, pred, dfnode, datum = 'datum') {\n    const name = isString(pred) ? pred : pred.param;\n    const vname = varName(name);\n    const store = stringValue(vname + STORE);\n    let selCmpt;\n    try {\n        selCmpt = model.getSelectionComponent(vname, name);\n    }\n    catch (e) {\n        // If a selection isn't found, treat as a variable parameter and coerce to boolean.\n        return `!!${vname}`;\n    }\n    if (selCmpt.project.timeUnit) {\n        const child = dfnode !== null && dfnode !== void 0 ? dfnode : model.component.data.raw;\n        const tunode = selCmpt.project.timeUnit.clone();\n        if (child.parent) {\n            tunode.insertAsParentOf(child);\n        }\n        else {\n            child.parent = tunode;\n        }\n    }\n    const fn = selCmpt.project.hasSelectionId ? 'vlSelectionIdTest(' : 'vlSelectionTest(';\n    const resolve = selCmpt.resolve === 'global' ? ')' : `, ${stringValue(selCmpt.resolve)})`;\n    const test = `${fn}${store}, ${datum}${resolve}`;\n    const length = `length(data(${store}))`;\n    return pred.empty === false ? `${length} && ${test}` : `!${length} || ${test}`;\n}\nexport function parseSelectionExtent(model, name, extent) {\n    const vname = varName(name);\n    const encoding = extent['encoding'];\n    let field = extent['field'];\n    let selCmpt;\n    try {\n        selCmpt = model.getSelectionComponent(vname, name);\n    }\n    catch (e) {\n        // If a selection isn't found, treat it as a variable parameter.\n        return vname;\n    }\n    if (!encoding && !field) {\n        field = selCmpt.project.items[0].field;\n        if (selCmpt.project.items.length > 1) {\n            warn('A \"field\" or \"encoding\" must be specified when using a selection as a scale domain. ' +\n                `Using \"field\": ${stringValue(field)}.`);\n        }\n    }\n    else if (encoding && !field) {\n        const encodings = selCmpt.project.items.filter(p => p.channel === encoding);\n        if (!encodings.length || encodings.length > 1) {\n            field = selCmpt.project.items[0].field;\n            warn((!encodings.length ? 'No ' : 'Multiple ') +\n                `matching ${stringValue(encoding)} encoding found for selection ${stringValue(extent.param)}. ` +\n                `Using \"field\": ${stringValue(field)}.`);\n        }\n        else {\n            field = encodings[0].field;\n        }\n    }\n    return `${selCmpt.name}[${stringValue(replacePathInField(field))}]`;\n}\nexport function materializeSelections(model, main) {\n    var _a;\n    for (const [selection, selCmpt] of entries((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})) {\n        const lookupName = model.getName(`lookup_${selection}`);\n        model.component.data.outputNodes[lookupName] = selCmpt.materialized = new OutputNode(new FilterNode(main, model, { param: selection }), lookupName, DataSourceType.Lookup, model.component.data.outputNodeRefCounts);\n    }\n}\n//# sourceMappingURL=parse.js.map"]},"metadata":{},"sourceType":"module"}