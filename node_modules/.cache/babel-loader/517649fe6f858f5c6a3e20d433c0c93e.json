{"ast":null,"code":"import _defineProperty from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toArray from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/toArray.js\";\nimport _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { isString } from 'vega-util';\nimport { binToString, isBinning, isParameterExtent } from '../../bin';\nimport { binRequiresRange, isTypedFieldDef, normalizeBin, vgField } from '../../channeldef';\nimport { duplicate, hash as _hash, isEmpty, keys, replacePathInField, unique, vals } from '../../util';\nimport { binFormatExpression } from '../format';\nimport { isUnitModel } from '../model';\nimport { parseSelectionExtent } from '../selection/parse';\nimport { DataFlowNode } from './dataflow';\nfunction rangeFormula(model, fieldDef, channel, config) {\n  var _a, _b;\n  if (binRequiresRange(fieldDef, channel)) {\n    // read format from axis or legend, if there is no format then use config.numberFormat\n    var guide = isUnitModel(model) ? (_b = (_a = model.axis(channel)) !== null && _a !== void 0 ? _a : model.legend(channel)) !== null && _b !== void 0 ? _b : {} : {};\n    var startField = vgField(fieldDef, {\n      expr: 'datum'\n    });\n    var endField = vgField(fieldDef, {\n      expr: 'datum',\n      binSuffix: 'end'\n    });\n    return {\n      formulaAs: vgField(fieldDef, {\n        binSuffix: 'range',\n        forAs: true\n      }),\n      formula: binFormatExpression(startField, endField, guide.format, guide.formatType, config)\n    };\n  }\n  return {};\n}\nfunction binKey(bin, field) {\n  return \"\".concat(binToString(bin), \"_\").concat(field);\n}\nfunction getSignalsFromModel(model, key) {\n  return {\n    signal: model.getName(\"\".concat(key, \"_bins\")),\n    extentSignal: model.getName(\"\".concat(key, \"_extent\"))\n  };\n}\nexport function getBinSignalName(model, field, bin) {\n  var _a;\n  var normalizedBin = (_a = normalizeBin(bin, undefined)) !== null && _a !== void 0 ? _a : {};\n  var key = binKey(normalizedBin, field);\n  return model.getName(\"\".concat(key, \"_bins\"));\n}\nfunction isBinTransform(t) {\n  return 'as' in t;\n}\nfunction createBinComponent(t, bin, model) {\n  var as;\n  var span;\n  if (isBinTransform(t)) {\n    as = isString(t.as) ? [t.as, \"\".concat(t.as, \"_end\")] : [t.as[0], t.as[1]];\n  } else {\n    as = [vgField(t, {\n      forAs: true\n    }), vgField(t, {\n      binSuffix: 'end',\n      forAs: true\n    })];\n  }\n  var normalizedBin = Object.assign({}, normalizeBin(bin, undefined));\n  var key = binKey(normalizedBin, t.field);\n  var _getSignalsFromModel = getSignalsFromModel(model, key),\n    signal = _getSignalsFromModel.signal,\n    extentSignal = _getSignalsFromModel.extentSignal;\n  if (isParameterExtent(normalizedBin.extent)) {\n    var ext = normalizedBin.extent;\n    span = parseSelectionExtent(model, ext.param, ext);\n    delete normalizedBin.extent; // Vega-Lite selection extent map to Vega's span property.\n  }\n\n  var binComponent = Object.assign(Object.assign(Object.assign({\n    bin: normalizedBin,\n    field: t.field,\n    as: [as]\n  }, signal ? {\n    signal: signal\n  } : {}), extentSignal ? {\n    extentSignal: extentSignal\n  } : {}), span ? {\n    span: span\n  } : {});\n  return {\n    key: key,\n    binComponent: binComponent\n  };\n}\nexport var BinNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(BinNode, _DataFlowNode);\n  var _super = _createSuper(BinNode);\n  function BinNode(parent, bins) {\n    var _this;\n    _classCallCheck(this, BinNode);\n    _this = _super.call(this, parent);\n    _this.bins = bins;\n    return _this;\n  }\n  _createClass(BinNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new BinNode(null, duplicate(this.bins));\n    }\n  }, {\n    key: \"merge\",\n    value:\n    /**\n     * Merge bin nodes. This method either integrates the bin config from the other node\n     * or if this node already has a bin config, renames the corresponding signal in the model.\n     */\n    function merge(other, renameSignal) {\n      var _iterator = _createForOfIteratorHelper(keys(other.bins)),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          if (key in this.bins) {\n            renameSignal(other.bins[key].signal, this.bins[key].signal);\n            // Ensure that we don't have duplicate names for signal pairs\n            this.bins[key].as = unique([].concat(_toConsumableArray(this.bins[key].as), _toConsumableArray(other.bins[key].as)), _hash);\n          } else {\n            this.bins[key] = other.bins[key];\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var _iterator2 = _createForOfIteratorHelper(other.children),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var child = _step2.value;\n          other.removeChild(child);\n          child.parent = this;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      other.remove();\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set(vals(this.bins).map(function (c) {\n        return c.as;\n      }).flat(2));\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return new Set(vals(this.bins).map(function (c) {\n        return c.field;\n      }));\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"Bin \".concat(_hash(this.bins));\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      return vals(this.bins).flatMap(function (bin) {\n        var transform = [];\n        var _bin$as = _toArray(bin.as),\n          binAs = _bin$as[0],\n          remainingAs = _bin$as.slice(1);\n        var _a = bin.bin,\n          extent = _a.extent,\n          params = __rest(_a, [\"extent\"]);\n        var binTrans = Object.assign(Object.assign(Object.assign({\n          type: 'bin',\n          field: replacePathInField(bin.field),\n          as: binAs,\n          signal: bin.signal\n        }, !isParameterExtent(extent) ? {\n          extent: extent\n        } : {\n          extent: null\n        }), bin.span ? {\n          span: {\n            signal: \"span(\".concat(bin.span, \")\")\n          }\n        } : {}), params);\n        if (!extent && bin.extentSignal) {\n          transform.push({\n            type: 'extent',\n            field: replacePathInField(bin.field),\n            signal: bin.extentSignal\n          });\n          binTrans.extent = {\n            signal: bin.extentSignal\n          };\n        }\n        transform.push(binTrans);\n        var _iterator3 = _createForOfIteratorHelper(remainingAs),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var as = _step3.value;\n            for (var i = 0; i < 2; i++) {\n              transform.push({\n                type: 'formula',\n                expr: vgField({\n                  field: binAs[i]\n                }, {\n                  expr: 'datum'\n                }),\n                as: as[i]\n              });\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n        if (bin.formula) {\n          transform.push({\n            type: 'formula',\n            expr: bin.formula,\n            as: bin.formulaAs\n          });\n        }\n        return transform;\n      });\n    }\n  }], [{\n    key: \"makeFromEncoding\",\n    value: function makeFromEncoding(parent, model) {\n      var bins = model.reduceFieldDef(function (binComponentIndex, fieldDef, channel) {\n        if (isTypedFieldDef(fieldDef) && isBinning(fieldDef.bin)) {\n          var _createBinComponent = createBinComponent(fieldDef, fieldDef.bin, model),\n            key = _createBinComponent.key,\n            binComponent = _createBinComponent.binComponent;\n          binComponentIndex[key] = Object.assign(Object.assign(Object.assign({}, binComponent), binComponentIndex[key]), rangeFormula(model, fieldDef, channel, model.config));\n        }\n        return binComponentIndex;\n      }, {});\n      if (isEmpty(bins)) {\n        return null;\n      }\n      return new BinNode(parent, bins);\n    }\n    /**\n     * Creates a bin node from BinTransform.\n     * The optional parameter should provide\n     */\n  }, {\n    key: \"makeFromTransform\",\n    value: function makeFromTransform(parent, t, model) {\n      var _createBinComponent2 = createBinComponent(t, t.bin, model),\n        key = _createBinComponent2.key,\n        binComponent = _createBinComponent2.binComponent;\n      return new BinNode(parent, _defineProperty({}, key, binComponent));\n    }\n  }]);\n  return BinNode;\n}(DataFlowNode);","map":{"version":3,"sources":["../../../../src/compile/data/bin.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isString } from 'vega-util';\nimport { binToString, isBinning, isParameterExtent } from '../../bin';\nimport { binRequiresRange, isTypedFieldDef, normalizeBin, vgField } from '../../channeldef';\nimport { duplicate, hash, isEmpty, keys, replacePathInField, unique, vals } from '../../util';\nimport { binFormatExpression } from '../format';\nimport { isUnitModel } from '../model';\nimport { parseSelectionExtent } from '../selection/parse';\nimport { DataFlowNode } from './dataflow';\nfunction rangeFormula(model, fieldDef, channel, config) {\n    var _a, _b;\n    if (binRequiresRange(fieldDef, channel)) {\n        // read format from axis or legend, if there is no format then use config.numberFormat\n        const guide = isUnitModel(model)\n            ? (_b = (_a = model.axis(channel)) !== null && _a !== void 0 ? _a : model.legend(channel)) !== null && _b !== void 0 ? _b : {}\n            : {};\n        const startField = vgField(fieldDef, { expr: 'datum' });\n        const endField = vgField(fieldDef, { expr: 'datum', binSuffix: 'end' });\n        return {\n            formulaAs: vgField(fieldDef, { binSuffix: 'range', forAs: true }),\n            formula: binFormatExpression(startField, endField, guide.format, guide.formatType, config)\n        };\n    }\n    return {};\n}\nfunction binKey(bin, field) {\n    return `${binToString(bin)}_${field}`;\n}\nfunction getSignalsFromModel(model, key) {\n    return {\n        signal: model.getName(`${key}_bins`),\n        extentSignal: model.getName(`${key}_extent`)\n    };\n}\nexport function getBinSignalName(model, field, bin) {\n    var _a;\n    const normalizedBin = (_a = normalizeBin(bin, undefined)) !== null && _a !== void 0 ? _a : {};\n    const key = binKey(normalizedBin, field);\n    return model.getName(`${key}_bins`);\n}\nfunction isBinTransform(t) {\n    return 'as' in t;\n}\nfunction createBinComponent(t, bin, model) {\n    let as;\n    let span;\n    if (isBinTransform(t)) {\n        as = isString(t.as) ? [t.as, `${t.as}_end`] : [t.as[0], t.as[1]];\n    }\n    else {\n        as = [vgField(t, { forAs: true }), vgField(t, { binSuffix: 'end', forAs: true })];\n    }\n    const normalizedBin = Object.assign({}, normalizeBin(bin, undefined));\n    const key = binKey(normalizedBin, t.field);\n    const { signal, extentSignal } = getSignalsFromModel(model, key);\n    if (isParameterExtent(normalizedBin.extent)) {\n        const ext = normalizedBin.extent;\n        span = parseSelectionExtent(model, ext.param, ext);\n        delete normalizedBin.extent; // Vega-Lite selection extent map to Vega's span property.\n    }\n    const binComponent = Object.assign(Object.assign(Object.assign({ bin: normalizedBin, field: t.field, as: [as] }, (signal ? { signal } : {})), (extentSignal ? { extentSignal } : {})), (span ? { span } : {}));\n    return { key, binComponent };\n}\nexport class BinNode extends DataFlowNode {\n    constructor(parent, bins) {\n        super(parent);\n        this.bins = bins;\n    }\n    clone() {\n        return new BinNode(null, duplicate(this.bins));\n    }\n    static makeFromEncoding(parent, model) {\n        const bins = model.reduceFieldDef((binComponentIndex, fieldDef, channel) => {\n            if (isTypedFieldDef(fieldDef) && isBinning(fieldDef.bin)) {\n                const { key, binComponent } = createBinComponent(fieldDef, fieldDef.bin, model);\n                binComponentIndex[key] = Object.assign(Object.assign(Object.assign({}, binComponent), binComponentIndex[key]), rangeFormula(model, fieldDef, channel, model.config));\n            }\n            return binComponentIndex;\n        }, {});\n        if (isEmpty(bins)) {\n            return null;\n        }\n        return new BinNode(parent, bins);\n    }\n    /**\n     * Creates a bin node from BinTransform.\n     * The optional parameter should provide\n     */\n    static makeFromTransform(parent, t, model) {\n        const { key, binComponent } = createBinComponent(t, t.bin, model);\n        return new BinNode(parent, {\n            [key]: binComponent\n        });\n    }\n    /**\n     * Merge bin nodes. This method either integrates the bin config from the other node\n     * or if this node already has a bin config, renames the corresponding signal in the model.\n     */\n    merge(other, renameSignal) {\n        for (const key of keys(other.bins)) {\n            if (key in this.bins) {\n                renameSignal(other.bins[key].signal, this.bins[key].signal);\n                // Ensure that we don't have duplicate names for signal pairs\n                this.bins[key].as = unique([...this.bins[key].as, ...other.bins[key].as], hash);\n            }\n            else {\n                this.bins[key] = other.bins[key];\n            }\n        }\n        for (const child of other.children) {\n            other.removeChild(child);\n            child.parent = this;\n        }\n        other.remove();\n    }\n    producedFields() {\n        return new Set(vals(this.bins)\n            .map(c => c.as)\n            .flat(2));\n    }\n    dependentFields() {\n        return new Set(vals(this.bins).map(c => c.field));\n    }\n    hash() {\n        return `Bin ${hash(this.bins)}`;\n    }\n    assemble() {\n        return vals(this.bins).flatMap(bin => {\n            const transform = [];\n            const [binAs, ...remainingAs] = bin.as;\n            const _a = bin.bin, { extent } = _a, params = __rest(_a, [\"extent\"]);\n            const binTrans = Object.assign(Object.assign(Object.assign({ type: 'bin', field: replacePathInField(bin.field), as: binAs, signal: bin.signal }, (!isParameterExtent(extent) ? { extent } : { extent: null })), (bin.span ? { span: { signal: `span(${bin.span})` } } : {})), params);\n            if (!extent && bin.extentSignal) {\n                transform.push({\n                    type: 'extent',\n                    field: replacePathInField(bin.field),\n                    signal: bin.extentSignal\n                });\n                binTrans.extent = { signal: bin.extentSignal };\n            }\n            transform.push(binTrans);\n            for (const as of remainingAs) {\n                for (let i = 0; i < 2; i++) {\n                    transform.push({\n                        type: 'formula',\n                        expr: vgField({ field: binAs[i] }, { expr: 'datum' }),\n                        as: as[i]\n                    });\n                }\n            }\n            if (bin.formula) {\n                transform.push({\n                    type: 'formula',\n                    expr: bin.formula,\n                    as: bin.formulaAs\n                });\n            }\n            return transform;\n        });\n    }\n}\n//# sourceMappingURL=bin.js.map"]},"metadata":{},"sourceType":"module"}