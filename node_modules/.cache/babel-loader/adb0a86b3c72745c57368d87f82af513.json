{"ast":null,"code":"import _defineProperty from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _slicedToArray from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { vgField } from '../../channeldef';\nimport { getTimeUnitParts, normalizeTimeUnit } from '../../timeunit';\nimport { duplicate, entries, hash as _hash, isEmpty, replacePathInField, vals } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport var TimeUnitNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(TimeUnitNode, _DataFlowNode);\n  var _super = _createSuper(TimeUnitNode);\n  function TimeUnitNode(parent, formula) {\n    var _this;\n    _classCallCheck(this, TimeUnitNode);\n    _this = _super.call(this, parent);\n    _this.formula = formula;\n    return _this;\n  }\n  _createClass(TimeUnitNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new TimeUnitNode(null, duplicate(this.formula));\n    }\n  }, {\n    key: \"merge\",\n    value:\n    /**\n     * Merge together TimeUnitNodes assigning the children of `other` to `this`\n     * and removing `other`.\n     */\n    function merge(other) {\n      this.formula = Object.assign({}, this.formula);\n      // if the same hash happen twice, merge\n      for (var key in other.formula) {\n        if (!this.formula[key]) {\n          // copy if it's not a duplicate\n          this.formula[key] = other.formula[key];\n        }\n      }\n      var _iterator = _createForOfIteratorHelper(other.children),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var child = _step.value;\n          other.removeChild(child);\n          child.parent = this;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      other.remove();\n    }\n    /**\n     * Remove time units coming from the other node.\n     */\n  }, {\n    key: \"removeFormulas\",\n    value: function removeFormulas(fields) {\n      var newFormula = {};\n      var _iterator2 = _createForOfIteratorHelper(entries(this.formula)),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n            key = _step2$value[0],\n            timeUnit = _step2$value[1];\n          if (!fields.has(timeUnit.as)) {\n            newFormula[key] = timeUnit;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      this.formula = newFormula;\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set(vals(this.formula).map(function (f) {\n        return f.as;\n      }));\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return new Set(vals(this.formula).map(function (f) {\n        return f.field;\n      }));\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"TimeUnit \".concat(_hash(this.formula));\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      var transforms = [];\n      var _iterator3 = _createForOfIteratorHelper(vals(this.formula)),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var f = _step3.value;\n          var field = f.field,\n            as = f.as,\n            timeUnit = f.timeUnit;\n          var _a = normalizeTimeUnit(timeUnit),\n            _a2 = _a,\n            unit = _a2.unit,\n            utc = _a2.utc,\n            params = __rest(_a, [\"unit\", \"utc\"]);\n          transforms.push(Object.assign(Object.assign(Object.assign(Object.assign({\n            field: replacePathInField(field),\n            type: 'timeunit'\n          }, unit ? {\n            units: getTimeUnitParts(unit)\n          } : {}), utc ? {\n            timezone: 'utc'\n          } : {}), params), {\n            as: [as, \"\".concat(as, \"_end\")]\n          }));\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return transforms;\n    }\n  }], [{\n    key: \"makeFromEncoding\",\n    value: function makeFromEncoding(parent, model) {\n      var formula = model.reduceFieldDef(function (timeUnitComponent, fieldDef) {\n        var field = fieldDef.field,\n          timeUnit = fieldDef.timeUnit;\n        if (timeUnit) {\n          var as = vgField(fieldDef, {\n            forAs: true\n          });\n          timeUnitComponent[_hash({\n            as: as,\n            field: field,\n            timeUnit: timeUnit\n          })] = {\n            as: as,\n            field: field,\n            timeUnit: timeUnit\n          };\n        }\n        return timeUnitComponent;\n      }, {});\n      if (isEmpty(formula)) {\n        return null;\n      }\n      return new TimeUnitNode(parent, formula);\n    }\n  }, {\n    key: \"makeFromTransform\",\n    value: function makeFromTransform(parent, t) {\n      var _a = Object.assign({}, t),\n        timeUnit = _a.timeUnit,\n        other = __rest(_a, [\"timeUnit\"]);\n      var normalizedTimeUnit = normalizeTimeUnit(timeUnit);\n      var component = Object.assign(Object.assign({}, other), {\n        timeUnit: normalizedTimeUnit\n      });\n      return new TimeUnitNode(parent, _defineProperty({}, _hash(component), component));\n    }\n  }]);\n  return TimeUnitNode;\n}(DataFlowNode);","map":{"version":3,"sources":["../../../../src/compile/data/timeunit.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { vgField } from '../../channeldef';\nimport { getTimeUnitParts, normalizeTimeUnit } from '../../timeunit';\nimport { duplicate, entries, hash, isEmpty, replacePathInField, vals } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class TimeUnitNode extends DataFlowNode {\n    constructor(parent, formula) {\n        super(parent);\n        this.formula = formula;\n    }\n    clone() {\n        return new TimeUnitNode(null, duplicate(this.formula));\n    }\n    static makeFromEncoding(parent, model) {\n        const formula = model.reduceFieldDef((timeUnitComponent, fieldDef) => {\n            const { field, timeUnit } = fieldDef;\n            if (timeUnit) {\n                const as = vgField(fieldDef, { forAs: true });\n                timeUnitComponent[hash({\n                    as,\n                    field,\n                    timeUnit\n                })] = {\n                    as,\n                    field,\n                    timeUnit\n                };\n            }\n            return timeUnitComponent;\n        }, {});\n        if (isEmpty(formula)) {\n            return null;\n        }\n        return new TimeUnitNode(parent, formula);\n    }\n    static makeFromTransform(parent, t) {\n        const _a = Object.assign({}, t), { timeUnit } = _a, other = __rest(_a, [\"timeUnit\"]);\n        const normalizedTimeUnit = normalizeTimeUnit(timeUnit);\n        const component = Object.assign(Object.assign({}, other), { timeUnit: normalizedTimeUnit });\n        return new TimeUnitNode(parent, {\n            [hash(component)]: component\n        });\n    }\n    /**\n     * Merge together TimeUnitNodes assigning the children of `other` to `this`\n     * and removing `other`.\n     */\n    merge(other) {\n        this.formula = Object.assign({}, this.formula);\n        // if the same hash happen twice, merge\n        for (const key in other.formula) {\n            if (!this.formula[key]) {\n                // copy if it's not a duplicate\n                this.formula[key] = other.formula[key];\n            }\n        }\n        for (const child of other.children) {\n            other.removeChild(child);\n            child.parent = this;\n        }\n        other.remove();\n    }\n    /**\n     * Remove time units coming from the other node.\n     */\n    removeFormulas(fields) {\n        const newFormula = {};\n        for (const [key, timeUnit] of entries(this.formula)) {\n            if (!fields.has(timeUnit.as)) {\n                newFormula[key] = timeUnit;\n            }\n        }\n        this.formula = newFormula;\n    }\n    producedFields() {\n        return new Set(vals(this.formula).map(f => f.as));\n    }\n    dependentFields() {\n        return new Set(vals(this.formula).map(f => f.field));\n    }\n    hash() {\n        return `TimeUnit ${hash(this.formula)}`;\n    }\n    assemble() {\n        const transforms = [];\n        for (const f of vals(this.formula)) {\n            const { field, as, timeUnit } = f;\n            const _a = normalizeTimeUnit(timeUnit), { unit, utc } = _a, params = __rest(_a, [\"unit\", \"utc\"]);\n            transforms.push(Object.assign(Object.assign(Object.assign(Object.assign({ field: replacePathInField(field), type: 'timeunit' }, (unit ? { units: getTimeUnitParts(unit) } : {})), (utc ? { timezone: 'utc' } : {})), params), { as: [as, `${as}_end`] }));\n        }\n        return transforms;\n    }\n}\n//# sourceMappingURL=timeunit.js.map"]},"metadata":{},"sourceType":"module"}