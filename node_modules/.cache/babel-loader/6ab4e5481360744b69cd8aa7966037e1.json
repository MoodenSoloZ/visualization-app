{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { LEGEND_SCALE_CHANNELS } from '../../legend';\nimport { keys, replaceAll, stringify, vals } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { mergeLegendComponent } from './parse';\nfunction setLegendEncode(legend, part, vgProp, vgRef) {\n  var _a, _b, _c;\n  var _d, _e;\n  (_a = legend.encode) !== null && _a !== void 0 ? _a : legend.encode = {};\n  (_b = (_d = legend.encode)[part]) !== null && _b !== void 0 ? _b : _d[part] = {};\n  (_c = (_e = legend.encode[part]).update) !== null && _c !== void 0 ? _c : _e.update = {};\n  // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n  legend.encode[part].update[vgProp] = vgRef;\n}\nexport function assembleLegends(model) {\n  var legendComponentIndex = model.component.legends;\n  var legendByDomain = {};\n  var _iterator = _createForOfIteratorHelper(keys(legendComponentIndex)),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var channel = _step.value;\n      var scaleComponent = model.getScaleComponent(channel);\n      var domainHash = stringify(scaleComponent.get('domains'));\n      if (legendByDomain[domainHash]) {\n        var _iterator2 = _createForOfIteratorHelper(legendByDomain[domainHash]),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var mergedLegendComponent = _step2.value;\n            var merged = mergeLegendComponent(mergedLegendComponent, legendComponentIndex[channel]);\n            if (!merged) {\n              // If cannot merge, need to add this legend separately\n              legendByDomain[domainHash].push(legendComponentIndex[channel]);\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      } else {\n        legendByDomain[domainHash] = [legendComponentIndex[channel].clone()];\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var legends = vals(legendByDomain).flat().map(function (l) {\n    return assembleLegend(l, model.config);\n  }).filter(function (l) {\n    return l !== undefined;\n  });\n  return legends;\n}\nexport function assembleLegend(legendCmpt, config) {\n  var _a, _b, _c;\n  var _d = legendCmpt.combine(),\n    disable = _d.disable,\n    labelExpr = _d.labelExpr,\n    selections = _d.selections,\n    legend = __rest(_d, [\"disable\", \"labelExpr\", \"selections\"]);\n  if (disable) {\n    return undefined;\n  }\n  if (config.aria === false && legend.aria == undefined) {\n    legend.aria = false;\n  }\n  if ((_a = legend.encode) === null || _a === void 0 ? void 0 : _a.symbols) {\n    var out = legend.encode.symbols.update;\n    if (out.fill && out.fill['value'] !== 'transparent' && !out.stroke && !legend.stroke) {\n      // For non color channel's legend, we need to override symbol stroke config from Vega config if stroke channel is not used.\n      out.stroke = {\n        value: 'transparent'\n      };\n    }\n    // Remove properties that the legend is encoding.\n    var _iterator3 = _createForOfIteratorHelper(LEGEND_SCALE_CHANNELS),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var property = _step3.value;\n        if (legend[property]) {\n          delete out[property];\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n  if (!legend.title) {\n    // title schema doesn't include null, ''\n    delete legend.title;\n  }\n  if (labelExpr !== undefined) {\n    var expr = labelExpr;\n    if (((_c = (_b = legend.encode) === null || _b === void 0 ? void 0 : _b.labels) === null || _c === void 0 ? void 0 : _c.update) && isSignalRef(legend.encode.labels.update.text)) {\n      expr = replaceAll(labelExpr, 'datum.label', legend.encode.labels.update.text.signal);\n    }\n    setLegendEncode(legend, 'labels', 'text', {\n      signal: expr\n    });\n  }\n  return legend;\n}","map":{"version":3,"sources":["../../../../src/compile/legend/assemble.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { LEGEND_SCALE_CHANNELS } from '../../legend';\nimport { keys, replaceAll, stringify, vals } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { mergeLegendComponent } from './parse';\nfunction setLegendEncode(legend, part, vgProp, vgRef) {\n    var _a, _b, _c;\n    var _d, _e;\n    (_a = legend.encode) !== null && _a !== void 0 ? _a : (legend.encode = {});\n    (_b = (_d = legend.encode)[part]) !== null && _b !== void 0 ? _b : (_d[part] = {});\n    (_c = (_e = legend.encode[part]).update) !== null && _c !== void 0 ? _c : (_e.update = {});\n    // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n    legend.encode[part].update[vgProp] = vgRef;\n}\nexport function assembleLegends(model) {\n    const legendComponentIndex = model.component.legends;\n    const legendByDomain = {};\n    for (const channel of keys(legendComponentIndex)) {\n        const scaleComponent = model.getScaleComponent(channel);\n        const domainHash = stringify(scaleComponent.get('domains'));\n        if (legendByDomain[domainHash]) {\n            for (const mergedLegendComponent of legendByDomain[domainHash]) {\n                const merged = mergeLegendComponent(mergedLegendComponent, legendComponentIndex[channel]);\n                if (!merged) {\n                    // If cannot merge, need to add this legend separately\n                    legendByDomain[domainHash].push(legendComponentIndex[channel]);\n                }\n            }\n        }\n        else {\n            legendByDomain[domainHash] = [legendComponentIndex[channel].clone()];\n        }\n    }\n    const legends = vals(legendByDomain)\n        .flat()\n        .map(l => assembleLegend(l, model.config))\n        .filter(l => l !== undefined);\n    return legends;\n}\nexport function assembleLegend(legendCmpt, config) {\n    var _a, _b, _c;\n    const _d = legendCmpt.combine(), { disable, labelExpr, selections } = _d, legend = __rest(_d, [\"disable\", \"labelExpr\", \"selections\"]);\n    if (disable) {\n        return undefined;\n    }\n    if (config.aria === false && legend.aria == undefined) {\n        legend.aria = false;\n    }\n    if ((_a = legend.encode) === null || _a === void 0 ? void 0 : _a.symbols) {\n        const out = legend.encode.symbols.update;\n        if (out.fill && out.fill['value'] !== 'transparent' && !out.stroke && !legend.stroke) {\n            // For non color channel's legend, we need to override symbol stroke config from Vega config if stroke channel is not used.\n            out.stroke = { value: 'transparent' };\n        }\n        // Remove properties that the legend is encoding.\n        for (const property of LEGEND_SCALE_CHANNELS) {\n            if (legend[property]) {\n                delete out[property];\n            }\n        }\n    }\n    if (!legend.title) {\n        // title schema doesn't include null, ''\n        delete legend.title;\n    }\n    if (labelExpr !== undefined) {\n        let expr = labelExpr;\n        if (((_c = (_b = legend.encode) === null || _b === void 0 ? void 0 : _b.labels) === null || _c === void 0 ? void 0 : _c.update) && isSignalRef(legend.encode.labels.update.text)) {\n            expr = replaceAll(labelExpr, 'datum.label', legend.encode.labels.update.text.signal);\n        }\n        setLegendEncode(legend, 'labels', 'text', { signal: expr });\n    }\n    return legend;\n}\n//# sourceMappingURL=assemble.js.map"]},"metadata":{},"sourceType":"module"}