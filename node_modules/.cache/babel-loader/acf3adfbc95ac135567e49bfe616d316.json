{"ast":null,"code":"import * as encode from './encode';\nexport var rule = {\n  vgMark: 'rule',\n  encodeEntry: function encodeEntry(model) {\n    var markDef = model.markDef;\n    var orient = markDef.orient;\n    if (!model.encoding.x && !model.encoding.y && !model.encoding.latitude && !model.encoding.longitude) {\n      // Show nothing if we have none of x, y, lat, and long.\n      return {};\n    }\n    return Object.assign(Object.assign(Object.assign(Object.assign({}, encode.baseEncodeEntry(model, {\n      align: 'ignore',\n      baseline: 'ignore',\n      color: 'include',\n      orient: 'ignore',\n      size: 'ignore',\n      theta: 'ignore'\n    })), encode.pointOrRangePosition('x', model, {\n      defaultPos: orient === 'horizontal' ? 'zeroOrMax' : 'mid',\n      defaultPos2: 'zeroOrMin',\n      range: orient !== 'vertical' // include x2 for horizontal or line segment rule\n    })), encode.pointOrRangePosition('y', model, {\n      defaultPos: orient === 'vertical' ? 'zeroOrMax' : 'mid',\n      defaultPos2: 'zeroOrMin',\n      range: orient !== 'horizontal' // include y2 for vertical or line segment rule\n    })), encode.nonPosition('size', model, {\n      vgChannel: 'strokeWidth' // VL's rule size is strokeWidth\n    }));\n  }\n};","map":{"version":3,"sources":["../../../../src/compile/mark/rule.ts"],"names":[],"mappings":"AAEA,OAAO,KAAK,MAAM,MAAM,UAAU;AAElC,OAAO,IAAM,IAAI,GAAiB;EAChC,MAAM,EAAE,MAAM;EACd,WAAW,EAAE,qBAAC,KAAgB,EAAI;IAChC,IAAO,OAAO,GAAI,KAAK,CAAhB,OAAO;IACd,IAAM,MAAM,GAAG,OAAO,CAAC,MAAM;IAE7B,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,QAAQ,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,SAAS,EAAE;MACnG;MACA,OAAO,CAAA,CAAE;IACV;IAED,OAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EACK,MAAM,CAAC,eAAe,CAAC,KAAK,EAAE;MAC/B,KAAK,EAAE,QAAQ;MACf,QAAQ,EAAE,QAAQ;MAClB,KAAK,EAAE,SAAS;MAChB,MAAM,EAAE,QAAQ;MAChB,IAAI,EAAE,QAAQ;MACd,KAAK,EAAE;KACR,CAAC,CAAA,EACC,MAAM,CAAC,oBAAoB,CAAC,GAAG,EAAE,KAAK,EAAE;MACzC,UAAU,EAAE,MAAM,KAAK,YAAY,GAAG,WAAW,GAAG,KAAK;MACzD,WAAW,EAAE,WAAW;MACxB,KAAK,EAAE,MAAM,KAAK,UAAU,CAAC;KAC9B,CAAC,CAAA,EACC,MAAM,CAAC,oBAAoB,CAAC,GAAG,EAAE,KAAK,EAAE;MACzC,UAAU,EAAE,MAAM,KAAK,UAAU,GAAG,WAAW,GAAG,KAAK;MACvD,WAAW,EAAE,WAAW;MACxB,KAAK,EAAE,MAAM,KAAK,YAAY,CAAC;KAChC,CAAC,CAAA,EACC,MAAM,CAAC,WAAW,CAAC,MAAM,EAAE,KAAK,EAAE;MACnC,SAAS,EAAE,aAAa,CAAC;KAC1B,CAAC,CAAA;EAEN;CACD","sourceRoot":"","sourcesContent":["import * as encode from './encode';\nexport const rule = {\n    vgMark: 'rule',\n    encodeEntry: (model) => {\n        const { markDef } = model;\n        const orient = markDef.orient;\n        if (!model.encoding.x && !model.encoding.y && !model.encoding.latitude && !model.encoding.longitude) {\n            // Show nothing if we have none of x, y, lat, and long.\n            return {};\n        }\n        return Object.assign(Object.assign(Object.assign(Object.assign({}, encode.baseEncodeEntry(model, {\n            align: 'ignore',\n            baseline: 'ignore',\n            color: 'include',\n            orient: 'ignore',\n            size: 'ignore',\n            theta: 'ignore'\n        })), encode.pointOrRangePosition('x', model, {\n            defaultPos: orient === 'horizontal' ? 'zeroOrMax' : 'mid',\n            defaultPos2: 'zeroOrMin',\n            range: orient !== 'vertical' // include x2 for horizontal or line segment rule\n        })), encode.pointOrRangePosition('y', model, {\n            defaultPos: orient === 'vertical' ? 'zeroOrMax' : 'mid',\n            defaultPos2: 'zeroOrMin',\n            range: orient !== 'horizontal' // include y2 for vertical or line segment rule\n        })), encode.nonPosition('size', model, {\n            vgChannel: 'strokeWidth' // VL's rule size is strokeWidth\n        }));\n    }\n};\n//# sourceMappingURL=rule.js.map"]},"metadata":{},"sourceType":"module"}