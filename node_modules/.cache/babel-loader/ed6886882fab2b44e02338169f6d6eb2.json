{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _fileUriToPath = _interopRequireDefault(require(\"file-uri-to-path\"));\nvar _ = require(\".\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar myGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {\n  fetch: undefined\n};\nvar RemoteFile = /*#__PURE__*/function () {\n  (0, _createClass2.default)(RemoteFile, [{\n    key: \"getBufferFromResponse\",\n    value: function () {\n      var _getBufferFromResponse = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(response) {\n        var resp;\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(typeof response.buffer === 'function')) {\n                  _context.next = 4;\n                  break;\n                }\n                return _context.abrupt(\"return\", response.buffer());\n              case 4:\n                if (!(typeof response.arrayBuffer === 'function')) {\n                  _context.next = 11;\n                  break;\n                }\n                _context.next = 7;\n                return response.arrayBuffer();\n              case 7:\n                resp = _context.sent;\n                return _context.abrupt(\"return\", Buffer.from(resp));\n              case 11:\n                throw new TypeError('invalid HTTP response object, has no buffer method, and no arrayBuffer method');\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      function getBufferFromResponse(_x) {\n        return _getBufferFromResponse.apply(this, arguments);\n      }\n      return getBufferFromResponse;\n    }()\n  }]);\n  function RemoteFile(source) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0, _classCallCheck2.default)(this, RemoteFile);\n    (0, _defineProperty2.default)(this, \"url\", void 0);\n    (0, _defineProperty2.default)(this, \"_stat\", void 0);\n    (0, _defineProperty2.default)(this, \"fetchImplementation\", void 0);\n    (0, _defineProperty2.default)(this, \"baseOverrides\", {});\n    this.url = source; // if it is a file URL, monkey-patch ourselves to act like a LocalFile\n\n    if (source.startsWith('file://')) {\n      var path = (0, _fileUriToPath.default)(source);\n      if (!path) {\n        throw new TypeError('invalid file url');\n      }\n      var localFile = new _.LocalFile(path);\n      this.read = localFile.read.bind(localFile);\n      this.readFile = localFile.readFile.bind(localFile);\n      this.stat = localFile.stat.bind(localFile); // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n      // @ts-ignore\n\n      this.fetchImplementation = function () {\n        /* intentionally blank */\n      };\n      return;\n    }\n    var fetch = opts.fetch || myGlobal.fetch && myGlobal.fetch.bind(myGlobal);\n    if (!fetch) {\n      throw new TypeError(\"no fetch function supplied, and none found in global environment\");\n    }\n    if (opts.overrides) {\n      this.baseOverrides = opts.overrides;\n    }\n    this.fetchImplementation = fetch;\n  }\n  (0, _createClass2.default)(RemoteFile, [{\n    key: \"fetch\",\n    value: function () {\n      var _fetch = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(input, init) {\n        var response;\n        return _regenerator.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return this.fetchImplementation(input, init);\n              case 3:\n                response = _context2.sent;\n                _context2.next = 16;\n                break;\n              case 6:\n                _context2.prev = 6;\n                _context2.t0 = _context2[\"catch\"](0);\n                if (!(_context2.t0.message === 'Failed to fetch')) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                // refetch to to help work around a chrome bug (discussed in generic-filehandle issue #72) in\n                // which the chrome cache returns a CORS error for content in its cache.\n                // see also https://github.com/GMOD/jbrowse-components/pull/1511\n                console.warn(\"generic-filehandle: refetching \".concat(input, \" to attempt to work around chrome CORS header caching bug\"));\n                _context2.next = 12;\n                return this.fetchImplementation(input, _objectSpread(_objectSpread({}, init), {}, {\n                  cache: 'reload'\n                }));\n              case 12:\n                response = _context2.sent;\n                _context2.next = 16;\n                break;\n              case 15:\n                throw _context2.t0;\n              case 16:\n                return _context2.abrupt(\"return\", response);\n              case 17:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 6]]);\n      }));\n      function fetch(_x2, _x3) {\n        return _fetch.apply(this, arguments);\n      }\n      return fetch;\n    }()\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(buffer) {\n        var offset,\n          length,\n          position,\n          opts,\n          _opts$headers,\n          headers,\n          signal,\n          _opts$overrides,\n          overrides,\n          args,\n          response,\n          responseData,\n          bytesCopied,\n          res,\n          sizeMatch,\n          _args3 = arguments;\n        return _regenerator.default.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                offset = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : 0;\n                length = _args3.length > 2 ? _args3[2] : undefined;\n                position = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : 0;\n                opts = _args3.length > 4 && _args3[4] !== undefined ? _args3[4] : {};\n                _opts$headers = opts.headers, headers = _opts$headers === void 0 ? {} : _opts$headers, signal = opts.signal, _opts$overrides = opts.overrides, overrides = _opts$overrides === void 0 ? {} : _opts$overrides;\n                if (length < Infinity) {\n                  headers.range = \"bytes=\".concat(position, \"-\").concat(position + length);\n                } else if (length === Infinity && position !== 0) {\n                  headers.range = \"bytes=\".concat(position, \"-\");\n                }\n                args = _objectSpread(_objectSpread(_objectSpread({}, this.baseOverrides), overrides), {}, {\n                  headers: _objectSpread(_objectSpread(_objectSpread({}, headers), overrides.headers), this.baseOverrides.headers),\n                  method: 'GET',\n                  redirect: 'follow',\n                  mode: 'cors',\n                  signal: signal\n                });\n                _context3.next = 9;\n                return this.fetch(this.url, args);\n              case 9:\n                response = _context3.sent;\n                if (response.ok) {\n                  _context3.next = 12;\n                  break;\n                }\n                throw new Error(\"HTTP \".concat(response.status, \" \").concat(response.statusText));\n              case 12:\n                if (!(response.status === 200 && position === 0 || response.status === 206)) {\n                  _context3.next = 21;\n                  break;\n                }\n                _context3.next = 15;\n                return this.getBufferFromResponse(response);\n              case 15:\n                responseData = _context3.sent;\n                bytesCopied = responseData.copy(buffer, offset, 0, Math.min(length, responseData.length)); // try to parse out the size of the remote file\n\n                res = response.headers.get('content-range');\n                sizeMatch = /\\/(\\d+)$/.exec(res || '');\n                if (sizeMatch && sizeMatch[1]) {\n                  this._stat = {\n                    size: parseInt(sizeMatch[1], 10)\n                  };\n                }\n                return _context3.abrupt(\"return\", {\n                  bytesRead: bytesCopied,\n                  buffer: buffer\n                });\n              case 21:\n                if (!(response.status === 200)) {\n                  _context3.next = 23;\n                  break;\n                }\n                throw new Error('${this.url} fetch returned status 200, expected 206');\n              case 23:\n                throw new Error(\"HTTP \".concat(response.status, \" fetching \").concat(this.url));\n              case 24:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function read(_x4) {\n        return _read.apply(this, arguments);\n      }\n      return read;\n    }()\n  }, {\n    key: \"readFile\",\n    value: function () {\n      var _readFile = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {\n        var options,\n          encoding,\n          opts,\n          _opts,\n          _opts$headers2,\n          headers,\n          signal,\n          _opts$overrides2,\n          overrides,\n          args,\n          response,\n          _args4 = arguments;\n        return _regenerator.default.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                options = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};\n                if (typeof options === 'string') {\n                  encoding = options;\n                  opts = {};\n                } else {\n                  encoding = options.encoding;\n                  opts = options;\n                  delete opts.encoding;\n                }\n                _opts = opts, _opts$headers2 = _opts.headers, headers = _opts$headers2 === void 0 ? {} : _opts$headers2, signal = _opts.signal, _opts$overrides2 = _opts.overrides, overrides = _opts$overrides2 === void 0 ? {} : _opts$overrides2;\n                args = _objectSpread(_objectSpread({\n                  headers: headers,\n                  method: 'GET',\n                  redirect: 'follow',\n                  mode: 'cors',\n                  signal: signal\n                }, this.baseOverrides), overrides);\n                _context4.next = 6;\n                return this.fetch(this.url, args);\n              case 6:\n                response = _context4.sent;\n                if (response) {\n                  _context4.next = 9;\n                  break;\n                }\n                throw new Error('generic-filehandle failed to fetch');\n              case 9:\n                if (!(response.status !== 200)) {\n                  _context4.next = 11;\n                  break;\n                }\n                throw Object.assign(new Error(\"HTTP \".concat(response.status, \" fetching \").concat(this.url)), {\n                  status: response.status\n                });\n              case 11:\n                if (!(encoding === 'utf8')) {\n                  _context4.next = 13;\n                  break;\n                }\n                return _context4.abrupt(\"return\", response.text());\n              case 13:\n                if (!encoding) {\n                  _context4.next = 15;\n                  break;\n                }\n                throw new Error(\"unsupported encoding: \".concat(encoding));\n              case 15:\n                return _context4.abrupt(\"return\", this.getBufferFromResponse(response));\n              case 16:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function readFile() {\n        return _readFile.apply(this, arguments);\n      }\n      return readFile;\n    }()\n  }, {\n    key: \"stat\",\n    value: function () {\n      var _stat = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5() {\n        var buf;\n        return _regenerator.default.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (this._stat) {\n                  _context5.next = 6;\n                  break;\n                }\n                buf = Buffer.allocUnsafe(10);\n                _context5.next = 4;\n                return this.read(buf, 0, 10, 0);\n              case 4:\n                if (this._stat) {\n                  _context5.next = 6;\n                  break;\n                }\n                throw new Error(\"unable to determine size of file at \".concat(this.url));\n              case 6:\n                return _context5.abrupt(\"return\", this._stat);\n              case 7:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function stat() {\n        return _stat.apply(this, arguments);\n      }\n      return stat;\n    }()\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6() {\n        return _regenerator.default.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                return _context6.abrupt(\"return\");\n              case 1:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n      function close() {\n        return _close.apply(this, arguments);\n      }\n      return close;\n    }()\n  }]);\n  return RemoteFile;\n}();\nexports.default = RemoteFile;","map":{"version":3,"sources":["../src/remoteFile.ts"],"names":["myGlobal","window","self","fetch","undefined","RemoteFile","response","buffer","arrayBuffer","resp","Buffer","from","TypeError","source","opts","url","startsWith","path","localFile","LocalFile","read","bind","readFile","stat","fetchImplementation","overrides","baseOverrides","input","init","message","console","warn","cache","offset","length","position","headers","signal","Infinity","range","args","method","redirect","mode","ok","Error","status","statusText","responseData","getBufferFromResponse","bytesCopied","copy","Math","min","res","get","sizeMatch","exec","_stat","size","parseInt","bytesRead","options","encoding","assign","text","buf","allocUnsafe"],"mappings":"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","sourcesContent":["import uri2path from 'file-uri-to-path'\nimport {\n  GenericFilehandle,\n  FilehandleOptions,\n  Stats,\n  Fetcher,\n  PolyfilledResponse,\n} from './filehandle'\nimport { LocalFile } from '.'\n\nconst myGlobal =\n  typeof window !== 'undefined'\n    ? window\n    : typeof self !== 'undefined'\n    ? self\n    : { fetch: undefined }\n\nexport default class RemoteFile implements GenericFilehandle {\n  protected url: string\n  private _stat?: Stats\n  private fetchImplementation: Fetcher\n  private baseOverrides: any = {}\n\n  private async getBufferFromResponse(response: PolyfilledResponse): Promise<Buffer> {\n    if (typeof response.buffer === 'function') {\n      return response.buffer()\n    } else if (typeof response.arrayBuffer === 'function') {\n      const resp = await response.arrayBuffer()\n      return Buffer.from(resp)\n    } else {\n      throw new TypeError(\n        'invalid HTTP response object, has no buffer method, and no arrayBuffer method',\n      )\n    }\n  }\n\n  public constructor(source: string, opts: FilehandleOptions = {}) {\n    this.url = source\n\n    // if it is a file URL, monkey-patch ourselves to act like a LocalFile\n    if (source.startsWith('file://')) {\n      const path = uri2path(source)\n      if (!path) {\n        throw new TypeError('invalid file url')\n      }\n      const localFile = new LocalFile(path)\n      this.read = localFile.read.bind(localFile)\n      this.readFile = localFile.readFile.bind(localFile)\n      this.stat = localFile.stat.bind(localFile)\n      // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n      // @ts-ignore\n      this.fetchImplementation = (): void => {\n        /* intentionally blank */\n      }\n      return\n    }\n\n    const fetch = opts.fetch || (myGlobal.fetch && myGlobal.fetch.bind(myGlobal))\n    if (!fetch) {\n      throw new TypeError(\n        `no fetch function supplied, and none found in global environment`,\n      )\n    }\n    if (opts.overrides) {\n      this.baseOverrides = opts.overrides\n    }\n    this.fetchImplementation = fetch\n  }\n\n  public async fetch(\n    input: RequestInfo,\n    init: RequestInit | undefined,\n  ): Promise<PolyfilledResponse> {\n    let response\n    try {\n      response = await this.fetchImplementation(input, init)\n    } catch (e) {\n      if (e.message === 'Failed to fetch') {\n        // refetch to to help work around a chrome bug (discussed in generic-filehandle issue #72) in\n        // which the chrome cache returns a CORS error for content in its cache.\n        // see also https://github.com/GMOD/jbrowse-components/pull/1511\n        console.warn(\n          `generic-filehandle: refetching ${input} to attempt to work around chrome CORS header caching bug`,\n        )\n        response = await this.fetchImplementation(input, { ...init, cache: 'reload' })\n      } else {\n        throw e\n      }\n    }\n    return response\n  }\n\n  public async read(\n    buffer: Buffer,\n    offset = 0,\n    length: number,\n    position = 0,\n    opts: FilehandleOptions = {},\n  ): Promise<{ bytesRead: number; buffer: Buffer }> {\n    const { headers = {}, signal, overrides = {} } = opts\n    if (length < Infinity) {\n      headers.range = `bytes=${position}-${position + length}`\n    } else if (length === Infinity && position !== 0) {\n      headers.range = `bytes=${position}-`\n    }\n    const args = {\n      ...this.baseOverrides,\n      ...overrides,\n      headers: { ...headers, ...overrides.headers, ...this.baseOverrides.headers },\n      method: 'GET',\n      redirect: 'follow',\n      mode: 'cors',\n      signal,\n    }\n    const response = await this.fetch(this.url, args)\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status} ${response.statusText}`)\n    }\n\n    if ((response.status === 200 && position === 0) || response.status === 206) {\n      const responseData = await this.getBufferFromResponse(response)\n      const bytesCopied = responseData.copy(\n        buffer,\n        offset,\n        0,\n        Math.min(length, responseData.length),\n      )\n\n      // try to parse out the size of the remote file\n      const res = response.headers.get('content-range')\n      const sizeMatch = /\\/(\\d+)$/.exec(res || '')\n      if (sizeMatch && sizeMatch[1]) {\n        this._stat = { size: parseInt(sizeMatch[1], 10) }\n      }\n\n      return { bytesRead: bytesCopied, buffer }\n    }\n\n    if (response.status === 200) {\n      throw new Error('${this.url} fetch returned status 200, expected 206')\n    }\n\n    // TODO: try harder here to gather more information about what the problem is\n    throw new Error(`HTTP ${response.status} fetching ${this.url}`)\n  }\n\n  public async readFile(\n    options: FilehandleOptions | string = {},\n  ): Promise<Buffer | string> {\n    let encoding\n    let opts\n    if (typeof options === 'string') {\n      encoding = options\n      opts = {}\n    } else {\n      encoding = options.encoding\n      opts = options\n      delete opts.encoding\n    }\n    const { headers = {}, signal, overrides = {} } = opts\n    const args = {\n      headers,\n      method: 'GET',\n      redirect: 'follow',\n      mode: 'cors',\n      signal,\n      ...this.baseOverrides,\n      ...overrides,\n    }\n    const response = await this.fetch(this.url, args)\n\n    if (!response) {\n      throw new Error('generic-filehandle failed to fetch')\n    }\n\n    if (response.status !== 200) {\n      throw Object.assign(new Error(`HTTP ${response.status} fetching ${this.url}`), {\n        status: response.status,\n      })\n    }\n    if (encoding === 'utf8') {\n      return response.text()\n    }\n    if (encoding) {\n      throw new Error(`unsupported encoding: ${encoding}`)\n    }\n    return this.getBufferFromResponse(response)\n  }\n\n  public async stat(): Promise<Stats> {\n    if (!this._stat) {\n      const buf = Buffer.allocUnsafe(10)\n      await this.read(buf, 0, 10, 0)\n      if (!this._stat) {\n        throw new Error(`unable to determine size of file at ${this.url}`)\n      }\n    }\n    return this._stat\n  }\n\n  public async close(): Promise<void> {\n    return\n  }\n}\n"]},"metadata":{},"sourceType":"script"}