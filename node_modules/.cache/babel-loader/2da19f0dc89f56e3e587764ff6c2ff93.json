{"ast":null,"code":"import { getSizeChannel } from '../channel';\nimport { stringify } from '../util';\nexport function invalidSpec(spec) {\n  return \"Invalid specification \".concat(stringify(spec), \". Make sure the specification includes at least one of the following properties: \\\"mark\\\", \\\"layer\\\", \\\"facet\\\", \\\"hconcat\\\", \\\"vconcat\\\", \\\"concat\\\", or \\\"repeat\\\".\");\n}\n// FIT\nexport var FIT_NON_SINGLE = 'Autosize \"fit\" only works for single views and layered views.';\nexport function containerSizeNonSingle(name) {\n  var uName = name == 'width' ? 'Width' : 'Height';\n  return \"\".concat(uName, \" \\\"container\\\" only works for single views and layered views.\");\n}\nexport function containerSizeNotCompatibleWithAutosize(name) {\n  var uName = name == 'width' ? 'Width' : 'Height';\n  var fitDirection = name == 'width' ? 'x' : 'y';\n  return \"\".concat(uName, \" \\\"container\\\" only works well with autosize \\\"fit\\\" or \\\"fit-\").concat(fitDirection, \"\\\".\");\n}\nexport function droppingFit(channel) {\n  return channel ? \"Dropping \\\"fit-\".concat(channel, \"\\\" because spec has discrete \").concat(getSizeChannel(channel), \".\") : \"Dropping \\\"fit\\\" because spec has discrete size.\";\n}\n// VIEW SIZE\nexport function unknownField(channel) {\n  return \"Unknown field for \".concat(channel, \". Cannot calculate view size.\");\n}\n// SELECTION\nexport function cannotProjectOnChannelWithoutField(channel) {\n  return \"Cannot project a selection on encoding channel \\\"\".concat(channel, \"\\\", which has no field.\");\n}\nexport function cannotProjectAggregate(channel, aggregate) {\n  return \"Cannot project a selection on encoding channel \\\"\".concat(channel, \"\\\" as it uses an aggregate function (\\\"\").concat(aggregate, \"\\\").\");\n}\nexport function nearestNotSupportForContinuous(mark) {\n  return \"The \\\"nearest\\\" transform is not supported for \".concat(mark, \" marks.\");\n}\nexport function selectionNotSupported(mark) {\n  return \"Selection not supported for \".concat(mark, \" yet.\");\n}\nexport function selectionNotFound(name) {\n  return \"Cannot find a selection named \\\"\".concat(name, \"\\\".\");\n}\nexport var SCALE_BINDINGS_CONTINUOUS = 'Scale bindings are currently only supported for scales with unbinned, continuous domains.';\nexport var LEGEND_BINDINGS_MUST_HAVE_PROJECTION = 'Legend bindings are only supported for selections over an individual field or encoding channel.';\nexport function cannotLookupVariableParameter(name) {\n  return \"Lookups can only be performed on selection parameters. \\\"\".concat(name, \"\\\" is a variable parameter.\");\n}\nexport function noSameUnitLookup(name) {\n  return \"Cannot define and lookup the \\\"\".concat(name, \"\\\" selection in the same view. \") + \"Try moving the lookup into a second, layered view?\";\n}\nexport var NEEDS_SAME_SELECTION = 'The same selection must be used to override scale domains in a layered view.';\nexport var INTERVAL_INITIALIZED_WITH_X_Y = 'Interval selections should be initialized using \"x\" and/or \"y\" keys.';\n// REPEAT\nexport function noSuchRepeatedValue(field) {\n  return \"Unknown repeated value \\\"\".concat(field, \"\\\".\");\n}\nexport function columnsNotSupportByRowCol(type) {\n  return \"The \\\"columns\\\" property cannot be used when \\\"\".concat(type, \"\\\" has nested row/column.\");\n}\n// CONCAT / REPEAT\nexport var CONCAT_CANNOT_SHARE_AXIS = 'Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).';\n// DATA\nexport function unrecognizedParse(p) {\n  return \"Unrecognized parse \\\"\".concat(p, \"\\\".\");\n}\nexport function differentParse(field, local, ancestor) {\n  return \"An ancestor parsed field \\\"\".concat(field, \"\\\" as \").concat(ancestor, \" but a child wants to parse the field as \").concat(local, \".\");\n}\nexport var ADD_SAME_CHILD_TWICE = 'Attempt to add the same child twice.';\n// TRANSFORMS\nexport function invalidTransformIgnored(transform) {\n  return \"Ignoring an invalid transform: \".concat(stringify(transform), \".\");\n}\nexport var NO_FIELDS_NEEDS_AS = 'If \"from.fields\" is not specified, \"as\" has to be a string that specifies the key to be used for the data from the secondary source.';\n// ENCODING & FACET\nexport function customFormatTypeNotAllowed(channel) {\n  return \"Config.customFormatTypes is not true, thus custom format type and format for channel \".concat(channel, \" are dropped.\");\n}\nexport function projectionOverridden(opt) {\n  var parentProjection = opt.parentProjection,\n    projection = opt.projection;\n  return \"Layer's shared projection \".concat(stringify(parentProjection), \" is overridden by a child projection \").concat(stringify(projection), \".\");\n}\nexport var REPLACE_ANGLE_WITH_THETA = 'Arc marks uses theta channel rather than angle, replacing angle with theta.';\nexport function offsetNestedInsideContinuousPositionScaleDropped(mainChannel) {\n  return \"\".concat(mainChannel, \"Offset dropped because \").concat(mainChannel, \" is continuous\");\n}\nexport function replaceOffsetWithMainChannel(mainChannel) {\n  return \"There is no \".concat(mainChannel, \" encoding. Replacing \").concat(mainChannel, \"Offset encoding as \").concat(mainChannel, \".\");\n}\nexport function primitiveChannelDef(channel, type, value) {\n  return \"Channel \".concat(channel, \" is a \").concat(type, \". Converted to {value: \").concat(stringify(value), \"}.\");\n}\nexport function invalidFieldType(type) {\n  return \"Invalid field type \\\"\".concat(type, \"\\\".\");\n}\nexport function invalidFieldTypeForCountAggregate(type, aggregate) {\n  return \"Invalid field type \\\"\".concat(type, \"\\\" for aggregate: \\\"\").concat(aggregate, \"\\\", using \\\"quantitative\\\" instead.\");\n}\nexport function invalidAggregate(aggregate) {\n  return \"Invalid aggregation operator \\\"\".concat(aggregate, \"\\\".\");\n}\nexport function missingFieldType(channel, newType) {\n  return \"Missing type for channel \\\"\".concat(channel, \"\\\", using \\\"\").concat(newType, \"\\\" instead.\");\n}\nexport function droppingColor(type, opt) {\n  var fill = opt.fill,\n    stroke = opt.stroke;\n  return \"Dropping color \".concat(type, \" as the plot also has \").concat(fill && stroke ? 'fill and stroke' : fill ? 'fill' : 'stroke', \".\");\n}\nexport function relativeBandSizeNotSupported(sizeChannel) {\n  return \"Position range does not support relative band size for \".concat(sizeChannel, \".\");\n}\nexport function emptyFieldDef(fieldDef, channel) {\n  return \"Dropping \".concat(stringify(fieldDef), \" from channel \\\"\").concat(channel, \"\\\" since it does not contain any data field, datum, value, or signal.\");\n}\nexport var LINE_WITH_VARYING_SIZE = 'Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.';\nexport function incompatibleChannel(channel, markOrFacet, when) {\n  return \"\".concat(channel, \" dropped as it is incompatible with \\\"\").concat(markOrFacet, \"\\\"\").concat(when ? \" when \".concat(when) : '', \".\");\n}\nexport function offsetEncodingScaleIgnored(channel) {\n  return \"\".concat(channel, \" encoding has no scale, so specified scale is ignored.\");\n}\nexport function invalidEncodingChannel(channel) {\n  return \"\".concat(channel, \"-encoding is dropped as \").concat(channel, \" is not a valid encoding channel.\");\n}\nexport function channelShouldBeDiscrete(channel) {\n  return \"\".concat(channel, \" encoding should be discrete (ordinal / nominal / binned).\");\n}\nexport function channelShouldBeDiscreteOrDiscretizing(channel) {\n  return \"\".concat(channel, \" encoding should be discrete (ordinal / nominal / binned) or use a discretizing scale (e.g. threshold).\");\n}\nexport function facetChannelDropped(channels) {\n  return \"Facet encoding dropped as \".concat(channels.join(' and '), \" \").concat(channels.length > 1 ? 'are' : 'is', \" also specified.\");\n}\nexport function discreteChannelCannotEncode(channel, type) {\n  return \"Using discrete channel \\\"\".concat(channel, \"\\\" to encode \\\"\").concat(type, \"\\\" field can be misleading as it does not encode \").concat(type === 'ordinal' ? 'order' : 'magnitude', \".\");\n}\n// MARK\nexport function rangeMarkAlignmentCannotBeExpression(align) {\n  return \"The \".concat(align, \" for range marks cannot be an expression\");\n}\nexport function lineWithRange(hasX2, hasY2) {\n  var channels = hasX2 && hasY2 ? 'x2 and y2' : hasX2 ? 'x2' : 'y2';\n  return \"Line mark is for continuous lines and thus cannot be used with \".concat(channels, \". We will use the rule mark (line segments) instead.\");\n}\nexport function orientOverridden(original, actual) {\n  return \"Specified orient \\\"\".concat(original, \"\\\" overridden with \\\"\").concat(actual, \"\\\".\");\n}\n// SCALE\nexport var CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN = 'Custom domain scale cannot be unioned with default field-based domain.';\nexport function cannotUseScalePropertyWithNonColor(prop) {\n  return \"Cannot use the scale property \\\"\".concat(prop, \"\\\" with non-color channel.\");\n}\nexport function cannotUseRelativeBandSizeWithNonBandScale(scaleType) {\n  return \"Cannot use the relative band size with \".concat(scaleType, \" scale.\");\n}\nexport function unaggregateDomainHasNoEffectForRawField(fieldDef) {\n  return \"Using unaggregated domain with raw field has no effect (\".concat(stringify(fieldDef), \").\");\n}\nexport function unaggregateDomainWithNonSharedDomainOp(aggregate) {\n  return \"Unaggregated domain not applicable for \\\"\".concat(aggregate, \"\\\" since it produces values outside the origin domain of the source data.\");\n}\nexport function unaggregatedDomainWithLogScale(fieldDef) {\n  return \"Unaggregated domain is currently unsupported for log scale (\".concat(stringify(fieldDef), \").\");\n}\nexport function cannotApplySizeToNonOrientedMark(mark) {\n  return \"Cannot apply size to non-oriented mark \\\"\".concat(mark, \"\\\".\");\n}\nexport function scaleTypeNotWorkWithChannel(channel, scaleType, defaultScaleType) {\n  return \"Channel \\\"\".concat(channel, \"\\\" does not work with \\\"\").concat(scaleType, \"\\\" scale. We are using \\\"\").concat(defaultScaleType, \"\\\" scale instead.\");\n}\nexport function scaleTypeNotWorkWithFieldDef(scaleType, defaultScaleType) {\n  return \"FieldDef does not work with \\\"\".concat(scaleType, \"\\\" scale. We are using \\\"\").concat(defaultScaleType, \"\\\" scale instead.\");\n}\nexport function scalePropertyNotWorkWithScaleType(scaleType, propName, channel) {\n  return \"\".concat(channel, \"-scale's \\\"\").concat(propName, \"\\\" is dropped as it does not work with \").concat(scaleType, \" scale.\");\n}\nexport function scaleTypeNotWorkWithMark(mark, scaleType) {\n  return \"Scale type \\\"\".concat(scaleType, \"\\\" does not work with mark \\\"\").concat(mark, \"\\\".\");\n}\nexport function stepDropped(channel) {\n  return \"The step for \\\"\".concat(channel, \"\\\" is dropped because the \").concat(channel === 'width' ? 'x' : 'y', \" is continuous.\");\n}\nexport function mergeConflictingProperty(property, propertyOf, v1, v2) {\n  return \"Conflicting \".concat(propertyOf.toString(), \" property \\\"\").concat(property.toString(), \"\\\" (\").concat(stringify(v1), \" and \").concat(stringify(v2), \"). Using \").concat(stringify(v1), \".\");\n}\nexport function mergeConflictingDomainProperty(property, propertyOf, v1, v2) {\n  return \"Conflicting \".concat(propertyOf.toString(), \" property \\\"\").concat(property.toString(), \"\\\" (\").concat(stringify(v1), \" and \").concat(stringify(v2), \"). Using the union of the two domains.\");\n}\nexport function independentScaleMeansIndependentGuide(channel) {\n  return \"Setting the scale to be independent for \\\"\".concat(channel, \"\\\" means we also have to set the guide (axis or legend) to be independent.\");\n}\nexport function domainSortDropped(sort) {\n  return \"Dropping sort property \".concat(stringify(sort), \" as unioned domains only support boolean or op \\\"count\\\", \\\"min\\\", and \\\"max\\\".\");\n}\nexport var MORE_THAN_ONE_SORT = 'Domains that should be unioned has conflicting sort properties. Sort will be set to true.';\nexport var FACETED_INDEPENDENT_DIFFERENT_SOURCES = 'Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.';\nexport var FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES = 'Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.';\nexport var FACETED_INDEPENDENT_SAME_SOURCE = 'Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.';\n// AXIS\nexport var INVALID_CHANNEL_FOR_AXIS = 'Invalid channel for axis.';\n// STACK\nexport function cannotStackRangedMark(channel) {\n  return \"Cannot stack \\\"\".concat(channel, \"\\\" if there is already \\\"\").concat(channel, \"2\\\".\");\n}\nexport function cannotStackNonLinearScale(scaleType) {\n  return \"Cannot stack non-linear scale (\".concat(scaleType, \").\");\n}\nexport function stackNonSummativeAggregate(aggregate) {\n  return \"Stacking is applied even though the aggregate function is non-summative (\\\"\".concat(aggregate, \"\\\").\");\n}\n// TIMEUNIT\nexport function invalidTimeUnit(unitName, value) {\n  return \"Invalid \".concat(unitName, \": \").concat(stringify(value), \".\");\n}\nexport function droppedDay(d) {\n  return \"Dropping day from datetime \".concat(stringify(d), \" as day cannot be combined with other units.\");\n}\nexport function errorBarCenterAndExtentAreNotNeeded(center, extent) {\n  return \"\".concat(extent ? 'extent ' : '').concat(extent && center ? 'and ' : '').concat(center ? 'center ' : '').concat(extent && center ? 'are ' : 'is ', \"not needed when data are aggregated.\");\n}\nexport function errorBarCenterIsUsedWithWrongExtent(center, extent, mark) {\n  return \"\".concat(center, \" is not usually used with \").concat(extent, \" for \").concat(mark, \".\");\n}\nexport function errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark) {\n  return \"Continuous axis should not have customized aggregation function \".concat(aggregate, \"; \").concat(compositeMark, \" already agregates the axis.\");\n}\nexport function errorBand1DNotSupport(property) {\n  return \"1D error band does not support \".concat(property, \".\");\n}\n// CHANNEL\nexport function channelRequiredForBinned(channel) {\n  return \"Channel \".concat(channel, \" is required for \\\"binned\\\" bin.\");\n}\nexport function channelShouldNotBeUsedForBinned(channel) {\n  return \"Channel \".concat(channel, \" should not be used with \\\"binned\\\" bin.\");\n}\nexport function domainRequiredForThresholdScale(channel) {\n  return \"Domain for \".concat(channel, \" is required for threshold scale.\");\n}","map":{"version":3,"sources":["../../../src/log/message.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { getSizeChannel } from '../channel';\nimport { stringify } from '../util';\nexport function invalidSpec(spec) {\n    return `Invalid specification ${stringify(spec)}. Make sure the specification includes at least one of the following properties: \"mark\", \"layer\", \"facet\", \"hconcat\", \"vconcat\", \"concat\", or \"repeat\".`;\n}\n// FIT\nexport const FIT_NON_SINGLE = 'Autosize \"fit\" only works for single views and layered views.';\nexport function containerSizeNonSingle(name) {\n    const uName = name == 'width' ? 'Width' : 'Height';\n    return `${uName} \"container\" only works for single views and layered views.`;\n}\nexport function containerSizeNotCompatibleWithAutosize(name) {\n    const uName = name == 'width' ? 'Width' : 'Height';\n    const fitDirection = name == 'width' ? 'x' : 'y';\n    return `${uName} \"container\" only works well with autosize \"fit\" or \"fit-${fitDirection}\".`;\n}\nexport function droppingFit(channel) {\n    return channel\n        ? `Dropping \"fit-${channel}\" because spec has discrete ${getSizeChannel(channel)}.`\n        : `Dropping \"fit\" because spec has discrete size.`;\n}\n// VIEW SIZE\nexport function unknownField(channel) {\n    return `Unknown field for ${channel}. Cannot calculate view size.`;\n}\n// SELECTION\nexport function cannotProjectOnChannelWithoutField(channel) {\n    return `Cannot project a selection on encoding channel \"${channel}\", which has no field.`;\n}\nexport function cannotProjectAggregate(channel, aggregate) {\n    return `Cannot project a selection on encoding channel \"${channel}\" as it uses an aggregate function (\"${aggregate}\").`;\n}\nexport function nearestNotSupportForContinuous(mark) {\n    return `The \"nearest\" transform is not supported for ${mark} marks.`;\n}\nexport function selectionNotSupported(mark) {\n    return `Selection not supported for ${mark} yet.`;\n}\nexport function selectionNotFound(name) {\n    return `Cannot find a selection named \"${name}\".`;\n}\nexport const SCALE_BINDINGS_CONTINUOUS = 'Scale bindings are currently only supported for scales with unbinned, continuous domains.';\nexport const LEGEND_BINDINGS_MUST_HAVE_PROJECTION = 'Legend bindings are only supported for selections over an individual field or encoding channel.';\nexport function cannotLookupVariableParameter(name) {\n    return `Lookups can only be performed on selection parameters. \"${name}\" is a variable parameter.`;\n}\nexport function noSameUnitLookup(name) {\n    return (`Cannot define and lookup the \"${name}\" selection in the same view. ` +\n        `Try moving the lookup into a second, layered view?`);\n}\nexport const NEEDS_SAME_SELECTION = 'The same selection must be used to override scale domains in a layered view.';\nexport const INTERVAL_INITIALIZED_WITH_X_Y = 'Interval selections should be initialized using \"x\" and/or \"y\" keys.';\n// REPEAT\nexport function noSuchRepeatedValue(field) {\n    return `Unknown repeated value \"${field}\".`;\n}\nexport function columnsNotSupportByRowCol(type) {\n    return `The \"columns\" property cannot be used when \"${type}\" has nested row/column.`;\n}\n// CONCAT / REPEAT\nexport const CONCAT_CANNOT_SHARE_AXIS = 'Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).';\n// DATA\nexport function unrecognizedParse(p) {\n    return `Unrecognized parse \"${p}\".`;\n}\nexport function differentParse(field, local, ancestor) {\n    return `An ancestor parsed field \"${field}\" as ${ancestor} but a child wants to parse the field as ${local}.`;\n}\nexport const ADD_SAME_CHILD_TWICE = 'Attempt to add the same child twice.';\n// TRANSFORMS\nexport function invalidTransformIgnored(transform) {\n    return `Ignoring an invalid transform: ${stringify(transform)}.`;\n}\nexport const NO_FIELDS_NEEDS_AS = 'If \"from.fields\" is not specified, \"as\" has to be a string that specifies the key to be used for the data from the secondary source.';\n// ENCODING & FACET\nexport function customFormatTypeNotAllowed(channel) {\n    return `Config.customFormatTypes is not true, thus custom format type and format for channel ${channel} are dropped.`;\n}\nexport function projectionOverridden(opt) {\n    const { parentProjection, projection } = opt;\n    return `Layer's shared projection ${stringify(parentProjection)} is overridden by a child projection ${stringify(projection)}.`;\n}\nexport const REPLACE_ANGLE_WITH_THETA = 'Arc marks uses theta channel rather than angle, replacing angle with theta.';\nexport function offsetNestedInsideContinuousPositionScaleDropped(mainChannel) {\n    return `${mainChannel}Offset dropped because ${mainChannel} is continuous`;\n}\nexport function replaceOffsetWithMainChannel(mainChannel) {\n    return `There is no ${mainChannel} encoding. Replacing ${mainChannel}Offset encoding as ${mainChannel}.`;\n}\nexport function primitiveChannelDef(channel, type, value) {\n    return `Channel ${channel} is a ${type}. Converted to {value: ${stringify(value)}}.`;\n}\nexport function invalidFieldType(type) {\n    return `Invalid field type \"${type}\".`;\n}\nexport function invalidFieldTypeForCountAggregate(type, aggregate) {\n    return `Invalid field type \"${type}\" for aggregate: \"${aggregate}\", using \"quantitative\" instead.`;\n}\nexport function invalidAggregate(aggregate) {\n    return `Invalid aggregation operator \"${aggregate}\".`;\n}\nexport function missingFieldType(channel, newType) {\n    return `Missing type for channel \"${channel}\", using \"${newType}\" instead.`;\n}\nexport function droppingColor(type, opt) {\n    const { fill, stroke } = opt;\n    return `Dropping color ${type} as the plot also has ${fill && stroke ? 'fill and stroke' : fill ? 'fill' : 'stroke'}.`;\n}\nexport function relativeBandSizeNotSupported(sizeChannel) {\n    return `Position range does not support relative band size for ${sizeChannel}.`;\n}\nexport function emptyFieldDef(fieldDef, channel) {\n    return `Dropping ${stringify(fieldDef)} from channel \"${channel}\" since it does not contain any data field, datum, value, or signal.`;\n}\nexport const LINE_WITH_VARYING_SIZE = 'Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.';\nexport function incompatibleChannel(channel, markOrFacet, when) {\n    return `${channel} dropped as it is incompatible with \"${markOrFacet}\"${when ? ` when ${when}` : ''}.`;\n}\nexport function offsetEncodingScaleIgnored(channel) {\n    return `${channel} encoding has no scale, so specified scale is ignored.`;\n}\nexport function invalidEncodingChannel(channel) {\n    return `${channel}-encoding is dropped as ${channel} is not a valid encoding channel.`;\n}\nexport function channelShouldBeDiscrete(channel) {\n    return `${channel} encoding should be discrete (ordinal / nominal / binned).`;\n}\nexport function channelShouldBeDiscreteOrDiscretizing(channel) {\n    return `${channel} encoding should be discrete (ordinal / nominal / binned) or use a discretizing scale (e.g. threshold).`;\n}\nexport function facetChannelDropped(channels) {\n    return `Facet encoding dropped as ${channels.join(' and ')} ${channels.length > 1 ? 'are' : 'is'} also specified.`;\n}\nexport function discreteChannelCannotEncode(channel, type) {\n    return `Using discrete channel \"${channel}\" to encode \"${type}\" field can be misleading as it does not encode ${type === 'ordinal' ? 'order' : 'magnitude'}.`;\n}\n// MARK\nexport function rangeMarkAlignmentCannotBeExpression(align) {\n    return `The ${align} for range marks cannot be an expression`;\n}\nexport function lineWithRange(hasX2, hasY2) {\n    const channels = hasX2 && hasY2 ? 'x2 and y2' : hasX2 ? 'x2' : 'y2';\n    return `Line mark is for continuous lines and thus cannot be used with ${channels}. We will use the rule mark (line segments) instead.`;\n}\nexport function orientOverridden(original, actual) {\n    return `Specified orient \"${original}\" overridden with \"${actual}\".`;\n}\n// SCALE\nexport const CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN = 'Custom domain scale cannot be unioned with default field-based domain.';\nexport function cannotUseScalePropertyWithNonColor(prop) {\n    return `Cannot use the scale property \"${prop}\" with non-color channel.`;\n}\nexport function cannotUseRelativeBandSizeWithNonBandScale(scaleType) {\n    return `Cannot use the relative band size with ${scaleType} scale.`;\n}\nexport function unaggregateDomainHasNoEffectForRawField(fieldDef) {\n    return `Using unaggregated domain with raw field has no effect (${stringify(fieldDef)}).`;\n}\nexport function unaggregateDomainWithNonSharedDomainOp(aggregate) {\n    return `Unaggregated domain not applicable for \"${aggregate}\" since it produces values outside the origin domain of the source data.`;\n}\nexport function unaggregatedDomainWithLogScale(fieldDef) {\n    return `Unaggregated domain is currently unsupported for log scale (${stringify(fieldDef)}).`;\n}\nexport function cannotApplySizeToNonOrientedMark(mark) {\n    return `Cannot apply size to non-oriented mark \"${mark}\".`;\n}\nexport function scaleTypeNotWorkWithChannel(channel, scaleType, defaultScaleType) {\n    return `Channel \"${channel}\" does not work with \"${scaleType}\" scale. We are using \"${defaultScaleType}\" scale instead.`;\n}\nexport function scaleTypeNotWorkWithFieldDef(scaleType, defaultScaleType) {\n    return `FieldDef does not work with \"${scaleType}\" scale. We are using \"${defaultScaleType}\" scale instead.`;\n}\nexport function scalePropertyNotWorkWithScaleType(scaleType, propName, channel) {\n    return `${channel}-scale's \"${propName}\" is dropped as it does not work with ${scaleType} scale.`;\n}\nexport function scaleTypeNotWorkWithMark(mark, scaleType) {\n    return `Scale type \"${scaleType}\" does not work with mark \"${mark}\".`;\n}\nexport function stepDropped(channel) {\n    return `The step for \"${channel}\" is dropped because the ${channel === 'width' ? 'x' : 'y'} is continuous.`;\n}\nexport function mergeConflictingProperty(property, propertyOf, v1, v2) {\n    return `Conflicting ${propertyOf.toString()} property \"${property.toString()}\" (${stringify(v1)} and ${stringify(v2)}). Using ${stringify(v1)}.`;\n}\nexport function mergeConflictingDomainProperty(property, propertyOf, v1, v2) {\n    return `Conflicting ${propertyOf.toString()} property \"${property.toString()}\" (${stringify(v1)} and ${stringify(v2)}). Using the union of the two domains.`;\n}\nexport function independentScaleMeansIndependentGuide(channel) {\n    return `Setting the scale to be independent for \"${channel}\" means we also have to set the guide (axis or legend) to be independent.`;\n}\nexport function domainSortDropped(sort) {\n    return `Dropping sort property ${stringify(sort)} as unioned domains only support boolean or op \"count\", \"min\", and \"max\".`;\n}\nexport const MORE_THAN_ONE_SORT = 'Domains that should be unioned has conflicting sort properties. Sort will be set to true.';\nexport const FACETED_INDEPENDENT_DIFFERENT_SOURCES = 'Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.';\nexport const FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES = 'Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.';\nexport const FACETED_INDEPENDENT_SAME_SOURCE = 'Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.';\n// AXIS\nexport const INVALID_CHANNEL_FOR_AXIS = 'Invalid channel for axis.';\n// STACK\nexport function cannotStackRangedMark(channel) {\n    return `Cannot stack \"${channel}\" if there is already \"${channel}2\".`;\n}\nexport function cannotStackNonLinearScale(scaleType) {\n    return `Cannot stack non-linear scale (${scaleType}).`;\n}\nexport function stackNonSummativeAggregate(aggregate) {\n    return `Stacking is applied even though the aggregate function is non-summative (\"${aggregate}\").`;\n}\n// TIMEUNIT\nexport function invalidTimeUnit(unitName, value) {\n    return `Invalid ${unitName}: ${stringify(value)}.`;\n}\nexport function droppedDay(d) {\n    return `Dropping day from datetime ${stringify(d)} as day cannot be combined with other units.`;\n}\nexport function errorBarCenterAndExtentAreNotNeeded(center, extent) {\n    return `${extent ? 'extent ' : ''}${extent && center ? 'and ' : ''}${center ? 'center ' : ''}${extent && center ? 'are ' : 'is '}not needed when data are aggregated.`;\n}\nexport function errorBarCenterIsUsedWithWrongExtent(center, extent, mark) {\n    return `${center} is not usually used with ${extent} for ${mark}.`;\n}\nexport function errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark) {\n    return `Continuous axis should not have customized aggregation function ${aggregate}; ${compositeMark} already agregates the axis.`;\n}\nexport function errorBand1DNotSupport(property) {\n    return `1D error band does not support ${property}.`;\n}\n// CHANNEL\nexport function channelRequiredForBinned(channel) {\n    return `Channel ${channel} is required for \"binned\" bin.`;\n}\nexport function channelShouldNotBeUsedForBinned(channel) {\n    return `Channel ${channel} should not be used with \"binned\" bin.`;\n}\nexport function domainRequiredForThresholdScale(channel) {\n    return `Domain for ${channel} is required for threshold scale.`;\n}\n//# sourceMappingURL=message.js.map"]},"metadata":{},"sourceType":"module"}