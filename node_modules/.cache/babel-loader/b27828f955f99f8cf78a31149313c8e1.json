{"ast":null,"code":"import _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { Transform } from 'vega-dataflow';\nimport { Marks, boundClip, GroupItem, Item, Bounds, multiLineOffset, boundStroke } from 'vega-scenegraph';\nimport { inherits, peek, isObject } from 'vega-util';\nvar Top = 'top';\nvar Left = 'left';\nvar Right = 'right';\nvar Bottom = 'bottom';\nvar TopLeft = 'top-left';\nvar TopRight = 'top-right';\nvar BottomLeft = 'bottom-left';\nvar BottomRight = 'bottom-right';\nvar Start = 'start';\nvar Middle = 'middle';\nvar End = 'end';\nvar X = 'x';\nvar Y = 'y';\nvar Group = 'group';\nvar AxisRole = 'axis';\nvar TitleRole = 'title';\nvar FrameRole = 'frame';\nvar ScopeRole = 'scope';\nvar LegendRole = 'legend';\nvar RowHeader = 'row-header';\nvar RowFooter = 'row-footer';\nvar RowTitle = 'row-title';\nvar ColHeader = 'column-header';\nvar ColFooter = 'column-footer';\nvar ColTitle = 'column-title';\nvar Padding = 'padding';\nvar Symbols = 'symbol';\nvar Fit = 'fit';\nvar FitX = 'fit-x';\nvar FitY = 'fit-y';\nvar Pad = 'pad';\nvar None = 'none';\nvar All = 'all';\nvar Each = 'each';\nvar Flush = 'flush';\nvar Column = 'column';\nvar Row = 'row';\n\n/**\n * Calculate bounding boxes for scenegraph items.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - The scenegraph mark instance to bound.\n */\n\nfunction Bound(params) {\n  Transform.call(this, null, params);\n}\ninherits(Bound, Transform, {\n  transform: function transform(_, pulse) {\n    var view = pulse.dataflow,\n      mark = _.mark,\n      type = mark.marktype,\n      entry = Marks[type],\n      bound = entry.bound;\n    var markBounds = mark.bounds,\n      rebound;\n    if (entry.nested) {\n      // multi-item marks have a single bounds instance\n      if (mark.items.length) view.dirty(mark.items[0]);\n      markBounds = boundItem(mark, bound);\n      mark.items.forEach(function (item) {\n        item.bounds.clear().union(markBounds);\n      });\n    } else if (type === Group || _.modified()) {\n      // operator parameters modified -> re-bound all items\n      // updates group bounds in response to modified group content\n      pulse.visit(pulse.MOD, function (item) {\n        return view.dirty(item);\n      });\n      markBounds.clear();\n      mark.items.forEach(function (item) {\n        return markBounds.union(boundItem(item, bound));\n      }); // force reflow for axes/legends/titles to propagate any layout changes\n\n      switch (mark.role) {\n        case AxisRole:\n        case LegendRole:\n        case TitleRole:\n          pulse.reflow();\n      }\n    } else {\n      // incrementally update bounds, re-bound mark as needed\n      rebound = pulse.changed(pulse.REM);\n      pulse.visit(pulse.ADD, function (item) {\n        markBounds.union(boundItem(item, bound));\n      });\n      pulse.visit(pulse.MOD, function (item) {\n        rebound = rebound || markBounds.alignsWith(item.bounds);\n        view.dirty(item);\n        markBounds.union(boundItem(item, bound));\n      });\n      if (rebound) {\n        markBounds.clear();\n        mark.items.forEach(function (item) {\n          return markBounds.union(item.bounds);\n        });\n      }\n    } // ensure mark bounds do not exceed any clipping region\n\n    boundClip(mark);\n    return pulse.modifies('bounds');\n  }\n});\nfunction boundItem(item, bound, opt) {\n  return bound(item.bounds.clear(), item, opt);\n}\nvar COUNTER_NAME = ':vega_identifier:';\n/**\n * Adds a unique identifier to all added tuples.\n * This transform creates a new signal that serves as an id counter.\n * As a result, the id counter is shared across all instances of this\n * transform, generating unique ids across multiple data streams. In\n * addition, this signal value can be included in a snapshot of the\n * dataflow state, enabling correct resumption of id allocation.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {string} params.as - The field name for the generated identifier.\n */\n\nfunction Identifier(params) {\n  Transform.call(this, 0, params);\n}\nIdentifier.Definition = {\n  'type': 'Identifier',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'as',\n    'type': 'string',\n    'required': true\n  }]\n};\ninherits(Identifier, Transform, {\n  transform: function transform(_, pulse) {\n    var counter = getCounter(pulse.dataflow),\n      as = _.as;\n    var id = counter.value;\n    pulse.visit(pulse.ADD, function (t) {\n      return t[as] = t[as] || ++id;\n    });\n    counter.set(this.value = id);\n    return pulse;\n  }\n});\nfunction getCounter(view) {\n  return view._signals[COUNTER_NAME] || (view._signals[COUNTER_NAME] = view.add(0));\n}\n\n/**\n * Bind scenegraph items to a scenegraph mark instance.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.markdef - The mark definition for creating the mark.\n *   This is an object of legal scenegraph mark properties which *must* include\n *   the 'marktype' property.\n */\n\nfunction Mark(params) {\n  Transform.call(this, null, params);\n}\ninherits(Mark, Transform, {\n  transform: function transform(_, pulse) {\n    var mark = this.value; // acquire mark on first invocation, bind context and group\n\n    if (!mark) {\n      mark = pulse.dataflow.scenegraph().mark(_.markdef, lookup(_), _.index);\n      mark.group.context = _.context;\n      if (!_.context.group) _.context.group = mark.group;\n      mark.source = this.source; // point to upstream collector\n\n      mark.clip = _.clip;\n      mark.interactive = _.interactive;\n      this.value = mark;\n    } // initialize entering items\n\n    var Init = mark.marktype === Group ? GroupItem : Item;\n    pulse.visit(pulse.ADD, function (item) {\n      return Init.call(item, mark);\n    }); // update clipping and/or interactive status\n\n    if (_.modified('clip') || _.modified('interactive')) {\n      mark.clip = _.clip;\n      mark.interactive = !!_.interactive;\n      mark.zdirty = true; // force scenegraph re-eval\n\n      pulse.reflow();\n    } // bind items array to scenegraph mark\n\n    mark.items = pulse.source;\n    return pulse;\n  }\n});\nfunction lookup(_) {\n  var g = _.groups,\n    p = _.parent;\n  return g && g.size === 1 ? g.get(Object.keys(g.object)[0]) : g && p ? g.lookup(p) : null;\n}\n\n/**\n * Analyze items for overlap, changing opacity to hide items with\n * overlapping bounding boxes. This transform will preserve at least\n * two items (e.g., first and last) even if overlap persists.\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator\n *   function for sorting items.\n * @param {object} [params.method] - The overlap removal method to apply.\n *   One of 'parity' (default, hide every other item until there is no\n *   more overlap) or 'greedy' (sequentially scan and hide and items that\n *   overlap with the last visible item).\n * @param {object} [params.boundScale] - A scale whose range should be used\n *   to bound the items. Items exceeding the bounds of the scale range\n *   will be treated as overlapping. If null or undefined, no bounds check\n *   will be applied.\n * @param {object} [params.boundOrient] - The orientation of the scale\n *   (top, bottom, left, or right) used to bound items. This parameter is\n *   ignored if boundScale is null or undefined.\n * @param {object} [params.boundTolerance] - The tolerance in pixels for\n *   bound inclusion testing (default 1). This specifies by how many pixels\n *   an item's bounds may exceed the scale range bounds and not be culled.\n * @constructor\n */\n\nfunction Overlap(params) {\n  Transform.call(this, null, params);\n}\nvar methods = {\n  parity: function parity(items) {\n    return items.filter(function (item, i) {\n      return i % 2 ? item.opacity = 0 : 1;\n    });\n  },\n  greedy: function greedy(items, sep) {\n    var a;\n    return items.filter(function (b, i) {\n      return !i || !intersect(a.bounds, b.bounds, sep) ? (a = b, 1) : b.opacity = 0;\n    });\n  }\n}; // compute bounding box intersection\n// including padding pixels of separation\n\nvar intersect = function intersect(a, b, sep) {\n  return sep > Math.max(b.x1 - a.x2, a.x1 - b.x2, b.y1 - a.y2, a.y1 - b.y2);\n};\nvar hasOverlap = function hasOverlap(items, pad) {\n  for (var i = 1, n = items.length, a = items[0].bounds, b; i < n; a = b, ++i) {\n    if (intersect(a, b = items[i].bounds, pad)) return true;\n  }\n};\nvar hasBounds = function hasBounds(item) {\n  var b = item.bounds;\n  return b.width() > 1 && b.height() > 1;\n};\nvar boundTest = function boundTest(scale, orient, tolerance) {\n  var range = scale.range(),\n    b = new Bounds();\n  if (orient === Top || orient === Bottom) {\n    b.set(range[0], -Infinity, range[1], +Infinity);\n  } else {\n    b.set(-Infinity, range[0], +Infinity, range[1]);\n  }\n  b.expand(tolerance || 1);\n  return function (item) {\n    return b.encloses(item.bounds);\n  };\n}; // reset all items to be fully opaque\n\nvar reset = function reset(source) {\n  source.forEach(function (item) {\n    return item.opacity = 1;\n  });\n  return source;\n}; // add all tuples to mod, fork pulse if parameters were modified\n// fork prevents cross-stream tuple pollution (e.g., pulse from scale)\n\nvar reflow = function reflow(pulse, _) {\n  return pulse.reflow(_.modified()).modifies('opacity');\n};\ninherits(Overlap, Transform, {\n  transform: function transform(_, pulse) {\n    var reduce = methods[_.method] || methods.parity,\n      sep = _.separation || 0;\n    var source = pulse.materialize(pulse.SOURCE).source,\n      items,\n      test;\n    if (!source || !source.length) return;\n    if (!_.method) {\n      // early exit if method is falsy\n      if (_.modified('method')) {\n        reset(source);\n        pulse = reflow(pulse, _);\n      }\n      return pulse;\n    } // skip labels with no content\n\n    source = source.filter(hasBounds); // early exit, nothing to do\n\n    if (!source.length) return;\n    if (_.sort) {\n      source = source.slice().sort(_.sort);\n    }\n    items = reset(source);\n    pulse = reflow(pulse, _);\n    if (items.length >= 3 && hasOverlap(items, sep)) {\n      do {\n        items = reduce(items, sep);\n      } while (items.length >= 3 && hasOverlap(items, sep));\n      if (items.length < 3 && !peek(source).opacity) {\n        if (items.length > 1) peek(items).opacity = 0;\n        peek(source).opacity = 1;\n      }\n    }\n    if (_.boundScale && _.boundTolerance >= 0) {\n      test = boundTest(_.boundScale, _.boundOrient, +_.boundTolerance);\n      source.forEach(function (item) {\n        if (!test(item)) item.opacity = 0;\n      });\n    } // re-calculate mark bounds\n\n    var bounds = items[0].mark.bounds.clear();\n    source.forEach(function (item) {\n      if (item.opacity) bounds.union(item.bounds);\n    });\n    return pulse;\n  }\n});\n\n/**\n * Queue modified scenegraph items for rendering.\n * @constructor\n */\n\nfunction Render(params) {\n  Transform.call(this, null, params);\n}\ninherits(Render, Transform, {\n  transform: function transform(_, pulse) {\n    var view = pulse.dataflow;\n    pulse.visit(pulse.ALL, function (item) {\n      return view.dirty(item);\n    }); // set z-index dirty flag as needed\n\n    if (pulse.fields && pulse.fields['zindex']) {\n      var item = pulse.source && pulse.source[0];\n      if (item) item.mark.zdirty = true;\n    }\n  }\n});\nvar tempBounds = new Bounds();\nfunction set(item, property, value) {\n  return item[property] === value ? 0 : (item[property] = value, 1);\n}\nfunction isYAxis(mark) {\n  var orient = mark.items[0].orient;\n  return orient === Left || orient === Right;\n}\nfunction axisIndices(datum) {\n  var index = +datum.grid;\n  return [datum.ticks ? index++ : -1,\n  // ticks index\n  datum.labels ? index++ : -1,\n  // labels index\n  index + +datum.domain // title index\n  ];\n}\n\nfunction axisLayout(view, axis, width, height) {\n  var item = axis.items[0],\n    datum = item.datum,\n    delta = item.translate != null ? item.translate : 0.5,\n    orient = item.orient,\n    indices = axisIndices(datum),\n    range = item.range,\n    offset = item.offset,\n    position = item.position,\n    minExtent = item.minExtent,\n    maxExtent = item.maxExtent,\n    title = datum.title && item.items[indices[2]].items[0],\n    titlePadding = item.titlePadding,\n    bounds = item.bounds,\n    dl = title && multiLineOffset(title),\n    x = 0,\n    y = 0,\n    i,\n    s;\n  tempBounds.clear().union(bounds);\n  bounds.clear();\n  if ((i = indices[0]) > -1) bounds.union(item.items[i].bounds);\n  if ((i = indices[1]) > -1) bounds.union(item.items[i].bounds); // position axis group and title\n\n  switch (orient) {\n    case Top:\n      x = position || 0;\n      y = -offset;\n      s = Math.max(minExtent, Math.min(maxExtent, -bounds.y1));\n      bounds.add(0, -s).add(range, 0);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 0, -1, bounds);\n      break;\n    case Left:\n      x = -offset;\n      y = position || 0;\n      s = Math.max(minExtent, Math.min(maxExtent, -bounds.x1));\n      bounds.add(-s, 0).add(0, range);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, -1, bounds);\n      break;\n    case Right:\n      x = width + offset;\n      y = position || 0;\n      s = Math.max(minExtent, Math.min(maxExtent, bounds.x2));\n      bounds.add(0, 0).add(s, range);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, 1, bounds);\n      break;\n    case Bottom:\n      x = position || 0;\n      y = height + offset;\n      s = Math.max(minExtent, Math.min(maxExtent, bounds.y2));\n      bounds.add(0, 0).add(range, s);\n      if (title) axisTitleLayout(view, title, s, titlePadding, 0, 0, 1, bounds);\n      break;\n    default:\n      x = item.x;\n      y = item.y;\n  } // update bounds\n\n  boundStroke(bounds.translate(x, y), item);\n  if (set(item, 'x', x + delta) | set(item, 'y', y + delta)) {\n    item.bounds = tempBounds;\n    view.dirty(item);\n    item.bounds = bounds;\n    view.dirty(item);\n  }\n  return item.mark.bounds.clear().union(bounds);\n}\nfunction axisTitleLayout(view, title, offset, pad, dl, isYAxis, sign, bounds) {\n  var b = title.bounds;\n  if (title.auto) {\n    var v = sign * (offset + dl + pad);\n    var dx = 0,\n      dy = 0;\n    view.dirty(title);\n    isYAxis ? dx = (title.x || 0) - (title.x = v) : dy = (title.y || 0) - (title.y = v);\n    title.mark.bounds.clear().union(b.translate(-dx, -dy));\n    view.dirty(title);\n  }\n  bounds.union(b);\n}\nvar min = function min(a, b) {\n  return Math.floor(Math.min(a, b));\n};\nvar max = function max(a, b) {\n  return Math.ceil(Math.max(a, b));\n};\nfunction gridLayoutGroups(group) {\n  var _views$rowheaders, _views$rowfooters, _views$colheaders, _views$colfooters, _views$marks;\n  var groups = group.items,\n    n = groups.length,\n    i = 0,\n    mark,\n    items;\n  var views = {\n    marks: [],\n    rowheaders: [],\n    rowfooters: [],\n    colheaders: [],\n    colfooters: [],\n    rowtitle: null,\n    coltitle: null\n  }; // layout axes, gather legends, collect bounds\n\n  for (; i < n; ++i) {\n    mark = groups[i];\n    items = mark.items;\n    if (mark.marktype === Group) {\n      switch (mark.role) {\n        case AxisRole:\n        case LegendRole:\n        case TitleRole:\n          break;\n        case RowHeader:\n          (_views$rowheaders = views.rowheaders).push.apply(_views$rowheaders, _toConsumableArray(items));\n          break;\n        case RowFooter:\n          (_views$rowfooters = views.rowfooters).push.apply(_views$rowfooters, _toConsumableArray(items));\n          break;\n        case ColHeader:\n          (_views$colheaders = views.colheaders).push.apply(_views$colheaders, _toConsumableArray(items));\n          break;\n        case ColFooter:\n          (_views$colfooters = views.colfooters).push.apply(_views$colfooters, _toConsumableArray(items));\n          break;\n        case RowTitle:\n          views.rowtitle = items[0];\n          break;\n        case ColTitle:\n          views.coltitle = items[0];\n          break;\n        default:\n          (_views$marks = views.marks).push.apply(_views$marks, _toConsumableArray(items));\n      }\n    }\n  }\n  return views;\n}\nfunction bboxFlush(item) {\n  return new Bounds().set(0, 0, item.width || 0, item.height || 0);\n}\nfunction bboxFull(item) {\n  var b = item.bounds.clone();\n  return b.empty() ? b.set(0, 0, 0, 0) : b.translate(-(item.x || 0), -(item.y || 0));\n}\nfunction get(opt, key, d) {\n  var v = isObject(opt) ? opt[key] : opt;\n  return v != null ? v : d !== undefined ? d : 0;\n}\nfunction offsetValue(v) {\n  return v < 0 ? Math.ceil(-v) : 0;\n}\nfunction gridLayout(view, groups, opt) {\n  var dirty = !opt.nodirty,\n    bbox = opt.bounds === Flush ? bboxFlush : bboxFull,\n    bounds = tempBounds.set(0, 0, 0, 0),\n    alignCol = get(opt.align, Column),\n    alignRow = get(opt.align, Row),\n    padCol = get(opt.padding, Column),\n    padRow = get(opt.padding, Row),\n    ncols = opt.columns || groups.length,\n    nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),\n    n = groups.length,\n    xOffset = Array(n),\n    xExtent = Array(ncols),\n    xMax = 0,\n    yOffset = Array(n),\n    yExtent = Array(nrows),\n    yMax = 0,\n    dx = Array(n),\n    dy = Array(n),\n    boxes = Array(n),\n    m,\n    i,\n    c,\n    r,\n    b,\n    g,\n    px,\n    py,\n    x,\n    y,\n    offset;\n  for (i = 0; i < ncols; ++i) {\n    xExtent[i] = 0;\n  }\n  for (i = 0; i < nrows; ++i) {\n    yExtent[i] = 0;\n  } // determine offsets for each group\n\n  for (i = 0; i < n; ++i) {\n    g = groups[i];\n    b = boxes[i] = bbox(g);\n    g.x = g.x || 0;\n    dx[i] = 0;\n    g.y = g.y || 0;\n    dy[i] = 0;\n    c = i % ncols;\n    r = ~~(i / ncols);\n    xMax = Math.max(xMax, px = Math.ceil(b.x2));\n    yMax = Math.max(yMax, py = Math.ceil(b.y2));\n    xExtent[c] = Math.max(xExtent[c], px);\n    yExtent[r] = Math.max(yExtent[r], py);\n    xOffset[i] = padCol + offsetValue(b.x1);\n    yOffset[i] = padRow + offsetValue(b.y1);\n    if (dirty) view.dirty(groups[i]);\n  } // set initial alignment offsets\n\n  for (i = 0; i < n; ++i) {\n    if (i % ncols === 0) xOffset[i] = 0;\n    if (i < ncols) yOffset[i] = 0;\n  } // enforce column alignment constraints\n\n  if (alignCol === Each) {\n    for (c = 1; c < ncols; ++c) {\n      for (offset = 0, i = c; i < n; i += ncols) {\n        if (offset < xOffset[i]) offset = xOffset[i];\n      }\n      for (i = c; i < n; i += ncols) {\n        xOffset[i] = offset + xExtent[c - 1];\n      }\n    }\n  } else if (alignCol === All) {\n    for (offset = 0, i = 0; i < n; ++i) {\n      if (i % ncols && offset < xOffset[i]) offset = xOffset[i];\n    }\n    for (i = 0; i < n; ++i) {\n      if (i % ncols) xOffset[i] = offset + xMax;\n    }\n  } else {\n    for (alignCol = false, c = 1; c < ncols; ++c) {\n      for (i = c; i < n; i += ncols) {\n        xOffset[i] += xExtent[c - 1];\n      }\n    }\n  } // enforce row alignment constraints\n\n  if (alignRow === Each) {\n    for (r = 1; r < nrows; ++r) {\n      for (offset = 0, i = r * ncols, m = i + ncols; i < m; ++i) {\n        if (offset < yOffset[i]) offset = yOffset[i];\n      }\n      for (i = r * ncols; i < m; ++i) {\n        yOffset[i] = offset + yExtent[r - 1];\n      }\n    }\n  } else if (alignRow === All) {\n    for (offset = 0, i = ncols; i < n; ++i) {\n      if (offset < yOffset[i]) offset = yOffset[i];\n    }\n    for (i = ncols; i < n; ++i) {\n      yOffset[i] = offset + yMax;\n    }\n  } else {\n    for (alignRow = false, r = 1; r < nrows; ++r) {\n      for (i = r * ncols, m = i + ncols; i < m; ++i) {\n        yOffset[i] += yExtent[r - 1];\n      }\n    }\n  } // perform horizontal grid layout\n\n  for (x = 0, i = 0; i < n; ++i) {\n    x = xOffset[i] + (i % ncols ? x : 0);\n    dx[i] += x - groups[i].x;\n  } // perform vertical grid layout\n\n  for (c = 0; c < ncols; ++c) {\n    for (y = 0, i = c; i < n; i += ncols) {\n      y += yOffset[i];\n      dy[i] += y - groups[i].y;\n    }\n  } // perform horizontal centering\n\n  if (alignCol && get(opt.center, Column) && nrows > 1) {\n    for (i = 0; i < n; ++i) {\n      b = alignCol === All ? xMax : xExtent[i % ncols];\n      x = b - boxes[i].x2 - groups[i].x - dx[i];\n      if (x > 0) dx[i] += x / 2;\n    }\n  } // perform vertical centering\n\n  if (alignRow && get(opt.center, Row) && ncols !== 1) {\n    for (i = 0; i < n; ++i) {\n      b = alignRow === All ? yMax : yExtent[~~(i / ncols)];\n      y = b - boxes[i].y2 - groups[i].y - dy[i];\n      if (y > 0) dy[i] += y / 2;\n    }\n  } // position grid relative to anchor\n\n  for (i = 0; i < n; ++i) {\n    bounds.union(boxes[i].translate(dx[i], dy[i]));\n  }\n  x = get(opt.anchor, X);\n  y = get(opt.anchor, Y);\n  switch (get(opt.anchor, Column)) {\n    case End:\n      x -= bounds.width();\n      break;\n    case Middle:\n      x -= bounds.width() / 2;\n  }\n  switch (get(opt.anchor, Row)) {\n    case End:\n      y -= bounds.height();\n      break;\n    case Middle:\n      y -= bounds.height() / 2;\n  }\n  x = Math.round(x);\n  y = Math.round(y); // update mark positions, bounds, dirty\n\n  bounds.clear();\n  for (i = 0; i < n; ++i) {\n    groups[i].mark.bounds.clear();\n  }\n  for (i = 0; i < n; ++i) {\n    g = groups[i];\n    g.x += dx[i] += x;\n    g.y += dy[i] += y;\n    bounds.union(g.mark.bounds.union(g.bounds.translate(dx[i], dy[i])));\n    if (dirty) view.dirty(g);\n  }\n  return bounds;\n}\nfunction trellisLayout(view, group, opt) {\n  var views = gridLayoutGroups(group),\n    groups = views.marks,\n    bbox = opt.bounds === Flush ? boundFlush : boundFull,\n    off = opt.offset,\n    ncols = opt.columns || groups.length,\n    nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),\n    cells = nrows * ncols,\n    x,\n    y,\n    x2,\n    y2,\n    anchor,\n    band,\n    offset; // -- initial grid layout\n\n  var bounds = gridLayout(view, groups, opt);\n  if (bounds.empty()) bounds.set(0, 0, 0, 0); // empty grid\n  // -- layout grid headers and footers --\n  // perform row header layout\n\n  if (views.rowheaders) {\n    band = get(opt.headerBand, Row, null);\n    x = layoutHeaders(view, views.rowheaders, groups, ncols, nrows, -get(off, 'rowHeader'), min, 0, bbox, 'x1', 0, ncols, 1, band);\n  } // perform column header layout\n\n  if (views.colheaders) {\n    band = get(opt.headerBand, Column, null);\n    y = layoutHeaders(view, views.colheaders, groups, ncols, ncols, -get(off, 'columnHeader'), min, 1, bbox, 'y1', 0, 1, ncols, band);\n  } // perform row footer layout\n\n  if (views.rowfooters) {\n    band = get(opt.footerBand, Row, null);\n    x2 = layoutHeaders(view, views.rowfooters, groups, ncols, nrows, get(off, 'rowFooter'), max, 0, bbox, 'x2', ncols - 1, ncols, 1, band);\n  } // perform column footer layout\n\n  if (views.colfooters) {\n    band = get(opt.footerBand, Column, null);\n    y2 = layoutHeaders(view, views.colfooters, groups, ncols, ncols, get(off, 'columnFooter'), max, 1, bbox, 'y2', cells - ncols, 1, ncols, band);\n  } // perform row title layout\n\n  if (views.rowtitle) {\n    anchor = get(opt.titleAnchor, Row);\n    offset = get(off, 'rowTitle');\n    offset = anchor === End ? x2 + offset : x - offset;\n    band = get(opt.titleBand, Row, 0.5);\n    layoutTitle(view, views.rowtitle, offset, 0, bounds, band);\n  } // perform column title layout\n\n  if (views.coltitle) {\n    anchor = get(opt.titleAnchor, Column);\n    offset = get(off, 'columnTitle');\n    offset = anchor === End ? y2 + offset : y - offset;\n    band = get(opt.titleBand, Column, 0.5);\n    layoutTitle(view, views.coltitle, offset, 1, bounds, band);\n  }\n}\nfunction boundFlush(item, field) {\n  return field === 'x1' ? item.x || 0 : field === 'y1' ? item.y || 0 : field === 'x2' ? (item.x || 0) + (item.width || 0) : field === 'y2' ? (item.y || 0) + (item.height || 0) : undefined;\n}\nfunction boundFull(item, field) {\n  return item.bounds[field];\n}\nfunction layoutHeaders(view, headers, groups, ncols, limit, offset, agg, isX, bound, bf, start, stride, back, band) {\n  var n = groups.length,\n    init = 0,\n    edge = 0,\n    i,\n    j,\n    k,\n    m,\n    b,\n    h,\n    g,\n    x,\n    y; // if no groups, early exit and return 0\n\n  if (!n) return init; // compute margin\n\n  for (i = start; i < n; i += stride) {\n    if (groups[i]) init = agg(init, bound(groups[i], bf));\n  } // if no headers, return margin calculation\n\n  if (!headers.length) return init; // check if number of headers exceeds number of rows or columns\n\n  if (headers.length > limit) {\n    view.warn('Grid headers exceed limit: ' + limit);\n    headers = headers.slice(0, limit);\n  } // apply offset\n\n  init += offset; // clear mark bounds for all headers\n\n  for (j = 0, m = headers.length; j < m; ++j) {\n    view.dirty(headers[j]);\n    headers[j].mark.bounds.clear();\n  } // layout each header\n\n  for (i = start, j = 0, m = headers.length; j < m; ++j, i += stride) {\n    h = headers[j];\n    b = h.mark.bounds; // search for nearest group to align to\n    // necessary if table has empty cells\n\n    for (k = i; k >= 0 && (g = groups[k]) == null; k -= back) {\n      ;\n    } // assign coordinates and update bounds\n\n    if (isX) {\n      x = band == null ? g.x : Math.round(g.bounds.x1 + band * g.bounds.width());\n      y = init;\n    } else {\n      x = init;\n      y = band == null ? g.y : Math.round(g.bounds.y1 + band * g.bounds.height());\n    }\n    b.union(h.bounds.translate(x - (h.x || 0), y - (h.y || 0)));\n    h.x = x;\n    h.y = y;\n    view.dirty(h); // update current edge of layout bounds\n\n    edge = agg(edge, b[bf]);\n  }\n  return edge;\n}\nfunction layoutTitle(view, g, offset, isX, bounds, band) {\n  if (!g) return;\n  view.dirty(g); // compute title coordinates\n\n  var x = offset,\n    y = offset;\n  isX ? x = Math.round(bounds.x1 + band * bounds.width()) : y = Math.round(bounds.y1 + band * bounds.height()); // assign coordinates and update bounds\n\n  g.bounds.translate(x - (g.x || 0), y - (g.y || 0));\n  g.mark.bounds.clear().union(g.bounds);\n  g.x = x;\n  g.y = y; // queue title for redraw\n\n  view.dirty(g);\n}\nfunction lookup$1(config, orient) {\n  var opt = config[orient] || {};\n  return function (key, d) {\n    return opt[key] != null ? opt[key] : config[key] != null ? config[key] : d;\n  };\n} // if legends specify offset directly, use the maximum specified value\n\nfunction offsets(legends, value) {\n  var max = -Infinity;\n  legends.forEach(function (item) {\n    if (item.offset != null) max = Math.max(max, item.offset);\n  });\n  return max > -Infinity ? max : value;\n}\nfunction legendParams(g, orient, config, xb, yb, w, h) {\n  var _ = lookup$1(config, orient),\n    offset = offsets(g, _('offset', 0)),\n    anchor = _('anchor', Start),\n    mult = anchor === End ? 1 : anchor === Middle ? 0.5 : 0;\n  var p = {\n    align: Each,\n    bounds: _('bounds', Flush),\n    columns: _('direction') === 'vertical' ? 1 : g.length,\n    padding: _('margin', 8),\n    center: _('center'),\n    nodirty: true\n  };\n  switch (orient) {\n    case Left:\n      p.anchor = {\n        x: Math.floor(xb.x1) - offset,\n        column: End,\n        y: mult * (h || xb.height() + 2 * xb.y1),\n        row: anchor\n      };\n      break;\n    case Right:\n      p.anchor = {\n        x: Math.ceil(xb.x2) + offset,\n        y: mult * (h || xb.height() + 2 * xb.y1),\n        row: anchor\n      };\n      break;\n    case Top:\n      p.anchor = {\n        y: Math.floor(yb.y1) - offset,\n        row: End,\n        x: mult * (w || yb.width() + 2 * yb.x1),\n        column: anchor\n      };\n      break;\n    case Bottom:\n      p.anchor = {\n        y: Math.ceil(yb.y2) + offset,\n        x: mult * (w || yb.width() + 2 * yb.x1),\n        column: anchor\n      };\n      break;\n    case TopLeft:\n      p.anchor = {\n        x: offset,\n        y: offset\n      };\n      break;\n    case TopRight:\n      p.anchor = {\n        x: w - offset,\n        y: offset,\n        column: End\n      };\n      break;\n    case BottomLeft:\n      p.anchor = {\n        x: offset,\n        y: h - offset,\n        row: End\n      };\n      break;\n    case BottomRight:\n      p.anchor = {\n        x: w - offset,\n        y: h - offset,\n        column: End,\n        row: End\n      };\n      break;\n  }\n  return p;\n}\nfunction legendLayout(view, legend) {\n  var item = legend.items[0],\n    datum = item.datum,\n    orient = item.orient,\n    bounds = item.bounds,\n    x = item.x,\n    y = item.y,\n    w,\n    h; // cache current bounds for later comparison\n\n  item._bounds ? item._bounds.clear().union(bounds) : item._bounds = bounds.clone();\n  bounds.clear(); // adjust legend to accommodate padding and title\n\n  legendGroupLayout(view, item, item.items[0].items[0]); // aggregate bounds to determine size, and include origin\n\n  bounds = legendBounds(item, bounds);\n  w = 2 * item.padding;\n  h = 2 * item.padding;\n  if (!bounds.empty()) {\n    w = Math.ceil(bounds.width() + w);\n    h = Math.ceil(bounds.height() + h);\n  }\n  if (datum.type === Symbols) {\n    legendEntryLayout(item.items[0].items[0].items[0].items);\n  }\n  if (orient !== None) {\n    item.x = x = 0;\n    item.y = y = 0;\n  }\n  item.width = w;\n  item.height = h;\n  boundStroke(bounds.set(x, y, x + w, y + h), item);\n  item.mark.bounds.clear().union(bounds);\n  return item;\n}\nfunction legendBounds(item, b) {\n  // aggregate item bounds\n  item.items.forEach(function (_) {\n    return b.union(_.bounds);\n  }); // anchor to legend origin\n\n  b.x1 = item.padding;\n  b.y1 = item.padding;\n  return b;\n}\nfunction legendGroupLayout(view, item, entry) {\n  var pad = item.padding,\n    ex = pad - entry.x,\n    ey = pad - entry.y;\n  if (!item.datum.title) {\n    if (ex || ey) translate(view, entry, ex, ey);\n  } else {\n    var title = item.items[1].items[0],\n      anchor = title.anchor,\n      tpad = item.titlePadding || 0,\n      tx = pad - title.x,\n      ty = pad - title.y;\n    switch (title.orient) {\n      case Left:\n        ex += Math.ceil(title.bounds.width()) + tpad;\n        break;\n      case Right:\n      case Bottom:\n        break;\n      default:\n        ey += title.bounds.height() + tpad;\n    }\n    if (ex || ey) translate(view, entry, ex, ey);\n    switch (title.orient) {\n      case Left:\n        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\n        break;\n      case Right:\n        tx += legendTitleOffset(item, entry, title, End, 0, 0) + tpad;\n        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\n        break;\n      case Bottom:\n        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\n        ty += legendTitleOffset(item, entry, title, End, -1, 0, 1) + tpad;\n        break;\n      default:\n        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\n    }\n    if (tx || ty) translate(view, title, tx, ty); // translate legend if title pushes into negative coordinates\n\n    if ((tx = Math.round(title.bounds.x1 - pad)) < 0) {\n      translate(view, entry, -tx, 0);\n      translate(view, title, -tx, 0);\n    }\n  }\n}\nfunction legendTitleOffset(item, entry, title, anchor, y, lr, noBar) {\n  var grad = item.datum.type !== 'symbol',\n    vgrad = title.datum.vgrad,\n    e = grad && (lr || !vgrad) && !noBar ? entry.items[0] : entry,\n    s = e.bounds[y ? 'y2' : 'x2'] - item.padding,\n    u = vgrad && lr ? s : 0,\n    v = vgrad && lr ? 0 : s,\n    o = y <= 0 ? 0 : multiLineOffset(title);\n  return Math.round(anchor === Start ? u : anchor === End ? v - o : 0.5 * (s - o));\n}\nfunction translate(view, item, dx, dy) {\n  item.x += dx;\n  item.y += dy;\n  item.bounds.translate(dx, dy);\n  item.mark.bounds.translate(dx, dy);\n  view.dirty(item);\n}\nfunction legendEntryLayout(entries) {\n  // get max widths for each column\n  var widths = entries.reduce(function (w, g) {\n    w[g.column] = Math.max(g.bounds.x2 - g.x, w[g.column] || 0);\n    return w;\n  }, {}); // set dimensions of legend entry groups\n\n  entries.forEach(function (g) {\n    g.width = widths[g.column];\n    g.height = g.bounds.y2 - g.y;\n  });\n}\nfunction titleLayout(view, mark, width, height, viewBounds) {\n  var group = mark.items[0],\n    frame = group.frame,\n    orient = group.orient,\n    anchor = group.anchor,\n    offset = group.offset,\n    padding = group.padding,\n    title = group.items[0].items[0],\n    subtitle = group.items[1] && group.items[1].items[0],\n    end = orient === Left || orient === Right ? height : width,\n    start = 0,\n    x = 0,\n    y = 0,\n    sx = 0,\n    sy = 0,\n    pos;\n  if (frame !== Group) {\n    orient === Left ? (start = viewBounds.y2, end = viewBounds.y1) : orient === Right ? (start = viewBounds.y1, end = viewBounds.y2) : (start = viewBounds.x1, end = viewBounds.x2);\n  } else if (orient === Left) {\n    start = height, end = 0;\n  }\n  pos = anchor === Start ? start : anchor === End ? end : (start + end) / 2;\n  if (subtitle && subtitle.text) {\n    // position subtitle\n    switch (orient) {\n      case Top:\n      case Bottom:\n        sy = title.bounds.height() + padding;\n        break;\n      case Left:\n        sx = title.bounds.width() + padding;\n        break;\n      case Right:\n        sx = -title.bounds.width() - padding;\n        break;\n    }\n    tempBounds.clear().union(subtitle.bounds);\n    tempBounds.translate(sx - (subtitle.x || 0), sy - (subtitle.y || 0));\n    if (set(subtitle, 'x', sx) | set(subtitle, 'y', sy)) {\n      view.dirty(subtitle);\n      subtitle.bounds.clear().union(tempBounds);\n      subtitle.mark.bounds.clear().union(tempBounds);\n      view.dirty(subtitle);\n    }\n    tempBounds.clear().union(subtitle.bounds);\n  } else {\n    tempBounds.clear();\n  }\n  tempBounds.union(title.bounds); // position title group\n\n  switch (orient) {\n    case Top:\n      x = pos;\n      y = viewBounds.y1 - tempBounds.height() - offset;\n      break;\n    case Left:\n      x = viewBounds.x1 - tempBounds.width() - offset;\n      y = pos;\n      break;\n    case Right:\n      x = viewBounds.x2 + tempBounds.width() + offset;\n      y = pos;\n      break;\n    case Bottom:\n      x = pos;\n      y = viewBounds.y2 + offset;\n      break;\n    default:\n      x = group.x;\n      y = group.y;\n  }\n  if (set(group, 'x', x) | set(group, 'y', y)) {\n    tempBounds.translate(x, y);\n    view.dirty(group);\n    group.bounds.clear().union(tempBounds);\n    mark.bounds.clear().union(tempBounds);\n    view.dirty(group);\n  }\n  return group.bounds;\n}\n\n/**\n * Layout view elements such as axes and legends.\n * Also performs size adjustments.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - Scenegraph mark of groups to layout.\n */\n\nfunction ViewLayout(params) {\n  Transform.call(this, null, params);\n}\ninherits(ViewLayout, Transform, {\n  transform: function transform(_, pulse) {\n    var view = pulse.dataflow;\n    _.mark.items.forEach(function (group) {\n      if (_.layout) trellisLayout(view, group, _.layout);\n      layoutGroup(view, group, _);\n    });\n    return shouldReflow(_.mark.group) ? pulse.reflow() : pulse;\n  }\n});\nfunction shouldReflow(group) {\n  // We typically should reflow if layout is invoked (#2568), as child items\n  // may have resized and reflow ensures group bounds are re-calculated.\n  // However, legend entries have a special exception to avoid instability.\n  // For example, if a selected legend symbol gains a stroke on hover,\n  // we don't want to re-position subsequent elements in the legend.\n  return group && group.mark.role !== 'legend-entry';\n}\nfunction layoutGroup(view, group, _) {\n  var items = group.items,\n    width = Math.max(0, group.width || 0),\n    height = Math.max(0, group.height || 0),\n    viewBounds = new Bounds().set(0, 0, width, height),\n    xBounds = viewBounds.clone(),\n    yBounds = viewBounds.clone(),\n    legends = [],\n    title,\n    mark,\n    orient,\n    b,\n    i,\n    n; // layout axes, gather legends, collect bounds\n\n  for (i = 0, n = items.length; i < n; ++i) {\n    mark = items[i];\n    switch (mark.role) {\n      case AxisRole:\n        b = isYAxis(mark) ? xBounds : yBounds;\n        b.union(axisLayout(view, mark, width, height));\n        break;\n      case TitleRole:\n        title = mark;\n        break;\n      case LegendRole:\n        legends.push(legendLayout(view, mark));\n        break;\n      case FrameRole:\n      case ScopeRole:\n      case RowHeader:\n      case RowFooter:\n      case RowTitle:\n      case ColHeader:\n      case ColFooter:\n      case ColTitle:\n        xBounds.union(mark.bounds);\n        yBounds.union(mark.bounds);\n        break;\n      default:\n        viewBounds.union(mark.bounds);\n    }\n  } // layout legends, adjust viewBounds\n\n  if (legends.length) {\n    // group legends by orient\n    var l = {};\n    legends.forEach(function (item) {\n      orient = item.orient || Right;\n      if (orient !== None) (l[orient] || (l[orient] = [])).push(item);\n    }); // perform grid layout for each orient group\n\n    for (var _orient in l) {\n      var g = l[_orient];\n      gridLayout(view, g, legendParams(g, _orient, _.legends, xBounds, yBounds, width, height));\n    } // update view bounds\n\n    legends.forEach(function (item) {\n      var b = item.bounds;\n      if (!b.equals(item._bounds)) {\n        item.bounds = item._bounds;\n        view.dirty(item); // dirty previous location\n\n        item.bounds = b;\n        view.dirty(item);\n      }\n      if (_.autosize && _.autosize.type === Fit) {\n        // For autosize fit, incorporate the orthogonal dimension only.\n        // Legends that overrun the chart area will then be clipped;\n        // otherwise the chart area gets reduced to nothing!\n        switch (item.orient) {\n          case Left:\n          case Right:\n            viewBounds.add(b.x1, 0).add(b.x2, 0);\n            break;\n          case Top:\n          case Bottom:\n            viewBounds.add(0, b.y1).add(0, b.y2);\n        }\n      } else {\n        viewBounds.union(b);\n      }\n    });\n  } // combine bounding boxes\n\n  viewBounds.union(xBounds).union(yBounds); // layout title, adjust bounds\n\n  if (title) {\n    viewBounds.union(titleLayout(view, title, width, height, viewBounds));\n  } // override aggregated view bounds if content is clipped\n\n  if (group.clip) {\n    viewBounds.set(0, 0, group.width || 0, group.height || 0);\n  } // perform size adjustment\n\n  viewSizeLayout(view, group, viewBounds, _);\n}\nfunction viewSizeLayout(view, group, viewBounds, _) {\n  var auto = _.autosize || {},\n    type = auto.type;\n  if (view._autosize < 1 || !type) return;\n  var viewWidth = view._width,\n    viewHeight = view._height,\n    width = Math.max(0, group.width || 0),\n    left = Math.max(0, Math.ceil(-viewBounds.x1)),\n    height = Math.max(0, group.height || 0),\n    top = Math.max(0, Math.ceil(-viewBounds.y1));\n  var right = Math.max(0, Math.ceil(viewBounds.x2 - width)),\n    bottom = Math.max(0, Math.ceil(viewBounds.y2 - height));\n  if (auto.contains === Padding) {\n    var padding = view.padding();\n    viewWidth -= padding.left + padding.right;\n    viewHeight -= padding.top + padding.bottom;\n  }\n  if (type === None) {\n    left = 0;\n    top = 0;\n    width = viewWidth;\n    height = viewHeight;\n  } else if (type === Fit) {\n    width = Math.max(0, viewWidth - left - right);\n    height = Math.max(0, viewHeight - top - bottom);\n  } else if (type === FitX) {\n    width = Math.max(0, viewWidth - left - right);\n    viewHeight = height + top + bottom;\n  } else if (type === FitY) {\n    viewWidth = width + left + right;\n    height = Math.max(0, viewHeight - top - bottom);\n  } else if (type === Pad) {\n    viewWidth = width + left + right;\n    viewHeight = height + top + bottom;\n  }\n  view._resizeView(viewWidth, viewHeight, width, height, [left, top], auto.resize);\n}\nexport { Bound as bound, Identifier as identifier, Mark as mark, Overlap as overlap, Render as render, ViewLayout as viewlayout };","map":{"version":3,"names":["Transform","Marks","boundClip","GroupItem","Item","Bounds","multiLineOffset","boundStroke","inherits","peek","isObject","Top","Left","Right","Bottom","TopLeft","TopRight","BottomLeft","BottomRight","Start","Middle","End","X","Y","Group","AxisRole","TitleRole","FrameRole","ScopeRole","LegendRole","RowHeader","RowFooter","RowTitle","ColHeader","ColFooter","ColTitle","Padding","Symbols","Fit","FitX","FitY","Pad","None","All","Each","Flush","Column","Row","Bound","params","call","transform","_","pulse","view","dataflow","mark","type","marktype","entry","bound","markBounds","bounds","rebound","nested","items","length","dirty","boundItem","forEach","item","clear","union","modified","visit","MOD","role","reflow","changed","REM","ADD","alignsWith","modifies","opt","COUNTER_NAME","Identifier","Definition","counter","getCounter","as","id","value","t","set","_signals","add","Mark","scenegraph","markdef","lookup","index","group","context","source","clip","interactive","Init","zdirty","g","groups","p","parent","size","get","Object","keys","object","Overlap","methods","parity","filter","i","opacity","greedy","sep","a","b","intersect","Math","max","x1","x2","y1","y2","hasOverlap","pad","n","hasBounds","width","height","boundTest","scale","orient","tolerance","range","Infinity","expand","encloses","reset","reduce","method","separation","materialize","SOURCE","test","sort","slice","boundScale","boundTolerance","boundOrient","Render","ALL","fields","tempBounds","property","isYAxis","axisIndices","datum","grid","ticks","labels","domain","axisLayout","axis","delta","translate","indices","offset","position","minExtent","maxExtent","title","titlePadding","dl","x","y","s","min","axisTitleLayout","sign","auto","v","dx","dy","floor","ceil","gridLayoutGroups","views","marks","rowheaders","rowfooters","colheaders","colfooters","rowtitle","coltitle","push","bboxFlush","bboxFull","clone","empty","key","d","undefined","offsetValue","gridLayout","nodirty","bbox","alignCol","align","alignRow","padCol","padding","padRow","ncols","columns","nrows","xOffset","Array","xExtent","xMax","yOffset","yExtent","yMax","boxes","m","c","r","px","py","center","anchor","round","trellisLayout","boundFlush","boundFull","off","cells","band","headerBand","layoutHeaders","footerBand","titleAnchor","titleBand","layoutTitle","field","headers","limit","agg","isX","bf","start","stride","back","init","edge","j","k","h","warn","lookup$1","config","offsets","legends","legendParams","xb","yb","w","mult","column","row","legendLayout","legend","_bounds","legendGroupLayout","legendBounds","legendEntryLayout","ex","ey","tpad","tx","ty","legendTitleOffset","lr","noBar","grad","vgrad","e","u","o","entries","widths","titleLayout","viewBounds","frame","subtitle","end","sx","sy","pos","text","ViewLayout","layout","layoutGroup","shouldReflow","xBounds","yBounds","l","equals","autosize","viewSizeLayout","_autosize","viewWidth","_width","viewHeight","_height","left","top","right","bottom","contains","_resizeView","resize","identifier","overlap","render","viewlayout"],"sources":["/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/vega-view-transforms/build/vega-view-transforms.module.js"],"sourcesContent":["import { Transform } from 'vega-dataflow';\nimport { Marks, boundClip, GroupItem, Item, Bounds, multiLineOffset, boundStroke } from 'vega-scenegraph';\nimport { inherits, peek, isObject } from 'vega-util';\n\nconst Top = 'top';\nconst Left = 'left';\nconst Right = 'right';\nconst Bottom = 'bottom';\nconst TopLeft = 'top-left';\nconst TopRight = 'top-right';\nconst BottomLeft = 'bottom-left';\nconst BottomRight = 'bottom-right';\nconst Start = 'start';\nconst Middle = 'middle';\nconst End = 'end';\nconst X = 'x';\nconst Y = 'y';\nconst Group = 'group';\nconst AxisRole = 'axis';\nconst TitleRole = 'title';\nconst FrameRole = 'frame';\nconst ScopeRole = 'scope';\nconst LegendRole = 'legend';\nconst RowHeader = 'row-header';\nconst RowFooter = 'row-footer';\nconst RowTitle = 'row-title';\nconst ColHeader = 'column-header';\nconst ColFooter = 'column-footer';\nconst ColTitle = 'column-title';\nconst Padding = 'padding';\nconst Symbols = 'symbol';\nconst Fit = 'fit';\nconst FitX = 'fit-x';\nconst FitY = 'fit-y';\nconst Pad = 'pad';\nconst None = 'none';\nconst All = 'all';\nconst Each = 'each';\nconst Flush = 'flush';\nconst Column = 'column';\nconst Row = 'row';\n\n/**\n * Calculate bounding boxes for scenegraph items.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - The scenegraph mark instance to bound.\n */\n\nfunction Bound(params) {\n  Transform.call(this, null, params);\n}\ninherits(Bound, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow,\n          mark = _.mark,\n          type = mark.marktype,\n          entry = Marks[type],\n          bound = entry.bound;\n    let markBounds = mark.bounds,\n        rebound;\n\n    if (entry.nested) {\n      // multi-item marks have a single bounds instance\n      if (mark.items.length) view.dirty(mark.items[0]);\n      markBounds = boundItem(mark, bound);\n      mark.items.forEach(item => {\n        item.bounds.clear().union(markBounds);\n      });\n    } else if (type === Group || _.modified()) {\n      // operator parameters modified -> re-bound all items\n      // updates group bounds in response to modified group content\n      pulse.visit(pulse.MOD, item => view.dirty(item));\n      markBounds.clear();\n      mark.items.forEach(item => markBounds.union(boundItem(item, bound))); // force reflow for axes/legends/titles to propagate any layout changes\n\n      switch (mark.role) {\n        case AxisRole:\n        case LegendRole:\n        case TitleRole:\n          pulse.reflow();\n      }\n    } else {\n      // incrementally update bounds, re-bound mark as needed\n      rebound = pulse.changed(pulse.REM);\n      pulse.visit(pulse.ADD, item => {\n        markBounds.union(boundItem(item, bound));\n      });\n      pulse.visit(pulse.MOD, item => {\n        rebound = rebound || markBounds.alignsWith(item.bounds);\n        view.dirty(item);\n        markBounds.union(boundItem(item, bound));\n      });\n\n      if (rebound) {\n        markBounds.clear();\n        mark.items.forEach(item => markBounds.union(item.bounds));\n      }\n    } // ensure mark bounds do not exceed any clipping region\n\n\n    boundClip(mark);\n    return pulse.modifies('bounds');\n  }\n\n});\n\nfunction boundItem(item, bound, opt) {\n  return bound(item.bounds.clear(), item, opt);\n}\n\nconst COUNTER_NAME = ':vega_identifier:';\n/**\n * Adds a unique identifier to all added tuples.\n * This transform creates a new signal that serves as an id counter.\n * As a result, the id counter is shared across all instances of this\n * transform, generating unique ids across multiple data streams. In\n * addition, this signal value can be included in a snapshot of the\n * dataflow state, enabling correct resumption of id allocation.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {string} params.as - The field name for the generated identifier.\n */\n\nfunction Identifier(params) {\n  Transform.call(this, 0, params);\n}\nIdentifier.Definition = {\n  'type': 'Identifier',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'as',\n    'type': 'string',\n    'required': true\n  }]\n};\ninherits(Identifier, Transform, {\n  transform(_, pulse) {\n    const counter = getCounter(pulse.dataflow),\n          as = _.as;\n    let id = counter.value;\n    pulse.visit(pulse.ADD, t => t[as] = t[as] || ++id);\n    counter.set(this.value = id);\n    return pulse;\n  }\n\n});\n\nfunction getCounter(view) {\n  return view._signals[COUNTER_NAME] || (view._signals[COUNTER_NAME] = view.add(0));\n}\n\n/**\n * Bind scenegraph items to a scenegraph mark instance.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.markdef - The mark definition for creating the mark.\n *   This is an object of legal scenegraph mark properties which *must* include\n *   the 'marktype' property.\n */\n\nfunction Mark(params) {\n  Transform.call(this, null, params);\n}\ninherits(Mark, Transform, {\n  transform(_, pulse) {\n    let mark = this.value; // acquire mark on first invocation, bind context and group\n\n    if (!mark) {\n      mark = pulse.dataflow.scenegraph().mark(_.markdef, lookup(_), _.index);\n      mark.group.context = _.context;\n      if (!_.context.group) _.context.group = mark.group;\n      mark.source = this.source; // point to upstream collector\n\n      mark.clip = _.clip;\n      mark.interactive = _.interactive;\n      this.value = mark;\n    } // initialize entering items\n\n\n    const Init = mark.marktype === Group ? GroupItem : Item;\n    pulse.visit(pulse.ADD, item => Init.call(item, mark)); // update clipping and/or interactive status\n\n    if (_.modified('clip') || _.modified('interactive')) {\n      mark.clip = _.clip;\n      mark.interactive = !!_.interactive;\n      mark.zdirty = true; // force scenegraph re-eval\n\n      pulse.reflow();\n    } // bind items array to scenegraph mark\n\n\n    mark.items = pulse.source;\n    return pulse;\n  }\n\n});\n\nfunction lookup(_) {\n  const g = _.groups,\n        p = _.parent;\n  return g && g.size === 1 ? g.get(Object.keys(g.object)[0]) : g && p ? g.lookup(p) : null;\n}\n\n/**\n * Analyze items for overlap, changing opacity to hide items with\n * overlapping bounding boxes. This transform will preserve at least\n * two items (e.g., first and last) even if overlap persists.\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator\n *   function for sorting items.\n * @param {object} [params.method] - The overlap removal method to apply.\n *   One of 'parity' (default, hide every other item until there is no\n *   more overlap) or 'greedy' (sequentially scan and hide and items that\n *   overlap with the last visible item).\n * @param {object} [params.boundScale] - A scale whose range should be used\n *   to bound the items. Items exceeding the bounds of the scale range\n *   will be treated as overlapping. If null or undefined, no bounds check\n *   will be applied.\n * @param {object} [params.boundOrient] - The orientation of the scale\n *   (top, bottom, left, or right) used to bound items. This parameter is\n *   ignored if boundScale is null or undefined.\n * @param {object} [params.boundTolerance] - The tolerance in pixels for\n *   bound inclusion testing (default 1). This specifies by how many pixels\n *   an item's bounds may exceed the scale range bounds and not be culled.\n * @constructor\n */\n\nfunction Overlap(params) {\n  Transform.call(this, null, params);\n}\nconst methods = {\n  parity: items => items.filter((item, i) => i % 2 ? item.opacity = 0 : 1),\n  greedy: (items, sep) => {\n    let a;\n    return items.filter((b, i) => !i || !intersect(a.bounds, b.bounds, sep) ? (a = b, 1) : b.opacity = 0);\n  }\n}; // compute bounding box intersection\n// including padding pixels of separation\n\nconst intersect = (a, b, sep) => sep > Math.max(b.x1 - a.x2, a.x1 - b.x2, b.y1 - a.y2, a.y1 - b.y2);\n\nconst hasOverlap = (items, pad) => {\n  for (var i = 1, n = items.length, a = items[0].bounds, b; i < n; a = b, ++i) {\n    if (intersect(a, b = items[i].bounds, pad)) return true;\n  }\n};\n\nconst hasBounds = item => {\n  const b = item.bounds;\n  return b.width() > 1 && b.height() > 1;\n};\n\nconst boundTest = (scale, orient, tolerance) => {\n  var range = scale.range(),\n      b = new Bounds();\n\n  if (orient === Top || orient === Bottom) {\n    b.set(range[0], -Infinity, range[1], +Infinity);\n  } else {\n    b.set(-Infinity, range[0], +Infinity, range[1]);\n  }\n\n  b.expand(tolerance || 1);\n  return item => b.encloses(item.bounds);\n}; // reset all items to be fully opaque\n\n\nconst reset = source => {\n  source.forEach(item => item.opacity = 1);\n  return source;\n}; // add all tuples to mod, fork pulse if parameters were modified\n// fork prevents cross-stream tuple pollution (e.g., pulse from scale)\n\n\nconst reflow = (pulse, _) => pulse.reflow(_.modified()).modifies('opacity');\n\ninherits(Overlap, Transform, {\n  transform(_, pulse) {\n    const reduce = methods[_.method] || methods.parity,\n          sep = _.separation || 0;\n    let source = pulse.materialize(pulse.SOURCE).source,\n        items,\n        test;\n    if (!source || !source.length) return;\n\n    if (!_.method) {\n      // early exit if method is falsy\n      if (_.modified('method')) {\n        reset(source);\n        pulse = reflow(pulse, _);\n      }\n\n      return pulse;\n    } // skip labels with no content\n\n\n    source = source.filter(hasBounds); // early exit, nothing to do\n\n    if (!source.length) return;\n\n    if (_.sort) {\n      source = source.slice().sort(_.sort);\n    }\n\n    items = reset(source);\n    pulse = reflow(pulse, _);\n\n    if (items.length >= 3 && hasOverlap(items, sep)) {\n      do {\n        items = reduce(items, sep);\n      } while (items.length >= 3 && hasOverlap(items, sep));\n\n      if (items.length < 3 && !peek(source).opacity) {\n        if (items.length > 1) peek(items).opacity = 0;\n        peek(source).opacity = 1;\n      }\n    }\n\n    if (_.boundScale && _.boundTolerance >= 0) {\n      test = boundTest(_.boundScale, _.boundOrient, +_.boundTolerance);\n      source.forEach(item => {\n        if (!test(item)) item.opacity = 0;\n      });\n    } // re-calculate mark bounds\n\n\n    const bounds = items[0].mark.bounds.clear();\n    source.forEach(item => {\n      if (item.opacity) bounds.union(item.bounds);\n    });\n    return pulse;\n  }\n\n});\n\n/**\n * Queue modified scenegraph items for rendering.\n * @constructor\n */\n\nfunction Render(params) {\n  Transform.call(this, null, params);\n}\ninherits(Render, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow;\n    pulse.visit(pulse.ALL, item => view.dirty(item)); // set z-index dirty flag as needed\n\n    if (pulse.fields && pulse.fields['zindex']) {\n      const item = pulse.source && pulse.source[0];\n      if (item) item.mark.zdirty = true;\n    }\n  }\n\n});\n\nconst tempBounds = new Bounds();\nfunction set(item, property, value) {\n  return item[property] === value ? 0 : (item[property] = value, 1);\n}\n\nfunction isYAxis(mark) {\n  var orient = mark.items[0].orient;\n  return orient === Left || orient === Right;\n}\n\nfunction axisIndices(datum) {\n  let index = +datum.grid;\n  return [datum.ticks ? index++ : -1, // ticks index\n  datum.labels ? index++ : -1, // labels index\n  index + +datum.domain // title index\n  ];\n}\n\nfunction axisLayout(view, axis, width, height) {\n  var item = axis.items[0],\n      datum = item.datum,\n      delta = item.translate != null ? item.translate : 0.5,\n      orient = item.orient,\n      indices = axisIndices(datum),\n      range = item.range,\n      offset = item.offset,\n      position = item.position,\n      minExtent = item.minExtent,\n      maxExtent = item.maxExtent,\n      title = datum.title && item.items[indices[2]].items[0],\n      titlePadding = item.titlePadding,\n      bounds = item.bounds,\n      dl = title && multiLineOffset(title),\n      x = 0,\n      y = 0,\n      i,\n      s;\n  tempBounds.clear().union(bounds);\n  bounds.clear();\n  if ((i = indices[0]) > -1) bounds.union(item.items[i].bounds);\n  if ((i = indices[1]) > -1) bounds.union(item.items[i].bounds); // position axis group and title\n\n  switch (orient) {\n    case Top:\n      x = position || 0;\n      y = -offset;\n      s = Math.max(minExtent, Math.min(maxExtent, -bounds.y1));\n      bounds.add(0, -s).add(range, 0);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 0, -1, bounds);\n      break;\n\n    case Left:\n      x = -offset;\n      y = position || 0;\n      s = Math.max(minExtent, Math.min(maxExtent, -bounds.x1));\n      bounds.add(-s, 0).add(0, range);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, -1, bounds);\n      break;\n\n    case Right:\n      x = width + offset;\n      y = position || 0;\n      s = Math.max(minExtent, Math.min(maxExtent, bounds.x2));\n      bounds.add(0, 0).add(s, range);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, 1, bounds);\n      break;\n\n    case Bottom:\n      x = position || 0;\n      y = height + offset;\n      s = Math.max(minExtent, Math.min(maxExtent, bounds.y2));\n      bounds.add(0, 0).add(range, s);\n      if (title) axisTitleLayout(view, title, s, titlePadding, 0, 0, 1, bounds);\n      break;\n\n    default:\n      x = item.x;\n      y = item.y;\n  } // update bounds\n\n\n  boundStroke(bounds.translate(x, y), item);\n\n  if (set(item, 'x', x + delta) | set(item, 'y', y + delta)) {\n    item.bounds = tempBounds;\n    view.dirty(item);\n    item.bounds = bounds;\n    view.dirty(item);\n  }\n\n  return item.mark.bounds.clear().union(bounds);\n}\n\nfunction axisTitleLayout(view, title, offset, pad, dl, isYAxis, sign, bounds) {\n  const b = title.bounds;\n\n  if (title.auto) {\n    const v = sign * (offset + dl + pad);\n    let dx = 0,\n        dy = 0;\n    view.dirty(title);\n    isYAxis ? dx = (title.x || 0) - (title.x = v) : dy = (title.y || 0) - (title.y = v);\n    title.mark.bounds.clear().union(b.translate(-dx, -dy));\n    view.dirty(title);\n  }\n\n  bounds.union(b);\n}\n\nconst min = (a, b) => Math.floor(Math.min(a, b));\n\nconst max = (a, b) => Math.ceil(Math.max(a, b));\n\nfunction gridLayoutGroups(group) {\n  var groups = group.items,\n      n = groups.length,\n      i = 0,\n      mark,\n      items;\n  const views = {\n    marks: [],\n    rowheaders: [],\n    rowfooters: [],\n    colheaders: [],\n    colfooters: [],\n    rowtitle: null,\n    coltitle: null\n  }; // layout axes, gather legends, collect bounds\n\n  for (; i < n; ++i) {\n    mark = groups[i];\n    items = mark.items;\n\n    if (mark.marktype === Group) {\n      switch (mark.role) {\n        case AxisRole:\n        case LegendRole:\n        case TitleRole:\n          break;\n\n        case RowHeader:\n          views.rowheaders.push(...items);\n          break;\n\n        case RowFooter:\n          views.rowfooters.push(...items);\n          break;\n\n        case ColHeader:\n          views.colheaders.push(...items);\n          break;\n\n        case ColFooter:\n          views.colfooters.push(...items);\n          break;\n\n        case RowTitle:\n          views.rowtitle = items[0];\n          break;\n\n        case ColTitle:\n          views.coltitle = items[0];\n          break;\n\n        default:\n          views.marks.push(...items);\n      }\n    }\n  }\n\n  return views;\n}\n\nfunction bboxFlush(item) {\n  return new Bounds().set(0, 0, item.width || 0, item.height || 0);\n}\n\nfunction bboxFull(item) {\n  const b = item.bounds.clone();\n  return b.empty() ? b.set(0, 0, 0, 0) : b.translate(-(item.x || 0), -(item.y || 0));\n}\n\nfunction get(opt, key, d) {\n  const v = isObject(opt) ? opt[key] : opt;\n  return v != null ? v : d !== undefined ? d : 0;\n}\n\nfunction offsetValue(v) {\n  return v < 0 ? Math.ceil(-v) : 0;\n}\n\nfunction gridLayout(view, groups, opt) {\n  var dirty = !opt.nodirty,\n      bbox = opt.bounds === Flush ? bboxFlush : bboxFull,\n      bounds = tempBounds.set(0, 0, 0, 0),\n      alignCol = get(opt.align, Column),\n      alignRow = get(opt.align, Row),\n      padCol = get(opt.padding, Column),\n      padRow = get(opt.padding, Row),\n      ncols = opt.columns || groups.length,\n      nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),\n      n = groups.length,\n      xOffset = Array(n),\n      xExtent = Array(ncols),\n      xMax = 0,\n      yOffset = Array(n),\n      yExtent = Array(nrows),\n      yMax = 0,\n      dx = Array(n),\n      dy = Array(n),\n      boxes = Array(n),\n      m,\n      i,\n      c,\n      r,\n      b,\n      g,\n      px,\n      py,\n      x,\n      y,\n      offset;\n\n  for (i = 0; i < ncols; ++i) xExtent[i] = 0;\n\n  for (i = 0; i < nrows; ++i) yExtent[i] = 0; // determine offsets for each group\n\n\n  for (i = 0; i < n; ++i) {\n    g = groups[i];\n    b = boxes[i] = bbox(g);\n    g.x = g.x || 0;\n    dx[i] = 0;\n    g.y = g.y || 0;\n    dy[i] = 0;\n    c = i % ncols;\n    r = ~~(i / ncols);\n    xMax = Math.max(xMax, px = Math.ceil(b.x2));\n    yMax = Math.max(yMax, py = Math.ceil(b.y2));\n    xExtent[c] = Math.max(xExtent[c], px);\n    yExtent[r] = Math.max(yExtent[r], py);\n    xOffset[i] = padCol + offsetValue(b.x1);\n    yOffset[i] = padRow + offsetValue(b.y1);\n    if (dirty) view.dirty(groups[i]);\n  } // set initial alignment offsets\n\n\n  for (i = 0; i < n; ++i) {\n    if (i % ncols === 0) xOffset[i] = 0;\n    if (i < ncols) yOffset[i] = 0;\n  } // enforce column alignment constraints\n\n\n  if (alignCol === Each) {\n    for (c = 1; c < ncols; ++c) {\n      for (offset = 0, i = c; i < n; i += ncols) {\n        if (offset < xOffset[i]) offset = xOffset[i];\n      }\n\n      for (i = c; i < n; i += ncols) {\n        xOffset[i] = offset + xExtent[c - 1];\n      }\n    }\n  } else if (alignCol === All) {\n    for (offset = 0, i = 0; i < n; ++i) {\n      if (i % ncols && offset < xOffset[i]) offset = xOffset[i];\n    }\n\n    for (i = 0; i < n; ++i) {\n      if (i % ncols) xOffset[i] = offset + xMax;\n    }\n  } else {\n    for (alignCol = false, c = 1; c < ncols; ++c) {\n      for (i = c; i < n; i += ncols) {\n        xOffset[i] += xExtent[c - 1];\n      }\n    }\n  } // enforce row alignment constraints\n\n\n  if (alignRow === Each) {\n    for (r = 1; r < nrows; ++r) {\n      for (offset = 0, i = r * ncols, m = i + ncols; i < m; ++i) {\n        if (offset < yOffset[i]) offset = yOffset[i];\n      }\n\n      for (i = r * ncols; i < m; ++i) {\n        yOffset[i] = offset + yExtent[r - 1];\n      }\n    }\n  } else if (alignRow === All) {\n    for (offset = 0, i = ncols; i < n; ++i) {\n      if (offset < yOffset[i]) offset = yOffset[i];\n    }\n\n    for (i = ncols; i < n; ++i) {\n      yOffset[i] = offset + yMax;\n    }\n  } else {\n    for (alignRow = false, r = 1; r < nrows; ++r) {\n      for (i = r * ncols, m = i + ncols; i < m; ++i) {\n        yOffset[i] += yExtent[r - 1];\n      }\n    }\n  } // perform horizontal grid layout\n\n\n  for (x = 0, i = 0; i < n; ++i) {\n    x = xOffset[i] + (i % ncols ? x : 0);\n    dx[i] += x - groups[i].x;\n  } // perform vertical grid layout\n\n\n  for (c = 0; c < ncols; ++c) {\n    for (y = 0, i = c; i < n; i += ncols) {\n      y += yOffset[i];\n      dy[i] += y - groups[i].y;\n    }\n  } // perform horizontal centering\n\n\n  if (alignCol && get(opt.center, Column) && nrows > 1) {\n    for (i = 0; i < n; ++i) {\n      b = alignCol === All ? xMax : xExtent[i % ncols];\n      x = b - boxes[i].x2 - groups[i].x - dx[i];\n      if (x > 0) dx[i] += x / 2;\n    }\n  } // perform vertical centering\n\n\n  if (alignRow && get(opt.center, Row) && ncols !== 1) {\n    for (i = 0; i < n; ++i) {\n      b = alignRow === All ? yMax : yExtent[~~(i / ncols)];\n      y = b - boxes[i].y2 - groups[i].y - dy[i];\n      if (y > 0) dy[i] += y / 2;\n    }\n  } // position grid relative to anchor\n\n\n  for (i = 0; i < n; ++i) {\n    bounds.union(boxes[i].translate(dx[i], dy[i]));\n  }\n\n  x = get(opt.anchor, X);\n  y = get(opt.anchor, Y);\n\n  switch (get(opt.anchor, Column)) {\n    case End:\n      x -= bounds.width();\n      break;\n\n    case Middle:\n      x -= bounds.width() / 2;\n  }\n\n  switch (get(opt.anchor, Row)) {\n    case End:\n      y -= bounds.height();\n      break;\n\n    case Middle:\n      y -= bounds.height() / 2;\n  }\n\n  x = Math.round(x);\n  y = Math.round(y); // update mark positions, bounds, dirty\n\n  bounds.clear();\n\n  for (i = 0; i < n; ++i) {\n    groups[i].mark.bounds.clear();\n  }\n\n  for (i = 0; i < n; ++i) {\n    g = groups[i];\n    g.x += dx[i] += x;\n    g.y += dy[i] += y;\n    bounds.union(g.mark.bounds.union(g.bounds.translate(dx[i], dy[i])));\n    if (dirty) view.dirty(g);\n  }\n\n  return bounds;\n}\nfunction trellisLayout(view, group, opt) {\n  var views = gridLayoutGroups(group),\n      groups = views.marks,\n      bbox = opt.bounds === Flush ? boundFlush : boundFull,\n      off = opt.offset,\n      ncols = opt.columns || groups.length,\n      nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),\n      cells = nrows * ncols,\n      x,\n      y,\n      x2,\n      y2,\n      anchor,\n      band,\n      offset; // -- initial grid layout\n\n  const bounds = gridLayout(view, groups, opt);\n  if (bounds.empty()) bounds.set(0, 0, 0, 0); // empty grid\n  // -- layout grid headers and footers --\n  // perform row header layout\n\n  if (views.rowheaders) {\n    band = get(opt.headerBand, Row, null);\n    x = layoutHeaders(view, views.rowheaders, groups, ncols, nrows, -get(off, 'rowHeader'), min, 0, bbox, 'x1', 0, ncols, 1, band);\n  } // perform column header layout\n\n\n  if (views.colheaders) {\n    band = get(opt.headerBand, Column, null);\n    y = layoutHeaders(view, views.colheaders, groups, ncols, ncols, -get(off, 'columnHeader'), min, 1, bbox, 'y1', 0, 1, ncols, band);\n  } // perform row footer layout\n\n\n  if (views.rowfooters) {\n    band = get(opt.footerBand, Row, null);\n    x2 = layoutHeaders(view, views.rowfooters, groups, ncols, nrows, get(off, 'rowFooter'), max, 0, bbox, 'x2', ncols - 1, ncols, 1, band);\n  } // perform column footer layout\n\n\n  if (views.colfooters) {\n    band = get(opt.footerBand, Column, null);\n    y2 = layoutHeaders(view, views.colfooters, groups, ncols, ncols, get(off, 'columnFooter'), max, 1, bbox, 'y2', cells - ncols, 1, ncols, band);\n  } // perform row title layout\n\n\n  if (views.rowtitle) {\n    anchor = get(opt.titleAnchor, Row);\n    offset = get(off, 'rowTitle');\n    offset = anchor === End ? x2 + offset : x - offset;\n    band = get(opt.titleBand, Row, 0.5);\n    layoutTitle(view, views.rowtitle, offset, 0, bounds, band);\n  } // perform column title layout\n\n\n  if (views.coltitle) {\n    anchor = get(opt.titleAnchor, Column);\n    offset = get(off, 'columnTitle');\n    offset = anchor === End ? y2 + offset : y - offset;\n    band = get(opt.titleBand, Column, 0.5);\n    layoutTitle(view, views.coltitle, offset, 1, bounds, band);\n  }\n}\n\nfunction boundFlush(item, field) {\n  return field === 'x1' ? item.x || 0 : field === 'y1' ? item.y || 0 : field === 'x2' ? (item.x || 0) + (item.width || 0) : field === 'y2' ? (item.y || 0) + (item.height || 0) : undefined;\n}\n\nfunction boundFull(item, field) {\n  return item.bounds[field];\n}\n\nfunction layoutHeaders(view, headers, groups, ncols, limit, offset, agg, isX, bound, bf, start, stride, back, band) {\n  var n = groups.length,\n      init = 0,\n      edge = 0,\n      i,\n      j,\n      k,\n      m,\n      b,\n      h,\n      g,\n      x,\n      y; // if no groups, early exit and return 0\n\n  if (!n) return init; // compute margin\n\n  for (i = start; i < n; i += stride) {\n    if (groups[i]) init = agg(init, bound(groups[i], bf));\n  } // if no headers, return margin calculation\n\n\n  if (!headers.length) return init; // check if number of headers exceeds number of rows or columns\n\n  if (headers.length > limit) {\n    view.warn('Grid headers exceed limit: ' + limit);\n    headers = headers.slice(0, limit);\n  } // apply offset\n\n\n  init += offset; // clear mark bounds for all headers\n\n  for (j = 0, m = headers.length; j < m; ++j) {\n    view.dirty(headers[j]);\n    headers[j].mark.bounds.clear();\n  } // layout each header\n\n\n  for (i = start, j = 0, m = headers.length; j < m; ++j, i += stride) {\n    h = headers[j];\n    b = h.mark.bounds; // search for nearest group to align to\n    // necessary if table has empty cells\n\n    for (k = i; k >= 0 && (g = groups[k]) == null; k -= back); // assign coordinates and update bounds\n\n\n    if (isX) {\n      x = band == null ? g.x : Math.round(g.bounds.x1 + band * g.bounds.width());\n      y = init;\n    } else {\n      x = init;\n      y = band == null ? g.y : Math.round(g.bounds.y1 + band * g.bounds.height());\n    }\n\n    b.union(h.bounds.translate(x - (h.x || 0), y - (h.y || 0)));\n    h.x = x;\n    h.y = y;\n    view.dirty(h); // update current edge of layout bounds\n\n    edge = agg(edge, b[bf]);\n  }\n\n  return edge;\n}\n\nfunction layoutTitle(view, g, offset, isX, bounds, band) {\n  if (!g) return;\n  view.dirty(g); // compute title coordinates\n\n  var x = offset,\n      y = offset;\n  isX ? x = Math.round(bounds.x1 + band * bounds.width()) : y = Math.round(bounds.y1 + band * bounds.height()); // assign coordinates and update bounds\n\n  g.bounds.translate(x - (g.x || 0), y - (g.y || 0));\n  g.mark.bounds.clear().union(g.bounds);\n  g.x = x;\n  g.y = y; // queue title for redraw\n\n  view.dirty(g);\n}\n\nfunction lookup$1(config, orient) {\n  const opt = config[orient] || {};\n  return (key, d) => opt[key] != null ? opt[key] : config[key] != null ? config[key] : d;\n} // if legends specify offset directly, use the maximum specified value\n\n\nfunction offsets(legends, value) {\n  let max = -Infinity;\n  legends.forEach(item => {\n    if (item.offset != null) max = Math.max(max, item.offset);\n  });\n  return max > -Infinity ? max : value;\n}\n\nfunction legendParams(g, orient, config, xb, yb, w, h) {\n  const _ = lookup$1(config, orient),\n        offset = offsets(g, _('offset', 0)),\n        anchor = _('anchor', Start),\n        mult = anchor === End ? 1 : anchor === Middle ? 0.5 : 0;\n\n  const p = {\n    align: Each,\n    bounds: _('bounds', Flush),\n    columns: _('direction') === 'vertical' ? 1 : g.length,\n    padding: _('margin', 8),\n    center: _('center'),\n    nodirty: true\n  };\n\n  switch (orient) {\n    case Left:\n      p.anchor = {\n        x: Math.floor(xb.x1) - offset,\n        column: End,\n        y: mult * (h || xb.height() + 2 * xb.y1),\n        row: anchor\n      };\n      break;\n\n    case Right:\n      p.anchor = {\n        x: Math.ceil(xb.x2) + offset,\n        y: mult * (h || xb.height() + 2 * xb.y1),\n        row: anchor\n      };\n      break;\n\n    case Top:\n      p.anchor = {\n        y: Math.floor(yb.y1) - offset,\n        row: End,\n        x: mult * (w || yb.width() + 2 * yb.x1),\n        column: anchor\n      };\n      break;\n\n    case Bottom:\n      p.anchor = {\n        y: Math.ceil(yb.y2) + offset,\n        x: mult * (w || yb.width() + 2 * yb.x1),\n        column: anchor\n      };\n      break;\n\n    case TopLeft:\n      p.anchor = {\n        x: offset,\n        y: offset\n      };\n      break;\n\n    case TopRight:\n      p.anchor = {\n        x: w - offset,\n        y: offset,\n        column: End\n      };\n      break;\n\n    case BottomLeft:\n      p.anchor = {\n        x: offset,\n        y: h - offset,\n        row: End\n      };\n      break;\n\n    case BottomRight:\n      p.anchor = {\n        x: w - offset,\n        y: h - offset,\n        column: End,\n        row: End\n      };\n      break;\n  }\n\n  return p;\n}\nfunction legendLayout(view, legend) {\n  var item = legend.items[0],\n      datum = item.datum,\n      orient = item.orient,\n      bounds = item.bounds,\n      x = item.x,\n      y = item.y,\n      w,\n      h; // cache current bounds for later comparison\n\n  item._bounds ? item._bounds.clear().union(bounds) : item._bounds = bounds.clone();\n  bounds.clear(); // adjust legend to accommodate padding and title\n\n  legendGroupLayout(view, item, item.items[0].items[0]); // aggregate bounds to determine size, and include origin\n\n  bounds = legendBounds(item, bounds);\n  w = 2 * item.padding;\n  h = 2 * item.padding;\n\n  if (!bounds.empty()) {\n    w = Math.ceil(bounds.width() + w);\n    h = Math.ceil(bounds.height() + h);\n  }\n\n  if (datum.type === Symbols) {\n    legendEntryLayout(item.items[0].items[0].items[0].items);\n  }\n\n  if (orient !== None) {\n    item.x = x = 0;\n    item.y = y = 0;\n  }\n\n  item.width = w;\n  item.height = h;\n  boundStroke(bounds.set(x, y, x + w, y + h), item);\n  item.mark.bounds.clear().union(bounds);\n  return item;\n}\n\nfunction legendBounds(item, b) {\n  // aggregate item bounds\n  item.items.forEach(_ => b.union(_.bounds)); // anchor to legend origin\n\n  b.x1 = item.padding;\n  b.y1 = item.padding;\n  return b;\n}\n\nfunction legendGroupLayout(view, item, entry) {\n  var pad = item.padding,\n      ex = pad - entry.x,\n      ey = pad - entry.y;\n\n  if (!item.datum.title) {\n    if (ex || ey) translate(view, entry, ex, ey);\n  } else {\n    var title = item.items[1].items[0],\n        anchor = title.anchor,\n        tpad = item.titlePadding || 0,\n        tx = pad - title.x,\n        ty = pad - title.y;\n\n    switch (title.orient) {\n      case Left:\n        ex += Math.ceil(title.bounds.width()) + tpad;\n        break;\n\n      case Right:\n      case Bottom:\n        break;\n\n      default:\n        ey += title.bounds.height() + tpad;\n    }\n\n    if (ex || ey) translate(view, entry, ex, ey);\n\n    switch (title.orient) {\n      case Left:\n        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\n        break;\n\n      case Right:\n        tx += legendTitleOffset(item, entry, title, End, 0, 0) + tpad;\n        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\n        break;\n\n      case Bottom:\n        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\n        ty += legendTitleOffset(item, entry, title, End, -1, 0, 1) + tpad;\n        break;\n\n      default:\n        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\n    }\n\n    if (tx || ty) translate(view, title, tx, ty); // translate legend if title pushes into negative coordinates\n\n    if ((tx = Math.round(title.bounds.x1 - pad)) < 0) {\n      translate(view, entry, -tx, 0);\n      translate(view, title, -tx, 0);\n    }\n  }\n}\n\nfunction legendTitleOffset(item, entry, title, anchor, y, lr, noBar) {\n  const grad = item.datum.type !== 'symbol',\n        vgrad = title.datum.vgrad,\n        e = grad && (lr || !vgrad) && !noBar ? entry.items[0] : entry,\n        s = e.bounds[y ? 'y2' : 'x2'] - item.padding,\n        u = vgrad && lr ? s : 0,\n        v = vgrad && lr ? 0 : s,\n        o = y <= 0 ? 0 : multiLineOffset(title);\n  return Math.round(anchor === Start ? u : anchor === End ? v - o : 0.5 * (s - o));\n}\n\nfunction translate(view, item, dx, dy) {\n  item.x += dx;\n  item.y += dy;\n  item.bounds.translate(dx, dy);\n  item.mark.bounds.translate(dx, dy);\n  view.dirty(item);\n}\n\nfunction legendEntryLayout(entries) {\n  // get max widths for each column\n  const widths = entries.reduce((w, g) => {\n    w[g.column] = Math.max(g.bounds.x2 - g.x, w[g.column] || 0);\n    return w;\n  }, {}); // set dimensions of legend entry groups\n\n  entries.forEach(g => {\n    g.width = widths[g.column];\n    g.height = g.bounds.y2 - g.y;\n  });\n}\n\nfunction titleLayout(view, mark, width, height, viewBounds) {\n  var group = mark.items[0],\n      frame = group.frame,\n      orient = group.orient,\n      anchor = group.anchor,\n      offset = group.offset,\n      padding = group.padding,\n      title = group.items[0].items[0],\n      subtitle = group.items[1] && group.items[1].items[0],\n      end = orient === Left || orient === Right ? height : width,\n      start = 0,\n      x = 0,\n      y = 0,\n      sx = 0,\n      sy = 0,\n      pos;\n\n  if (frame !== Group) {\n    orient === Left ? (start = viewBounds.y2, end = viewBounds.y1) : orient === Right ? (start = viewBounds.y1, end = viewBounds.y2) : (start = viewBounds.x1, end = viewBounds.x2);\n  } else if (orient === Left) {\n    start = height, end = 0;\n  }\n\n  pos = anchor === Start ? start : anchor === End ? end : (start + end) / 2;\n\n  if (subtitle && subtitle.text) {\n    // position subtitle\n    switch (orient) {\n      case Top:\n      case Bottom:\n        sy = title.bounds.height() + padding;\n        break;\n\n      case Left:\n        sx = title.bounds.width() + padding;\n        break;\n\n      case Right:\n        sx = -title.bounds.width() - padding;\n        break;\n    }\n\n    tempBounds.clear().union(subtitle.bounds);\n    tempBounds.translate(sx - (subtitle.x || 0), sy - (subtitle.y || 0));\n\n    if (set(subtitle, 'x', sx) | set(subtitle, 'y', sy)) {\n      view.dirty(subtitle);\n      subtitle.bounds.clear().union(tempBounds);\n      subtitle.mark.bounds.clear().union(tempBounds);\n      view.dirty(subtitle);\n    }\n\n    tempBounds.clear().union(subtitle.bounds);\n  } else {\n    tempBounds.clear();\n  }\n\n  tempBounds.union(title.bounds); // position title group\n\n  switch (orient) {\n    case Top:\n      x = pos;\n      y = viewBounds.y1 - tempBounds.height() - offset;\n      break;\n\n    case Left:\n      x = viewBounds.x1 - tempBounds.width() - offset;\n      y = pos;\n      break;\n\n    case Right:\n      x = viewBounds.x2 + tempBounds.width() + offset;\n      y = pos;\n      break;\n\n    case Bottom:\n      x = pos;\n      y = viewBounds.y2 + offset;\n      break;\n\n    default:\n      x = group.x;\n      y = group.y;\n  }\n\n  if (set(group, 'x', x) | set(group, 'y', y)) {\n    tempBounds.translate(x, y);\n    view.dirty(group);\n    group.bounds.clear().union(tempBounds);\n    mark.bounds.clear().union(tempBounds);\n    view.dirty(group);\n  }\n\n  return group.bounds;\n}\n\n/**\n * Layout view elements such as axes and legends.\n * Also performs size adjustments.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - Scenegraph mark of groups to layout.\n */\n\nfunction ViewLayout(params) {\n  Transform.call(this, null, params);\n}\ninherits(ViewLayout, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow;\n\n    _.mark.items.forEach(group => {\n      if (_.layout) trellisLayout(view, group, _.layout);\n      layoutGroup(view, group, _);\n    });\n\n    return shouldReflow(_.mark.group) ? pulse.reflow() : pulse;\n  }\n\n});\n\nfunction shouldReflow(group) {\n  // We typically should reflow if layout is invoked (#2568), as child items\n  // may have resized and reflow ensures group bounds are re-calculated.\n  // However, legend entries have a special exception to avoid instability.\n  // For example, if a selected legend symbol gains a stroke on hover,\n  // we don't want to re-position subsequent elements in the legend.\n  return group && group.mark.role !== 'legend-entry';\n}\n\nfunction layoutGroup(view, group, _) {\n  var items = group.items,\n      width = Math.max(0, group.width || 0),\n      height = Math.max(0, group.height || 0),\n      viewBounds = new Bounds().set(0, 0, width, height),\n      xBounds = viewBounds.clone(),\n      yBounds = viewBounds.clone(),\n      legends = [],\n      title,\n      mark,\n      orient,\n      b,\n      i,\n      n; // layout axes, gather legends, collect bounds\n\n  for (i = 0, n = items.length; i < n; ++i) {\n    mark = items[i];\n\n    switch (mark.role) {\n      case AxisRole:\n        b = isYAxis(mark) ? xBounds : yBounds;\n        b.union(axisLayout(view, mark, width, height));\n        break;\n\n      case TitleRole:\n        title = mark;\n        break;\n\n      case LegendRole:\n        legends.push(legendLayout(view, mark));\n        break;\n\n      case FrameRole:\n      case ScopeRole:\n      case RowHeader:\n      case RowFooter:\n      case RowTitle:\n      case ColHeader:\n      case ColFooter:\n      case ColTitle:\n        xBounds.union(mark.bounds);\n        yBounds.union(mark.bounds);\n        break;\n\n      default:\n        viewBounds.union(mark.bounds);\n    }\n  } // layout legends, adjust viewBounds\n\n\n  if (legends.length) {\n    // group legends by orient\n    const l = {};\n    legends.forEach(item => {\n      orient = item.orient || Right;\n      if (orient !== None) (l[orient] || (l[orient] = [])).push(item);\n    }); // perform grid layout for each orient group\n\n    for (const orient in l) {\n      const g = l[orient];\n      gridLayout(view, g, legendParams(g, orient, _.legends, xBounds, yBounds, width, height));\n    } // update view bounds\n\n\n    legends.forEach(item => {\n      const b = item.bounds;\n\n      if (!b.equals(item._bounds)) {\n        item.bounds = item._bounds;\n        view.dirty(item); // dirty previous location\n\n        item.bounds = b;\n        view.dirty(item);\n      }\n\n      if (_.autosize && _.autosize.type === Fit) {\n        // For autosize fit, incorporate the orthogonal dimension only.\n        // Legends that overrun the chart area will then be clipped;\n        // otherwise the chart area gets reduced to nothing!\n        switch (item.orient) {\n          case Left:\n          case Right:\n            viewBounds.add(b.x1, 0).add(b.x2, 0);\n            break;\n\n          case Top:\n          case Bottom:\n            viewBounds.add(0, b.y1).add(0, b.y2);\n        }\n      } else {\n        viewBounds.union(b);\n      }\n    });\n  } // combine bounding boxes\n\n\n  viewBounds.union(xBounds).union(yBounds); // layout title, adjust bounds\n\n  if (title) {\n    viewBounds.union(titleLayout(view, title, width, height, viewBounds));\n  } // override aggregated view bounds if content is clipped\n\n\n  if (group.clip) {\n    viewBounds.set(0, 0, group.width || 0, group.height || 0);\n  } // perform size adjustment\n\n\n  viewSizeLayout(view, group, viewBounds, _);\n}\n\nfunction viewSizeLayout(view, group, viewBounds, _) {\n  const auto = _.autosize || {},\n        type = auto.type;\n  if (view._autosize < 1 || !type) return;\n  let viewWidth = view._width,\n      viewHeight = view._height,\n      width = Math.max(0, group.width || 0),\n      left = Math.max(0, Math.ceil(-viewBounds.x1)),\n      height = Math.max(0, group.height || 0),\n      top = Math.max(0, Math.ceil(-viewBounds.y1));\n  const right = Math.max(0, Math.ceil(viewBounds.x2 - width)),\n        bottom = Math.max(0, Math.ceil(viewBounds.y2 - height));\n\n  if (auto.contains === Padding) {\n    const padding = view.padding();\n    viewWidth -= padding.left + padding.right;\n    viewHeight -= padding.top + padding.bottom;\n  }\n\n  if (type === None) {\n    left = 0;\n    top = 0;\n    width = viewWidth;\n    height = viewHeight;\n  } else if (type === Fit) {\n    width = Math.max(0, viewWidth - left - right);\n    height = Math.max(0, viewHeight - top - bottom);\n  } else if (type === FitX) {\n    width = Math.max(0, viewWidth - left - right);\n    viewHeight = height + top + bottom;\n  } else if (type === FitY) {\n    viewWidth = width + left + right;\n    height = Math.max(0, viewHeight - top - bottom);\n  } else if (type === Pad) {\n    viewWidth = width + left + right;\n    viewHeight = height + top + bottom;\n  }\n\n  view._resizeView(viewWidth, viewHeight, width, height, [left, top], auto.resize);\n}\n\nexport { Bound as bound, Identifier as identifier, Mark as mark, Overlap as overlap, Render as render, ViewLayout as viewlayout };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}