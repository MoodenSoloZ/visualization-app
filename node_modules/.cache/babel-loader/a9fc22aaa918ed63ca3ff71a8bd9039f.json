{"ast":null,"code":"import _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _inherits from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Optimizer_modified;\nimport { GraticuleNode } from './graticule';\nimport { SequenceNode } from './sequence';\nimport { SourceNode } from './source';\n/**\n * Whether this dataflow node is the source of the dataflow that produces data i.e. a source or a generator.\n */\nexport function isDataSourceNode(node) {\n  return node instanceof SourceNode || node instanceof GraticuleNode || node instanceof SequenceNode;\n}\n/**\n * Abstract base class for Dataflow optimizers.\n * Contains only mutation handling logic. Subclasses need to implement iteration logic.\n */\nexport var Optimizer = /*#__PURE__*/function () {\n  function Optimizer() {\n    _classCallCheck(this, Optimizer);\n    _Optimizer_modified.set(this, void 0);\n    __classPrivateFieldSet(this, _Optimizer_modified, false, \"f\");\n  }\n  // Once true, #modified is never set to false\n  _createClass(Optimizer, [{\n    key: \"setModified\",\n    value: function setModified() {\n      __classPrivateFieldSet(this, _Optimizer_modified, true, \"f\");\n    }\n  }, {\n    key: \"modifiedFlag\",\n    get: function get() {\n      return __classPrivateFieldGet(this, _Optimizer_modified, \"f\");\n    }\n  }]);\n  return Optimizer;\n}();\n_Optimizer_modified = new WeakMap();\n/**\n * Starts from a node and runs the optimization function (the \"run\" method) upwards to the root,\n * depending on the continue and modified flag values returned by the optimization function.\n */\nexport var BottomUpOptimizer = /*#__PURE__*/function (_Optimizer) {\n  _inherits(BottomUpOptimizer, _Optimizer);\n  var _super = _createSuper(BottomUpOptimizer);\n  function BottomUpOptimizer() {\n    _classCallCheck(this, BottomUpOptimizer);\n    return _super.apply(this, arguments);\n  }\n  _createClass(BottomUpOptimizer, [{\n    key: \"getNodeDepths\",\n    value:\n    /**\n     * Compute a map of node depths that we can use to determine a topological sort order.\n     */\n    function getNodeDepths(node, depth, depths) {\n      depths.set(node, depth);\n      var _iterator = _createForOfIteratorHelper(node.children),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var child = _step.value;\n          this.getNodeDepths(child, depth + 1, depths);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return depths;\n    }\n    /**\n     * Run the optimizer on all nodes starting from the leaves.\n     */\n  }, {\n    key: \"optimize\",\n    value: function optimize(node) {\n      var depths = this.getNodeDepths(node, 0, new Map());\n      var topologicalSort = _toConsumableArray(depths.entries()).sort(function (a, b) {\n        return b[1] - a[1];\n      });\n      var _iterator2 = _createForOfIteratorHelper(topologicalSort),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var tuple = _step2.value;\n          this.run(tuple[0]);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return this.modifiedFlag;\n    }\n  }]);\n  return BottomUpOptimizer;\n}(Optimizer);\n/**\n * The optimizer function (the \"run\" method), is invoked on the given node and then continues recursively.\n */\nexport var TopDownOptimizer = /*#__PURE__*/function (_Optimizer2) {\n  _inherits(TopDownOptimizer, _Optimizer2);\n  var _super2 = _createSuper(TopDownOptimizer);\n  function TopDownOptimizer() {\n    _classCallCheck(this, TopDownOptimizer);\n    return _super2.apply(this, arguments);\n  }\n  _createClass(TopDownOptimizer, [{\n    key: \"optimize\",\n    value:\n    /**\n     * Run the optimizer depth first on all nodes starting from the roots.\n     */\n    function optimize(node) {\n      this.run(node);\n      var _iterator3 = _createForOfIteratorHelper(node.children),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var child = _step3.value;\n          this.optimize(child);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return this.modifiedFlag;\n    }\n  }]);\n  return TopDownOptimizer;\n}(Optimizer);","map":{"version":3,"sources":["../../../../src/compile/data/optimizer.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AACA,SAAQ,aAAa,QAAO,aAAa;AACzC,SAAQ,YAAY,QAAO,YAAY;AACvC,SAAQ,UAAU,QAAO,UAAU;AAEnC;;AAEG;AACH,OAAM,SAAU,gBAAgB,CAAC,IAAkB,EAAA;EACjD,OAAO,IAAI,YAAY,UAAU,IAAI,IAAI,YAAY,aAAa,IAAI,IAAI,YAAY,YAAY;AACpG;AAEA;;;AAGG;AACH,WAAsB,SAAS;EAG7B,qBAAA;IAAA;IAFA,mBAAA,CAAA,GAAA,CAAA,IAAA,EAAA,KAAA,CAAA,CAAA;IAGE,sBAAA,CAAA,IAAI,EAAA,mBAAA,EAAa,KAAK,EAAA,GAAA,CAAA;EACxB;EAEA;EAAA;IAAA;IAAA,OACO,uBAAW;MAChB,sBAAA,CAAA,IAAI,EAAA,mBAAA,EAAa,IAAI,EAAA,GAAA,CAAA;IACvB;EAAC;IAAA;IAAA,KAED,eAAgB;MACd,OAAO,sBAAA,CAAA,IAAI,EAAA,mBAAA,EAAA,GAAA,CAAU;IACvB;EAAC;EAAA;AAAA;;AAQH;;;AAGG;AACH,WAAsB,iBAAkB;EAAA;EAAA;EAAA;IAAA;IAAA;EAAA;EAAA;IAAA;IAAA;IAMtC;;AAEG;IACK,uBACN,IAAkB,EAClB,KAAa,EACb,MAAiC,EAAA;MAEjC,MAAM,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC;MAAC,2CAEJ,IAAI,CAAC,QAAQ;QAAA;MAAA;QAAjC,oDAAmC;UAAA,IAAxB,KAAK;UACd,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,KAAK,GAAG,CAAC,EAAE,MAAM,CAAC;;MAC7C;QAAA;MAAA;QAAA;MAAA;MAED,OAAO,MAAM;IACf;IAEA;;AAEG;EAFH;IAAA;IAAA,OAGO,kBAAS,IAAkB,EAAA;MAChC,IAAM,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC,EAAE,IAAI,GAAG,EAAE,CAAC;MACrD,IAAM,eAAe,GAAG,mBAAI,MAAM,CAAC,OAAO,EAAE,EAAE,IAAI,CAAC,UAAC,CAAC,EAAE,CAAC;QAAA,OAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;MAAA,EAAC;MAAC,4CAEtD,eAAe;QAAA;MAAA;QAAnC,uDAAqC;UAAA,IAA1B,KAAK;UACd,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;;MACnB;QAAA;MAAA;QAAA;MAAA;MAED,OAAO,IAAI,CAAC,YAAY;IAC1B;EAAC;EAAA;AAAA,EAnC6C,SAAS;AAsCzD;;AAEG;AACH,WAAsB,gBAAiB;EAAA;EAAA;EAAA;IAAA;IAAA;EAAA;EAAA;IAAA;IAAA;IAMrC;;AAEG;IACI,kBAAS,IAAkB,EAAA;MAChC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC;MAAC,4CAEK,IAAI,CAAC,QAAQ;QAAA;MAAA;QAAjC,uDAAmC;UAAA,IAAxB,KAAK;UACd,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC;;MACrB;QAAA;MAAA;QAAA;MAAA;MAED,OAAO,IAAI,CAAC,YAAY;IAC1B;EAAC;EAAA;AAAA,EAjB4C,SAAS","sourceRoot":"","sourcesContent":["var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Optimizer_modified;\nimport { GraticuleNode } from './graticule';\nimport { SequenceNode } from './sequence';\nimport { SourceNode } from './source';\n/**\n * Whether this dataflow node is the source of the dataflow that produces data i.e. a source or a generator.\n */\nexport function isDataSourceNode(node) {\n    return node instanceof SourceNode || node instanceof GraticuleNode || node instanceof SequenceNode;\n}\n/**\n * Abstract base class for Dataflow optimizers.\n * Contains only mutation handling logic. Subclasses need to implement iteration logic.\n */\nexport class Optimizer {\n    constructor() {\n        _Optimizer_modified.set(this, void 0);\n        __classPrivateFieldSet(this, _Optimizer_modified, false, \"f\");\n    }\n    // Once true, #modified is never set to false\n    setModified() {\n        __classPrivateFieldSet(this, _Optimizer_modified, true, \"f\");\n    }\n    get modifiedFlag() {\n        return __classPrivateFieldGet(this, _Optimizer_modified, \"f\");\n    }\n}\n_Optimizer_modified = new WeakMap();\n/**\n * Starts from a node and runs the optimization function (the \"run\" method) upwards to the root,\n * depending on the continue and modified flag values returned by the optimization function.\n */\nexport class BottomUpOptimizer extends Optimizer {\n    /**\n     * Compute a map of node depths that we can use to determine a topological sort order.\n     */\n    getNodeDepths(node, depth, depths) {\n        depths.set(node, depth);\n        for (const child of node.children) {\n            this.getNodeDepths(child, depth + 1, depths);\n        }\n        return depths;\n    }\n    /**\n     * Run the optimizer on all nodes starting from the leaves.\n     */\n    optimize(node) {\n        const depths = this.getNodeDepths(node, 0, new Map());\n        const topologicalSort = [...depths.entries()].sort((a, b) => b[1] - a[1]);\n        for (const tuple of topologicalSort) {\n            this.run(tuple[0]);\n        }\n        return this.modifiedFlag;\n    }\n}\n/**\n * The optimizer function (the \"run\" method), is invoked on the given node and then continues recursively.\n */\nexport class TopDownOptimizer extends Optimizer {\n    /**\n     * Run the optimizer depth first on all nodes starting from the roots.\n     */\n    optimize(node) {\n        this.run(node);\n        for (const child of node.children) {\n            this.optimize(child);\n        }\n        return this.modifiedFlag;\n    }\n}\n//# sourceMappingURL=optimizer.js.map"]},"metadata":{},"sourceType":"module"}