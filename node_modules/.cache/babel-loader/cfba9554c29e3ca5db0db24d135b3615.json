{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _defineProperty from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { COLOR, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef, isFieldDef } from '../../channeldef';\nimport { LEGEND_SCALE_CHANNELS } from '../../legend';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport { GEOJSON } from '../../type';\nimport { deleteNestedProperty, isEmpty, keys, varName } from '../../util';\nimport { mergeTitleComponent } from '../common';\nimport { guideEncodeEntry } from '../guide';\nimport { isUnitModel } from '../model';\nimport { parseGuideResolve } from '../resolve';\nimport { parseInteractiveLegend } from '../selection/legends';\nimport { defaultTieBreaker, makeImplicit, mergeValuesWithExplicit } from '../split';\nimport { LegendComponent, LEGEND_COMPONENT_PROPERTIES } from './component';\nimport { legendEncodeRules } from './encode';\nimport { getDirection, getLegendType, legendRules } from './properties';\nexport function parseLegend(model) {\n  var legendComponent = isUnitModel(model) ? parseUnitLegend(model) : parseNonUnitLegend(model);\n  model.component.legends = legendComponent;\n  return legendComponent;\n}\nfunction parseUnitLegend(model) {\n  var encoding = model.encoding;\n  var legendComponent = {};\n  for (var _i = 0, _arr = [COLOR].concat(_toConsumableArray(LEGEND_SCALE_CHANNELS)); _i < _arr.length; _i++) {\n    var channel = _arr[_i];\n    var def = getFieldOrDatumDef(encoding[channel]);\n    if (!def || !model.getScaleComponent(channel)) {\n      continue;\n    }\n    if (channel === SHAPE && isFieldDef(def) && def.type === GEOJSON) {\n      continue;\n    }\n    legendComponent[channel] = parseLegendForChannel(model, channel);\n  }\n  return legendComponent;\n}\nfunction getLegendDefWithScale(model, channel) {\n  var scale = model.scaleName(channel);\n  if (model.mark === 'trail') {\n    if (channel === 'color') {\n      // trail is a filled mark, but its default symbolType (\"stroke\") should use \"stroke\"\n      return {\n        stroke: scale\n      };\n    } else if (channel === 'size') {\n      return {\n        strokeWidth: scale\n      };\n    }\n  }\n  if (channel === 'color') {\n    return model.markDef.filled ? {\n      fill: scale\n    } : {\n      stroke: scale\n    };\n  }\n  return _defineProperty({}, channel, scale);\n}\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isExplicit(value, property, legend, fieldDef) {\n  switch (property) {\n    case 'disable':\n      return legend !== undefined;\n    // if axis is specified or null/false, then its enable/disable state is explicit\n    case 'values':\n      // specified legend.values is already respected, but may get transformed.\n      return !!(legend === null || legend === void 0 ? void 0 : legend.values);\n    case 'title':\n      // title can be explicit if fieldDef.title is set\n      if (property === 'title' && value === (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.title)) {\n        return true;\n      }\n  }\n  // Otherwise, things are explicit if the returned value matches the specified property\n  return value === (legend || {})[property];\n}\nexport function parseLegendForChannel(model, channel) {\n  var _a, _b, _c;\n  var legend = model.legend(channel);\n  var markDef = model.markDef,\n    encoding = model.encoding,\n    config = model.config;\n  var legendConfig = config.legend;\n  var legendCmpt = new LegendComponent({}, getLegendDefWithScale(model, channel));\n  parseInteractiveLegend(model, channel, legendCmpt);\n  var disable = legend !== undefined ? !legend : legendConfig.disable;\n  legendCmpt.set('disable', disable, legend !== undefined);\n  if (disable) {\n    return legendCmpt;\n  }\n  legend = legend || {};\n  var scaleType = model.getScaleComponent(channel).get('type');\n  var fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n  var timeUnit = isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : undefined;\n  var orient = legend.orient || config.legend.orient || 'right';\n  var legendType = getLegendType({\n    legend: legend,\n    channel: channel,\n    timeUnit: timeUnit,\n    scaleType: scaleType\n  });\n  var direction = getDirection({\n    legend: legend,\n    legendType: legendType,\n    orient: orient,\n    legendConfig: legendConfig\n  });\n  var ruleParams = {\n    legend: legend,\n    channel: channel,\n    model: model,\n    markDef: markDef,\n    encoding: encoding,\n    fieldOrDatumDef: fieldOrDatumDef,\n    legendConfig: legendConfig,\n    config: config,\n    scaleType: scaleType,\n    orient: orient,\n    legendType: legendType,\n    direction: direction\n  };\n  var _iterator = _createForOfIteratorHelper(LEGEND_COMPONENT_PROPERTIES),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var property = _step.value;\n      if (legendType === 'gradient' && property.startsWith('symbol') || legendType === 'symbol' && property.startsWith('gradient')) {\n        continue;\n      }\n      var _value = property in legendRules ? legendRules[property](ruleParams) : legend[property];\n      if (_value !== undefined) {\n        var explicit = isExplicit(_value, property, legend, model.fieldDef(channel));\n        if (explicit || config.legend[property] === undefined) {\n          legendCmpt.set(property, _value, explicit);\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var legendEncoding = (_b = legend === null || legend === void 0 ? void 0 : legend.encoding) !== null && _b !== void 0 ? _b : {};\n  var selections = legendCmpt.get('selections');\n  var legendEncode = {};\n  var legendEncodeParams = {\n    fieldOrDatumDef: fieldOrDatumDef,\n    model: model,\n    channel: channel,\n    legendCmpt: legendCmpt,\n    legendType: legendType\n  };\n  for (var _i2 = 0, _arr2 = ['labels', 'legend', 'title', 'symbols', 'gradient', 'entries']; _i2 < _arr2.length; _i2++) {\n    var part = _arr2[_i2];\n    var legendEncodingPart = guideEncodeEntry((_c = legendEncoding[part]) !== null && _c !== void 0 ? _c : {}, model);\n    var value = part in legendEncodeRules ? legendEncodeRules[part](legendEncodingPart, legendEncodeParams) // apply rule\n    : legendEncodingPart; // no rule -- just default values\n    if (value !== undefined && !isEmpty(value)) {\n      legendEncode[part] = Object.assign(Object.assign(Object.assign({}, (selections === null || selections === void 0 ? void 0 : selections.length) && isFieldDef(fieldOrDatumDef) ? {\n        name: \"\".concat(varName(fieldOrDatumDef.field), \"_legend_\").concat(part)\n      } : {}), (selections === null || selections === void 0 ? void 0 : selections.length) ? {\n        interactive: !!selections\n      } : {}), {\n        update: value\n      });\n    }\n  }\n  if (!isEmpty(legendEncode)) {\n    legendCmpt.set('encode', legendEncode, !!(legend === null || legend === void 0 ? void 0 : legend.encoding));\n  }\n  return legendCmpt;\n}\nfunction parseNonUnitLegend(model) {\n  var _model$component = model.component,\n    legends = _model$component.legends,\n    resolve = _model$component.resolve;\n  var _iterator2 = _createForOfIteratorHelper(model.children),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var child = _step2.value;\n      parseLegend(child);\n      var _iterator4 = _createForOfIteratorHelper(keys(child.component.legends)),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var channel = _step4.value;\n          resolve.legend[channel] = parseGuideResolve(model.component.resolve, channel);\n          if (resolve.legend[channel] === 'shared') {\n            // If the resolve says shared (and has not been overridden)\n            // We will try to merge and see if there is a conflict\n            legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);\n            if (!legends[channel]) {\n              // If merge returns nothing, there is a conflict so we cannot make the legend shared.\n              // Thus, mark legend as independent and remove the legend component.\n              resolve.legend[channel] = 'independent';\n              delete legends[channel];\n            }\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  var _iterator3 = _createForOfIteratorHelper(keys(legends)),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _channel = _step3.value;\n      var _iterator5 = _createForOfIteratorHelper(model.children),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _child = _step5.value;\n          if (!_child.component.legends[_channel]) {\n            // skip if the child does not have a particular legend\n            continue;\n          }\n          if (resolve.legend[_channel] === 'shared') {\n            // After merging shared legend, make sure to remove legend from child\n            delete _child.component.legends[_channel];\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return legends;\n}\nexport function mergeLegendComponent(mergedLegend, childLegend) {\n  var _a, _b, _c, _d;\n  if (!mergedLegend) {\n    return childLegend.clone();\n  }\n  var mergedOrient = mergedLegend.getWithExplicit('orient');\n  var childOrient = childLegend.getWithExplicit('orient');\n  if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n    // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n    // Cannot merge due to inconsistent orient\n    return undefined;\n  }\n  var typeMerged = false;\n  // Otherwise, let's merge\n  var _iterator6 = _createForOfIteratorHelper(LEGEND_COMPONENT_PROPERTIES),\n    _step6;\n  try {\n    var _loop = function _loop() {\n      var prop = _step6.value;\n      var mergedValueWithExplicit = mergeValuesWithExplicit(mergedLegend.getWithExplicit(prop), childLegend.getWithExplicit(prop), prop, 'legend',\n      // Tie breaker function\n      function (v1, v2) {\n        switch (prop) {\n          case 'symbolType':\n            return mergeSymbolType(v1, v2);\n          case 'title':\n            return mergeTitleComponent(v1, v2);\n          case 'type':\n            // There are only two types. If we have different types, then prefer symbol over gradient.\n            typeMerged = true;\n            return makeImplicit('symbol');\n        }\n        return defaultTieBreaker(v1, v2, prop, 'legend');\n      });\n      mergedLegend.setWithExplicit(prop, mergedValueWithExplicit);\n    };\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  if (typeMerged) {\n    if ((_b = (_a = mergedLegend.implicit) === null || _a === void 0 ? void 0 : _a.encode) === null || _b === void 0 ? void 0 : _b.gradient) {\n      deleteNestedProperty(mergedLegend.implicit, ['encode', 'gradient']);\n    }\n    if ((_d = (_c = mergedLegend.explicit) === null || _c === void 0 ? void 0 : _c.encode) === null || _d === void 0 ? void 0 : _d.gradient) {\n      deleteNestedProperty(mergedLegend.explicit, ['encode', 'gradient']);\n    }\n  }\n  return mergedLegend;\n}\nfunction mergeSymbolType(st1, st2) {\n  if (st2.value === 'circle') {\n    // prefer \"circle\" over \"stroke\"\n    return st2;\n  }\n  return st1;\n}","map":{"version":3,"sources":["../../../../src/compile/legend/parse.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { COLOR, SHAPE } from '../../channel';\nimport { getFieldOrDatumDef, isFieldDef } from '../../channeldef';\nimport { LEGEND_SCALE_CHANNELS } from '../../legend';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport { GEOJSON } from '../../type';\nimport { deleteNestedProperty, isEmpty, keys, varName } from '../../util';\nimport { mergeTitleComponent } from '../common';\nimport { guideEncodeEntry } from '../guide';\nimport { isUnitModel } from '../model';\nimport { parseGuideResolve } from '../resolve';\nimport { parseInteractiveLegend } from '../selection/legends';\nimport { defaultTieBreaker, makeImplicit, mergeValuesWithExplicit } from '../split';\nimport { LegendComponent, LEGEND_COMPONENT_PROPERTIES } from './component';\nimport { legendEncodeRules } from './encode';\nimport { getDirection, getLegendType, legendRules } from './properties';\nexport function parseLegend(model) {\n    const legendComponent = isUnitModel(model) ? parseUnitLegend(model) : parseNonUnitLegend(model);\n    model.component.legends = legendComponent;\n    return legendComponent;\n}\nfunction parseUnitLegend(model) {\n    const { encoding } = model;\n    const legendComponent = {};\n    for (const channel of [COLOR, ...LEGEND_SCALE_CHANNELS]) {\n        const def = getFieldOrDatumDef(encoding[channel]);\n        if (!def || !model.getScaleComponent(channel)) {\n            continue;\n        }\n        if (channel === SHAPE && isFieldDef(def) && def.type === GEOJSON) {\n            continue;\n        }\n        legendComponent[channel] = parseLegendForChannel(model, channel);\n    }\n    return legendComponent;\n}\nfunction getLegendDefWithScale(model, channel) {\n    const scale = model.scaleName(channel);\n    if (model.mark === 'trail') {\n        if (channel === 'color') {\n            // trail is a filled mark, but its default symbolType (\"stroke\") should use \"stroke\"\n            return { stroke: scale };\n        }\n        else if (channel === 'size') {\n            return { strokeWidth: scale };\n        }\n    }\n    if (channel === 'color') {\n        return model.markDef.filled ? { fill: scale } : { stroke: scale };\n    }\n    return { [channel]: scale };\n}\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isExplicit(value, property, legend, fieldDef) {\n    switch (property) {\n        case 'disable':\n            return legend !== undefined; // if axis is specified or null/false, then its enable/disable state is explicit\n        case 'values':\n            // specified legend.values is already respected, but may get transformed.\n            return !!(legend === null || legend === void 0 ? void 0 : legend.values);\n        case 'title':\n            // title can be explicit if fieldDef.title is set\n            if (property === 'title' && value === (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.title)) {\n                return true;\n            }\n    }\n    // Otherwise, things are explicit if the returned value matches the specified property\n    return value === (legend || {})[property];\n}\nexport function parseLegendForChannel(model, channel) {\n    var _a, _b, _c;\n    let legend = model.legend(channel);\n    const { markDef, encoding, config } = model;\n    const legendConfig = config.legend;\n    const legendCmpt = new LegendComponent({}, getLegendDefWithScale(model, channel));\n    parseInteractiveLegend(model, channel, legendCmpt);\n    const disable = legend !== undefined ? !legend : legendConfig.disable;\n    legendCmpt.set('disable', disable, legend !== undefined);\n    if (disable) {\n        return legendCmpt;\n    }\n    legend = legend || {};\n    const scaleType = model.getScaleComponent(channel).get('type');\n    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n    const timeUnit = isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : undefined;\n    const orient = legend.orient || config.legend.orient || 'right';\n    const legendType = getLegendType({ legend, channel, timeUnit, scaleType });\n    const direction = getDirection({ legend, legendType, orient, legendConfig });\n    const ruleParams = {\n        legend,\n        channel,\n        model,\n        markDef,\n        encoding,\n        fieldOrDatumDef,\n        legendConfig,\n        config,\n        scaleType,\n        orient,\n        legendType,\n        direction\n    };\n    for (const property of LEGEND_COMPONENT_PROPERTIES) {\n        if ((legendType === 'gradient' && property.startsWith('symbol')) ||\n            (legendType === 'symbol' && property.startsWith('gradient'))) {\n            continue;\n        }\n        const value = property in legendRules ? legendRules[property](ruleParams) : legend[property];\n        if (value !== undefined) {\n            const explicit = isExplicit(value, property, legend, model.fieldDef(channel));\n            if (explicit || config.legend[property] === undefined) {\n                legendCmpt.set(property, value, explicit);\n            }\n        }\n    }\n    const legendEncoding = (_b = legend === null || legend === void 0 ? void 0 : legend.encoding) !== null && _b !== void 0 ? _b : {};\n    const selections = legendCmpt.get('selections');\n    const legendEncode = {};\n    const legendEncodeParams = { fieldOrDatumDef, model, channel, legendCmpt, legendType };\n    for (const part of ['labels', 'legend', 'title', 'symbols', 'gradient', 'entries']) {\n        const legendEncodingPart = guideEncodeEntry((_c = legendEncoding[part]) !== null && _c !== void 0 ? _c : {}, model);\n        const value = part in legendEncodeRules\n            ? legendEncodeRules[part](legendEncodingPart, legendEncodeParams) // apply rule\n            : legendEncodingPart; // no rule -- just default values\n        if (value !== undefined && !isEmpty(value)) {\n            legendEncode[part] = Object.assign(Object.assign(Object.assign({}, ((selections === null || selections === void 0 ? void 0 : selections.length) && isFieldDef(fieldOrDatumDef)\n                ? { name: `${varName(fieldOrDatumDef.field)}_legend_${part}` }\n                : {})), ((selections === null || selections === void 0 ? void 0 : selections.length) ? { interactive: !!selections } : {})), { update: value });\n        }\n    }\n    if (!isEmpty(legendEncode)) {\n        legendCmpt.set('encode', legendEncode, !!(legend === null || legend === void 0 ? void 0 : legend.encoding));\n    }\n    return legendCmpt;\n}\nfunction parseNonUnitLegend(model) {\n    const { legends, resolve } = model.component;\n    for (const child of model.children) {\n        parseLegend(child);\n        for (const channel of keys(child.component.legends)) {\n            resolve.legend[channel] = parseGuideResolve(model.component.resolve, channel);\n            if (resolve.legend[channel] === 'shared') {\n                // If the resolve says shared (and has not been overridden)\n                // We will try to merge and see if there is a conflict\n                legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);\n                if (!legends[channel]) {\n                    // If merge returns nothing, there is a conflict so we cannot make the legend shared.\n                    // Thus, mark legend as independent and remove the legend component.\n                    resolve.legend[channel] = 'independent';\n                    delete legends[channel];\n                }\n            }\n        }\n    }\n    for (const channel of keys(legends)) {\n        for (const child of model.children) {\n            if (!child.component.legends[channel]) {\n                // skip if the child does not have a particular legend\n                continue;\n            }\n            if (resolve.legend[channel] === 'shared') {\n                // After merging shared legend, make sure to remove legend from child\n                delete child.component.legends[channel];\n            }\n        }\n    }\n    return legends;\n}\nexport function mergeLegendComponent(mergedLegend, childLegend) {\n    var _a, _b, _c, _d;\n    if (!mergedLegend) {\n        return childLegend.clone();\n    }\n    const mergedOrient = mergedLegend.getWithExplicit('orient');\n    const childOrient = childLegend.getWithExplicit('orient');\n    if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n        // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n        // Cannot merge due to inconsistent orient\n        return undefined;\n    }\n    let typeMerged = false;\n    // Otherwise, let's merge\n    for (const prop of LEGEND_COMPONENT_PROPERTIES) {\n        const mergedValueWithExplicit = mergeValuesWithExplicit(mergedLegend.getWithExplicit(prop), childLegend.getWithExplicit(prop), prop, 'legend', \n        // Tie breaker function\n        (v1, v2) => {\n            switch (prop) {\n                case 'symbolType':\n                    return mergeSymbolType(v1, v2);\n                case 'title':\n                    return mergeTitleComponent(v1, v2);\n                case 'type':\n                    // There are only two types. If we have different types, then prefer symbol over gradient.\n                    typeMerged = true;\n                    return makeImplicit('symbol');\n            }\n            return defaultTieBreaker(v1, v2, prop, 'legend');\n        });\n        mergedLegend.setWithExplicit(prop, mergedValueWithExplicit);\n    }\n    if (typeMerged) {\n        if ((_b = (_a = mergedLegend.implicit) === null || _a === void 0 ? void 0 : _a.encode) === null || _b === void 0 ? void 0 : _b.gradient) {\n            deleteNestedProperty(mergedLegend.implicit, ['encode', 'gradient']);\n        }\n        if ((_d = (_c = mergedLegend.explicit) === null || _c === void 0 ? void 0 : _c.encode) === null || _d === void 0 ? void 0 : _d.gradient) {\n            deleteNestedProperty(mergedLegend.explicit, ['encode', 'gradient']);\n        }\n    }\n    return mergedLegend;\n}\nfunction mergeSymbolType(st1, st2) {\n    if (st2.value === 'circle') {\n        // prefer \"circle\" over \"stroke\"\n        return st2;\n    }\n    return st1;\n}\n//# sourceMappingURL=parse.js.map"]},"metadata":{},"sourceType":"module"}