{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { parseSelector } from 'vega-event-selector';\nimport { isString } from 'vega-util';\nimport { TUPLE } from '.';\nimport { varName } from '../../util';\nimport inputBindings from './inputs';\nimport toggle, { TOGGLE } from './toggle';\nvar clear = {\n  defined: function defined(selCmpt) {\n    return selCmpt.clear !== undefined && selCmpt.clear !== false;\n  },\n  parse: function parse(model, selCmpt) {\n    if (selCmpt.clear) {\n      selCmpt.clear = isString(selCmpt.clear) ? parseSelector(selCmpt.clear, 'view') : selCmpt.clear;\n    }\n  },\n  topLevelSignals: function topLevelSignals(model, selCmpt, signals) {\n    if (inputBindings.defined(selCmpt)) {\n      var _iterator = _createForOfIteratorHelper(selCmpt.project.items),\n        _step;\n      try {\n        var _loop = function _loop() {\n          var proj = _step.value;\n          var idx = signals.findIndex(function (n) {\n            return n.name === varName(\"\".concat(selCmpt.name, \"_\").concat(proj.field));\n          });\n          if (idx !== -1) {\n            signals[idx].on.push({\n              events: selCmpt.clear,\n              update: 'null'\n            });\n          }\n        };\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    return signals;\n  },\n  signals: function signals(model, selCmpt, _signals) {\n    function addClear(idx, update) {\n      if (idx !== -1 && _signals[idx].on) {\n        _signals[idx].on.push({\n          events: selCmpt.clear,\n          update: update\n        });\n      }\n    }\n    // Be as minimalist as possible when adding clear triggers to minimize dataflow execution.\n    if (selCmpt.type === 'interval') {\n      var _iterator2 = _createForOfIteratorHelper(selCmpt.project.items),\n        _step2;\n      try {\n        var _loop2 = function _loop2() {\n          var proj = _step2.value;\n          var vIdx = _signals.findIndex(function (n) {\n            return n.name === proj.signals.visual;\n          });\n          addClear(vIdx, '[0, 0]');\n          if (vIdx === -1) {\n            var dIdx = _signals.findIndex(function (n) {\n              return n.name === proj.signals.data;\n            });\n            addClear(dIdx, 'null');\n          }\n        };\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          _loop2();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    } else {\n      var tIdx = _signals.findIndex(function (n) {\n        return n.name === selCmpt.name + TUPLE;\n      });\n      addClear(tIdx, 'null');\n      if (toggle.defined(selCmpt)) {\n        tIdx = _signals.findIndex(function (n) {\n          return n.name === selCmpt.name + TOGGLE;\n        });\n        addClear(tIdx, 'false');\n      }\n    }\n    return _signals;\n  }\n};\nexport default clear;","map":{"version":3,"sources":["../../../../src/compile/selection/clear.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { parseSelector } from 'vega-event-selector';\nimport { isString } from 'vega-util';\nimport { TUPLE } from '.';\nimport { varName } from '../../util';\nimport inputBindings from './inputs';\nimport toggle, { TOGGLE } from './toggle';\nconst clear = {\n    defined: selCmpt => {\n        return selCmpt.clear !== undefined && selCmpt.clear !== false;\n    },\n    parse: (model, selCmpt) => {\n        if (selCmpt.clear) {\n            selCmpt.clear = isString(selCmpt.clear) ? parseSelector(selCmpt.clear, 'view') : selCmpt.clear;\n        }\n    },\n    topLevelSignals: (model, selCmpt, signals) => {\n        if (inputBindings.defined(selCmpt)) {\n            for (const proj of selCmpt.project.items) {\n                const idx = signals.findIndex(n => n.name === varName(`${selCmpt.name}_${proj.field}`));\n                if (idx !== -1) {\n                    signals[idx].on.push({ events: selCmpt.clear, update: 'null' });\n                }\n            }\n        }\n        return signals;\n    },\n    signals: (model, selCmpt, signals) => {\n        function addClear(idx, update) {\n            if (idx !== -1 && signals[idx].on) {\n                signals[idx].on.push({ events: selCmpt.clear, update });\n            }\n        }\n        // Be as minimalist as possible when adding clear triggers to minimize dataflow execution.\n        if (selCmpt.type === 'interval') {\n            for (const proj of selCmpt.project.items) {\n                const vIdx = signals.findIndex(n => n.name === proj.signals.visual);\n                addClear(vIdx, '[0, 0]');\n                if (vIdx === -1) {\n                    const dIdx = signals.findIndex(n => n.name === proj.signals.data);\n                    addClear(dIdx, 'null');\n                }\n            }\n        }\n        else {\n            let tIdx = signals.findIndex(n => n.name === selCmpt.name + TUPLE);\n            addClear(tIdx, 'null');\n            if (toggle.defined(selCmpt)) {\n                tIdx = signals.findIndex(n => n.name === selCmpt.name + TOGGLE);\n                addClear(tIdx, 'false');\n            }\n        }\n        return signals;\n    }\n};\nexport default clear;\n//# sourceMappingURL=clear.js.map"]},"metadata":{},"sourceType":"module"}