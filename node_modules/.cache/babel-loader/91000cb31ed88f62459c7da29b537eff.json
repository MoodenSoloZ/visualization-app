{"ast":null,"code":"import * as log from '../../../log';\nimport { contains } from '../../../util';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { nonPosition } from './nonposition';\nexport function color(model) {\n  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    filled: undefined\n  };\n  var _a, _b, _c, _d;\n  var markDef = model.markDef,\n    encoding = model.encoding,\n    config = model.config;\n  var markType = markDef.type;\n  // Allow filled to be overridden (for trail's \"filled\")\n  var filled = (_a = opt.filled) !== null && _a !== void 0 ? _a : getMarkPropOrConfig('filled', markDef, config);\n  var transparentIfNeeded = contains(['bar', 'point', 'circle', 'square', 'geoshape'], markType) ? 'transparent' : undefined;\n  var defaultFill = (_c = (_b = getMarkPropOrConfig(filled === true ? 'color' : undefined, markDef, config, {\n    vgChannel: 'fill'\n  })) !== null && _b !== void 0 ? _b :\n  // need to add this manually as getMarkConfig normally drops config.mark[channel] if vgChannel is specified\n  config.mark[filled === true && 'color']) !== null && _c !== void 0 ? _c :\n  // If there is no fill, always fill symbols, bar, geoshape\n  // with transparent fills https://github.com/vega/vega-lite/issues/1316\n  transparentIfNeeded;\n  var defaultStroke = (_d = getMarkPropOrConfig(filled === false ? 'color' : undefined, markDef, config, {\n    vgChannel: 'stroke'\n  })) !== null && _d !== void 0 ? _d :\n  // need to add this manually as getMarkConfig normally drops config.mark[channel] if vgChannel is specified\n  config.mark[filled === false && 'color'];\n  var colorVgChannel = filled ? 'fill' : 'stroke';\n  var fillStrokeMarkDefAndConfig = Object.assign(Object.assign({}, defaultFill ? {\n    fill: signalOrValueRef(defaultFill)\n  } : {}), defaultStroke ? {\n    stroke: signalOrValueRef(defaultStroke)\n  } : {});\n  if (markDef.color && (filled ? markDef.fill : markDef.stroke)) {\n    log.warn(log.message.droppingColor('property', {\n      fill: 'fill' in markDef,\n      stroke: 'stroke' in markDef\n    }));\n  }\n  return Object.assign(Object.assign(Object.assign(Object.assign({}, fillStrokeMarkDefAndConfig), nonPosition('color', model, {\n    vgChannel: colorVgChannel,\n    defaultValue: filled ? defaultFill : defaultStroke\n  })), nonPosition('fill', model, {\n    // if there is encoding.fill, include default fill just in case we have conditional-only fill encoding\n    defaultValue: encoding.fill ? defaultFill : undefined\n  })), nonPosition('stroke', model, {\n    // if there is encoding.stroke, include default fill just in case we have conditional-only stroke encoding\n    defaultValue: encoding.stroke ? defaultStroke : undefined\n  }));\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/color.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as log from '../../../log';\nimport { contains } from '../../../util';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { nonPosition } from './nonposition';\nexport function color(model, opt = { filled: undefined }) {\n    var _a, _b, _c, _d;\n    const { markDef, encoding, config } = model;\n    const { type: markType } = markDef;\n    // Allow filled to be overridden (for trail's \"filled\")\n    const filled = (_a = opt.filled) !== null && _a !== void 0 ? _a : getMarkPropOrConfig('filled', markDef, config);\n    const transparentIfNeeded = contains(['bar', 'point', 'circle', 'square', 'geoshape'], markType)\n        ? 'transparent'\n        : undefined;\n    const defaultFill = (_c = (_b = getMarkPropOrConfig(filled === true ? 'color' : undefined, markDef, config, { vgChannel: 'fill' })) !== null && _b !== void 0 ? _b : \n    // need to add this manually as getMarkConfig normally drops config.mark[channel] if vgChannel is specified\n    config.mark[filled === true && 'color']) !== null && _c !== void 0 ? _c : \n    // If there is no fill, always fill symbols, bar, geoshape\n    // with transparent fills https://github.com/vega/vega-lite/issues/1316\n    transparentIfNeeded;\n    const defaultStroke = (_d = getMarkPropOrConfig(filled === false ? 'color' : undefined, markDef, config, { vgChannel: 'stroke' })) !== null && _d !== void 0 ? _d : \n    // need to add this manually as getMarkConfig normally drops config.mark[channel] if vgChannel is specified\n    config.mark[filled === false && 'color'];\n    const colorVgChannel = filled ? 'fill' : 'stroke';\n    const fillStrokeMarkDefAndConfig = Object.assign(Object.assign({}, (defaultFill ? { fill: signalOrValueRef(defaultFill) } : {})), (defaultStroke ? { stroke: signalOrValueRef(defaultStroke) } : {}));\n    if (markDef.color && (filled ? markDef.fill : markDef.stroke)) {\n        log.warn(log.message.droppingColor('property', { fill: 'fill' in markDef, stroke: 'stroke' in markDef }));\n    }\n    return Object.assign(Object.assign(Object.assign(Object.assign({}, fillStrokeMarkDefAndConfig), nonPosition('color', model, {\n        vgChannel: colorVgChannel,\n        defaultValue: filled ? defaultFill : defaultStroke\n    })), nonPosition('fill', model, {\n        // if there is encoding.fill, include default fill just in case we have conditional-only fill encoding\n        defaultValue: encoding.fill ? defaultFill : undefined\n    })), nonPosition('stroke', model, {\n        // if there is encoding.stroke, include default fill just in case we have conditional-only stroke encoding\n        defaultValue: encoding.stroke ? defaultStroke : undefined\n    }));\n}\n//# sourceMappingURL=color.js.map"]},"metadata":{},"sourceType":"module"}