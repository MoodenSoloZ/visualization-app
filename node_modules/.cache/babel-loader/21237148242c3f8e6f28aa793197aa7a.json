{"ast":null,"code":"import _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { toSet, stringValue, error, isArray, isObject, hasOwnProperty, accessor, key, field, array, compare, truthy } from 'vega-util';\nimport { tupleid } from 'vega-dataflow';\n\n/**\n * Parse a serialized dataflow specification.\n */\nfunction parse(spec) {\n  var ctx = this,\n    operators = spec.operators || []; // parse background\n\n  if (spec.background) {\n    ctx.background = spec.background;\n  } // parse event configuration\n\n  if (spec.eventConfig) {\n    ctx.eventConfig = spec.eventConfig;\n  } // parse locale configuration\n\n  if (spec.locale) {\n    ctx.locale = spec.locale;\n  } // parse operators\n\n  operators.forEach(function (entry) {\n    return ctx.parseOperator(entry);\n  }); // parse operator parameters\n\n  operators.forEach(function (entry) {\n    return ctx.parseOperatorParameters(entry);\n  }); // parse streams\n\n  (spec.streams || []).forEach(function (entry) {\n    return ctx.parseStream(entry);\n  }); // parse updates\n\n  (spec.updates || []).forEach(function (entry) {\n    return ctx.parseUpdate(entry);\n  });\n  return ctx.resolve();\n}\nvar Skip = toSet(['rule']),\n  Swap = toSet(['group', 'image', 'rect']);\nfunction adjustSpatial(encode, marktype) {\n  var code = '';\n  if (Skip[marktype]) return code;\n  if (encode.x2) {\n    if (encode.x) {\n      if (Swap[marktype]) {\n        code += 'if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;';\n      }\n      code += 'o.width=o.x2-o.x;';\n    } else {\n      code += 'o.x=o.x2-(o.width||0);';\n    }\n  }\n  if (encode.xc) {\n    code += 'o.x=o.xc-(o.width||0)/2;';\n  }\n  if (encode.y2) {\n    if (encode.y) {\n      if (Swap[marktype]) {\n        code += 'if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;';\n      }\n      code += 'o.height=o.y2-o.y;';\n    } else {\n      code += 'o.y=o.y2-(o.height||0);';\n    }\n  }\n  if (encode.yc) {\n    code += 'o.y=o.yc-(o.height||0)/2;';\n  }\n  return code;\n}\nfunction canonicalType(type) {\n  return (type + '').toLowerCase();\n}\nfunction isOperator(type) {\n  return canonicalType(type) === 'operator';\n}\nfunction isCollect(type) {\n  return canonicalType(type) === 'collect';\n}\nfunction expression(ctx, args, code) {\n  // wrap code in return statement if expression does not terminate\n  if (code[code.length - 1] !== ';') {\n    code = 'return(' + code + ');';\n  }\n  var fn = Function.apply(void 0, _toConsumableArray(args.concat(code)));\n  return ctx && ctx.functions ? fn.bind(ctx.functions) : fn;\n} // generate code for comparing a single field\n\nfunction _compare(u, v, lt, gt) {\n  return \"((u = \".concat(u, \") < (v = \").concat(v, \") || u == null) && v != null ? \").concat(lt, \"\\n  : (u > v || v == null) && u != null ? \").concat(gt, \"\\n  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? \").concat(lt, \"\\n  : v !== v && u === u ? \").concat(gt, \" : \");\n}\nvar expressionCodegen = {\n  /**\n   * Parse an expression used to update an operator value.\n   */\n  operator: function operator(ctx, expr) {\n    return expression(ctx, ['_'], expr.code);\n  },\n  /**\n   * Parse an expression provided as an operator parameter value.\n   */\n  parameter: function parameter(ctx, expr) {\n    return expression(ctx, ['datum', '_'], expr.code);\n  },\n  /**\n   * Parse an expression applied to an event stream.\n   */\n  event: function event(ctx, expr) {\n    return expression(ctx, ['event'], expr.code);\n  },\n  /**\n   * Parse an expression used to handle an event-driven operator update.\n   */\n  handler: function handler(ctx, expr) {\n    var code = \"var datum=event.item&&event.item.datum;return \".concat(expr.code, \";\");\n    return expression(ctx, ['_', 'event'], code);\n  },\n  /**\n   * Parse an expression that performs visual encoding.\n   */\n  encode: function encode(ctx, _encode) {\n    var marktype = _encode.marktype,\n      channels = _encode.channels;\n    var code = 'var o=item,datum=o.datum,m=0,$;';\n    for (var name in channels) {\n      var o = 'o[' + stringValue(name) + ']';\n      code += \"$=\".concat(channels[name].code, \";if(\").concat(o, \"!==$)\").concat(o, \"=$,m=1;\");\n    }\n    code += adjustSpatial(channels, marktype);\n    code += 'return m;';\n    return expression(ctx, ['item', '_'], code);\n  },\n  /**\n   * Optimized code generators for access and comparison.\n   */\n  codegen: {\n    get: function get(path) {\n      var ref = \"[\".concat(path.map(stringValue).join(']['), \"]\");\n      var get = Function('_', \"return _\".concat(ref, \";\"));\n      get.path = ref;\n      return get;\n    },\n    comparator: function comparator(fields, orders) {\n      var t;\n      var map = function map(f, i) {\n        var o = orders[i];\n        var u, v;\n        if (f.path) {\n          u = \"a\".concat(f.path);\n          v = \"b\".concat(f.path);\n        } else {\n          (t = t || {})['f' + i] = f;\n          u = \"this.f\".concat(i, \"(a)\");\n          v = \"this.f\".concat(i, \"(b)\");\n        }\n        return _compare(u, v, -o, o);\n      };\n      var fn = Function('a', 'b', 'var u, v; return ' + fields.map(map).join('') + '0;');\n      return t ? fn.bind(t) : fn;\n    }\n  }\n};\n\n/**\n * Parse a dataflow operator.\n */\n\nfunction parseOperator(spec) {\n  var ctx = this;\n  if (isOperator(spec.type) || !spec.type) {\n    ctx.operator(spec, spec.update ? ctx.operatorExpression(spec.update) : null);\n  } else {\n    ctx.transform(spec, spec.type);\n  }\n}\n/**\n * Parse and assign operator parameters.\n */\n\nfunction parseOperatorParameters(spec) {\n  var ctx = this;\n  if (spec.params) {\n    var op = ctx.get(spec.id);\n    if (!op) error('Invalid operator id: ' + spec.id);\n    ctx.dataflow.connect(op, op.parameters(ctx.parseParameters(spec.params), spec.react, spec.initonly));\n  }\n}\n\n/**\n * Parse a set of operator parameters.\n */\n\nfunction parseParameters(spec, params) {\n  params = params || {};\n  var ctx = this;\n  for (var _key in spec) {\n    var value = spec[_key];\n    params[_key] = isArray(value) ? value.map(function (v) {\n      return parseParameter(v, ctx, params);\n    }) : parseParameter(value, ctx, params);\n  }\n  return params;\n}\n/**\n * Parse a single parameter.\n */\n\nfunction parseParameter(spec, ctx, params) {\n  if (!spec || !isObject(spec)) return spec;\n  for (var i = 0, n = PARSERS.length, p; i < n; ++i) {\n    p = PARSERS[i];\n    if (hasOwnProperty(spec, p.key)) {\n      return p.parse(spec, ctx, params);\n    }\n  }\n  return spec;\n}\n/** Reference parsers. */\n\nvar PARSERS = [{\n  key: '$ref',\n  parse: getOperator\n}, {\n  key: '$key',\n  parse: getKey\n}, {\n  key: '$expr',\n  parse: getExpression\n}, {\n  key: '$field',\n  parse: getField\n}, {\n  key: '$encode',\n  parse: getEncode\n}, {\n  key: '$compare',\n  parse: getCompare\n}, {\n  key: '$context',\n  parse: getContext\n}, {\n  key: '$subflow',\n  parse: getSubflow\n}, {\n  key: '$tupleid',\n  parse: getTupleId\n}];\n/**\n * Resolve an operator reference.\n */\n\nfunction getOperator(_, ctx) {\n  return ctx.get(_.$ref) || error('Operator not defined: ' + _.$ref);\n}\n/**\n * Resolve an expression reference.\n */\n\nfunction getExpression(_, ctx, params) {\n  if (_.$params) {\n    // parse expression parameters\n    ctx.parseParameters(_.$params, params);\n  }\n  var k = 'e:' + _.$expr.code + '_' + _.$name;\n  return ctx.fn[k] || (ctx.fn[k] = accessor(ctx.parameterExpression(_.$expr), _.$fields, _.$name));\n}\n/**\n * Resolve a key accessor reference.\n */\n\nfunction getKey(_, ctx) {\n  var k = 'k:' + _.$key + '_' + !!_.$flat;\n  return ctx.fn[k] || (ctx.fn[k] = key(_.$key, _.$flat, ctx.expr.codegen));\n}\n/**\n * Resolve a field accessor reference.\n */\n\nfunction getField(_, ctx) {\n  if (!_.$field) return null;\n  var k = 'f:' + _.$field + '_' + _.$name;\n  return ctx.fn[k] || (ctx.fn[k] = field(_.$field, _.$name, ctx.expr.codegen));\n}\n/**\n * Resolve a comparator function reference.\n */\n\nfunction getCompare(_, ctx) {\n  // As of Vega 5.5.3, $tupleid sort is no longer used.\n  // Keep here for now for backwards compatibility.\n  var k = 'c:' + _.$compare + '_' + _.$order,\n    c = array(_.$compare).map(function (_) {\n      return _ && _.$tupleid ? tupleid : _;\n    });\n  return ctx.fn[k] || (ctx.fn[k] = compare(c, _.$order, ctx.expr.codegen));\n}\n/**\n * Resolve an encode operator reference.\n */\n\nfunction getEncode(_, ctx) {\n  var spec = _.$encode,\n    encode = {};\n  for (var name in spec) {\n    var enc = spec[name];\n    encode[name] = accessor(ctx.encodeExpression(enc.$expr), enc.$fields);\n    encode[name].output = enc.$output;\n  }\n  return encode;\n}\n/**\n * Resolve a context reference.\n */\n\nfunction getContext(_, ctx) {\n  return ctx;\n}\n/**\n * Resolve a recursive subflow specification.\n */\n\nfunction getSubflow(_, ctx) {\n  var spec = _.$subflow;\n  return function (dataflow, key, parent) {\n    var subctx = ctx.fork().parse(spec),\n      op = subctx.get(spec.operators[0].id),\n      p = subctx.signals.parent;\n    if (p) p.set(parent);\n    op.detachSubflow = function () {\n      return ctx.detach(subctx);\n    };\n    return op;\n  };\n}\n/**\n * Resolve a tuple id reference.\n */\n\nfunction getTupleId() {\n  return tupleid;\n}\n\n/**\n * Parse an event stream specification.\n */\n\nfunction parseStream(spec) {\n  var ctx = this,\n    filter = spec.filter != null ? ctx.eventExpression(spec.filter) : undefined,\n    stream = spec.stream != null ? ctx.get(spec.stream) : undefined,\n    args;\n  if (spec.source) {\n    stream = ctx.events(spec.source, spec.type, filter);\n  } else if (spec.merge) {\n    args = spec.merge.map(function (_) {\n      return ctx.get(_);\n    });\n    stream = args[0].merge.apply(args[0], args.slice(1));\n  }\n  if (spec.between) {\n    args = spec.between.map(function (_) {\n      return ctx.get(_);\n    });\n    stream = stream.between(args[0], args[1]);\n  }\n  if (spec.filter) {\n    stream = stream.filter(filter);\n  }\n  if (spec.throttle != null) {\n    stream = stream.throttle(+spec.throttle);\n  }\n  if (spec.debounce != null) {\n    stream = stream.debounce(+spec.debounce);\n  }\n  if (stream == null) {\n    error('Invalid stream definition: ' + JSON.stringify(spec));\n  }\n  if (spec.consume) stream.consume(true);\n  ctx.stream(spec, stream);\n}\n\n/**\n * Parse an event-driven operator update.\n */\n\nfunction parseUpdate(spec) {\n  var ctx = this,\n    srcid = isObject(srcid = spec.source) ? srcid.$ref : srcid,\n    source = ctx.get(srcid),\n    target = null,\n    update = spec.update,\n    params = undefined;\n  if (!source) error('Source not defined: ' + spec.source);\n  target = spec.target && spec.target.$expr ? ctx.eventExpression(spec.target.$expr) : ctx.get(spec.target);\n  if (update && update.$expr) {\n    if (update.$params) {\n      params = ctx.parseParameters(update.$params);\n    }\n    update = ctx.handlerExpression(update.$expr);\n  }\n  ctx.update(spec, source, target, update, params);\n}\nvar SKIP = {\n  skip: true\n};\nfunction getState(options) {\n  var ctx = this,\n    state = {};\n  if (options.signals) {\n    var signals = state.signals = {};\n    Object.keys(ctx.signals).forEach(function (key) {\n      var op = ctx.signals[key];\n      if (options.signals(key, op)) {\n        signals[key] = op.value;\n      }\n    });\n  }\n  if (options.data) {\n    var data = state.data = {};\n    Object.keys(ctx.data).forEach(function (key) {\n      var dataset = ctx.data[key];\n      if (options.data(key, dataset)) {\n        data[key] = dataset.input.value;\n      }\n    });\n  }\n  if (ctx.subcontext && options.recurse !== false) {\n    state.subcontext = ctx.subcontext.map(function (ctx) {\n      return ctx.getState(options);\n    });\n  }\n  return state;\n}\nfunction setState(state) {\n  var ctx = this,\n    df = ctx.dataflow,\n    data = state.data,\n    signals = state.signals;\n  Object.keys(signals || {}).forEach(function (key) {\n    df.update(ctx.signals[key], signals[key], SKIP);\n  });\n  Object.keys(data || {}).forEach(function (key) {\n    df.pulse(ctx.data[key].input, df.changeset().remove(truthy).insert(data[key]));\n  });\n  (state.subcontext || []).forEach(function (substate, i) {\n    var subctx = ctx.subcontext[i];\n    if (subctx) subctx.setState(substate);\n  });\n}\n\n/**\n * Context objects store the current parse state.\n * Enables lookup of parsed operators, event streams, accessors, etc.\n * Provides a 'fork' method for creating child contexts for subflows.\n */\n\nfunction context(df, transforms, functions, expr) {\n  return new Context(df, transforms, functions, expr);\n}\nfunction Context(df, transforms, functions, expr) {\n  this.dataflow = df;\n  this.transforms = transforms;\n  this.events = df.events.bind(df);\n  this.expr = expr || expressionCodegen, this.signals = {};\n  this.scales = {};\n  this.nodes = {};\n  this.data = {};\n  this.fn = {};\n  if (functions) {\n    this.functions = Object.create(functions);\n    this.functions.context = this;\n  }\n}\nfunction Subcontext(ctx) {\n  this.dataflow = ctx.dataflow;\n  this.transforms = ctx.transforms;\n  this.events = ctx.events;\n  this.expr = ctx.expr;\n  this.signals = Object.create(ctx.signals);\n  this.scales = Object.create(ctx.scales);\n  this.nodes = Object.create(ctx.nodes);\n  this.data = Object.create(ctx.data);\n  this.fn = Object.create(ctx.fn);\n  if (ctx.functions) {\n    this.functions = Object.create(ctx.functions);\n    this.functions.context = this;\n  }\n}\nContext.prototype = Subcontext.prototype = {\n  fork: function fork() {\n    var ctx = new Subcontext(this);\n    (this.subcontext || (this.subcontext = [])).push(ctx);\n    return ctx;\n  },\n  detach: function detach(ctx) {\n    this.subcontext = this.subcontext.filter(function (c) {\n      return c !== ctx;\n    }); // disconnect all nodes in the subcontext\n    // wipe out targets first for better efficiency\n\n    var keys = Object.keys(ctx.nodes);\n    for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {\n      var _key2 = _keys[_i];\n      ctx.nodes[_key2]._targets = null;\n    }\n    for (var _i2 = 0, _keys2 = keys; _i2 < _keys2.length; _i2++) {\n      var _key3 = _keys2[_i2];\n      ctx.nodes[_key3].detach();\n    }\n    ctx.nodes = null;\n  },\n  get: function get(id) {\n    return this.nodes[id];\n  },\n  set: function set(id, node) {\n    return this.nodes[id] = node;\n  },\n  add: function add(spec, op) {\n    var ctx = this,\n      df = ctx.dataflow,\n      data = spec.value;\n    ctx.set(spec.id, op);\n    if (isCollect(spec.type) && data) {\n      if (data.$ingest) {\n        df.ingest(op, data.$ingest, data.$format);\n      } else if (data.$request) {\n        df.preload(op, data.$request, data.$format);\n      } else {\n        df.pulse(op, df.changeset().insert(data));\n      }\n    }\n    if (spec.root) {\n      ctx.root = op;\n    }\n    if (spec.parent) {\n      var p = ctx.get(spec.parent.$ref);\n      if (p) {\n        df.connect(p, [op]);\n        op.targets().add(p);\n      } else {\n        (ctx.unresolved = ctx.unresolved || []).push(function () {\n          p = ctx.get(spec.parent.$ref);\n          df.connect(p, [op]);\n          op.targets().add(p);\n        });\n      }\n    }\n    if (spec.signal) {\n      ctx.signals[spec.signal] = op;\n    }\n    if (spec.scale) {\n      ctx.scales[spec.scale] = op;\n    }\n    if (spec.data) {\n      var _loop = function _loop(name) {\n        var data = ctx.data[name] || (ctx.data[name] = {});\n        spec.data[name].forEach(function (role) {\n          return data[role] = op;\n        });\n      };\n      for (var name in spec.data) {\n        _loop(name);\n      }\n    }\n  },\n  resolve: function resolve() {\n    (this.unresolved || []).forEach(function (fn) {\n      return fn();\n    });\n    delete this.unresolved;\n    return this;\n  },\n  operator: function operator(spec, update) {\n    this.add(spec, this.dataflow.add(spec.value, update));\n  },\n  transform: function transform(spec, type) {\n    this.add(spec, this.dataflow.add(this.transforms[canonicalType(type)]));\n  },\n  stream: function stream(spec, _stream) {\n    this.set(spec.id, _stream);\n  },\n  update: function update(spec, stream, target, _update, params) {\n    this.dataflow.on(stream, target, _update, params, spec.options);\n  },\n  // expression parsing\n  operatorExpression: function operatorExpression(expr) {\n    return this.expr.operator(this, expr);\n  },\n  parameterExpression: function parameterExpression(expr) {\n    return this.expr.parameter(this, expr);\n  },\n  eventExpression: function eventExpression(expr) {\n    return this.expr.event(this, expr);\n  },\n  handlerExpression: function handlerExpression(expr) {\n    return this.expr.handler(this, expr);\n  },\n  encodeExpression: function encodeExpression(encode) {\n    return this.expr.encode(this, encode);\n  },\n  // parse methods\n  parse: parse,\n  parseOperator: parseOperator,\n  parseOperatorParameters: parseOperatorParameters,\n  parseParameters: parseParameters,\n  parseStream: parseStream,\n  parseUpdate: parseUpdate,\n  // state methods\n  getState: getState,\n  setState: setState\n};\nexport { context };","map":{"version":3,"names":["toSet","stringValue","error","isArray","isObject","hasOwnProperty","accessor","key","field","array","compare","truthy","tupleid","parse","spec","ctx","operators","background","eventConfig","locale","forEach","entry","parseOperator","parseOperatorParameters","streams","parseStream","updates","parseUpdate","resolve","Skip","Swap","adjustSpatial","encode","marktype","code","x2","x","xc","y2","y","yc","canonicalType","type","toLowerCase","isOperator","isCollect","expression","args","length","fn","Function","concat","functions","bind","_compare","u","v","lt","gt","expressionCodegen","operator","expr","parameter","event","handler","channels","name","o","codegen","get","path","ref","map","join","comparator","fields","orders","t","f","i","update","operatorExpression","transform","params","op","id","dataflow","connect","parameters","parseParameters","react","initonly","value","parseParameter","n","PARSERS","p","getOperator","getKey","getExpression","getField","getEncode","getCompare","getContext","getSubflow","getTupleId","_","$ref","$params","k","$expr","$name","parameterExpression","$fields","$key","$flat","$field","$compare","$order","c","$tupleid","$encode","enc","encodeExpression","output","$output","$subflow","parent","subctx","fork","signals","set","detachSubflow","detach","filter","eventExpression","undefined","stream","source","events","merge","apply","slice","between","throttle","debounce","JSON","stringify","consume","srcid","target","handlerExpression","SKIP","skip","getState","options","state","Object","keys","data","dataset","input","subcontext","recurse","setState","df","pulse","changeset","remove","insert","substate","context","transforms","Context","scales","nodes","create","Subcontext","prototype","push","_targets","node","add","$ingest","ingest","$format","$request","preload","root","targets","unresolved","signal","scale","role","on"],"sources":["/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/vega-runtime/build/vega-runtime.module.js"],"sourcesContent":["import { toSet, stringValue, error, isArray, isObject, hasOwnProperty, accessor, key, field, array, compare, truthy } from 'vega-util';\nimport { tupleid } from 'vega-dataflow';\n\n/**\n * Parse a serialized dataflow specification.\n */\nfunction parse (spec) {\n  const ctx = this,\n        operators = spec.operators || []; // parse background\n\n  if (spec.background) {\n    ctx.background = spec.background;\n  } // parse event configuration\n\n\n  if (spec.eventConfig) {\n    ctx.eventConfig = spec.eventConfig;\n  } // parse locale configuration\n\n\n  if (spec.locale) {\n    ctx.locale = spec.locale;\n  } // parse operators\n\n\n  operators.forEach(entry => ctx.parseOperator(entry)); // parse operator parameters\n\n  operators.forEach(entry => ctx.parseOperatorParameters(entry)); // parse streams\n\n  (spec.streams || []).forEach(entry => ctx.parseStream(entry)); // parse updates\n\n  (spec.updates || []).forEach(entry => ctx.parseUpdate(entry));\n  return ctx.resolve();\n}\n\nconst Skip = toSet(['rule']),\n      Swap = toSet(['group', 'image', 'rect']);\nfunction adjustSpatial(encode, marktype) {\n  let code = '';\n  if (Skip[marktype]) return code;\n\n  if (encode.x2) {\n    if (encode.x) {\n      if (Swap[marktype]) {\n        code += 'if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;';\n      }\n\n      code += 'o.width=o.x2-o.x;';\n    } else {\n      code += 'o.x=o.x2-(o.width||0);';\n    }\n  }\n\n  if (encode.xc) {\n    code += 'o.x=o.xc-(o.width||0)/2;';\n  }\n\n  if (encode.y2) {\n    if (encode.y) {\n      if (Swap[marktype]) {\n        code += 'if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;';\n      }\n\n      code += 'o.height=o.y2-o.y;';\n    } else {\n      code += 'o.y=o.y2-(o.height||0);';\n    }\n  }\n\n  if (encode.yc) {\n    code += 'o.y=o.yc-(o.height||0)/2;';\n  }\n\n  return code;\n}\nfunction canonicalType(type) {\n  return (type + '').toLowerCase();\n}\nfunction isOperator(type) {\n  return canonicalType(type) === 'operator';\n}\nfunction isCollect(type) {\n  return canonicalType(type) === 'collect';\n}\n\nfunction expression(ctx, args, code) {\n  // wrap code in return statement if expression does not terminate\n  if (code[code.length - 1] !== ';') {\n    code = 'return(' + code + ');';\n  }\n\n  const fn = Function(...args.concat(code));\n  return ctx && ctx.functions ? fn.bind(ctx.functions) : fn;\n} // generate code for comparing a single field\n\n\nfunction _compare(u, v, lt, gt) {\n  return \"((u = \".concat(u, \") < (v = \").concat(v, \") || u == null) && v != null ? \").concat(lt, \"\\n  : (u > v || v == null) && u != null ? \").concat(gt, \"\\n  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? \").concat(lt, \"\\n  : v !== v && u === u ? \").concat(gt, \" : \");\n}\n\nvar expressionCodegen = {\n  /**\n   * Parse an expression used to update an operator value.\n   */\n  operator: (ctx, expr) => expression(ctx, ['_'], expr.code),\n\n  /**\n   * Parse an expression provided as an operator parameter value.\n   */\n  parameter: (ctx, expr) => expression(ctx, ['datum', '_'], expr.code),\n\n  /**\n   * Parse an expression applied to an event stream.\n   */\n  event: (ctx, expr) => expression(ctx, ['event'], expr.code),\n\n  /**\n   * Parse an expression used to handle an event-driven operator update.\n   */\n  handler: (ctx, expr) => {\n    const code = \"var datum=event.item&&event.item.datum;return \".concat(expr.code, \";\");\n    return expression(ctx, ['_', 'event'], code);\n  },\n\n  /**\n   * Parse an expression that performs visual encoding.\n   */\n  encode: (ctx, encode) => {\n    const {\n      marktype,\n      channels\n    } = encode;\n    let code = 'var o=item,datum=o.datum,m=0,$;';\n\n    for (const name in channels) {\n      const o = 'o[' + stringValue(name) + ']';\n      code += \"$=\".concat(channels[name].code, \";if(\").concat(o, \"!==$)\").concat(o, \"=$,m=1;\");\n    }\n\n    code += adjustSpatial(channels, marktype);\n    code += 'return m;';\n    return expression(ctx, ['item', '_'], code);\n  },\n\n  /**\n   * Optimized code generators for access and comparison.\n   */\n  codegen: {\n    get(path) {\n      const ref = \"[\".concat(path.map(stringValue).join(']['), \"]\");\n      const get = Function('_', \"return _\".concat(ref, \";\"));\n      get.path = ref;\n      return get;\n    },\n\n    comparator(fields, orders) {\n      let t;\n\n      const map = (f, i) => {\n        const o = orders[i];\n        let u, v;\n\n        if (f.path) {\n          u = \"a\".concat(f.path);\n          v = \"b\".concat(f.path);\n        } else {\n          (t = t || {})['f' + i] = f;\n          u = \"this.f\".concat(i, \"(a)\");\n          v = \"this.f\".concat(i, \"(b)\");\n        }\n\n        return _compare(u, v, -o, o);\n      };\n\n      const fn = Function('a', 'b', 'var u, v; return ' + fields.map(map).join('') + '0;');\n      return t ? fn.bind(t) : fn;\n    }\n\n  }\n};\n\n/**\n * Parse a dataflow operator.\n */\n\nfunction parseOperator(spec) {\n  const ctx = this;\n\n  if (isOperator(spec.type) || !spec.type) {\n    ctx.operator(spec, spec.update ? ctx.operatorExpression(spec.update) : null);\n  } else {\n    ctx.transform(spec, spec.type);\n  }\n}\n/**\n * Parse and assign operator parameters.\n */\n\nfunction parseOperatorParameters(spec) {\n  const ctx = this;\n\n  if (spec.params) {\n    const op = ctx.get(spec.id);\n    if (!op) error('Invalid operator id: ' + spec.id);\n    ctx.dataflow.connect(op, op.parameters(ctx.parseParameters(spec.params), spec.react, spec.initonly));\n  }\n}\n\n/**\n * Parse a set of operator parameters.\n */\n\nfunction parseParameters(spec, params) {\n  params = params || {};\n  const ctx = this;\n\n  for (const key in spec) {\n    const value = spec[key];\n    params[key] = isArray(value) ? value.map(v => parseParameter(v, ctx, params)) : parseParameter(value, ctx, params);\n  }\n\n  return params;\n}\n/**\n * Parse a single parameter.\n */\n\nfunction parseParameter(spec, ctx, params) {\n  if (!spec || !isObject(spec)) return spec;\n\n  for (let i = 0, n = PARSERS.length, p; i < n; ++i) {\n    p = PARSERS[i];\n\n    if (hasOwnProperty(spec, p.key)) {\n      return p.parse(spec, ctx, params);\n    }\n  }\n\n  return spec;\n}\n/** Reference parsers. */\n\n\nvar PARSERS = [{\n  key: '$ref',\n  parse: getOperator\n}, {\n  key: '$key',\n  parse: getKey\n}, {\n  key: '$expr',\n  parse: getExpression\n}, {\n  key: '$field',\n  parse: getField\n}, {\n  key: '$encode',\n  parse: getEncode\n}, {\n  key: '$compare',\n  parse: getCompare\n}, {\n  key: '$context',\n  parse: getContext\n}, {\n  key: '$subflow',\n  parse: getSubflow\n}, {\n  key: '$tupleid',\n  parse: getTupleId\n}];\n/**\n * Resolve an operator reference.\n */\n\nfunction getOperator(_, ctx) {\n  return ctx.get(_.$ref) || error('Operator not defined: ' + _.$ref);\n}\n/**\n * Resolve an expression reference.\n */\n\n\nfunction getExpression(_, ctx, params) {\n  if (_.$params) {\n    // parse expression parameters\n    ctx.parseParameters(_.$params, params);\n  }\n\n  const k = 'e:' + _.$expr.code + '_' + _.$name;\n  return ctx.fn[k] || (ctx.fn[k] = accessor(ctx.parameterExpression(_.$expr), _.$fields, _.$name));\n}\n/**\n * Resolve a key accessor reference.\n */\n\n\nfunction getKey(_, ctx) {\n  const k = 'k:' + _.$key + '_' + !!_.$flat;\n  return ctx.fn[k] || (ctx.fn[k] = key(_.$key, _.$flat, ctx.expr.codegen));\n}\n/**\n * Resolve a field accessor reference.\n */\n\n\nfunction getField(_, ctx) {\n  if (!_.$field) return null;\n  const k = 'f:' + _.$field + '_' + _.$name;\n  return ctx.fn[k] || (ctx.fn[k] = field(_.$field, _.$name, ctx.expr.codegen));\n}\n/**\n * Resolve a comparator function reference.\n */\n\n\nfunction getCompare(_, ctx) {\n  // As of Vega 5.5.3, $tupleid sort is no longer used.\n  // Keep here for now for backwards compatibility.\n  const k = 'c:' + _.$compare + '_' + _.$order,\n        c = array(_.$compare).map(_ => _ && _.$tupleid ? tupleid : _);\n  return ctx.fn[k] || (ctx.fn[k] = compare(c, _.$order, ctx.expr.codegen));\n}\n/**\n * Resolve an encode operator reference.\n */\n\n\nfunction getEncode(_, ctx) {\n  const spec = _.$encode,\n        encode = {};\n\n  for (const name in spec) {\n    const enc = spec[name];\n    encode[name] = accessor(ctx.encodeExpression(enc.$expr), enc.$fields);\n    encode[name].output = enc.$output;\n  }\n\n  return encode;\n}\n/**\n * Resolve a context reference.\n */\n\n\nfunction getContext(_, ctx) {\n  return ctx;\n}\n/**\n * Resolve a recursive subflow specification.\n */\n\n\nfunction getSubflow(_, ctx) {\n  const spec = _.$subflow;\n  return function (dataflow, key, parent) {\n    const subctx = ctx.fork().parse(spec),\n          op = subctx.get(spec.operators[0].id),\n          p = subctx.signals.parent;\n    if (p) p.set(parent);\n\n    op.detachSubflow = () => ctx.detach(subctx);\n\n    return op;\n  };\n}\n/**\n * Resolve a tuple id reference.\n */\n\n\nfunction getTupleId() {\n  return tupleid;\n}\n\n/**\n * Parse an event stream specification.\n */\n\nfunction parseStream (spec) {\n  var ctx = this,\n      filter = spec.filter != null ? ctx.eventExpression(spec.filter) : undefined,\n      stream = spec.stream != null ? ctx.get(spec.stream) : undefined,\n      args;\n\n  if (spec.source) {\n    stream = ctx.events(spec.source, spec.type, filter);\n  } else if (spec.merge) {\n    args = spec.merge.map(_ => ctx.get(_));\n    stream = args[0].merge.apply(args[0], args.slice(1));\n  }\n\n  if (spec.between) {\n    args = spec.between.map(_ => ctx.get(_));\n    stream = stream.between(args[0], args[1]);\n  }\n\n  if (spec.filter) {\n    stream = stream.filter(filter);\n  }\n\n  if (spec.throttle != null) {\n    stream = stream.throttle(+spec.throttle);\n  }\n\n  if (spec.debounce != null) {\n    stream = stream.debounce(+spec.debounce);\n  }\n\n  if (stream == null) {\n    error('Invalid stream definition: ' + JSON.stringify(spec));\n  }\n\n  if (spec.consume) stream.consume(true);\n  ctx.stream(spec, stream);\n}\n\n/**\n * Parse an event-driven operator update.\n */\n\nfunction parseUpdate (spec) {\n  var ctx = this,\n      srcid = isObject(srcid = spec.source) ? srcid.$ref : srcid,\n      source = ctx.get(srcid),\n      target = null,\n      update = spec.update,\n      params = undefined;\n  if (!source) error('Source not defined: ' + spec.source);\n  target = spec.target && spec.target.$expr ? ctx.eventExpression(spec.target.$expr) : ctx.get(spec.target);\n\n  if (update && update.$expr) {\n    if (update.$params) {\n      params = ctx.parseParameters(update.$params);\n    }\n\n    update = ctx.handlerExpression(update.$expr);\n  }\n\n  ctx.update(spec, source, target, update, params);\n}\n\nconst SKIP = {\n  skip: true\n};\nfunction getState(options) {\n  var ctx = this,\n      state = {};\n\n  if (options.signals) {\n    var signals = state.signals = {};\n    Object.keys(ctx.signals).forEach(key => {\n      const op = ctx.signals[key];\n\n      if (options.signals(key, op)) {\n        signals[key] = op.value;\n      }\n    });\n  }\n\n  if (options.data) {\n    var data = state.data = {};\n    Object.keys(ctx.data).forEach(key => {\n      const dataset = ctx.data[key];\n\n      if (options.data(key, dataset)) {\n        data[key] = dataset.input.value;\n      }\n    });\n  }\n\n  if (ctx.subcontext && options.recurse !== false) {\n    state.subcontext = ctx.subcontext.map(ctx => ctx.getState(options));\n  }\n\n  return state;\n}\nfunction setState(state) {\n  var ctx = this,\n      df = ctx.dataflow,\n      data = state.data,\n      signals = state.signals;\n  Object.keys(signals || {}).forEach(key => {\n    df.update(ctx.signals[key], signals[key], SKIP);\n  });\n  Object.keys(data || {}).forEach(key => {\n    df.pulse(ctx.data[key].input, df.changeset().remove(truthy).insert(data[key]));\n  });\n  (state.subcontext || []).forEach((substate, i) => {\n    const subctx = ctx.subcontext[i];\n    if (subctx) subctx.setState(substate);\n  });\n}\n\n/**\n * Context objects store the current parse state.\n * Enables lookup of parsed operators, event streams, accessors, etc.\n * Provides a 'fork' method for creating child contexts for subflows.\n */\n\nfunction context (df, transforms, functions, expr) {\n  return new Context(df, transforms, functions, expr);\n}\n\nfunction Context(df, transforms, functions, expr) {\n  this.dataflow = df;\n  this.transforms = transforms;\n  this.events = df.events.bind(df);\n  this.expr = expr || expressionCodegen, this.signals = {};\n  this.scales = {};\n  this.nodes = {};\n  this.data = {};\n  this.fn = {};\n\n  if (functions) {\n    this.functions = Object.create(functions);\n    this.functions.context = this;\n  }\n}\n\nfunction Subcontext(ctx) {\n  this.dataflow = ctx.dataflow;\n  this.transforms = ctx.transforms;\n  this.events = ctx.events;\n  this.expr = ctx.expr;\n  this.signals = Object.create(ctx.signals);\n  this.scales = Object.create(ctx.scales);\n  this.nodes = Object.create(ctx.nodes);\n  this.data = Object.create(ctx.data);\n  this.fn = Object.create(ctx.fn);\n\n  if (ctx.functions) {\n    this.functions = Object.create(ctx.functions);\n    this.functions.context = this;\n  }\n}\n\nContext.prototype = Subcontext.prototype = {\n  fork() {\n    const ctx = new Subcontext(this);\n    (this.subcontext || (this.subcontext = [])).push(ctx);\n    return ctx;\n  },\n\n  detach(ctx) {\n    this.subcontext = this.subcontext.filter(c => c !== ctx); // disconnect all nodes in the subcontext\n    // wipe out targets first for better efficiency\n\n    const keys = Object.keys(ctx.nodes);\n\n    for (const key of keys) ctx.nodes[key]._targets = null;\n\n    for (const key of keys) ctx.nodes[key].detach();\n\n    ctx.nodes = null;\n  },\n\n  get(id) {\n    return this.nodes[id];\n  },\n\n  set(id, node) {\n    return this.nodes[id] = node;\n  },\n\n  add(spec, op) {\n    const ctx = this,\n          df = ctx.dataflow,\n          data = spec.value;\n    ctx.set(spec.id, op);\n\n    if (isCollect(spec.type) && data) {\n      if (data.$ingest) {\n        df.ingest(op, data.$ingest, data.$format);\n      } else if (data.$request) {\n        df.preload(op, data.$request, data.$format);\n      } else {\n        df.pulse(op, df.changeset().insert(data));\n      }\n    }\n\n    if (spec.root) {\n      ctx.root = op;\n    }\n\n    if (spec.parent) {\n      let p = ctx.get(spec.parent.$ref);\n\n      if (p) {\n        df.connect(p, [op]);\n        op.targets().add(p);\n      } else {\n        (ctx.unresolved = ctx.unresolved || []).push(() => {\n          p = ctx.get(spec.parent.$ref);\n          df.connect(p, [op]);\n          op.targets().add(p);\n        });\n      }\n    }\n\n    if (spec.signal) {\n      ctx.signals[spec.signal] = op;\n    }\n\n    if (spec.scale) {\n      ctx.scales[spec.scale] = op;\n    }\n\n    if (spec.data) {\n      for (const name in spec.data) {\n        const data = ctx.data[name] || (ctx.data[name] = {});\n        spec.data[name].forEach(role => data[role] = op);\n      }\n    }\n  },\n\n  resolve() {\n    (this.unresolved || []).forEach(fn => fn());\n    delete this.unresolved;\n    return this;\n  },\n\n  operator(spec, update) {\n    this.add(spec, this.dataflow.add(spec.value, update));\n  },\n\n  transform(spec, type) {\n    this.add(spec, this.dataflow.add(this.transforms[canonicalType(type)]));\n  },\n\n  stream(spec, stream) {\n    this.set(spec.id, stream);\n  },\n\n  update(spec, stream, target, update, params) {\n    this.dataflow.on(stream, target, update, params, spec.options);\n  },\n\n  // expression parsing\n  operatorExpression(expr) {\n    return this.expr.operator(this, expr);\n  },\n\n  parameterExpression(expr) {\n    return this.expr.parameter(this, expr);\n  },\n\n  eventExpression(expr) {\n    return this.expr.event(this, expr);\n  },\n\n  handlerExpression(expr) {\n    return this.expr.handler(this, expr);\n  },\n\n  encodeExpression(encode) {\n    return this.expr.encode(this, encode);\n  },\n\n  // parse methods\n  parse,\n  parseOperator,\n  parseOperatorParameters,\n  parseParameters,\n  parseStream,\n  parseUpdate,\n  // state methods\n  getState,\n  setState\n};\n\nexport { context };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}