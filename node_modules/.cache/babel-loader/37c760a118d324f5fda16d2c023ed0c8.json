{"ast":null,"code":"var VIEW = 'view',\n  LBRACK = '[',\n  RBRACK = ']',\n  LBRACE = '{',\n  RBRACE = '}',\n  COLON = ':',\n  COMMA = ',',\n  NAME = '@',\n  GT = '>',\n  ILLEGAL = /[[\\]{}]/,\n  DEFAULT_MARKS = {\n    '*': 1,\n    arc: 1,\n    area: 1,\n    group: 1,\n    image: 1,\n    line: 1,\n    path: 1,\n    rect: 1,\n    rule: 1,\n    shape: 1,\n    symbol: 1,\n    text: 1,\n    trail: 1\n  };\nvar DEFAULT_SOURCE, MARKS;\n/**\n * Parse an event selector string.\n * Returns an array of event stream definitions.\n */\n\nfunction eventSelector(selector, source, marks) {\n  DEFAULT_SOURCE = source || VIEW;\n  MARKS = marks || DEFAULT_MARKS;\n  return parseMerge(selector.trim()).map(parseSelector);\n}\nfunction isMarkType(type) {\n  return MARKS[type];\n}\nfunction find(s, i, endChar, pushChar, popChar) {\n  var n = s.length;\n  var count = 0,\n    c;\n  for (; i < n; ++i) {\n    c = s[i];\n    if (!count && c === endChar) return i;else if (popChar && popChar.indexOf(c) >= 0) --count;else if (pushChar && pushChar.indexOf(c) >= 0) ++count;\n  }\n  return i;\n}\nfunction parseMerge(s) {\n  var output = [],\n    n = s.length;\n  var start = 0,\n    i = 0;\n  while (i < n) {\n    i = find(s, i, COMMA, LBRACK + LBRACE, RBRACK + RBRACE);\n    output.push(s.substring(start, i).trim());\n    start = ++i;\n  }\n  if (output.length === 0) {\n    throw 'Empty event selector: ' + s;\n  }\n  return output;\n}\nfunction parseSelector(s) {\n  return s[0] === '[' ? parseBetween(s) : parseStream(s);\n}\nfunction parseBetween(s) {\n  var n = s.length;\n  var i = 1,\n    b;\n  i = find(s, i, RBRACK, LBRACK, RBRACK);\n  if (i === n) {\n    throw 'Empty between selector: ' + s;\n  }\n  b = parseMerge(s.substring(1, i));\n  if (b.length !== 2) {\n    throw 'Between selector must have two elements: ' + s;\n  }\n  s = s.slice(i + 1).trim();\n  if (s[0] !== GT) {\n    throw 'Expected \\'>\\' after between selector: ' + s;\n  }\n  b = b.map(parseSelector);\n  var stream = parseSelector(s.slice(1).trim());\n  if (stream.between) {\n    return {\n      between: b,\n      stream: stream\n    };\n  } else {\n    stream.between = b;\n  }\n  return stream;\n}\nfunction parseStream(s) {\n  var stream = {\n      source: DEFAULT_SOURCE\n    },\n    source = [];\n  var throttle = [0, 0],\n    markname = 0,\n    start = 0,\n    n = s.length,\n    i = 0,\n    j,\n    filter; // extract throttle from end\n\n  if (s[n - 1] === RBRACE) {\n    i = s.lastIndexOf(LBRACE);\n    if (i >= 0) {\n      try {\n        throttle = parseThrottle(s.substring(i + 1, n - 1));\n      } catch (e) {\n        throw 'Invalid throttle specification: ' + s;\n      }\n      s = s.slice(0, i).trim();\n      n = s.length;\n    } else throw 'Unmatched right brace: ' + s;\n    i = 0;\n  }\n  if (!n) throw s; // set name flag based on first char\n\n  if (s[0] === NAME) markname = ++i; // extract first part of multi-part stream selector\n\n  j = find(s, i, COLON);\n  if (j < n) {\n    source.push(s.substring(start, j).trim());\n    start = i = ++j;\n  } // extract remaining part of stream selector\n\n  i = find(s, i, LBRACK);\n  if (i === n) {\n    source.push(s.substring(start, n).trim());\n  } else {\n    source.push(s.substring(start, i).trim());\n    filter = [];\n    start = ++i;\n    if (start === n) throw 'Unmatched left bracket: ' + s;\n  } // extract filters\n\n  while (i < n) {\n    i = find(s, i, RBRACK);\n    if (i === n) throw 'Unmatched left bracket: ' + s;\n    filter.push(s.substring(start, i).trim());\n    if (i < n - 1 && s[++i] !== LBRACK) throw 'Expected left bracket: ' + s;\n    start = ++i;\n  } // marshall event stream specification\n\n  if (!(n = source.length) || ILLEGAL.test(source[n - 1])) {\n    throw 'Invalid event selector: ' + s;\n  }\n  if (n > 1) {\n    stream.type = source[1];\n    if (markname) {\n      stream.markname = source[0].slice(1);\n    } else if (isMarkType(source[0])) {\n      stream.marktype = source[0];\n    } else {\n      stream.source = source[0];\n    }\n  } else {\n    stream.type = source[0];\n  }\n  if (stream.type.slice(-1) === '!') {\n    stream.consume = true;\n    stream.type = stream.type.slice(0, -1);\n  }\n  if (filter != null) stream.filter = filter;\n  if (throttle[0]) stream.throttle = throttle[0];\n  if (throttle[1]) stream.debounce = throttle[1];\n  return stream;\n}\nfunction parseThrottle(s) {\n  var a = s.split(COMMA);\n  if (!s.length || a.length > 2) throw s;\n  return a.map(function (_) {\n    var x = +_;\n    if (x !== x) throw s;\n    return x;\n  });\n}\nexport { eventSelector as parseSelector };","map":{"version":3,"names":["VIEW","LBRACK","RBRACK","LBRACE","RBRACE","COLON","COMMA","NAME","GT","ILLEGAL","DEFAULT_MARKS","arc","area","group","image","line","path","rect","rule","shape","symbol","text","trail","DEFAULT_SOURCE","MARKS","eventSelector","selector","source","marks","parseMerge","trim","map","parseSelector","isMarkType","type","find","s","i","endChar","pushChar","popChar","n","length","count","c","indexOf","output","start","push","substring","parseBetween","parseStream","b","slice","stream","between","throttle","markname","j","filter","lastIndexOf","parseThrottle","e","test","marktype","consume","debounce","a","split","_","x"],"sources":["/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/vega-event-selector/build/vega-event-selector.module.js"],"sourcesContent":["const VIEW = 'view',\n      LBRACK = '[',\n      RBRACK = ']',\n      LBRACE = '{',\n      RBRACE = '}',\n      COLON = ':',\n      COMMA = ',',\n      NAME = '@',\n      GT = '>',\n      ILLEGAL = /[[\\]{}]/,\n      DEFAULT_MARKS = {\n  '*': 1,\n  arc: 1,\n  area: 1,\n  group: 1,\n  image: 1,\n  line: 1,\n  path: 1,\n  rect: 1,\n  rule: 1,\n  shape: 1,\n  symbol: 1,\n  text: 1,\n  trail: 1\n};\nlet DEFAULT_SOURCE, MARKS;\n/**\n * Parse an event selector string.\n * Returns an array of event stream definitions.\n */\n\nfunction eventSelector (selector, source, marks) {\n  DEFAULT_SOURCE = source || VIEW;\n  MARKS = marks || DEFAULT_MARKS;\n  return parseMerge(selector.trim()).map(parseSelector);\n}\n\nfunction isMarkType(type) {\n  return MARKS[type];\n}\n\nfunction find(s, i, endChar, pushChar, popChar) {\n  const n = s.length;\n  let count = 0,\n      c;\n\n  for (; i < n; ++i) {\n    c = s[i];\n    if (!count && c === endChar) return i;else if (popChar && popChar.indexOf(c) >= 0) --count;else if (pushChar && pushChar.indexOf(c) >= 0) ++count;\n  }\n\n  return i;\n}\n\nfunction parseMerge(s) {\n  const output = [],\n        n = s.length;\n  let start = 0,\n      i = 0;\n\n  while (i < n) {\n    i = find(s, i, COMMA, LBRACK + LBRACE, RBRACK + RBRACE);\n    output.push(s.substring(start, i).trim());\n    start = ++i;\n  }\n\n  if (output.length === 0) {\n    throw 'Empty event selector: ' + s;\n  }\n\n  return output;\n}\n\nfunction parseSelector(s) {\n  return s[0] === '[' ? parseBetween(s) : parseStream(s);\n}\n\nfunction parseBetween(s) {\n  const n = s.length;\n  let i = 1,\n      b;\n  i = find(s, i, RBRACK, LBRACK, RBRACK);\n\n  if (i === n) {\n    throw 'Empty between selector: ' + s;\n  }\n\n  b = parseMerge(s.substring(1, i));\n\n  if (b.length !== 2) {\n    throw 'Between selector must have two elements: ' + s;\n  }\n\n  s = s.slice(i + 1).trim();\n\n  if (s[0] !== GT) {\n    throw 'Expected \\'>\\' after between selector: ' + s;\n  }\n\n  b = b.map(parseSelector);\n  const stream = parseSelector(s.slice(1).trim());\n\n  if (stream.between) {\n    return {\n      between: b,\n      stream: stream\n    };\n  } else {\n    stream.between = b;\n  }\n\n  return stream;\n}\n\nfunction parseStream(s) {\n  const stream = {\n    source: DEFAULT_SOURCE\n  },\n        source = [];\n  let throttle = [0, 0],\n      markname = 0,\n      start = 0,\n      n = s.length,\n      i = 0,\n      j,\n      filter; // extract throttle from end\n\n  if (s[n - 1] === RBRACE) {\n    i = s.lastIndexOf(LBRACE);\n\n    if (i >= 0) {\n      try {\n        throttle = parseThrottle(s.substring(i + 1, n - 1));\n      } catch (e) {\n        throw 'Invalid throttle specification: ' + s;\n      }\n\n      s = s.slice(0, i).trim();\n      n = s.length;\n    } else throw 'Unmatched right brace: ' + s;\n\n    i = 0;\n  }\n\n  if (!n) throw s; // set name flag based on first char\n\n  if (s[0] === NAME) markname = ++i; // extract first part of multi-part stream selector\n\n  j = find(s, i, COLON);\n\n  if (j < n) {\n    source.push(s.substring(start, j).trim());\n    start = i = ++j;\n  } // extract remaining part of stream selector\n\n\n  i = find(s, i, LBRACK);\n\n  if (i === n) {\n    source.push(s.substring(start, n).trim());\n  } else {\n    source.push(s.substring(start, i).trim());\n    filter = [];\n    start = ++i;\n    if (start === n) throw 'Unmatched left bracket: ' + s;\n  } // extract filters\n\n\n  while (i < n) {\n    i = find(s, i, RBRACK);\n    if (i === n) throw 'Unmatched left bracket: ' + s;\n    filter.push(s.substring(start, i).trim());\n    if (i < n - 1 && s[++i] !== LBRACK) throw 'Expected left bracket: ' + s;\n    start = ++i;\n  } // marshall event stream specification\n\n\n  if (!(n = source.length) || ILLEGAL.test(source[n - 1])) {\n    throw 'Invalid event selector: ' + s;\n  }\n\n  if (n > 1) {\n    stream.type = source[1];\n\n    if (markname) {\n      stream.markname = source[0].slice(1);\n    } else if (isMarkType(source[0])) {\n      stream.marktype = source[0];\n    } else {\n      stream.source = source[0];\n    }\n  } else {\n    stream.type = source[0];\n  }\n\n  if (stream.type.slice(-1) === '!') {\n    stream.consume = true;\n    stream.type = stream.type.slice(0, -1);\n  }\n\n  if (filter != null) stream.filter = filter;\n  if (throttle[0]) stream.throttle = throttle[0];\n  if (throttle[1]) stream.debounce = throttle[1];\n  return stream;\n}\n\nfunction parseThrottle(s) {\n  const a = s.split(COMMA);\n  if (!s.length || a.length > 2) throw s;\n  return a.map(_ => {\n    const x = +_;\n    if (x !== x) throw s;\n    return x;\n  });\n}\n\nexport { eventSelector as parseSelector };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}