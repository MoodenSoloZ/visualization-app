{"ast":null,"code":"import _classCallCheck from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { isGenerator, isInlineData, isNamedData, isSphereGenerator, isUrlData } from '../../data';\nimport { contains, isEmpty, omit } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport var SourceNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(SourceNode, _DataFlowNode);\n  var _super = _createSuper(SourceNode);\n  function SourceNode(data) {\n    var _this;\n    _classCallCheck(this, SourceNode);\n    _this = _super.call(this, null); // source cannot have parent\n    data !== null && data !== void 0 ? data : data = {\n      name: 'source'\n    };\n    var format;\n    if (!isGenerator(data)) {\n      format = data.format ? Object.assign({}, omit(data.format, ['parse'])) : {};\n    }\n    if (isInlineData(data)) {\n      _this._data = {\n        values: data.values\n      };\n    } else if (isUrlData(data)) {\n      _this._data = {\n        url: data.url\n      };\n      if (!format.type) {\n        // Extract extension from URL using snippet from\n        // http://stackoverflow.com/questions/680929/how-to-extract-extension-from-filename-string-in-javascript\n        var defaultExtension = /(?:\\.([^.]+))?$/.exec(data.url)[1];\n        if (!contains(['json', 'csv', 'tsv', 'dsv', 'topojson'], defaultExtension)) {\n          defaultExtension = 'json';\n        }\n        // defaultExtension has type string but we ensure that it is DataFormatType above\n        format.type = defaultExtension;\n      }\n    } else if (isSphereGenerator(data)) {\n      // hardwire GeoJSON sphere data into output specification\n      _this._data = {\n        values: [{\n          type: 'Sphere'\n        }]\n      };\n    } else if (isNamedData(data) || isGenerator(data)) {\n      _this._data = {};\n    }\n    // set flag to check if generator\n    _this._generator = isGenerator(data);\n    // any dataset can be named\n    if (data.name) {\n      _this._name = data.name;\n    }\n    if (format && !isEmpty(format)) {\n      _this._data.format = format;\n    }\n    return _this;\n  }\n  _createClass(SourceNode, [{\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return new Set();\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return undefined; // we don't know what this source produces\n    }\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this._data;\n    }\n  }, {\n    key: \"hasName\",\n    value: function hasName() {\n      return !!this._name;\n    }\n  }, {\n    key: \"isGenerator\",\n    get: function get() {\n      return this._generator;\n    }\n  }, {\n    key: \"dataName\",\n    get: function get() {\n      return this._name;\n    },\n    set: function set(name) {\n      this._name = name;\n    }\n  }, {\n    key: \"parent\",\n    set: function set(parent) {\n      throw new Error('Source nodes have to be roots.');\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      throw new Error('Source nodes are roots and cannot be removed.');\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      throw new Error('Cannot hash sources');\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      return Object.assign(Object.assign({\n        name: this._name\n      }, this._data), {\n        transform: []\n      });\n    }\n  }]);\n  return SourceNode;\n}(DataFlowNode);","map":{"version":3,"sources":["../../../../src/compile/data/source.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isGenerator, isInlineData, isNamedData, isSphereGenerator, isUrlData } from '../../data';\nimport { contains, isEmpty, omit } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class SourceNode extends DataFlowNode {\n    constructor(data) {\n        super(null); // source cannot have parent\n        data !== null && data !== void 0 ? data : (data = { name: 'source' });\n        let format;\n        if (!isGenerator(data)) {\n            format = data.format ? Object.assign({}, omit(data.format, ['parse'])) : {};\n        }\n        if (isInlineData(data)) {\n            this._data = { values: data.values };\n        }\n        else if (isUrlData(data)) {\n            this._data = { url: data.url };\n            if (!format.type) {\n                // Extract extension from URL using snippet from\n                // http://stackoverflow.com/questions/680929/how-to-extract-extension-from-filename-string-in-javascript\n                let defaultExtension = /(?:\\.([^.]+))?$/.exec(data.url)[1];\n                if (!contains(['json', 'csv', 'tsv', 'dsv', 'topojson'], defaultExtension)) {\n                    defaultExtension = 'json';\n                }\n                // defaultExtension has type string but we ensure that it is DataFormatType above\n                format.type = defaultExtension;\n            }\n        }\n        else if (isSphereGenerator(data)) {\n            // hardwire GeoJSON sphere data into output specification\n            this._data = { values: [{ type: 'Sphere' }] };\n        }\n        else if (isNamedData(data) || isGenerator(data)) {\n            this._data = {};\n        }\n        // set flag to check if generator\n        this._generator = isGenerator(data);\n        // any dataset can be named\n        if (data.name) {\n            this._name = data.name;\n        }\n        if (format && !isEmpty(format)) {\n            this._data.format = format;\n        }\n    }\n    dependentFields() {\n        return new Set();\n    }\n    producedFields() {\n        return undefined; // we don't know what this source produces\n    }\n    get data() {\n        return this._data;\n    }\n    hasName() {\n        return !!this._name;\n    }\n    get isGenerator() {\n        return this._generator;\n    }\n    get dataName() {\n        return this._name;\n    }\n    set dataName(name) {\n        this._name = name;\n    }\n    set parent(parent) {\n        throw new Error('Source nodes have to be roots.');\n    }\n    remove() {\n        throw new Error('Source nodes are roots and cannot be removed.');\n    }\n    hash() {\n        throw new Error('Cannot hash sources');\n    }\n    assemble() {\n        return Object.assign(Object.assign({ name: this._name }, this._data), { transform: [] });\n    }\n}\n//# sourceMappingURL=source.js.map"]},"metadata":{},"sourceType":"module"}