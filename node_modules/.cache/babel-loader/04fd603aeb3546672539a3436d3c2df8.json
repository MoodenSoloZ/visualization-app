{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { array, stringValue } from 'vega-util';\nimport { STORE, TUPLE, unitName } from '.';\nimport { X, Y } from '../../channel';\nimport { warn } from '../../log';\nimport { hasContinuousDomain } from '../../scale';\nimport { keys } from '../../util';\nimport { assembleInit } from './assemble';\nimport { TUPLE_FIELDS } from './project';\nimport scales from './scales';\nexport var BRUSH = '_brush';\nexport var SCALE_TRIGGER = '_scale_trigger';\nvar interval = {\n  defined: function defined(selCmpt) {\n    return selCmpt.type === 'interval';\n  },\n  signals: function signals(model, selCmpt, _signals) {\n    var name = selCmpt.name;\n    var fieldsSg = name + TUPLE_FIELDS;\n    var hasScales = scales.defined(selCmpt);\n    var init = selCmpt.init ? selCmpt.init[0] : null;\n    var dataSignals = [];\n    var scaleTriggers = [];\n    if (selCmpt.translate && !hasScales) {\n      var filterExpr = \"!event.item || event.item.mark.name !== \".concat(stringValue(name + BRUSH));\n      events(selCmpt, function (on, evt) {\n        var _a;\n        var _b;\n        var filters = array((_a = (_b = evt.between[0]).filter) !== null && _a !== void 0 ? _a : _b.filter = []);\n        if (!filters.includes(filterExpr)) {\n          filters.push(filterExpr);\n        }\n        return on;\n      });\n    }\n    selCmpt.project.items.forEach(function (proj, i) {\n      var channel = proj.channel;\n      if (channel !== X && channel !== Y) {\n        warn('Interval selections only support x and y encoding channels.');\n        return;\n      }\n      var val = init ? init[i] : null;\n      var cs = channelSignals(model, selCmpt, proj, val);\n      var dname = proj.signals.data;\n      var vname = proj.signals.visual;\n      var scaleName = stringValue(model.scaleName(channel));\n      var scaleType = model.getScaleComponent(channel).get('type');\n      var toNum = hasContinuousDomain(scaleType) ? '+' : '';\n      _signals.push.apply(_signals, _toConsumableArray(cs));\n      dataSignals.push(dname);\n      scaleTriggers.push({\n        scaleName: model.scaleName(channel),\n        expr: \"(!isArray(\".concat(dname, \") || \") + \"(\".concat(toNum, \"invert(\").concat(scaleName, \", \").concat(vname, \")[0] === \").concat(toNum).concat(dname, \"[0] && \") + \"\".concat(toNum, \"invert(\").concat(scaleName, \", \").concat(vname, \")[1] === \").concat(toNum).concat(dname, \"[1]))\")\n      });\n    });\n    // Proxy scale reactions to ensure that an infinite loop doesn't occur\n    // when an interval selection filter touches the scale.\n    if (!hasScales && scaleTriggers.length) {\n      _signals.push({\n        name: name + SCALE_TRIGGER,\n        value: {},\n        on: [{\n          events: scaleTriggers.map(function (t) {\n            return {\n              scale: t.scaleName\n            };\n          }),\n          update: \"\".concat(scaleTriggers.map(function (t) {\n            return t.expr;\n          }).join(' && '), \" ? \").concat(name + SCALE_TRIGGER, \" : {}\")\n        }]\n      });\n    }\n    // Only add an interval to the store if it has valid data extents. Data extents\n    // are set to null if pixel extents are equal to account for intervals over\n    // ordinal/nominal domains which, when inverted, will still produce a valid datum.\n    var update = \"unit: \".concat(unitName(model), \", fields: \").concat(fieldsSg, \", values\");\n    return _signals.concat(Object.assign(Object.assign({\n      name: name + TUPLE\n    }, init ? {\n      init: \"{\".concat(update, \": \").concat(assembleInit(init), \"}\")\n    } : {}), dataSignals.length ? {\n      on: [{\n        events: [{\n          signal: dataSignals.join(' || ')\n        }],\n        update: \"\".concat(dataSignals.join(' && '), \" ? {\").concat(update, \": [\").concat(dataSignals, \"]} : null\")\n      }]\n    } : {}));\n  },\n  marks: function marks(model, selCmpt, _marks) {\n    var name = selCmpt.name;\n    var _selCmpt$project$hasC = selCmpt.project.hasChannel,\n      x = _selCmpt$project$hasC.x,\n      y = _selCmpt$project$hasC.y;\n    var xvname = x === null || x === void 0 ? void 0 : x.signals.visual;\n    var yvname = y === null || y === void 0 ? void 0 : y.signals.visual;\n    var store = \"data(\".concat(stringValue(selCmpt.name + STORE), \")\");\n    // Do not add a brush if we're binding to scales\n    // or we don't have a valid interval projection\n    if (scales.defined(selCmpt) || !x && !y) {\n      return _marks;\n    }\n    var update = {\n      x: x !== undefined ? {\n        signal: \"\".concat(xvname, \"[0]\")\n      } : {\n        value: 0\n      },\n      y: y !== undefined ? {\n        signal: \"\".concat(yvname, \"[0]\")\n      } : {\n        value: 0\n      },\n      x2: x !== undefined ? {\n        signal: \"\".concat(xvname, \"[1]\")\n      } : {\n        field: {\n          group: 'width'\n        }\n      },\n      y2: y !== undefined ? {\n        signal: \"\".concat(yvname, \"[1]\")\n      } : {\n        field: {\n          group: 'height'\n        }\n      }\n    };\n    // If the selection is resolved to global, only a single interval is in\n    // the store. Wrap brush mark's encodings with a production rule to test\n    // this based on the `unit` property. Hide the brush mark if it corresponds\n    // to a unit different from the one in the store.\n    if (selCmpt.resolve === 'global') {\n      var _iterator = _createForOfIteratorHelper(keys(update)),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          update[key] = [Object.assign({\n            test: \"\".concat(store, \".length && \").concat(store, \"[0].unit === \").concat(unitName(model))\n          }, update[key]), {\n            value: 0\n          }];\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    // Two brush marks ensure that fill colors and other aesthetic choices do\n    // not interefere with the core marks, but that the brushed region can still\n    // be interacted with (e.g., dragging it around).\n    var _a = selCmpt.mark,\n      fill = _a.fill,\n      fillOpacity = _a.fillOpacity,\n      cursor = _a.cursor,\n      stroke = __rest(_a, [\"fill\", \"fillOpacity\", \"cursor\"]);\n    var vgStroke = keys(stroke).reduce(function (def, k) {\n      def[k] = [{\n        test: [x !== undefined && \"\".concat(xvname, \"[0] !== \").concat(xvname, \"[1]\"), y !== undefined && \"\".concat(yvname, \"[0] !== \").concat(yvname, \"[1]\")].filter(function (t) {\n          return t;\n        }).join(' && '),\n        value: stroke[k]\n      }, {\n        value: null\n      }];\n      return def;\n    }, {});\n    return [{\n      name: \"\".concat(name + BRUSH, \"_bg\"),\n      type: 'rect',\n      clip: true,\n      encode: {\n        enter: {\n          fill: {\n            value: fill\n          },\n          fillOpacity: {\n            value: fillOpacity\n          }\n        },\n        update: update\n      }\n    }].concat(_toConsumableArray(_marks), [{\n      name: name + BRUSH,\n      type: 'rect',\n      clip: true,\n      encode: {\n        enter: Object.assign(Object.assign({}, cursor ? {\n          cursor: {\n            value: cursor\n          }\n        } : {}), {\n          fill: {\n            value: 'transparent'\n          }\n        }),\n        update: Object.assign(Object.assign({}, update), vgStroke)\n      }\n    }]);\n  }\n};\nexport default interval;\n/**\n * Returns the visual and data signals for an interval selection.\n */\nfunction channelSignals(model, selCmpt, proj, init) {\n  var channel = proj.channel;\n  var vname = proj.signals.visual;\n  var dname = proj.signals.data;\n  var hasScales = scales.defined(selCmpt);\n  var scaleName = stringValue(model.scaleName(channel));\n  var scale = model.getScaleComponent(channel);\n  var scaleType = scale ? scale.get('type') : undefined;\n  var scaled = function scaled(str) {\n    return \"scale(\".concat(scaleName, \", \").concat(str, \")\");\n  };\n  var size = model.getSizeSignalRef(channel === X ? 'width' : 'height').signal;\n  var coord = \"\".concat(channel, \"(unit)\");\n  var on = events(selCmpt, function (def, evt) {\n    return [].concat(_toConsumableArray(def), [{\n      events: evt.between[0],\n      update: \"[\".concat(coord, \", \").concat(coord, \"]\")\n    }, {\n      events: evt,\n      update: \"[\".concat(vname, \"[0], clamp(\").concat(coord, \", 0, \").concat(size, \")]\")\n    } // Brush End\n    ]);\n  });\n  // React to pan/zooms of continuous scales. Non-continuous scales\n  // (band, point) cannot be pan/zoomed and any other changes\n  // to their domains (e.g., filtering) should clear the brushes.\n  on.push({\n    events: {\n      signal: selCmpt.name + SCALE_TRIGGER\n    },\n    update: hasContinuousDomain(scaleType) ? \"[\".concat(scaled(\"\".concat(dname, \"[0]\")), \", \").concat(scaled(\"\".concat(dname, \"[1]\")), \"]\") : \"[0, 0]\"\n  });\n  return hasScales ? [{\n    name: dname,\n    on: []\n  }] : [Object.assign(Object.assign({\n    name: vname\n  }, init ? {\n    init: assembleInit(init, true, scaled)\n  } : {\n    value: []\n  }), {\n    on: on\n  }), Object.assign(Object.assign({\n    name: dname\n  }, init ? {\n    init: assembleInit(init)\n  } : {}), {\n    on: [{\n      events: {\n        signal: vname\n      },\n      update: \"\".concat(vname, \"[0] === \").concat(vname, \"[1] ? null : invert(\").concat(scaleName, \", \").concat(vname, \")\")\n    }]\n  })];\n}\nfunction events(selCmpt, cb) {\n  return selCmpt.events.reduce(function (on, evt) {\n    if (!evt.between) {\n      warn(\"\".concat(evt, \" is not an ordered event stream for interval selections.\"));\n      return on;\n    }\n    return cb(on, evt);\n  }, []);\n}","map":{"version":3,"sources":["../../../../src/compile/selection/interval.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { array, stringValue } from 'vega-util';\nimport { STORE, TUPLE, unitName } from '.';\nimport { X, Y } from '../../channel';\nimport { warn } from '../../log';\nimport { hasContinuousDomain } from '../../scale';\nimport { keys } from '../../util';\nimport { assembleInit } from './assemble';\nimport { TUPLE_FIELDS } from './project';\nimport scales from './scales';\nexport const BRUSH = '_brush';\nexport const SCALE_TRIGGER = '_scale_trigger';\nconst interval = {\n    defined: selCmpt => selCmpt.type === 'interval',\n    signals: (model, selCmpt, signals) => {\n        const name = selCmpt.name;\n        const fieldsSg = name + TUPLE_FIELDS;\n        const hasScales = scales.defined(selCmpt);\n        const init = selCmpt.init ? selCmpt.init[0] : null;\n        const dataSignals = [];\n        const scaleTriggers = [];\n        if (selCmpt.translate && !hasScales) {\n            const filterExpr = `!event.item || event.item.mark.name !== ${stringValue(name + BRUSH)}`;\n            events(selCmpt, (on, evt) => {\n                var _a;\n                var _b;\n                const filters = array(((_a = (_b = evt.between[0]).filter) !== null && _a !== void 0 ? _a : (_b.filter = [])));\n                if (!filters.includes(filterExpr)) {\n                    filters.push(filterExpr);\n                }\n                return on;\n            });\n        }\n        selCmpt.project.items.forEach((proj, i) => {\n            const channel = proj.channel;\n            if (channel !== X && channel !== Y) {\n                warn('Interval selections only support x and y encoding channels.');\n                return;\n            }\n            const val = init ? init[i] : null;\n            const cs = channelSignals(model, selCmpt, proj, val);\n            const dname = proj.signals.data;\n            const vname = proj.signals.visual;\n            const scaleName = stringValue(model.scaleName(channel));\n            const scaleType = model.getScaleComponent(channel).get('type');\n            const toNum = hasContinuousDomain(scaleType) ? '+' : '';\n            signals.push(...cs);\n            dataSignals.push(dname);\n            scaleTriggers.push({\n                scaleName: model.scaleName(channel),\n                expr: `(!isArray(${dname}) || ` +\n                    `(${toNum}invert(${scaleName}, ${vname})[0] === ${toNum}${dname}[0] && ` +\n                    `${toNum}invert(${scaleName}, ${vname})[1] === ${toNum}${dname}[1]))`\n            });\n        });\n        // Proxy scale reactions to ensure that an infinite loop doesn't occur\n        // when an interval selection filter touches the scale.\n        if (!hasScales && scaleTriggers.length) {\n            signals.push({\n                name: name + SCALE_TRIGGER,\n                value: {},\n                on: [\n                    {\n                        events: scaleTriggers.map(t => ({ scale: t.scaleName })),\n                        update: `${scaleTriggers.map(t => t.expr).join(' && ')} ? ${name + SCALE_TRIGGER} : {}`\n                    }\n                ]\n            });\n        }\n        // Only add an interval to the store if it has valid data extents. Data extents\n        // are set to null if pixel extents are equal to account for intervals over\n        // ordinal/nominal domains which, when inverted, will still produce a valid datum.\n        const update = `unit: ${unitName(model)}, fields: ${fieldsSg}, values`;\n        return signals.concat(Object.assign(Object.assign({ name: name + TUPLE }, (init ? { init: `{${update}: ${assembleInit(init)}}` } : {})), (dataSignals.length\n            ? {\n                on: [\n                    {\n                        events: [{ signal: dataSignals.join(' || ') }],\n                        update: `${dataSignals.join(' && ')} ? {${update}: [${dataSignals}]} : null`\n                    }\n                ]\n            }\n            : {})));\n    },\n    marks: (model, selCmpt, marks) => {\n        const name = selCmpt.name;\n        const { x, y } = selCmpt.project.hasChannel;\n        const xvname = x === null || x === void 0 ? void 0 : x.signals.visual;\n        const yvname = y === null || y === void 0 ? void 0 : y.signals.visual;\n        const store = `data(${stringValue(selCmpt.name + STORE)})`;\n        // Do not add a brush if we're binding to scales\n        // or we don't have a valid interval projection\n        if (scales.defined(selCmpt) || (!x && !y)) {\n            return marks;\n        }\n        const update = {\n            x: x !== undefined ? { signal: `${xvname}[0]` } : { value: 0 },\n            y: y !== undefined ? { signal: `${yvname}[0]` } : { value: 0 },\n            x2: x !== undefined ? { signal: `${xvname}[1]` } : { field: { group: 'width' } },\n            y2: y !== undefined ? { signal: `${yvname}[1]` } : { field: { group: 'height' } }\n        };\n        // If the selection is resolved to global, only a single interval is in\n        // the store. Wrap brush mark's encodings with a production rule to test\n        // this based on the `unit` property. Hide the brush mark if it corresponds\n        // to a unit different from the one in the store.\n        if (selCmpt.resolve === 'global') {\n            for (const key of keys(update)) {\n                update[key] = [\n                    Object.assign({ test: `${store}.length && ${store}[0].unit === ${unitName(model)}` }, update[key]),\n                    { value: 0 }\n                ];\n            }\n        }\n        // Two brush marks ensure that fill colors and other aesthetic choices do\n        // not interefere with the core marks, but that the brushed region can still\n        // be interacted with (e.g., dragging it around).\n        const _a = selCmpt.mark, { fill, fillOpacity, cursor } = _a, stroke = __rest(_a, [\"fill\", \"fillOpacity\", \"cursor\"]);\n        const vgStroke = keys(stroke).reduce((def, k) => {\n            def[k] = [\n                {\n                    test: [x !== undefined && `${xvname}[0] !== ${xvname}[1]`, y !== undefined && `${yvname}[0] !== ${yvname}[1]`]\n                        .filter(t => t)\n                        .join(' && '),\n                    value: stroke[k]\n                },\n                { value: null }\n            ];\n            return def;\n        }, {});\n        return [\n            {\n                name: `${name + BRUSH}_bg`,\n                type: 'rect',\n                clip: true,\n                encode: {\n                    enter: {\n                        fill: { value: fill },\n                        fillOpacity: { value: fillOpacity }\n                    },\n                    update\n                }\n            },\n            ...marks,\n            {\n                name: name + BRUSH,\n                type: 'rect',\n                clip: true,\n                encode: {\n                    enter: Object.assign(Object.assign({}, (cursor ? { cursor: { value: cursor } } : {})), { fill: { value: 'transparent' } }),\n                    update: Object.assign(Object.assign({}, update), vgStroke)\n                }\n            }\n        ];\n    }\n};\nexport default interval;\n/**\n * Returns the visual and data signals for an interval selection.\n */\nfunction channelSignals(model, selCmpt, proj, init) {\n    const channel = proj.channel;\n    const vname = proj.signals.visual;\n    const dname = proj.signals.data;\n    const hasScales = scales.defined(selCmpt);\n    const scaleName = stringValue(model.scaleName(channel));\n    const scale = model.getScaleComponent(channel);\n    const scaleType = scale ? scale.get('type') : undefined;\n    const scaled = (str) => `scale(${scaleName}, ${str})`;\n    const size = model.getSizeSignalRef(channel === X ? 'width' : 'height').signal;\n    const coord = `${channel}(unit)`;\n    const on = events(selCmpt, (def, evt) => {\n        return [\n            ...def,\n            { events: evt.between[0], update: `[${coord}, ${coord}]` },\n            { events: evt, update: `[${vname}[0], clamp(${coord}, 0, ${size})]` } // Brush End\n        ];\n    });\n    // React to pan/zooms of continuous scales. Non-continuous scales\n    // (band, point) cannot be pan/zoomed and any other changes\n    // to their domains (e.g., filtering) should clear the brushes.\n    on.push({\n        events: { signal: selCmpt.name + SCALE_TRIGGER },\n        update: hasContinuousDomain(scaleType) ? `[${scaled(`${dname}[0]`)}, ${scaled(`${dname}[1]`)}]` : `[0, 0]`\n    });\n    return hasScales\n        ? [{ name: dname, on: [] }]\n        : [\n            Object.assign(Object.assign({ name: vname }, (init ? { init: assembleInit(init, true, scaled) } : { value: [] })), { on }),\n            Object.assign(Object.assign({ name: dname }, (init ? { init: assembleInit(init) } : {})), { on: [\n                    {\n                        events: { signal: vname },\n                        update: `${vname}[0] === ${vname}[1] ? null : invert(${scaleName}, ${vname})`\n                    }\n                ] })\n        ];\n}\nfunction events(selCmpt, cb) {\n    return selCmpt.events.reduce((on, evt) => {\n        if (!evt.between) {\n            warn(`${evt} is not an ordered event stream for interval selections.`);\n            return on;\n        }\n        return cb(on, evt);\n    }, []);\n}\n//# sourceMappingURL=interval.js.map"]},"metadata":{},"sourceType":"module"}