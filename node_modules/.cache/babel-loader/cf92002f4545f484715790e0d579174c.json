{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport Observable from \"./observable\";\n// TODO: This observer iteration approach looks inelegant and expensive\n// Idea: Come up with super class for Subscription that contains the\n//       notify*, ... methods and use it here\n/**\n * A subject is a \"hot\" observable (see `multicast`) that has its observer\n * methods (`.next(value)`, `.error(error)`, `.complete()`) exposed.\n *\n * Be careful, though! With great power comes great responsibility. Only use\n * the `Subject` when you really need to trigger updates \"from the outside\" and\n * try to keep the code that can access it to a minimum. Return\n * `Observable.from(mySubject)` to not allow other code to mutate.\n */\nvar MulticastSubject = /*#__PURE__*/function (_Observable) {\n  _inherits(MulticastSubject, _Observable);\n  var _super = _createSuper(MulticastSubject);\n  function MulticastSubject() {\n    var _this;\n    _classCallCheck(this, MulticastSubject);\n    _this = _super.call(this, function (observer) {\n      _this._observers.add(observer);\n      return function () {\n        return _this._observers.delete(observer);\n      };\n    });\n    _this._observers = new Set();\n    return _this;\n  }\n  _createClass(MulticastSubject, [{\n    key: \"next\",\n    value: function next(value) {\n      var _iterator = _createForOfIteratorHelper(this._observers),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var observer = _step.value;\n          observer.next(value);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"error\",\n    value: function error(_error) {\n      var _iterator2 = _createForOfIteratorHelper(this._observers),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var observer = _step2.value;\n          observer.error(_error);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      var _iterator3 = _createForOfIteratorHelper(this._observers),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var observer = _step3.value;\n          observer.complete();\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }]);\n  return MulticastSubject;\n}(Observable);\nexport default MulticastSubject;","map":{"version":3,"names":["Observable","MulticastSubject","observer","_observers","add","delete","Set","value","next","error","complete"],"sources":["/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/observable-fns/dist.esm/subject.js"],"sourcesContent":["import Observable from \"./observable\";\n// TODO: This observer iteration approach looks inelegant and expensive\n// Idea: Come up with super class for Subscription that contains the\n//       notify*, ... methods and use it here\n/**\n * A subject is a \"hot\" observable (see `multicast`) that has its observer\n * methods (`.next(value)`, `.error(error)`, `.complete()`) exposed.\n *\n * Be careful, though! With great power comes great responsibility. Only use\n * the `Subject` when you really need to trigger updates \"from the outside\" and\n * try to keep the code that can access it to a minimum. Return\n * `Observable.from(mySubject)` to not allow other code to mutate.\n */\nclass MulticastSubject extends Observable {\n    constructor() {\n        super(observer => {\n            this._observers.add(observer);\n            return () => this._observers.delete(observer);\n        });\n        this._observers = new Set();\n    }\n    next(value) {\n        for (const observer of this._observers) {\n            observer.next(value);\n        }\n    }\n    error(error) {\n        for (const observer of this._observers) {\n            observer.error(error);\n        }\n    }\n    complete() {\n        for (const observer of this._observers) {\n            observer.complete();\n        }\n    }\n}\nexport default MulticastSubject;\n"],"mappings":";;;;;AAAA,OAAOA,UAAU,MAAM,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA,IASMC,gBAAgB;EAAA;EAAA;EAClB,4BAAc;IAAA;IAAA;IACV,0BAAM,UAAAC,QAAQ,EAAI;MACd,MAAKC,UAAU,CAACC,GAAG,CAACF,QAAQ,CAAC;MAC7B,OAAO;QAAA,OAAM,MAAKC,UAAU,CAACE,MAAM,CAACH,QAAQ,CAAC;MAAA;IACjD,CAAC;IACD,MAAKC,UAAU,GAAG,IAAIG,GAAG,EAAE;IAAC;EAChC;EAAC;IAAA;IAAA,OACD,cAAKC,KAAK,EAAE;MAAA,2CACe,IAAI,CAACJ,UAAU;QAAA;MAAA;QAAtC,oDAAwC;UAAA,IAA7BD,QAAQ;UACfA,QAAQ,CAACM,IAAI,CAACD,KAAK,CAAC;QACxB;MAAC;QAAA;MAAA;QAAA;MAAA;IACL;EAAC;IAAA;IAAA,OACD,eAAME,MAAK,EAAE;MAAA,4CACc,IAAI,CAACN,UAAU;QAAA;MAAA;QAAtC,uDAAwC;UAAA,IAA7BD,QAAQ;UACfA,QAAQ,CAACO,KAAK,CAACA,MAAK,CAAC;QACzB;MAAC;QAAA;MAAA;QAAA;MAAA;IACL;EAAC;IAAA;IAAA,OACD,oBAAW;MAAA,4CACgB,IAAI,CAACN,UAAU;QAAA;MAAA;QAAtC,uDAAwC;UAAA,IAA7BD,QAAQ;UACfA,QAAQ,CAACQ,QAAQ,EAAE;QACvB;MAAC;QAAA;MAAA;QAAA;MAAA;IACL;EAAC;EAAA;AAAA,EAtB0BV,UAAU;AAwBzC,eAAeC,gBAAgB"},"metadata":{},"sourceType":"module"}