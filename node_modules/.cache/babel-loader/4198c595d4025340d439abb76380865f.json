{"ast":null,"code":"import _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { isString, mergeConfig } from 'vega-util';\nimport { getPositionScaleChannel } from '../channel';\nimport * as vlFieldDef from '../channeldef';\nimport { initConfig, stripAndRedirectConfig } from '../config';\nimport * as log from '../log';\nimport { normalize } from '../normalize';\nimport { assembleParameterSignals } from '../parameter';\nimport { extractTopLevelProperties, getFitType, isFitType } from '../spec/toplevel';\nimport { keys } from '../util';\nimport { buildModel } from './buildmodel';\nimport { assembleRootData } from './data/assemble';\nimport { optimizeDataflow } from './data/optimize';\n/**\n * Vega-Lite's main function, for compiling Vega-Lite spec into Vega spec.\n *\n * At a high-level, we make the following transformations in different phases:\n *\n * Input spec\n *     |\n *     |  (Normalization)\n *     v\n * Normalized Spec (Row/Column channels in single-view specs becomes faceted specs, composite marks becomes layered specs.)\n *     |\n *     |  (Build Model)\n *     v\n * A model tree of the spec\n *     |\n *     |  (Parse)\n *     v\n * A model tree with parsed components (intermediate structure of visualization primitives in a format that can be easily merged)\n *     |\n *     | (Optimize)\n *     v\n * A model tree with parsed components with the data component optimized\n *     |\n *     | (Assemble)\n *     v\n * Vega spec\n *\n * @param inputSpec The Vega-Lite specification.\n * @param opt       Optional arguments passed to the Vega-Lite compiler.\n * @returns         An object containing the compiled Vega spec and normalized Vega-Lite spec.\n */\nexport function compile(inputSpec) {\n  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  // 0. Augment opt with default opts\n  if (opt.logger) {\n    // set the singleton logger to the provided logger\n    log.set(opt.logger);\n  }\n  if (opt.fieldTitle) {\n    // set the singleton field title formatter\n    vlFieldDef.setTitleFormatter(opt.fieldTitle);\n  }\n  try {\n    // 1. Initialize config by deep merging default config with the config provided via option and the input spec.\n    var config = initConfig(mergeConfig(opt.config, inputSpec.config));\n    // 2. Normalize: Convert input spec -> normalized spec\n    // - Decompose all extended unit specs into composition of unit spec. For example, a box plot get expanded into multiple layers of bars, ticks, and rules. The shorthand row/column channel is also expanded to a facet spec.\n    // - Normalize autosize and width or height spec\n    var spec = normalize(inputSpec, config);\n    // 3. Build Model: normalized spec -> Model (a tree structure)\n    // This phases instantiates the models with default config by doing a top-down traversal. This allows us to pass properties that child models derive from their parents via their constructors.\n    // See the abstract `Model` class and its children (UnitModel, LayerModel, FacetModel, ConcatModel) for different types of models.\n    var model = buildModel(spec, null, '', undefined, config);\n    // 4 Parse: Model --> Model with components\n    // Note that components = intermediate representations that are equivalent to Vega specs.\n    // We need these intermediate representation because we need to merge many visualization \"components\" like projections, scales, axes, and legends.\n    // We will later convert these components into actual Vega specs in the assemble phase.\n    // In this phase, we do a bottom-up traversal over the whole tree to\n    // parse for each type of components once (e.g., data, layout, mark, scale).\n    // By doing bottom-up traversal, we start parsing components of unit specs and\n    // then merge child components of parent composite specs.\n    //\n    // Please see inside model.parse() for order of different components parsed.\n    model.parse();\n    // drawDataflow(model.component.data.sources);\n    // 5. Optimize the dataflow. This will modify the data component of the model.\n    optimizeDataflow(model.component.data, model);\n    // drawDataflow(model.component.data.sources);\n    // 6. Assemble: convert model components --> Vega Spec.\n    var vgSpec = assembleTopLevelModel(model, getTopLevelProperties(inputSpec, spec.autosize, config, model), inputSpec.datasets, inputSpec.usermeta);\n    return {\n      spec: vgSpec,\n      normalized: spec\n    };\n  } finally {\n    // Reset the singleton logger if a logger is provided\n    if (opt.logger) {\n      log.reset();\n    }\n    // Reset the singleton field title formatter if provided\n    if (opt.fieldTitle) {\n      vlFieldDef.resetTitleFormatter();\n    }\n  }\n}\nfunction getTopLevelProperties(inputSpec, autosize, config, model) {\n  var width = model.component.layoutSize.get('width');\n  var height = model.component.layoutSize.get('height');\n  if (autosize === undefined) {\n    autosize = {\n      type: 'pad'\n    };\n    if (model.hasAxisOrientSignalRef()) {\n      autosize.resize = true;\n    }\n  } else if (isString(autosize)) {\n    autosize = {\n      type: autosize\n    };\n  }\n  if (width && height && isFitType(autosize.type)) {\n    if (width === 'step' && height === 'step') {\n      log.warn(log.message.droppingFit());\n      autosize.type = 'pad';\n    } else if (width === 'step' || height === 'step') {\n      // effectively XOR, because else if\n      // get step dimension\n      var sizeType = width === 'step' ? 'width' : 'height';\n      // log that we're dropping fit for respective channel\n      log.warn(log.message.droppingFit(getPositionScaleChannel(sizeType)));\n      // setting type to inverse fit (so if we dropped fit-x, type is now fit-y)\n      var inverseSizeType = sizeType === 'width' ? 'height' : 'width';\n      autosize.type = getFitType(inverseSizeType);\n    }\n  }\n  return Object.assign(Object.assign(Object.assign({}, keys(autosize).length === 1 && autosize.type ? autosize.type === 'pad' ? {} : {\n    autosize: autosize.type\n  } : {\n    autosize: autosize\n  }), extractTopLevelProperties(config, false)), extractTopLevelProperties(inputSpec, true));\n}\n/*\n * Assemble the top-level model to a Vega spec.\n *\n * Note: this couldn't be `model.assemble()` since the top-level model\n * needs some special treatment to generate top-level properties.\n */\nfunction assembleTopLevelModel(model, topLevelProperties) {\n  var datasets = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var usermeta = arguments.length > 3 ? arguments[3] : undefined;\n  // Config with Vega-Lite only config removed.\n  var vgConfig = model.config ? stripAndRedirectConfig(model.config) : undefined;\n  var data = [].concat(model.assembleSelectionData([]),\n  // only assemble data in the root\n  assembleRootData(model.component.data, datasets));\n  var projections = model.assembleProjections();\n  var title = model.assembleTitle();\n  var style = model.assembleGroupStyle();\n  var encodeEntry = model.assembleGroupEncodeEntry(true);\n  var layoutSignals = model.assembleLayoutSignals();\n  // move width and height signals with values to top level\n  layoutSignals = layoutSignals.filter(function (signal) {\n    if ((signal.name === 'width' || signal.name === 'height') && signal.value !== undefined) {\n      topLevelProperties[signal.name] = +signal.value;\n      return false;\n    }\n    return true;\n  });\n  var params = topLevelProperties.params,\n    otherTopLevelProps = __rest(topLevelProperties, [\"params\"]);\n  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n    $schema: 'https://vega.github.io/schema/vega/v5.json'\n  }, model.description ? {\n    description: model.description\n  } : {}), otherTopLevelProps), title ? {\n    title: title\n  } : {}), style ? {\n    style: style\n  } : {}), encodeEntry ? {\n    encode: {\n      update: encodeEntry\n    }\n  } : {}), {\n    data: data\n  }), projections.length > 0 ? {\n    projections: projections\n  } : {}), model.assembleGroup([].concat(_toConsumableArray(layoutSignals), _toConsumableArray(model.assembleSelectionTopLevelSignals([])), _toConsumableArray(assembleParameterSignals(params))))), vgConfig ? {\n    config: vgConfig\n  } : {}), usermeta ? {\n    usermeta: usermeta\n  } : {});\n}","map":{"version":3,"sources":["../../../src/compile/compile.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isString, mergeConfig } from 'vega-util';\nimport { getPositionScaleChannel } from '../channel';\nimport * as vlFieldDef from '../channeldef';\nimport { initConfig, stripAndRedirectConfig } from '../config';\nimport * as log from '../log';\nimport { normalize } from '../normalize';\nimport { assembleParameterSignals } from '../parameter';\nimport { extractTopLevelProperties, getFitType, isFitType } from '../spec/toplevel';\nimport { keys } from '../util';\nimport { buildModel } from './buildmodel';\nimport { assembleRootData } from './data/assemble';\nimport { optimizeDataflow } from './data/optimize';\n/**\n * Vega-Lite's main function, for compiling Vega-Lite spec into Vega spec.\n *\n * At a high-level, we make the following transformations in different phases:\n *\n * Input spec\n *     |\n *     |  (Normalization)\n *     v\n * Normalized Spec (Row/Column channels in single-view specs becomes faceted specs, composite marks becomes layered specs.)\n *     |\n *     |  (Build Model)\n *     v\n * A model tree of the spec\n *     |\n *     |  (Parse)\n *     v\n * A model tree with parsed components (intermediate structure of visualization primitives in a format that can be easily merged)\n *     |\n *     | (Optimize)\n *     v\n * A model tree with parsed components with the data component optimized\n *     |\n *     | (Assemble)\n *     v\n * Vega spec\n *\n * @param inputSpec The Vega-Lite specification.\n * @param opt       Optional arguments passed to the Vega-Lite compiler.\n * @returns         An object containing the compiled Vega spec and normalized Vega-Lite spec.\n */\nexport function compile(inputSpec, opt = {}) {\n    // 0. Augment opt with default opts\n    if (opt.logger) {\n        // set the singleton logger to the provided logger\n        log.set(opt.logger);\n    }\n    if (opt.fieldTitle) {\n        // set the singleton field title formatter\n        vlFieldDef.setTitleFormatter(opt.fieldTitle);\n    }\n    try {\n        // 1. Initialize config by deep merging default config with the config provided via option and the input spec.\n        const config = initConfig(mergeConfig(opt.config, inputSpec.config));\n        // 2. Normalize: Convert input spec -> normalized spec\n        // - Decompose all extended unit specs into composition of unit spec. For example, a box plot get expanded into multiple layers of bars, ticks, and rules. The shorthand row/column channel is also expanded to a facet spec.\n        // - Normalize autosize and width or height spec\n        const spec = normalize(inputSpec, config);\n        // 3. Build Model: normalized spec -> Model (a tree structure)\n        // This phases instantiates the models with default config by doing a top-down traversal. This allows us to pass properties that child models derive from their parents via their constructors.\n        // See the abstract `Model` class and its children (UnitModel, LayerModel, FacetModel, ConcatModel) for different types of models.\n        const model = buildModel(spec, null, '', undefined, config);\n        // 4 Parse: Model --> Model with components\n        // Note that components = intermediate representations that are equivalent to Vega specs.\n        // We need these intermediate representation because we need to merge many visualization \"components\" like projections, scales, axes, and legends.\n        // We will later convert these components into actual Vega specs in the assemble phase.\n        // In this phase, we do a bottom-up traversal over the whole tree to\n        // parse for each type of components once (e.g., data, layout, mark, scale).\n        // By doing bottom-up traversal, we start parsing components of unit specs and\n        // then merge child components of parent composite specs.\n        //\n        // Please see inside model.parse() for order of different components parsed.\n        model.parse();\n        // drawDataflow(model.component.data.sources);\n        // 5. Optimize the dataflow. This will modify the data component of the model.\n        optimizeDataflow(model.component.data, model);\n        // drawDataflow(model.component.data.sources);\n        // 6. Assemble: convert model components --> Vega Spec.\n        const vgSpec = assembleTopLevelModel(model, getTopLevelProperties(inputSpec, spec.autosize, config, model), inputSpec.datasets, inputSpec.usermeta);\n        return {\n            spec: vgSpec,\n            normalized: spec\n        };\n    }\n    finally {\n        // Reset the singleton logger if a logger is provided\n        if (opt.logger) {\n            log.reset();\n        }\n        // Reset the singleton field title formatter if provided\n        if (opt.fieldTitle) {\n            vlFieldDef.resetTitleFormatter();\n        }\n    }\n}\nfunction getTopLevelProperties(inputSpec, autosize, config, model) {\n    const width = model.component.layoutSize.get('width');\n    const height = model.component.layoutSize.get('height');\n    if (autosize === undefined) {\n        autosize = { type: 'pad' };\n        if (model.hasAxisOrientSignalRef()) {\n            autosize.resize = true;\n        }\n    }\n    else if (isString(autosize)) {\n        autosize = { type: autosize };\n    }\n    if (width && height && isFitType(autosize.type)) {\n        if (width === 'step' && height === 'step') {\n            log.warn(log.message.droppingFit());\n            autosize.type = 'pad';\n        }\n        else if (width === 'step' || height === 'step') {\n            // effectively XOR, because else if\n            // get step dimension\n            const sizeType = width === 'step' ? 'width' : 'height';\n            // log that we're dropping fit for respective channel\n            log.warn(log.message.droppingFit(getPositionScaleChannel(sizeType)));\n            // setting type to inverse fit (so if we dropped fit-x, type is now fit-y)\n            const inverseSizeType = sizeType === 'width' ? 'height' : 'width';\n            autosize.type = getFitType(inverseSizeType);\n        }\n    }\n    return Object.assign(Object.assign(Object.assign({}, (keys(autosize).length === 1 && autosize.type\n        ? autosize.type === 'pad'\n            ? {}\n            : { autosize: autosize.type }\n        : { autosize })), extractTopLevelProperties(config, false)), extractTopLevelProperties(inputSpec, true));\n}\n/*\n * Assemble the top-level model to a Vega spec.\n *\n * Note: this couldn't be `model.assemble()` since the top-level model\n * needs some special treatment to generate top-level properties.\n */\nfunction assembleTopLevelModel(model, topLevelProperties, datasets = {}, usermeta) {\n    // Config with Vega-Lite only config removed.\n    const vgConfig = model.config ? stripAndRedirectConfig(model.config) : undefined;\n    const data = [].concat(model.assembleSelectionData([]), \n    // only assemble data in the root\n    assembleRootData(model.component.data, datasets));\n    const projections = model.assembleProjections();\n    const title = model.assembleTitle();\n    const style = model.assembleGroupStyle();\n    const encodeEntry = model.assembleGroupEncodeEntry(true);\n    let layoutSignals = model.assembleLayoutSignals();\n    // move width and height signals with values to top level\n    layoutSignals = layoutSignals.filter(signal => {\n        if ((signal.name === 'width' || signal.name === 'height') && signal.value !== undefined) {\n            topLevelProperties[signal.name] = +signal.value;\n            return false;\n        }\n        return true;\n    });\n    const { params } = topLevelProperties, otherTopLevelProps = __rest(topLevelProperties, [\"params\"]);\n    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ $schema: 'https://vega.github.io/schema/vega/v5.json' }, (model.description ? { description: model.description } : {})), otherTopLevelProps), (title ? { title } : {})), (style ? { style } : {})), (encodeEntry ? { encode: { update: encodeEntry } } : {})), { data }), (projections.length > 0 ? { projections } : {})), model.assembleGroup([\n        ...layoutSignals,\n        ...model.assembleSelectionTopLevelSignals([]),\n        ...assembleParameterSignals(params)\n    ])), (vgConfig ? { config: vgConfig } : {})), (usermeta ? { usermeta } : {}));\n}\n//# sourceMappingURL=compile.js.map"]},"metadata":{},"sourceType":"module"}