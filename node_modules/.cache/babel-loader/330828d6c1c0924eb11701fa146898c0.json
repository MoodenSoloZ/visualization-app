{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { array, isArray } from 'vega-util';\nimport { AXIS_PARTS, AXIS_PROPERTY_TYPE, CONDITIONAL_AXIS_PROP_INDEX, isConditionalAxisValue } from '../../axis';\nimport { POSITION_SCALE_CHANNELS } from '../../channel';\nimport { defaultTitle } from '../../channeldef';\nimport { isText } from '../../title';\nimport { contains, getFirstDefined, isEmpty, replaceAll } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { exprFromValueRefOrSignalRef } from '../common';\nimport { expression } from '../predicate';\nfunction assembleTitle(title, config) {\n  if (!title) {\n    return undefined;\n  }\n  if (isArray(title) && !isText(title)) {\n    return title.map(function (fieldDef) {\n      return defaultTitle(fieldDef, config);\n    }).join(', ');\n  }\n  return title;\n}\nfunction setAxisEncode(axis, part, vgProp, vgRef) {\n  var _a, _b, _c;\n  var _d, _e;\n  (_a = axis.encode) !== null && _a !== void 0 ? _a : axis.encode = {};\n  (_b = (_d = axis.encode)[part]) !== null && _b !== void 0 ? _b : _d[part] = {};\n  (_c = (_e = axis.encode[part]).update) !== null && _c !== void 0 ? _c : _e.update = {};\n  // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n  axis.encode[part].update[vgProp] = vgRef;\n}\nexport function assembleAxis(axisCmpt, kind, config) {\n  var opt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n    header: false\n  };\n  var _a, _b;\n  var _c = axisCmpt.combine(),\n    disable = _c.disable,\n    orient = _c.orient,\n    scale = _c.scale,\n    labelExpr = _c.labelExpr,\n    title = _c.title,\n    zindex = _c.zindex,\n    axis = __rest(_c, [\"disable\", \"orient\", \"scale\", \"labelExpr\", \"title\", \"zindex\"]);\n  if (disable) {\n    return undefined;\n  }\n  for (var prop in axis) {\n    var propType = AXIS_PROPERTY_TYPE[prop];\n    var propValue = axis[prop];\n    if (propType && propType !== kind && propType !== 'both') {\n      // Remove properties that are not valid for this kind of axis\n      delete axis[prop];\n    } else if (isConditionalAxisValue(propValue)) {\n      // deal with conditional axis value\n      var condition = propValue.condition,\n        valueOrSignalRef = __rest(propValue, [\"condition\"]);\n      var conditions = array(condition);\n      var propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];\n      if (propIndex) {\n        var _propIndex = propIndex,\n          vgProp = _propIndex.vgProp,\n          part = _propIndex.part;\n        // If there is a corresponding Vega property for the channel,\n        // use Vega's custom axis encoding and delete the original axis property to avoid conflicts\n        var vgRef = [].concat(_toConsumableArray(conditions.map(function (c) {\n          var test = c.test,\n            valueOrSignalCRef = __rest(c, [\"test\"]);\n          return Object.assign({\n            test: expression(null, test)\n          }, valueOrSignalCRef);\n        })), [valueOrSignalRef]);\n        setAxisEncode(axis, part, vgProp, vgRef);\n        delete axis[prop];\n      } else if (propIndex === null) {\n        // If propIndex is null, this means we support conditional axis property by converting the condition to signal instead.\n        var signalRef = {\n          signal: conditions.map(function (c) {\n            var test = c.test,\n              valueOrSignalCRef = __rest(c, [\"test\"]);\n            return \"\".concat(expression(null, test), \" ? \").concat(exprFromValueRefOrSignalRef(valueOrSignalCRef), \" : \");\n          }).join('') + exprFromValueRefOrSignalRef(valueOrSignalRef)\n        };\n        axis[prop] = signalRef;\n      }\n    } else if (isSignalRef(propValue)) {\n      var _propIndex2 = CONDITIONAL_AXIS_PROP_INDEX[prop];\n      if (_propIndex2) {\n        var _vgProp = _propIndex2.vgProp,\n          _part = _propIndex2.part;\n        setAxisEncode(axis, _part, _vgProp, propValue);\n        delete axis[prop];\n      } // else do nothing since the property already supports signal\n    }\n    // Do not pass labelAlign/Baseline = null to Vega since it won't pass the schema\n    // Note that we need to use null so the default labelAlign is preserved.\n    if (contains(['labelAlign', 'labelBaseline'], prop) && axis[prop] === null) {\n      delete axis[prop];\n    }\n  }\n  if (kind === 'grid') {\n    if (!axis.grid) {\n      return undefined;\n    }\n    // Remove unnecessary encode block\n    if (axis.encode) {\n      // Only need to keep encode block for grid\n      var grid = axis.encode.grid;\n      axis.encode = Object.assign({}, grid ? {\n        grid: grid\n      } : {});\n      if (isEmpty(axis.encode)) {\n        delete axis.encode;\n      }\n    }\n    return Object.assign(Object.assign({\n      scale: scale,\n      orient: orient\n    }, axis), {\n      domain: false,\n      labels: false,\n      aria: false,\n      // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`\n      // would not affect gridAxis\n      maxExtent: 0,\n      minExtent: 0,\n      ticks: false,\n      zindex: getFirstDefined(zindex, 0) // put grid behind marks by default\n    });\n  } else {\n    // kind === 'main'\n    if (!opt.header && axisCmpt.mainExtracted) {\n      // if mainExtracted has been extracted to a separate facet\n      return undefined;\n    }\n    if (labelExpr !== undefined) {\n      var expr = labelExpr;\n      if (((_b = (_a = axis.encode) === null || _a === void 0 ? void 0 : _a.labels) === null || _b === void 0 ? void 0 : _b.update) && isSignalRef(axis.encode.labels.update.text)) {\n        expr = replaceAll(labelExpr, 'datum.label', axis.encode.labels.update.text.signal);\n      }\n      setAxisEncode(axis, 'labels', 'text', {\n        signal: expr\n      });\n    }\n    if (axis.labelAlign === null) {\n      delete axis.labelAlign;\n    }\n    // Remove unnecessary encode block\n    if (axis.encode) {\n      var _iterator = _createForOfIteratorHelper(AXIS_PARTS),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _part2 = _step.value;\n          if (!axisCmpt.hasAxisPart(_part2)) {\n            delete axis.encode[_part2];\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      if (isEmpty(axis.encode)) {\n        delete axis.encode;\n      }\n    }\n    var titleString = assembleTitle(title, config);\n    return Object.assign(Object.assign(Object.assign(Object.assign({\n      scale: scale,\n      orient: orient,\n      grid: false\n    }, titleString ? {\n      title: titleString\n    } : {}), axis), config.aria === false ? {\n      aria: false\n    } : {}), {\n      zindex: getFirstDefined(zindex, 0) // put axis line above marks by default\n    });\n  }\n}\n/**\n * Add axis signals so grid line works correctly\n * (Fix https://github.com/vega/vega-lite/issues/4226)\n */\nexport function assembleAxisSignals(model) {\n  var axes = model.component.axes;\n  var signals = [];\n  var _iterator2 = _createForOfIteratorHelper(POSITION_SCALE_CHANNELS),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var channel = _step2.value;\n      if (axes[channel]) {\n        var _iterator3 = _createForOfIteratorHelper(axes[channel]),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var axis = _step3.value;\n            if (!axis.get('disable') && !axis.get('gridScale')) {\n              // If there is x-axis but no y-scale for gridScale, need to set height/width so x-axis can draw the grid with the right height. Same for y-axis and width.\n              var sizeType = channel === 'x' ? 'height' : 'width';\n              var update = model.getSizeSignalRef(sizeType).signal;\n              if (sizeType !== update) {\n                signals.push({\n                  name: sizeType,\n                  update: update\n                });\n              }\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return signals;\n}\nexport function assembleAxes(axisComponents, config) {\n  var _axisComponents$x = axisComponents.x,\n    x = _axisComponents$x === void 0 ? [] : _axisComponents$x,\n    _axisComponents$y = axisComponents.y,\n    y = _axisComponents$y === void 0 ? [] : _axisComponents$y;\n  return [].concat(_toConsumableArray(x.map(function (a) {\n    return assembleAxis(a, 'grid', config);\n  })), _toConsumableArray(y.map(function (a) {\n    return assembleAxis(a, 'grid', config);\n  })), _toConsumableArray(x.map(function (a) {\n    return assembleAxis(a, 'main', config);\n  })), _toConsumableArray(y.map(function (a) {\n    return assembleAxis(a, 'main', config);\n  }))).filter(function (a) {\n    return a;\n  }); // filter undefined\n}","map":{"version":3,"sources":["../../../../src/compile/axis/assemble.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { array, isArray } from 'vega-util';\nimport { AXIS_PARTS, AXIS_PROPERTY_TYPE, CONDITIONAL_AXIS_PROP_INDEX, isConditionalAxisValue } from '../../axis';\nimport { POSITION_SCALE_CHANNELS } from '../../channel';\nimport { defaultTitle } from '../../channeldef';\nimport { isText } from '../../title';\nimport { contains, getFirstDefined, isEmpty, replaceAll } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { exprFromValueRefOrSignalRef } from '../common';\nimport { expression } from '../predicate';\nfunction assembleTitle(title, config) {\n    if (!title) {\n        return undefined;\n    }\n    if (isArray(title) && !isText(title)) {\n        return title.map(fieldDef => defaultTitle(fieldDef, config)).join(', ');\n    }\n    return title;\n}\nfunction setAxisEncode(axis, part, vgProp, vgRef) {\n    var _a, _b, _c;\n    var _d, _e;\n    (_a = axis.encode) !== null && _a !== void 0 ? _a : (axis.encode = {});\n    (_b = (_d = axis.encode)[part]) !== null && _b !== void 0 ? _b : (_d[part] = {});\n    (_c = (_e = axis.encode[part]).update) !== null && _c !== void 0 ? _c : (_e.update = {});\n    // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n    axis.encode[part].update[vgProp] = vgRef;\n}\nexport function assembleAxis(axisCmpt, kind, config, opt = { header: false }) {\n    var _a, _b;\n    const _c = axisCmpt.combine(), { disable, orient, scale, labelExpr, title, zindex } = _c, axis = __rest(_c, [\"disable\", \"orient\", \"scale\", \"labelExpr\", \"title\", \"zindex\"]);\n    if (disable) {\n        return undefined;\n    }\n    for (const prop in axis) {\n        const propType = AXIS_PROPERTY_TYPE[prop];\n        const propValue = axis[prop];\n        if (propType && propType !== kind && propType !== 'both') {\n            // Remove properties that are not valid for this kind of axis\n            delete axis[prop];\n        }\n        else if (isConditionalAxisValue(propValue)) {\n            // deal with conditional axis value\n            const { condition } = propValue, valueOrSignalRef = __rest(propValue, [\"condition\"]);\n            const conditions = array(condition);\n            const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];\n            if (propIndex) {\n                const { vgProp, part } = propIndex;\n                // If there is a corresponding Vega property for the channel,\n                // use Vega's custom axis encoding and delete the original axis property to avoid conflicts\n                const vgRef = [\n                    ...conditions.map(c => {\n                        const { test } = c, valueOrSignalCRef = __rest(c, [\"test\"]);\n                        return Object.assign({ test: expression(null, test) }, valueOrSignalCRef);\n                    }),\n                    valueOrSignalRef\n                ];\n                setAxisEncode(axis, part, vgProp, vgRef);\n                delete axis[prop];\n            }\n            else if (propIndex === null) {\n                // If propIndex is null, this means we support conditional axis property by converting the condition to signal instead.\n                const signalRef = {\n                    signal: conditions\n                        .map(c => {\n                        const { test } = c, valueOrSignalCRef = __rest(c, [\"test\"]);\n                        return `${expression(null, test)} ? ${exprFromValueRefOrSignalRef(valueOrSignalCRef)} : `;\n                    })\n                        .join('') + exprFromValueRefOrSignalRef(valueOrSignalRef)\n                };\n                axis[prop] = signalRef;\n            }\n        }\n        else if (isSignalRef(propValue)) {\n            const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];\n            if (propIndex) {\n                const { vgProp, part } = propIndex;\n                setAxisEncode(axis, part, vgProp, propValue);\n                delete axis[prop];\n            } // else do nothing since the property already supports signal\n        }\n        // Do not pass labelAlign/Baseline = null to Vega since it won't pass the schema\n        // Note that we need to use null so the default labelAlign is preserved.\n        if (contains(['labelAlign', 'labelBaseline'], prop) && axis[prop] === null) {\n            delete axis[prop];\n        }\n    }\n    if (kind === 'grid') {\n        if (!axis.grid) {\n            return undefined;\n        }\n        // Remove unnecessary encode block\n        if (axis.encode) {\n            // Only need to keep encode block for grid\n            const { grid } = axis.encode;\n            axis.encode = Object.assign({}, (grid ? { grid } : {}));\n            if (isEmpty(axis.encode)) {\n                delete axis.encode;\n            }\n        }\n        return Object.assign(Object.assign({ scale,\n            orient }, axis), { domain: false, labels: false, aria: false, \n            // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`\n            // would not affect gridAxis\n            maxExtent: 0, minExtent: 0, ticks: false, zindex: getFirstDefined(zindex, 0) // put grid behind marks by default\n         });\n    }\n    else {\n        // kind === 'main'\n        if (!opt.header && axisCmpt.mainExtracted) {\n            // if mainExtracted has been extracted to a separate facet\n            return undefined;\n        }\n        if (labelExpr !== undefined) {\n            let expr = labelExpr;\n            if (((_b = (_a = axis.encode) === null || _a === void 0 ? void 0 : _a.labels) === null || _b === void 0 ? void 0 : _b.update) && isSignalRef(axis.encode.labels.update.text)) {\n                expr = replaceAll(labelExpr, 'datum.label', axis.encode.labels.update.text.signal);\n            }\n            setAxisEncode(axis, 'labels', 'text', { signal: expr });\n        }\n        if (axis.labelAlign === null) {\n            delete axis.labelAlign;\n        }\n        // Remove unnecessary encode block\n        if (axis.encode) {\n            for (const part of AXIS_PARTS) {\n                if (!axisCmpt.hasAxisPart(part)) {\n                    delete axis.encode[part];\n                }\n            }\n            if (isEmpty(axis.encode)) {\n                delete axis.encode;\n            }\n        }\n        const titleString = assembleTitle(title, config);\n        return Object.assign(Object.assign(Object.assign(Object.assign({ scale,\n            orient, grid: false }, (titleString ? { title: titleString } : {})), axis), (config.aria === false ? { aria: false } : {})), { zindex: getFirstDefined(zindex, 0) // put axis line above marks by default\n         });\n    }\n}\n/**\n * Add axis signals so grid line works correctly\n * (Fix https://github.com/vega/vega-lite/issues/4226)\n */\nexport function assembleAxisSignals(model) {\n    const { axes } = model.component;\n    const signals = [];\n    for (const channel of POSITION_SCALE_CHANNELS) {\n        if (axes[channel]) {\n            for (const axis of axes[channel]) {\n                if (!axis.get('disable') && !axis.get('gridScale')) {\n                    // If there is x-axis but no y-scale for gridScale, need to set height/width so x-axis can draw the grid with the right height. Same for y-axis and width.\n                    const sizeType = channel === 'x' ? 'height' : 'width';\n                    const update = model.getSizeSignalRef(sizeType).signal;\n                    if (sizeType !== update) {\n                        signals.push({\n                            name: sizeType,\n                            update\n                        });\n                    }\n                }\n            }\n        }\n    }\n    return signals;\n}\nexport function assembleAxes(axisComponents, config) {\n    const { x = [], y = [] } = axisComponents;\n    return [\n        ...x.map(a => assembleAxis(a, 'grid', config)),\n        ...y.map(a => assembleAxis(a, 'grid', config)),\n        ...x.map(a => assembleAxis(a, 'main', config)),\n        ...y.map(a => assembleAxis(a, 'main', config))\n    ].filter(a => a); // filter undefined\n}\n//# sourceMappingURL=assemble.js.map"]},"metadata":{},"sourceType":"module"}