{"ast":null,"code":"import _classCallCheck from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Split } from '../split';\n/**\n * Class to track interesting properties (see https://15721.courses.cs.cmu.edu/spring2016/papers/graefe-ieee1995.pdf)\n * about how fields have been parsed or whether they have been derived in a transform. We use this to not parse the\n * same field again (or differently).\n */\nexport var AncestorParse = /*#__PURE__*/function (_Split) {\n  _inherits(AncestorParse, _Split);\n  var _super = _createSuper(AncestorParse);\n  function AncestorParse() {\n    var _this;\n    var explicit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var implicit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var parseNothing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    _classCallCheck(this, AncestorParse);\n    _this = _super.call(this, explicit, implicit);\n    _this.explicit = explicit;\n    _this.implicit = implicit;\n    _this.parseNothing = parseNothing;\n    return _this;\n  }\n  _createClass(AncestorParse, [{\n    key: \"clone\",\n    value: function clone() {\n      var clone = _get(_getPrototypeOf(AncestorParse.prototype), \"clone\", this).call(this);\n      clone.parseNothing = this.parseNothing;\n      return clone;\n    }\n  }]);\n  return AncestorParse;\n}(Split);","map":{"version":3,"sources":["../../../../src/compile/data/index.ts"],"names":[],"mappings":";;;;;;AAEA,SAAQ,KAAK,QAAO,UAAU;AAkD9B;;;;AAIG;AACH,WAAa,aAAc;EAAA;EAAA;EACzB,yBAG6B;IAAA;IAAA,IAFX,QAAA,uEAA2B,CAAA,CAAE;IAAA,IAC7B,QAAA,uEAA2B,CAAA,CAAE;IAAA,IACtC,YAAA,uEAAe,KAAK;IAAA;IAE3B,0BAAM,QAAQ,EAAE,QAAQ;IAJR,MAAA,QAAQ,GAAR,QAAQ;IACR,MAAA,QAAQ,GAAR,QAAQ;IACjB,MAAA,YAAY,GAAZ,YAAY;IAAQ;EAG7B;EAAC;IAAA;IAAA,OAEM,iBAAK;MACV,IAAM,KAAK,2EAAiC;MAC5C,KAAK,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY;MACtC,OAAO,KAAK;IACd;EAAC;EAAA;AAAA,EAbgC,KAAY","sourceRoot":"","sourcesContent":["import { Split } from '../split';\n/**\n * Class to track interesting properties (see https://15721.courses.cs.cmu.edu/spring2016/papers/graefe-ieee1995.pdf)\n * about how fields have been parsed or whether they have been derived in a transform. We use this to not parse the\n * same field again (or differently).\n */\nexport class AncestorParse extends Split {\n    constructor(explicit = {}, implicit = {}, parseNothing = false) {\n        super(explicit, implicit);\n        this.explicit = explicit;\n        this.implicit = implicit;\n        this.parseNothing = parseNothing;\n    }\n    clone() {\n        const clone = super.clone();\n        clone.parseNothing = this.parseNothing;\n        return clone;\n    }\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}