{"ast":null,"code":"import _defineProperty from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { isArray, isNumber } from 'vega-util';\nimport { isBinned, isBinning, isBinParams } from '../../../bin';\nimport { getOffsetChannel, getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel, isPolarPositionChannel, isXorY } from '../../../channel';\nimport { getBandSize, isFieldDef, isFieldOrDatumDef, vgField } from '../../../channeldef';\nimport { getViewConfigDiscreteStep } from '../../../config';\nimport * as log from '../../../log';\nimport { isRelativeBandSize } from '../../../mark';\nimport { hasDiscreteDomain } from '../../../scale';\nimport { isSignalRef, isVgRangeStep } from '../../../vega.schema';\nimport { getMarkPropOrConfig, signalOrStringValue, signalOrValueRef } from '../../common';\nimport { nonPosition } from './nonposition';\nimport { positionOffset } from './offset';\nimport { vgAlignedPositionChannel } from './position-align';\nimport { pointPositionDefaultRef } from './position-point';\nimport { rangePosition } from './position-range';\nimport * as ref from './valueref';\nexport function rectPosition(model, channel) {\n  var _a, _b;\n  var config = model.config,\n    encoding = model.encoding,\n    markDef = model.markDef;\n  var mark = markDef.type;\n  var channel2 = getSecondaryRangeChannel(channel);\n  var sizeChannel = getSizeChannel(channel);\n  var channelDef = encoding[channel];\n  var channelDef2 = encoding[channel2];\n  var scale = model.getScaleComponent(channel);\n  var scaleType = scale ? scale.get('type') : undefined;\n  var orient = markDef.orient;\n  var hasSizeDef = (_b = (_a = encoding[sizeChannel]) !== null && _a !== void 0 ? _a : encoding.size) !== null && _b !== void 0 ? _b : getMarkPropOrConfig('size', markDef, config, {\n    vgChannel: sizeChannel\n  });\n  var isBarBand = mark === 'bar' && (channel === 'x' ? orient === 'vertical' : orient === 'horizontal');\n  // x, x2, and width -- we must specify two of these in all conditions\n  if (isFieldDef(channelDef) && (isBinning(channelDef.bin) || isBinned(channelDef.bin) || channelDef.timeUnit && !channelDef2) && !(hasSizeDef && !isRelativeBandSize(hasSizeDef)) && !hasDiscreteDomain(scaleType)) {\n    return rectBinPosition({\n      fieldDef: channelDef,\n      fieldDef2: channelDef2,\n      channel: channel,\n      model: model\n    });\n  } else if ((isFieldOrDatumDef(channelDef) && hasDiscreteDomain(scaleType) || isBarBand) && !channelDef2) {\n    return positionAndSize(channelDef, channel, model);\n  } else {\n    return rangePosition(channel, model, {\n      defaultPos: 'zeroOrMax',\n      defaultPos2: 'zeroOrMin'\n    });\n  }\n}\nfunction defaultSizeRef(sizeChannel, scaleName, scale, config, bandSize) {\n  if (isRelativeBandSize(bandSize)) {\n    if (scale) {\n      var scaleType = scale.get('type');\n      if (scaleType === 'band') {\n        var bandWidth = \"bandwidth('\".concat(scaleName, \"')\");\n        if (bandSize.band !== 1) {\n          bandWidth = \"\".concat(bandSize.band, \" * \").concat(bandWidth);\n        }\n        // TODO(#8351): make 0.25 here configurable\n        return {\n          signal: \"max(0.25, \".concat(bandWidth, \")\")\n        };\n      } else if (bandSize.band !== 1) {\n        log.warn(log.message.cannotUseRelativeBandSizeWithNonBandScale(scaleType));\n        bandSize = undefined;\n      }\n    } else {\n      return {\n        mult: bandSize.band,\n        field: {\n          group: sizeChannel\n        }\n      };\n    }\n  } else if (isSignalRef(bandSize)) {\n    return bandSize;\n  } else if (bandSize) {\n    return {\n      value: bandSize\n    };\n  }\n  // no valid band size\n  if (scale) {\n    var scaleRange = scale.get('range');\n    if (isVgRangeStep(scaleRange) && isNumber(scaleRange.step)) {\n      return {\n        value: scaleRange.step - 2\n      };\n    }\n  }\n  var defaultStep = getViewConfigDiscreteStep(config.view, sizeChannel);\n  return {\n    value: defaultStep - 2\n  };\n}\n/**\n * Output position encoding and its size encoding for continuous, point, and band scales.\n */\nfunction positionAndSize(fieldDef, channel, model) {\n  var markDef = model.markDef,\n    encoding = model.encoding,\n    config = model.config,\n    stack = model.stack;\n  var orient = markDef.orient;\n  var scaleName = model.scaleName(channel);\n  var scale = model.getScaleComponent(channel);\n  var vgSizeChannel = getSizeChannel(channel);\n  var channel2 = getSecondaryRangeChannel(channel);\n  var offsetScaleChannel = getOffsetChannel(channel);\n  var offsetScaleName = model.scaleName(offsetScaleChannel);\n  // use \"size\" channel for bars, if there is orient and the channel matches the right orientation\n  var useVlSizeChannel = orient === 'horizontal' && channel === 'y' || orient === 'vertical' && channel === 'x';\n  // Use size encoding / mark property / config if it exists\n  var sizeMixins;\n  if (encoding.size || markDef.size) {\n    if (useVlSizeChannel) {\n      sizeMixins = nonPosition('size', model, {\n        vgChannel: vgSizeChannel,\n        defaultRef: signalOrValueRef(markDef.size)\n      });\n    } else {\n      log.warn(log.message.cannotApplySizeToNonOrientedMark(markDef.type));\n    }\n  }\n  var hasSizeFromMarkOrEncoding = !!sizeMixins;\n  // Otherwise, apply default value\n  var bandSize = getBandSize({\n    channel: channel,\n    fieldDef: fieldDef,\n    markDef: markDef,\n    config: config,\n    scaleType: scale === null || scale === void 0 ? void 0 : scale.get('type'),\n    useVlSizeChannel: useVlSizeChannel\n  });\n  sizeMixins = sizeMixins || _defineProperty({}, vgSizeChannel, defaultSizeRef(vgSizeChannel, offsetScaleName || scaleName, scale, config, bandSize));\n  /*\n    Band scales with size value and all point scales, use xc/yc + band=0.5\n       Otherwise (band scales that has size based on a band ref), use x/y with position band = (1 - size_band) / 2.\n    In this case, size_band is the band specified in the x/y-encoding.\n    By default band is 1, so `(1 - band) / 2` = 0.\n    If band is 0.6, the the x/y position in such case should be `(1 - band) / 2` = 0.2\n   */\n  var defaultBandAlign = (scale === null || scale === void 0 ? void 0 : scale.get('type')) === 'band' && isRelativeBandSize(bandSize) && !hasSizeFromMarkOrEncoding ? 'top' : 'middle';\n  var vgChannel = vgAlignedPositionChannel(channel, markDef, config, defaultBandAlign);\n  var center = vgChannel === 'xc' || vgChannel === 'yc';\n  var _positionOffset = positionOffset({\n      channel: channel,\n      markDef: markDef,\n      encoding: encoding,\n      model: model,\n      bandPosition: center ? 0.5 : 0\n    }),\n    offset = _positionOffset.offset,\n    offsetType = _positionOffset.offsetType;\n  var posRef = ref.midPointRefWithPositionInvalidTest({\n    channel: channel,\n    channelDef: fieldDef,\n    markDef: markDef,\n    config: config,\n    scaleName: scaleName,\n    scale: scale,\n    stack: stack,\n    offset: offset,\n    defaultRef: pointPositionDefaultRef({\n      model: model,\n      defaultPos: 'mid',\n      channel: channel,\n      scaleName: scaleName,\n      scale: scale\n    }),\n    bandPosition: center ? offsetType === 'encoding' ? 0 : 0.5 : isSignalRef(bandSize) ? {\n      signal: \"(1-\".concat(bandSize, \")/2\")\n    } : isRelativeBandSize(bandSize) ? (1 - bandSize.band) / 2 : 0\n  });\n  if (vgSizeChannel) {\n    return Object.assign(_defineProperty({}, vgChannel, posRef), sizeMixins);\n  } else {\n    var _ref2;\n    // otherwise, we must simulate size by setting position2 = position + size\n    // (for theta/radius since Vega doesn't have thetaWidth/radiusWidth)\n    var vgChannel2 = getVgPositionChannel(channel2);\n    var sizeRef = sizeMixins[vgSizeChannel];\n    var sizeOffset = offset ? Object.assign(Object.assign({}, sizeRef), {\n      offset: offset\n    }) : sizeRef;\n    return _ref2 = {}, _defineProperty(_ref2, vgChannel, posRef), _defineProperty(_ref2, vgChannel2, isArray(posRef) ? [posRef[0], Object.assign(Object.assign({}, posRef[1]), {\n      offset: sizeOffset\n    })] : Object.assign(Object.assign({}, posRef), {\n      offset: sizeOffset\n    })), _ref2;\n  }\n}\nfunction getBinSpacing(channel, spacing, reverse, translate, offset) {\n  if (isPolarPositionChannel(channel)) {\n    return 0;\n  }\n  var spacingOffset = channel === 'x' || channel === 'y2' ? -spacing / 2 : spacing / 2;\n  if (isSignalRef(reverse) || isSignalRef(offset) || isSignalRef(translate)) {\n    var reverseExpr = signalOrStringValue(reverse);\n    var offsetExpr = signalOrStringValue(offset);\n    var translateExpr = signalOrStringValue(translate);\n    var t = translateExpr ? \"\".concat(translateExpr, \" + \") : '';\n    var r = reverseExpr ? \"(\".concat(reverseExpr, \" ? -1 : 1) * \") : '';\n    var o = offsetExpr ? \"(\".concat(offsetExpr, \" + \").concat(spacingOffset, \")\") : spacingOffset;\n    return {\n      signal: t + r + o\n    };\n  } else {\n    offset = offset || 0;\n    return translate + (reverse ? -offset - spacingOffset : +offset + spacingOffset);\n  }\n}\nfunction rectBinPosition(_ref3) {\n  var fieldDef = _ref3.fieldDef,\n    fieldDef2 = _ref3.fieldDef2,\n    channel = _ref3.channel,\n    model = _ref3.model;\n  var _a, _b, _c;\n  var config = model.config,\n    markDef = model.markDef,\n    encoding = model.encoding;\n  var scale = model.getScaleComponent(channel);\n  var scaleName = model.scaleName(channel);\n  var scaleType = scale ? scale.get('type') : undefined;\n  var reverse = scale.get('reverse');\n  var bandSize = getBandSize({\n    channel: channel,\n    fieldDef: fieldDef,\n    markDef: markDef,\n    config: config,\n    scaleType: scaleType\n  });\n  var axis = (_a = model.component.axes[channel]) === null || _a === void 0 ? void 0 : _a[0];\n  var axisTranslate = (_b = axis === null || axis === void 0 ? void 0 : axis.get('translate')) !== null && _b !== void 0 ? _b : 0.5; // vega default is 0.5\n  var spacing = isXorY(channel) ? (_c = getMarkPropOrConfig('binSpacing', markDef, config)) !== null && _c !== void 0 ? _c : 0 : 0;\n  var channel2 = getSecondaryRangeChannel(channel);\n  var vgChannel = getVgPositionChannel(channel);\n  var vgChannel2 = getVgPositionChannel(channel2);\n  var _positionOffset2 = positionOffset({\n      channel: channel,\n      markDef: markDef,\n      encoding: encoding,\n      model: model,\n      bandPosition: 0\n    }),\n    offset = _positionOffset2.offset;\n  var bandPosition = isSignalRef(bandSize) ? {\n    signal: \"(1-\".concat(bandSize.signal, \")/2\")\n  } : isRelativeBandSize(bandSize) ? (1 - bandSize.band) / 2 : 0.5;\n  if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {\n    var _ref4;\n    return _ref4 = {}, _defineProperty(_ref4, vgChannel2, rectBinRef({\n      fieldDef: fieldDef,\n      scaleName: scaleName,\n      bandPosition: bandPosition,\n      offset: getBinSpacing(channel2, spacing, reverse, axisTranslate, offset)\n    })), _defineProperty(_ref4, vgChannel, rectBinRef({\n      fieldDef: fieldDef,\n      scaleName: scaleName,\n      bandPosition: isSignalRef(bandPosition) ? {\n        signal: \"1-\".concat(bandPosition.signal)\n      } : 1 - bandPosition,\n      offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset)\n    })), _ref4;\n  } else if (isBinned(fieldDef.bin)) {\n    var startRef = ref.valueRefForFieldOrDatumDef(fieldDef, scaleName, {}, {\n      offset: getBinSpacing(channel2, spacing, reverse, axisTranslate, offset)\n    });\n    if (isFieldDef(fieldDef2)) {\n      var _ref5;\n      return _ref5 = {}, _defineProperty(_ref5, vgChannel2, startRef), _defineProperty(_ref5, vgChannel, ref.valueRefForFieldOrDatumDef(fieldDef2, scaleName, {}, {\n        offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset)\n      })), _ref5;\n    } else if (isBinParams(fieldDef.bin) && fieldDef.bin.step) {\n      var _ref6;\n      return _ref6 = {}, _defineProperty(_ref6, vgChannel2, startRef), _defineProperty(_ref6, vgChannel, {\n        signal: \"scale(\\\"\".concat(scaleName, \"\\\", \").concat(vgField(fieldDef, {\n          expr: 'datum'\n        }), \" + \").concat(fieldDef.bin.step, \")\"),\n        offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset)\n      }), _ref6;\n    }\n  }\n  log.warn(log.message.channelRequiredForBinned(channel2));\n  return undefined;\n}\n/**\n * Value Ref for binned fields\n */\nexport function rectBinRef(_ref7) {\n  var fieldDef = _ref7.fieldDef,\n    scaleName = _ref7.scaleName,\n    bandPosition = _ref7.bandPosition,\n    offset = _ref7.offset;\n  return ref.interpolatedSignalRef({\n    scaleName: scaleName,\n    fieldOrDatumDef: fieldDef,\n    bandPosition: bandPosition,\n    offset: offset\n  });\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/position-rect.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray, isNumber } from 'vega-util';\nimport { isBinned, isBinning, isBinParams } from '../../../bin';\nimport { getOffsetChannel, getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel, isPolarPositionChannel, isXorY } from '../../../channel';\nimport { getBandSize, isFieldDef, isFieldOrDatumDef, vgField } from '../../../channeldef';\nimport { getViewConfigDiscreteStep } from '../../../config';\nimport * as log from '../../../log';\nimport { isRelativeBandSize } from '../../../mark';\nimport { hasDiscreteDomain } from '../../../scale';\nimport { isSignalRef, isVgRangeStep } from '../../../vega.schema';\nimport { getMarkPropOrConfig, signalOrStringValue, signalOrValueRef } from '../../common';\nimport { nonPosition } from './nonposition';\nimport { positionOffset } from './offset';\nimport { vgAlignedPositionChannel } from './position-align';\nimport { pointPositionDefaultRef } from './position-point';\nimport { rangePosition } from './position-range';\nimport * as ref from './valueref';\nexport function rectPosition(model, channel) {\n    var _a, _b;\n    const { config, encoding, markDef } = model;\n    const mark = markDef.type;\n    const channel2 = getSecondaryRangeChannel(channel);\n    const sizeChannel = getSizeChannel(channel);\n    const channelDef = encoding[channel];\n    const channelDef2 = encoding[channel2];\n    const scale = model.getScaleComponent(channel);\n    const scaleType = scale ? scale.get('type') : undefined;\n    const orient = markDef.orient;\n    const hasSizeDef = (_b = (_a = encoding[sizeChannel]) !== null && _a !== void 0 ? _a : encoding.size) !== null && _b !== void 0 ? _b : getMarkPropOrConfig('size', markDef, config, { vgChannel: sizeChannel });\n    const isBarBand = mark === 'bar' && (channel === 'x' ? orient === 'vertical' : orient === 'horizontal');\n    // x, x2, and width -- we must specify two of these in all conditions\n    if (isFieldDef(channelDef) &&\n        (isBinning(channelDef.bin) || isBinned(channelDef.bin) || (channelDef.timeUnit && !channelDef2)) &&\n        !(hasSizeDef && !isRelativeBandSize(hasSizeDef)) &&\n        !hasDiscreteDomain(scaleType)) {\n        return rectBinPosition({\n            fieldDef: channelDef,\n            fieldDef2: channelDef2,\n            channel,\n            model\n        });\n    }\n    else if (((isFieldOrDatumDef(channelDef) && hasDiscreteDomain(scaleType)) || isBarBand) && !channelDef2) {\n        return positionAndSize(channelDef, channel, model);\n    }\n    else {\n        return rangePosition(channel, model, { defaultPos: 'zeroOrMax', defaultPos2: 'zeroOrMin' });\n    }\n}\nfunction defaultSizeRef(sizeChannel, scaleName, scale, config, bandSize) {\n    if (isRelativeBandSize(bandSize)) {\n        if (scale) {\n            const scaleType = scale.get('type');\n            if (scaleType === 'band') {\n                let bandWidth = `bandwidth('${scaleName}')`;\n                if (bandSize.band !== 1) {\n                    bandWidth = `${bandSize.band} * ${bandWidth}`;\n                }\n                // TODO(#8351): make 0.25 here configurable\n                return { signal: `max(0.25, ${bandWidth})` };\n            }\n            else if (bandSize.band !== 1) {\n                log.warn(log.message.cannotUseRelativeBandSizeWithNonBandScale(scaleType));\n                bandSize = undefined;\n            }\n        }\n        else {\n            return {\n                mult: bandSize.band,\n                field: { group: sizeChannel }\n            };\n        }\n    }\n    else if (isSignalRef(bandSize)) {\n        return bandSize;\n    }\n    else if (bandSize) {\n        return { value: bandSize };\n    }\n    // no valid band size\n    if (scale) {\n        const scaleRange = scale.get('range');\n        if (isVgRangeStep(scaleRange) && isNumber(scaleRange.step)) {\n            return { value: scaleRange.step - 2 };\n        }\n    }\n    const defaultStep = getViewConfigDiscreteStep(config.view, sizeChannel);\n    return { value: defaultStep - 2 };\n}\n/**\n * Output position encoding and its size encoding for continuous, point, and band scales.\n */\nfunction positionAndSize(fieldDef, channel, model) {\n    const { markDef, encoding, config, stack } = model;\n    const orient = markDef.orient;\n    const scaleName = model.scaleName(channel);\n    const scale = model.getScaleComponent(channel);\n    const vgSizeChannel = getSizeChannel(channel);\n    const channel2 = getSecondaryRangeChannel(channel);\n    const offsetScaleChannel = getOffsetChannel(channel);\n    const offsetScaleName = model.scaleName(offsetScaleChannel);\n    // use \"size\" channel for bars, if there is orient and the channel matches the right orientation\n    const useVlSizeChannel = (orient === 'horizontal' && channel === 'y') || (orient === 'vertical' && channel === 'x');\n    // Use size encoding / mark property / config if it exists\n    let sizeMixins;\n    if (encoding.size || markDef.size) {\n        if (useVlSizeChannel) {\n            sizeMixins = nonPosition('size', model, {\n                vgChannel: vgSizeChannel,\n                defaultRef: signalOrValueRef(markDef.size)\n            });\n        }\n        else {\n            log.warn(log.message.cannotApplySizeToNonOrientedMark(markDef.type));\n        }\n    }\n    const hasSizeFromMarkOrEncoding = !!sizeMixins;\n    // Otherwise, apply default value\n    const bandSize = getBandSize({ channel, fieldDef, markDef, config, scaleType: scale === null || scale === void 0 ? void 0 : scale.get('type'), useVlSizeChannel });\n    sizeMixins = sizeMixins || {\n        [vgSizeChannel]: defaultSizeRef(vgSizeChannel, offsetScaleName || scaleName, scale, config, bandSize)\n    };\n    /*\n      Band scales with size value and all point scales, use xc/yc + band=0.5\n  \n      Otherwise (band scales that has size based on a band ref), use x/y with position band = (1 - size_band) / 2.\n      In this case, size_band is the band specified in the x/y-encoding.\n      By default band is 1, so `(1 - band) / 2` = 0.\n      If band is 0.6, the the x/y position in such case should be `(1 - band) / 2` = 0.2\n     */\n    const defaultBandAlign = (scale === null || scale === void 0 ? void 0 : scale.get('type')) === 'band' && isRelativeBandSize(bandSize) && !hasSizeFromMarkOrEncoding ? 'top' : 'middle';\n    const vgChannel = vgAlignedPositionChannel(channel, markDef, config, defaultBandAlign);\n    const center = vgChannel === 'xc' || vgChannel === 'yc';\n    const { offset, offsetType } = positionOffset({ channel, markDef, encoding, model, bandPosition: center ? 0.5 : 0 });\n    const posRef = ref.midPointRefWithPositionInvalidTest({\n        channel,\n        channelDef: fieldDef,\n        markDef,\n        config,\n        scaleName,\n        scale,\n        stack,\n        offset,\n        defaultRef: pointPositionDefaultRef({ model, defaultPos: 'mid', channel, scaleName, scale }),\n        bandPosition: center\n            ? offsetType === 'encoding'\n                ? 0\n                : 0.5\n            : isSignalRef(bandSize)\n                ? { signal: `(1-${bandSize})/2` }\n                : isRelativeBandSize(bandSize)\n                    ? (1 - bandSize.band) / 2\n                    : 0\n    });\n    if (vgSizeChannel) {\n        return Object.assign({ [vgChannel]: posRef }, sizeMixins);\n    }\n    else {\n        // otherwise, we must simulate size by setting position2 = position + size\n        // (for theta/radius since Vega doesn't have thetaWidth/radiusWidth)\n        const vgChannel2 = getVgPositionChannel(channel2);\n        const sizeRef = sizeMixins[vgSizeChannel];\n        const sizeOffset = offset ? Object.assign(Object.assign({}, sizeRef), { offset }) : sizeRef;\n        return {\n            [vgChannel]: posRef,\n            // posRef might be an array that wraps position invalid test\n            [vgChannel2]: isArray(posRef)\n                ? [posRef[0], Object.assign(Object.assign({}, posRef[1]), { offset: sizeOffset })]\n                : Object.assign(Object.assign({}, posRef), { offset: sizeOffset })\n        };\n    }\n}\nfunction getBinSpacing(channel, spacing, reverse, translate, offset) {\n    if (isPolarPositionChannel(channel)) {\n        return 0;\n    }\n    const spacingOffset = channel === 'x' || channel === 'y2' ? -spacing / 2 : spacing / 2;\n    if (isSignalRef(reverse) || isSignalRef(offset) || isSignalRef(translate)) {\n        const reverseExpr = signalOrStringValue(reverse);\n        const offsetExpr = signalOrStringValue(offset);\n        const translateExpr = signalOrStringValue(translate);\n        const t = translateExpr ? `${translateExpr} + ` : '';\n        const r = reverseExpr ? `(${reverseExpr} ? -1 : 1) * ` : '';\n        const o = offsetExpr ? `(${offsetExpr} + ${spacingOffset})` : spacingOffset;\n        return {\n            signal: t + r + o\n        };\n    }\n    else {\n        offset = offset || 0;\n        return translate + (reverse ? -offset - spacingOffset : +offset + spacingOffset);\n    }\n}\nfunction rectBinPosition({ fieldDef, fieldDef2, channel, model }) {\n    var _a, _b, _c;\n    const { config, markDef, encoding } = model;\n    const scale = model.getScaleComponent(channel);\n    const scaleName = model.scaleName(channel);\n    const scaleType = scale ? scale.get('type') : undefined;\n    const reverse = scale.get('reverse');\n    const bandSize = getBandSize({ channel, fieldDef, markDef, config, scaleType });\n    const axis = (_a = model.component.axes[channel]) === null || _a === void 0 ? void 0 : _a[0];\n    const axisTranslate = (_b = axis === null || axis === void 0 ? void 0 : axis.get('translate')) !== null && _b !== void 0 ? _b : 0.5; // vega default is 0.5\n    const spacing = isXorY(channel) ? (_c = getMarkPropOrConfig('binSpacing', markDef, config)) !== null && _c !== void 0 ? _c : 0 : 0;\n    const channel2 = getSecondaryRangeChannel(channel);\n    const vgChannel = getVgPositionChannel(channel);\n    const vgChannel2 = getVgPositionChannel(channel2);\n    const { offset } = positionOffset({ channel, markDef, encoding, model, bandPosition: 0 });\n    const bandPosition = isSignalRef(bandSize)\n        ? { signal: `(1-${bandSize.signal})/2` }\n        : isRelativeBandSize(bandSize)\n            ? (1 - bandSize.band) / 2\n            : 0.5;\n    if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {\n        return {\n            [vgChannel2]: rectBinRef({\n                fieldDef,\n                scaleName,\n                bandPosition,\n                offset: getBinSpacing(channel2, spacing, reverse, axisTranslate, offset)\n            }),\n            [vgChannel]: rectBinRef({\n                fieldDef,\n                scaleName,\n                bandPosition: isSignalRef(bandPosition) ? { signal: `1-${bandPosition.signal}` } : 1 - bandPosition,\n                offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset)\n            })\n        };\n    }\n    else if (isBinned(fieldDef.bin)) {\n        const startRef = ref.valueRefForFieldOrDatumDef(fieldDef, scaleName, {}, { offset: getBinSpacing(channel2, spacing, reverse, axisTranslate, offset) });\n        if (isFieldDef(fieldDef2)) {\n            return {\n                [vgChannel2]: startRef,\n                [vgChannel]: ref.valueRefForFieldOrDatumDef(fieldDef2, scaleName, {}, { offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset) })\n            };\n        }\n        else if (isBinParams(fieldDef.bin) && fieldDef.bin.step) {\n            return {\n                [vgChannel2]: startRef,\n                [vgChannel]: {\n                    signal: `scale(\"${scaleName}\", ${vgField(fieldDef, { expr: 'datum' })} + ${fieldDef.bin.step})`,\n                    offset: getBinSpacing(channel, spacing, reverse, axisTranslate, offset)\n                }\n            };\n        }\n    }\n    log.warn(log.message.channelRequiredForBinned(channel2));\n    return undefined;\n}\n/**\n * Value Ref for binned fields\n */\nexport function rectBinRef({ fieldDef, scaleName, bandPosition, offset }) {\n    return ref.interpolatedSignalRef({\n        scaleName,\n        fieldOrDatumDef: fieldDef,\n        bandPosition,\n        offset\n    });\n}\n//# sourceMappingURL=position-rect.js.map"]},"metadata":{},"sourceType":"module"}