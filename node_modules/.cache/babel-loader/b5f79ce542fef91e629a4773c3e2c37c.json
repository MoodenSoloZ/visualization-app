{"ast":null,"code":"import { array, isArray, stringValue } from 'vega-util';\nimport { COLOR, OPACITY } from '../../channel';\nimport { hasConditionalValueDef, isFieldDef, isValueDef } from '../../channeldef';\nimport { FILL_STROKE_CONFIG } from '../../mark';\nimport { getFirstDefined, isEmpty, varName } from '../../util';\nimport { applyMarkConfig, signalOrValueRef } from '../common';\nimport { formatCustomType, isCustomFormatType } from '../format';\nimport * as mixins from '../mark/encode';\nimport { STORE } from '../selection';\nexport var legendEncodeRules = {\n  symbols: symbols,\n  gradient: gradient,\n  labels: labels,\n  entries: entries\n};\nexport function symbols(symbolsSpec, _ref) {\n  var fieldOrDatumDef = _ref.fieldOrDatumDef,\n    model = _ref.model,\n    channel = _ref.channel,\n    legendCmpt = _ref.legendCmpt,\n    legendType = _ref.legendType;\n  var _a, _b, _c, _d, _e, _f, _g, _h;\n  if (legendType !== 'symbol') {\n    return undefined;\n  }\n  var markDef = model.markDef,\n    encoding = model.encoding,\n    config = model.config,\n    mark = model.mark;\n  var filled = markDef.filled && mark !== 'trail';\n  var out = Object.assign(Object.assign({}, applyMarkConfig({}, model, FILL_STROKE_CONFIG)), mixins.color(model, {\n    filled: filled\n  })); // FIXME: remove this when VgEncodeEntry is compatible with SymbolEncodeEntry\n  var symbolOpacity = (_a = legendCmpt.get('symbolOpacity')) !== null && _a !== void 0 ? _a : config.legend.symbolOpacity;\n  var symbolFillColor = (_b = legendCmpt.get('symbolFillColor')) !== null && _b !== void 0 ? _b : config.legend.symbolFillColor;\n  var symbolStrokeColor = (_c = legendCmpt.get('symbolStrokeColor')) !== null && _c !== void 0 ? _c : config.legend.symbolStrokeColor;\n  var opacity = symbolOpacity === undefined ? (_d = getMaxValue(encoding.opacity)) !== null && _d !== void 0 ? _d : markDef.opacity : undefined;\n  if (out.fill) {\n    // for fill legend, we don't want any fill in symbol\n    if (channel === 'fill' || filled && channel === COLOR) {\n      delete out.fill;\n    } else {\n      if (out.fill['field']) {\n        // For others, set fill to some opaque value (or nothing if a color is already set)\n        if (symbolFillColor) {\n          delete out.fill;\n        } else {\n          out.fill = signalOrValueRef((_e = config.legend.symbolBaseFillColor) !== null && _e !== void 0 ? _e : 'black');\n          out.fillOpacity = signalOrValueRef(opacity !== null && opacity !== void 0 ? opacity : 1);\n        }\n      } else if (isArray(out.fill)) {\n        var fill = (_h = (_g = getFirstConditionValue((_f = encoding.fill) !== null && _f !== void 0 ? _f : encoding.color)) !== null && _g !== void 0 ? _g : markDef.fill) !== null && _h !== void 0 ? _h : filled && markDef.color;\n        if (fill) {\n          out.fill = signalOrValueRef(fill);\n        }\n      }\n    }\n  }\n  if (out.stroke) {\n    if (channel === 'stroke' || !filled && channel === COLOR) {\n      delete out.stroke;\n    } else {\n      if (out.stroke['field'] || symbolStrokeColor) {\n        // For others, remove stroke field\n        delete out.stroke;\n      } else if (isArray(out.stroke)) {\n        var stroke = getFirstDefined(getFirstConditionValue(encoding.stroke || encoding.color), markDef.stroke, filled ? markDef.color : undefined);\n        if (stroke) {\n          out.stroke = {\n            value: stroke\n          };\n        }\n      }\n    }\n  }\n  if (channel !== OPACITY) {\n    var condition = isFieldDef(fieldOrDatumDef) && selectedCondition(model, legendCmpt, fieldOrDatumDef);\n    if (condition) {\n      out.opacity = [Object.assign({\n        test: condition\n      }, signalOrValueRef(opacity !== null && opacity !== void 0 ? opacity : 1)), signalOrValueRef(config.legend.unselectedOpacity)];\n    } else if (opacity) {\n      out.opacity = signalOrValueRef(opacity);\n    }\n  }\n  out = Object.assign(Object.assign({}, out), symbolsSpec);\n  return isEmpty(out) ? undefined : out;\n}\nexport function gradient(gradientSpec, _ref2) {\n  var model = _ref2.model,\n    legendType = _ref2.legendType,\n    legendCmpt = _ref2.legendCmpt;\n  var _a;\n  if (legendType !== 'gradient') {\n    return undefined;\n  }\n  var config = model.config,\n    markDef = model.markDef,\n    encoding = model.encoding;\n  var out = {};\n  var gradientOpacity = (_a = legendCmpt.get('gradientOpacity')) !== null && _a !== void 0 ? _a : config.legend.gradientOpacity;\n  var opacity = gradientOpacity === undefined ? getMaxValue(encoding.opacity) || markDef.opacity : undefined;\n  if (opacity) {\n    // only apply opacity if it is neither zero or undefined\n    out.opacity = signalOrValueRef(opacity);\n  }\n  out = Object.assign(Object.assign({}, out), gradientSpec);\n  return isEmpty(out) ? undefined : out;\n}\nexport function labels(specifiedlabelsSpec, _ref3) {\n  var fieldOrDatumDef = _ref3.fieldOrDatumDef,\n    model = _ref3.model,\n    channel = _ref3.channel,\n    legendCmpt = _ref3.legendCmpt;\n  var legend = model.legend(channel) || {};\n  var config = model.config;\n  var condition = isFieldDef(fieldOrDatumDef) ? selectedCondition(model, legendCmpt, fieldOrDatumDef) : undefined;\n  var opacity = condition ? [{\n    test: condition,\n    value: 1\n  }, {\n    value: config.legend.unselectedOpacity\n  }] : undefined;\n  var format = legend.format,\n    formatType = legend.formatType;\n  var text = undefined;\n  if (isCustomFormatType(formatType)) {\n    text = formatCustomType({\n      fieldOrDatumDef: fieldOrDatumDef,\n      field: 'datum.value',\n      format: format,\n      formatType: formatType,\n      config: config\n    });\n  } else if (format === undefined && formatType === undefined && config.customFormatTypes) {\n    if (fieldOrDatumDef.type === 'quantitative' && config.numberFormatType) {\n      text = formatCustomType({\n        fieldOrDatumDef: fieldOrDatumDef,\n        field: 'datum.value',\n        format: config.numberFormat,\n        formatType: config.numberFormatType,\n        config: config\n      });\n    } else if (fieldOrDatumDef.type === 'temporal' && config.timeFormatType && isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit === undefined) {\n      text = formatCustomType({\n        fieldOrDatumDef: fieldOrDatumDef,\n        field: 'datum.value',\n        format: config.timeFormat,\n        formatType: config.timeFormatType,\n        config: config\n      });\n    }\n  }\n  var labelsSpec = Object.assign(Object.assign(Object.assign({}, opacity ? {\n    opacity: opacity\n  } : {}), text ? {\n    text: text\n  } : {}), specifiedlabelsSpec);\n  return isEmpty(labelsSpec) ? undefined : labelsSpec;\n}\nexport function entries(entriesSpec, _ref4) {\n  var legendCmpt = _ref4.legendCmpt;\n  var selections = legendCmpt.get('selections');\n  return (selections === null || selections === void 0 ? void 0 : selections.length) ? Object.assign(Object.assign({}, entriesSpec), {\n    fill: {\n      value: 'transparent'\n    }\n  }) : entriesSpec;\n}\nfunction getMaxValue(channelDef) {\n  return getConditionValue(channelDef, function (v, conditionalDef) {\n    return Math.max(v, conditionalDef.value);\n  });\n}\nexport function getFirstConditionValue(channelDef) {\n  return getConditionValue(channelDef, function (v, conditionalDef) {\n    return getFirstDefined(v, conditionalDef.value);\n  });\n}\nfunction getConditionValue(channelDef, reducer) {\n  if (hasConditionalValueDef(channelDef)) {\n    return array(channelDef.condition).reduce(reducer, channelDef.value);\n  } else if (isValueDef(channelDef)) {\n    return channelDef.value;\n  }\n  return undefined;\n}\nfunction selectedCondition(model, legendCmpt, fieldDef) {\n  var selections = legendCmpt.get('selections');\n  if (!(selections === null || selections === void 0 ? void 0 : selections.length)) return undefined;\n  var field = stringValue(fieldDef.field);\n  return selections.map(function (name) {\n    var store = stringValue(varName(name) + STORE);\n    return \"(!length(data(\".concat(store, \")) || (\").concat(name, \"[\").concat(field, \"] && indexof(\").concat(name, \"[\").concat(field, \"], datum.value) >= 0))\");\n  }).join(' || ');\n}","map":{"version":3,"sources":["../../../../src/compile/legend/encode.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { array, isArray, stringValue } from 'vega-util';\nimport { COLOR, OPACITY } from '../../channel';\nimport { hasConditionalValueDef, isFieldDef, isValueDef } from '../../channeldef';\nimport { FILL_STROKE_CONFIG } from '../../mark';\nimport { getFirstDefined, isEmpty, varName } from '../../util';\nimport { applyMarkConfig, signalOrValueRef } from '../common';\nimport { formatCustomType, isCustomFormatType } from '../format';\nimport * as mixins from '../mark/encode';\nimport { STORE } from '../selection';\nexport const legendEncodeRules = {\n    symbols,\n    gradient,\n    labels,\n    entries\n};\nexport function symbols(symbolsSpec, { fieldOrDatumDef, model, channel, legendCmpt, legendType }) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    if (legendType !== 'symbol') {\n        return undefined;\n    }\n    const { markDef, encoding, config, mark } = model;\n    const filled = markDef.filled && mark !== 'trail';\n    let out = Object.assign(Object.assign({}, applyMarkConfig({}, model, FILL_STROKE_CONFIG)), mixins.color(model, { filled })); // FIXME: remove this when VgEncodeEntry is compatible with SymbolEncodeEntry\n    const symbolOpacity = (_a = legendCmpt.get('symbolOpacity')) !== null && _a !== void 0 ? _a : config.legend.symbolOpacity;\n    const symbolFillColor = (_b = legendCmpt.get('symbolFillColor')) !== null && _b !== void 0 ? _b : config.legend.symbolFillColor;\n    const symbolStrokeColor = (_c = legendCmpt.get('symbolStrokeColor')) !== null && _c !== void 0 ? _c : config.legend.symbolStrokeColor;\n    const opacity = symbolOpacity === undefined ? (_d = getMaxValue(encoding.opacity)) !== null && _d !== void 0 ? _d : markDef.opacity : undefined;\n    if (out.fill) {\n        // for fill legend, we don't want any fill in symbol\n        if (channel === 'fill' || (filled && channel === COLOR)) {\n            delete out.fill;\n        }\n        else {\n            if (out.fill['field']) {\n                // For others, set fill to some opaque value (or nothing if a color is already set)\n                if (symbolFillColor) {\n                    delete out.fill;\n                }\n                else {\n                    out.fill = signalOrValueRef((_e = config.legend.symbolBaseFillColor) !== null && _e !== void 0 ? _e : 'black');\n                    out.fillOpacity = signalOrValueRef(opacity !== null && opacity !== void 0 ? opacity : 1);\n                }\n            }\n            else if (isArray(out.fill)) {\n                const fill = (_h = (_g = getFirstConditionValue((_f = encoding.fill) !== null && _f !== void 0 ? _f : encoding.color)) !== null && _g !== void 0 ? _g : markDef.fill) !== null && _h !== void 0 ? _h : (filled && markDef.color);\n                if (fill) {\n                    out.fill = signalOrValueRef(fill);\n                }\n            }\n        }\n    }\n    if (out.stroke) {\n        if (channel === 'stroke' || (!filled && channel === COLOR)) {\n            delete out.stroke;\n        }\n        else {\n            if (out.stroke['field'] || symbolStrokeColor) {\n                // For others, remove stroke field\n                delete out.stroke;\n            }\n            else if (isArray(out.stroke)) {\n                const stroke = getFirstDefined(getFirstConditionValue(encoding.stroke || encoding.color), markDef.stroke, filled ? markDef.color : undefined);\n                if (stroke) {\n                    out.stroke = { value: stroke };\n                }\n            }\n        }\n    }\n    if (channel !== OPACITY) {\n        const condition = isFieldDef(fieldOrDatumDef) && selectedCondition(model, legendCmpt, fieldOrDatumDef);\n        if (condition) {\n            out.opacity = [\n                Object.assign({ test: condition }, signalOrValueRef(opacity !== null && opacity !== void 0 ? opacity : 1)),\n                signalOrValueRef(config.legend.unselectedOpacity)\n            ];\n        }\n        else if (opacity) {\n            out.opacity = signalOrValueRef(opacity);\n        }\n    }\n    out = Object.assign(Object.assign({}, out), symbolsSpec);\n    return isEmpty(out) ? undefined : out;\n}\nexport function gradient(gradientSpec, { model, legendType, legendCmpt }) {\n    var _a;\n    if (legendType !== 'gradient') {\n        return undefined;\n    }\n    const { config, markDef, encoding } = model;\n    let out = {};\n    const gradientOpacity = (_a = legendCmpt.get('gradientOpacity')) !== null && _a !== void 0 ? _a : config.legend.gradientOpacity;\n    const opacity = gradientOpacity === undefined ? getMaxValue(encoding.opacity) || markDef.opacity : undefined;\n    if (opacity) {\n        // only apply opacity if it is neither zero or undefined\n        out.opacity = signalOrValueRef(opacity);\n    }\n    out = Object.assign(Object.assign({}, out), gradientSpec);\n    return isEmpty(out) ? undefined : out;\n}\nexport function labels(specifiedlabelsSpec, { fieldOrDatumDef, model, channel, legendCmpt }) {\n    const legend = model.legend(channel) || {};\n    const config = model.config;\n    const condition = isFieldDef(fieldOrDatumDef) ? selectedCondition(model, legendCmpt, fieldOrDatumDef) : undefined;\n    const opacity = condition ? [{ test: condition, value: 1 }, { value: config.legend.unselectedOpacity }] : undefined;\n    const { format, formatType } = legend;\n    let text = undefined;\n    if (isCustomFormatType(formatType)) {\n        text = formatCustomType({\n            fieldOrDatumDef,\n            field: 'datum.value',\n            format,\n            formatType,\n            config\n        });\n    }\n    else if (format === undefined && formatType === undefined && config.customFormatTypes) {\n        if (fieldOrDatumDef.type === 'quantitative' && config.numberFormatType) {\n            text = formatCustomType({\n                fieldOrDatumDef,\n                field: 'datum.value',\n                format: config.numberFormat,\n                formatType: config.numberFormatType,\n                config\n            });\n        }\n        else if (fieldOrDatumDef.type === 'temporal' &&\n            config.timeFormatType &&\n            isFieldDef(fieldOrDatumDef) &&\n            fieldOrDatumDef.timeUnit === undefined) {\n            text = formatCustomType({\n                fieldOrDatumDef,\n                field: 'datum.value',\n                format: config.timeFormat,\n                formatType: config.timeFormatType,\n                config\n            });\n        }\n    }\n    const labelsSpec = Object.assign(Object.assign(Object.assign({}, (opacity ? { opacity } : {})), (text ? { text } : {})), specifiedlabelsSpec);\n    return isEmpty(labelsSpec) ? undefined : labelsSpec;\n}\nexport function entries(entriesSpec, { legendCmpt }) {\n    const selections = legendCmpt.get('selections');\n    return (selections === null || selections === void 0 ? void 0 : selections.length) ? Object.assign(Object.assign({}, entriesSpec), { fill: { value: 'transparent' } }) : entriesSpec;\n}\nfunction getMaxValue(channelDef) {\n    return getConditionValue(channelDef, (v, conditionalDef) => Math.max(v, conditionalDef.value));\n}\nexport function getFirstConditionValue(channelDef) {\n    return getConditionValue(channelDef, (v, conditionalDef) => {\n        return getFirstDefined(v, conditionalDef.value);\n    });\n}\nfunction getConditionValue(channelDef, reducer) {\n    if (hasConditionalValueDef(channelDef)) {\n        return array(channelDef.condition).reduce(reducer, channelDef.value);\n    }\n    else if (isValueDef(channelDef)) {\n        return channelDef.value;\n    }\n    return undefined;\n}\nfunction selectedCondition(model, legendCmpt, fieldDef) {\n    const selections = legendCmpt.get('selections');\n    if (!(selections === null || selections === void 0 ? void 0 : selections.length))\n        return undefined;\n    const field = stringValue(fieldDef.field);\n    return selections\n        .map(name => {\n        const store = stringValue(varName(name) + STORE);\n        return `(!length(data(${store})) || (${name}[${field}] && indexof(${name}[${field}], datum.value) >= 0))`;\n    })\n        .join(' || ');\n}\n//# sourceMappingURL=encode.js.map"]},"metadata":{},"sourceType":"module"}