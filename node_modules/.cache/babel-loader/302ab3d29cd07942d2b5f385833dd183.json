{"ast":null,"code":"import { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { wrapCondition } from './conditional';\nimport * as ref from './valueref';\n/**\n * Return encode for non-positional channels with scales. (Text doesn't have scale.)\n */\nexport function nonPosition(channel, model) {\n  var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var markDef = model.markDef,\n    encoding = model.encoding,\n    config = model.config;\n  var vgChannel = opt.vgChannel;\n  var defaultRef = opt.defaultRef,\n    defaultValue = opt.defaultValue;\n  if (defaultRef === undefined) {\n    // prettier-ignore\n    defaultValue !== null && defaultValue !== void 0 ? defaultValue : defaultValue = getMarkPropOrConfig(channel, markDef, config, {\n      vgChannel: vgChannel,\n      ignoreVgConfig: true\n    });\n    if (defaultValue !== undefined) {\n      defaultRef = signalOrValueRef(defaultValue);\n    }\n  }\n  var channelDef = encoding[channel];\n  return wrapCondition(model, channelDef, vgChannel !== null && vgChannel !== void 0 ? vgChannel : channel, function (cDef) {\n    return ref.midPoint({\n      channel: channel,\n      channelDef: cDef,\n      markDef: markDef,\n      config: config,\n      scaleName: model.scaleName(channel),\n      scale: model.getScaleComponent(channel),\n      stack: null,\n      defaultRef: defaultRef\n    });\n  });\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/nonposition.ts"],"names":[],"mappings":"AAIA,SAAQ,mBAAmB,EAAE,gBAAgB,QAAO,cAAc;AAElE,SAAQ,aAAa,QAAO,eAAe;AAC3C,OAAO,KAAK,GAAG,MAAM,YAAY;AAEjC;;AAEG;AACH,OAAM,SAAU,WAAW,CACzB,OAAgC,EAChC,KAAgB,EAKV;EAAA,IAJN,GAAA,uEAII,CAAA,CAAE;EAEN,IAAO,OAAO,GAAsB,KAAK,CAAlC,OAAO;IAAE,QAAQ,GAAY,KAAK,CAAzB,QAAQ;IAAE,MAAM,GAAI,KAAK,CAAf,MAAM;EAChC,IAAO,SAAS,GAAI,GAAG,CAAhB,SAAS;EAChB,IAAK,UAAU,GAAkB,GAAG,CAA/B,UAAU;IAAE,YAAY,GAAI,GAAG,CAAnB,YAAY;EAE7B,IAAI,UAAU,KAAK,SAAS,EAAE;IAC5B;IACA,YAAY,KAAA,IAAA,IAAZ,YAAY,KAAA,KAAA,CAAA,GAAZ,YAAY,GAAZ,YAAY,GAAK,mBAAmB,CAAC,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE;MAAC,SAAS,EAAT,SAAS;MAAE,cAAc,EAAE;IAAI,CAAC,CAAC;IAEjG,IAAI,YAAY,KAAK,SAAS,EAAE;MAC9B,UAAU,GAAG,gBAAgB,CAAC,YAAY,CAAC;IAC5C;EACF;EAED,IAAM,UAAU,GAAG,QAAQ,CAAC,OAAO,CAAC;EAEpC,OAAO,aAAa,CAAC,KAAK,EAAE,UAAU,EAAE,SAAS,KAAA,IAAA,IAAT,SAAS,KAAA,KAAA,CAAA,GAAT,SAAS,GAAI,OAAO,EAAE,UAAA,IAAI,EAAG;IACnE,OAAO,GAAG,CAAC,QAAQ,CAAC;MAClB,OAAO,EAAP,OAAO;MACP,UAAU,EAAE,IAAI;MAChB,OAAO,EAAP,OAAO;MACP,MAAM,EAAN,MAAM;MACN,SAAS,EAAE,KAAK,CAAC,SAAS,CAAC,OAAO,CAAC;MACnC,KAAK,EAAE,KAAK,CAAC,iBAAiB,CAAC,OAAO,CAAC;MACvC,KAAK,EAAE,IAAI;MACX,UAAU,EAAV;KACD,CAAC;EACJ,CAAC,CAAC;AACJ","sourceRoot":"","sourcesContent":["import { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { wrapCondition } from './conditional';\nimport * as ref from './valueref';\n/**\n * Return encode for non-positional channels with scales. (Text doesn't have scale.)\n */\nexport function nonPosition(channel, model, opt = {}) {\n    const { markDef, encoding, config } = model;\n    const { vgChannel } = opt;\n    let { defaultRef, defaultValue } = opt;\n    if (defaultRef === undefined) {\n        // prettier-ignore\n        defaultValue !== null && defaultValue !== void 0 ? defaultValue : (defaultValue = getMarkPropOrConfig(channel, markDef, config, { vgChannel, ignoreVgConfig: true }));\n        if (defaultValue !== undefined) {\n            defaultRef = signalOrValueRef(defaultValue);\n        }\n    }\n    const channelDef = encoding[channel];\n    return wrapCondition(model, channelDef, vgChannel !== null && vgChannel !== void 0 ? vgChannel : channel, cDef => {\n        return ref.midPoint({\n            channel,\n            channelDef: cDef,\n            markDef,\n            config,\n            scaleName: model.scaleName(channel),\n            scale: model.getScaleComponent(channel),\n            stack: null,\n            defaultRef\n        });\n    });\n}\n//# sourceMappingURL=nonposition.js.map"]},"metadata":{},"sourceType":"module"}