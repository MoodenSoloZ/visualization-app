{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport * as log from '../../log';\nimport * as optimizers from './optimizers';\nimport { moveFacetDown } from './subtree';\nexport var FACET_SCALE_PREFIX = 'scale_';\nexport var MAX_OPTIMIZATION_RUNS = 5;\n/**\n * Iterates over a dataflow graph and checks whether all links are consistent.\n */\nexport function checkLinks(nodes) {\n  var _iterator = _createForOfIteratorHelper(nodes),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var node = _step.value;\n      var _iterator2 = _createForOfIteratorHelper(node.children),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var child = _step2.value;\n          if (child.parent !== node) {\n            // log.error('Dataflow graph is inconsistent.', node, child);\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      if (!checkLinks(node.children)) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return true;\n}\n/**\n * Run the specified optimizer on the provided nodes.\n *\n * @param optimizer The optimizer instance to run.\n * @param nodes A set of nodes to optimize.\n */\nfunction runOptimizer(optimizer, nodes) {\n  var modified = false;\n  var _iterator3 = _createForOfIteratorHelper(nodes),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var node = _step3.value;\n      modified = optimizer.optimize(node) || modified;\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return modified;\n}\nfunction optimizationDataflowHelper(dataComponent, model, firstPass) {\n  var roots = dataComponent.sources;\n  var modified = false;\n  modified = runOptimizer(new optimizers.RemoveUnnecessaryOutputNodes(), roots) || modified;\n  modified = runOptimizer(new optimizers.RemoveUnnecessaryIdentifierNodes(model), roots) || modified;\n  // remove source nodes that don't have any children because they also don't have output nodes\n  roots = roots.filter(function (r) {\n    return r.numChildren() > 0;\n  });\n  modified = runOptimizer(new optimizers.RemoveUnusedSubtrees(), roots) || modified;\n  roots = roots.filter(function (r) {\n    return r.numChildren() > 0;\n  });\n  if (!firstPass) {\n    // Only run these optimizations after the optimizer has moved down the facet node.\n    // With this change, we can be more aggressive in the optimizations.\n    modified = runOptimizer(new optimizers.MoveParseUp(), roots) || modified;\n    modified = runOptimizer(new optimizers.MergeBins(model), roots) || modified;\n    modified = runOptimizer(new optimizers.RemoveDuplicateTimeUnits(), roots) || modified;\n    modified = runOptimizer(new optimizers.MergeParse(), roots) || modified;\n    modified = runOptimizer(new optimizers.MergeAggregates(), roots) || modified;\n    modified = runOptimizer(new optimizers.MergeTimeUnits(), roots) || modified;\n    modified = runOptimizer(new optimizers.MergeIdenticalNodes(), roots) || modified;\n    modified = runOptimizer(new optimizers.MergeOutputs(), roots) || modified;\n  }\n  dataComponent.sources = roots;\n  return modified;\n}\n/**\n * Optimizes the dataflow of the passed in data component.\n */\nexport function optimizeDataflow(data, model) {\n  // check before optimizations\n  checkLinks(data.sources);\n  var firstPassCounter = 0;\n  var secondPassCounter = 0;\n  for (var i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {\n    if (!optimizationDataflowHelper(data, model, true)) {\n      break;\n    }\n    firstPassCounter++;\n  }\n  // move facets down and make a copy of the subtree so that we can have scales at the top level\n  data.sources.map(moveFacetDown);\n  for (var _i = 0; _i < MAX_OPTIMIZATION_RUNS; _i++) {\n    if (!optimizationDataflowHelper(data, model, false)) {\n      break;\n    }\n    secondPassCounter++;\n  }\n  // check after optimizations\n  checkLinks(data.sources);\n  if (Math.max(firstPassCounter, secondPassCounter) === MAX_OPTIMIZATION_RUNS) {\n    log.warn(\"Maximum optimization runs(\".concat(MAX_OPTIMIZATION_RUNS, \") reached.\"));\n  }\n}","map":{"version":3,"sources":["../../../../src/compile/data/optimize.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as log from '../../log';\nimport * as optimizers from './optimizers';\nimport { moveFacetDown } from './subtree';\nexport const FACET_SCALE_PREFIX = 'scale_';\nexport const MAX_OPTIMIZATION_RUNS = 5;\n/**\n * Iterates over a dataflow graph and checks whether all links are consistent.\n */\nexport function checkLinks(nodes) {\n    for (const node of nodes) {\n        for (const child of node.children) {\n            if (child.parent !== node) {\n                // log.error('Dataflow graph is inconsistent.', node, child);\n                return false;\n            }\n        }\n        if (!checkLinks(node.children)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Run the specified optimizer on the provided nodes.\n *\n * @param optimizer The optimizer instance to run.\n * @param nodes A set of nodes to optimize.\n */\nfunction runOptimizer(optimizer, nodes) {\n    let modified = false;\n    for (const node of nodes) {\n        modified = optimizer.optimize(node) || modified;\n    }\n    return modified;\n}\nfunction optimizationDataflowHelper(dataComponent, model, firstPass) {\n    let roots = dataComponent.sources;\n    let modified = false;\n    modified = runOptimizer(new optimizers.RemoveUnnecessaryOutputNodes(), roots) || modified;\n    modified = runOptimizer(new optimizers.RemoveUnnecessaryIdentifierNodes(model), roots) || modified;\n    // remove source nodes that don't have any children because they also don't have output nodes\n    roots = roots.filter(r => r.numChildren() > 0);\n    modified = runOptimizer(new optimizers.RemoveUnusedSubtrees(), roots) || modified;\n    roots = roots.filter(r => r.numChildren() > 0);\n    if (!firstPass) {\n        // Only run these optimizations after the optimizer has moved down the facet node.\n        // With this change, we can be more aggressive in the optimizations.\n        modified = runOptimizer(new optimizers.MoveParseUp(), roots) || modified;\n        modified = runOptimizer(new optimizers.MergeBins(model), roots) || modified;\n        modified = runOptimizer(new optimizers.RemoveDuplicateTimeUnits(), roots) || modified;\n        modified = runOptimizer(new optimizers.MergeParse(), roots) || modified;\n        modified = runOptimizer(new optimizers.MergeAggregates(), roots) || modified;\n        modified = runOptimizer(new optimizers.MergeTimeUnits(), roots) || modified;\n        modified = runOptimizer(new optimizers.MergeIdenticalNodes(), roots) || modified;\n        modified = runOptimizer(new optimizers.MergeOutputs(), roots) || modified;\n    }\n    dataComponent.sources = roots;\n    return modified;\n}\n/**\n * Optimizes the dataflow of the passed in data component.\n */\nexport function optimizeDataflow(data, model) {\n    // check before optimizations\n    checkLinks(data.sources);\n    let firstPassCounter = 0;\n    let secondPassCounter = 0;\n    for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {\n        if (!optimizationDataflowHelper(data, model, true)) {\n            break;\n        }\n        firstPassCounter++;\n    }\n    // move facets down and make a copy of the subtree so that we can have scales at the top level\n    data.sources.map(moveFacetDown);\n    for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {\n        if (!optimizationDataflowHelper(data, model, false)) {\n            break;\n        }\n        secondPassCounter++;\n    }\n    // check after optimizations\n    checkLinks(data.sources);\n    if (Math.max(firstPassCounter, secondPassCounter) === MAX_OPTIMIZATION_RUNS) {\n        log.warn(`Maximum optimization runs(${MAX_OPTIMIZATION_RUNS}) reached.`);\n    }\n}\n//# sourceMappingURL=optimize.js.map"]},"metadata":{},"sourceType":"module"}