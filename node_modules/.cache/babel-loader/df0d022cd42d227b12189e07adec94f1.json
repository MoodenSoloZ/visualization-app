{"ast":null,"code":"import { permute, bisectLeft, bisectRight } from 'd3-array';\nimport { Transform } from 'vega-dataflow';\nimport { inherits } from 'vega-util';\nvar array8 = function array8(n) {\n  return new Uint8Array(n);\n};\nvar array16 = function array16(n) {\n  return new Uint16Array(n);\n};\nvar array32 = function array32(n) {\n  return new Uint32Array(n);\n};\n\n/**\n * Maintains CrossFilter state.\n */\n\nfunction Bitmaps() {\n  var width = 8,\n    _data = [],\n    _seen = array32(0),\n    _curr = array(0, width),\n    _prev = array(0, width);\n  return {\n    data: function data() {\n      return _data;\n    },\n    seen: function seen() {\n      return _seen = lengthen(_seen, _data.length);\n    },\n    add: function add(array) {\n      for (var i = 0, j = _data.length, n = array.length, t; i < n; ++i) {\n        t = array[i];\n        t._index = j++;\n        _data.push(t);\n      }\n    },\n    remove: function remove(num, map) {\n      // map: index -> boolean (true => remove)\n      var n = _data.length,\n        copy = Array(n - num),\n        reindex = _data; // reuse old data array for index map\n\n      var t, i, j; // seek forward to first removal\n\n      for (i = 0; !map[i] && i < n; ++i) {\n        copy[i] = _data[i];\n        reindex[i] = i;\n      } // condense arrays\n\n      for (j = i; i < n; ++i) {\n        t = _data[i];\n        if (!map[i]) {\n          reindex[i] = j;\n          _curr[j] = _curr[i];\n          _prev[j] = _prev[i];\n          copy[j] = t;\n          t._index = j++;\n        } else {\n          reindex[i] = -1;\n        }\n        _curr[i] = 0; // clear unused bits\n      }\n\n      _data = copy;\n      return reindex;\n    },\n    size: function size() {\n      return _data.length;\n    },\n    curr: function curr() {\n      return _curr;\n    },\n    prev: function prev() {\n      return _prev;\n    },\n    reset: function reset(k) {\n      return _prev[k] = _curr[k];\n    },\n    all: function all() {\n      return width < 0x101 ? 0xff : width < 0x10001 ? 0xffff : 0xffffffff;\n    },\n    set: function set(k, one) {\n      _curr[k] |= one;\n    },\n    clear: function clear(k, one) {\n      _curr[k] &= ~one;\n    },\n    resize: function resize(n, m) {\n      var k = _curr.length;\n      if (n > k || m > width) {\n        width = Math.max(m, width);\n        _curr = array(n, width, _curr);\n        _prev = array(n, width);\n      }\n    }\n  };\n}\nfunction lengthen(array, length, copy) {\n  if (array.length >= length) return array;\n  copy = copy || new array.constructor(length);\n  copy.set(array);\n  return copy;\n}\nfunction array(n, m, array) {\n  var copy = (m < 0x101 ? array8 : m < 0x10001 ? array16 : array32)(n);\n  if (array) copy.set(array);\n  return copy;\n}\nfunction Dimension(index, i, query) {\n  var bit = 1 << i;\n  return {\n    one: bit,\n    zero: ~bit,\n    range: query.slice(),\n    bisect: index.bisect,\n    index: index.index,\n    size: index.size,\n    onAdd: function onAdd(added, curr) {\n      var dim = this,\n        range = dim.bisect(dim.range, added.value),\n        idx = added.index,\n        lo = range[0],\n        hi = range[1],\n        n1 = idx.length;\n      var i;\n      for (i = 0; i < lo; ++i) {\n        curr[idx[i]] |= bit;\n      }\n      for (i = hi; i < n1; ++i) {\n        curr[idx[i]] |= bit;\n      }\n      return dim;\n    }\n  };\n}\n\n/**\n * Maintains a list of values, sorted by key.\n */\n\nfunction SortedIndex() {\n  var _index = array32(0),\n    value = [],\n    _size = 0;\n  function insert(key, data, base) {\n    if (!data.length) return [];\n    var n0 = _size,\n      n1 = data.length,\n      addi = array32(n1);\n    var addv = Array(n1),\n      oldv,\n      oldi,\n      i;\n    for (i = 0; i < n1; ++i) {\n      addv[i] = key(data[i]);\n      addi[i] = i;\n    }\n    addv = sort(addv, addi);\n    if (n0) {\n      oldv = value;\n      oldi = _index;\n      value = Array(n0 + n1);\n      _index = array32(n0 + n1);\n      merge(base, oldv, oldi, n0, addv, addi, n1, value, _index);\n    } else {\n      if (base > 0) for (i = 0; i < n1; ++i) {\n        addi[i] += base;\n      }\n      value = addv;\n      _index = addi;\n    }\n    _size = n0 + n1;\n    return {\n      index: addi,\n      value: addv\n    };\n  }\n  function remove(num, map) {\n    // map: index -> remove\n    var n = _size;\n    var idx, i, j; // seek forward to first removal\n\n    for (i = 0; !map[_index[i]] && i < n; ++i) {\n      ;\n    } // condense index and value arrays\n\n    for (j = i; i < n; ++i) {\n      if (!map[idx = _index[i]]) {\n        _index[j] = idx;\n        value[j] = value[i];\n        ++j;\n      }\n    }\n    _size = n - num;\n  }\n  function reindex(map) {\n    for (var i = 0, n = _size; i < n; ++i) {\n      _index[i] = map[_index[i]];\n    }\n  }\n  function bisect(range, array) {\n    var n;\n    if (array) {\n      n = array.length;\n    } else {\n      array = value;\n      n = _size;\n    }\n    return [bisectLeft(array, range[0], 0, n), bisectRight(array, range[1], 0, n)];\n  }\n  return {\n    insert: insert,\n    remove: remove,\n    bisect: bisect,\n    reindex: reindex,\n    index: function index() {\n      return _index;\n    },\n    size: function size() {\n      return _size;\n    }\n  };\n}\nfunction sort(values, index) {\n  values.sort.call(index, function (a, b) {\n    var x = values[a],\n      y = values[b];\n    return x < y ? -1 : x > y ? 1 : 0;\n  });\n  return permute(values, index);\n}\nfunction merge(base, value0, index0, n0, value1, index1, n1, value, index) {\n  var i0 = 0,\n    i1 = 0,\n    i;\n  for (i = 0; i0 < n0 && i1 < n1; ++i) {\n    if (value0[i0] < value1[i1]) {\n      value[i] = value0[i0];\n      index[i] = index0[i0++];\n    } else {\n      value[i] = value1[i1];\n      index[i] = index1[i1++] + base;\n    }\n  }\n  for (; i0 < n0; ++i0, ++i) {\n    value[i] = value0[i0];\n    index[i] = index0[i0];\n  }\n  for (; i1 < n1; ++i1, ++i) {\n    value[i] = value1[i1];\n    index[i] = index1[i1] + base;\n  }\n}\n\n/**\n * An indexed multi-dimensional filter.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.fields - An array of dimension accessors to filter.\n * @param {Array} params.query - An array of per-dimension range queries.\n */\n\nfunction CrossFilter(params) {\n  Transform.call(this, Bitmaps(), params);\n  this._indices = null;\n  this._dims = null;\n}\nCrossFilter.Definition = {\n  'type': 'CrossFilter',\n  'metadata': {},\n  'params': [{\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'required': true\n  }, {\n    'name': 'query',\n    'type': 'array',\n    'array': true,\n    'required': true,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }]\n};\ninherits(CrossFilter, Transform, {\n  transform: function transform(_, pulse) {\n    if (!this._dims) {\n      return this.init(_, pulse);\n    } else {\n      var init = _.modified('fields') || _.fields.some(function (f) {\n        return pulse.modified(f.fields);\n      });\n      return init ? this.reinit(_, pulse) : this.eval(_, pulse);\n    }\n  },\n  init: function init(_, pulse) {\n    var fields = _.fields,\n      query = _.query,\n      indices = this._indices = {},\n      dims = this._dims = [],\n      m = query.length;\n    var i = 0,\n      key,\n      index; // instantiate indices and dimensions\n\n    for (; i < m; ++i) {\n      key = fields[i].fname;\n      index = indices[key] || (indices[key] = SortedIndex());\n      dims.push(Dimension(index, i, query[i]));\n    }\n    return this.eval(_, pulse);\n  },\n  reinit: function reinit(_, pulse) {\n    var output = pulse.materialize().fork(),\n      fields = _.fields,\n      query = _.query,\n      indices = this._indices,\n      dims = this._dims,\n      bits = this.value,\n      curr = bits.curr(),\n      prev = bits.prev(),\n      all = bits.all(),\n      out = output.rem = output.add,\n      mod = output.mod,\n      m = query.length,\n      adds = {};\n    var add, index, key, mods, remMap, modMap, i, n, f; // set prev to current state\n\n    prev.set(curr); // if pulse has remove tuples, process them first\n\n    if (pulse.rem.length) {\n      remMap = this.remove(_, pulse, output);\n    } // if pulse has added tuples, add them to state\n\n    if (pulse.add.length) {\n      bits.add(pulse.add);\n    } // if pulse has modified tuples, create an index map\n\n    if (pulse.mod.length) {\n      modMap = {};\n      for (mods = pulse.mod, i = 0, n = mods.length; i < n; ++i) {\n        modMap[mods[i]._index] = 1;\n      }\n    } // re-initialize indices as needed, update curr bitmap\n\n    for (i = 0; i < m; ++i) {\n      f = fields[i];\n      if (!dims[i] || _.modified('fields', i) || pulse.modified(f.fields)) {\n        key = f.fname;\n        if (!(add = adds[key])) {\n          indices[key] = index = SortedIndex();\n          adds[key] = add = index.insert(f, pulse.source, 0);\n        }\n        dims[i] = Dimension(index, i, query[i]).onAdd(add, curr);\n      }\n    } // visit each tuple\n    // if filter state changed, push index to add/rem\n    // else if in mod and passes a filter, push index to mod\n\n    for (i = 0, n = bits.data().length; i < n; ++i) {\n      if (remMap[i]) {\n        // skip if removed tuple\n        continue;\n      } else if (prev[i] !== curr[i]) {\n        // add if state changed\n        out.push(i);\n      } else if (modMap[i] && curr[i] !== all) {\n        // otherwise, pass mods through\n        mod.push(i);\n      }\n    }\n    bits.mask = (1 << m) - 1;\n    return output;\n  },\n  eval: function _eval(_, pulse) {\n    var output = pulse.materialize().fork(),\n      m = this._dims.length;\n    var mask = 0;\n    if (pulse.rem.length) {\n      this.remove(_, pulse, output);\n      mask |= (1 << m) - 1;\n    }\n    if (_.modified('query') && !_.modified('fields')) {\n      mask |= this.update(_, pulse, output);\n    }\n    if (pulse.add.length) {\n      this.insert(_, pulse, output);\n      mask |= (1 << m) - 1;\n    }\n    if (pulse.mod.length) {\n      this.modify(pulse, output);\n      mask |= (1 << m) - 1;\n    }\n    this.value.mask = mask;\n    return output;\n  },\n  insert: function insert(_, pulse, output) {\n    var tuples = pulse.add,\n      bits = this.value,\n      dims = this._dims,\n      indices = this._indices,\n      fields = _.fields,\n      adds = {},\n      out = output.add,\n      n = bits.size() + tuples.length,\n      m = dims.length;\n    var k = bits.size(),\n      j,\n      key,\n      add; // resize bitmaps and add tuples as needed\n\n    bits.resize(n, m);\n    bits.add(tuples);\n    var curr = bits.curr(),\n      prev = bits.prev(),\n      all = bits.all(); // add to dimensional indices\n\n    for (j = 0; j < m; ++j) {\n      key = fields[j].fname;\n      add = adds[key] || (adds[key] = indices[key].insert(fields[j], tuples, k));\n      dims[j].onAdd(add, curr);\n    } // set previous filters, output if passes at least one filter\n\n    for (; k < n; ++k) {\n      prev[k] = all;\n      if (curr[k] !== all) out.push(k);\n    }\n  },\n  modify: function modify(pulse, output) {\n    var out = output.mod,\n      bits = this.value,\n      curr = bits.curr(),\n      all = bits.all(),\n      tuples = pulse.mod;\n    var i, n, k;\n    for (i = 0, n = tuples.length; i < n; ++i) {\n      k = tuples[i]._index;\n      if (curr[k] !== all) out.push(k);\n    }\n  },\n  remove: function remove(_, pulse, output) {\n    var indices = this._indices,\n      bits = this.value,\n      curr = bits.curr(),\n      prev = bits.prev(),\n      all = bits.all(),\n      map = {},\n      out = output.rem,\n      tuples = pulse.rem;\n    var i, n, k, f; // process tuples, output if passes at least one filter\n\n    for (i = 0, n = tuples.length; i < n; ++i) {\n      k = tuples[i]._index;\n      map[k] = 1; // build index map\n\n      prev[k] = f = curr[k];\n      curr[k] = all;\n      if (f !== all) out.push(k);\n    } // remove from dimensional indices\n\n    for (k in indices) {\n      indices[k].remove(n, map);\n    }\n    this.reindex(pulse, n, map);\n    return map;\n  },\n  // reindex filters and indices after propagation completes\n  reindex: function reindex(pulse, num, map) {\n    var indices = this._indices,\n      bits = this.value;\n    pulse.runAfter(function () {\n      var indexMap = bits.remove(num, map);\n      for (var key in indices) {\n        indices[key].reindex(indexMap);\n      }\n    });\n  },\n  update: function update(_, pulse, output) {\n    var dims = this._dims,\n      query = _.query,\n      stamp = pulse.stamp,\n      m = dims.length;\n    var mask = 0,\n      i,\n      q; // survey how many queries have changed\n\n    output.filters = 0;\n    for (q = 0; q < m; ++q) {\n      if (_.modified('query', q)) {\n        i = q;\n        ++mask;\n      }\n    }\n    if (mask === 1) {\n      // only one query changed, use more efficient update\n      mask = dims[i].one;\n      this.incrementOne(dims[i], query[i], output.add, output.rem);\n    } else {\n      // multiple queries changed, perform full record keeping\n      for (q = 0, mask = 0; q < m; ++q) {\n        if (!_.modified('query', q)) continue;\n        mask |= dims[q].one;\n        this.incrementAll(dims[q], query[q], stamp, output.add);\n        output.rem = output.add; // duplicate add/rem for downstream resolve\n      }\n    }\n\n    return mask;\n  },\n  incrementAll: function incrementAll(dim, query, stamp, out) {\n    var bits = this.value,\n      seen = bits.seen(),\n      curr = bits.curr(),\n      prev = bits.prev(),\n      index = dim.index(),\n      old = dim.bisect(dim.range),\n      range = dim.bisect(query),\n      lo1 = range[0],\n      hi1 = range[1],\n      lo0 = old[0],\n      hi0 = old[1],\n      one = dim.one;\n    var i, j, k; // Fast incremental update based on previous lo index.\n\n    if (lo1 < lo0) {\n      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n        k = index[i];\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n        curr[k] ^= one;\n      }\n    } else if (lo1 > lo0) {\n      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n        k = index[i];\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n        curr[k] ^= one;\n      }\n    } // Fast incremental update based on previous hi index.\n\n    if (hi1 > hi0) {\n      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n        k = index[i];\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n        curr[k] ^= one;\n      }\n    } else if (hi1 < hi0) {\n      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n        k = index[i];\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n        curr[k] ^= one;\n      }\n    }\n    dim.range = query.slice();\n  },\n  incrementOne: function incrementOne(dim, query, add, rem) {\n    var bits = this.value,\n      curr = bits.curr(),\n      index = dim.index(),\n      old = dim.bisect(dim.range),\n      range = dim.bisect(query),\n      lo1 = range[0],\n      hi1 = range[1],\n      lo0 = old[0],\n      hi0 = old[1],\n      one = dim.one;\n    var i, j, k; // Fast incremental update based on previous lo index.\n\n    if (lo1 < lo0) {\n      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        add.push(k);\n      }\n    } else if (lo1 > lo0) {\n      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        rem.push(k);\n      }\n    } // Fast incremental update based on previous hi index.\n\n    if (hi1 > hi0) {\n      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        add.push(k);\n      }\n    } else if (hi1 < hi0) {\n      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        rem.push(k);\n      }\n    }\n    dim.range = query.slice();\n  }\n});\n\n/**\n * Selectively filters tuples by resolving against a filter bitmap.\n * Useful for processing the output of a cross-filter transform.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.ignore - A bit mask indicating which filters to ignore.\n * @param {object} params.filter - The per-tuple filter bitmaps. Typically this\n *   parameter value is a reference to a {@link CrossFilter} transform.\n */\n\nfunction ResolveFilter(params) {\n  Transform.call(this, null, params);\n}\nResolveFilter.Definition = {\n  'type': 'ResolveFilter',\n  'metadata': {},\n  'params': [{\n    'name': 'ignore',\n    'type': 'number',\n    'required': true,\n    'description': 'A bit mask indicating which filters to ignore.'\n  }, {\n    'name': 'filter',\n    'type': 'object',\n    'required': true,\n    'description': 'Per-tuple filter bitmaps from a CrossFilter transform.'\n  }]\n};\ninherits(ResolveFilter, Transform, {\n  transform: function transform(_, pulse) {\n    var ignore = ~(_.ignore || 0),\n      // bit mask where zeros -> dims to ignore\n      bitmap = _.filter,\n      mask = bitmap.mask; // exit early if no relevant filter changes\n\n    if ((mask & ignore) === 0) return pulse.StopPropagation;\n    var output = pulse.fork(pulse.ALL),\n      data = bitmap.data(),\n      curr = bitmap.curr(),\n      prev = bitmap.prev(),\n      pass = function pass(k) {\n        return !(curr[k] & ignore) ? data[k] : null;\n      }; // propagate all mod tuples that pass the filter\n\n    output.filter(output.MOD, pass); // determine add & rem tuples via filter functions\n    // for efficiency, we do *not* populate new arrays,\n    // instead we add filter functions applied downstream\n\n    if (!(mask & mask - 1)) {\n      // only one filter changed\n      output.filter(output.ADD, pass);\n      output.filter(output.REM, function (k) {\n        return (curr[k] & ignore) === mask ? data[k] : null;\n      });\n    } else {\n      // multiple filters changed\n      output.filter(output.ADD, function (k) {\n        var c = curr[k] & ignore,\n          f = !c && c ^ prev[k] & ignore;\n        return f ? data[k] : null;\n      });\n      output.filter(output.REM, function (k) {\n        var c = curr[k] & ignore,\n          f = c && !(c ^ (c ^ prev[k] & ignore));\n        return f ? data[k] : null;\n      });\n    } // add filter to source data in case of reflow...\n\n    return output.filter(output.SOURCE, function (t) {\n      return pass(t._index);\n    });\n  }\n});\nexport { CrossFilter as crossfilter, ResolveFilter as resolvefilter };","map":{"version":3,"names":["permute","bisectLeft","bisectRight","Transform","inherits","array8","n","Uint8Array","array16","Uint16Array","array32","Uint32Array","Bitmaps","width","data","seen","curr","array","prev","lengthen","length","add","i","j","t","_index","push","remove","num","map","copy","Array","reindex","size","reset","k","all","set","one","clear","resize","m","Math","max","constructor","Dimension","index","query","bit","zero","range","slice","bisect","onAdd","added","dim","value","idx","lo","hi","n1","SortedIndex","insert","key","base","n0","addi","addv","oldv","oldi","sort","merge","values","call","a","b","x","y","value0","index0","value1","index1","i0","i1","CrossFilter","params","_indices","_dims","Definition","transform","_","pulse","init","modified","fields","some","f","reinit","eval","indices","dims","fname","output","materialize","fork","bits","out","rem","mod","adds","mods","remMap","modMap","source","mask","update","modify","tuples","runAfter","indexMap","stamp","q","filters","incrementOne","incrementAll","old","lo1","hi1","lo0","hi0","min","ResolveFilter","ignore","bitmap","filter","StopPropagation","ALL","pass","MOD","ADD","REM","c","SOURCE","crossfilter","resolvefilter"],"sources":["/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/vega-crossfilter/build/vega-crossfilter.module.js"],"sourcesContent":["import { permute, bisectLeft, bisectRight } from 'd3-array';\nimport { Transform } from 'vega-dataflow';\nimport { inherits } from 'vega-util';\n\nconst array8 = n => new Uint8Array(n);\nconst array16 = n => new Uint16Array(n);\nconst array32 = n => new Uint32Array(n);\n\n/**\n * Maintains CrossFilter state.\n */\n\nfunction Bitmaps() {\n  let width = 8,\n      data = [],\n      seen = array32(0),\n      curr = array(0, width),\n      prev = array(0, width);\n  return {\n    data: () => data,\n    seen: () => seen = lengthen(seen, data.length),\n\n    add(array) {\n      for (let i = 0, j = data.length, n = array.length, t; i < n; ++i) {\n        t = array[i];\n        t._index = j++;\n        data.push(t);\n      }\n    },\n\n    remove(num, map) {\n      // map: index -> boolean (true => remove)\n      const n = data.length,\n            copy = Array(n - num),\n            reindex = data; // reuse old data array for index map\n\n      let t, i, j; // seek forward to first removal\n\n      for (i = 0; !map[i] && i < n; ++i) {\n        copy[i] = data[i];\n        reindex[i] = i;\n      } // condense arrays\n\n\n      for (j = i; i < n; ++i) {\n        t = data[i];\n\n        if (!map[i]) {\n          reindex[i] = j;\n          curr[j] = curr[i];\n          prev[j] = prev[i];\n          copy[j] = t;\n          t._index = j++;\n        } else {\n          reindex[i] = -1;\n        }\n\n        curr[i] = 0; // clear unused bits\n      }\n\n      data = copy;\n      return reindex;\n    },\n\n    size: () => data.length,\n    curr: () => curr,\n    prev: () => prev,\n    reset: k => prev[k] = curr[k],\n    all: () => width < 0x101 ? 0xff : width < 0x10001 ? 0xffff : 0xffffffff,\n\n    set(k, one) {\n      curr[k] |= one;\n    },\n\n    clear(k, one) {\n      curr[k] &= ~one;\n    },\n\n    resize(n, m) {\n      const k = curr.length;\n\n      if (n > k || m > width) {\n        width = Math.max(m, width);\n        curr = array(n, width, curr);\n        prev = array(n, width);\n      }\n    }\n\n  };\n}\n\nfunction lengthen(array, length, copy) {\n  if (array.length >= length) return array;\n  copy = copy || new array.constructor(length);\n  copy.set(array);\n  return copy;\n}\n\nfunction array(n, m, array) {\n  const copy = (m < 0x101 ? array8 : m < 0x10001 ? array16 : array32)(n);\n  if (array) copy.set(array);\n  return copy;\n}\n\nfunction Dimension (index, i, query) {\n  const bit = 1 << i;\n  return {\n    one: bit,\n    zero: ~bit,\n    range: query.slice(),\n    bisect: index.bisect,\n    index: index.index,\n    size: index.size,\n\n    onAdd(added, curr) {\n      const dim = this,\n            range = dim.bisect(dim.range, added.value),\n            idx = added.index,\n            lo = range[0],\n            hi = range[1],\n            n1 = idx.length;\n      let i;\n\n      for (i = 0; i < lo; ++i) curr[idx[i]] |= bit;\n\n      for (i = hi; i < n1; ++i) curr[idx[i]] |= bit;\n\n      return dim;\n    }\n\n  };\n}\n\n/**\n * Maintains a list of values, sorted by key.\n */\n\nfunction SortedIndex() {\n  let index = array32(0),\n      value = [],\n      size = 0;\n\n  function insert(key, data, base) {\n    if (!data.length) return [];\n    const n0 = size,\n          n1 = data.length,\n          addi = array32(n1);\n    let addv = Array(n1),\n        oldv,\n        oldi,\n        i;\n\n    for (i = 0; i < n1; ++i) {\n      addv[i] = key(data[i]);\n      addi[i] = i;\n    }\n\n    addv = sort(addv, addi);\n\n    if (n0) {\n      oldv = value;\n      oldi = index;\n      value = Array(n0 + n1);\n      index = array32(n0 + n1);\n      merge(base, oldv, oldi, n0, addv, addi, n1, value, index);\n    } else {\n      if (base > 0) for (i = 0; i < n1; ++i) {\n        addi[i] += base;\n      }\n      value = addv;\n      index = addi;\n    }\n\n    size = n0 + n1;\n    return {\n      index: addi,\n      value: addv\n    };\n  }\n\n  function remove(num, map) {\n    // map: index -> remove\n    const n = size;\n    let idx, i, j; // seek forward to first removal\n\n    for (i = 0; !map[index[i]] && i < n; ++i); // condense index and value arrays\n\n\n    for (j = i; i < n; ++i) {\n      if (!map[idx = index[i]]) {\n        index[j] = idx;\n        value[j] = value[i];\n        ++j;\n      }\n    }\n\n    size = n - num;\n  }\n\n  function reindex(map) {\n    for (let i = 0, n = size; i < n; ++i) {\n      index[i] = map[index[i]];\n    }\n  }\n\n  function bisect(range, array) {\n    let n;\n\n    if (array) {\n      n = array.length;\n    } else {\n      array = value;\n      n = size;\n    }\n\n    return [bisectLeft(array, range[0], 0, n), bisectRight(array, range[1], 0, n)];\n  }\n\n  return {\n    insert: insert,\n    remove: remove,\n    bisect: bisect,\n    reindex: reindex,\n    index: () => index,\n    size: () => size\n  };\n}\n\nfunction sort(values, index) {\n  values.sort.call(index, (a, b) => {\n    const x = values[a],\n          y = values[b];\n    return x < y ? -1 : x > y ? 1 : 0;\n  });\n  return permute(values, index);\n}\n\nfunction merge(base, value0, index0, n0, value1, index1, n1, value, index) {\n  let i0 = 0,\n      i1 = 0,\n      i;\n\n  for (i = 0; i0 < n0 && i1 < n1; ++i) {\n    if (value0[i0] < value1[i1]) {\n      value[i] = value0[i0];\n      index[i] = index0[i0++];\n    } else {\n      value[i] = value1[i1];\n      index[i] = index1[i1++] + base;\n    }\n  }\n\n  for (; i0 < n0; ++i0, ++i) {\n    value[i] = value0[i0];\n    index[i] = index0[i0];\n  }\n\n  for (; i1 < n1; ++i1, ++i) {\n    value[i] = value1[i1];\n    index[i] = index1[i1] + base;\n  }\n}\n\n/**\n * An indexed multi-dimensional filter.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.fields - An array of dimension accessors to filter.\n * @param {Array} params.query - An array of per-dimension range queries.\n */\n\nfunction CrossFilter(params) {\n  Transform.call(this, Bitmaps(), params);\n  this._indices = null;\n  this._dims = null;\n}\nCrossFilter.Definition = {\n  'type': 'CrossFilter',\n  'metadata': {},\n  'params': [{\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'required': true\n  }, {\n    'name': 'query',\n    'type': 'array',\n    'array': true,\n    'required': true,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }]\n};\ninherits(CrossFilter, Transform, {\n  transform(_, pulse) {\n    if (!this._dims) {\n      return this.init(_, pulse);\n    } else {\n      var init = _.modified('fields') || _.fields.some(f => pulse.modified(f.fields));\n\n      return init ? this.reinit(_, pulse) : this.eval(_, pulse);\n    }\n  },\n\n  init(_, pulse) {\n    const fields = _.fields,\n          query = _.query,\n          indices = this._indices = {},\n          dims = this._dims = [],\n          m = query.length;\n    let i = 0,\n        key,\n        index; // instantiate indices and dimensions\n\n    for (; i < m; ++i) {\n      key = fields[i].fname;\n      index = indices[key] || (indices[key] = SortedIndex());\n      dims.push(Dimension(index, i, query[i]));\n    }\n\n    return this.eval(_, pulse);\n  },\n\n  reinit(_, pulse) {\n    const output = pulse.materialize().fork(),\n          fields = _.fields,\n          query = _.query,\n          indices = this._indices,\n          dims = this._dims,\n          bits = this.value,\n          curr = bits.curr(),\n          prev = bits.prev(),\n          all = bits.all(),\n          out = output.rem = output.add,\n          mod = output.mod,\n          m = query.length,\n          adds = {};\n    let add, index, key, mods, remMap, modMap, i, n, f; // set prev to current state\n\n    prev.set(curr); // if pulse has remove tuples, process them first\n\n    if (pulse.rem.length) {\n      remMap = this.remove(_, pulse, output);\n    } // if pulse has added tuples, add them to state\n\n\n    if (pulse.add.length) {\n      bits.add(pulse.add);\n    } // if pulse has modified tuples, create an index map\n\n\n    if (pulse.mod.length) {\n      modMap = {};\n\n      for (mods = pulse.mod, i = 0, n = mods.length; i < n; ++i) {\n        modMap[mods[i]._index] = 1;\n      }\n    } // re-initialize indices as needed, update curr bitmap\n\n\n    for (i = 0; i < m; ++i) {\n      f = fields[i];\n\n      if (!dims[i] || _.modified('fields', i) || pulse.modified(f.fields)) {\n        key = f.fname;\n\n        if (!(add = adds[key])) {\n          indices[key] = index = SortedIndex();\n          adds[key] = add = index.insert(f, pulse.source, 0);\n        }\n\n        dims[i] = Dimension(index, i, query[i]).onAdd(add, curr);\n      }\n    } // visit each tuple\n    // if filter state changed, push index to add/rem\n    // else if in mod and passes a filter, push index to mod\n\n\n    for (i = 0, n = bits.data().length; i < n; ++i) {\n      if (remMap[i]) {\n        // skip if removed tuple\n        continue;\n      } else if (prev[i] !== curr[i]) {\n        // add if state changed\n        out.push(i);\n      } else if (modMap[i] && curr[i] !== all) {\n        // otherwise, pass mods through\n        mod.push(i);\n      }\n    }\n\n    bits.mask = (1 << m) - 1;\n    return output;\n  },\n\n  eval(_, pulse) {\n    const output = pulse.materialize().fork(),\n          m = this._dims.length;\n    let mask = 0;\n\n    if (pulse.rem.length) {\n      this.remove(_, pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    if (_.modified('query') && !_.modified('fields')) {\n      mask |= this.update(_, pulse, output);\n    }\n\n    if (pulse.add.length) {\n      this.insert(_, pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    if (pulse.mod.length) {\n      this.modify(pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    this.value.mask = mask;\n    return output;\n  },\n\n  insert(_, pulse, output) {\n    const tuples = pulse.add,\n          bits = this.value,\n          dims = this._dims,\n          indices = this._indices,\n          fields = _.fields,\n          adds = {},\n          out = output.add,\n          n = bits.size() + tuples.length,\n          m = dims.length;\n    let k = bits.size(),\n        j,\n        key,\n        add; // resize bitmaps and add tuples as needed\n\n    bits.resize(n, m);\n    bits.add(tuples);\n    const curr = bits.curr(),\n          prev = bits.prev(),\n          all = bits.all(); // add to dimensional indices\n\n    for (j = 0; j < m; ++j) {\n      key = fields[j].fname;\n      add = adds[key] || (adds[key] = indices[key].insert(fields[j], tuples, k));\n      dims[j].onAdd(add, curr);\n    } // set previous filters, output if passes at least one filter\n\n\n    for (; k < n; ++k) {\n      prev[k] = all;\n      if (curr[k] !== all) out.push(k);\n    }\n  },\n\n  modify(pulse, output) {\n    const out = output.mod,\n          bits = this.value,\n          curr = bits.curr(),\n          all = bits.all(),\n          tuples = pulse.mod;\n    let i, n, k;\n\n    for (i = 0, n = tuples.length; i < n; ++i) {\n      k = tuples[i]._index;\n      if (curr[k] !== all) out.push(k);\n    }\n  },\n\n  remove(_, pulse, output) {\n    const indices = this._indices,\n          bits = this.value,\n          curr = bits.curr(),\n          prev = bits.prev(),\n          all = bits.all(),\n          map = {},\n          out = output.rem,\n          tuples = pulse.rem;\n    let i, n, k, f; // process tuples, output if passes at least one filter\n\n    for (i = 0, n = tuples.length; i < n; ++i) {\n      k = tuples[i]._index;\n      map[k] = 1; // build index map\n\n      prev[k] = f = curr[k];\n      curr[k] = all;\n      if (f !== all) out.push(k);\n    } // remove from dimensional indices\n\n\n    for (k in indices) {\n      indices[k].remove(n, map);\n    }\n\n    this.reindex(pulse, n, map);\n    return map;\n  },\n\n  // reindex filters and indices after propagation completes\n  reindex(pulse, num, map) {\n    const indices = this._indices,\n          bits = this.value;\n    pulse.runAfter(() => {\n      const indexMap = bits.remove(num, map);\n\n      for (const key in indices) indices[key].reindex(indexMap);\n    });\n  },\n\n  update(_, pulse, output) {\n    const dims = this._dims,\n          query = _.query,\n          stamp = pulse.stamp,\n          m = dims.length;\n    let mask = 0,\n        i,\n        q; // survey how many queries have changed\n\n    output.filters = 0;\n\n    for (q = 0; q < m; ++q) {\n      if (_.modified('query', q)) {\n        i = q;\n        ++mask;\n      }\n    }\n\n    if (mask === 1) {\n      // only one query changed, use more efficient update\n      mask = dims[i].one;\n      this.incrementOne(dims[i], query[i], output.add, output.rem);\n    } else {\n      // multiple queries changed, perform full record keeping\n      for (q = 0, mask = 0; q < m; ++q) {\n        if (!_.modified('query', q)) continue;\n        mask |= dims[q].one;\n        this.incrementAll(dims[q], query[q], stamp, output.add);\n        output.rem = output.add; // duplicate add/rem for downstream resolve\n      }\n    }\n\n    return mask;\n  },\n\n  incrementAll(dim, query, stamp, out) {\n    const bits = this.value,\n          seen = bits.seen(),\n          curr = bits.curr(),\n          prev = bits.prev(),\n          index = dim.index(),\n          old = dim.bisect(dim.range),\n          range = dim.bisect(query),\n          lo1 = range[0],\n          hi1 = range[1],\n          lo0 = old[0],\n          hi0 = old[1],\n          one = dim.one;\n    let i, j, k; // Fast incremental update based on previous lo index.\n\n    if (lo1 < lo0) {\n      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    } else if (lo1 > lo0) {\n      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    } // Fast incremental update based on previous hi index.\n\n\n    if (hi1 > hi0) {\n      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    } else if (hi1 < hi0) {\n      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n        k = index[i];\n\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n\n        curr[k] ^= one;\n      }\n    }\n\n    dim.range = query.slice();\n  },\n\n  incrementOne(dim, query, add, rem) {\n    const bits = this.value,\n          curr = bits.curr(),\n          index = dim.index(),\n          old = dim.bisect(dim.range),\n          range = dim.bisect(query),\n          lo1 = range[0],\n          hi1 = range[1],\n          lo0 = old[0],\n          hi0 = old[1],\n          one = dim.one;\n    let i, j, k; // Fast incremental update based on previous lo index.\n\n    if (lo1 < lo0) {\n      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        add.push(k);\n      }\n    } else if (lo1 > lo0) {\n      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        rem.push(k);\n      }\n    } // Fast incremental update based on previous hi index.\n\n\n    if (hi1 > hi0) {\n      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        add.push(k);\n      }\n    } else if (hi1 < hi0) {\n      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        rem.push(k);\n      }\n    }\n\n    dim.range = query.slice();\n  }\n\n});\n\n/**\n * Selectively filters tuples by resolving against a filter bitmap.\n * Useful for processing the output of a cross-filter transform.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.ignore - A bit mask indicating which filters to ignore.\n * @param {object} params.filter - The per-tuple filter bitmaps. Typically this\n *   parameter value is a reference to a {@link CrossFilter} transform.\n */\n\nfunction ResolveFilter(params) {\n  Transform.call(this, null, params);\n}\nResolveFilter.Definition = {\n  'type': 'ResolveFilter',\n  'metadata': {},\n  'params': [{\n    'name': 'ignore',\n    'type': 'number',\n    'required': true,\n    'description': 'A bit mask indicating which filters to ignore.'\n  }, {\n    'name': 'filter',\n    'type': 'object',\n    'required': true,\n    'description': 'Per-tuple filter bitmaps from a CrossFilter transform.'\n  }]\n};\ninherits(ResolveFilter, Transform, {\n  transform(_, pulse) {\n    const ignore = ~(_.ignore || 0),\n          // bit mask where zeros -> dims to ignore\n    bitmap = _.filter,\n          mask = bitmap.mask; // exit early if no relevant filter changes\n\n    if ((mask & ignore) === 0) return pulse.StopPropagation;\n\n    const output = pulse.fork(pulse.ALL),\n          data = bitmap.data(),\n          curr = bitmap.curr(),\n          prev = bitmap.prev(),\n          pass = k => !(curr[k] & ignore) ? data[k] : null; // propagate all mod tuples that pass the filter\n\n\n    output.filter(output.MOD, pass); // determine add & rem tuples via filter functions\n    // for efficiency, we do *not* populate new arrays,\n    // instead we add filter functions applied downstream\n\n    if (!(mask & mask - 1)) {\n      // only one filter changed\n      output.filter(output.ADD, pass);\n      output.filter(output.REM, k => (curr[k] & ignore) === mask ? data[k] : null);\n    } else {\n      // multiple filters changed\n      output.filter(output.ADD, k => {\n        const c = curr[k] & ignore,\n              f = !c && c ^ prev[k] & ignore;\n        return f ? data[k] : null;\n      });\n      output.filter(output.REM, k => {\n        const c = curr[k] & ignore,\n              f = c && !(c ^ (c ^ prev[k] & ignore));\n        return f ? data[k] : null;\n      });\n    } // add filter to source data in case of reflow...\n\n\n    return output.filter(output.SOURCE, t => pass(t._index));\n  }\n\n});\n\nexport { CrossFilter as crossfilter, ResolveFilter as resolvefilter };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}