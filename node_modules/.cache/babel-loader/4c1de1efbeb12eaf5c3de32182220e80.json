{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { isArray, isNumber, isObject } from 'vega-util';\nimport { isBinning } from '../../bin';\nimport { ANGLE, COLOR, FILL, FILLOPACITY, getOffsetScaleChannel, getSizeChannel, isXorY, isXorYOffset, OPACITY, RADIUS, SCALE_CHANNELS, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH, THETA, X, XOFFSET, Y, YOFFSET } from '../../channel';\nimport { getFieldOrDatumDef, isFieldOrDatumDef } from '../../channeldef';\nimport { getViewConfigDiscreteSize, getViewConfigDiscreteStep } from '../../config';\nimport { DataSourceType } from '../../data';\nimport { channelHasFieldOrDatum } from '../../encoding';\nimport * as log from '../../log';\nimport { channelScalePropertyIncompatability, hasContinuousDomain, hasDiscreteDomain, isContinuousToDiscrete, isExtendedScheme, scaleTypeSupportProperty } from '../../scale';\nimport { getStepFor, isStep } from '../../spec/base';\nimport { isDiscrete } from '../../type';\nimport * as util from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { exprFromSignalRefOrValue, signalOrStringValue } from '../common';\nimport { getBinSignalName } from '../data/bin';\nimport { SignalRefWrapper } from '../signal';\nimport { makeExplicit, makeImplicit } from '../split';\nexport var RANGE_PROPERTIES = ['range', 'scheme'];\nexport function parseUnitScaleRange(model) {\n  var localScaleComponents = model.component.scales;\n  // use SCALE_CHANNELS instead of scales[channel] to ensure that x, y come first!\n  var _iterator = _createForOfIteratorHelper(SCALE_CHANNELS),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var channel = _step.value;\n      var localScaleCmpt = localScaleComponents[channel];\n      if (!localScaleCmpt) {\n        continue;\n      }\n      var rangeWithExplicit = parseRangeForChannel(channel, model);\n      localScaleCmpt.setWithExplicit('range', rangeWithExplicit);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nfunction getBinStepSignal(model, channel) {\n  var fieldDef = model.fieldDef(channel);\n  if (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) {\n    var bin = fieldDef.bin,\n      field = fieldDef.field;\n    var sizeType = getSizeChannel(channel);\n    var sizeSignal = model.getName(sizeType);\n    if (isObject(bin) && bin.binned && bin.step !== undefined) {\n      return new SignalRefWrapper(function () {\n        var scaleName = model.scaleName(channel);\n        var binCount = \"(domain(\\\"\".concat(scaleName, \"\\\")[1] - domain(\\\"\").concat(scaleName, \"\\\")[0]) / \").concat(bin.step);\n        return \"\".concat(model.getSignalName(sizeSignal), \" / (\").concat(binCount, \")\");\n      });\n    } else if (isBinning(bin)) {\n      var binSignal = getBinSignalName(model, field, bin);\n      // TODO: extract this to be range step signal\n      return new SignalRefWrapper(function () {\n        var updatedName = model.getSignalName(binSignal);\n        var binCount = \"(\".concat(updatedName, \".stop - \").concat(updatedName, \".start) / \").concat(updatedName, \".step\");\n        return \"\".concat(model.getSignalName(sizeSignal), \" / (\").concat(binCount, \")\");\n      });\n    }\n  }\n  return undefined;\n}\n/**\n * Return mixins that includes one of the Vega range types (explicit range, range.step, range.scheme).\n */\nexport function parseRangeForChannel(channel, model) {\n  var specifiedScale = model.specifiedScales[channel];\n  var size = model.size;\n  var mergedScaleCmpt = model.getScaleComponent(channel);\n  var scaleType = mergedScaleCmpt.get('type');\n  // Check if any of the range properties is specified.\n  // If so, check if it is compatible and make sure that we only output one of the properties\n  var _iterator2 = _createForOfIteratorHelper(RANGE_PROPERTIES),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var property = _step2.value;\n      if (specifiedScale[property] !== undefined) {\n        var supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n        var channelIncompatability = channelScalePropertyIncompatability(channel, property);\n        if (!supportedByScaleType) {\n          log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n        } else if (channelIncompatability) {\n          // channel\n          log.warn(channelIncompatability);\n        } else {\n          switch (property) {\n            case 'range':\n              {\n                var range = specifiedScale.range;\n                if (isArray(range)) {\n                  if (isXorY(channel)) {\n                    return makeExplicit(range.map(function (v) {\n                      if (v === 'width' || v === 'height') {\n                        // get signal for width/height\n                        // Just like default range logic below, we use SignalRefWrapper to account for potential merges and renames.\n                        var sizeSignal = model.getName(v);\n                        var getSignalName = model.getSignalName.bind(model);\n                        return SignalRefWrapper.fromName(getSignalName, sizeSignal);\n                      }\n                      return v;\n                    }));\n                  }\n                } else if (isObject(range)) {\n                  return makeExplicit({\n                    data: model.requestDataName(DataSourceType.Main),\n                    field: range.field,\n                    sort: {\n                      op: 'min',\n                      field: model.vgField(channel)\n                    }\n                  });\n                }\n                return makeExplicit(range);\n              }\n            case 'scheme':\n              return makeExplicit(parseScheme(specifiedScale[property]));\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  var sizeChannel = channel === X || channel === 'xOffset' ? 'width' : 'height';\n  var sizeValue = size[sizeChannel];\n  if (isStep(sizeValue)) {\n    if (isXorY(channel)) {\n      if (hasDiscreteDomain(scaleType)) {\n        var step = getPositionStep(sizeValue, model, channel);\n        // Need to be explicit so layer with step wins over layer without step\n        if (step) {\n          return makeExplicit({\n            step: step\n          });\n        }\n      } else {\n        log.warn(log.message.stepDropped(sizeChannel));\n      }\n    } else if (isXorYOffset(channel)) {\n      var positionChannel = channel === XOFFSET ? 'x' : 'y';\n      var positionScaleCmpt = model.getScaleComponent(positionChannel);\n      var positionScaleType = positionScaleCmpt.get('type');\n      if (positionScaleType === 'band') {\n        var _step3 = getOffsetStep(sizeValue, scaleType);\n        if (_step3) {\n          return makeExplicit(_step3);\n        }\n      }\n    }\n  }\n  var rangeMin = specifiedScale.rangeMin,\n    rangeMax = specifiedScale.rangeMax;\n  var d = defaultRange(channel, model);\n  if ((rangeMin !== undefined || rangeMax !== undefined) &&\n  // it's ok to check just rangeMin's compatibility since rangeMin/rangeMax are the same\n  scaleTypeSupportProperty(scaleType, 'rangeMin') && isArray(d) && d.length === 2) {\n    return makeExplicit([rangeMin !== null && rangeMin !== void 0 ? rangeMin : d[0], rangeMax !== null && rangeMax !== void 0 ? rangeMax : d[1]]);\n  }\n  return makeImplicit(d);\n}\nfunction parseScheme(scheme) {\n  if (isExtendedScheme(scheme)) {\n    return Object.assign({\n      scheme: scheme.name\n    }, util.omit(scheme, ['name']));\n  }\n  return {\n    scheme: scheme\n  };\n}\nfunction defaultRange(channel, model) {\n  var size = model.size,\n    config = model.config,\n    mark = model.mark,\n    encoding = model.encoding;\n  var getSignalName = model.getSignalName.bind(model);\n  var _getFieldOrDatumDef = getFieldOrDatumDef(encoding[channel]),\n    type = _getFieldOrDatumDef.type;\n  var mergedScaleCmpt = model.getScaleComponent(channel);\n  var scaleType = mergedScaleCmpt.get('type');\n  var _model$specifiedScale = model.specifiedScales[channel],\n    domain = _model$specifiedScale.domain,\n    domainMid = _model$specifiedScale.domainMid;\n  switch (channel) {\n    case X:\n    case Y:\n      {\n        // If there is no explicit width/height for discrete x/y scales\n        if (util.contains(['point', 'band'], scaleType)) {\n          var positionSize = getDiscretePositionSize(channel, size, config.view);\n          if (isStep(positionSize)) {\n            var step = getPositionStep(positionSize, model, channel);\n            return {\n              step: step\n            };\n          }\n        }\n        // If step is null, use zero to width or height.\n        // Note that we use SignalRefWrapper to account for potential merges and renames.\n        var sizeType = getSizeChannel(channel);\n        var sizeSignal = model.getName(sizeType);\n        if (channel === Y && hasContinuousDomain(scaleType)) {\n          // For y continuous scale, we have to start from the height as the bottom part has the max value.\n          return [SignalRefWrapper.fromName(getSignalName, sizeSignal), 0];\n        } else {\n          return [0, SignalRefWrapper.fromName(getSignalName, sizeSignal)];\n        }\n      }\n    case XOFFSET:\n    case YOFFSET:\n      return getOffsetRange(channel, model, scaleType);\n    case SIZE:\n      {\n        // TODO: support custom rangeMin, rangeMax\n        var zero = model.component.scales[channel].get('zero');\n        var rangeMin = sizeRangeMin(mark, zero, config);\n        var rangeMax = sizeRangeMax(mark, size, model, config);\n        if (isContinuousToDiscrete(scaleType)) {\n          return interpolateRange(rangeMin, rangeMax, defaultContinuousToDiscreteCount(scaleType, config, domain, channel));\n        } else {\n          return [rangeMin, rangeMax];\n        }\n      }\n    case THETA:\n      return [0, Math.PI * 2];\n    case ANGLE:\n      // TODO: add config.scale.min/maxAngleDegree (for point and text) and config.scale.min/maxAngleRadian (for arc) once we add arc marks.\n      // (It's weird to add just config.scale.min/maxAngleDegree for now)\n      return [0, 360];\n    case RADIUS:\n      {\n        // max radius = half od min(width,height)\n        return [0, new SignalRefWrapper(function () {\n          var w = model.getSignalName('width');\n          var h = model.getSignalName('height');\n          return \"min(\".concat(w, \",\").concat(h, \")/2\");\n        })];\n      }\n    case STROKEWIDTH:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minStrokeWidth, config.scale.maxStrokeWidth];\n    case STROKEDASH:\n      return [\n      // TODO: add this to Vega's config.range?\n      [1, 0], [4, 2], [2, 1], [1, 1], [1, 2, 4, 2]];\n    case SHAPE:\n      return 'symbol';\n    case COLOR:\n    case FILL:\n    case STROKE:\n      if (scaleType === 'ordinal') {\n        // Only nominal data uses ordinal scale by default\n        return type === 'nominal' ? 'category' : 'ordinal';\n      } else {\n        if (domainMid !== undefined) {\n          return 'diverging';\n        } else {\n          return mark === 'rect' || mark === 'geoshape' ? 'heatmap' : 'ramp';\n        }\n      }\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minOpacity, config.scale.maxOpacity];\n  }\n}\nfunction getPositionStep(step, model, channel) {\n  var _a, _b, _c, _d, _e;\n  var encoding = model.encoding;\n  var mergedScaleCmpt = model.getScaleComponent(channel);\n  var offsetChannel = getOffsetScaleChannel(channel);\n  var offsetDef = encoding[offsetChannel];\n  var stepFor = getStepFor({\n    step: step,\n    offsetIsDiscrete: isFieldOrDatumDef(offsetDef) && isDiscrete(offsetDef.type)\n  });\n  if (stepFor === 'offset' && channelHasFieldOrDatum(encoding, offsetChannel)) {\n    var offsetScaleCmpt = model.getScaleComponent(offsetChannel);\n    var offsetScaleName = model.scaleName(offsetChannel);\n    var stepCount = \"domain('\".concat(offsetScaleName, \"').length\");\n    if (offsetScaleCmpt.get('type') === 'band') {\n      var offsetPaddingInner = (_b = (_a = offsetScaleCmpt.get('paddingInner')) !== null && _a !== void 0 ? _a : offsetScaleCmpt.get('padding')) !== null && _b !== void 0 ? _b : 0;\n      var offsetPaddingOuter = (_d = (_c = offsetScaleCmpt.get('paddingOuter')) !== null && _c !== void 0 ? _c : offsetScaleCmpt.get('padding')) !== null && _d !== void 0 ? _d : 0;\n      stepCount = \"bandspace(\".concat(stepCount, \", \").concat(offsetPaddingInner, \", \").concat(offsetPaddingOuter, \")\");\n    }\n    var paddingInner = (_e = mergedScaleCmpt.get('paddingInner')) !== null && _e !== void 0 ? _e : mergedScaleCmpt.get('padding');\n    return {\n      signal: \"\".concat(step.step, \" * \").concat(stepCount, \" / (1-\").concat(exprFromSignalRefOrValue(paddingInner), \")\")\n    };\n  } else {\n    return step.step;\n  }\n}\nfunction getOffsetStep(step, offsetScaleType) {\n  var stepFor = getStepFor({\n    step: step,\n    offsetIsDiscrete: hasDiscreteDomain(offsetScaleType)\n  });\n  if (stepFor === 'offset') {\n    return {\n      step: step.step\n    };\n  }\n  return undefined;\n}\nfunction getOffsetRange(channel, model, offsetScaleType) {\n  var positionChannel = channel === XOFFSET ? 'x' : 'y';\n  var positionScaleCmpt = model.getScaleComponent(positionChannel);\n  var positionScaleType = positionScaleCmpt.get('type');\n  var positionScaleName = model.scaleName(positionChannel);\n  if (positionScaleType === 'band') {\n    var size = getDiscretePositionSize(positionChannel, model.size, model.config.view);\n    if (isStep(size)) {\n      // step is for offset\n      var step = getOffsetStep(size, offsetScaleType);\n      if (step) {\n        return step;\n      }\n    }\n    // otherwise use the position\n    return [0, {\n      signal: \"bandwidth('\".concat(positionScaleName, \"')\")\n    }];\n  } else {\n    // continuous scale\n    return util.never(\"Cannot use \".concat(channel, \" scale if \").concat(positionChannel, \" scale is not discrete.\"));\n  }\n}\nfunction getDiscretePositionSize(channel, size, viewConfig) {\n  var sizeChannel = channel === X ? 'width' : 'height';\n  var sizeValue = size[sizeChannel];\n  if (sizeValue) {\n    return sizeValue;\n  }\n  return getViewConfigDiscreteSize(viewConfig, sizeChannel);\n}\nexport function defaultContinuousToDiscreteCount(scaleType, config, domain, channel) {\n  switch (scaleType) {\n    case 'quantile':\n      return config.scale.quantileCount;\n    case 'quantize':\n      return config.scale.quantizeCount;\n    case 'threshold':\n      if (domain !== undefined && isArray(domain)) {\n        return domain.length + 1;\n      } else {\n        log.warn(log.message.domainRequiredForThresholdScale(channel));\n        // default threshold boundaries for threshold scale since domain has cardinality of 2\n        return 3;\n      }\n  }\n}\n/**\n * Returns the linear interpolation of the range according to the cardinality\n *\n * @param rangeMin start of the range\n * @param rangeMax end of the range\n * @param cardinality number of values in the output range\n */\nexport function interpolateRange(rangeMin, rangeMax, cardinality) {\n  // always return a signal since it's better to compute the sequence in Vega later\n  var f = function f() {\n    var rMax = signalOrStringValue(rangeMax);\n    var rMin = signalOrStringValue(rangeMin);\n    var step = \"(\".concat(rMax, \" - \").concat(rMin, \") / (\").concat(cardinality, \" - 1)\");\n    return \"sequence(\".concat(rMin, \", \").concat(rMax, \" + \").concat(step, \", \").concat(step, \")\");\n  };\n  if (isSignalRef(rangeMax)) {\n    return new SignalRefWrapper(f);\n  } else {\n    return {\n      signal: f()\n    };\n  }\n}\nfunction sizeRangeMin(mark, zero, config) {\n  if (zero) {\n    if (isSignalRef(zero)) {\n      return {\n        signal: \"\".concat(zero.signal, \" ? 0 : \").concat(sizeRangeMin(mark, false, config))\n      };\n    } else {\n      return 0;\n    }\n  }\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      return config.scale.minBandSize;\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.minStrokeWidth;\n    case 'text':\n      return config.scale.minFontSize;\n    case 'point':\n    case 'square':\n    case 'circle':\n      return config.scale.minSize;\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMin not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\nexport var MAX_SIZE_RANGE_STEP_RATIO = 0.95;\nfunction sizeRangeMax(mark, size, model, config) {\n  var xyStepSignals = {\n    x: getBinStepSignal(model, 'x'),\n    y: getBinStepSignal(model, 'y')\n  };\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      {\n        if (config.scale.maxBandSize !== undefined) {\n          return config.scale.maxBandSize;\n        }\n        var min = minXYStep(size, xyStepSignals, config.view);\n        if (isNumber(min)) {\n          return min - 1;\n        } else {\n          return new SignalRefWrapper(function () {\n            return \"\".concat(min.signal, \" - 1\");\n          });\n        }\n      }\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.maxStrokeWidth;\n    case 'text':\n      return config.scale.maxFontSize;\n    case 'point':\n    case 'square':\n    case 'circle':\n      {\n        if (config.scale.maxSize) {\n          return config.scale.maxSize;\n        }\n        var pointStep = minXYStep(size, xyStepSignals, config.view);\n        if (isNumber(pointStep)) {\n          return Math.pow(MAX_SIZE_RANGE_STEP_RATIO * pointStep, 2);\n        } else {\n          return new SignalRefWrapper(function () {\n            return \"pow(\".concat(MAX_SIZE_RANGE_STEP_RATIO, \" * \").concat(pointStep.signal, \", 2)\");\n          });\n        }\n      }\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMax not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n/**\n * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.\n */\nfunction minXYStep(size, xyStepSignals, viewConfig) {\n  var widthStep = isStep(size.width) ? size.width.step : getViewConfigDiscreteStep(viewConfig, 'width');\n  var heightStep = isStep(size.height) ? size.height.step : getViewConfigDiscreteStep(viewConfig, 'height');\n  if (xyStepSignals.x || xyStepSignals.y) {\n    return new SignalRefWrapper(function () {\n      var exprs = [xyStepSignals.x ? xyStepSignals.x.signal : widthStep, xyStepSignals.y ? xyStepSignals.y.signal : heightStep];\n      return \"min(\".concat(exprs.join(', '), \")\");\n    });\n  }\n  return Math.min(widthStep, heightStep);\n}","map":{"version":3,"sources":["../../../../src/compile/scale/range.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray, isNumber, isObject } from 'vega-util';\nimport { isBinning } from '../../bin';\nimport { ANGLE, COLOR, FILL, FILLOPACITY, getOffsetScaleChannel, getSizeChannel, isXorY, isXorYOffset, OPACITY, RADIUS, SCALE_CHANNELS, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH, THETA, X, XOFFSET, Y, YOFFSET } from '../../channel';\nimport { getFieldOrDatumDef, isFieldOrDatumDef } from '../../channeldef';\nimport { getViewConfigDiscreteSize, getViewConfigDiscreteStep } from '../../config';\nimport { DataSourceType } from '../../data';\nimport { channelHasFieldOrDatum } from '../../encoding';\nimport * as log from '../../log';\nimport { channelScalePropertyIncompatability, hasContinuousDomain, hasDiscreteDomain, isContinuousToDiscrete, isExtendedScheme, scaleTypeSupportProperty } from '../../scale';\nimport { getStepFor, isStep } from '../../spec/base';\nimport { isDiscrete } from '../../type';\nimport * as util from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { exprFromSignalRefOrValue, signalOrStringValue } from '../common';\nimport { getBinSignalName } from '../data/bin';\nimport { SignalRefWrapper } from '../signal';\nimport { makeExplicit, makeImplicit } from '../split';\nexport const RANGE_PROPERTIES = ['range', 'scheme'];\nexport function parseUnitScaleRange(model) {\n    const localScaleComponents = model.component.scales;\n    // use SCALE_CHANNELS instead of scales[channel] to ensure that x, y come first!\n    for (const channel of SCALE_CHANNELS) {\n        const localScaleCmpt = localScaleComponents[channel];\n        if (!localScaleCmpt) {\n            continue;\n        }\n        const rangeWithExplicit = parseRangeForChannel(channel, model);\n        localScaleCmpt.setWithExplicit('range', rangeWithExplicit);\n    }\n}\nfunction getBinStepSignal(model, channel) {\n    const fieldDef = model.fieldDef(channel);\n    if (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) {\n        const { bin, field } = fieldDef;\n        const sizeType = getSizeChannel(channel);\n        const sizeSignal = model.getName(sizeType);\n        if (isObject(bin) && bin.binned && bin.step !== undefined) {\n            return new SignalRefWrapper(() => {\n                const scaleName = model.scaleName(channel);\n                const binCount = `(domain(\"${scaleName}\")[1] - domain(\"${scaleName}\")[0]) / ${bin.step}`;\n                return `${model.getSignalName(sizeSignal)} / (${binCount})`;\n            });\n        }\n        else if (isBinning(bin)) {\n            const binSignal = getBinSignalName(model, field, bin);\n            // TODO: extract this to be range step signal\n            return new SignalRefWrapper(() => {\n                const updatedName = model.getSignalName(binSignal);\n                const binCount = `(${updatedName}.stop - ${updatedName}.start) / ${updatedName}.step`;\n                return `${model.getSignalName(sizeSignal)} / (${binCount})`;\n            });\n        }\n    }\n    return undefined;\n}\n/**\n * Return mixins that includes one of the Vega range types (explicit range, range.step, range.scheme).\n */\nexport function parseRangeForChannel(channel, model) {\n    const specifiedScale = model.specifiedScales[channel];\n    const { size } = model;\n    const mergedScaleCmpt = model.getScaleComponent(channel);\n    const scaleType = mergedScaleCmpt.get('type');\n    // Check if any of the range properties is specified.\n    // If so, check if it is compatible and make sure that we only output one of the properties\n    for (const property of RANGE_PROPERTIES) {\n        if (specifiedScale[property] !== undefined) {\n            const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n            const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n            if (!supportedByScaleType) {\n                log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n            }\n            else if (channelIncompatability) {\n                // channel\n                log.warn(channelIncompatability);\n            }\n            else {\n                switch (property) {\n                    case 'range': {\n                        const range = specifiedScale.range;\n                        if (isArray(range)) {\n                            if (isXorY(channel)) {\n                                return makeExplicit(range.map(v => {\n                                    if (v === 'width' || v === 'height') {\n                                        // get signal for width/height\n                                        // Just like default range logic below, we use SignalRefWrapper to account for potential merges and renames.\n                                        const sizeSignal = model.getName(v);\n                                        const getSignalName = model.getSignalName.bind(model);\n                                        return SignalRefWrapper.fromName(getSignalName, sizeSignal);\n                                    }\n                                    return v;\n                                }));\n                            }\n                        }\n                        else if (isObject(range)) {\n                            return makeExplicit({\n                                data: model.requestDataName(DataSourceType.Main),\n                                field: range.field,\n                                sort: { op: 'min', field: model.vgField(channel) }\n                            });\n                        }\n                        return makeExplicit(range);\n                    }\n                    case 'scheme':\n                        return makeExplicit(parseScheme(specifiedScale[property]));\n                }\n            }\n        }\n    }\n    const sizeChannel = channel === X || channel === 'xOffset' ? 'width' : 'height';\n    const sizeValue = size[sizeChannel];\n    if (isStep(sizeValue)) {\n        if (isXorY(channel)) {\n            if (hasDiscreteDomain(scaleType)) {\n                const step = getPositionStep(sizeValue, model, channel);\n                // Need to be explicit so layer with step wins over layer without step\n                if (step) {\n                    return makeExplicit({ step });\n                }\n            }\n            else {\n                log.warn(log.message.stepDropped(sizeChannel));\n            }\n        }\n        else if (isXorYOffset(channel)) {\n            const positionChannel = channel === XOFFSET ? 'x' : 'y';\n            const positionScaleCmpt = model.getScaleComponent(positionChannel);\n            const positionScaleType = positionScaleCmpt.get('type');\n            if (positionScaleType === 'band') {\n                const step = getOffsetStep(sizeValue, scaleType);\n                if (step) {\n                    return makeExplicit(step);\n                }\n            }\n        }\n    }\n    const { rangeMin, rangeMax } = specifiedScale;\n    const d = defaultRange(channel, model);\n    if ((rangeMin !== undefined || rangeMax !== undefined) &&\n        // it's ok to check just rangeMin's compatibility since rangeMin/rangeMax are the same\n        scaleTypeSupportProperty(scaleType, 'rangeMin') &&\n        isArray(d) &&\n        d.length === 2) {\n        return makeExplicit([rangeMin !== null && rangeMin !== void 0 ? rangeMin : d[0], rangeMax !== null && rangeMax !== void 0 ? rangeMax : d[1]]);\n    }\n    return makeImplicit(d);\n}\nfunction parseScheme(scheme) {\n    if (isExtendedScheme(scheme)) {\n        return Object.assign({ scheme: scheme.name }, util.omit(scheme, ['name']));\n    }\n    return { scheme };\n}\nfunction defaultRange(channel, model) {\n    const { size, config, mark, encoding } = model;\n    const getSignalName = model.getSignalName.bind(model);\n    const { type } = getFieldOrDatumDef(encoding[channel]);\n    const mergedScaleCmpt = model.getScaleComponent(channel);\n    const scaleType = mergedScaleCmpt.get('type');\n    const { domain, domainMid } = model.specifiedScales[channel];\n    switch (channel) {\n        case X:\n        case Y: {\n            // If there is no explicit width/height for discrete x/y scales\n            if (util.contains(['point', 'band'], scaleType)) {\n                const positionSize = getDiscretePositionSize(channel, size, config.view);\n                if (isStep(positionSize)) {\n                    const step = getPositionStep(positionSize, model, channel);\n                    return { step };\n                }\n            }\n            // If step is null, use zero to width or height.\n            // Note that we use SignalRefWrapper to account for potential merges and renames.\n            const sizeType = getSizeChannel(channel);\n            const sizeSignal = model.getName(sizeType);\n            if (channel === Y && hasContinuousDomain(scaleType)) {\n                // For y continuous scale, we have to start from the height as the bottom part has the max value.\n                return [SignalRefWrapper.fromName(getSignalName, sizeSignal), 0];\n            }\n            else {\n                return [0, SignalRefWrapper.fromName(getSignalName, sizeSignal)];\n            }\n        }\n        case XOFFSET:\n        case YOFFSET:\n            return getOffsetRange(channel, model, scaleType);\n        case SIZE: {\n            // TODO: support custom rangeMin, rangeMax\n            const zero = model.component.scales[channel].get('zero');\n            const rangeMin = sizeRangeMin(mark, zero, config);\n            const rangeMax = sizeRangeMax(mark, size, model, config);\n            if (isContinuousToDiscrete(scaleType)) {\n                return interpolateRange(rangeMin, rangeMax, defaultContinuousToDiscreteCount(scaleType, config, domain, channel));\n            }\n            else {\n                return [rangeMin, rangeMax];\n            }\n        }\n        case THETA:\n            return [0, Math.PI * 2];\n        case ANGLE:\n            // TODO: add config.scale.min/maxAngleDegree (for point and text) and config.scale.min/maxAngleRadian (for arc) once we add arc marks.\n            // (It's weird to add just config.scale.min/maxAngleDegree for now)\n            return [0, 360];\n        case RADIUS: {\n            // max radius = half od min(width,height)\n            return [\n                0,\n                new SignalRefWrapper(() => {\n                    const w = model.getSignalName('width');\n                    const h = model.getSignalName('height');\n                    return `min(${w},${h})/2`;\n                })\n            ];\n        }\n        case STROKEWIDTH:\n            // TODO: support custom rangeMin, rangeMax\n            return [config.scale.minStrokeWidth, config.scale.maxStrokeWidth];\n        case STROKEDASH:\n            return [\n                // TODO: add this to Vega's config.range?\n                [1, 0],\n                [4, 2],\n                [2, 1],\n                [1, 1],\n                [1, 2, 4, 2]\n            ];\n        case SHAPE:\n            return 'symbol';\n        case COLOR:\n        case FILL:\n        case STROKE:\n            if (scaleType === 'ordinal') {\n                // Only nominal data uses ordinal scale by default\n                return type === 'nominal' ? 'category' : 'ordinal';\n            }\n            else {\n                if (domainMid !== undefined) {\n                    return 'diverging';\n                }\n                else {\n                    return mark === 'rect' || mark === 'geoshape' ? 'heatmap' : 'ramp';\n                }\n            }\n        case OPACITY:\n        case FILLOPACITY:\n        case STROKEOPACITY:\n            // TODO: support custom rangeMin, rangeMax\n            return [config.scale.minOpacity, config.scale.maxOpacity];\n    }\n}\nfunction getPositionStep(step, model, channel) {\n    var _a, _b, _c, _d, _e;\n    const { encoding } = model;\n    const mergedScaleCmpt = model.getScaleComponent(channel);\n    const offsetChannel = getOffsetScaleChannel(channel);\n    const offsetDef = encoding[offsetChannel];\n    const stepFor = getStepFor({ step, offsetIsDiscrete: isFieldOrDatumDef(offsetDef) && isDiscrete(offsetDef.type) });\n    if (stepFor === 'offset' && channelHasFieldOrDatum(encoding, offsetChannel)) {\n        const offsetScaleCmpt = model.getScaleComponent(offsetChannel);\n        const offsetScaleName = model.scaleName(offsetChannel);\n        let stepCount = `domain('${offsetScaleName}').length`;\n        if (offsetScaleCmpt.get('type') === 'band') {\n            const offsetPaddingInner = (_b = (_a = offsetScaleCmpt.get('paddingInner')) !== null && _a !== void 0 ? _a : offsetScaleCmpt.get('padding')) !== null && _b !== void 0 ? _b : 0;\n            const offsetPaddingOuter = (_d = (_c = offsetScaleCmpt.get('paddingOuter')) !== null && _c !== void 0 ? _c : offsetScaleCmpt.get('padding')) !== null && _d !== void 0 ? _d : 0;\n            stepCount = `bandspace(${stepCount}, ${offsetPaddingInner}, ${offsetPaddingOuter})`;\n        }\n        const paddingInner = (_e = mergedScaleCmpt.get('paddingInner')) !== null && _e !== void 0 ? _e : mergedScaleCmpt.get('padding');\n        return {\n            signal: `${step.step} * ${stepCount} / (1-${exprFromSignalRefOrValue(paddingInner)})`\n        };\n    }\n    else {\n        return step.step;\n    }\n}\nfunction getOffsetStep(step, offsetScaleType) {\n    const stepFor = getStepFor({ step, offsetIsDiscrete: hasDiscreteDomain(offsetScaleType) });\n    if (stepFor === 'offset') {\n        return { step: step.step };\n    }\n    return undefined;\n}\nfunction getOffsetRange(channel, model, offsetScaleType) {\n    const positionChannel = channel === XOFFSET ? 'x' : 'y';\n    const positionScaleCmpt = model.getScaleComponent(positionChannel);\n    const positionScaleType = positionScaleCmpt.get('type');\n    const positionScaleName = model.scaleName(positionChannel);\n    if (positionScaleType === 'band') {\n        const size = getDiscretePositionSize(positionChannel, model.size, model.config.view);\n        if (isStep(size)) {\n            // step is for offset\n            const step = getOffsetStep(size, offsetScaleType);\n            if (step) {\n                return step;\n            }\n        }\n        // otherwise use the position\n        return [0, { signal: `bandwidth('${positionScaleName}')` }];\n    }\n    else {\n        // continuous scale\n        return util.never(`Cannot use ${channel} scale if ${positionChannel} scale is not discrete.`);\n    }\n}\nfunction getDiscretePositionSize(channel, size, viewConfig) {\n    const sizeChannel = channel === X ? 'width' : 'height';\n    const sizeValue = size[sizeChannel];\n    if (sizeValue) {\n        return sizeValue;\n    }\n    return getViewConfigDiscreteSize(viewConfig, sizeChannel);\n}\nexport function defaultContinuousToDiscreteCount(scaleType, config, domain, channel) {\n    switch (scaleType) {\n        case 'quantile':\n            return config.scale.quantileCount;\n        case 'quantize':\n            return config.scale.quantizeCount;\n        case 'threshold':\n            if (domain !== undefined && isArray(domain)) {\n                return domain.length + 1;\n            }\n            else {\n                log.warn(log.message.domainRequiredForThresholdScale(channel));\n                // default threshold boundaries for threshold scale since domain has cardinality of 2\n                return 3;\n            }\n    }\n}\n/**\n * Returns the linear interpolation of the range according to the cardinality\n *\n * @param rangeMin start of the range\n * @param rangeMax end of the range\n * @param cardinality number of values in the output range\n */\nexport function interpolateRange(rangeMin, rangeMax, cardinality) {\n    // always return a signal since it's better to compute the sequence in Vega later\n    const f = () => {\n        const rMax = signalOrStringValue(rangeMax);\n        const rMin = signalOrStringValue(rangeMin);\n        const step = `(${rMax} - ${rMin}) / (${cardinality} - 1)`;\n        return `sequence(${rMin}, ${rMax} + ${step}, ${step})`;\n    };\n    if (isSignalRef(rangeMax)) {\n        return new SignalRefWrapper(f);\n    }\n    else {\n        return { signal: f() };\n    }\n}\nfunction sizeRangeMin(mark, zero, config) {\n    if (zero) {\n        if (isSignalRef(zero)) {\n            return { signal: `${zero.signal} ? 0 : ${sizeRangeMin(mark, false, config)}` };\n        }\n        else {\n            return 0;\n        }\n    }\n    switch (mark) {\n        case 'bar':\n        case 'tick':\n            return config.scale.minBandSize;\n        case 'line':\n        case 'trail':\n        case 'rule':\n            return config.scale.minStrokeWidth;\n        case 'text':\n            return config.scale.minFontSize;\n        case 'point':\n        case 'square':\n        case 'circle':\n            return config.scale.minSize;\n    }\n    /* istanbul ignore next: should never reach here */\n    // sizeRangeMin not implemented for the mark\n    throw new Error(log.message.incompatibleChannel('size', mark));\n}\nexport const MAX_SIZE_RANGE_STEP_RATIO = 0.95;\nfunction sizeRangeMax(mark, size, model, config) {\n    const xyStepSignals = {\n        x: getBinStepSignal(model, 'x'),\n        y: getBinStepSignal(model, 'y')\n    };\n    switch (mark) {\n        case 'bar':\n        case 'tick': {\n            if (config.scale.maxBandSize !== undefined) {\n                return config.scale.maxBandSize;\n            }\n            const min = minXYStep(size, xyStepSignals, config.view);\n            if (isNumber(min)) {\n                return min - 1;\n            }\n            else {\n                return new SignalRefWrapper(() => `${min.signal} - 1`);\n            }\n        }\n        case 'line':\n        case 'trail':\n        case 'rule':\n            return config.scale.maxStrokeWidth;\n        case 'text':\n            return config.scale.maxFontSize;\n        case 'point':\n        case 'square':\n        case 'circle': {\n            if (config.scale.maxSize) {\n                return config.scale.maxSize;\n            }\n            const pointStep = minXYStep(size, xyStepSignals, config.view);\n            if (isNumber(pointStep)) {\n                return Math.pow(MAX_SIZE_RANGE_STEP_RATIO * pointStep, 2);\n            }\n            else {\n                return new SignalRefWrapper(() => `pow(${MAX_SIZE_RANGE_STEP_RATIO} * ${pointStep.signal}, 2)`);\n            }\n        }\n    }\n    /* istanbul ignore next: should never reach here */\n    // sizeRangeMax not implemented for the mark\n    throw new Error(log.message.incompatibleChannel('size', mark));\n}\n/**\n * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.\n */\nfunction minXYStep(size, xyStepSignals, viewConfig) {\n    const widthStep = isStep(size.width) ? size.width.step : getViewConfigDiscreteStep(viewConfig, 'width');\n    const heightStep = isStep(size.height) ? size.height.step : getViewConfigDiscreteStep(viewConfig, 'height');\n    if (xyStepSignals.x || xyStepSignals.y) {\n        return new SignalRefWrapper(() => {\n            const exprs = [\n                xyStepSignals.x ? xyStepSignals.x.signal : widthStep,\n                xyStepSignals.y ? xyStepSignals.y.signal : heightStep\n            ];\n            return `min(${exprs.join(', ')})`;\n        });\n    }\n    return Math.min(widthStep, heightStep);\n}\n//# sourceMappingURL=range.js.map"]},"metadata":{},"sourceType":"module"}