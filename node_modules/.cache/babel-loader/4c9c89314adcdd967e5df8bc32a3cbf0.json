{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _defineProperty from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { array, isObject } from 'vega-util';\nimport { isSingleDefUnitChannel } from '../../channel';\nimport * as log from '../../log';\nimport { hasContinuousDomain } from '../../scale';\nimport { SELECTION_ID } from '../../selection';\nimport { hash, keys, replacePathInField, varName, isEmpty } from '../../util';\nimport { TimeUnitNode } from '../data/timeunit';\nexport var TUPLE_FIELDS = '_tuple_fields';\nexport var SelectionProjectionComponent = /*#__PURE__*/_createClass(function SelectionProjectionComponent() {\n  _classCallCheck(this, SelectionProjectionComponent);\n  for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n    items[_key] = arguments[_key];\n  }\n  this.items = items;\n  this.hasChannel = {};\n  this.hasField = {};\n  this.hasSelectionId = false;\n});\nvar project = {\n  defined: function defined() {\n    return true; // This transform handles its own defaults, so always run parse.\n  },\n\n  parse: function parse(model, selCmpt, selDef) {\n    var _a;\n    var name = selCmpt.name;\n    var proj = (_a = selCmpt.project) !== null && _a !== void 0 ? _a : selCmpt.project = new SelectionProjectionComponent();\n    var parsed = {};\n    var timeUnits = {};\n    var signals = new Set();\n    var signalName = function signalName(p, range) {\n      var suffix = range === 'visual' ? p.channel : p.field;\n      var sg = varName(\"\".concat(name, \"_\").concat(suffix));\n      for (var counter = 1; signals.has(sg); counter++) {\n        sg = varName(\"\".concat(name, \"_\").concat(suffix, \"_\").concat(counter));\n      }\n      signals.add(sg);\n      return _defineProperty({}, range, sg);\n    };\n    var type = selCmpt.type;\n    var cfg = model.config.selection[type];\n    var init = selDef.value !== undefined ? array(selDef.value) : null;\n    // If no explicit projection (either fields or encodings) is specified, set some defaults.\n    // If an initial value is set, try to infer projections.\n    var _ref2 = isObject(selDef.select) ? selDef.select : {},\n      fields = _ref2.fields,\n      encodings = _ref2.encodings;\n    if (!fields && !encodings && init) {\n      var _iterator = _createForOfIteratorHelper(init),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var initVal = _step.value;\n          // initVal may be a scalar value to smoothen varParam -> pointSelection gradient.\n          if (!isObject(initVal)) {\n            continue;\n          }\n          var _iterator2 = _createForOfIteratorHelper(keys(initVal)),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var key = _step2.value;\n              if (isSingleDefUnitChannel(key)) {\n                (encodings || (encodings = [])).push(key);\n              } else {\n                if (type === 'interval') {\n                  log.warn(log.message.INTERVAL_INITIALIZED_WITH_X_Y);\n                  encodings = cfg.encodings;\n                } else {\n                  (fields || (fields = [])).push(key);\n                }\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    // If no initial value is specified, use the default configuration.\n    // We break this out as a separate if block (instead of an else condition)\n    // to account for unprojected point selections that have scalar initial values\n    if (!fields && !encodings) {\n      encodings = cfg.encodings;\n      if ('fields' in cfg) {\n        fields = cfg.fields;\n      }\n    }\n    var _iterator3 = _createForOfIteratorHelper(encodings !== null && encodings !== void 0 ? encodings : []),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var channel = _step3.value;\n        var fieldDef = model.fieldDef(channel);\n        if (fieldDef) {\n          var field = fieldDef.field;\n          if (fieldDef.aggregate) {\n            log.warn(log.message.cannotProjectAggregate(channel, fieldDef.aggregate));\n            continue;\n          } else if (!field) {\n            log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n            continue;\n          }\n          if (fieldDef.timeUnit) {\n            field = model.vgField(channel);\n            // Construct TimeUnitComponents which will be combined into a\n            // TimeUnitNode. This node may need to be inserted into the\n            // dataflow if the selection is used across views that do not\n            // have these time units defined.\n            var component = {\n              timeUnit: fieldDef.timeUnit,\n              as: field,\n              field: fieldDef.field\n            };\n            timeUnits[hash(component)] = component;\n          }\n          // Prevent duplicate projections on the same field.\n          // TODO: what if the same field is bound to multiple channels (e.g., SPLOM diag).\n          if (!parsed[field]) {\n            // Determine whether the tuple will store enumerated or ranged values.\n            // Interval selections store ranges for continuous scales, and enumerations otherwise.\n            // Single/multi selections store ranges for binned fields, and enumerations otherwise.\n            var tplType = 'E';\n            if (type === 'interval') {\n              var scaleType = model.getScaleComponent(channel).get('type');\n              if (hasContinuousDomain(scaleType)) {\n                tplType = 'R';\n              }\n            } else if (fieldDef.bin) {\n              tplType = 'R-RE';\n            }\n            var p = {\n              field: field,\n              channel: channel,\n              type: tplType\n            };\n            p.signals = Object.assign(Object.assign({}, signalName(p, 'data')), signalName(p, 'visual'));\n            proj.items.push(parsed[field] = p);\n            proj.hasField[field] = proj.hasChannel[channel] = parsed[field];\n            proj.hasSelectionId = proj.hasSelectionId || field === SELECTION_ID;\n          }\n        } else {\n          log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    var _iterator4 = _createForOfIteratorHelper(fields !== null && fields !== void 0 ? fields : []),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _field = _step4.value;\n        if (proj.hasField[_field]) continue;\n        var _p = {\n          type: 'E',\n          field: _field\n        };\n        _p.signals = Object.assign({}, signalName(_p, 'data'));\n        proj.items.push(_p);\n        proj.hasField[_field] = _p;\n        proj.hasSelectionId = proj.hasSelectionId || _field === SELECTION_ID;\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n    if (init) {\n      selCmpt.init = init.map(function (v) {\n        // Selections can be initialized either with a full object that maps projections to values\n        // or scalar values to smoothen the abstraction gradient from variable params to point selections.\n        return proj.items.map(function (p) {\n          return isObject(v) ? v[p.channel] !== undefined ? v[p.channel] : v[p.field] : v;\n        });\n      });\n    }\n    if (!isEmpty(timeUnits)) {\n      proj.timeUnit = new TimeUnitNode(null, timeUnits);\n    }\n  },\n  signals: function signals(model, selCmpt, allSignals) {\n    var name = selCmpt.name + TUPLE_FIELDS;\n    var hasSignal = allSignals.filter(function (s) {\n      return s.name === name;\n    });\n    return hasSignal.length > 0 || selCmpt.project.hasSelectionId ? allSignals : allSignals.concat({\n      name: name,\n      value: selCmpt.project.items.map(function (proj) {\n        var signals = proj.signals,\n          hasLegend = proj.hasLegend,\n          rest = __rest(proj, [\"signals\", \"hasLegend\"]);\n        rest.field = replacePathInField(rest.field);\n        return rest;\n      })\n    });\n  }\n};\nexport default project;","map":{"version":3,"sources":["../../../../src/compile/selection/project.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA,SAAQ,KAAK,EAAE,QAAQ,QAAO,WAAW;AACzC,SAAQ,sBAAsB,QAA2C,eAAe;AACxF,OAAO,KAAK,GAAG,MAAM,WAAW;AAChC,SAAQ,mBAAmB,QAAO,aAAa;AAC/C,SAAkF,YAAY,QAAO,iBAAiB;AACtH,SAAc,IAAI,EAAE,IAAI,EAAE,kBAAkB,EAAE,OAAO,EAAE,OAAO,QAAO,YAAY;AACjF,SAA2B,YAAY,QAAO,kBAAkB;AAEhE,OAAO,IAAM,YAAY,GAAG,eAAe;AAqB3C,WAAa,4BAA4B,6BAOvC,wCAA2C;EAAA;EAAA,kCAA5B,KAA4B;IAA5B,KAA4B;EAAA;EACzC,IAAI,CAAC,KAAK,GAAG,KAAK;EAClB,IAAI,CAAC,UAAU,GAAG,CAAA,CAAE;EACpB,IAAI,CAAC,QAAQ,GAAG,CAAA,CAAE;EAClB,IAAI,CAAC,cAAc,GAAG,KAAK;AAC7B,CAAC;AAGH,IAAM,OAAO,GAAsB;EACjC,OAAO,EAAE,mBAAK;IACZ,OAAO,IAAI,CAAC,CAAC;EACf,CAAC;;EAED,KAAK,EAAE,eAAC,KAAK,EAAE,OAAO,EAAE,MAAM,EAAI;;IAChC,IAAM,IAAI,GAAG,OAAO,CAAC,IAAI;IACzB,IAAM,IAAI,GAAG,CAAA,EAAA,GAAC,OAAO,CAAC,OAAO,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAf,OAAO,CAAC,OAAO,GAAK,IAAI,4BAA4B,EAAG;IACrE,IAAM,MAAM,GAA8B,CAAA,CAAE;IAC5C,IAAM,SAAS,GAA4B,CAAA,CAAE;IAE7C,IAAM,OAAO,GAAG,IAAI,GAAG,EAAU;IACjC,IAAM,UAAU,GAAG,SAAb,UAAU,CAAI,CAAsB,EAAE,KAAwB,EAAI;MACtE,IAAM,MAAM,GAAG,KAAK,KAAK,QAAQ,GAAG,CAAC,CAAC,OAAO,GAAG,CAAC,CAAC,KAAK;MACvD,IAAI,EAAE,GAAG,OAAO,WAAI,IAAI,cAAI,MAAM,EAAG;MACrC,KAAK,IAAI,OAAO,GAAG,CAAC,EAAE,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,OAAO,EAAE,EAAE;QAChD,EAAE,GAAG,OAAO,WAAI,IAAI,cAAI,MAAM,cAAI,OAAO,EAAG;MAC7C;MACD,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC;MACf,2BAAS,KAAK,EAAG,EAAE;IACrB,CAAC;IAED,IAAM,IAAI,GAAG,OAAO,CAAC,IAAI;IACzB,IAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC;IACxC,IAAM,IAAI,GACR,MAAM,CAAC,KAAK,KAAK,SAAS,GACrB,KAAK,CAAC,MAAM,CAAC,KAAY,CAA6D,GACvF,IAAI;IAEV;IACA;IACA,YAA2B,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC,MAAM,GAAG,CAAA,CAAE;MAAlE,MAAM,SAAN,MAAM;MAAE,SAAS,SAAT,SAAS;IACtB,IAAI,CAAC,MAAM,IAAI,CAAC,SAAS,IAAI,IAAI,EAAE;MAAA,2CACX,IAAI;QAAA;MAAA;QAA1B,oDAA4B;UAAA,IAAjB,OAAO;UAChB;UACA,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE;YACtB;;UACD,4CAEiB,IAAI,CAAC,OAAO,CAAC;YAAA;UAAA;YAA/B,uDAAiC;cAAA,IAAtB,GAAG;cACZ,IAAI,sBAAsB,CAAC,GAAG,CAAC,EAAE;gBAC/B,CAAC,SAAS,KAAK,SAAS,GAAG,EAAE,CAAC,EAAE,IAAI,CAAC,GAA2B,CAAC;eAClE,MAAM;gBACL,IAAI,IAAI,KAAK,UAAU,EAAE;kBACvB,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,6BAA6B,CAAC;kBACnD,SAAS,GAAG,GAAG,CAAC,SAAS;iBAC1B,MAAM;kBACL,CAAC,MAAM,KAAK,MAAM,GAAG,EAAE,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC;gBACpC;cACF;;UACF;YAAA;UAAA;YAAA;UAAA;;MACF;QAAA;MAAA;QAAA;MAAA;IACF;IAED;IACA;IACA;IACA,IAAI,CAAC,MAAM,IAAI,CAAC,SAAS,EAAE;MACzB,SAAS,GAAG,GAAG,CAAC,SAAS;MACzB,IAAI,QAAQ,IAAI,GAAG,EAAE;QACnB,MAAM,GAAG,GAAG,CAAC,MAAM;MACpB;;IACF,4CAEqB,SAAS,KAAA,IAAA,IAAT,SAAS,KAAA,KAAA,CAAA,GAAT,SAAS,GAAI,EAAE;MAAA;IAAA;MAArC,uDAAuC;QAAA,IAA5B,OAAO;QAChB,IAAM,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAC;QACxC,IAAI,QAAQ,EAAE;UACZ,IAAI,KAAK,GAAG,QAAQ,CAAC,KAAK;UAE1B,IAAI,QAAQ,CAAC,SAAS,EAAE;YACtB,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,sBAAsB,CAAC,OAAO,EAAE,QAAQ,CAAC,SAAS,CAAC,CAAC;YACzE;WACD,MAAM,IAAI,CAAC,KAAK,EAAE;YACjB,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,kCAAkC,CAAC,OAAO,CAAC,CAAC;YACjE;UACD;UAED,IAAI,QAAQ,CAAC,QAAQ,EAAE;YACrB,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC;YAC9B;YACA;YACA;YACA;YACA,IAAM,SAAS,GAAG;cAChB,QAAQ,EAAE,QAAQ,CAAC,QAAQ;cAC3B,EAAE,EAAE,KAAK;cACT,KAAK,EAAE,QAAQ,CAAC;aACjB;YAED,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,GAAG,SAAS;UACvC;UAED;UACA;UACA,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE;YAClB;YACA;YACA;YACA,IAAI,OAAO,GAAmB,GAAG;YACjC,IAAI,IAAI,KAAK,UAAU,EAAE;cACvB,IAAM,SAAS,GAAG,KAAK,CAAC,iBAAiB,CAAC,OAAuB,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC;cAC9E,IAAI,mBAAmB,CAAC,SAAS,CAAC,EAAE;gBAClC,OAAO,GAAG,GAAG;cACd;aACF,MAAM,IAAI,QAAQ,CAAC,GAAG,EAAE;cACvB,OAAO,GAAG,MAAM;YACjB;YAED,IAAM,CAAC,GAAwB;cAAC,KAAK,EAAL,KAAK;cAAE,OAAO,EAAP,OAAO;cAAE,IAAI,EAAE;YAAO,CAAC;YAC9D,CAAC,CAAC,OAAO,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAO,UAAU,CAAC,CAAC,EAAE,MAAM,CAAC,CAAA,EAAK,UAAU,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;YAClE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAE;YACpC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC;YAC/D,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,cAAc,IAAI,KAAK,KAAK,YAAY;UACpE;SACF,MAAM;UACL,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,kCAAkC,CAAC,OAAO,CAAC,CAAC;QAClE;;IACF;MAAA;IAAA;MAAA;IAAA;IAAA,4CAEmB,MAAM,KAAA,IAAA,IAAN,MAAM,KAAA,KAAA,CAAA,GAAN,MAAM,GAAI,EAAE;MAAA;IAAA;MAAhC,uDAAkC;QAAA,IAAvB,MAAK;QACd,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAK,CAAC,EAAE;QAC1B,IAAM,EAAC,GAAwB;UAAC,IAAI,EAAE,GAAG;UAAE,KAAK,EAAL;QAAK,CAAC;QACjD,EAAC,CAAC,OAAO,GAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAO,UAAU,CAAC,EAAC,EAAE,MAAM,CAAC,CAAC;QACtC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAC,CAAC;QAClB,IAAI,CAAC,QAAQ,CAAC,MAAK,CAAC,GAAG,EAAC;QACxB,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,cAAc,IAAI,MAAK,KAAK,YAAY;;IACpE;MAAA;IAAA;MAAA;IAAA;IAED,IAAI,IAAI,EAAE;MACR,OAAO,CAAC,IAAI,GAAI,IAAY,CAAC,GAAG,CAAC,UAAC,CAAsD,EAAI;QAC1F;QACA;QACA,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,UAAA,CAAC;UAAA,OAAK,QAAQ,CAAC,CAAC,CAAC,GAAI,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAI,CAAC;QAAA,CAAC,CAAC;MAC1G,CAAC,CAAC;IACH;IAED,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE;MACvB,IAAI,CAAC,QAAQ,GAAG,IAAI,YAAY,CAAC,IAAI,EAAE,SAAS,CAAC;IAClD;EACH,CAAC;EAED,OAAO,EAAE,iBAAC,KAAK,EAAE,OAAO,EAAE,UAAU,EAAI;IACtC,IAAM,IAAI,GAAG,OAAO,CAAC,IAAI,GAAG,YAAY;IACxC,IAAM,SAAS,GAAG,UAAU,CAAC,MAAM,CAAC,UAAA,CAAC;MAAA,OAAI,CAAC,CAAC,IAAI,KAAK,IAAI;IAAA,EAAC;IACzD,OAAO,SAAS,CAAC,MAAM,GAAG,CAAC,IAAI,OAAO,CAAC,OAAO,CAAC,cAAc,GACzD,UAAU,GACV,UAAU,CAAC,MAAM,CAAC;MAChB,IAAI,EAAJ,IAAI;MACJ,KAAK,EAAE,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,UAAA,IAAI,EAAG;QACtC,IAAO,OAAO,GAAwB,IAAI,CAAnC,OAAO;UAAE,SAAS,GAAa,IAAI,CAA1B,SAAS;UAAK,IAAI,GAAA,MAAA,CAAI,IAAI,EAApC,CAAA,SAAA,EAAA,WAAA,CAA6B,CAAO;QAC1C,IAAI,CAAC,KAAK,GAAG,kBAAkB,CAAC,IAAI,CAAC,KAAK,CAAC;QAC3C,OAAO,IAAI;MACb,CAAC;KACF,CAAC;EACR;CACD;AAED,eAAe,OAAO","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { array, isObject } from 'vega-util';\nimport { isSingleDefUnitChannel } from '../../channel';\nimport * as log from '../../log';\nimport { hasContinuousDomain } from '../../scale';\nimport { SELECTION_ID } from '../../selection';\nimport { hash, keys, replacePathInField, varName, isEmpty } from '../../util';\nimport { TimeUnitNode } from '../data/timeunit';\nexport const TUPLE_FIELDS = '_tuple_fields';\nexport class SelectionProjectionComponent {\n    constructor(...items) {\n        this.items = items;\n        this.hasChannel = {};\n        this.hasField = {};\n        this.hasSelectionId = false;\n    }\n}\nconst project = {\n    defined: () => {\n        return true; // This transform handles its own defaults, so always run parse.\n    },\n    parse: (model, selCmpt, selDef) => {\n        var _a;\n        const name = selCmpt.name;\n        const proj = ((_a = selCmpt.project) !== null && _a !== void 0 ? _a : (selCmpt.project = new SelectionProjectionComponent()));\n        const parsed = {};\n        const timeUnits = {};\n        const signals = new Set();\n        const signalName = (p, range) => {\n            const suffix = range === 'visual' ? p.channel : p.field;\n            let sg = varName(`${name}_${suffix}`);\n            for (let counter = 1; signals.has(sg); counter++) {\n                sg = varName(`${name}_${suffix}_${counter}`);\n            }\n            signals.add(sg);\n            return { [range]: sg };\n        };\n        const type = selCmpt.type;\n        const cfg = model.config.selection[type];\n        const init = selDef.value !== undefined\n            ? array(selDef.value)\n            : null;\n        // If no explicit projection (either fields or encodings) is specified, set some defaults.\n        // If an initial value is set, try to infer projections.\n        let { fields, encodings } = (isObject(selDef.select) ? selDef.select : {});\n        if (!fields && !encodings && init) {\n            for (const initVal of init) {\n                // initVal may be a scalar value to smoothen varParam -> pointSelection gradient.\n                if (!isObject(initVal)) {\n                    continue;\n                }\n                for (const key of keys(initVal)) {\n                    if (isSingleDefUnitChannel(key)) {\n                        (encodings || (encodings = [])).push(key);\n                    }\n                    else {\n                        if (type === 'interval') {\n                            log.warn(log.message.INTERVAL_INITIALIZED_WITH_X_Y);\n                            encodings = cfg.encodings;\n                        }\n                        else {\n                            (fields || (fields = [])).push(key);\n                        }\n                    }\n                }\n            }\n        }\n        // If no initial value is specified, use the default configuration.\n        // We break this out as a separate if block (instead of an else condition)\n        // to account for unprojected point selections that have scalar initial values\n        if (!fields && !encodings) {\n            encodings = cfg.encodings;\n            if ('fields' in cfg) {\n                fields = cfg.fields;\n            }\n        }\n        for (const channel of encodings !== null && encodings !== void 0 ? encodings : []) {\n            const fieldDef = model.fieldDef(channel);\n            if (fieldDef) {\n                let field = fieldDef.field;\n                if (fieldDef.aggregate) {\n                    log.warn(log.message.cannotProjectAggregate(channel, fieldDef.aggregate));\n                    continue;\n                }\n                else if (!field) {\n                    log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n                    continue;\n                }\n                if (fieldDef.timeUnit) {\n                    field = model.vgField(channel);\n                    // Construct TimeUnitComponents which will be combined into a\n                    // TimeUnitNode. This node may need to be inserted into the\n                    // dataflow if the selection is used across views that do not\n                    // have these time units defined.\n                    const component = {\n                        timeUnit: fieldDef.timeUnit,\n                        as: field,\n                        field: fieldDef.field\n                    };\n                    timeUnits[hash(component)] = component;\n                }\n                // Prevent duplicate projections on the same field.\n                // TODO: what if the same field is bound to multiple channels (e.g., SPLOM diag).\n                if (!parsed[field]) {\n                    // Determine whether the tuple will store enumerated or ranged values.\n                    // Interval selections store ranges for continuous scales, and enumerations otherwise.\n                    // Single/multi selections store ranges for binned fields, and enumerations otherwise.\n                    let tplType = 'E';\n                    if (type === 'interval') {\n                        const scaleType = model.getScaleComponent(channel).get('type');\n                        if (hasContinuousDomain(scaleType)) {\n                            tplType = 'R';\n                        }\n                    }\n                    else if (fieldDef.bin) {\n                        tplType = 'R-RE';\n                    }\n                    const p = { field, channel, type: tplType };\n                    p.signals = Object.assign(Object.assign({}, signalName(p, 'data')), signalName(p, 'visual'));\n                    proj.items.push((parsed[field] = p));\n                    proj.hasField[field] = proj.hasChannel[channel] = parsed[field];\n                    proj.hasSelectionId = proj.hasSelectionId || field === SELECTION_ID;\n                }\n            }\n            else {\n                log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n            }\n        }\n        for (const field of fields !== null && fields !== void 0 ? fields : []) {\n            if (proj.hasField[field])\n                continue;\n            const p = { type: 'E', field };\n            p.signals = Object.assign({}, signalName(p, 'data'));\n            proj.items.push(p);\n            proj.hasField[field] = p;\n            proj.hasSelectionId = proj.hasSelectionId || field === SELECTION_ID;\n        }\n        if (init) {\n            selCmpt.init = init.map((v) => {\n                // Selections can be initialized either with a full object that maps projections to values\n                // or scalar values to smoothen the abstraction gradient from variable params to point selections.\n                return proj.items.map(p => (isObject(v) ? (v[p.channel] !== undefined ? v[p.channel] : v[p.field]) : v));\n            });\n        }\n        if (!isEmpty(timeUnits)) {\n            proj.timeUnit = new TimeUnitNode(null, timeUnits);\n        }\n    },\n    signals: (model, selCmpt, allSignals) => {\n        const name = selCmpt.name + TUPLE_FIELDS;\n        const hasSignal = allSignals.filter(s => s.name === name);\n        return hasSignal.length > 0 || selCmpt.project.hasSelectionId\n            ? allSignals\n            : allSignals.concat({\n                name,\n                value: selCmpt.project.items.map(proj => {\n                    const { signals, hasLegend } = proj, rest = __rest(proj, [\"signals\", \"hasLegend\"]);\n                    rest.field = replacePathInField(rest.field);\n                    return rest;\n                })\n            });\n    }\n};\nexport default project;\n//# sourceMappingURL=project.js.map"]},"metadata":{},"sourceType":"module"}