{"ast":null,"code":"import _defineProperty from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { isNumber, isObject } from 'vega-util';\nimport { getMarkPropOrConfig } from '../compile/common';\nimport { extractTransformsFromEncoding, normalizeEncoding } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { isEmpty, omit } from '../util';\nimport { CompositeMarkNormalizer } from './base';\nimport { compositeMarkContinuousAxis, compositeMarkOrient, filterTooltipWithAggregatedField, getCompositeMarkTooltip, getTitle, makeCompositeAggregatePartFactory, partLayerMixins } from './common';\nexport var BOXPLOT = 'boxplot';\nexport var BOXPLOT_PARTS = ['box', 'median', 'outliers', 'rule', 'ticks'];\nexport var boxPlotNormalizer = new CompositeMarkNormalizer(BOXPLOT, normalizeBoxPlot);\nexport function getBoxPlotType(extent) {\n  if (isNumber(extent)) {\n    return 'tukey';\n  }\n  // Ham: If we ever want to, we could add another extent syntax `{kIQR: number}` for the original [Q1-k*IQR, Q3+k*IQR] whisker and call this boxPlotType = `kIQR`. However, I'm not exposing this for now.\n  return extent;\n}\nexport function normalizeBoxPlot(spec, _ref) {\n  var config = _ref.config;\n  var _a, _b;\n  // Need to initEncoding first so we can infer type\n  spec = Object.assign(Object.assign({}, spec), {\n    encoding: normalizeEncoding(spec.encoding, config)\n  });\n  var _spec = spec,\n    mark = _spec.mark,\n    _encoding = _spec.encoding,\n    params = _spec.params,\n    _p = _spec.projection,\n    outerSpec = __rest(spec, [\"mark\", \"encoding\", \"params\", \"projection\"]);\n  var markDef = isMarkDef(mark) ? mark : {\n    type: mark\n  };\n  // TODO(https://github.com/vega/vega-lite/issues/3702): add selection support\n  if (params) {\n    log.warn(log.message.selectionNotSupported('boxplot'));\n  }\n  var extent = (_a = markDef.extent) !== null && _a !== void 0 ? _a : config.boxplot.extent;\n  var sizeValue = getMarkPropOrConfig('size', markDef,\n  // TODO: https://github.com/vega/vega-lite/issues/6245\n  config);\n  var invalid = markDef.invalid;\n  var boxPlotType = getBoxPlotType(extent);\n  var _boxParams = boxParams(spec, extent, config),\n    bins = _boxParams.bins,\n    timeUnits = _boxParams.timeUnits,\n    transform = _boxParams.transform,\n    continuousAxisChannelDef = _boxParams.continuousAxisChannelDef,\n    continuousAxis = _boxParams.continuousAxis,\n    groupby = _boxParams.groupby,\n    aggregate = _boxParams.aggregate,\n    encodingWithoutContinuousAxis = _boxParams.encodingWithoutContinuousAxis,\n    ticksOrient = _boxParams.ticksOrient,\n    boxOrient = _boxParams.boxOrient,\n    customTooltipWithoutAggregatedField = _boxParams.customTooltipWithoutAggregatedField;\n  var color = encodingWithoutContinuousAxis.color,\n    size = encodingWithoutContinuousAxis.size,\n    encodingWithoutSizeColorAndContinuousAxis = __rest(encodingWithoutContinuousAxis, [\"color\", \"size\"]);\n  var makeBoxPlotPart = function makeBoxPlotPart(sharedEncoding) {\n    return makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, config.boxplot);\n  };\n  var makeBoxPlotExtent = makeBoxPlotPart(encodingWithoutSizeColorAndContinuousAxis);\n  var makeBoxPlotBox = makeBoxPlotPart(encodingWithoutContinuousAxis);\n  var makeBoxPlotMidTick = makeBoxPlotPart(Object.assign(Object.assign({}, encodingWithoutSizeColorAndContinuousAxis), size ? {\n    size: size\n  } : {}));\n  var fiveSummaryTooltipEncoding = getCompositeMarkTooltip([{\n    fieldPrefix: boxPlotType === 'min-max' ? 'upper_whisker_' : 'max_',\n    titlePrefix: 'Max'\n  }, {\n    fieldPrefix: 'upper_box_',\n    titlePrefix: 'Q3'\n  }, {\n    fieldPrefix: 'mid_box_',\n    titlePrefix: 'Median'\n  }, {\n    fieldPrefix: 'lower_box_',\n    titlePrefix: 'Q1'\n  }, {\n    fieldPrefix: boxPlotType === 'min-max' ? 'lower_whisker_' : 'min_',\n    titlePrefix: 'Min'\n  }], continuousAxisChannelDef, encodingWithoutContinuousAxis);\n  // ## Whisker Layers\n  var endTick = {\n    type: 'tick',\n    color: 'black',\n    opacity: 1,\n    orient: ticksOrient,\n    invalid: invalid,\n    aria: false\n  };\n  var whiskerTooltipEncoding = boxPlotType === 'min-max' ? fiveSummaryTooltipEncoding // for min-max, show five-summary tooltip for whisker\n  :\n  // for tukey / k-IQR, just show upper/lower-whisker\n  getCompositeMarkTooltip([{\n    fieldPrefix: 'upper_whisker_',\n    titlePrefix: 'Upper Whisker'\n  }, {\n    fieldPrefix: 'lower_whisker_',\n    titlePrefix: 'Lower Whisker'\n  }], continuousAxisChannelDef, encodingWithoutContinuousAxis);\n  var whiskerLayers = [].concat(_toConsumableArray(makeBoxPlotExtent({\n    partName: 'rule',\n    mark: {\n      type: 'rule',\n      invalid: invalid,\n      aria: false\n    },\n    positionPrefix: 'lower_whisker',\n    endPositionPrefix: 'lower_box',\n    extraEncoding: whiskerTooltipEncoding\n  })), _toConsumableArray(makeBoxPlotExtent({\n    partName: 'rule',\n    mark: {\n      type: 'rule',\n      invalid: invalid,\n      aria: false\n    },\n    positionPrefix: 'upper_box',\n    endPositionPrefix: 'upper_whisker',\n    extraEncoding: whiskerTooltipEncoding\n  })), _toConsumableArray(makeBoxPlotExtent({\n    partName: 'ticks',\n    mark: endTick,\n    positionPrefix: 'lower_whisker',\n    extraEncoding: whiskerTooltipEncoding\n  })), _toConsumableArray(makeBoxPlotExtent({\n    partName: 'ticks',\n    mark: endTick,\n    positionPrefix: 'upper_whisker',\n    extraEncoding: whiskerTooltipEncoding\n  })));\n  // ## Box Layers\n  // TODO: support hiding certain mark parts\n  var boxLayers = [].concat(_toConsumableArray(boxPlotType !== 'tukey' ? whiskerLayers : []), _toConsumableArray(makeBoxPlotBox({\n    partName: 'box',\n    mark: Object.assign(Object.assign({\n      type: 'bar'\n    }, sizeValue ? {\n      size: sizeValue\n    } : {}), {\n      orient: boxOrient,\n      invalid: invalid,\n      ariaRoleDescription: 'box'\n    }),\n    positionPrefix: 'lower_box',\n    endPositionPrefix: 'upper_box',\n    extraEncoding: fiveSummaryTooltipEncoding\n  })), _toConsumableArray(makeBoxPlotMidTick({\n    partName: 'median',\n    mark: Object.assign(Object.assign(Object.assign({\n      type: 'tick',\n      invalid: invalid\n    }, isObject(config.boxplot.median) && config.boxplot.median.color ? {\n      color: config.boxplot.median.color\n    } : {}), sizeValue ? {\n      size: sizeValue\n    } : {}), {\n      orient: ticksOrient,\n      aria: false\n    }),\n    positionPrefix: 'mid_box',\n    extraEncoding: fiveSummaryTooltipEncoding\n  })));\n  if (boxPlotType === 'min-max') {\n    return Object.assign(Object.assign({}, outerSpec), {\n      transform: ((_b = outerSpec.transform) !== null && _b !== void 0 ? _b : []).concat(transform),\n      layer: boxLayers\n    });\n  }\n  // Tukey Box Plot\n  var lowerBoxExpr = \"datum[\\\"lower_box_\".concat(continuousAxisChannelDef.field, \"\\\"]\");\n  var upperBoxExpr = \"datum[\\\"upper_box_\".concat(continuousAxisChannelDef.field, \"\\\"]\");\n  var iqrExpr = \"(\".concat(upperBoxExpr, \" - \").concat(lowerBoxExpr, \")\");\n  var lowerWhiskerExpr = \"\".concat(lowerBoxExpr, \" - \").concat(extent, \" * \").concat(iqrExpr);\n  var upperWhiskerExpr = \"\".concat(upperBoxExpr, \" + \").concat(extent, \" * \").concat(iqrExpr);\n  var fieldExpr = \"datum[\\\"\".concat(continuousAxisChannelDef.field, \"\\\"]\");\n  var joinaggregateTransform = {\n    joinaggregate: boxParamsQuartiles(continuousAxisChannelDef.field),\n    groupby: groupby\n  };\n  var filteredWhiskerSpec = {\n    transform: [{\n      filter: \"(\".concat(lowerWhiskerExpr, \" <= \").concat(fieldExpr, \") && (\").concat(fieldExpr, \" <= \").concat(upperWhiskerExpr, \")\")\n    }, {\n      aggregate: [{\n        op: 'min',\n        field: continuousAxisChannelDef.field,\n        as: \"lower_whisker_\".concat(continuousAxisChannelDef.field)\n      }, {\n        op: 'max',\n        field: continuousAxisChannelDef.field,\n        as: \"upper_whisker_\".concat(continuousAxisChannelDef.field)\n      },\n      // preserve lower_box / upper_box\n      {\n        op: 'min',\n        field: \"lower_box_\".concat(continuousAxisChannelDef.field),\n        as: \"lower_box_\".concat(continuousAxisChannelDef.field)\n      }, {\n        op: 'max',\n        field: \"upper_box_\".concat(continuousAxisChannelDef.field),\n        as: \"upper_box_\".concat(continuousAxisChannelDef.field)\n      }].concat(_toConsumableArray(aggregate)),\n      groupby: groupby\n    }],\n    layer: whiskerLayers\n  };\n  var tooltip = encodingWithoutSizeColorAndContinuousAxis.tooltip,\n    encodingWithoutSizeColorContinuousAxisAndTooltip = __rest(encodingWithoutSizeColorAndContinuousAxis, [\"tooltip\"]);\n  var scale = continuousAxisChannelDef.scale,\n    axis = continuousAxisChannelDef.axis;\n  var title = getTitle(continuousAxisChannelDef);\n  var axisWithoutTitle = omit(axis, ['title']);\n  var outlierLayersMixins = partLayerMixins(markDef, 'outliers', config.boxplot, {\n    transform: [{\n      filter: \"(\".concat(fieldExpr, \" < \").concat(lowerWhiskerExpr, \") || (\").concat(fieldExpr, \" > \").concat(upperWhiskerExpr, \")\")\n    }],\n    mark: 'point',\n    encoding: Object.assign(Object.assign(Object.assign(_defineProperty({}, continuousAxis, Object.assign(Object.assign(Object.assign({\n      field: continuousAxisChannelDef.field,\n      type: continuousAxisChannelDef.type\n    }, title !== undefined ? {\n      title: title\n    } : {}), scale !== undefined ? {\n      scale: scale\n    } : {}), isEmpty(axisWithoutTitle) ? {} : {\n      axis: axisWithoutTitle\n    })), encodingWithoutSizeColorContinuousAxisAndTooltip), color ? {\n      color: color\n    } : {}), customTooltipWithoutAggregatedField ? {\n      tooltip: customTooltipWithoutAggregatedField\n    } : {})\n  })[0];\n  var filteredLayersMixins;\n  var filteredLayersMixinsTransforms = [].concat(_toConsumableArray(bins), _toConsumableArray(timeUnits), [joinaggregateTransform]);\n  if (outlierLayersMixins) {\n    filteredLayersMixins = {\n      transform: filteredLayersMixinsTransforms,\n      layer: [outlierLayersMixins, filteredWhiskerSpec]\n    };\n  } else {\n    var _filteredLayersMixins;\n    filteredLayersMixins = filteredWhiskerSpec;\n    (_filteredLayersMixins = filteredLayersMixins.transform).unshift.apply(_filteredLayersMixins, _toConsumableArray(filteredLayersMixinsTransforms));\n  }\n  return Object.assign(Object.assign({}, outerSpec), {\n    layer: [filteredLayersMixins, {\n      // boxplot\n      transform: transform,\n      layer: boxLayers\n    }]\n  });\n}\nfunction boxParamsQuartiles(continousAxisField) {\n  return [{\n    op: 'q1',\n    field: continousAxisField,\n    as: \"lower_box_\".concat(continousAxisField)\n  }, {\n    op: 'q3',\n    field: continousAxisField,\n    as: \"upper_box_\".concat(continousAxisField)\n  }];\n}\nfunction boxParams(spec, extent, config) {\n  var orient = compositeMarkOrient(spec, BOXPLOT);\n  var _compositeMarkContinu = compositeMarkContinuousAxis(spec, orient, BOXPLOT),\n    continuousAxisChannelDef = _compositeMarkContinu.continuousAxisChannelDef,\n    continuousAxis = _compositeMarkContinu.continuousAxis;\n  var continuousFieldName = continuousAxisChannelDef.field;\n  var boxPlotType = getBoxPlotType(extent);\n  var boxplotSpecificAggregate = [].concat(_toConsumableArray(boxParamsQuartiles(continuousFieldName)), [{\n    op: 'median',\n    field: continuousFieldName,\n    as: \"mid_box_\".concat(continuousFieldName)\n  }, {\n    op: 'min',\n    field: continuousFieldName,\n    as: (boxPlotType === 'min-max' ? 'lower_whisker_' : 'min_') + continuousFieldName\n  }, {\n    op: 'max',\n    field: continuousFieldName,\n    as: (boxPlotType === 'min-max' ? 'upper_whisker_' : 'max_') + continuousFieldName\n  }]);\n  var postAggregateCalculates = boxPlotType === 'min-max' || boxPlotType === 'tukey' ? [] : [\n  // This is for the  original k-IQR, which we do not expose\n  {\n    calculate: \"datum[\\\"upper_box_\".concat(continuousFieldName, \"\\\"] - datum[\\\"lower_box_\").concat(continuousFieldName, \"\\\"]\"),\n    as: \"iqr_\".concat(continuousFieldName)\n  }, {\n    calculate: \"min(datum[\\\"upper_box_\".concat(continuousFieldName, \"\\\"] + datum[\\\"iqr_\").concat(continuousFieldName, \"\\\"] * \").concat(extent, \", datum[\\\"max_\").concat(continuousFieldName, \"\\\"])\"),\n    as: \"upper_whisker_\".concat(continuousFieldName)\n  }, {\n    calculate: \"max(datum[\\\"lower_box_\".concat(continuousFieldName, \"\\\"] - datum[\\\"iqr_\").concat(continuousFieldName, \"\\\"] * \").concat(extent, \", datum[\\\"min_\").concat(continuousFieldName, \"\\\"])\"),\n    as: \"lower_whisker_\".concat(continuousFieldName)\n  }];\n  var _a = spec.encoding,\n    _b = continuousAxis,\n    oldContinuousAxisChannelDef = _a[_b],\n    oldEncodingWithoutContinuousAxis = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n  var _filterTooltipWithAgg = filterTooltipWithAggregatedField(oldEncodingWithoutContinuousAxis),\n    customTooltipWithoutAggregatedField = _filterTooltipWithAgg.customTooltipWithoutAggregatedField,\n    filteredEncoding = _filterTooltipWithAgg.filteredEncoding;\n  var _extractTransformsFro = extractTransformsFromEncoding(filteredEncoding, config),\n    bins = _extractTransformsFro.bins,\n    timeUnits = _extractTransformsFro.timeUnits,\n    aggregate = _extractTransformsFro.aggregate,\n    groupby = _extractTransformsFro.groupby,\n    encodingWithoutContinuousAxis = _extractTransformsFro.encoding;\n  var ticksOrient = orient === 'vertical' ? 'horizontal' : 'vertical';\n  var boxOrient = orient;\n  var transform = [].concat(_toConsumableArray(bins), _toConsumableArray(timeUnits), [{\n    aggregate: [].concat(_toConsumableArray(aggregate), _toConsumableArray(boxplotSpecificAggregate)),\n    groupby: groupby\n  }], postAggregateCalculates);\n  return {\n    bins: bins,\n    timeUnits: timeUnits,\n    transform: transform,\n    groupby: groupby,\n    aggregate: aggregate,\n    continuousAxisChannelDef: continuousAxisChannelDef,\n    continuousAxis: continuousAxis,\n    encodingWithoutContinuousAxis: encodingWithoutContinuousAxis,\n    ticksOrient: ticksOrient,\n    boxOrient: boxOrient,\n    customTooltipWithoutAggregatedField: customTooltipWithoutAggregatedField\n  };\n}","map":{"version":3,"sources":["../../../src/compositemark/boxplot.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isNumber, isObject } from 'vega-util';\nimport { getMarkPropOrConfig } from '../compile/common';\nimport { extractTransformsFromEncoding, normalizeEncoding } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { isEmpty, omit } from '../util';\nimport { CompositeMarkNormalizer } from './base';\nimport { compositeMarkContinuousAxis, compositeMarkOrient, filterTooltipWithAggregatedField, getCompositeMarkTooltip, getTitle, makeCompositeAggregatePartFactory, partLayerMixins } from './common';\nexport const BOXPLOT = 'boxplot';\nexport const BOXPLOT_PARTS = ['box', 'median', 'outliers', 'rule', 'ticks'];\nexport const boxPlotNormalizer = new CompositeMarkNormalizer(BOXPLOT, normalizeBoxPlot);\nexport function getBoxPlotType(extent) {\n    if (isNumber(extent)) {\n        return 'tukey';\n    }\n    // Ham: If we ever want to, we could add another extent syntax `{kIQR: number}` for the original [Q1-k*IQR, Q3+k*IQR] whisker and call this boxPlotType = `kIQR`. However, I'm not exposing this for now.\n    return extent;\n}\nexport function normalizeBoxPlot(spec, { config }) {\n    var _a, _b;\n    // Need to initEncoding first so we can infer type\n    spec = Object.assign(Object.assign({}, spec), { encoding: normalizeEncoding(spec.encoding, config) });\n    const { mark, encoding: _encoding, params, projection: _p } = spec, outerSpec = __rest(spec, [\"mark\", \"encoding\", \"params\", \"projection\"]);\n    const markDef = isMarkDef(mark) ? mark : { type: mark };\n    // TODO(https://github.com/vega/vega-lite/issues/3702): add selection support\n    if (params) {\n        log.warn(log.message.selectionNotSupported('boxplot'));\n    }\n    const extent = (_a = markDef.extent) !== null && _a !== void 0 ? _a : config.boxplot.extent;\n    const sizeValue = getMarkPropOrConfig('size', markDef, // TODO: https://github.com/vega/vega-lite/issues/6245\n    config);\n    const invalid = markDef.invalid;\n    const boxPlotType = getBoxPlotType(extent);\n    const { bins, timeUnits, transform, continuousAxisChannelDef, continuousAxis, groupby, aggregate, encodingWithoutContinuousAxis, ticksOrient, boxOrient, customTooltipWithoutAggregatedField } = boxParams(spec, extent, config);\n    const { color, size } = encodingWithoutContinuousAxis, encodingWithoutSizeColorAndContinuousAxis = __rest(encodingWithoutContinuousAxis, [\"color\", \"size\"]);\n    const makeBoxPlotPart = (sharedEncoding) => {\n        return makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, config.boxplot);\n    };\n    const makeBoxPlotExtent = makeBoxPlotPart(encodingWithoutSizeColorAndContinuousAxis);\n    const makeBoxPlotBox = makeBoxPlotPart(encodingWithoutContinuousAxis);\n    const makeBoxPlotMidTick = makeBoxPlotPart(Object.assign(Object.assign({}, encodingWithoutSizeColorAndContinuousAxis), (size ? { size } : {})));\n    const fiveSummaryTooltipEncoding = getCompositeMarkTooltip([\n        { fieldPrefix: boxPlotType === 'min-max' ? 'upper_whisker_' : 'max_', titlePrefix: 'Max' },\n        { fieldPrefix: 'upper_box_', titlePrefix: 'Q3' },\n        { fieldPrefix: 'mid_box_', titlePrefix: 'Median' },\n        { fieldPrefix: 'lower_box_', titlePrefix: 'Q1' },\n        { fieldPrefix: boxPlotType === 'min-max' ? 'lower_whisker_' : 'min_', titlePrefix: 'Min' }\n    ], continuousAxisChannelDef, encodingWithoutContinuousAxis);\n    // ## Whisker Layers\n    const endTick = { type: 'tick', color: 'black', opacity: 1, orient: ticksOrient, invalid, aria: false };\n    const whiskerTooltipEncoding = boxPlotType === 'min-max'\n        ? fiveSummaryTooltipEncoding // for min-max, show five-summary tooltip for whisker\n        : // for tukey / k-IQR, just show upper/lower-whisker\n            getCompositeMarkTooltip([\n                { fieldPrefix: 'upper_whisker_', titlePrefix: 'Upper Whisker' },\n                { fieldPrefix: 'lower_whisker_', titlePrefix: 'Lower Whisker' }\n            ], continuousAxisChannelDef, encodingWithoutContinuousAxis);\n    const whiskerLayers = [\n        ...makeBoxPlotExtent({\n            partName: 'rule',\n            mark: { type: 'rule', invalid, aria: false },\n            positionPrefix: 'lower_whisker',\n            endPositionPrefix: 'lower_box',\n            extraEncoding: whiskerTooltipEncoding\n        }),\n        ...makeBoxPlotExtent({\n            partName: 'rule',\n            mark: { type: 'rule', invalid, aria: false },\n            positionPrefix: 'upper_box',\n            endPositionPrefix: 'upper_whisker',\n            extraEncoding: whiskerTooltipEncoding\n        }),\n        ...makeBoxPlotExtent({\n            partName: 'ticks',\n            mark: endTick,\n            positionPrefix: 'lower_whisker',\n            extraEncoding: whiskerTooltipEncoding\n        }),\n        ...makeBoxPlotExtent({\n            partName: 'ticks',\n            mark: endTick,\n            positionPrefix: 'upper_whisker',\n            extraEncoding: whiskerTooltipEncoding\n        })\n    ];\n    // ## Box Layers\n    // TODO: support hiding certain mark parts\n    const boxLayers = [\n        ...(boxPlotType !== 'tukey' ? whiskerLayers : []),\n        ...makeBoxPlotBox({\n            partName: 'box',\n            mark: Object.assign(Object.assign({ type: 'bar' }, (sizeValue ? { size: sizeValue } : {})), { orient: boxOrient, invalid, ariaRoleDescription: 'box' }),\n            positionPrefix: 'lower_box',\n            endPositionPrefix: 'upper_box',\n            extraEncoding: fiveSummaryTooltipEncoding\n        }),\n        ...makeBoxPlotMidTick({\n            partName: 'median',\n            mark: Object.assign(Object.assign(Object.assign({ type: 'tick', invalid }, (isObject(config.boxplot.median) && config.boxplot.median.color ? { color: config.boxplot.median.color } : {})), (sizeValue ? { size: sizeValue } : {})), { orient: ticksOrient, aria: false }),\n            positionPrefix: 'mid_box',\n            extraEncoding: fiveSummaryTooltipEncoding\n        })\n    ];\n    if (boxPlotType === 'min-max') {\n        return Object.assign(Object.assign({}, outerSpec), { transform: ((_b = outerSpec.transform) !== null && _b !== void 0 ? _b : []).concat(transform), layer: boxLayers });\n    }\n    // Tukey Box Plot\n    const lowerBoxExpr = `datum[\"lower_box_${continuousAxisChannelDef.field}\"]`;\n    const upperBoxExpr = `datum[\"upper_box_${continuousAxisChannelDef.field}\"]`;\n    const iqrExpr = `(${upperBoxExpr} - ${lowerBoxExpr})`;\n    const lowerWhiskerExpr = `${lowerBoxExpr} - ${extent} * ${iqrExpr}`;\n    const upperWhiskerExpr = `${upperBoxExpr} + ${extent} * ${iqrExpr}`;\n    const fieldExpr = `datum[\"${continuousAxisChannelDef.field}\"]`;\n    const joinaggregateTransform = {\n        joinaggregate: boxParamsQuartiles(continuousAxisChannelDef.field),\n        groupby\n    };\n    const filteredWhiskerSpec = {\n        transform: [\n            {\n                filter: `(${lowerWhiskerExpr} <= ${fieldExpr}) && (${fieldExpr} <= ${upperWhiskerExpr})`\n            },\n            {\n                aggregate: [\n                    {\n                        op: 'min',\n                        field: continuousAxisChannelDef.field,\n                        as: `lower_whisker_${continuousAxisChannelDef.field}`\n                    },\n                    {\n                        op: 'max',\n                        field: continuousAxisChannelDef.field,\n                        as: `upper_whisker_${continuousAxisChannelDef.field}`\n                    },\n                    // preserve lower_box / upper_box\n                    {\n                        op: 'min',\n                        field: `lower_box_${continuousAxisChannelDef.field}`,\n                        as: `lower_box_${continuousAxisChannelDef.field}`\n                    },\n                    {\n                        op: 'max',\n                        field: `upper_box_${continuousAxisChannelDef.field}`,\n                        as: `upper_box_${continuousAxisChannelDef.field}`\n                    },\n                    ...aggregate\n                ],\n                groupby\n            }\n        ],\n        layer: whiskerLayers\n    };\n    const { tooltip } = encodingWithoutSizeColorAndContinuousAxis, encodingWithoutSizeColorContinuousAxisAndTooltip = __rest(encodingWithoutSizeColorAndContinuousAxis, [\"tooltip\"]);\n    const { scale, axis } = continuousAxisChannelDef;\n    const title = getTitle(continuousAxisChannelDef);\n    const axisWithoutTitle = omit(axis, ['title']);\n    const outlierLayersMixins = partLayerMixins(markDef, 'outliers', config.boxplot, {\n        transform: [{ filter: `(${fieldExpr} < ${lowerWhiskerExpr}) || (${fieldExpr} > ${upperWhiskerExpr})` }],\n        mark: 'point',\n        encoding: Object.assign(Object.assign(Object.assign({ [continuousAxis]: Object.assign(Object.assign(Object.assign({ field: continuousAxisChannelDef.field, type: continuousAxisChannelDef.type }, (title !== undefined ? { title } : {})), (scale !== undefined ? { scale } : {})), (isEmpty(axisWithoutTitle) ? {} : { axis: axisWithoutTitle })) }, encodingWithoutSizeColorContinuousAxisAndTooltip), (color ? { color } : {})), (customTooltipWithoutAggregatedField ? { tooltip: customTooltipWithoutAggregatedField } : {}))\n    })[0];\n    let filteredLayersMixins;\n    const filteredLayersMixinsTransforms = [...bins, ...timeUnits, joinaggregateTransform];\n    if (outlierLayersMixins) {\n        filteredLayersMixins = {\n            transform: filteredLayersMixinsTransforms,\n            layer: [outlierLayersMixins, filteredWhiskerSpec]\n        };\n    }\n    else {\n        filteredLayersMixins = filteredWhiskerSpec;\n        filteredLayersMixins.transform.unshift(...filteredLayersMixinsTransforms);\n    }\n    return Object.assign(Object.assign({}, outerSpec), { layer: [\n            filteredLayersMixins,\n            {\n                // boxplot\n                transform,\n                layer: boxLayers\n            }\n        ] });\n}\nfunction boxParamsQuartiles(continousAxisField) {\n    return [\n        {\n            op: 'q1',\n            field: continousAxisField,\n            as: `lower_box_${continousAxisField}`\n        },\n        {\n            op: 'q3',\n            field: continousAxisField,\n            as: `upper_box_${continousAxisField}`\n        }\n    ];\n}\nfunction boxParams(spec, extent, config) {\n    const orient = compositeMarkOrient(spec, BOXPLOT);\n    const { continuousAxisChannelDef, continuousAxis } = compositeMarkContinuousAxis(spec, orient, BOXPLOT);\n    const continuousFieldName = continuousAxisChannelDef.field;\n    const boxPlotType = getBoxPlotType(extent);\n    const boxplotSpecificAggregate = [\n        ...boxParamsQuartiles(continuousFieldName),\n        {\n            op: 'median',\n            field: continuousFieldName,\n            as: `mid_box_${continuousFieldName}`\n        },\n        {\n            op: 'min',\n            field: continuousFieldName,\n            as: (boxPlotType === 'min-max' ? 'lower_whisker_' : 'min_') + continuousFieldName\n        },\n        {\n            op: 'max',\n            field: continuousFieldName,\n            as: (boxPlotType === 'min-max' ? 'upper_whisker_' : 'max_') + continuousFieldName\n        }\n    ];\n    const postAggregateCalculates = boxPlotType === 'min-max' || boxPlotType === 'tukey'\n        ? []\n        : [\n            // This is for the  original k-IQR, which we do not expose\n            {\n                calculate: `datum[\"upper_box_${continuousFieldName}\"] - datum[\"lower_box_${continuousFieldName}\"]`,\n                as: `iqr_${continuousFieldName}`\n            },\n            {\n                calculate: `min(datum[\"upper_box_${continuousFieldName}\"] + datum[\"iqr_${continuousFieldName}\"] * ${extent}, datum[\"max_${continuousFieldName}\"])`,\n                as: `upper_whisker_${continuousFieldName}`\n            },\n            {\n                calculate: `max(datum[\"lower_box_${continuousFieldName}\"] - datum[\"iqr_${continuousFieldName}\"] * ${extent}, datum[\"min_${continuousFieldName}\"])`,\n                as: `lower_whisker_${continuousFieldName}`\n            }\n        ];\n    const _a = spec.encoding, _b = continuousAxis, oldContinuousAxisChannelDef = _a[_b], oldEncodingWithoutContinuousAxis = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n    const { customTooltipWithoutAggregatedField, filteredEncoding } = filterTooltipWithAggregatedField(oldEncodingWithoutContinuousAxis);\n    const { bins, timeUnits, aggregate, groupby, encoding: encodingWithoutContinuousAxis } = extractTransformsFromEncoding(filteredEncoding, config);\n    const ticksOrient = orient === 'vertical' ? 'horizontal' : 'vertical';\n    const boxOrient = orient;\n    const transform = [\n        ...bins,\n        ...timeUnits,\n        {\n            aggregate: [...aggregate, ...boxplotSpecificAggregate],\n            groupby\n        },\n        ...postAggregateCalculates\n    ];\n    return {\n        bins,\n        timeUnits,\n        transform,\n        groupby,\n        aggregate,\n        continuousAxisChannelDef,\n        continuousAxis,\n        encodingWithoutContinuousAxis,\n        ticksOrient,\n        boxOrient,\n        customTooltipWithoutAggregatedField\n    };\n}\n//# sourceMappingURL=boxplot.js.map"]},"metadata":{},"sourceType":"module"}