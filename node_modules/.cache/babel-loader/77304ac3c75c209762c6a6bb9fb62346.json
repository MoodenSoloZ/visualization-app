{"ast":null,"code":"import _classCallCheck from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { array, isString } from 'vega-util';\nimport * as log from '../../log';\nimport { isLookupData, isLookupSelection } from '../../transform';\nimport { duplicate, hash as _hash, varName } from '../../util';\nimport { DataFlowNode, OutputNode } from './dataflow';\nimport { findSource } from './parse';\nimport { SourceNode } from './source';\nimport { DataSourceType } from '../../data';\nexport var LookupNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(LookupNode, _DataFlowNode);\n  var _super = _createSuper(LookupNode);\n  function LookupNode(parent, transform, secondary) {\n    var _this;\n    _classCallCheck(this, LookupNode);\n    _this = _super.call(this, parent);\n    _this.transform = transform;\n    _this.secondary = secondary;\n    return _this;\n  }\n  _createClass(LookupNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new LookupNode(null, duplicate(this.transform), this.secondary);\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return new Set([this.transform.lookup]);\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set(this.transform.as ? array(this.transform.as) : this.transform.from.fields);\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"Lookup \".concat(_hash({\n        transform: this.transform,\n        secondary: this.secondary\n      }));\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      var foreign;\n      if (this.transform.from.fields) {\n        // lookup a few fields and add create a flat output\n        foreign = Object.assign({\n          values: this.transform.from.fields\n        }, this.transform.as ? {\n          as: array(this.transform.as)\n        } : {});\n      } else {\n        // lookup full record and nest it\n        var asName = this.transform.as;\n        if (!isString(asName)) {\n          log.warn(log.message.NO_FIELDS_NEEDS_AS);\n          asName = '_lookup';\n        }\n        foreign = {\n          as: [asName]\n        };\n      }\n      return Object.assign(Object.assign({\n        type: 'lookup',\n        from: this.secondary,\n        key: this.transform.from.key,\n        fields: [this.transform.lookup]\n      }, foreign), this.transform.default ? {\n        default: this.transform.default\n      } : {});\n    }\n  }], [{\n    key: \"make\",\n    value: function make(parent, model, transform, counter) {\n      var sources = model.component.data.sources;\n      var _transform = transform,\n        from = _transform.from;\n      var fromOutputNode = null;\n      if (isLookupData(from)) {\n        var fromSource = findSource(from.data, sources);\n        if (!fromSource) {\n          fromSource = new SourceNode(from.data);\n          sources.push(fromSource);\n        }\n        var fromOutputName = model.getName(\"lookup_\".concat(counter));\n        fromOutputNode = new OutputNode(fromSource, fromOutputName, DataSourceType.Lookup, model.component.data.outputNodeRefCounts);\n        model.component.data.outputNodes[fromOutputName] = fromOutputNode;\n      } else if (isLookupSelection(from)) {\n        var selName = from.param;\n        transform = Object.assign({\n          as: selName\n        }, transform);\n        var selCmpt;\n        try {\n          selCmpt = model.getSelectionComponent(varName(selName), selName);\n        } catch (e) {\n          throw new Error(log.message.cannotLookupVariableParameter(selName));\n        }\n        fromOutputNode = selCmpt.materialized;\n        if (!fromOutputNode) {\n          throw new Error(log.message.noSameUnitLookup(selName));\n        }\n      }\n      return new LookupNode(parent, transform, fromOutputNode.getSource());\n    }\n  }]);\n  return LookupNode;\n}(DataFlowNode);","map":{"version":3,"sources":["../../../../src/compile/data/lookup.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { array, isString } from 'vega-util';\nimport * as log from '../../log';\nimport { isLookupData, isLookupSelection } from '../../transform';\nimport { duplicate, hash, varName } from '../../util';\nimport { DataFlowNode, OutputNode } from './dataflow';\nimport { findSource } from './parse';\nimport { SourceNode } from './source';\nimport { DataSourceType } from '../../data';\nexport class LookupNode extends DataFlowNode {\n    constructor(parent, transform, secondary) {\n        super(parent);\n        this.transform = transform;\n        this.secondary = secondary;\n    }\n    clone() {\n        return new LookupNode(null, duplicate(this.transform), this.secondary);\n    }\n    static make(parent, model, transform, counter) {\n        const sources = model.component.data.sources;\n        const { from } = transform;\n        let fromOutputNode = null;\n        if (isLookupData(from)) {\n            let fromSource = findSource(from.data, sources);\n            if (!fromSource) {\n                fromSource = new SourceNode(from.data);\n                sources.push(fromSource);\n            }\n            const fromOutputName = model.getName(`lookup_${counter}`);\n            fromOutputNode = new OutputNode(fromSource, fromOutputName, DataSourceType.Lookup, model.component.data.outputNodeRefCounts);\n            model.component.data.outputNodes[fromOutputName] = fromOutputNode;\n        }\n        else if (isLookupSelection(from)) {\n            const selName = from.param;\n            transform = Object.assign({ as: selName }, transform);\n            let selCmpt;\n            try {\n                selCmpt = model.getSelectionComponent(varName(selName), selName);\n            }\n            catch (e) {\n                throw new Error(log.message.cannotLookupVariableParameter(selName));\n            }\n            fromOutputNode = selCmpt.materialized;\n            if (!fromOutputNode) {\n                throw new Error(log.message.noSameUnitLookup(selName));\n            }\n        }\n        return new LookupNode(parent, transform, fromOutputNode.getSource());\n    }\n    dependentFields() {\n        return new Set([this.transform.lookup]);\n    }\n    producedFields() {\n        return new Set(this.transform.as ? array(this.transform.as) : this.transform.from.fields);\n    }\n    hash() {\n        return `Lookup ${hash({ transform: this.transform, secondary: this.secondary })}`;\n    }\n    assemble() {\n        let foreign;\n        if (this.transform.from.fields) {\n            // lookup a few fields and add create a flat output\n            foreign = Object.assign({ values: this.transform.from.fields }, (this.transform.as ? { as: array(this.transform.as) } : {}));\n        }\n        else {\n            // lookup full record and nest it\n            let asName = this.transform.as;\n            if (!isString(asName)) {\n                log.warn(log.message.NO_FIELDS_NEEDS_AS);\n                asName = '_lookup';\n            }\n            foreign = {\n                as: [asName]\n            };\n        }\n        return Object.assign(Object.assign({ type: 'lookup', from: this.secondary, key: this.transform.from.key, fields: [this.transform.lookup] }, foreign), (this.transform.default ? { default: this.transform.default } : {}));\n    }\n}\n//# sourceMappingURL=lookup.js.map"]},"metadata":{},"sourceType":"module"}