{"ast":null,"code":"import _defineProperty from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { array } from 'vega-util';\nimport { isConditionalDef, isConditionalParameter } from '../../../channeldef';\nimport { expression } from '../../predicate';\nimport { parseSelectionPredicate } from '../../selection/parse';\n/**\n * Return a mixin that includes a Vega production rule for a Vega-Lite conditional channel definition\n * or a simple mixin if channel def has no condition.\n */\nexport function wrapCondition(model, channelDef, vgChannel, refFn) {\n  var condition = isConditionalDef(channelDef) && channelDef.condition;\n  var valueRef = refFn(channelDef);\n  if (condition) {\n    var conditions = array(condition);\n    var vgConditions = conditions.map(function (c) {\n      var conditionValueRef = refFn(c);\n      if (isConditionalParameter(c)) {\n        var param = c.param,\n          empty = c.empty;\n        var test = parseSelectionPredicate(model, {\n          param: param,\n          empty: empty\n        });\n        return Object.assign({\n          test: test\n        }, conditionValueRef);\n      } else {\n        var _test = expression(model, c.test); // FIXME: remove casting once TS is no longer dumb about it\n        return Object.assign({\n          test: _test\n        }, conditionValueRef);\n      }\n    });\n    return _defineProperty({}, vgChannel, [].concat(_toConsumableArray(vgConditions), _toConsumableArray(valueRef !== undefined ? [valueRef] : [])));\n  } else {\n    return valueRef !== undefined ? _defineProperty({}, vgChannel, valueRef) : {};\n  }\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/conditional.ts"],"names":[],"mappings":";;AAAA,SAAQ,KAAK,QAAO,WAAW;AAC/B,SAA0C,gBAAgB,EAAE,sBAAsB,QAAO,qBAAqB;AAG9G,SAAQ,UAAU,QAAO,iBAAiB;AAC1C,SAAQ,uBAAuB,QAAO,uBAAuB;AAG7D;;;AAGG;AACH,OAAM,SAAU,aAAa,CAC3B,KAAgB,EAChB,UAAc,EACd,SAAiB,EACjB,KAA+B,EAAA;EAE/B,IAAM,SAAS,GAAG,gBAAgB,CAAK,UAAU,CAAC,IAAI,UAAU,CAAC,SAAS;EAC1E,IAAM,QAAQ,GAAG,KAAK,CAAC,UAAU,CAAC;EAClC,IAAI,SAAS,EAAE;IACb,IAAM,UAAU,GAAG,KAAK,CAAC,SAAS,CAAC;IACnC,IAAM,YAAY,GAAG,UAAU,CAAC,GAAG,CAAC,UAAA,CAAC,EAAG;MACtC,IAAM,iBAAiB,GAAG,KAAK,CAAC,CAAC,CAAC;MAClC,IAAI,sBAAsB,CAAM,CAAC,CAAC,EAAE;QAClC,IAAO,KAAK,GAAW,CAAC,CAAjB,KAAK;UAAE,KAAK,GAAI,CAAC,CAAV,KAAK;QACnB,IAAM,IAAI,GAAG,uBAAuB,CAAC,KAAK,EAAE;UAAC,KAAK,EAAL,KAAK;UAAE,KAAK,EAAL;QAAK,CAAC,CAAC;QAC3D,OAAA,MAAA,CAAA,MAAA,CAAA;UAAQ,IAAI,EAAJ;QAAI,CAAA,EAAK,iBAAiB,CAAA;OACnC,MAAM;QACL,IAAM,KAAI,GAAG,UAAU,CAAC,KAAK,EAAG,CAA+B,CAAC,IAAI,CAAC,CAAC,CAAC;QACvE,OAAA,MAAA,CAAA,MAAA,CAAA;UAAQ,IAAI,EAAJ;QAAI,CAAA,EAAK,iBAAiB,CAAA;MACnC;IACH,CAAC,CAAC;IACF,2BACG,SAAS,+BAAO,YAAY,sBAAM,QAAQ,KAAK,SAAS,GAAG,CAAC,QAAQ,CAAC,GAAG,EAAE;GAE9E,MAAM;IACL,OAAO,QAAQ,KAAK,SAAS,uBAAK,SAAS,EAAG,QAAQ,IAAI,CAAA,CAAE;EAC7D;AACH","sourceRoot":"","sourcesContent":["import { array } from 'vega-util';\nimport { isConditionalDef, isConditionalParameter } from '../../../channeldef';\nimport { expression } from '../../predicate';\nimport { parseSelectionPredicate } from '../../selection/parse';\n/**\n * Return a mixin that includes a Vega production rule for a Vega-Lite conditional channel definition\n * or a simple mixin if channel def has no condition.\n */\nexport function wrapCondition(model, channelDef, vgChannel, refFn) {\n    const condition = isConditionalDef(channelDef) && channelDef.condition;\n    const valueRef = refFn(channelDef);\n    if (condition) {\n        const conditions = array(condition);\n        const vgConditions = conditions.map(c => {\n            const conditionValueRef = refFn(c);\n            if (isConditionalParameter(c)) {\n                const { param, empty } = c;\n                const test = parseSelectionPredicate(model, { param, empty });\n                return Object.assign({ test }, conditionValueRef);\n            }\n            else {\n                const test = expression(model, c.test); // FIXME: remove casting once TS is no longer dumb about it\n                return Object.assign({ test }, conditionValueRef);\n            }\n        });\n        return {\n            [vgChannel]: [...vgConditions, ...(valueRef !== undefined ? [valueRef] : [])]\n        };\n    }\n    else {\n        return valueRef !== undefined ? { [vgChannel]: valueRef } : {};\n    }\n}\n//# sourceMappingURL=conditional.js.map"]},"metadata":{},"sourceType":"module"}