{"ast":null,"code":"import { getMarkPropOrConfig } from '../common';\nimport * as encode from './encode';\nexport var text = {\n  vgMark: 'text',\n  encodeEntry: function encodeEntry(model) {\n    var config = model.config,\n      encoding = model.encoding;\n    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, encode.baseEncodeEntry(model, {\n      align: 'include',\n      baseline: 'include',\n      color: 'include',\n      size: 'ignore',\n      orient: 'ignore',\n      theta: 'include'\n    })), encode.pointPosition('x', model, {\n      defaultPos: 'mid'\n    })), encode.pointPosition('y', model, {\n      defaultPos: 'mid'\n    })), encode.text(model)), encode.nonPosition('size', model, {\n      vgChannel: 'fontSize' // VL's text size is fontSize\n    })), encode.nonPosition('angle', model)), encode.valueIfDefined('align', align(model.markDef, encoding, config))), encode.valueIfDefined('baseline', baseline(model.markDef, encoding, config))), encode.pointPosition('radius', model, {\n      defaultPos: null\n    })), encode.pointPosition('theta', model, {\n      defaultPos: null\n    }));\n  }\n};\nfunction align(markDef, encoding, config) {\n  var a = getMarkPropOrConfig('align', markDef, config);\n  if (a === undefined) {\n    return 'center';\n  }\n  // If there is a config, Vega-parser will process this already.\n  return undefined;\n}\nfunction baseline(markDef, encoding, config) {\n  var b = getMarkPropOrConfig('baseline', markDef, config);\n  if (b === undefined) {\n    return 'middle';\n  }\n  // If there is a config, Vega-parser will process this already.\n  return undefined;\n}","map":{"version":3,"sources":["../../../../src/compile/mark/text.ts"],"names":[],"mappings":"AAIA,SAAQ,mBAAmB,QAAO,WAAW;AAG7C,OAAO,KAAK,MAAM,MAAM,UAAU;AAElC,OAAO,IAAM,IAAI,GAAiB;EAChC,MAAM,EAAE,MAAM;EAEd,WAAW,EAAE,qBAAC,KAAgB,EAAI;IAChC,IAAO,MAAM,GAAc,KAAK,CAAzB,MAAM;MAAE,QAAQ,GAAI,KAAK,CAAjB,QAAQ;IAEvB,OAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EACK,MAAM,CAAC,eAAe,CAAC,KAAK,EAAE;MAC/B,KAAK,EAAE,SAAS;MAChB,QAAQ,EAAE,SAAS;MACnB,KAAK,EAAE,SAAS;MAChB,IAAI,EAAE,QAAQ;MACd,MAAM,EAAE,QAAQ;MAChB,KAAK,EAAE;KACR,CAAC,CAAA,EACC,MAAM,CAAC,aAAa,CAAC,GAAG,EAAE,KAAK,EAAE;MAAC,UAAU,EAAE;IAAK,CAAC,CAAC,CAAA,EACrD,MAAM,CAAC,aAAa,CAAC,GAAG,EAAE,KAAK,EAAE;MAAC,UAAU,EAAE;IAAK,CAAC,CAAC,CAAA,EACrD,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA,EAClB,MAAM,CAAC,WAAW,CAAC,MAAM,EAAE,KAAK,EAAE;MACnC,SAAS,EAAE,UAAU,CAAC;KACvB,CAAC,CAAA,EACC,MAAM,CAAC,WAAW,CAAC,OAAO,EAAE,KAAK,CAAC,CAAA,EAClC,MAAM,CAAC,cAAc,CAAC,OAAO,EAAE,KAAK,CAAC,KAAK,CAAC,OAAO,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC,CAAA,EACtE,MAAM,CAAC,cAAc,CAAC,UAAU,EAAE,QAAQ,CAAC,KAAK,CAAC,OAAO,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC,CAAA,EAC5E,MAAM,CAAC,aAAa,CAAC,QAAQ,EAAE,KAAK,EAAE;MAAC,UAAU,EAAE;IAAI,CAAC,CAAC,CAAA,EACzD,MAAM,CAAC,aAAa,CAAC,OAAO,EAAE,KAAK,EAAE;MAAC,UAAU,EAAE;IAAI,CAAC,CAAC,CAAA;EAE/D;CACD;AAED,SAAS,KAAK,CAAC,OAAgB,EAAE,QAA0B,EAAE,MAAyB,EAAA;EACpF,IAAM,CAAC,GAAG,mBAAmB,CAAC,OAAO,EAAE,OAAO,EAAE,MAAM,CAAC;EACvD,IAAI,CAAC,KAAK,SAAS,EAAE;IACnB,OAAO,QAAQ;EAChB;EACD;EACA,OAAO,SAAS;AAClB;AAEA,SAAS,QAAQ,CAAC,OAAgB,EAAE,QAA0B,EAAE,MAAyB,EAAA;EACvF,IAAM,CAAC,GAAG,mBAAmB,CAAC,UAAU,EAAE,OAAO,EAAE,MAAM,CAAC;EAC1D,IAAI,CAAC,KAAK,SAAS,EAAE;IACnB,OAAO,QAAQ;EAChB;EACD;EACA,OAAO,SAAS;AAClB","sourceRoot":"","sourcesContent":["import { getMarkPropOrConfig } from '../common';\nimport * as encode from './encode';\nexport const text = {\n    vgMark: 'text',\n    encodeEntry: (model) => {\n        const { config, encoding } = model;\n        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, encode.baseEncodeEntry(model, {\n            align: 'include',\n            baseline: 'include',\n            color: 'include',\n            size: 'ignore',\n            orient: 'ignore',\n            theta: 'include'\n        })), encode.pointPosition('x', model, { defaultPos: 'mid' })), encode.pointPosition('y', model, { defaultPos: 'mid' })), encode.text(model)), encode.nonPosition('size', model, {\n            vgChannel: 'fontSize' // VL's text size is fontSize\n        })), encode.nonPosition('angle', model)), encode.valueIfDefined('align', align(model.markDef, encoding, config))), encode.valueIfDefined('baseline', baseline(model.markDef, encoding, config))), encode.pointPosition('radius', model, { defaultPos: null })), encode.pointPosition('theta', model, { defaultPos: null }));\n    }\n};\nfunction align(markDef, encoding, config) {\n    const a = getMarkPropOrConfig('align', markDef, config);\n    if (a === undefined) {\n        return 'center';\n    }\n    // If there is a config, Vega-parser will process this already.\n    return undefined;\n}\nfunction baseline(markDef, encoding, config) {\n    const b = getMarkPropOrConfig('baseline', markDef, config);\n    if (b === undefined) {\n        return 'middle';\n    }\n    // If there is a config, Vega-parser will process this already.\n    return undefined;\n}\n//# sourceMappingURL=text.js.map"]},"metadata":{},"sourceType":"module"}