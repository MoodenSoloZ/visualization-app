{"ast":null,"code":"import _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { isObject, isString } from 'vega-util';\nimport { isAggregateOp, isArgmaxDef, isArgminDef, MULTIDOMAIN_SORT_OP_INDEX as UNIONDOMAIN_SORT_OP_INDEX, SHARED_DOMAIN_OPS } from '../../aggregate';\nimport { isBinning, isBinParams, isParameterExtent } from '../../bin';\nimport { getSecondaryRangeChannel, isScaleChannel } from '../../channel';\nimport { binRequiresRange, getFieldOrDatumDef, hasBandEnd, isDatumDef, isFieldDef, valueExpr, vgField } from '../../channeldef';\nimport { DataSourceType } from '../../data';\nimport * as log from '../../log';\nimport { hasDiscreteDomain, isDomainUnionWith, isParameterDomain } from '../../scale';\nimport { DEFAULT_SORT_OP, isSortArray, isSortByEncoding, isSortField } from '../../sort';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport * as util from '../../util';\nimport { isDataRefDomain, isDataRefUnionedDomain, isFieldRefUnionDomain, isSignalRef } from '../../vega.schema';\nimport { getBinSignalName } from '../data/bin';\nimport { sortArrayIndexField } from '../data/calculate';\nimport { FACET_SCALE_PREFIX } from '../data/optimize';\nimport { isFacetModel, isUnitModel } from '../model';\nimport { SignalRefWrapper } from '../signal';\nimport { makeExplicit, makeImplicit, mergeValuesWithExplicit } from '../split';\nexport function parseScaleDomain(model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleDomain(model);\n  } else {\n    parseNonUnitScaleDomain(model);\n  }\n}\nfunction parseUnitScaleDomain(model) {\n  var localScaleComponents = model.component.scales;\n  var _iterator = _createForOfIteratorHelper(util.keys(localScaleComponents)),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var channel = _step.value;\n      var domains = parseDomainForChannel(model, channel);\n      var localScaleCmpt = localScaleComponents[channel];\n      localScaleCmpt.setWithExplicit('domains', domains);\n      parseSelectionDomain(model, channel);\n      if (model.component.data.isFaceted) {\n        // get resolve from closest facet parent as this decides whether we need to refer to cloned subtree or not\n        var facetParent = model;\n        while (!isFacetModel(facetParent) && facetParent.parent) {\n          facetParent = facetParent.parent;\n        }\n        var resolve = facetParent.component.resolve.scale[channel];\n        if (resolve === 'shared') {\n          var _iterator2 = _createForOfIteratorHelper(domains.value),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var domain = _step2.value;\n              // Replace the scale domain with data output from a cloned subtree after the facet.\n              if (isDataRefDomain(domain)) {\n                // use data from cloned subtree (which is the same as data but with a prefix added once)\n                domain.data = FACET_SCALE_PREFIX + domain.data.replace(FACET_SCALE_PREFIX, '');\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nfunction parseNonUnitScaleDomain(model) {\n  var _iterator3 = _createForOfIteratorHelper(model.children),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var child = _step3.value;\n      parseScaleDomain(child);\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  var localScaleComponents = model.component.scales;\n  var _iterator4 = _createForOfIteratorHelper(util.keys(localScaleComponents)),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var channel = _step4.value;\n      var domains = void 0;\n      var selectionExtent = null;\n      var _iterator5 = _createForOfIteratorHelper(model.children),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _child = _step5.value;\n          var childComponent = _child.component.scales[channel];\n          if (childComponent) {\n            if (domains === undefined) {\n              domains = childComponent.getWithExplicit('domains');\n            } else {\n              domains = mergeValuesWithExplicit(domains, childComponent.getWithExplicit('domains'), 'domains', 'scale', domainsTieBreaker);\n            }\n            var se = childComponent.get('selectionExtent');\n            if (selectionExtent && se && selectionExtent.param !== se.param) {\n              log.warn(log.message.NEEDS_SAME_SELECTION);\n            }\n            selectionExtent = se;\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      localScaleComponents[channel].setWithExplicit('domains', domains);\n      if (selectionExtent) {\n        localScaleComponents[channel].set('selectionExtent', selectionExtent, true);\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n}\n/**\n * Remove unaggregated domain if it is not applicable\n * Add unaggregated domain if domain is not specified and config.scale.useUnaggregatedDomain is true.\n */\nfunction normalizeUnaggregatedDomain(domain, fieldDef, scaleType, scaleConfig) {\n  if (domain === 'unaggregated') {\n    var _canUseUnaggregatedDo = canUseUnaggregatedDomain(fieldDef, scaleType),\n      valid = _canUseUnaggregatedDo.valid,\n      reason = _canUseUnaggregatedDo.reason;\n    if (!valid) {\n      log.warn(reason);\n      return undefined;\n    }\n  } else if (domain === undefined && scaleConfig.useUnaggregatedDomain) {\n    // Apply config if domain is not specified.\n    var _canUseUnaggregatedDo2 = canUseUnaggregatedDomain(fieldDef, scaleType),\n      _valid = _canUseUnaggregatedDo2.valid;\n    if (_valid) {\n      return 'unaggregated';\n    }\n  }\n  return domain;\n}\nexport function parseDomainForChannel(model, channel) {\n  var scaleType = model.getScaleComponent(channel).get('type');\n  var encoding = model.encoding;\n  var domain = normalizeUnaggregatedDomain(model.scaleDomain(channel), model.typedFieldDef(channel), scaleType, model.config.scale);\n  if (domain !== model.scaleDomain(channel)) {\n    model.specifiedScales[channel] = Object.assign(Object.assign({}, model.specifiedScales[channel]), {\n      domain: domain\n    });\n  }\n  // If channel is either X or Y then union them with X2 & Y2 if they exist\n  if (channel === 'x' && getFieldOrDatumDef(encoding.x2)) {\n    if (getFieldOrDatumDef(encoding.x)) {\n      return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType, domain, model, 'x'), parseSingleChannelDomain(scaleType, domain, model, 'x2'), 'domain', 'scale', domainsTieBreaker);\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'x2');\n    }\n  } else if (channel === 'y' && getFieldOrDatumDef(encoding.y2)) {\n    if (getFieldOrDatumDef(encoding.y)) {\n      return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType, domain, model, 'y'), parseSingleChannelDomain(scaleType, domain, model, 'y2'), 'domain', 'scale', domainsTieBreaker);\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'y2');\n    }\n  }\n  return parseSingleChannelDomain(scaleType, domain, model, channel);\n}\nfunction mapDomainToDataSignal(domain, type, timeUnit) {\n  return domain.map(function (v) {\n    var data = valueExpr(v, {\n      timeUnit: timeUnit,\n      type: type\n    });\n    return {\n      signal: \"{data: \".concat(data, \"}\")\n    };\n  });\n}\nfunction convertDomainIfItIsDateTime(domain, type, timeUnit) {\n  var _a;\n  // explicit value\n  var normalizedTimeUnit = (_a = normalizeTimeUnit(timeUnit)) === null || _a === void 0 ? void 0 : _a.unit;\n  if (type === 'temporal' || normalizedTimeUnit) {\n    return mapDomainToDataSignal(domain, type, normalizedTimeUnit);\n  }\n  return [domain]; // Date time won't make sense\n}\n\nfunction parseSingleChannelDomain(scaleType, domain, model, channel) {\n  var encoding = model.encoding;\n  var fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n  var type = fieldOrDatumDef.type;\n  var timeUnit = fieldOrDatumDef['timeUnit'];\n  if (isDomainUnionWith(domain)) {\n    var defaultDomain = parseSingleChannelDomain(scaleType, undefined, model, channel);\n    var unionWith = convertDomainIfItIsDateTime(domain.unionWith, type, timeUnit);\n    return makeExplicit([].concat(_toConsumableArray(unionWith), _toConsumableArray(defaultDomain.value)));\n  } else if (isSignalRef(domain)) {\n    return makeExplicit([domain]);\n  } else if (domain && domain !== 'unaggregated' && !isParameterDomain(domain)) {\n    return makeExplicit(convertDomainIfItIsDateTime(domain, type, timeUnit));\n  }\n  var stack = model.stack;\n  if (stack && channel === stack.fieldChannel) {\n    if (stack.offset === 'normalize') {\n      return makeImplicit([[0, 1]]);\n    }\n    var data = model.requestDataName(DataSourceType.Main);\n    return makeImplicit([{\n      data: data,\n      field: model.vgField(channel, {\n        suffix: 'start'\n      })\n    }, {\n      data: data,\n      field: model.vgField(channel, {\n        suffix: 'end'\n      })\n    }]);\n  }\n  var sort = isScaleChannel(channel) && isFieldDef(fieldOrDatumDef) ? domainSort(model, channel, scaleType) : undefined;\n  if (isDatumDef(fieldOrDatumDef)) {\n    var d = convertDomainIfItIsDateTime([fieldOrDatumDef.datum], type, timeUnit);\n    return makeImplicit(d);\n  }\n  var fieldDef = fieldOrDatumDef; // now we can be sure it's a fieldDef\n  if (domain === 'unaggregated') {\n    var _data = model.requestDataName(DataSourceType.Main);\n    var field = fieldOrDatumDef.field;\n    return makeImplicit([{\n      data: _data,\n      field: vgField({\n        field: field,\n        aggregate: 'min'\n      })\n    }, {\n      data: _data,\n      field: vgField({\n        field: field,\n        aggregate: 'max'\n      })\n    }]);\n  } else if (isBinning(fieldDef.bin)) {\n    if (hasDiscreteDomain(scaleType)) {\n      if (scaleType === 'bin-ordinal') {\n        // we can omit the domain as it is inferred from the `bins` property\n        return makeImplicit([]);\n      }\n      // ordinal bin scale takes domain from bin_range, ordered by bin start\n      // This is useful for both axis-based scale (x/y) and legend-based scale (other channels).\n      return makeImplicit([{\n        // If sort by aggregation of a specified sort field, we need to use RAW table,\n        // so we can aggregate values for the scale independently from the main aggregation.\n        data: util.isBoolean(sort) ? model.requestDataName(DataSourceType.Main) : model.requestDataName(DataSourceType.Raw),\n        // Use range if we added it and the scale does not support computing a range as a signal.\n        field: model.vgField(channel, binRequiresRange(fieldDef, channel) ? {\n          binSuffix: 'range'\n        } : {}),\n        // we have to use a sort object if sort = true to make the sort correct by bin start\n        sort: sort === true || !isObject(sort) ? {\n          field: model.vgField(channel, {}),\n          op: 'min' // min or max doesn't matter since we sort by the start of the bin range\n        } : sort\n      }]);\n    } else {\n      // continuous scales\n      var bin = fieldDef.bin;\n      if (isBinning(bin)) {\n        var binSignal = getBinSignalName(model, fieldDef.field, bin);\n        return makeImplicit([new SignalRefWrapper(function () {\n          var signal = model.getSignalName(binSignal);\n          return \"[\".concat(signal, \".start, \").concat(signal, \".stop]\");\n        })]);\n      } else {\n        return makeImplicit([{\n          data: model.requestDataName(DataSourceType.Main),\n          field: model.vgField(channel, {})\n        }]);\n      }\n    }\n  } else if (fieldDef.timeUnit && util.contains(['time', 'utc'], scaleType) && hasBandEnd(fieldDef, isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined, model.markDef, model.config)) {\n    var _data2 = model.requestDataName(DataSourceType.Main);\n    return makeImplicit([{\n      data: _data2,\n      field: model.vgField(channel)\n    }, {\n      data: _data2,\n      field: model.vgField(channel, {\n        suffix: 'end'\n      })\n    }]);\n  } else if (sort) {\n    return makeImplicit([{\n      // If sort by aggregation of a specified sort field, we need to use RAW table,\n      // so we can aggregate values for the scale independently from the main aggregation.\n      data: util.isBoolean(sort) ? model.requestDataName(DataSourceType.Main) : model.requestDataName(DataSourceType.Raw),\n      field: model.vgField(channel),\n      sort: sort\n    }]);\n  } else {\n    return makeImplicit([{\n      data: model.requestDataName(DataSourceType.Main),\n      field: model.vgField(channel)\n    }]);\n  }\n}\nfunction normalizeSortField(sort, isStackedMeasure) {\n  var op = sort.op,\n    field = sort.field,\n    order = sort.order;\n  return Object.assign(Object.assign({\n    // Apply default op\n    op: op !== null && op !== void 0 ? op : isStackedMeasure ? 'sum' : DEFAULT_SORT_OP\n  }, field ? {\n    field: util.replacePathInField(field)\n  } : {}), order ? {\n    order: order\n  } : {});\n}\nfunction parseSelectionDomain(model, channel) {\n  var _a;\n  var scale = model.component.scales[channel];\n  var spec = model.specifiedScales[channel].domain;\n  var bin = (_a = model.fieldDef(channel)) === null || _a === void 0 ? void 0 : _a.bin;\n  var domain = isParameterDomain(spec) && spec;\n  var extent = isBinParams(bin) && isParameterExtent(bin.extent) && bin.extent;\n  if (domain || extent) {\n    // As scale parsing occurs before selection parsing, we cannot set\n    // domainRaw directly. So instead, we store the selectionExtent on\n    // the scale component, and then add domainRaw during scale assembly.\n    scale.set('selectionExtent', domain !== null && domain !== void 0 ? domain : extent, true);\n  }\n}\nexport function domainSort(model, channel, scaleType) {\n  if (!hasDiscreteDomain(scaleType)) {\n    return undefined;\n  }\n  // save to cast as the only exception is the geojson type for shape, which would not generate a scale\n  var fieldDef = model.fieldDef(channel);\n  var sort = fieldDef.sort;\n  // if the sort is specified with array, use the derived sort index field\n  if (isSortArray(sort)) {\n    return {\n      op: 'min',\n      field: sortArrayIndexField(fieldDef, channel),\n      order: 'ascending'\n    };\n  }\n  var stack = model.stack;\n  var stackDimensions = stack ? new Set([].concat(_toConsumableArray(stack.groupbyFields), _toConsumableArray(stack.stackBy.map(function (s) {\n    return s.fieldDef.field;\n  })))) : undefined;\n  // Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)\n  if (isSortField(sort)) {\n    var isStackedMeasure = stack && !stackDimensions.has(sort.field);\n    return normalizeSortField(sort, isStackedMeasure);\n  } else if (isSortByEncoding(sort)) {\n    var encoding = sort.encoding,\n      order = sort.order;\n    var fieldDefToSortBy = model.fieldDef(encoding);\n    var aggregate = fieldDefToSortBy.aggregate,\n      field = fieldDefToSortBy.field;\n    var _isStackedMeasure = stack && !stackDimensions.has(field);\n    if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {\n      return normalizeSortField({\n        field: vgField(fieldDefToSortBy),\n        order: order\n      }, _isStackedMeasure);\n    } else if (isAggregateOp(aggregate) || !aggregate) {\n      return normalizeSortField({\n        op: aggregate,\n        field: field,\n        order: order\n      }, _isStackedMeasure);\n    }\n  } else if (sort === 'descending') {\n    return {\n      op: 'min',\n      field: model.vgField(channel),\n      order: 'descending'\n    };\n  } else if (util.contains(['ascending', undefined /* default =ascending*/], sort)) {\n    return true;\n  }\n  // sort == null\n  return undefined;\n}\n/**\n * Determine if a scale can use unaggregated domain.\n * @return {Boolean} Returns true if all of the following conditions apply:\n * 1. `scale.domain` is `unaggregated`\n * 2. Aggregation function is not `count` or `sum`\n * 3. The scale is quantitative or time scale.\n */\nexport function canUseUnaggregatedDomain(fieldDef, scaleType) {\n  var aggregate = fieldDef.aggregate,\n    type = fieldDef.type;\n  if (!aggregate) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainHasNoEffectForRawField(fieldDef)\n    };\n  }\n  if (isString(aggregate) && !SHARED_DOMAIN_OPS.has(aggregate)) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainWithNonSharedDomainOp(aggregate)\n    };\n  }\n  if (type === 'quantitative') {\n    if (scaleType === 'log') {\n      return {\n        valid: false,\n        reason: log.message.unaggregatedDomainWithLogScale(fieldDef)\n      };\n    }\n  }\n  return {\n    valid: true\n  };\n}\n/**\n * Tie breaker for mergeValuesWithExplicit for domains. We concat the specified values.\n */\nfunction domainsTieBreaker(v1, v2, property, propertyOf) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingDomainProperty(property, propertyOf, v1.value, v2.value));\n  }\n  // If equal score, concat the domains so that we union them later.\n  return {\n    explicit: v1.explicit,\n    value: [].concat(_toConsumableArray(v1.value), _toConsumableArray(v2.value))\n  };\n}\n/**\n * Converts an array of domains to a single Vega scale domain.\n */\nexport function mergeDomains(domains) {\n  var uniqueDomains = util.unique(domains.map(function (domain) {\n    // ignore sort property when computing the unique domains\n    if (isDataRefDomain(domain)) {\n      var _s = domain.sort,\n        domainWithoutSort = __rest(domain, [\"sort\"]);\n      return domainWithoutSort;\n    }\n    return domain;\n  }), util.hash);\n  var sorts = util.unique(domains.map(function (d) {\n    if (isDataRefDomain(d)) {\n      var s = d.sort;\n      if (s !== undefined && !util.isBoolean(s)) {\n        if ('op' in s && s.op === 'count') {\n          // let's make sure that if op is count, we don't use a field\n          delete s.field;\n        }\n        if (s.order === 'ascending') {\n          // drop order: ascending as it is the default\n          delete s.order;\n        }\n      }\n      return s;\n    }\n    return undefined;\n  }).filter(function (s) {\n    return s !== undefined;\n  }), util.hash);\n  if (uniqueDomains.length === 0) {\n    return undefined;\n  } else if (uniqueDomains.length === 1) {\n    var domain = domains[0];\n    if (isDataRefDomain(domain) && sorts.length > 0) {\n      var _sort = sorts[0];\n      if (sorts.length > 1) {\n        log.warn(log.message.MORE_THAN_ONE_SORT);\n        _sort = true;\n      } else {\n        // Simplify domain sort by removing field and op when the field is the same as the domain field.\n        if (isObject(_sort) && 'field' in _sort) {\n          var sortField = _sort.field;\n          if (domain.field === sortField) {\n            _sort = _sort.order ? {\n              order: _sort.order\n            } : true;\n          }\n        }\n      }\n      return Object.assign(Object.assign({}, domain), {\n        sort: _sort\n      });\n    }\n    return domain;\n  }\n  // only keep sort properties that work with unioned domains\n  var unionDomainSorts = util.unique(sorts.map(function (s) {\n    if (util.isBoolean(s) || !('op' in s) || isString(s.op) && s.op in UNIONDOMAIN_SORT_OP_INDEX) {\n      return s;\n    }\n    log.warn(log.message.domainSortDropped(s));\n    return true;\n  }), util.hash);\n  var sort;\n  if (unionDomainSorts.length === 1) {\n    sort = unionDomainSorts[0];\n  } else if (unionDomainSorts.length > 1) {\n    log.warn(log.message.MORE_THAN_ONE_SORT);\n    sort = true;\n  }\n  var allData = util.unique(domains.map(function (d) {\n    if (isDataRefDomain(d)) {\n      return d.data;\n    }\n    return null;\n  }), function (x) {\n    return x;\n  });\n  if (allData.length === 1 && allData[0] !== null) {\n    // create a union domain of different fields with a single data source\n    var _domain = Object.assign({\n      data: allData[0],\n      fields: uniqueDomains.map(function (d) {\n        return d.field;\n      })\n    }, sort ? {\n      sort: sort\n    } : {});\n    return _domain;\n  }\n  return Object.assign({\n    fields: uniqueDomains\n  }, sort ? {\n    sort: sort\n  } : {});\n}\n/**\n * Return a field if a scale uses a single field.\n * Return `undefined` otherwise.\n */\nexport function getFieldFromDomain(domain) {\n  if (isDataRefDomain(domain) && isString(domain.field)) {\n    return domain.field;\n  } else if (isDataRefUnionedDomain(domain)) {\n    var field;\n    var _iterator6 = _createForOfIteratorHelper(domain.fields),\n      _step6;\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var nonUnionDomain = _step6.value;\n        if (isDataRefDomain(nonUnionDomain) && isString(nonUnionDomain.field)) {\n          if (!field) {\n            field = nonUnionDomain.field;\n          } else if (field !== nonUnionDomain.field) {\n            log.warn(log.message.FACETED_INDEPENDENT_DIFFERENT_SOURCES);\n            return field;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n    log.warn(log.message.FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES);\n    return field;\n  } else if (isFieldRefUnionDomain(domain)) {\n    log.warn(log.message.FACETED_INDEPENDENT_SAME_SOURCE);\n    var _field = domain.fields[0];\n    return isString(_field) ? _field : undefined;\n  }\n  return undefined;\n}\nexport function assembleDomain(model, channel) {\n  var scaleComponent = model.component.scales[channel];\n  var domains = scaleComponent.get('domains').map(function (domain) {\n    // Correct references to data as the original domain's data was determined\n    // in parseScale, which happens before parseData. Thus the original data\n    // reference can be incorrect.\n    if (isDataRefDomain(domain)) {\n      domain.data = model.lookupDataSource(domain.data);\n    }\n    return domain;\n  });\n  // domains is an array that has to be merged into a single vega domain\n  return mergeDomains(domains);\n}","map":{"version":3,"sources":["../../../../src/compile/scale/domain.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isObject, isString } from 'vega-util';\nimport { isAggregateOp, isArgmaxDef, isArgminDef, MULTIDOMAIN_SORT_OP_INDEX as UNIONDOMAIN_SORT_OP_INDEX, SHARED_DOMAIN_OPS } from '../../aggregate';\nimport { isBinning, isBinParams, isParameterExtent } from '../../bin';\nimport { getSecondaryRangeChannel, isScaleChannel } from '../../channel';\nimport { binRequiresRange, getFieldOrDatumDef, hasBandEnd, isDatumDef, isFieldDef, valueExpr, vgField } from '../../channeldef';\nimport { DataSourceType } from '../../data';\nimport * as log from '../../log';\nimport { hasDiscreteDomain, isDomainUnionWith, isParameterDomain } from '../../scale';\nimport { DEFAULT_SORT_OP, isSortArray, isSortByEncoding, isSortField } from '../../sort';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport * as util from '../../util';\nimport { isDataRefDomain, isDataRefUnionedDomain, isFieldRefUnionDomain, isSignalRef } from '../../vega.schema';\nimport { getBinSignalName } from '../data/bin';\nimport { sortArrayIndexField } from '../data/calculate';\nimport { FACET_SCALE_PREFIX } from '../data/optimize';\nimport { isFacetModel, isUnitModel } from '../model';\nimport { SignalRefWrapper } from '../signal';\nimport { makeExplicit, makeImplicit, mergeValuesWithExplicit } from '../split';\nexport function parseScaleDomain(model) {\n    if (isUnitModel(model)) {\n        parseUnitScaleDomain(model);\n    }\n    else {\n        parseNonUnitScaleDomain(model);\n    }\n}\nfunction parseUnitScaleDomain(model) {\n    const localScaleComponents = model.component.scales;\n    for (const channel of util.keys(localScaleComponents)) {\n        const domains = parseDomainForChannel(model, channel);\n        const localScaleCmpt = localScaleComponents[channel];\n        localScaleCmpt.setWithExplicit('domains', domains);\n        parseSelectionDomain(model, channel);\n        if (model.component.data.isFaceted) {\n            // get resolve from closest facet parent as this decides whether we need to refer to cloned subtree or not\n            let facetParent = model;\n            while (!isFacetModel(facetParent) && facetParent.parent) {\n                facetParent = facetParent.parent;\n            }\n            const resolve = facetParent.component.resolve.scale[channel];\n            if (resolve === 'shared') {\n                for (const domain of domains.value) {\n                    // Replace the scale domain with data output from a cloned subtree after the facet.\n                    if (isDataRefDomain(domain)) {\n                        // use data from cloned subtree (which is the same as data but with a prefix added once)\n                        domain.data = FACET_SCALE_PREFIX + domain.data.replace(FACET_SCALE_PREFIX, '');\n                    }\n                }\n            }\n        }\n    }\n}\nfunction parseNonUnitScaleDomain(model) {\n    for (const child of model.children) {\n        parseScaleDomain(child);\n    }\n    const localScaleComponents = model.component.scales;\n    for (const channel of util.keys(localScaleComponents)) {\n        let domains;\n        let selectionExtent = null;\n        for (const child of model.children) {\n            const childComponent = child.component.scales[channel];\n            if (childComponent) {\n                if (domains === undefined) {\n                    domains = childComponent.getWithExplicit('domains');\n                }\n                else {\n                    domains = mergeValuesWithExplicit(domains, childComponent.getWithExplicit('domains'), 'domains', 'scale', domainsTieBreaker);\n                }\n                const se = childComponent.get('selectionExtent');\n                if (selectionExtent && se && selectionExtent.param !== se.param) {\n                    log.warn(log.message.NEEDS_SAME_SELECTION);\n                }\n                selectionExtent = se;\n            }\n        }\n        localScaleComponents[channel].setWithExplicit('domains', domains);\n        if (selectionExtent) {\n            localScaleComponents[channel].set('selectionExtent', selectionExtent, true);\n        }\n    }\n}\n/**\n * Remove unaggregated domain if it is not applicable\n * Add unaggregated domain if domain is not specified and config.scale.useUnaggregatedDomain is true.\n */\nfunction normalizeUnaggregatedDomain(domain, fieldDef, scaleType, scaleConfig) {\n    if (domain === 'unaggregated') {\n        const { valid, reason } = canUseUnaggregatedDomain(fieldDef, scaleType);\n        if (!valid) {\n            log.warn(reason);\n            return undefined;\n        }\n    }\n    else if (domain === undefined && scaleConfig.useUnaggregatedDomain) {\n        // Apply config if domain is not specified.\n        const { valid } = canUseUnaggregatedDomain(fieldDef, scaleType);\n        if (valid) {\n            return 'unaggregated';\n        }\n    }\n    return domain;\n}\nexport function parseDomainForChannel(model, channel) {\n    const scaleType = model.getScaleComponent(channel).get('type');\n    const { encoding } = model;\n    const domain = normalizeUnaggregatedDomain(model.scaleDomain(channel), model.typedFieldDef(channel), scaleType, model.config.scale);\n    if (domain !== model.scaleDomain(channel)) {\n        model.specifiedScales[channel] = Object.assign(Object.assign({}, model.specifiedScales[channel]), { domain });\n    }\n    // If channel is either X or Y then union them with X2 & Y2 if they exist\n    if (channel === 'x' && getFieldOrDatumDef(encoding.x2)) {\n        if (getFieldOrDatumDef(encoding.x)) {\n            return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType, domain, model, 'x'), parseSingleChannelDomain(scaleType, domain, model, 'x2'), 'domain', 'scale', domainsTieBreaker);\n        }\n        else {\n            return parseSingleChannelDomain(scaleType, domain, model, 'x2');\n        }\n    }\n    else if (channel === 'y' && getFieldOrDatumDef(encoding.y2)) {\n        if (getFieldOrDatumDef(encoding.y)) {\n            return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType, domain, model, 'y'), parseSingleChannelDomain(scaleType, domain, model, 'y2'), 'domain', 'scale', domainsTieBreaker);\n        }\n        else {\n            return parseSingleChannelDomain(scaleType, domain, model, 'y2');\n        }\n    }\n    return parseSingleChannelDomain(scaleType, domain, model, channel);\n}\nfunction mapDomainToDataSignal(domain, type, timeUnit) {\n    return domain.map(v => {\n        const data = valueExpr(v, { timeUnit, type });\n        return { signal: `{data: ${data}}` };\n    });\n}\nfunction convertDomainIfItIsDateTime(domain, type, timeUnit) {\n    var _a;\n    // explicit value\n    const normalizedTimeUnit = (_a = normalizeTimeUnit(timeUnit)) === null || _a === void 0 ? void 0 : _a.unit;\n    if (type === 'temporal' || normalizedTimeUnit) {\n        return mapDomainToDataSignal(domain, type, normalizedTimeUnit);\n    }\n    return [domain]; // Date time won't make sense\n}\nfunction parseSingleChannelDomain(scaleType, domain, model, channel) {\n    const { encoding } = model;\n    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n    const { type } = fieldOrDatumDef;\n    const timeUnit = fieldOrDatumDef['timeUnit'];\n    if (isDomainUnionWith(domain)) {\n        const defaultDomain = parseSingleChannelDomain(scaleType, undefined, model, channel);\n        const unionWith = convertDomainIfItIsDateTime(domain.unionWith, type, timeUnit);\n        return makeExplicit([...unionWith, ...defaultDomain.value]);\n    }\n    else if (isSignalRef(domain)) {\n        return makeExplicit([domain]);\n    }\n    else if (domain && domain !== 'unaggregated' && !isParameterDomain(domain)) {\n        return makeExplicit(convertDomainIfItIsDateTime(domain, type, timeUnit));\n    }\n    const stack = model.stack;\n    if (stack && channel === stack.fieldChannel) {\n        if (stack.offset === 'normalize') {\n            return makeImplicit([[0, 1]]);\n        }\n        const data = model.requestDataName(DataSourceType.Main);\n        return makeImplicit([\n            {\n                data,\n                field: model.vgField(channel, { suffix: 'start' })\n            },\n            {\n                data,\n                field: model.vgField(channel, { suffix: 'end' })\n            }\n        ]);\n    }\n    const sort = isScaleChannel(channel) && isFieldDef(fieldOrDatumDef) ? domainSort(model, channel, scaleType) : undefined;\n    if (isDatumDef(fieldOrDatumDef)) {\n        const d = convertDomainIfItIsDateTime([fieldOrDatumDef.datum], type, timeUnit);\n        return makeImplicit(d);\n    }\n    const fieldDef = fieldOrDatumDef; // now we can be sure it's a fieldDef\n    if (domain === 'unaggregated') {\n        const data = model.requestDataName(DataSourceType.Main);\n        const { field } = fieldOrDatumDef;\n        return makeImplicit([\n            {\n                data,\n                field: vgField({ field, aggregate: 'min' })\n            },\n            {\n                data,\n                field: vgField({ field, aggregate: 'max' })\n            }\n        ]);\n    }\n    else if (isBinning(fieldDef.bin)) {\n        if (hasDiscreteDomain(scaleType)) {\n            if (scaleType === 'bin-ordinal') {\n                // we can omit the domain as it is inferred from the `bins` property\n                return makeImplicit([]);\n            }\n            // ordinal bin scale takes domain from bin_range, ordered by bin start\n            // This is useful for both axis-based scale (x/y) and legend-based scale (other channels).\n            return makeImplicit([\n                {\n                    // If sort by aggregation of a specified sort field, we need to use RAW table,\n                    // so we can aggregate values for the scale independently from the main aggregation.\n                    data: util.isBoolean(sort)\n                        ? model.requestDataName(DataSourceType.Main)\n                        : model.requestDataName(DataSourceType.Raw),\n                    // Use range if we added it and the scale does not support computing a range as a signal.\n                    field: model.vgField(channel, binRequiresRange(fieldDef, channel) ? { binSuffix: 'range' } : {}),\n                    // we have to use a sort object if sort = true to make the sort correct by bin start\n                    sort: sort === true || !isObject(sort)\n                        ? {\n                            field: model.vgField(channel, {}),\n                            op: 'min' // min or max doesn't matter since we sort by the start of the bin range\n                        }\n                        : sort\n                }\n            ]);\n        }\n        else {\n            // continuous scales\n            const { bin } = fieldDef;\n            if (isBinning(bin)) {\n                const binSignal = getBinSignalName(model, fieldDef.field, bin);\n                return makeImplicit([\n                    new SignalRefWrapper(() => {\n                        const signal = model.getSignalName(binSignal);\n                        return `[${signal}.start, ${signal}.stop]`;\n                    })\n                ]);\n            }\n            else {\n                return makeImplicit([\n                    {\n                        data: model.requestDataName(DataSourceType.Main),\n                        field: model.vgField(channel, {})\n                    }\n                ]);\n            }\n        }\n    }\n    else if (fieldDef.timeUnit &&\n        util.contains(['time', 'utc'], scaleType) &&\n        hasBandEnd(fieldDef, isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined, model.markDef, model.config)) {\n        const data = model.requestDataName(DataSourceType.Main);\n        return makeImplicit([\n            {\n                data,\n                field: model.vgField(channel)\n            },\n            {\n                data,\n                field: model.vgField(channel, { suffix: 'end' })\n            }\n        ]);\n    }\n    else if (sort) {\n        return makeImplicit([\n            {\n                // If sort by aggregation of a specified sort field, we need to use RAW table,\n                // so we can aggregate values for the scale independently from the main aggregation.\n                data: util.isBoolean(sort)\n                    ? model.requestDataName(DataSourceType.Main)\n                    : model.requestDataName(DataSourceType.Raw),\n                field: model.vgField(channel),\n                sort\n            }\n        ]);\n    }\n    else {\n        return makeImplicit([\n            {\n                data: model.requestDataName(DataSourceType.Main),\n                field: model.vgField(channel)\n            }\n        ]);\n    }\n}\nfunction normalizeSortField(sort, isStackedMeasure) {\n    const { op, field, order } = sort;\n    return Object.assign(Object.assign({ \n        // Apply default op\n        op: op !== null && op !== void 0 ? op : (isStackedMeasure ? 'sum' : DEFAULT_SORT_OP) }, (field ? { field: util.replacePathInField(field) } : {})), (order ? { order } : {}));\n}\nfunction parseSelectionDomain(model, channel) {\n    var _a;\n    const scale = model.component.scales[channel];\n    const spec = model.specifiedScales[channel].domain;\n    const bin = (_a = model.fieldDef(channel)) === null || _a === void 0 ? void 0 : _a.bin;\n    const domain = isParameterDomain(spec) && spec;\n    const extent = isBinParams(bin) && isParameterExtent(bin.extent) && bin.extent;\n    if (domain || extent) {\n        // As scale parsing occurs before selection parsing, we cannot set\n        // domainRaw directly. So instead, we store the selectionExtent on\n        // the scale component, and then add domainRaw during scale assembly.\n        scale.set('selectionExtent', domain !== null && domain !== void 0 ? domain : extent, true);\n    }\n}\nexport function domainSort(model, channel, scaleType) {\n    if (!hasDiscreteDomain(scaleType)) {\n        return undefined;\n    }\n    // save to cast as the only exception is the geojson type for shape, which would not generate a scale\n    const fieldDef = model.fieldDef(channel);\n    const sort = fieldDef.sort;\n    // if the sort is specified with array, use the derived sort index field\n    if (isSortArray(sort)) {\n        return {\n            op: 'min',\n            field: sortArrayIndexField(fieldDef, channel),\n            order: 'ascending'\n        };\n    }\n    const { stack } = model;\n    const stackDimensions = stack\n        ? new Set([...stack.groupbyFields, ...stack.stackBy.map(s => s.fieldDef.field)])\n        : undefined;\n    // Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)\n    if (isSortField(sort)) {\n        const isStackedMeasure = stack && !stackDimensions.has(sort.field);\n        return normalizeSortField(sort, isStackedMeasure);\n    }\n    else if (isSortByEncoding(sort)) {\n        const { encoding, order } = sort;\n        const fieldDefToSortBy = model.fieldDef(encoding);\n        const { aggregate, field } = fieldDefToSortBy;\n        const isStackedMeasure = stack && !stackDimensions.has(field);\n        if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {\n            return normalizeSortField({\n                field: vgField(fieldDefToSortBy),\n                order\n            }, isStackedMeasure);\n        }\n        else if (isAggregateOp(aggregate) || !aggregate) {\n            return normalizeSortField({\n                op: aggregate,\n                field,\n                order\n            }, isStackedMeasure);\n        }\n    }\n    else if (sort === 'descending') {\n        return {\n            op: 'min',\n            field: model.vgField(channel),\n            order: 'descending'\n        };\n    }\n    else if (util.contains(['ascending', undefined /* default =ascending*/], sort)) {\n        return true;\n    }\n    // sort == null\n    return undefined;\n}\n/**\n * Determine if a scale can use unaggregated domain.\n * @return {Boolean} Returns true if all of the following conditions apply:\n * 1. `scale.domain` is `unaggregated`\n * 2. Aggregation function is not `count` or `sum`\n * 3. The scale is quantitative or time scale.\n */\nexport function canUseUnaggregatedDomain(fieldDef, scaleType) {\n    const { aggregate, type } = fieldDef;\n    if (!aggregate) {\n        return {\n            valid: false,\n            reason: log.message.unaggregateDomainHasNoEffectForRawField(fieldDef)\n        };\n    }\n    if (isString(aggregate) && !SHARED_DOMAIN_OPS.has(aggregate)) {\n        return {\n            valid: false,\n            reason: log.message.unaggregateDomainWithNonSharedDomainOp(aggregate)\n        };\n    }\n    if (type === 'quantitative') {\n        if (scaleType === 'log') {\n            return {\n                valid: false,\n                reason: log.message.unaggregatedDomainWithLogScale(fieldDef)\n            };\n        }\n    }\n    return { valid: true };\n}\n/**\n * Tie breaker for mergeValuesWithExplicit for domains. We concat the specified values.\n */\nfunction domainsTieBreaker(v1, v2, property, propertyOf) {\n    if (v1.explicit && v2.explicit) {\n        log.warn(log.message.mergeConflictingDomainProperty(property, propertyOf, v1.value, v2.value));\n    }\n    // If equal score, concat the domains so that we union them later.\n    return { explicit: v1.explicit, value: [...v1.value, ...v2.value] };\n}\n/**\n * Converts an array of domains to a single Vega scale domain.\n */\nexport function mergeDomains(domains) {\n    const uniqueDomains = util.unique(domains.map(domain => {\n        // ignore sort property when computing the unique domains\n        if (isDataRefDomain(domain)) {\n            const { sort: _s } = domain, domainWithoutSort = __rest(domain, [\"sort\"]);\n            return domainWithoutSort;\n        }\n        return domain;\n    }), util.hash);\n    const sorts = util.unique(domains\n        .map(d => {\n        if (isDataRefDomain(d)) {\n            const s = d.sort;\n            if (s !== undefined && !util.isBoolean(s)) {\n                if ('op' in s && s.op === 'count') {\n                    // let's make sure that if op is count, we don't use a field\n                    delete s.field;\n                }\n                if (s.order === 'ascending') {\n                    // drop order: ascending as it is the default\n                    delete s.order;\n                }\n            }\n            return s;\n        }\n        return undefined;\n    })\n        .filter(s => s !== undefined), util.hash);\n    if (uniqueDomains.length === 0) {\n        return undefined;\n    }\n    else if (uniqueDomains.length === 1) {\n        const domain = domains[0];\n        if (isDataRefDomain(domain) && sorts.length > 0) {\n            let sort = sorts[0];\n            if (sorts.length > 1) {\n                log.warn(log.message.MORE_THAN_ONE_SORT);\n                sort = true;\n            }\n            else {\n                // Simplify domain sort by removing field and op when the field is the same as the domain field.\n                if (isObject(sort) && 'field' in sort) {\n                    const sortField = sort.field;\n                    if (domain.field === sortField) {\n                        sort = sort.order ? { order: sort.order } : true;\n                    }\n                }\n            }\n            return Object.assign(Object.assign({}, domain), { sort });\n        }\n        return domain;\n    }\n    // only keep sort properties that work with unioned domains\n    const unionDomainSorts = util.unique(sorts.map(s => {\n        if (util.isBoolean(s) || !('op' in s) || (isString(s.op) && s.op in UNIONDOMAIN_SORT_OP_INDEX)) {\n            return s;\n        }\n        log.warn(log.message.domainSortDropped(s));\n        return true;\n    }), util.hash);\n    let sort;\n    if (unionDomainSorts.length === 1) {\n        sort = unionDomainSorts[0];\n    }\n    else if (unionDomainSorts.length > 1) {\n        log.warn(log.message.MORE_THAN_ONE_SORT);\n        sort = true;\n    }\n    const allData = util.unique(domains.map(d => {\n        if (isDataRefDomain(d)) {\n            return d.data;\n        }\n        return null;\n    }), x => x);\n    if (allData.length === 1 && allData[0] !== null) {\n        // create a union domain of different fields with a single data source\n        const domain = Object.assign({ data: allData[0], fields: uniqueDomains.map(d => d.field) }, (sort ? { sort } : {}));\n        return domain;\n    }\n    return Object.assign({ fields: uniqueDomains }, (sort ? { sort } : {}));\n}\n/**\n * Return a field if a scale uses a single field.\n * Return `undefined` otherwise.\n */\nexport function getFieldFromDomain(domain) {\n    if (isDataRefDomain(domain) && isString(domain.field)) {\n        return domain.field;\n    }\n    else if (isDataRefUnionedDomain(domain)) {\n        let field;\n        for (const nonUnionDomain of domain.fields) {\n            if (isDataRefDomain(nonUnionDomain) && isString(nonUnionDomain.field)) {\n                if (!field) {\n                    field = nonUnionDomain.field;\n                }\n                else if (field !== nonUnionDomain.field) {\n                    log.warn(log.message.FACETED_INDEPENDENT_DIFFERENT_SOURCES);\n                    return field;\n                }\n            }\n        }\n        log.warn(log.message.FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES);\n        return field;\n    }\n    else if (isFieldRefUnionDomain(domain)) {\n        log.warn(log.message.FACETED_INDEPENDENT_SAME_SOURCE);\n        const field = domain.fields[0];\n        return isString(field) ? field : undefined;\n    }\n    return undefined;\n}\nexport function assembleDomain(model, channel) {\n    const scaleComponent = model.component.scales[channel];\n    const domains = scaleComponent.get('domains').map((domain) => {\n        // Correct references to data as the original domain's data was determined\n        // in parseScale, which happens before parseData. Thus the original data\n        // reference can be incorrect.\n        if (isDataRefDomain(domain)) {\n            domain.data = model.lookupDataSource(domain.data);\n        }\n        return domain;\n    });\n    // domains is an array that has to be merged into a single vega domain\n    return mergeDomains(domains);\n}\n//# sourceMappingURL=domain.js.map"]},"metadata":{},"sourceType":"module"}