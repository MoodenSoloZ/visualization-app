{"ast":null,"code":"import _classCallCheck from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { isArgmaxDef, isArgminDef } from '../../aggregate';\nimport { getPositionChannelFromLatLong, getSecondaryRangeChannel, isGeoPositionChannel, isScaleChannel } from '../../channel';\nimport { binRequiresRange, hasBandEnd, isScaleFieldDef, isTypedFieldDef, vgField } from '../../channeldef';\nimport * as log from '../../log';\nimport { isFieldRange } from '../../scale';\nimport { duplicate, hash as _hash, keys, replacePathInField, setEqual } from '../../util';\nimport { isUnitModel } from '../model';\nimport { DataFlowNode } from './dataflow';\nfunction addDimension(dims, channel, fieldDef, model) {\n  var _a;\n  var channelDef2 = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined;\n  if (isTypedFieldDef(fieldDef) && isUnitModel(model) && hasBandEnd(fieldDef, channelDef2, model.markDef, model.config)) {\n    dims.add(vgField(fieldDef, {}));\n    dims.add(vgField(fieldDef, {\n      suffix: 'end'\n    }));\n    if (fieldDef.bin && binRequiresRange(fieldDef, channel)) {\n      dims.add(vgField(fieldDef, {\n        binSuffix: 'range'\n      }));\n    }\n  } else if (isGeoPositionChannel(channel)) {\n    var posChannel = getPositionChannelFromLatLong(channel);\n    dims.add(model.getName(posChannel));\n  } else {\n    dims.add(vgField(fieldDef));\n  }\n  if (isScaleFieldDef(fieldDef) && isFieldRange((_a = fieldDef.scale) === null || _a === void 0 ? void 0 : _a.range)) {\n    dims.add(fieldDef.scale.range.field);\n  }\n  return dims;\n}\nfunction mergeMeasures(parentMeasures, childMeasures) {\n  var _a;\n  var _iterator = _createForOfIteratorHelper(keys(childMeasures)),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var field = _step.value;\n      // when we merge a measure, we either have to add an aggregation operator or even a new field\n      var ops = childMeasures[field];\n      var _iterator2 = _createForOfIteratorHelper(keys(ops)),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var op = _step2.value;\n          if (field in parentMeasures) {\n            // add operator to existing measure field\n            parentMeasures[field][op] = new Set([].concat(_toConsumableArray((_a = parentMeasures[field][op]) !== null && _a !== void 0 ? _a : []), _toConsumableArray(ops[op])));\n          } else {\n            parentMeasures[field] = _defineProperty({}, op, ops[op]);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nexport var AggregateNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(AggregateNode, _DataFlowNode);\n  var _super = _createSuper(AggregateNode);\n  /**\n   * @param dimensions string set for dimensions\n   * @param measures dictionary mapping field name => dict of aggregation functions and names to use\n   */\n  function AggregateNode(parent, dimensions, measures) {\n    var _this;\n    _classCallCheck(this, AggregateNode);\n    _this = _super.call(this, parent);\n    _this.dimensions = dimensions;\n    _this.measures = measures;\n    return _this;\n  }\n  _createClass(AggregateNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new AggregateNode(null, new Set(this.dimensions), duplicate(this.measures));\n    }\n  }, {\n    key: \"groupBy\",\n    get: function get() {\n      return this.dimensions;\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(other) {\n      if (setEqual(this.dimensions, other.dimensions)) {\n        mergeMeasures(this.measures, other.measures);\n        return true;\n      }\n      log.debug('different dimensions, cannot merge');\n      return false;\n    }\n  }, {\n    key: \"addDimensions\",\n    value: function addDimensions(fields) {\n      fields.forEach(this.dimensions.add, this.dimensions);\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return new Set([].concat(_toConsumableArray(this.dimensions), _toConsumableArray(keys(this.measures))));\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      var out = new Set();\n      var _iterator3 = _createForOfIteratorHelper(keys(this.measures)),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var field = _step3.value;\n          var _iterator4 = _createForOfIteratorHelper(keys(this.measures[field])),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var op = _step4.value;\n              var m = this.measures[field][op];\n              if (m.size === 0) {\n                out.add(\"\".concat(op, \"_\").concat(field));\n              } else {\n                m.forEach(out.add, out);\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return out;\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"Aggregate \".concat(_hash({\n        dimensions: this.dimensions,\n        measures: this.measures\n      }));\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      var ops = [];\n      var fields = [];\n      var as = [];\n      var _iterator5 = _createForOfIteratorHelper(keys(this.measures)),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var field = _step5.value;\n          var _iterator6 = _createForOfIteratorHelper(keys(this.measures[field])),\n            _step6;\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var op = _step6.value;\n              var _iterator7 = _createForOfIteratorHelper(this.measures[field][op]),\n                _step7;\n              try {\n                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                  var alias = _step7.value;\n                  as.push(alias);\n                  ops.push(op);\n                  fields.push(field === '*' ? null : replacePathInField(field));\n                }\n              } catch (err) {\n                _iterator7.e(err);\n              } finally {\n                _iterator7.f();\n              }\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      var result = {\n        type: 'aggregate',\n        groupby: _toConsumableArray(this.dimensions).map(replacePathInField),\n        ops: ops,\n        fields: fields,\n        as: as\n      };\n      return result;\n    }\n  }], [{\n    key: \"makeFromEncoding\",\n    value: function makeFromEncoding(parent, model) {\n      var isAggregate = false;\n      model.forEachFieldDef(function (fd) {\n        if (fd.aggregate) {\n          isAggregate = true;\n        }\n      });\n      var meas = {};\n      var dims = new Set();\n      if (!isAggregate) {\n        // no need to create this node if the model has no aggregation\n        return null;\n      }\n      model.forEachFieldDef(function (fieldDef, channel) {\n        var _a, _b, _c, _d;\n        var aggregate = fieldDef.aggregate,\n          field = fieldDef.field;\n        if (aggregate) {\n          if (aggregate === 'count') {\n            (_a = meas['*']) !== null && _a !== void 0 ? _a : meas['*'] = {};\n            meas['*']['count'] = new Set([vgField(fieldDef, {\n              forAs: true\n            })]);\n          } else {\n            if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {\n              var op = isArgminDef(aggregate) ? 'argmin' : 'argmax';\n              var argField = aggregate[op];\n              (_b = meas[argField]) !== null && _b !== void 0 ? _b : meas[argField] = {};\n              meas[argField][op] = new Set([vgField({\n                op: op,\n                field: argField\n              }, {\n                forAs: true\n              })]);\n            } else {\n              (_c = meas[field]) !== null && _c !== void 0 ? _c : meas[field] = {};\n              meas[field][aggregate] = new Set([vgField(fieldDef, {\n                forAs: true\n              })]);\n            }\n            // For scale channel with domain === 'unaggregated', add min/max so we can use their union as unaggregated domain\n            if (isScaleChannel(channel) && model.scaleDomain(channel) === 'unaggregated') {\n              (_d = meas[field]) !== null && _d !== void 0 ? _d : meas[field] = {};\n              meas[field]['min'] = new Set([vgField({\n                field: field,\n                aggregate: 'min'\n              }, {\n                forAs: true\n              })]);\n              meas[field]['max'] = new Set([vgField({\n                field: field,\n                aggregate: 'max'\n              }, {\n                forAs: true\n              })]);\n            }\n          }\n        } else {\n          addDimension(dims, channel, fieldDef, model);\n        }\n      });\n      if (dims.size + keys(meas).length === 0) {\n        return null;\n      }\n      return new AggregateNode(parent, dims, meas);\n    }\n  }, {\n    key: \"makeFromTransform\",\n    value: function makeFromTransform(parent, t) {\n      var _a, _b, _c;\n      var dims = new Set();\n      var meas = {};\n      var _iterator8 = _createForOfIteratorHelper(t.aggregate),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var s = _step8.value;\n          var op = s.op,\n            field = s.field,\n            as = s.as;\n          if (op) {\n            if (op === 'count') {\n              (_a = meas['*']) !== null && _a !== void 0 ? _a : meas['*'] = {};\n              meas['*']['count'] = new Set([as ? as : vgField(s, {\n                forAs: true\n              })]);\n            } else {\n              (_b = meas[field]) !== null && _b !== void 0 ? _b : meas[field] = {};\n              meas[field][op] = new Set([as ? as : vgField(s, {\n                forAs: true\n              })]);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n      var _iterator9 = _createForOfIteratorHelper((_c = t.groupby) !== null && _c !== void 0 ? _c : []),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var _s = _step9.value;\n          dims.add(_s);\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n      if (dims.size + keys(meas).length === 0) {\n        return null;\n      }\n      return new AggregateNode(parent, dims, meas);\n    }\n  }]);\n  return AggregateNode;\n}(DataFlowNode);","map":{"version":3,"sources":["../../../../src/compile/data/aggregate.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArgmaxDef, isArgminDef } from '../../aggregate';\nimport { getPositionChannelFromLatLong, getSecondaryRangeChannel, isGeoPositionChannel, isScaleChannel } from '../../channel';\nimport { binRequiresRange, hasBandEnd, isScaleFieldDef, isTypedFieldDef, vgField } from '../../channeldef';\nimport * as log from '../../log';\nimport { isFieldRange } from '../../scale';\nimport { duplicate, hash, keys, replacePathInField, setEqual } from '../../util';\nimport { isUnitModel } from '../model';\nimport { DataFlowNode } from './dataflow';\nfunction addDimension(dims, channel, fieldDef, model) {\n    var _a;\n    const channelDef2 = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined;\n    if (isTypedFieldDef(fieldDef) &&\n        isUnitModel(model) &&\n        hasBandEnd(fieldDef, channelDef2, model.markDef, model.config)) {\n        dims.add(vgField(fieldDef, {}));\n        dims.add(vgField(fieldDef, { suffix: 'end' }));\n        if (fieldDef.bin && binRequiresRange(fieldDef, channel)) {\n            dims.add(vgField(fieldDef, { binSuffix: 'range' }));\n        }\n    }\n    else if (isGeoPositionChannel(channel)) {\n        const posChannel = getPositionChannelFromLatLong(channel);\n        dims.add(model.getName(posChannel));\n    }\n    else {\n        dims.add(vgField(fieldDef));\n    }\n    if (isScaleFieldDef(fieldDef) && isFieldRange((_a = fieldDef.scale) === null || _a === void 0 ? void 0 : _a.range)) {\n        dims.add(fieldDef.scale.range.field);\n    }\n    return dims;\n}\nfunction mergeMeasures(parentMeasures, childMeasures) {\n    var _a;\n    for (const field of keys(childMeasures)) {\n        // when we merge a measure, we either have to add an aggregation operator or even a new field\n        const ops = childMeasures[field];\n        for (const op of keys(ops)) {\n            if (field in parentMeasures) {\n                // add operator to existing measure field\n                parentMeasures[field][op] = new Set([...((_a = parentMeasures[field][op]) !== null && _a !== void 0 ? _a : []), ...ops[op]]);\n            }\n            else {\n                parentMeasures[field] = { [op]: ops[op] };\n            }\n        }\n    }\n}\nexport class AggregateNode extends DataFlowNode {\n    /**\n     * @param dimensions string set for dimensions\n     * @param measures dictionary mapping field name => dict of aggregation functions and names to use\n     */\n    constructor(parent, dimensions, measures) {\n        super(parent);\n        this.dimensions = dimensions;\n        this.measures = measures;\n    }\n    clone() {\n        return new AggregateNode(null, new Set(this.dimensions), duplicate(this.measures));\n    }\n    get groupBy() {\n        return this.dimensions;\n    }\n    static makeFromEncoding(parent, model) {\n        let isAggregate = false;\n        model.forEachFieldDef(fd => {\n            if (fd.aggregate) {\n                isAggregate = true;\n            }\n        });\n        const meas = {};\n        const dims = new Set();\n        if (!isAggregate) {\n            // no need to create this node if the model has no aggregation\n            return null;\n        }\n        model.forEachFieldDef((fieldDef, channel) => {\n            var _a, _b, _c, _d;\n            const { aggregate, field } = fieldDef;\n            if (aggregate) {\n                if (aggregate === 'count') {\n                    (_a = meas['*']) !== null && _a !== void 0 ? _a : (meas['*'] = {});\n                    meas['*']['count'] = new Set([vgField(fieldDef, { forAs: true })]);\n                }\n                else {\n                    if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {\n                        const op = isArgminDef(aggregate) ? 'argmin' : 'argmax';\n                        const argField = aggregate[op];\n                        (_b = meas[argField]) !== null && _b !== void 0 ? _b : (meas[argField] = {});\n                        meas[argField][op] = new Set([vgField({ op, field: argField }, { forAs: true })]);\n                    }\n                    else {\n                        (_c = meas[field]) !== null && _c !== void 0 ? _c : (meas[field] = {});\n                        meas[field][aggregate] = new Set([vgField(fieldDef, { forAs: true })]);\n                    }\n                    // For scale channel with domain === 'unaggregated', add min/max so we can use their union as unaggregated domain\n                    if (isScaleChannel(channel) && model.scaleDomain(channel) === 'unaggregated') {\n                        (_d = meas[field]) !== null && _d !== void 0 ? _d : (meas[field] = {});\n                        meas[field]['min'] = new Set([vgField({ field, aggregate: 'min' }, { forAs: true })]);\n                        meas[field]['max'] = new Set([vgField({ field, aggregate: 'max' }, { forAs: true })]);\n                    }\n                }\n            }\n            else {\n                addDimension(dims, channel, fieldDef, model);\n            }\n        });\n        if (dims.size + keys(meas).length === 0) {\n            return null;\n        }\n        return new AggregateNode(parent, dims, meas);\n    }\n    static makeFromTransform(parent, t) {\n        var _a, _b, _c;\n        const dims = new Set();\n        const meas = {};\n        for (const s of t.aggregate) {\n            const { op, field, as } = s;\n            if (op) {\n                if (op === 'count') {\n                    (_a = meas['*']) !== null && _a !== void 0 ? _a : (meas['*'] = {});\n                    meas['*']['count'] = new Set([as ? as : vgField(s, { forAs: true })]);\n                }\n                else {\n                    (_b = meas[field]) !== null && _b !== void 0 ? _b : (meas[field] = {});\n                    meas[field][op] = new Set([as ? as : vgField(s, { forAs: true })]);\n                }\n            }\n        }\n        for (const s of (_c = t.groupby) !== null && _c !== void 0 ? _c : []) {\n            dims.add(s);\n        }\n        if (dims.size + keys(meas).length === 0) {\n            return null;\n        }\n        return new AggregateNode(parent, dims, meas);\n    }\n    merge(other) {\n        if (setEqual(this.dimensions, other.dimensions)) {\n            mergeMeasures(this.measures, other.measures);\n            return true;\n        }\n        log.debug('different dimensions, cannot merge');\n        return false;\n    }\n    addDimensions(fields) {\n        fields.forEach(this.dimensions.add, this.dimensions);\n    }\n    dependentFields() {\n        return new Set([...this.dimensions, ...keys(this.measures)]);\n    }\n    producedFields() {\n        const out = new Set();\n        for (const field of keys(this.measures)) {\n            for (const op of keys(this.measures[field])) {\n                const m = this.measures[field][op];\n                if (m.size === 0) {\n                    out.add(`${op}_${field}`);\n                }\n                else {\n                    m.forEach(out.add, out);\n                }\n            }\n        }\n        return out;\n    }\n    hash() {\n        return `Aggregate ${hash({ dimensions: this.dimensions, measures: this.measures })}`;\n    }\n    assemble() {\n        const ops = [];\n        const fields = [];\n        const as = [];\n        for (const field of keys(this.measures)) {\n            for (const op of keys(this.measures[field])) {\n                for (const alias of this.measures[field][op]) {\n                    as.push(alias);\n                    ops.push(op);\n                    fields.push(field === '*' ? null : replacePathInField(field));\n                }\n            }\n        }\n        const result = {\n            type: 'aggregate',\n            groupby: [...this.dimensions].map(replacePathInField),\n            ops,\n            fields,\n            as\n        };\n        return result;\n    }\n}\n//# sourceMappingURL=aggregate.js.map"]},"metadata":{},"sourceType":"module"}