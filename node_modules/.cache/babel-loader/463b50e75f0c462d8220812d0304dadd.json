{"ast":null,"code":"import _slicedToArray from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { isArray } from 'vega';\nimport { isBinParams } from '../bin';\nimport { isConditionalDef, isFieldDef, isScaleFieldDef } from '../channeldef';\nimport { normalizeLogicalComposition } from '../logical';\nimport { SpecMapper } from '../spec/map';\nimport { isBin, isFilter, isLookup } from '../transform';\nimport { duplicate, entries, vals } from '../util';\nexport var SelectionCompatibilityNormalizer = /*#__PURE__*/function (_SpecMapper) {\n  _inherits(SelectionCompatibilityNormalizer, _SpecMapper);\n  var _super = _createSuper(SelectionCompatibilityNormalizer);\n  function SelectionCompatibilityNormalizer() {\n    _classCallCheck(this, SelectionCompatibilityNormalizer);\n    return _super.apply(this, arguments);\n  }\n  _createClass(SelectionCompatibilityNormalizer, [{\n    key: \"map\",\n    value: function map(spec, normParams) {\n      var _a, _b;\n      (_a = normParams.emptySelections) !== null && _a !== void 0 ? _a : normParams.emptySelections = {};\n      (_b = normParams.selectionPredicates) !== null && _b !== void 0 ? _b : normParams.selectionPredicates = {};\n      spec = normalizeTransforms(spec, normParams);\n      return _get(_getPrototypeOf(SelectionCompatibilityNormalizer.prototype), \"map\", this).call(this, spec, normParams);\n    }\n  }, {\n    key: \"mapLayerOrUnit\",\n    value: function mapLayerOrUnit(spec, normParams) {\n      spec = normalizeTransforms(spec, normParams);\n      if (spec.encoding) {\n        var encoding = {};\n        var _iterator = _createForOfIteratorHelper(entries(spec.encoding)),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n              channel = _step$value[0],\n              enc = _step$value[1];\n            encoding[channel] = normalizeChannelDef(enc, normParams);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        spec = Object.assign(Object.assign({}, spec), {\n          encoding: encoding\n        });\n      }\n      return _get(_getPrototypeOf(SelectionCompatibilityNormalizer.prototype), \"mapLayerOrUnit\", this).call(this, spec, normParams);\n    }\n  }, {\n    key: \"mapUnit\",\n    value: function mapUnit(spec, normParams) {\n      var _a = spec,\n        selection = _a.selection,\n        rest = __rest(_a, [\"selection\"]);\n      if (selection) {\n        return Object.assign(Object.assign({}, rest), {\n          params: entries(selection).map(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n              name = _ref2[0],\n              selDef = _ref2[1];\n            var _a;\n            var _b = selDef,\n              value = _b.init,\n              bind = _b.bind,\n              empty = _b.empty,\n              select = __rest(_b, [\"init\", \"bind\", \"empty\"]);\n            if (select.type === 'single') {\n              select.type = 'point';\n              select.toggle = false;\n            } else if (select.type === 'multi') {\n              select.type = 'point';\n            }\n            // Propagate emptiness forwards and backwards\n            normParams.emptySelections[name] = empty !== 'none';\n            var _iterator2 = _createForOfIteratorHelper(vals((_a = normParams.selectionPredicates[name]) !== null && _a !== void 0 ? _a : {})),\n              _step2;\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var pred = _step2.value;\n                pred.empty = empty !== 'none';\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n            return {\n              name: name,\n              value: value,\n              select: select,\n              bind: bind\n            };\n          })\n        });\n      }\n      return spec;\n    }\n  }]);\n  return SelectionCompatibilityNormalizer;\n}(SpecMapper);\nfunction normalizeTransforms(spec, normParams) {\n  var tx = spec.transform,\n    rest = __rest(spec, [\"transform\"]);\n  if (tx) {\n    var transform = tx.map(function (t) {\n      if (isFilter(t)) {\n        return {\n          filter: normalizePredicate(t, normParams)\n        };\n      } else if (isBin(t) && isBinParams(t.bin)) {\n        return Object.assign(Object.assign({}, t), {\n          bin: normalizeBinExtent(t.bin)\n        });\n      } else if (isLookup(t)) {\n        var _a = t.from,\n          param = _a.selection,\n          from = __rest(_a, [\"selection\"]);\n        return param ? Object.assign(Object.assign({}, t), {\n          from: Object.assign({\n            param: param\n          }, from)\n        }) : t;\n      }\n      return t;\n    });\n    return Object.assign(Object.assign({}, rest), {\n      transform: transform\n    });\n  }\n  return spec;\n}\nfunction normalizeChannelDef(obj, normParams) {\n  var _a, _b;\n  var enc = duplicate(obj);\n  if (isFieldDef(enc) && isBinParams(enc.bin)) {\n    enc.bin = normalizeBinExtent(enc.bin);\n  }\n  if (isScaleFieldDef(enc) && ((_b = (_a = enc.scale) === null || _a === void 0 ? void 0 : _a.domain) === null || _b === void 0 ? void 0 : _b.selection)) {\n    var _c = enc.scale.domain,\n      param = _c.selection,\n      domain = __rest(_c, [\"selection\"]);\n    enc.scale.domain = Object.assign(Object.assign({}, domain), param ? {\n      param: param\n    } : {});\n  }\n  if (isConditionalDef(enc)) {\n    if (isArray(enc.condition)) {\n      enc.condition = enc.condition.map(function (c) {\n        var selection = c.selection,\n          param = c.param,\n          test = c.test,\n          cond = __rest(c, [\"selection\", \"param\", \"test\"]);\n        return param ? c : Object.assign(Object.assign({}, cond), {\n          test: normalizePredicate(c, normParams)\n        });\n      });\n    } else {\n      var _d = normalizeChannelDef(enc.condition, normParams),\n        selection = _d.selection,\n        _param = _d.param,\n        test = _d.test,\n        cond = __rest(_d, [\"selection\", \"param\", \"test\"]);\n      enc.condition = _param ? enc.condition : Object.assign(Object.assign({}, cond), {\n        test: normalizePredicate(enc.condition, normParams)\n      });\n    }\n  }\n  return enc;\n}\nfunction normalizeBinExtent(bin) {\n  var ext = bin.extent;\n  if (ext === null || ext === void 0 ? void 0 : ext.selection) {\n    var param = ext.selection,\n      rest = __rest(ext, [\"selection\"]);\n    return Object.assign(Object.assign({}, bin), {\n      extent: Object.assign(Object.assign({}, rest), {\n        param: param\n      })\n    });\n  }\n  return bin;\n}\nfunction normalizePredicate(op, normParams) {\n  // Normalize old compositions of selection names (e.g., selection: {and: [\"one\", \"two\"]})\n  var normalizeSelectionComposition = function normalizeSelectionComposition(o) {\n    return normalizeLogicalComposition(o, function (param) {\n      var _a, _b;\n      var _c;\n      var empty = (_a = normParams.emptySelections[param]) !== null && _a !== void 0 ? _a : true;\n      var pred = {\n        param: param,\n        empty: empty\n      };\n      (_b = (_c = normParams.selectionPredicates)[param]) !== null && _b !== void 0 ? _b : _c[param] = [];\n      normParams.selectionPredicates[param].push(pred);\n      return pred;\n    });\n  };\n  return op.selection ? normalizeSelectionComposition(op.selection) : normalizeLogicalComposition(op.test || op.filter, function (o) {\n    return o.selection ? normalizeSelectionComposition(o.selection) : o;\n  });\n}","map":{"version":3,"sources":["../../../src/normalize/selectioncompat.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isArray } from 'vega';\nimport { isBinParams } from '../bin';\nimport { isConditionalDef, isFieldDef, isScaleFieldDef } from '../channeldef';\nimport { normalizeLogicalComposition } from '../logical';\nimport { SpecMapper } from '../spec/map';\nimport { isBin, isFilter, isLookup } from '../transform';\nimport { duplicate, entries, vals } from '../util';\nexport class SelectionCompatibilityNormalizer extends SpecMapper {\n    map(spec, normParams) {\n        var _a, _b;\n        (_a = normParams.emptySelections) !== null && _a !== void 0 ? _a : (normParams.emptySelections = {});\n        (_b = normParams.selectionPredicates) !== null && _b !== void 0 ? _b : (normParams.selectionPredicates = {});\n        spec = normalizeTransforms(spec, normParams);\n        return super.map(spec, normParams);\n    }\n    mapLayerOrUnit(spec, normParams) {\n        spec = normalizeTransforms(spec, normParams);\n        if (spec.encoding) {\n            const encoding = {};\n            for (const [channel, enc] of entries(spec.encoding)) {\n                encoding[channel] = normalizeChannelDef(enc, normParams);\n            }\n            spec = Object.assign(Object.assign({}, spec), { encoding });\n        }\n        return super.mapLayerOrUnit(spec, normParams);\n    }\n    mapUnit(spec, normParams) {\n        const _a = spec, { selection } = _a, rest = __rest(_a, [\"selection\"]);\n        if (selection) {\n            return Object.assign(Object.assign({}, rest), { params: entries(selection).map(([name, selDef]) => {\n                    var _a;\n                    const _b = selDef, { init: value, bind, empty } = _b, select = __rest(_b, [\"init\", \"bind\", \"empty\"]);\n                    if (select.type === 'single') {\n                        select.type = 'point';\n                        select.toggle = false;\n                    }\n                    else if (select.type === 'multi') {\n                        select.type = 'point';\n                    }\n                    // Propagate emptiness forwards and backwards\n                    normParams.emptySelections[name] = empty !== 'none';\n                    for (const pred of vals((_a = normParams.selectionPredicates[name]) !== null && _a !== void 0 ? _a : {})) {\n                        pred.empty = empty !== 'none';\n                    }\n                    return { name, value, select, bind };\n                }) });\n        }\n        return spec;\n    }\n}\nfunction normalizeTransforms(spec, normParams) {\n    const { transform: tx } = spec, rest = __rest(spec, [\"transform\"]);\n    if (tx) {\n        const transform = tx.map((t) => {\n            if (isFilter(t)) {\n                return { filter: normalizePredicate(t, normParams) };\n            }\n            else if (isBin(t) && isBinParams(t.bin)) {\n                return Object.assign(Object.assign({}, t), { bin: normalizeBinExtent(t.bin) });\n            }\n            else if (isLookup(t)) {\n                const _a = t.from, { selection: param } = _a, from = __rest(_a, [\"selection\"]);\n                return param\n                    ? Object.assign(Object.assign({}, t), { from: Object.assign({ param }, from) }) : t;\n            }\n            return t;\n        });\n        return Object.assign(Object.assign({}, rest), { transform });\n    }\n    return spec;\n}\nfunction normalizeChannelDef(obj, normParams) {\n    var _a, _b;\n    const enc = duplicate(obj);\n    if (isFieldDef(enc) && isBinParams(enc.bin)) {\n        enc.bin = normalizeBinExtent(enc.bin);\n    }\n    if (isScaleFieldDef(enc) && ((_b = (_a = enc.scale) === null || _a === void 0 ? void 0 : _a.domain) === null || _b === void 0 ? void 0 : _b.selection)) {\n        const _c = enc.scale.domain, { selection: param } = _c, domain = __rest(_c, [\"selection\"]);\n        enc.scale.domain = Object.assign(Object.assign({}, domain), (param ? { param } : {}));\n    }\n    if (isConditionalDef(enc)) {\n        if (isArray(enc.condition)) {\n            enc.condition = enc.condition.map((c) => {\n                const { selection, param, test } = c, cond = __rest(c, [\"selection\", \"param\", \"test\"]);\n                return param ? c : Object.assign(Object.assign({}, cond), { test: normalizePredicate(c, normParams) });\n            });\n        }\n        else {\n            const _d = normalizeChannelDef(enc.condition, normParams), { selection, param, test } = _d, cond = __rest(_d, [\"selection\", \"param\", \"test\"]);\n            enc.condition = param\n                ? enc.condition\n                : Object.assign(Object.assign({}, cond), { test: normalizePredicate(enc.condition, normParams) });\n        }\n    }\n    return enc;\n}\nfunction normalizeBinExtent(bin) {\n    const ext = bin.extent;\n    if (ext === null || ext === void 0 ? void 0 : ext.selection) {\n        const { selection: param } = ext, rest = __rest(ext, [\"selection\"]);\n        return Object.assign(Object.assign({}, bin), { extent: Object.assign(Object.assign({}, rest), { param }) });\n    }\n    return bin;\n}\nfunction normalizePredicate(op, normParams) {\n    // Normalize old compositions of selection names (e.g., selection: {and: [\"one\", \"two\"]})\n    const normalizeSelectionComposition = (o) => {\n        return normalizeLogicalComposition(o, param => {\n            var _a, _b;\n            var _c;\n            const empty = (_a = normParams.emptySelections[param]) !== null && _a !== void 0 ? _a : true;\n            const pred = { param, empty };\n            (_b = (_c = normParams.selectionPredicates)[param]) !== null && _b !== void 0 ? _b : (_c[param] = []);\n            normParams.selectionPredicates[param].push(pred);\n            return pred;\n        });\n    };\n    return op.selection\n        ? normalizeSelectionComposition(op.selection)\n        : normalizeLogicalComposition(op.test || op.filter, o => o.selection ? normalizeSelectionComposition(o.selection) : o);\n}\n//# sourceMappingURL=selectioncompat.js.map"]},"metadata":{},"sourceType":"module"}