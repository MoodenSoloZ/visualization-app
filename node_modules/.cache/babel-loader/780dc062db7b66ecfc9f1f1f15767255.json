{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { array, isBoolean } from 'vega-util';\nimport { SUM_OPS } from './aggregate';\nimport { getSecondaryRangeChannel, NONPOSITION_CHANNELS } from './channel';\nimport { channelDefType, getFieldDef, isFieldDef, isFieldOrDatumDef, vgField } from './channeldef';\nimport { channelHasField, isAggregate } from './encoding';\nimport * as log from './log';\nimport { ARC, AREA, BAR, CIRCLE, isMarkDef, isPathMark, LINE, POINT, RULE, SQUARE, TEXT, TICK } from './mark';\nimport { ScaleType } from './scale';\nvar STACK_OFFSET_INDEX = {\n  zero: 1,\n  center: 1,\n  normalize: 1\n};\nexport function isStackOffset(s) {\n  return s in STACK_OFFSET_INDEX;\n}\nexport var STACKABLE_MARKS = new Set([ARC, BAR, AREA, RULE, POINT, CIRCLE, SQUARE, LINE, TEXT, TICK]);\nexport var STACK_BY_DEFAULT_MARKS = new Set([BAR, AREA, ARC]);\nfunction isUnbinnedQuantitative(channelDef) {\n  return isFieldDef(channelDef) && channelDefType(channelDef) === 'quantitative' && !channelDef.bin;\n}\nfunction potentialStackedChannel(encoding, x) {\n  var _a, _b;\n  var y = x === 'x' ? 'y' : 'radius';\n  var xDef = encoding[x];\n  var yDef = encoding[y];\n  if (isFieldDef(xDef) && isFieldDef(yDef)) {\n    if (isUnbinnedQuantitative(xDef) && isUnbinnedQuantitative(yDef)) {\n      if (xDef.stack) {\n        return x;\n      } else if (yDef.stack) {\n        return y;\n      }\n      var xAggregate = isFieldDef(xDef) && !!xDef.aggregate;\n      var yAggregate = isFieldDef(yDef) && !!yDef.aggregate;\n      // if there is no explicit stacking, only apply stack if there is only one aggregate for x or y\n      if (xAggregate !== yAggregate) {\n        return xAggregate ? x : y;\n      } else {\n        var xScale = (_a = xDef.scale) === null || _a === void 0 ? void 0 : _a.type;\n        var yScale = (_b = yDef.scale) === null || _b === void 0 ? void 0 : _b.type;\n        if (xScale && xScale !== 'linear') {\n          return y;\n        } else if (yScale && yScale !== 'linear') {\n          return x;\n        }\n      }\n    } else if (isUnbinnedQuantitative(xDef)) {\n      return x;\n    } else if (isUnbinnedQuantitative(yDef)) {\n      return y;\n    }\n  } else if (isUnbinnedQuantitative(xDef)) {\n    return x;\n  } else if (isUnbinnedQuantitative(yDef)) {\n    return y;\n  }\n  return undefined;\n}\nfunction getDimensionChannel(channel) {\n  switch (channel) {\n    case 'x':\n      return 'y';\n    case 'y':\n      return 'x';\n    case 'theta':\n      return 'radius';\n    case 'radius':\n      return 'theta';\n  }\n}\nexport function stack(m, encoding) {\n  var _a, _b;\n  var mark = isMarkDef(m) ? m.type : m;\n  // Should have stackable mark\n  if (!STACKABLE_MARKS.has(mark)) {\n    return null;\n  }\n  // Run potential stacked twice, one for Cartesian and another for Polar,\n  // so text marks can be stacked in any of the coordinates.\n  // Note: The logic here is not perfectly correct.  If we want to support stacked dot plots where each dot is a pie chart with label, we have to change the stack logic here to separate Cartesian stacking for polar stacking.\n  // However, since we probably never want to do that, let's just note the limitation here.\n  var fieldChannel = potentialStackedChannel(encoding, 'x') || potentialStackedChannel(encoding, 'theta');\n  if (!fieldChannel) {\n    return null;\n  }\n  var stackedFieldDef = encoding[fieldChannel];\n  var stackedField = isFieldDef(stackedFieldDef) ? vgField(stackedFieldDef, {}) : undefined;\n  var dimensionChannel = getDimensionChannel(fieldChannel);\n  var groupbyChannels = [];\n  var groupbyFields = new Set();\n  if (encoding[dimensionChannel]) {\n    var dimensionDef = encoding[dimensionChannel];\n    var dimensionField = isFieldDef(dimensionDef) ? vgField(dimensionDef, {}) : undefined;\n    if (dimensionField && dimensionField !== stackedField) {\n      // avoid grouping by the stacked field\n      groupbyChannels.push(dimensionChannel);\n      groupbyFields.add(dimensionField);\n    }\n    var dimensionOffsetChannel = dimensionChannel === 'x' ? 'xOffset' : 'yOffset';\n    var dimensionOffsetDef = encoding[dimensionOffsetChannel];\n    var dimensionOffsetField = isFieldDef(dimensionOffsetDef) ? vgField(dimensionOffsetDef, {}) : undefined;\n    if (dimensionOffsetField && dimensionOffsetField !== stackedField) {\n      // avoid grouping by the stacked field\n      groupbyChannels.push(dimensionOffsetChannel);\n      groupbyFields.add(dimensionOffsetField);\n    }\n  }\n  // If the dimension has offset, don't stack anymore\n  // Should have grouping level of detail that is different from the dimension field\n  var stackBy = NONPOSITION_CHANNELS.reduce(function (sc, channel) {\n    // Ignore tooltip in stackBy (https://github.com/vega/vega-lite/issues/4001)\n    if (channel !== 'tooltip' && channelHasField(encoding, channel)) {\n      var channelDef = encoding[channel];\n      var _iterator = _createForOfIteratorHelper(array(channelDef)),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var cDef = _step.value;\n          var fieldDef = getFieldDef(cDef);\n          if (fieldDef.aggregate) {\n            continue;\n          }\n          // Check whether the channel's field is identical to x/y's field or if the channel is a repeat\n          var f = vgField(fieldDef, {});\n          if (\n          // if fielddef is a repeat, just include it in the stack by\n          !f ||\n          // otherwise, the field must be different from the groupBy fields.\n          !groupbyFields.has(f)) {\n            sc.push({\n              channel: channel,\n              fieldDef: fieldDef\n            });\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    return sc;\n  }, []);\n  // Automatically determine offset\n  var offset;\n  if (stackedFieldDef.stack !== undefined) {\n    if (isBoolean(stackedFieldDef.stack)) {\n      offset = stackedFieldDef.stack ? 'zero' : null;\n    } else {\n      offset = stackedFieldDef.stack;\n    }\n  } else if (STACK_BY_DEFAULT_MARKS.has(mark)) {\n    offset = 'zero';\n  }\n  if (!offset || !isStackOffset(offset)) {\n    return null;\n  }\n  if (isAggregate(encoding) && stackBy.length === 0) {\n    return null;\n  }\n  // warn when stacking non-linear\n  if (((_a = stackedFieldDef === null || stackedFieldDef === void 0 ? void 0 : stackedFieldDef.scale) === null || _a === void 0 ? void 0 : _a.type) && ((_b = stackedFieldDef === null || stackedFieldDef === void 0 ? void 0 : stackedFieldDef.scale) === null || _b === void 0 ? void 0 : _b.type) !== ScaleType.LINEAR) {\n    log.warn(log.message.cannotStackNonLinearScale(stackedFieldDef.scale.type));\n    return null;\n  }\n  // Check if it is a ranged mark\n  if (isFieldOrDatumDef(encoding[getSecondaryRangeChannel(fieldChannel)])) {\n    if (stackedFieldDef.stack !== undefined) {\n      log.warn(log.message.cannotStackRangedMark(fieldChannel));\n    }\n    return null;\n  }\n  // Warn if stacking non-summative aggregate\n  if (isFieldDef(stackedFieldDef) && stackedFieldDef.aggregate && !SUM_OPS.has(stackedFieldDef.aggregate)) {\n    log.warn(log.message.stackNonSummativeAggregate(stackedFieldDef.aggregate));\n  }\n  return {\n    groupbyChannels: groupbyChannels,\n    groupbyFields: groupbyFields,\n    fieldChannel: fieldChannel,\n    impute: stackedFieldDef.impute === null ? false : isPathMark(mark),\n    stackBy: stackBy,\n    offset: offset\n  };\n}","map":{"version":3,"sources":["../../src/stack.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { array, isBoolean } from 'vega-util';\nimport { SUM_OPS } from './aggregate';\nimport { getSecondaryRangeChannel, NONPOSITION_CHANNELS } from './channel';\nimport { channelDefType, getFieldDef, isFieldDef, isFieldOrDatumDef, vgField } from './channeldef';\nimport { channelHasField, isAggregate } from './encoding';\nimport * as log from './log';\nimport { ARC, AREA, BAR, CIRCLE, isMarkDef, isPathMark, LINE, POINT, RULE, SQUARE, TEXT, TICK } from './mark';\nimport { ScaleType } from './scale';\nconst STACK_OFFSET_INDEX = {\n    zero: 1,\n    center: 1,\n    normalize: 1\n};\nexport function isStackOffset(s) {\n    return s in STACK_OFFSET_INDEX;\n}\nexport const STACKABLE_MARKS = new Set([ARC, BAR, AREA, RULE, POINT, CIRCLE, SQUARE, LINE, TEXT, TICK]);\nexport const STACK_BY_DEFAULT_MARKS = new Set([BAR, AREA, ARC]);\nfunction isUnbinnedQuantitative(channelDef) {\n    return isFieldDef(channelDef) && channelDefType(channelDef) === 'quantitative' && !channelDef.bin;\n}\nfunction potentialStackedChannel(encoding, x) {\n    var _a, _b;\n    const y = x === 'x' ? 'y' : 'radius';\n    const xDef = encoding[x];\n    const yDef = encoding[y];\n    if (isFieldDef(xDef) && isFieldDef(yDef)) {\n        if (isUnbinnedQuantitative(xDef) && isUnbinnedQuantitative(yDef)) {\n            if (xDef.stack) {\n                return x;\n            }\n            else if (yDef.stack) {\n                return y;\n            }\n            const xAggregate = isFieldDef(xDef) && !!xDef.aggregate;\n            const yAggregate = isFieldDef(yDef) && !!yDef.aggregate;\n            // if there is no explicit stacking, only apply stack if there is only one aggregate for x or y\n            if (xAggregate !== yAggregate) {\n                return xAggregate ? x : y;\n            }\n            else {\n                const xScale = (_a = xDef.scale) === null || _a === void 0 ? void 0 : _a.type;\n                const yScale = (_b = yDef.scale) === null || _b === void 0 ? void 0 : _b.type;\n                if (xScale && xScale !== 'linear') {\n                    return y;\n                }\n                else if (yScale && yScale !== 'linear') {\n                    return x;\n                }\n            }\n        }\n        else if (isUnbinnedQuantitative(xDef)) {\n            return x;\n        }\n        else if (isUnbinnedQuantitative(yDef)) {\n            return y;\n        }\n    }\n    else if (isUnbinnedQuantitative(xDef)) {\n        return x;\n    }\n    else if (isUnbinnedQuantitative(yDef)) {\n        return y;\n    }\n    return undefined;\n}\nfunction getDimensionChannel(channel) {\n    switch (channel) {\n        case 'x':\n            return 'y';\n        case 'y':\n            return 'x';\n        case 'theta':\n            return 'radius';\n        case 'radius':\n            return 'theta';\n    }\n}\nexport function stack(m, encoding) {\n    var _a, _b;\n    const mark = isMarkDef(m) ? m.type : m;\n    // Should have stackable mark\n    if (!STACKABLE_MARKS.has(mark)) {\n        return null;\n    }\n    // Run potential stacked twice, one for Cartesian and another for Polar,\n    // so text marks can be stacked in any of the coordinates.\n    // Note: The logic here is not perfectly correct.  If we want to support stacked dot plots where each dot is a pie chart with label, we have to change the stack logic here to separate Cartesian stacking for polar stacking.\n    // However, since we probably never want to do that, let's just note the limitation here.\n    const fieldChannel = potentialStackedChannel(encoding, 'x') || potentialStackedChannel(encoding, 'theta');\n    if (!fieldChannel) {\n        return null;\n    }\n    const stackedFieldDef = encoding[fieldChannel];\n    const stackedField = isFieldDef(stackedFieldDef) ? vgField(stackedFieldDef, {}) : undefined;\n    const dimensionChannel = getDimensionChannel(fieldChannel);\n    const groupbyChannels = [];\n    const groupbyFields = new Set();\n    if (encoding[dimensionChannel]) {\n        const dimensionDef = encoding[dimensionChannel];\n        const dimensionField = isFieldDef(dimensionDef) ? vgField(dimensionDef, {}) : undefined;\n        if (dimensionField && dimensionField !== stackedField) {\n            // avoid grouping by the stacked field\n            groupbyChannels.push(dimensionChannel);\n            groupbyFields.add(dimensionField);\n        }\n        const dimensionOffsetChannel = dimensionChannel === 'x' ? 'xOffset' : 'yOffset';\n        const dimensionOffsetDef = encoding[dimensionOffsetChannel];\n        const dimensionOffsetField = isFieldDef(dimensionOffsetDef) ? vgField(dimensionOffsetDef, {}) : undefined;\n        if (dimensionOffsetField && dimensionOffsetField !== stackedField) {\n            // avoid grouping by the stacked field\n            groupbyChannels.push(dimensionOffsetChannel);\n            groupbyFields.add(dimensionOffsetField);\n        }\n    }\n    // If the dimension has offset, don't stack anymore\n    // Should have grouping level of detail that is different from the dimension field\n    const stackBy = NONPOSITION_CHANNELS.reduce((sc, channel) => {\n        // Ignore tooltip in stackBy (https://github.com/vega/vega-lite/issues/4001)\n        if (channel !== 'tooltip' && channelHasField(encoding, channel)) {\n            const channelDef = encoding[channel];\n            for (const cDef of array(channelDef)) {\n                const fieldDef = getFieldDef(cDef);\n                if (fieldDef.aggregate) {\n                    continue;\n                }\n                // Check whether the channel's field is identical to x/y's field or if the channel is a repeat\n                const f = vgField(fieldDef, {});\n                if (\n                // if fielddef is a repeat, just include it in the stack by\n                !f ||\n                    // otherwise, the field must be different from the groupBy fields.\n                    !groupbyFields.has(f)) {\n                    sc.push({ channel, fieldDef });\n                }\n            }\n        }\n        return sc;\n    }, []);\n    // Automatically determine offset\n    let offset;\n    if (stackedFieldDef.stack !== undefined) {\n        if (isBoolean(stackedFieldDef.stack)) {\n            offset = stackedFieldDef.stack ? 'zero' : null;\n        }\n        else {\n            offset = stackedFieldDef.stack;\n        }\n    }\n    else if (STACK_BY_DEFAULT_MARKS.has(mark)) {\n        offset = 'zero';\n    }\n    if (!offset || !isStackOffset(offset)) {\n        return null;\n    }\n    if (isAggregate(encoding) && stackBy.length === 0) {\n        return null;\n    }\n    // warn when stacking non-linear\n    if (((_a = stackedFieldDef === null || stackedFieldDef === void 0 ? void 0 : stackedFieldDef.scale) === null || _a === void 0 ? void 0 : _a.type) && ((_b = stackedFieldDef === null || stackedFieldDef === void 0 ? void 0 : stackedFieldDef.scale) === null || _b === void 0 ? void 0 : _b.type) !== ScaleType.LINEAR) {\n        log.warn(log.message.cannotStackNonLinearScale(stackedFieldDef.scale.type));\n        return null;\n    }\n    // Check if it is a ranged mark\n    if (isFieldOrDatumDef(encoding[getSecondaryRangeChannel(fieldChannel)])) {\n        if (stackedFieldDef.stack !== undefined) {\n            log.warn(log.message.cannotStackRangedMark(fieldChannel));\n        }\n        return null;\n    }\n    // Warn if stacking non-summative aggregate\n    if (isFieldDef(stackedFieldDef) &&\n        stackedFieldDef.aggregate &&\n        !SUM_OPS.has(stackedFieldDef.aggregate)) {\n        log.warn(log.message.stackNonSummativeAggregate(stackedFieldDef.aggregate));\n    }\n    return {\n        groupbyChannels,\n        groupbyFields,\n        fieldChannel,\n        impute: stackedFieldDef.impute === null ? false : isPathMark(mark),\n        stackBy,\n        offset\n    };\n}\n//# sourceMappingURL=stack.js.map"]},"metadata":{},"sourceType":"module"}