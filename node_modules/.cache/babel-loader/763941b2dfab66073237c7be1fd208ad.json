{"ast":null,"code":"import { regressionLoess, sampleCurve, regressionLinear, regressionLog, regressionExp, regressionPow, regressionQuad, regressionPoly } from 'vega-statistics';\nimport { Transform, ingest } from 'vega-dataflow';\nimport { inherits, accessorName, hasOwnProperty, error, extent } from 'vega-util';\nfunction partition(data, groupby) {\n  var groups = [],\n    get = function get(f) {\n      return f(t);\n    },\n    map,\n    i,\n    n,\n    t,\n    k,\n    g; // partition data points into stack groups\n\n  if (groupby == null) {\n    groups.push(data);\n  } else {\n    for (map = {}, i = 0, n = data.length; i < n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n      if (!g) {\n        map[k] = g = [];\n        g.dims = k;\n        groups.push(g);\n      }\n      g.push(t);\n    }\n  }\n  return groups;\n}\n\n/**\n * Compute locally-weighted regression fits for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.x - An accessor for the predictor data field.\n * @param {function(object): *} params.y - An accessor for the predicted data field.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {number} [params.bandwidth=0.3] - The loess bandwidth.\n */\n\nfunction Loess(params) {\n  Transform.call(this, null, params);\n}\nLoess.Definition = {\n  'type': 'Loess',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'x',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'y',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'bandwidth',\n    'type': 'number',\n    'default': 0.3\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true\n  }]\n};\ninherits(Loess, Transform, {\n  transform: function transform(_, pulse) {\n    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n    if (!this.value || pulse.changed() || _.modified()) {\n      var source = pulse.materialize(pulse.SOURCE).source,\n        groups = partition(source, _.groupby),\n        names = (_.groupby || []).map(accessorName),\n        m = names.length,\n        as = _.as || [accessorName(_.x), accessorName(_.y)],\n        values = [];\n      groups.forEach(function (g) {\n        regressionLoess(g, _.x, _.y, _.bandwidth || 0.3).forEach(function (p) {\n          var t = {};\n          for (var i = 0; i < m; ++i) {\n            t[names[i]] = g.dims[i];\n          }\n          t[as[0]] = p[0];\n          t[as[1]] = p[1];\n          values.push(ingest(t));\n        });\n      });\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n    return out;\n  }\n});\nvar Methods = {\n  linear: regressionLinear,\n  log: regressionLog,\n  exp: regressionExp,\n  pow: regressionPow,\n  quad: regressionQuad,\n  poly: regressionPoly\n};\nvar degreesOfFreedom = function degreesOfFreedom(method, order) {\n  return method === 'poly' ? order : method === 'quad' ? 2 : 1;\n};\n/**\n * Compute regression fits for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.x - An accessor for the predictor data field.\n * @param {function(object): *} params.y - An accessor for the predicted data field.\n * @param {string} [params.method='linear'] - The regression method to apply.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {Array<number>} [params.extent] - The domain extent over which to plot the regression line.\n * @param {number} [params.order=3] - The polynomial order. Only applies to the 'poly' method.\n */\n\nfunction Regression(params) {\n  Transform.call(this, null, params);\n}\nRegression.Definition = {\n  'type': 'Regression',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'x',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'y',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'method',\n    'type': 'string',\n    'default': 'linear',\n    'values': Object.keys(Methods)\n  }, {\n    'name': 'order',\n    'type': 'number',\n    'default': 3\n  }, {\n    'name': 'extent',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'params',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true\n  }]\n};\ninherits(Regression, Transform, {\n  transform: function transform(_, pulse) {\n    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n    if (!this.value || pulse.changed() || _.modified()) {\n      var source = pulse.materialize(pulse.SOURCE).source,\n        groups = partition(source, _.groupby),\n        names = (_.groupby || []).map(accessorName),\n        method = _.method || 'linear',\n        order = _.order || 3,\n        dof = degreesOfFreedom(method, order),\n        as = _.as || [accessorName(_.x), accessorName(_.y)],\n        fit = Methods[method],\n        values = [];\n      var domain = _.extent;\n      if (!hasOwnProperty(Methods, method)) {\n        error('Invalid regression method: ' + method);\n      }\n      if (domain != null) {\n        if (method === 'log' && domain[0] <= 0) {\n          pulse.dataflow.warn('Ignoring extent with values <= 0 for log regression.');\n          domain = null;\n        }\n      }\n      groups.forEach(function (g) {\n        var n = g.length;\n        if (n <= dof) {\n          pulse.dataflow.warn('Skipping regression with more parameters than data points.');\n          return;\n        }\n        var model = fit(g, _.x, _.y, order);\n        if (_.params) {\n          // if parameter vectors requested return those\n          values.push(ingest({\n            keys: g.dims,\n            coef: model.coef,\n            rSquared: model.rSquared\n          }));\n          return;\n        }\n        var dom = domain || extent(g, _.x),\n          add = function add(p) {\n            var t = {};\n            for (var i = 0; i < names.length; ++i) {\n              t[names[i]] = g.dims[i];\n            }\n            t[as[0]] = p[0];\n            t[as[1]] = p[1];\n            values.push(ingest(t));\n          };\n        if (method === 'linear') {\n          // for linear regression we only need the end points\n          dom.forEach(function (x) {\n            return add([x, model.predict(x)]);\n          });\n        } else {\n          // otherwise return trend line sample points\n          sampleCurve(model.predict, dom, 25, 200).forEach(add);\n        }\n      });\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n    return out;\n  }\n});\nexport { Loess as loess, Regression as regression };","map":{"version":3,"names":["regressionLoess","sampleCurve","regressionLinear","regressionLog","regressionExp","regressionPow","regressionQuad","regressionPoly","Transform","ingest","inherits","accessorName","hasOwnProperty","error","extent","partition","data","groupby","groups","get","f","t","map","i","n","k","g","push","length","dims","Loess","params","call","Definition","transform","_","pulse","out","fork","NO_SOURCE","NO_FIELDS","value","changed","modified","source","materialize","SOURCE","names","m","as","x","y","values","forEach","bandwidth","p","rem","add","Methods","linear","log","exp","pow","quad","poly","degreesOfFreedom","method","order","Regression","Object","keys","dof","fit","domain","dataflow","warn","model","coef","rSquared","dom","predict","loess","regression"],"sources":["/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/vega-regression/build/vega-regression.module.js"],"sourcesContent":["import { regressionLoess, sampleCurve, regressionLinear, regressionLog, regressionExp, regressionPow, regressionQuad, regressionPoly } from 'vega-statistics';\nimport { Transform, ingest } from 'vega-dataflow';\nimport { inherits, accessorName, hasOwnProperty, error, extent } from 'vega-util';\n\nfunction partition (data, groupby) {\n  var groups = [],\n      get = function (f) {\n    return f(t);\n  },\n      map,\n      i,\n      n,\n      t,\n      k,\n      g; // partition data points into stack groups\n\n\n  if (groupby == null) {\n    groups.push(data);\n  } else {\n    for (map = {}, i = 0, n = data.length; i < n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n\n      if (!g) {\n        map[k] = g = [];\n        g.dims = k;\n        groups.push(g);\n      }\n\n      g.push(t);\n    }\n  }\n\n  return groups;\n}\n\n/**\n * Compute locally-weighted regression fits for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.x - An accessor for the predictor data field.\n * @param {function(object): *} params.y - An accessor for the predicted data field.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {number} [params.bandwidth=0.3] - The loess bandwidth.\n */\n\nfunction Loess(params) {\n  Transform.call(this, null, params);\n}\nLoess.Definition = {\n  'type': 'Loess',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'x',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'y',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'bandwidth',\n    'type': 'number',\n    'default': 0.3\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true\n  }]\n};\ninherits(Loess, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n    if (!this.value || pulse.changed() || _.modified()) {\n      const source = pulse.materialize(pulse.SOURCE).source,\n            groups = partition(source, _.groupby),\n            names = (_.groupby || []).map(accessorName),\n            m = names.length,\n            as = _.as || [accessorName(_.x), accessorName(_.y)],\n            values = [];\n      groups.forEach(g => {\n        regressionLoess(g, _.x, _.y, _.bandwidth || 0.3).forEach(p => {\n          const t = {};\n\n          for (let i = 0; i < m; ++i) {\n            t[names[i]] = g.dims[i];\n          }\n\n          t[as[0]] = p[0];\n          t[as[1]] = p[1];\n          values.push(ingest(t));\n        });\n      });\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n\n    return out;\n  }\n\n});\n\nconst Methods = {\n  linear: regressionLinear,\n  log: regressionLog,\n  exp: regressionExp,\n  pow: regressionPow,\n  quad: regressionQuad,\n  poly: regressionPoly\n};\n\nconst degreesOfFreedom = (method, order) => method === 'poly' ? order : method === 'quad' ? 2 : 1;\n/**\n * Compute regression fits for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.x - An accessor for the predictor data field.\n * @param {function(object): *} params.y - An accessor for the predicted data field.\n * @param {string} [params.method='linear'] - The regression method to apply.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {Array<number>} [params.extent] - The domain extent over which to plot the regression line.\n * @param {number} [params.order=3] - The polynomial order. Only applies to the 'poly' method.\n */\n\n\nfunction Regression(params) {\n  Transform.call(this, null, params);\n}\nRegression.Definition = {\n  'type': 'Regression',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'x',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'y',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'method',\n    'type': 'string',\n    'default': 'linear',\n    'values': Object.keys(Methods)\n  }, {\n    'name': 'order',\n    'type': 'number',\n    'default': 3\n  }, {\n    'name': 'extent',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'params',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true\n  }]\n};\ninherits(Regression, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n    if (!this.value || pulse.changed() || _.modified()) {\n      const source = pulse.materialize(pulse.SOURCE).source,\n            groups = partition(source, _.groupby),\n            names = (_.groupby || []).map(accessorName),\n            method = _.method || 'linear',\n            order = _.order || 3,\n            dof = degreesOfFreedom(method, order),\n            as = _.as || [accessorName(_.x), accessorName(_.y)],\n            fit = Methods[method],\n            values = [];\n      let domain = _.extent;\n\n      if (!hasOwnProperty(Methods, method)) {\n        error('Invalid regression method: ' + method);\n      }\n\n      if (domain != null) {\n        if (method === 'log' && domain[0] <= 0) {\n          pulse.dataflow.warn('Ignoring extent with values <= 0 for log regression.');\n          domain = null;\n        }\n      }\n\n      groups.forEach(g => {\n        const n = g.length;\n\n        if (n <= dof) {\n          pulse.dataflow.warn('Skipping regression with more parameters than data points.');\n          return;\n        }\n\n        const model = fit(g, _.x, _.y, order);\n\n        if (_.params) {\n          // if parameter vectors requested return those\n          values.push(ingest({\n            keys: g.dims,\n            coef: model.coef,\n            rSquared: model.rSquared\n          }));\n          return;\n        }\n\n        const dom = domain || extent(g, _.x),\n              add = p => {\n          const t = {};\n\n          for (let i = 0; i < names.length; ++i) {\n            t[names[i]] = g.dims[i];\n          }\n\n          t[as[0]] = p[0];\n          t[as[1]] = p[1];\n          values.push(ingest(t));\n        };\n\n        if (method === 'linear') {\n          // for linear regression we only need the end points\n          dom.forEach(x => add([x, model.predict(x)]));\n        } else {\n          // otherwise return trend line sample points\n          sampleCurve(model.predict, dom, 25, 200).forEach(add);\n        }\n      });\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n\n    return out;\n  }\n\n});\n\nexport { Loess as loess, Regression as regression };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}