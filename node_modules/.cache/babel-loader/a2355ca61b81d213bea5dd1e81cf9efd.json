{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { isAggregateOp } from '../../aggregate';\nimport { vgField } from '../../channeldef';\nimport { duplicate, hash as _hash } from '../../util';\nimport { unique } from '../../util';\nimport { DataFlowNode } from './dataflow';\n/**\n * A class for the window transform nodes\n */\nexport var WindowTransformNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(WindowTransformNode, _DataFlowNode);\n  var _super = _createSuper(WindowTransformNode);\n  function WindowTransformNode(parent, transform) {\n    var _this;\n    _classCallCheck(this, WindowTransformNode);\n    _this = _super.call(this, parent);\n    _this.transform = transform;\n    return _this;\n  }\n  _createClass(WindowTransformNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new WindowTransformNode(null, duplicate(this.transform));\n    }\n  }, {\n    key: \"addDimensions\",\n    value: function addDimensions(fields) {\n      this.transform.groupby = unique(this.transform.groupby.concat(fields), function (d) {\n        return d;\n      });\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      var _a, _b;\n      var out = new Set();\n      ((_a = this.transform.groupby) !== null && _a !== void 0 ? _a : []).forEach(out.add, out);\n      ((_b = this.transform.sort) !== null && _b !== void 0 ? _b : []).forEach(function (m) {\n        return out.add(m.field);\n      });\n      this.transform.window.map(function (w) {\n        return w.field;\n      }).filter(function (f) {\n        return f !== undefined;\n      }).forEach(out.add, out);\n      return out;\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set(this.transform.window.map(this.getDefaultName));\n    }\n  }, {\n    key: \"getDefaultName\",\n    value: function getDefaultName(windowFieldDef) {\n      var _a;\n      return (_a = windowFieldDef.as) !== null && _a !== void 0 ? _a : vgField(windowFieldDef);\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"WindowTransform \".concat(_hash(this.transform));\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      var _a;\n      var fields = [];\n      var ops = [];\n      var as = [];\n      var params = [];\n      var _iterator = _createForOfIteratorHelper(this.transform.window),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var window = _step.value;\n          ops.push(window.op);\n          as.push(this.getDefaultName(window));\n          params.push(window.param === undefined ? null : window.param);\n          fields.push(window.field === undefined ? null : window.field);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var frame = this.transform.frame;\n      var groupby = this.transform.groupby;\n      if (frame && frame[0] === null && frame[1] === null && ops.every(function (o) {\n        return isAggregateOp(o);\n      })) {\n        // when the window does not rely on any particular window ops or frame, switch to a simpler and more efficient joinaggregate\n        return Object.assign({\n          type: 'joinaggregate',\n          as: as,\n          ops: ops,\n          fields: fields\n        }, groupby !== undefined ? {\n          groupby: groupby\n        } : {});\n      }\n      var sortFields = [];\n      var sortOrder = [];\n      if (this.transform.sort !== undefined) {\n        var _iterator2 = _createForOfIteratorHelper(this.transform.sort),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var sortField = _step2.value;\n            sortFields.push(sortField.field);\n            sortOrder.push((_a = sortField.order) !== null && _a !== void 0 ? _a : 'ascending');\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      var sort = {\n        field: sortFields,\n        order: sortOrder\n      };\n      var ignorePeers = this.transform.ignorePeers;\n      return Object.assign(Object.assign(Object.assign({\n        type: 'window',\n        params: params,\n        as: as,\n        ops: ops,\n        fields: fields,\n        sort: sort\n      }, ignorePeers !== undefined ? {\n        ignorePeers: ignorePeers\n      } : {}), groupby !== undefined ? {\n        groupby: groupby\n      } : {}), frame !== undefined ? {\n        frame: frame\n      } : {});\n    }\n  }]);\n  return WindowTransformNode;\n}(DataFlowNode);","map":{"version":3,"sources":["../../../../src/compile/data/window.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isAggregateOp } from '../../aggregate';\nimport { vgField } from '../../channeldef';\nimport { duplicate, hash } from '../../util';\nimport { unique } from '../../util';\nimport { DataFlowNode } from './dataflow';\n/**\n * A class for the window transform nodes\n */\nexport class WindowTransformNode extends DataFlowNode {\n    constructor(parent, transform) {\n        super(parent);\n        this.transform = transform;\n    }\n    clone() {\n        return new WindowTransformNode(null, duplicate(this.transform));\n    }\n    addDimensions(fields) {\n        this.transform.groupby = unique(this.transform.groupby.concat(fields), d => d);\n    }\n    dependentFields() {\n        var _a, _b;\n        const out = new Set();\n        ((_a = this.transform.groupby) !== null && _a !== void 0 ? _a : []).forEach(out.add, out);\n        ((_b = this.transform.sort) !== null && _b !== void 0 ? _b : []).forEach(m => out.add(m.field));\n        this.transform.window\n            .map(w => w.field)\n            .filter(f => f !== undefined)\n            .forEach(out.add, out);\n        return out;\n    }\n    producedFields() {\n        return new Set(this.transform.window.map(this.getDefaultName));\n    }\n    getDefaultName(windowFieldDef) {\n        var _a;\n        return (_a = windowFieldDef.as) !== null && _a !== void 0 ? _a : vgField(windowFieldDef);\n    }\n    hash() {\n        return `WindowTransform ${hash(this.transform)}`;\n    }\n    assemble() {\n        var _a;\n        const fields = [];\n        const ops = [];\n        const as = [];\n        const params = [];\n        for (const window of this.transform.window) {\n            ops.push(window.op);\n            as.push(this.getDefaultName(window));\n            params.push(window.param === undefined ? null : window.param);\n            fields.push(window.field === undefined ? null : window.field);\n        }\n        const frame = this.transform.frame;\n        const groupby = this.transform.groupby;\n        if (frame && frame[0] === null && frame[1] === null && ops.every(o => isAggregateOp(o))) {\n            // when the window does not rely on any particular window ops or frame, switch to a simpler and more efficient joinaggregate\n            return Object.assign({ type: 'joinaggregate', as, ops: ops, fields }, (groupby !== undefined ? { groupby } : {}));\n        }\n        const sortFields = [];\n        const sortOrder = [];\n        if (this.transform.sort !== undefined) {\n            for (const sortField of this.transform.sort) {\n                sortFields.push(sortField.field);\n                sortOrder.push((_a = sortField.order) !== null && _a !== void 0 ? _a : 'ascending');\n            }\n        }\n        const sort = {\n            field: sortFields,\n            order: sortOrder\n        };\n        const ignorePeers = this.transform.ignorePeers;\n        return Object.assign(Object.assign(Object.assign({ type: 'window', params,\n            as,\n            ops,\n            fields,\n            sort }, (ignorePeers !== undefined ? { ignorePeers } : {})), (groupby !== undefined ? { groupby } : {})), (frame !== undefined ? { frame } : {}));\n    }\n}\n//# sourceMappingURL=window.js.map"]},"metadata":{},"sourceType":"module"}