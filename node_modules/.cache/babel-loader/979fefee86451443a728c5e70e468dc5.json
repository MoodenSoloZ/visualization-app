{"ast":null,"code":"import _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { isObject } from 'vega';\nimport { isString } from 'vega-util';\nimport * as CHANNEL from './channel';\nimport { isColorChannel } from './channel';\nimport * as log from './log';\nimport { NOMINAL, ORDINAL, QUANTITATIVE, TEMPORAL } from './type';\nimport { contains, keys } from './util';\nexport var ScaleType = {\n  // Continuous - Quantitative\n  LINEAR: 'linear',\n  LOG: 'log',\n  POW: 'pow',\n  SQRT: 'sqrt',\n  SYMLOG: 'symlog',\n  IDENTITY: 'identity',\n  SEQUENTIAL: 'sequential',\n  // Continuous - Time\n  TIME: 'time',\n  UTC: 'utc',\n  // Discretizing scales\n  QUANTILE: 'quantile',\n  QUANTIZE: 'quantize',\n  THRESHOLD: 'threshold',\n  BIN_ORDINAL: 'bin-ordinal',\n  // Discrete scales\n  ORDINAL: 'ordinal',\n  POINT: 'point',\n  BAND: 'band'\n};\n/**\n * Index for scale categories -- only scale of the same categories can be merged together.\n * Current implementation is trying to be conservative and avoid merging scale type that might not work together\n */\nexport var SCALE_CATEGORY_INDEX = {\n  linear: 'numeric',\n  log: 'numeric',\n  pow: 'numeric',\n  sqrt: 'numeric',\n  symlog: 'numeric',\n  identity: 'numeric',\n  sequential: 'numeric',\n  time: 'time',\n  utc: 'time',\n  ordinal: 'ordinal',\n  'bin-ordinal': 'bin-ordinal',\n  point: 'ordinal-position',\n  band: 'ordinal-position',\n  quantile: 'discretizing',\n  quantize: 'discretizing',\n  threshold: 'discretizing'\n};\nexport var SCALE_TYPES = keys(SCALE_CATEGORY_INDEX);\n/**\n * Whether the two given scale types can be merged together.\n */\nexport function scaleCompatible(scaleType1, scaleType2) {\n  var scaleCategory1 = SCALE_CATEGORY_INDEX[scaleType1];\n  var scaleCategory2 = SCALE_CATEGORY_INDEX[scaleType2];\n  return scaleCategory1 === scaleCategory2 || scaleCategory1 === 'ordinal-position' && scaleCategory2 === 'time' || scaleCategory2 === 'ordinal-position' && scaleCategory1 === 'time';\n}\n/**\n * Index for scale precedence -- high score = higher priority for merging.\n */\nvar SCALE_PRECEDENCE_INDEX = {\n  // numeric\n  linear: 0,\n  log: 1,\n  pow: 1,\n  sqrt: 1,\n  symlog: 1,\n  identity: 1,\n  sequential: 1,\n  // time\n  time: 0,\n  utc: 0,\n  // ordinal-position -- these have higher precedence than continuous scales as they support more types of data\n  point: 10,\n  band: 11,\n  // non grouped types\n  ordinal: 0,\n  'bin-ordinal': 0,\n  quantile: 0,\n  quantize: 0,\n  threshold: 0\n};\n/**\n * Return scale categories -- only scale of the same categories can be merged together.\n */\nexport function scaleTypePrecedence(scaleType) {\n  return SCALE_PRECEDENCE_INDEX[scaleType];\n}\nexport var QUANTITATIVE_SCALES = new Set(['linear', 'log', 'pow', 'sqrt', 'symlog']);\nexport var CONTINUOUS_TO_CONTINUOUS_SCALES = new Set([].concat(_toConsumableArray(QUANTITATIVE_SCALES), ['time', 'utc']));\nexport function isQuantitative(type) {\n  return QUANTITATIVE_SCALES.has(type);\n}\nexport var CONTINUOUS_TO_DISCRETE_SCALES = new Set(['quantile', 'quantize', 'threshold']);\nexport var CONTINUOUS_DOMAIN_SCALES = new Set([].concat(_toConsumableArray(CONTINUOUS_TO_CONTINUOUS_SCALES), _toConsumableArray(CONTINUOUS_TO_DISCRETE_SCALES), ['sequential', 'identity']));\nexport var DISCRETE_DOMAIN_SCALES = new Set(['ordinal', 'bin-ordinal', 'point', 'band']);\nexport var TIME_SCALE_TYPES = new Set(['time', 'utc']);\nexport function hasDiscreteDomain(type) {\n  return DISCRETE_DOMAIN_SCALES.has(type);\n}\nexport function hasContinuousDomain(type) {\n  return CONTINUOUS_DOMAIN_SCALES.has(type);\n}\nexport function isContinuousToContinuous(type) {\n  return CONTINUOUS_TO_CONTINUOUS_SCALES.has(type);\n}\nexport function isContinuousToDiscrete(type) {\n  return CONTINUOUS_TO_DISCRETE_SCALES.has(type);\n}\nexport var defaultScaleConfig = {\n  pointPadding: 0.5,\n  barBandPaddingInner: 0.1,\n  rectBandPaddingInner: 0,\n  bandWithNestedOffsetPaddingInner: 0.2,\n  bandWithNestedOffsetPaddingOuter: 0.2,\n  minBandSize: 2,\n  minFontSize: 8,\n  maxFontSize: 40,\n  minOpacity: 0.3,\n  maxOpacity: 0.8,\n  // FIXME: revise if these *can* become ratios of width/height step\n  minSize: 9,\n  minStrokeWidth: 1,\n  maxStrokeWidth: 4,\n  quantileCount: 4,\n  quantizeCount: 4,\n  zero: true\n};\nexport function isExtendedScheme(scheme) {\n  return !isString(scheme) && !!scheme['name'];\n}\nexport function isParameterDomain(domain) {\n  return domain === null || domain === void 0 ? void 0 : domain['param'];\n}\nexport function isDomainUnionWith(domain) {\n  return domain === null || domain === void 0 ? void 0 : domain['unionWith'];\n}\nexport function isFieldRange(range) {\n  return isObject(range) && 'field' in range;\n}\nvar SCALE_PROPERTY_INDEX = {\n  type: 1,\n  domain: 1,\n  domainMax: 1,\n  domainMin: 1,\n  domainMid: 1,\n  align: 1,\n  range: 1,\n  rangeMax: 1,\n  rangeMin: 1,\n  scheme: 1,\n  bins: 1,\n  // Other properties\n  reverse: 1,\n  round: 1,\n  // quantitative / time\n  clamp: 1,\n  nice: 1,\n  // quantitative\n  base: 1,\n  exponent: 1,\n  constant: 1,\n  interpolate: 1,\n  zero: 1,\n  // band/point\n  padding: 1,\n  paddingInner: 1,\n  paddingOuter: 1\n};\nexport var SCALE_PROPERTIES = keys(SCALE_PROPERTY_INDEX);\nvar type = SCALE_PROPERTY_INDEX.type,\n  domain = SCALE_PROPERTY_INDEX.domain,\n  range = SCALE_PROPERTY_INDEX.range,\n  rangeMax = SCALE_PROPERTY_INDEX.rangeMax,\n  rangeMin = SCALE_PROPERTY_INDEX.rangeMin,\n  scheme = SCALE_PROPERTY_INDEX.scheme,\n  NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX = __rest(SCALE_PROPERTY_INDEX, [\"type\", \"domain\", \"range\", \"rangeMax\", \"rangeMin\", \"scheme\"]);\nexport var NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES = keys(NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX);\nexport function scaleTypeSupportProperty(scaleType, propName) {\n  switch (propName) {\n    case 'type':\n    case 'domain':\n    case 'reverse':\n    case 'range':\n      return true;\n    case 'scheme':\n    case 'interpolate':\n      return !['point', 'band', 'identity'].includes(scaleType);\n    case 'bins':\n      return !['point', 'band', 'identity', 'ordinal'].includes(scaleType);\n    case 'round':\n      return isContinuousToContinuous(scaleType) || scaleType === 'band' || scaleType === 'point';\n    case 'padding':\n    case 'rangeMin':\n    case 'rangeMax':\n      return isContinuousToContinuous(scaleType) || ['point', 'band'].includes(scaleType);\n    case 'paddingOuter':\n    case 'align':\n      return ['point', 'band'].includes(scaleType);\n    case 'paddingInner':\n      return scaleType === 'band';\n    case 'domainMax':\n    case 'domainMid':\n    case 'domainMin':\n    case 'clamp':\n      return isContinuousToContinuous(scaleType);\n    case 'nice':\n      return isContinuousToContinuous(scaleType) || scaleType === 'quantize' || scaleType === 'threshold';\n    case 'exponent':\n      return scaleType === 'pow';\n    case 'base':\n      return scaleType === 'log';\n    case 'constant':\n      return scaleType === 'symlog';\n    case 'zero':\n      return hasContinuousDomain(scaleType) && !contains(['log', 'time', 'utc', 'threshold', 'quantile' // quantile depends on distribution so zero does not matter\n      ], scaleType);\n  }\n}\n/**\n * Returns undefined if the input channel supports the input scale property name\n */\nexport function channelScalePropertyIncompatability(channel, propName) {\n  switch (propName) {\n    case 'interpolate':\n    case 'scheme':\n    case 'domainMid':\n      if (!isColorChannel(channel)) {\n        return log.message.cannotUseScalePropertyWithNonColor(propName);\n      }\n      return undefined;\n    case 'align':\n    case 'type':\n    case 'bins':\n    case 'domain':\n    case 'domainMax':\n    case 'domainMin':\n    case 'range':\n    case 'base':\n    case 'exponent':\n    case 'constant':\n    case 'nice':\n    case 'padding':\n    case 'paddingInner':\n    case 'paddingOuter':\n    case 'rangeMax':\n    case 'rangeMin':\n    case 'reverse':\n    case 'round':\n    case 'clamp':\n    case 'zero':\n      return undefined;\n    // GOOD!\n  }\n}\n\nexport function scaleTypeSupportDataType(specifiedType, fieldDefType) {\n  if (contains([ORDINAL, NOMINAL], fieldDefType)) {\n    return specifiedType === undefined || hasDiscreteDomain(specifiedType);\n  } else if (fieldDefType === TEMPORAL) {\n    return contains([ScaleType.TIME, ScaleType.UTC, undefined], specifiedType);\n  } else if (fieldDefType === QUANTITATIVE) {\n    return isQuantitative(specifiedType) || isContinuousToDiscrete(specifiedType) || specifiedType === undefined;\n  }\n  return true;\n}\nexport function channelSupportScaleType(channel, scaleType) {\n  var hasNestedOffsetScale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (!CHANNEL.isScaleChannel(channel)) {\n    return false;\n  }\n  switch (channel) {\n    case CHANNEL.X:\n    case CHANNEL.Y:\n    case CHANNEL.XOFFSET:\n    case CHANNEL.YOFFSET:\n    case CHANNEL.THETA:\n    case CHANNEL.RADIUS:\n      if (isContinuousToContinuous(scaleType)) {\n        return true;\n      } else if (scaleType === 'band') {\n        return true;\n      } else if (scaleType === 'point') {\n        /*\n          Point scale can't be use if the position has a nested offset scale\n          because if there is a nested scale, then it's band.\n        */\n        return !hasNestedOffsetScale;\n      }\n      return false;\n    case CHANNEL.SIZE: // TODO: size and opacity can support ordinal with more modification\n    case CHANNEL.STROKEWIDTH:\n    case CHANNEL.OPACITY:\n    case CHANNEL.FILLOPACITY:\n    case CHANNEL.STROKEOPACITY:\n    case CHANNEL.ANGLE:\n      // Although it generally doesn't make sense to use band with size and opacity,\n      // it can also work since we use band: 0.5 to get midpoint.\n      return isContinuousToContinuous(scaleType) || isContinuousToDiscrete(scaleType) || contains(['band', 'point', 'ordinal'], scaleType);\n    case CHANNEL.COLOR:\n    case CHANNEL.FILL:\n    case CHANNEL.STROKE:\n      return scaleType !== 'band';\n    // band does not make sense with color\n    case CHANNEL.STROKEDASH:\n    case CHANNEL.SHAPE:\n      return scaleType === 'ordinal' || isContinuousToDiscrete(scaleType);\n  }\n}","map":{"version":3,"sources":["../../src/scale.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isObject } from 'vega';\nimport { isString } from 'vega-util';\nimport * as CHANNEL from './channel';\nimport { isColorChannel } from './channel';\nimport * as log from './log';\nimport { NOMINAL, ORDINAL, QUANTITATIVE, TEMPORAL } from './type';\nimport { contains, keys } from './util';\nexport const ScaleType = {\n    // Continuous - Quantitative\n    LINEAR: 'linear',\n    LOG: 'log',\n    POW: 'pow',\n    SQRT: 'sqrt',\n    SYMLOG: 'symlog',\n    IDENTITY: 'identity',\n    SEQUENTIAL: 'sequential',\n    // Continuous - Time\n    TIME: 'time',\n    UTC: 'utc',\n    // Discretizing scales\n    QUANTILE: 'quantile',\n    QUANTIZE: 'quantize',\n    THRESHOLD: 'threshold',\n    BIN_ORDINAL: 'bin-ordinal',\n    // Discrete scales\n    ORDINAL: 'ordinal',\n    POINT: 'point',\n    BAND: 'band'\n};\n/**\n * Index for scale categories -- only scale of the same categories can be merged together.\n * Current implementation is trying to be conservative and avoid merging scale type that might not work together\n */\nexport const SCALE_CATEGORY_INDEX = {\n    linear: 'numeric',\n    log: 'numeric',\n    pow: 'numeric',\n    sqrt: 'numeric',\n    symlog: 'numeric',\n    identity: 'numeric',\n    sequential: 'numeric',\n    time: 'time',\n    utc: 'time',\n    ordinal: 'ordinal',\n    'bin-ordinal': 'bin-ordinal',\n    point: 'ordinal-position',\n    band: 'ordinal-position',\n    quantile: 'discretizing',\n    quantize: 'discretizing',\n    threshold: 'discretizing'\n};\nexport const SCALE_TYPES = keys(SCALE_CATEGORY_INDEX);\n/**\n * Whether the two given scale types can be merged together.\n */\nexport function scaleCompatible(scaleType1, scaleType2) {\n    const scaleCategory1 = SCALE_CATEGORY_INDEX[scaleType1];\n    const scaleCategory2 = SCALE_CATEGORY_INDEX[scaleType2];\n    return (scaleCategory1 === scaleCategory2 ||\n        (scaleCategory1 === 'ordinal-position' && scaleCategory2 === 'time') ||\n        (scaleCategory2 === 'ordinal-position' && scaleCategory1 === 'time'));\n}\n/**\n * Index for scale precedence -- high score = higher priority for merging.\n */\nconst SCALE_PRECEDENCE_INDEX = {\n    // numeric\n    linear: 0,\n    log: 1,\n    pow: 1,\n    sqrt: 1,\n    symlog: 1,\n    identity: 1,\n    sequential: 1,\n    // time\n    time: 0,\n    utc: 0,\n    // ordinal-position -- these have higher precedence than continuous scales as they support more types of data\n    point: 10,\n    band: 11,\n    // non grouped types\n    ordinal: 0,\n    'bin-ordinal': 0,\n    quantile: 0,\n    quantize: 0,\n    threshold: 0\n};\n/**\n * Return scale categories -- only scale of the same categories can be merged together.\n */\nexport function scaleTypePrecedence(scaleType) {\n    return SCALE_PRECEDENCE_INDEX[scaleType];\n}\nexport const QUANTITATIVE_SCALES = new Set([\n    'linear',\n    'log',\n    'pow',\n    'sqrt',\n    'symlog'\n]);\nexport const CONTINUOUS_TO_CONTINUOUS_SCALES = new Set([\n    ...QUANTITATIVE_SCALES,\n    'time',\n    'utc'\n]);\nexport function isQuantitative(type) {\n    return QUANTITATIVE_SCALES.has(type);\n}\nexport const CONTINUOUS_TO_DISCRETE_SCALES = new Set([\n    'quantile',\n    'quantize',\n    'threshold'\n]);\nexport const CONTINUOUS_DOMAIN_SCALES = new Set([\n    ...CONTINUOUS_TO_CONTINUOUS_SCALES,\n    ...CONTINUOUS_TO_DISCRETE_SCALES,\n    'sequential',\n    'identity'\n]);\nexport const DISCRETE_DOMAIN_SCALES = new Set([\n    'ordinal',\n    'bin-ordinal',\n    'point',\n    'band'\n]);\nexport const TIME_SCALE_TYPES = new Set(['time', 'utc']);\nexport function hasDiscreteDomain(type) {\n    return DISCRETE_DOMAIN_SCALES.has(type);\n}\nexport function hasContinuousDomain(type) {\n    return CONTINUOUS_DOMAIN_SCALES.has(type);\n}\nexport function isContinuousToContinuous(type) {\n    return CONTINUOUS_TO_CONTINUOUS_SCALES.has(type);\n}\nexport function isContinuousToDiscrete(type) {\n    return CONTINUOUS_TO_DISCRETE_SCALES.has(type);\n}\nexport const defaultScaleConfig = {\n    pointPadding: 0.5,\n    barBandPaddingInner: 0.1,\n    rectBandPaddingInner: 0,\n    bandWithNestedOffsetPaddingInner: 0.2,\n    bandWithNestedOffsetPaddingOuter: 0.2,\n    minBandSize: 2,\n    minFontSize: 8,\n    maxFontSize: 40,\n    minOpacity: 0.3,\n    maxOpacity: 0.8,\n    // FIXME: revise if these *can* become ratios of width/height step\n    minSize: 9,\n    minStrokeWidth: 1,\n    maxStrokeWidth: 4,\n    quantileCount: 4,\n    quantizeCount: 4,\n    zero: true\n};\nexport function isExtendedScheme(scheme) {\n    return !isString(scheme) && !!scheme['name'];\n}\nexport function isParameterDomain(domain) {\n    return domain === null || domain === void 0 ? void 0 : domain['param'];\n}\nexport function isDomainUnionWith(domain) {\n    return domain === null || domain === void 0 ? void 0 : domain['unionWith'];\n}\nexport function isFieldRange(range) {\n    return isObject(range) && 'field' in range;\n}\nconst SCALE_PROPERTY_INDEX = {\n    type: 1,\n    domain: 1,\n    domainMax: 1,\n    domainMin: 1,\n    domainMid: 1,\n    align: 1,\n    range: 1,\n    rangeMax: 1,\n    rangeMin: 1,\n    scheme: 1,\n    bins: 1,\n    // Other properties\n    reverse: 1,\n    round: 1,\n    // quantitative / time\n    clamp: 1,\n    nice: 1,\n    // quantitative\n    base: 1,\n    exponent: 1,\n    constant: 1,\n    interpolate: 1,\n    zero: 1,\n    // band/point\n    padding: 1,\n    paddingInner: 1,\n    paddingOuter: 1\n};\nexport const SCALE_PROPERTIES = keys(SCALE_PROPERTY_INDEX);\nconst { type, domain, range, rangeMax, rangeMin, scheme } = SCALE_PROPERTY_INDEX, NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX = __rest(SCALE_PROPERTY_INDEX, [\"type\", \"domain\", \"range\", \"rangeMax\", \"rangeMin\", \"scheme\"]);\nexport const NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES = keys(NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX);\nexport function scaleTypeSupportProperty(scaleType, propName) {\n    switch (propName) {\n        case 'type':\n        case 'domain':\n        case 'reverse':\n        case 'range':\n            return true;\n        case 'scheme':\n        case 'interpolate':\n            return !['point', 'band', 'identity'].includes(scaleType);\n        case 'bins':\n            return !['point', 'band', 'identity', 'ordinal'].includes(scaleType);\n        case 'round':\n            return isContinuousToContinuous(scaleType) || scaleType === 'band' || scaleType === 'point';\n        case 'padding':\n        case 'rangeMin':\n        case 'rangeMax':\n            return isContinuousToContinuous(scaleType) || ['point', 'band'].includes(scaleType);\n        case 'paddingOuter':\n        case 'align':\n            return ['point', 'band'].includes(scaleType);\n        case 'paddingInner':\n            return scaleType === 'band';\n        case 'domainMax':\n        case 'domainMid':\n        case 'domainMin':\n        case 'clamp':\n            return isContinuousToContinuous(scaleType);\n        case 'nice':\n            return isContinuousToContinuous(scaleType) || scaleType === 'quantize' || scaleType === 'threshold';\n        case 'exponent':\n            return scaleType === 'pow';\n        case 'base':\n            return scaleType === 'log';\n        case 'constant':\n            return scaleType === 'symlog';\n        case 'zero':\n            return (hasContinuousDomain(scaleType) &&\n                !contains([\n                    'log',\n                    'time',\n                    'utc',\n                    'threshold',\n                    'quantile' // quantile depends on distribution so zero does not matter\n                ], scaleType));\n    }\n}\n/**\n * Returns undefined if the input channel supports the input scale property name\n */\nexport function channelScalePropertyIncompatability(channel, propName) {\n    switch (propName) {\n        case 'interpolate':\n        case 'scheme':\n        case 'domainMid':\n            if (!isColorChannel(channel)) {\n                return log.message.cannotUseScalePropertyWithNonColor(propName);\n            }\n            return undefined;\n        case 'align':\n        case 'type':\n        case 'bins':\n        case 'domain':\n        case 'domainMax':\n        case 'domainMin':\n        case 'range':\n        case 'base':\n        case 'exponent':\n        case 'constant':\n        case 'nice':\n        case 'padding':\n        case 'paddingInner':\n        case 'paddingOuter':\n        case 'rangeMax':\n        case 'rangeMin':\n        case 'reverse':\n        case 'round':\n        case 'clamp':\n        case 'zero':\n            return undefined; // GOOD!\n    }\n}\nexport function scaleTypeSupportDataType(specifiedType, fieldDefType) {\n    if (contains([ORDINAL, NOMINAL], fieldDefType)) {\n        return specifiedType === undefined || hasDiscreteDomain(specifiedType);\n    }\n    else if (fieldDefType === TEMPORAL) {\n        return contains([ScaleType.TIME, ScaleType.UTC, undefined], specifiedType);\n    }\n    else if (fieldDefType === QUANTITATIVE) {\n        return isQuantitative(specifiedType) || isContinuousToDiscrete(specifiedType) || specifiedType === undefined;\n    }\n    return true;\n}\nexport function channelSupportScaleType(channel, scaleType, hasNestedOffsetScale = false) {\n    if (!CHANNEL.isScaleChannel(channel)) {\n        return false;\n    }\n    switch (channel) {\n        case CHANNEL.X:\n        case CHANNEL.Y:\n        case CHANNEL.XOFFSET:\n        case CHANNEL.YOFFSET:\n        case CHANNEL.THETA:\n        case CHANNEL.RADIUS:\n            if (isContinuousToContinuous(scaleType)) {\n                return true;\n            }\n            else if (scaleType === 'band') {\n                return true;\n            }\n            else if (scaleType === 'point') {\n                /*\n                  Point scale can't be use if the position has a nested offset scale\n                  because if there is a nested scale, then it's band.\n                */\n                return !hasNestedOffsetScale;\n            }\n            return false;\n        case CHANNEL.SIZE: // TODO: size and opacity can support ordinal with more modification\n        case CHANNEL.STROKEWIDTH:\n        case CHANNEL.OPACITY:\n        case CHANNEL.FILLOPACITY:\n        case CHANNEL.STROKEOPACITY:\n        case CHANNEL.ANGLE:\n            // Although it generally doesn't make sense to use band with size and opacity,\n            // it can also work since we use band: 0.5 to get midpoint.\n            return (isContinuousToContinuous(scaleType) ||\n                isContinuousToDiscrete(scaleType) ||\n                contains(['band', 'point', 'ordinal'], scaleType));\n        case CHANNEL.COLOR:\n        case CHANNEL.FILL:\n        case CHANNEL.STROKE:\n            return scaleType !== 'band'; // band does not make sense with color\n        case CHANNEL.STROKEDASH:\n        case CHANNEL.SHAPE:\n            return scaleType === 'ordinal' || isContinuousToDiscrete(scaleType);\n    }\n}\n//# sourceMappingURL=scale.js.map"]},"metadata":{},"sourceType":"module"}