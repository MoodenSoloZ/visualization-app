{"ast":null,"code":"import { isXorY } from '../channel';\nimport * as log from '../log';\nimport { isConcatModel, isFacetModel, isLayerModel } from './model';\nexport function defaultScaleResolve(channel, model) {\n  if (isFacetModel(model)) {\n    return channel === 'theta' ? 'independent' : 'shared';\n  } else if (isLayerModel(model)) {\n    return 'shared';\n  } else if (isConcatModel(model)) {\n    return isXorY(channel) || channel === 'theta' || channel === 'radius' ? 'independent' : 'shared';\n  }\n  /* istanbul ignore next: should never reach here. */\n  throw new Error('invalid model type for resolve');\n}\nexport function parseGuideResolve(resolve, channel) {\n  var channelScaleResolve = resolve.scale[channel];\n  var guide = isXorY(channel) ? 'axis' : 'legend';\n  if (channelScaleResolve === 'independent') {\n    if (resolve[guide][channel] === 'shared') {\n      log.warn(log.message.independentScaleMeansIndependentGuide(channel));\n    }\n    return 'independent';\n  }\n  return resolve[guide][channel] || 'shared';\n}","map":{"version":3,"sources":["../../../src/compile/resolve.ts"],"names":[],"mappings":"AAAA,SAAQ,MAAM,QAAqB,YAAY;AAC/C,OAAO,KAAK,GAAG,MAAM,QAAQ;AAE7B,SAAQ,aAAa,EAAE,YAAY,EAAE,YAAY,QAAc,SAAS;AAExE,OAAM,SAAU,mBAAmB,CAAC,OAAqB,EAAE,KAAY,EAAA;EACrE,IAAI,YAAY,CAAC,KAAK,CAAC,EAAE;IACvB,OAAO,OAAO,KAAK,OAAO,GAAG,aAAa,GAAG,QAAQ;GACtD,MAAM,IAAI,YAAY,CAAC,KAAK,CAAC,EAAE;IAC9B,OAAO,QAAQ;GAChB,MAAM,IAAI,aAAa,CAAC,KAAK,CAAC,EAAE;IAC/B,OAAO,MAAM,CAAC,OAAO,CAAC,IAAI,OAAO,KAAK,OAAO,IAAI,OAAO,KAAK,QAAQ,GAAG,aAAa,GAAG,QAAQ;EACjG;EACD;EACA,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC;AACnD;AAEA,OAAM,SAAU,iBAAiB,CAAC,OAAgB,EAAE,OAAqB,EAAA;EACvE,IAAM,mBAAmB,GAAG,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC;EAClD,IAAM,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,GAAG,MAAM,GAAG,QAAQ;EAEjD,IAAI,mBAAmB,KAAK,aAAa,EAAE;IACzC,IAAI,OAAO,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,KAAK,QAAQ,EAAE;MACxC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,qCAAqC,CAAC,OAAO,CAAC,CAAC;IACrE;IACD,OAAO,aAAa;EACrB;EAED,OAAO,OAAO,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,IAAI,QAAQ;AAC5C","sourceRoot":"","sourcesContent":["import { isXorY } from '../channel';\nimport * as log from '../log';\nimport { isConcatModel, isFacetModel, isLayerModel } from './model';\nexport function defaultScaleResolve(channel, model) {\n    if (isFacetModel(model)) {\n        return channel === 'theta' ? 'independent' : 'shared';\n    }\n    else if (isLayerModel(model)) {\n        return 'shared';\n    }\n    else if (isConcatModel(model)) {\n        return isXorY(channel) || channel === 'theta' || channel === 'radius' ? 'independent' : 'shared';\n    }\n    /* istanbul ignore next: should never reach here. */\n    throw new Error('invalid model type for resolve');\n}\nexport function parseGuideResolve(resolve, channel) {\n    const channelScaleResolve = resolve.scale[channel];\n    const guide = isXorY(channel) ? 'axis' : 'legend';\n    if (channelScaleResolve === 'independent') {\n        if (resolve[guide][channel] === 'shared') {\n            log.warn(log.message.independentScaleMeansIndependentGuide(channel));\n        }\n        return 'independent';\n    }\n    return resolve[guide][channel] || 'shared';\n}\n//# sourceMappingURL=resolve.js.map"]},"metadata":{},"sourceType":"module"}