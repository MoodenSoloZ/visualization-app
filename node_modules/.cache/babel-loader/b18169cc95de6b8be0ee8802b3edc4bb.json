{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { array } from 'vega-util';\nimport { isQuantitative } from '../../scale';\nimport { keys, titleCase } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { getStyleConfig, signalOrStringValue } from '../common';\nfunction getAxisConfigFromConfigTypes(configTypes, config, channel, orient) {\n  // TODO: add special casing to add conditional value based on orient signal\n  return Object.assign.apply(null, [{}].concat(_toConsumableArray(configTypes.map(function (configType) {\n    if (configType === 'axisOrient') {\n      var orient1 = channel === 'x' ? 'bottom' : 'left';\n      var orientConfig1 = config[channel === 'x' ? 'axisBottom' : 'axisLeft'] || {};\n      var orientConfig2 = config[channel === 'x' ? 'axisTop' : 'axisRight'] || {};\n      var props = new Set([].concat(_toConsumableArray(keys(orientConfig1)), _toConsumableArray(keys(orientConfig2))));\n      var conditionalOrientAxisConfig = {};\n      var _iterator = _createForOfIteratorHelper(props.values()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var prop = _step.value;\n          conditionalOrientAxisConfig[prop] = {\n            // orient is surely signal in this case\n            signal: \"\".concat(orient['signal'], \" === \\\"\").concat(orient1, \"\\\" ? \").concat(signalOrStringValue(orientConfig1[prop]), \" : \").concat(signalOrStringValue(orientConfig2[prop]))\n          };\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return conditionalOrientAxisConfig;\n    }\n    return config[configType];\n  }))));\n}\nexport function getAxisConfigs(channel, scaleType, orient, config) {\n  var typeBasedConfigTypes = scaleType === 'band' ? ['axisDiscrete', 'axisBand'] : scaleType === 'point' ? ['axisDiscrete', 'axisPoint'] : isQuantitative(scaleType) ? ['axisQuantitative'] : scaleType === 'time' || scaleType === 'utc' ? ['axisTemporal'] : [];\n  var axisChannel = channel === 'x' ? 'axisX' : 'axisY';\n  var axisOrient = isSignalRef(orient) ? 'axisOrient' : \"axis\".concat(titleCase(orient)); // axisTop, axisBottom, ...\n  var vlOnlyConfigTypes = [].concat(typeBasedConfigTypes, _toConsumableArray(typeBasedConfigTypes.map(function (c) {\n    return axisChannel + c.substr(4);\n  })));\n  var vgConfigTypes = ['axis', axisOrient, axisChannel];\n  return {\n    vlOnlyAxisConfig: getAxisConfigFromConfigTypes(vlOnlyConfigTypes, config, channel, orient),\n    vgAxisConfig: getAxisConfigFromConfigTypes(vgConfigTypes, config, channel, orient),\n    axisConfigStyle: getAxisConfigStyle([].concat(vgConfigTypes, _toConsumableArray(vlOnlyConfigTypes)), config)\n  };\n}\nexport function getAxisConfigStyle(axisConfigTypes, config) {\n  var _a;\n  var toMerge = [{}];\n  var _iterator2 = _createForOfIteratorHelper(axisConfigTypes),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var configType = _step2.value;\n      // TODO: add special casing to add conditional value based on orient signal\n      var style = (_a = config[configType]) === null || _a === void 0 ? void 0 : _a.style;\n      if (style) {\n        style = array(style);\n        var _iterator3 = _createForOfIteratorHelper(style),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var s = _step3.value;\n            toMerge.push(config.style[s]);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return Object.assign.apply(null, toMerge);\n}\nexport function getAxisConfig(property, styleConfigIndex, style) {\n  var axisConfigs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _a;\n  var styleConfig = getStyleConfig(property, style, styleConfigIndex);\n  if (styleConfig !== undefined) {\n    return {\n      configFrom: 'style',\n      configValue: styleConfig\n    };\n  }\n  for (var _i = 0, _arr = ['vlOnlyAxisConfig', 'vgAxisConfig', 'axisConfigStyle']; _i < _arr.length; _i++) {\n    var configFrom = _arr[_i];\n    if (((_a = axisConfigs[configFrom]) === null || _a === void 0 ? void 0 : _a[property]) !== undefined) {\n      return {\n        configFrom: configFrom,\n        configValue: axisConfigs[configFrom][property]\n      };\n    }\n  }\n  return {};\n}","map":{"version":3,"sources":["../../../../src/compile/axis/config.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { array } from 'vega-util';\nimport { isQuantitative } from '../../scale';\nimport { keys, titleCase } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { getStyleConfig, signalOrStringValue } from '../common';\nfunction getAxisConfigFromConfigTypes(configTypes, config, channel, orient) {\n    // TODO: add special casing to add conditional value based on orient signal\n    return Object.assign.apply(null, [\n        {},\n        ...configTypes.map(configType => {\n            if (configType === 'axisOrient') {\n                const orient1 = channel === 'x' ? 'bottom' : 'left';\n                const orientConfig1 = config[channel === 'x' ? 'axisBottom' : 'axisLeft'] || {};\n                const orientConfig2 = config[channel === 'x' ? 'axisTop' : 'axisRight'] || {};\n                const props = new Set([...keys(orientConfig1), ...keys(orientConfig2)]);\n                const conditionalOrientAxisConfig = {};\n                for (const prop of props.values()) {\n                    conditionalOrientAxisConfig[prop] = {\n                        // orient is surely signal in this case\n                        signal: `${orient['signal']} === \"${orient1}\" ? ${signalOrStringValue(orientConfig1[prop])} : ${signalOrStringValue(orientConfig2[prop])}`\n                    };\n                }\n                return conditionalOrientAxisConfig;\n            }\n            return config[configType];\n        })\n    ]);\n}\nexport function getAxisConfigs(channel, scaleType, orient, config) {\n    const typeBasedConfigTypes = scaleType === 'band'\n        ? ['axisDiscrete', 'axisBand']\n        : scaleType === 'point'\n            ? ['axisDiscrete', 'axisPoint']\n            : isQuantitative(scaleType)\n                ? ['axisQuantitative']\n                : scaleType === 'time' || scaleType === 'utc'\n                    ? ['axisTemporal']\n                    : [];\n    const axisChannel = channel === 'x' ? 'axisX' : 'axisY';\n    const axisOrient = isSignalRef(orient) ? 'axisOrient' : `axis${titleCase(orient)}`; // axisTop, axisBottom, ...\n    const vlOnlyConfigTypes = [\n        // technically Vega does have axisBand, but if we make another separation here,\n        // it will further introduce complexity in the code\n        ...typeBasedConfigTypes,\n        ...typeBasedConfigTypes.map(c => axisChannel + c.substr(4))\n    ];\n    const vgConfigTypes = ['axis', axisOrient, axisChannel];\n    return {\n        vlOnlyAxisConfig: getAxisConfigFromConfigTypes(vlOnlyConfigTypes, config, channel, orient),\n        vgAxisConfig: getAxisConfigFromConfigTypes(vgConfigTypes, config, channel, orient),\n        axisConfigStyle: getAxisConfigStyle([...vgConfigTypes, ...vlOnlyConfigTypes], config)\n    };\n}\nexport function getAxisConfigStyle(axisConfigTypes, config) {\n    var _a;\n    const toMerge = [{}];\n    for (const configType of axisConfigTypes) {\n        // TODO: add special casing to add conditional value based on orient signal\n        let style = (_a = config[configType]) === null || _a === void 0 ? void 0 : _a.style;\n        if (style) {\n            style = array(style);\n            for (const s of style) {\n                toMerge.push(config.style[s]);\n            }\n        }\n    }\n    return Object.assign.apply(null, toMerge);\n}\nexport function getAxisConfig(property, styleConfigIndex, style, axisConfigs = {}) {\n    var _a;\n    const styleConfig = getStyleConfig(property, style, styleConfigIndex);\n    if (styleConfig !== undefined) {\n        return {\n            configFrom: 'style',\n            configValue: styleConfig\n        };\n    }\n    for (const configFrom of ['vlOnlyAxisConfig', 'vgAxisConfig', 'axisConfigStyle']) {\n        if (((_a = axisConfigs[configFrom]) === null || _a === void 0 ? void 0 : _a[property]) !== undefined) {\n            return { configFrom, configValue: axisConfigs[configFrom][property] };\n        }\n    }\n    return {};\n}\n//# sourceMappingURL=config.js.map"]},"metadata":{},"sourceType":"module"}