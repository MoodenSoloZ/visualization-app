{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { array, isArray } from 'vega-util';\nimport { isArgmaxDef, isArgminDef } from './aggregate';\nimport { isBinned, isBinning } from './bin';\nimport { ANGLE, CHANNELS, COLOR, DESCRIPTION, DETAIL, FILL, FILLOPACITY, getMainChannelFromOffsetChannel, getOffsetScaleChannel, HREF, isChannel, isNonPositionScaleChannel, isSecondaryRangeChannel, isXorY, isXorYOffset, KEY, LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, OPACITY, ORDER, RADIUS, RADIUS2, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH, supportMark, TEXT, THETA, THETA2, TOOLTIP, UNIT_CHANNELS, URL, X, X2, XOFFSET, Y, Y2, YOFFSET } from './channel';\nimport { binRequiresRange, getFieldDef, getGuide, hasConditionalFieldDef, hasConditionalFieldOrDatumDef, initChannelDef, initFieldDef, isConditionalDef, isDatumDef, isFieldDef, isTypedFieldDef, isValueDef, title, vgField } from './channeldef';\nimport * as log from './log';\nimport { isContinuous, isDiscrete, QUANTITATIVE, TEMPORAL } from './type';\nimport { keys, some } from './util';\nimport { isSignalRef } from './vega.schema';\nexport function channelHasField(encoding, channel) {\n  var channelDef = encoding && encoding[channel];\n  if (channelDef) {\n    if (isArray(channelDef)) {\n      return some(channelDef, function (fieldDef) {\n        return !!fieldDef.field;\n      });\n    } else {\n      return isFieldDef(channelDef) || hasConditionalFieldDef(channelDef);\n    }\n  }\n  return false;\n}\nexport function channelHasFieldOrDatum(encoding, channel) {\n  var channelDef = encoding && encoding[channel];\n  if (channelDef) {\n    if (isArray(channelDef)) {\n      return some(channelDef, function (fieldDef) {\n        return !!fieldDef.field;\n      });\n    } else {\n      return isFieldDef(channelDef) || isDatumDef(channelDef) || hasConditionalFieldOrDatumDef(channelDef);\n    }\n  }\n  return false;\n}\nexport function channelHasNestedOffsetScale(encoding, channel) {\n  if (isXorY(channel)) {\n    var fieldDef = encoding[channel];\n    if ((isFieldDef(fieldDef) || isDatumDef(fieldDef)) && isDiscrete(fieldDef.type)) {\n      var offsetChannel = getOffsetScaleChannel(channel);\n      return channelHasFieldOrDatum(encoding, offsetChannel);\n    }\n  }\n  return false;\n}\nexport function isAggregate(encoding) {\n  return some(CHANNELS, function (channel) {\n    if (channelHasField(encoding, channel)) {\n      var channelDef = encoding[channel];\n      if (isArray(channelDef)) {\n        return some(channelDef, function (fieldDef) {\n          return !!fieldDef.aggregate;\n        });\n      } else {\n        var fieldDef = getFieldDef(channelDef);\n        return fieldDef && !!fieldDef.aggregate;\n      }\n    }\n    return false;\n  });\n}\nexport function extractTransformsFromEncoding(oldEncoding, config) {\n  var groupby = [];\n  var bins = [];\n  var timeUnits = [];\n  var aggregate = [];\n  var encoding = {};\n  forEach(oldEncoding, function (channelDef, channel) {\n    // Extract potential embedded transformations along with remaining properties\n    if (isFieldDef(channelDef)) {\n      var field = channelDef.field,\n        aggOp = channelDef.aggregate,\n        bin = channelDef.bin,\n        timeUnit = channelDef.timeUnit,\n        remaining = __rest(channelDef, [\"field\", \"aggregate\", \"bin\", \"timeUnit\"]);\n      if (aggOp || timeUnit || bin) {\n        var guide = getGuide(channelDef);\n        var isTitleDefined = guide === null || guide === void 0 ? void 0 : guide.title;\n        var newField = vgField(channelDef, {\n          forAs: true\n        });\n        var newFieldDef = Object.assign(Object.assign(Object.assign({}, isTitleDefined ? [] : {\n          title: title(channelDef, config, {\n            allowDisabling: true\n          })\n        }), remaining), {\n          // Always overwrite field\n          field: newField\n        });\n        if (aggOp) {\n          var op;\n          if (isArgmaxDef(aggOp)) {\n            op = 'argmax';\n            newField = vgField({\n              op: 'argmax',\n              field: aggOp.argmax\n            }, {\n              forAs: true\n            });\n            newFieldDef.field = \"\".concat(newField, \".\").concat(field);\n          } else if (isArgminDef(aggOp)) {\n            op = 'argmin';\n            newField = vgField({\n              op: 'argmin',\n              field: aggOp.argmin\n            }, {\n              forAs: true\n            });\n            newFieldDef.field = \"\".concat(newField, \".\").concat(field);\n          } else if (aggOp !== 'boxplot' && aggOp !== 'errorbar' && aggOp !== 'errorband') {\n            op = aggOp;\n          }\n          if (op) {\n            var aggregateEntry = {\n              op: op,\n              as: newField\n            };\n            if (field) {\n              aggregateEntry.field = field;\n            }\n            aggregate.push(aggregateEntry);\n          }\n        } else {\n          groupby.push(newField);\n          if (isTypedFieldDef(channelDef) && isBinning(bin)) {\n            bins.push({\n              bin: bin,\n              field: field,\n              as: newField\n            });\n            // Add additional groupbys for range and end of bins\n            groupby.push(vgField(channelDef, {\n              binSuffix: 'end'\n            }));\n            if (binRequiresRange(channelDef, channel)) {\n              groupby.push(vgField(channelDef, {\n                binSuffix: 'range'\n              }));\n            }\n            // Create accompanying 'x2' or 'y2' field if channel is 'x' or 'y' respectively\n            if (isXorY(channel)) {\n              var secondaryChannel = {\n                field: \"\".concat(newField, \"_end\")\n              };\n              encoding[\"\".concat(channel, \"2\")] = secondaryChannel;\n            }\n            newFieldDef.bin = 'binned';\n            if (!isSecondaryRangeChannel(channel)) {\n              newFieldDef['type'] = QUANTITATIVE;\n            }\n          } else if (timeUnit) {\n            timeUnits.push({\n              timeUnit: timeUnit,\n              field: field,\n              as: newField\n            });\n            // define the format type for later compilation\n            var formatType = isTypedFieldDef(channelDef) && channelDef.type !== TEMPORAL && 'time';\n            if (formatType) {\n              if (channel === TEXT || channel === TOOLTIP) {\n                newFieldDef['formatType'] = formatType;\n              } else if (isNonPositionScaleChannel(channel)) {\n                newFieldDef['legend'] = Object.assign({\n                  formatType: formatType\n                }, newFieldDef['legend']);\n              } else if (isXorY(channel)) {\n                newFieldDef['axis'] = Object.assign({\n                  formatType: formatType\n                }, newFieldDef['axis']);\n              }\n            }\n          }\n        }\n        // now the field should refer to post-transformed field instead\n        encoding[channel] = newFieldDef;\n      } else {\n        groupby.push(field);\n        encoding[channel] = oldEncoding[channel];\n      }\n    } else {\n      // For value def / signal ref / datum def, just copy\n      encoding[channel] = oldEncoding[channel];\n    }\n  });\n  return {\n    bins: bins,\n    timeUnits: timeUnits,\n    aggregate: aggregate,\n    groupby: groupby,\n    encoding: encoding\n  };\n}\nexport function markChannelCompatible(encoding, channel, mark) {\n  var markSupported = supportMark(channel, mark);\n  if (!markSupported) {\n    return false;\n  } else if (markSupported === 'binned') {\n    var primaryFieldDef = encoding[channel === X2 ? X : Y];\n    // circle, point, square and tick only support x2/y2 when their corresponding x/y fieldDef\n    // has \"binned\" data and thus need x2/y2 to specify the bin-end field.\n    if (isFieldDef(primaryFieldDef) && isFieldDef(encoding[channel]) && isBinned(primaryFieldDef.bin)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\nexport function initEncoding(encoding, mark, filled, config) {\n  var normalizedEncoding = {};\n  var _iterator = _createForOfIteratorHelper(keys(encoding)),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var key = _step.value;\n      if (!isChannel(key)) {\n        // Drop invalid channel\n        log.warn(log.message.invalidEncodingChannel(key));\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var _iterator2 = _createForOfIteratorHelper(UNIT_CHANNELS),\n    _step2;\n  try {\n    var _loop = function _loop() {\n      var channel = _step2.value;\n      if (!encoding[channel]) {\n        return \"continue\";\n      }\n      var channelDef = encoding[channel];\n      if (isXorYOffset(channel)) {\n        var mainChannel = getMainChannelFromOffsetChannel(channel);\n        var positionDef = normalizedEncoding[mainChannel];\n        if (isFieldDef(positionDef)) {\n          if (isContinuous(positionDef.type)) {\n            if (isFieldDef(channelDef)) {\n              // TODO: nesting continuous field instead continuous field should\n              // behave like offsetting the data in data domain\n              log.warn(log.message.offsetNestedInsideContinuousPositionScaleDropped(mainChannel));\n              return \"continue\";\n            }\n          }\n        } else {\n          // no x/y, replace it with main channel\n          channel = mainChannel;\n          log.warn(log.message.replaceOffsetWithMainChannel(mainChannel));\n        }\n      }\n      if (channel === 'angle' && mark === 'arc' && !encoding.theta) {\n        log.warn(log.message.REPLACE_ANGLE_WITH_THETA);\n        channel = THETA;\n      }\n      if (!markChannelCompatible(encoding, channel, mark)) {\n        // Drop unsupported channel\n        log.warn(log.message.incompatibleChannel(channel, mark));\n        return \"continue\";\n      }\n      // Drop line's size if the field is aggregated.\n      if (channel === SIZE && mark === 'line') {\n        var fieldDef = getFieldDef(encoding[channel]);\n        if (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.aggregate) {\n          log.warn(log.message.LINE_WITH_VARYING_SIZE);\n          return \"continue\";\n        }\n      }\n      // Drop color if either fill or stroke is specified\n      if (channel === COLOR && (filled ? 'fill' in encoding : 'stroke' in encoding)) {\n        log.warn(log.message.droppingColor('encoding', {\n          fill: 'fill' in encoding,\n          stroke: 'stroke' in encoding\n        }));\n        return \"continue\";\n      }\n      if (channel === DETAIL || channel === ORDER && !isArray(channelDef) && !isValueDef(channelDef) || channel === TOOLTIP && isArray(channelDef)) {\n        if (channelDef) {\n          // Array of fieldDefs for detail channel (or production rule)\n          normalizedEncoding[channel] = array(channelDef).reduce(function (defs, fieldDef) {\n            if (!isFieldDef(fieldDef)) {\n              log.warn(log.message.emptyFieldDef(fieldDef, channel));\n            } else {\n              defs.push(initFieldDef(fieldDef, channel));\n            }\n            return defs;\n          }, []);\n        }\n      } else {\n        if (channel === TOOLTIP && channelDef === null) {\n          // Preserve null so we can use it to disable tooltip\n          normalizedEncoding[channel] = null;\n        } else if (!isFieldDef(channelDef) && !isDatumDef(channelDef) && !isValueDef(channelDef) && !isConditionalDef(channelDef) && !isSignalRef(channelDef)) {\n          log.warn(log.message.emptyFieldDef(channelDef, channel));\n          return \"continue\";\n        }\n        normalizedEncoding[channel] = initChannelDef(channelDef, channel, config);\n      }\n    };\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _ret = _loop();\n      if (_ret === \"continue\") continue;\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return normalizedEncoding;\n}\n/**\n * For composite marks, we have to call initChannelDef during init so we can infer types earlier.\n */\nexport function normalizeEncoding(encoding, config) {\n  var normalizedEncoding = {};\n  var _iterator3 = _createForOfIteratorHelper(keys(encoding)),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var channel = _step3.value;\n      var newChannelDef = initChannelDef(encoding[channel], channel, config, {\n        compositeMark: true\n      });\n      normalizedEncoding[channel] = newChannelDef;\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return normalizedEncoding;\n}\nexport function fieldDefs(encoding) {\n  var arr = [];\n  var _iterator4 = _createForOfIteratorHelper(keys(encoding)),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var channel = _step4.value;\n      if (channelHasField(encoding, channel)) {\n        var channelDef = encoding[channel];\n        var channelDefArray = array(channelDef);\n        var _iterator5 = _createForOfIteratorHelper(channelDefArray),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var def = _step5.value;\n            if (isFieldDef(def)) {\n              arr.push(def);\n            } else if (hasConditionalFieldDef(def)) {\n              arr.push(def.condition);\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return arr;\n}\nexport function forEach(mapping, f, thisArg) {\n  if (!mapping) {\n    return;\n  }\n  var _iterator6 = _createForOfIteratorHelper(keys(mapping)),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var channel = _step6.value;\n      var el = mapping[channel];\n      if (isArray(el)) {\n        var _iterator7 = _createForOfIteratorHelper(el),\n          _step7;\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var channelDef = _step7.value;\n            f.call(thisArg, channelDef, channel);\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n      } else {\n        f.call(thisArg, el, channel);\n      }\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n}\nexport function reduce(mapping, f, init, thisArg) {\n  if (!mapping) {\n    return init;\n  }\n  return keys(mapping).reduce(function (r, channel) {\n    var map = mapping[channel];\n    if (isArray(map)) {\n      return map.reduce(function (r1, channelDef) {\n        return f.call(thisArg, r1, channelDef, channel);\n      }, r);\n    } else {\n      return f.call(thisArg, r, map, channel);\n    }\n  }, init);\n}\n/**\n * Returns list of path grouping fields for the given encoding\n */\nexport function pathGroupingFields(mark, encoding) {\n  return keys(encoding).reduce(function (details, channel) {\n    switch (channel) {\n      // x, y, x2, y2, lat, long, lat1, long2, order, tooltip, href, aria label, cursor should not cause lines to group\n      case X:\n      case Y:\n      case HREF:\n      case DESCRIPTION:\n      case URL:\n      case X2:\n      case Y2:\n      case XOFFSET:\n      case YOFFSET:\n      case THETA:\n      case THETA2:\n      case RADIUS:\n      case RADIUS2:\n      // falls through\n      case LATITUDE:\n      case LONGITUDE:\n      case LATITUDE2:\n      case LONGITUDE2:\n      // TODO: case 'cursor':\n      // text, shape, shouldn't be a part of line/trail/area [falls through]\n      case TEXT:\n      case SHAPE:\n      case ANGLE:\n      // falls through\n      // tooltip fields should not be added to group by [falls through]\n      case TOOLTIP:\n        return details;\n      case ORDER:\n        // order should not group line / trail\n        if (mark === 'line' || mark === 'trail') {\n          return details;\n        }\n      // but order should group area for stacking (falls through)\n      case DETAIL:\n      case KEY:\n        {\n          var channelDef = encoding[channel];\n          if (isArray(channelDef) || isFieldDef(channelDef)) {\n            var _iterator8 = _createForOfIteratorHelper(array(channelDef)),\n              _step8;\n            try {\n              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                var fieldDef = _step8.value;\n                if (!fieldDef.aggregate) {\n                  details.push(vgField(fieldDef, {}));\n                }\n              }\n            } catch (err) {\n              _iterator8.e(err);\n            } finally {\n              _iterator8.f();\n            }\n          }\n          return details;\n        }\n      case SIZE:\n        if (mark === 'trail') {\n          // For trail, size should not group trail lines.\n          return details;\n        }\n      // For line, size should group lines.\n      // falls through\n      case COLOR:\n      case FILL:\n      case STROKE:\n      case OPACITY:\n      case FILLOPACITY:\n      case STROKEOPACITY:\n      case STROKEDASH:\n      case STROKEWIDTH:\n        {\n          // TODO strokeDashOffset:\n          // falls through\n          var _fieldDef = getFieldDef(encoding[channel]);\n          if (_fieldDef && !_fieldDef.aggregate) {\n            details.push(vgField(_fieldDef, {}));\n          }\n          return details;\n        }\n    }\n  }, []);\n}","map":{"version":3,"sources":["../../src/encoding.ts"],"names":[],"mappings":";;;;;;;;;;;AACA,SAAQ,KAAK,EAAE,OAAO,QAAO,WAAW;AACxC,SAAQ,WAAW,EAAE,WAAW,QAAO,aAAa;AACpD,SAAQ,QAAQ,EAAE,SAAS,QAAO,OAAO;AACzC,SACE,KAAK,EAEL,QAAQ,EACR,KAAK,EACL,WAAW,EACX,MAAM,EACN,IAAI,EACJ,WAAW,EACX,+BAA+B,EAC/B,qBAAqB,EACrB,IAAI,EACJ,SAAS,EACT,yBAAyB,EACzB,uBAAuB,EACvB,MAAM,EACN,YAAY,EACZ,GAAG,EACH,QAAQ,EACR,SAAS,EACT,SAAS,EACT,UAAU,EACV,OAAO,EACP,KAAK,EACL,MAAM,EACN,OAAO,EACP,KAAK,EACL,IAAI,EACJ,MAAM,EACN,UAAU,EACV,aAAa,EACb,WAAW,EACX,WAAW,EACX,IAAI,EACJ,KAAK,EACL,MAAM,EACN,OAAO,EACP,aAAa,EACb,GAAG,EACH,CAAC,EACD,EAAE,EACF,OAAO,EACP,CAAC,EACD,EAAE,EACF,OAAO,QACF,WAAW;AAClB,SACE,gBAAgB,EAMhB,WAAW,EACX,QAAQ,EACR,sBAAsB,EACtB,6BAA6B,EAC7B,cAAc,EACd,YAAY,EACZ,gBAAgB,EAChB,UAAU,EACV,UAAU,EACV,eAAe,EACf,UAAU,EAgBV,KAAK,EAEL,OAAO,QACF,cAAc;AAErB,OAAO,KAAK,GAAG,MAAM,OAAO;AAI5B,SAAQ,YAAY,EAAE,UAAU,EAAE,YAAY,EAAE,QAAQ,QAAO,QAAQ;AACvE,SAAQ,IAAI,EAAE,IAAI,QAAO,QAAQ;AACjC,SAAQ,WAAW,QAAO,eAAe;AA0OzC,OAAM,SAAU,eAAe,CAC7B,QAA8B,EAC9B,OAAmC,EAAA;EAEnC,IAAM,UAAU,GAAG,QAAQ,IAAI,QAAQ,CAAC,OAAO,CAAC;EAChD,IAAI,UAAU,EAAE;IACd,IAAI,OAAO,CAAC,UAAU,CAAC,EAAE;MACvB,OAAO,IAAI,CAAC,UAAU,EAAE,UAAA,QAAQ;QAAA,OAAI,CAAC,CAAC,QAAQ,CAAC,KAAK;MAAA,EAAC;KACtD,MAAM;MACL,OAAO,UAAU,CAAC,UAAU,CAAC,IAAI,sBAAsB,CAAQ,UAAU,CAAC;IAC3E;EACF;EACD,OAAO,KAAK;AACd;AAEA,OAAM,SAAU,sBAAsB,CACpC,QAA8B,EAC9B,OAAmC,EAAA;EAEnC,IAAM,UAAU,GAAG,QAAQ,IAAI,QAAQ,CAAC,OAAO,CAAC;EAChD,IAAI,UAAU,EAAE;IACd,IAAI,OAAO,CAAC,UAAU,CAAC,EAAE;MACvB,OAAO,IAAI,CAAC,UAAU,EAAE,UAAA,QAAQ;QAAA,OAAI,CAAC,CAAC,QAAQ,CAAC,KAAK;MAAA,EAAC;KACtD,MAAM;MACL,OAAO,UAAU,CAAC,UAAU,CAAC,IAAI,UAAU,CAAC,UAAU,CAAC,IAAI,6BAA6B,CAAQ,UAAU,CAAC;IAC5G;EACF;EACD,OAAO,KAAK;AACd;AAEA,OAAM,SAAU,2BAA2B,CACzC,QAA8B,EAC9B,OAAmC,EAAA;EAEnC,IAAI,MAAM,CAAC,OAAO,CAAC,EAAE;IACnB,IAAM,QAAQ,GAAG,QAAQ,CAAC,OAAO,CAAC;IAClC,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,IAAI,UAAU,CAAC,QAAQ,CAAC,KAAK,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;MAC/E,IAAM,aAAa,GAAG,qBAAqB,CAAC,OAAO,CAAC;MACpD,OAAO,sBAAsB,CAAC,QAAQ,EAAE,aAAa,CAAC;IACvD;EACF;EACD,OAAO,KAAK;AACd;AAEA,OAAM,SAAU,WAAW,CAAC,QAAgC,EAAA;EAC1D,OAAO,IAAI,CAAC,QAAQ,EAAE,UAAA,OAAO,EAAG;IAC9B,IAAI,eAAe,CAAC,QAAQ,EAAE,OAAO,CAAC,EAAE;MACtC,IAAM,UAAU,GAAG,QAAQ,CAAC,OAAO,CAAC;MACpC,IAAI,OAAO,CAAC,UAAU,CAAC,EAAE;QACvB,OAAO,IAAI,CAAC,UAAU,EAAE,UAAA,QAAQ;UAAA,OAAI,CAAC,CAAC,QAAQ,CAAC,SAAS;QAAA,EAAC;OAC1D,MAAM;QACL,IAAM,QAAQ,GAAG,WAAW,CAAC,UAAU,CAAC;QACxC,OAAO,QAAQ,IAAI,CAAC,CAAC,QAAQ,CAAC,SAAS;MACxC;IACF;IACD,OAAO,KAAK;EACd,CAAC,CAAC;AACJ;AAEA,OAAM,SAAU,6BAA6B,CAAC,WAA0B,EAAE,MAAc,EAAA;EACtF,IAAM,OAAO,GAAa,EAAE;EAC5B,IAAM,IAAI,GAAmB,EAAE;EAC/B,IAAM,SAAS,GAAwB,EAAE;EACzC,IAAM,SAAS,GAAyB,EAAE;EAC1C,IAAM,QAAQ,GAAqB,CAAA,CAAE;EAErC,OAAO,CAAC,WAAW,EAAE,UAAC,UAAU,EAAE,OAAO,EAAI;IAC3C;IACA,IAAI,UAAU,CAAC,UAAU,CAAC,EAAE;MAC1B,IAAO,KAAK,GAAmD,UAAU,CAAlE,KAAK;QAAa,KAAK,GAAiC,UAAU,CAA3D,SAAS;QAAS,GAAG,GAA4B,UAAU,CAAzC,GAAG;QAAE,QAAQ,GAAkB,UAAU,CAApC,QAAQ;QAAK,SAAS,GAAA,MAAA,CAAI,UAAU,EAAnE,CAAA,OAAA,EAAA,WAAA,EAAA,KAAA,EAAA,UAAA,CAAsD,CAAa;MACzE,IAAI,KAAK,IAAI,QAAQ,IAAI,GAAG,EAAE;QAC5B,IAAM,KAAK,GAAG,QAAQ,CAAC,UAAU,CAAC;QAClC,IAAM,cAAc,GAAG,KAAK,KAAA,IAAA,IAAL,KAAK,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAL,KAAK,CAAE,KAAK;QACnC,IAAI,QAAQ,GAAG,OAAO,CAAC,UAAU,EAAE;UAAC,KAAK,EAAE;QAAI,CAAC,CAAC;QACjD,IAAM,WAAW,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAEX,cAAc,GAAG,EAAE,GAAG;UAAC,KAAK,EAAE,KAAK,CAAC,UAAU,EAAE,MAAM,EAAE;YAAC,cAAc,EAAE;UAAI,CAAC;QAAC,CAAC,CAAC,EAClF,SAAS,CAAA,EAAA;UACZ;UACA,KAAK,EAAE;QAAQ,CAAA,CAChB;QAED,IAAI,KAAK,EAAE;UACT,IAAI,EAAe;UAEnB,IAAI,WAAW,CAAC,KAAK,CAAC,EAAE;YACtB,EAAE,GAAG,QAAQ;YACb,QAAQ,GAAG,OAAO,CAAC;cAAC,EAAE,EAAE,QAAQ;cAAE,KAAK,EAAE,KAAK,CAAC;YAAM,CAAC,EAAE;cAAC,KAAK,EAAE;YAAI,CAAC,CAAC;YACtE,WAAW,CAAC,KAAK,aAAM,QAAQ,cAAI,KAAK,CAAE;WAC3C,MAAM,IAAI,WAAW,CAAC,KAAK,CAAC,EAAE;YAC7B,EAAE,GAAG,QAAQ;YACb,QAAQ,GAAG,OAAO,CAAC;cAAC,EAAE,EAAE,QAAQ;cAAE,KAAK,EAAE,KAAK,CAAC;YAAM,CAAC,EAAE;cAAC,KAAK,EAAE;YAAI,CAAC,CAAC;YACtE,WAAW,CAAC,KAAK,aAAM,QAAQ,cAAI,KAAK,CAAE;WAC3C,MAAM,IAAI,KAAK,KAAK,SAAS,IAAI,KAAK,KAAK,UAAU,IAAI,KAAK,KAAK,WAAW,EAAE;YAC/E,EAAE,GAAG,KAAK;UACX;UAED,IAAI,EAAE,EAAE;YACN,IAAM,cAAc,GAAuB;cACzC,EAAE,EAAF,EAAE;cACF,EAAE,EAAE;aACL;YACD,IAAI,KAAK,EAAE;cACT,cAAc,CAAC,KAAK,GAAG,KAAK;YAC7B;YACD,SAAS,CAAC,IAAI,CAAC,cAAc,CAAC;UAC/B;SACF,MAAM;UACL,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC;UACtB,IAAI,eAAe,CAAC,UAAU,CAAC,IAAI,SAAS,CAAC,GAAG,CAAC,EAAE;YACjD,IAAI,CAAC,IAAI,CAAC;cAAC,GAAG,EAAH,GAAG;cAAE,KAAK,EAAL,KAAK;cAAE,EAAE,EAAE;YAAQ,CAAC,CAAC;YACrC;YACA,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE;cAAC,SAAS,EAAE;YAAK,CAAC,CAAC,CAAC;YACrD,IAAI,gBAAgB,CAAC,UAAU,EAAE,OAAO,CAAC,EAAE;cACzC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE;gBAAC,SAAS,EAAE;cAAO,CAAC,CAAC,CAAC;YACxD;YACD;YACA,IAAI,MAAM,CAAC,OAAO,CAAC,EAAE;cACnB,IAAM,gBAAgB,GAA8B;gBAClD,KAAK,YAAK,QAAQ;eACnB;cACD,QAAQ,WAAI,OAAO,OAAI,GAAG,gBAAgB;YAC3C;YACD,WAAW,CAAC,GAAG,GAAG,QAAQ;YAC1B,IAAI,CAAC,uBAAuB,CAAC,OAAO,CAAC,EAAE;cACrC,WAAW,CAAC,MAAM,CAAC,GAAG,YAAY;YACnC;WACF,MAAM,IAAI,QAAQ,EAAE;YACnB,SAAS,CAAC,IAAI,CAAC;cACb,QAAQ,EAAR,QAAQ;cACR,KAAK,EAAL,KAAK;cACL,EAAE,EAAE;aACL,CAAC;YAEF;YACA,IAAM,UAAU,GAAG,eAAe,CAAC,UAAU,CAAC,IAAI,UAAU,CAAC,IAAI,KAAK,QAAQ,IAAI,MAAM;YACxF,IAAI,UAAU,EAAE;cACd,IAAI,OAAO,KAAK,IAAI,IAAI,OAAO,KAAK,OAAO,EAAE;gBAC3C,WAAW,CAAC,YAAY,CAAC,GAAG,UAAU;eACvC,MAAM,IAAI,yBAAyB,CAAC,OAAO,CAAC,EAAE;gBAC7C,WAAW,CAAC,QAAQ,CAAC,GAAA,MAAA,CAAA,MAAA,CAAA;kBACnB,UAAU,EAAV;gBAAU,CAAA,EACP,WAAW,CAAC,QAAQ,CAAC,CACzB;eACF,MAAM,IAAI,MAAM,CAAC,OAAO,CAAC,EAAE;gBAC1B,WAAW,CAAC,MAAM,CAAC,GAAA,MAAA,CAAA,MAAA,CAAA;kBACjB,UAAU,EAAV;gBAAU,CAAA,EACP,WAAW,CAAC,MAAM,CAAC,CACvB;cACF;YACF;UACF;QACF;QAED;QACA,QAAQ,CAAC,OAAc,CAAC,GAAG,WAAW;OACvC,MAAM;QACL,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC;QACnB,QAAQ,CAAC,OAAc,CAAC,GAAG,WAAW,CAAC,OAAO,CAAC;MAChD;KACF,MAAM;MACL;MACA,QAAQ,CAAC,OAAc,CAAC,GAAG,WAAW,CAAC,OAAO,CAAC;IAChD;EACH,CAAC,CAAC;EAEF,OAAO;IACL,IAAI,EAAJ,IAAI;IACJ,SAAS,EAAT,SAAS;IACT,SAAS,EAAT,SAAS;IACT,OAAO,EAAP,OAAO;IACP,QAAQ,EAAR;GACD;AACH;AAEA,OAAM,SAAU,qBAAqB,CAAC,QAA0B,EAAE,OAAgB,EAAE,IAAU,EAAA;EAC5F,IAAM,aAAa,GAAG,WAAW,CAAC,OAAO,EAAE,IAAI,CAAC;EAChD,IAAI,CAAC,aAAa,EAAE;IAClB,OAAO,KAAK;GACb,MAAM,IAAI,aAAa,KAAK,QAAQ,EAAE;IACrC,IAAM,eAAe,GAAG,QAAQ,CAAC,OAAO,KAAK,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;IAExD;IACA;IACA,IAAI,UAAU,CAAC,eAAe,CAAC,IAAI,UAAU,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,IAAI,QAAQ,CAAC,eAAe,CAAC,GAAG,CAAC,EAAE;MACjG,OAAO,IAAI;KACZ,MAAM;MACL,OAAO,KAAK;IACb;EACF;EACD,OAAO,IAAI;AACb;AAEA,OAAM,SAAU,YAAY,CAC1B,QAA0B,EAC1B,IAAU,EACV,MAAe,EACf,MAAc,EAAA;EAEd,IAAM,kBAAkB,GAAqB,CAAA,CAAE;EAAC,2CAC9B,IAAI,CAAC,QAAQ,CAAC;IAAA;EAAA;IAAhC,oDAAkC;MAAA,IAAvB,GAAG;MACZ,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE;QACnB;QACA,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,sBAAsB,CAAC,GAAG,CAAC,CAAC;MAClD;;EACF;IAAA;EAAA;IAAA;EAAA;EAAA,4CAEmB,aAAa;IAAA;EAAA;IAAA;MAAA,IAAxB,OAAO;MACd,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE;QACtB;MACD;MAED,IAAM,UAAU,GAAG,QAAQ,CAAC,OAAO,CAAC;MACpC,IAAI,YAAY,CAAC,OAAO,CAAC,EAAE;QACzB,IAAM,WAAW,GAAG,+BAA+B,CAAC,OAAO,CAAC;QAE5D,IAAM,WAAW,GAAG,kBAAkB,CAAC,WAAW,CAAC;QACnD,IAAI,UAAU,CAAC,WAAW,CAAC,EAAE;UAC3B,IAAI,YAAY,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE;YAClC,IAAI,UAAU,CAAC,UAAU,CAAC,EAAE;cAC1B;cACA;cACA,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,gDAAgD,CAAC,WAAW,CAAC,CAAC;cACnF;YACD;UACF;SACF,MAAM;UACL;UACA,OAAO,GAAG,WAAW;UACrB,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,4BAA4B,CAAC,WAAW,CAAC,CAAC;QAChE;MACF;MAED,IAAI,OAAO,KAAK,OAAO,IAAI,IAAI,KAAK,KAAK,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE;QAC5D,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,wBAAwB,CAAC;QAC9C,OAAO,GAAG,KAAK;MAChB;MAED,IAAI,CAAC,qBAAqB,CAAC,QAAQ,EAAE,OAAO,EAAE,IAAI,CAAC,EAAE;QACnD;QACA,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,mBAAmB,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QACxD;MACD;MAED;MACA,IAAI,OAAO,KAAK,IAAI,IAAI,IAAI,KAAK,MAAM,EAAE;QACvC,IAAM,QAAQ,GAAG,WAAW,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QAC/C,IAAI,QAAQ,KAAA,IAAA,IAAR,QAAQ,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAR,QAAQ,CAAE,SAAS,EAAE;UACvB,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,sBAAsB,CAAC;UAC5C;QACD;MACF;MACD;MAEA,IAAI,OAAO,KAAK,KAAK,KAAK,MAAM,GAAG,MAAM,IAAI,QAAQ,GAAG,QAAQ,IAAI,QAAQ,CAAC,EAAE;QAC7E,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,aAAa,CAAC,UAAU,EAAE;UAAC,IAAI,EAAE,MAAM,IAAI,QAAQ;UAAE,MAAM,EAAE,QAAQ,IAAI;QAAQ,CAAC,CAAC,CAAC;QACzG;MACD;MAED,IACE,OAAO,KAAK,MAAM,IACjB,OAAO,KAAK,KAAK,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,UAAU,CAAE,IACrE,OAAO,KAAK,OAAO,IAAI,OAAO,CAAC,UAAU,CAAE,EAC5C;QACA,IAAI,UAAU,EAAE;UACd;UACC,kBAAkB,CAAC,OAAO,CAAS,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC,MAAM,CAC7D,UAAC,IAAwB,EAAE,QAA0B,EAAI;YACvD,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;cACzB,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,aAAa,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;aACvD,MAAM;cACL,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;YAC3C;YACD,OAAO,IAAI;UACb,CAAC,EACD,EAAE,CACH;QACF;OACF,MAAM;QACL,IAAI,OAAO,KAAK,OAAO,IAAI,UAAU,KAAK,IAAI,EAAE;UAC9C;UACA,kBAAkB,CAAC,OAAO,CAAC,GAAG,IAAI;SACnC,MAAM,IACL,CAAC,UAAU,CAAC,UAAU,CAAC,IACvB,CAAC,UAAU,CAAC,UAAU,CAAC,IACvB,CAAC,UAAU,CAAC,UAAU,CAAC,IACvB,CAAC,gBAAgB,CAAC,UAAU,CAAC,IAC7B,CAAC,WAAW,CAAC,UAAU,CAAC,EACxB;UACA,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,aAAa,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;UACxD;QACD;QAED,kBAAkB,CAAC,OAAc,CAAC,GAAG,cAAc,CAAC,UAAwB,EAAE,OAAO,EAAE,MAAM,CAAC;;IAC/F;IAvFH,uDAAmC;MAAA;MAAA,yBAmF7B;;EAKL;IAAA;EAAA;IAAA;EAAA;EACD,OAAO,kBAAkB;AAC3B;AAEA;;AAEG;AACH,OAAM,SAAU,iBAAiB,CAAC,QAA0B,EAAE,MAAc,EAAA;EAC1E,IAAM,kBAAkB,GAAqB,CAAA,CAAE;EAAC,4CAE1B,IAAI,CAAC,QAAQ,CAAC;IAAA;EAAA;IAApC,uDAAsC;MAAA,IAA3B,OAAO;MAChB,IAAM,aAAa,GAAG,cAAc,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE,OAAO,EAAE,MAAM,EAAE;QAAC,aAAa,EAAE;MAAI,CAAC,CAAC;MAC/F,kBAAkB,CAAC,OAAc,CAAC,GAAG,aAAa;;EACnD;IAAA;EAAA;IAAA;EAAA;EAED,OAAO,kBAAkB;AAC3B;AAEA,OAAM,SAAU,SAAS,CAAkB,QAA8B,EAAA;EACvE,IAAM,GAAG,GAAkB,EAAE;EAAC,4CACR,IAAI,CAAC,QAAQ,CAAC;IAAA;EAAA;IAApC,uDAAsC;MAAA,IAA3B,OAAO;MAChB,IAAI,eAAe,CAAC,QAAQ,EAAE,OAAO,CAAC,EAAE;QACtC,IAAM,UAAU,GAAG,QAAQ,CAAC,OAAO,CAAC;QACpC,IAAM,eAAe,GAAG,KAAK,CAAC,UAAU,CAAC;QAAC,4CACxB,eAAe;UAAA;QAAA;UAAjC,uDAAmC;YAAA,IAAxB,GAAG;YACZ,IAAI,UAAU,CAAC,GAAG,CAAC,EAAE;cACnB,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC;aACd,MAAM,IAAI,sBAAsB,CAAI,GAAG,CAAC,EAAE;cACzC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC;YACxB;;QACF;UAAA;QAAA;UAAA;QAAA;MACF;;EACF;IAAA;EAAA;IAAA;EAAA;EACD,OAAO,GAAG;AACZ;AAEA,OAAM,SAAU,OAAO,CACrB,OAAU,EACV,CAAuC,EACvC,OAAa,EAAA;EAEb,IAAI,CAAC,OAAO,EAAE;IACZ;;EACD,4CAEqB,IAAI,CAAC,OAAO,CAAC;IAAA;EAAA;IAAnC,uDAAqC;MAAA,IAA1B,OAAO;MAChB,IAAM,EAAE,GAAG,OAAO,CAAC,OAAO,CAAC;MAC3B,IAAI,OAAO,CAAC,EAAE,CAAC,EAAE;QAAA,4CACU,EAAe;UAAA;QAAA;UAAxC,uDAA0C;YAAA,IAA/B,UAAU;YACnB,CAAC,CAAC,IAAI,CAAC,OAAO,EAAE,UAAU,EAAE,OAAO,CAAC;;QACrC;UAAA;QAAA;UAAA;QAAA;OACF,MAAM;QACL,CAAC,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE,EAAE,OAAO,CAAC;MAC7B;;EACF;IAAA;EAAA;IAAA;EAAA;AACH;AAEA,OAAM,SAAU,MAAM,CACpB,OAAU,EACV,CAAyD,EACzD,IAAO,EACP,OAAa,EAAA;EAEb,IAAI,CAAC,OAAO,EAAE;IACZ,OAAO,IAAI;EACZ;EAED,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,UAAC,CAAC,EAAE,OAAO,EAAI;IACzC,IAAM,GAAG,GAAG,OAAO,CAAC,OAAO,CAAC;IAC5B,IAAI,OAAO,CAAC,GAAG,CAAC,EAAE;MAChB,OAAO,GAAG,CAAC,MAAM,CAAC,UAAC,EAAK,EAAE,UAAsB,EAAI;QAClD,OAAO,CAAC,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE,EAAE,UAAU,EAAE,OAAO,CAAC;MACjD,CAAC,EAAE,CAAC,CAAC;KACN,MAAM;MACL,OAAO,CAAC,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,EAAE,GAAG,EAAE,OAAO,CAAC;IACxC;EACH,CAAC,EAAE,IAAI,CAAC;AACV;AAEA;;AAEG;AACH,OAAM,SAAU,kBAAkB,CAAC,IAAU,EAAE,QAA0B,EAAA;EACvE,OAAO,IAAI,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,UAAC,OAAO,EAAE,OAAO,EAAI;IAChD,QAAQ,OAAO;MACb;MACA,KAAK,CAAC;MACN,KAAK,CAAC;MACN,KAAK,IAAI;MACT,KAAK,WAAW;MAChB,KAAK,GAAG;MACR,KAAK,EAAE;MACP,KAAK,EAAE;MACP,KAAK,OAAO;MACZ,KAAK,OAAO;MACZ,KAAK,KAAK;MACV,KAAK,MAAM;MACX,KAAK,MAAM;MACX,KAAK,OAAO;MACZ;MAEA,KAAK,QAAQ;MACb,KAAK,SAAS;MACd,KAAK,SAAS;MACd,KAAK,UAAU;MACf;MAEA;MACA,KAAK,IAAI;MACT,KAAK,KAAK;MACV,KAAK,KAAK;MACV;MAEA;MACA,KAAK,OAAO;QACV,OAAO,OAAO;MAEhB,KAAK,KAAK;QACR;QACA,IAAI,IAAI,KAAK,MAAM,IAAI,IAAI,KAAK,OAAO,EAAE;UACvC,OAAO,OAAO;QACf;MACH;MAEA,KAAK,MAAM;MACX,KAAK,GAAG;QAAE;UACR,IAAM,UAAU,GAAG,QAAQ,CAAC,OAAO,CAAC;UACpC,IAAI,OAAO,CAAC,UAAU,CAAC,IAAI,UAAU,CAAC,UAAU,CAAC,EAAE;YAAA,4CAC1B,KAAK,CAAC,UAAU,CAAC;cAAA;YAAA;cAAxC,uDAA0C;gBAAA,IAA/B,QAAQ;gBACjB,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE;kBACvB,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAA,CAAE,CAAC,CAAC;gBACpC;;YACF;cAAA;YAAA;cAAA;YAAA;UACF;UACD,OAAO,OAAO;QACf;MAED,KAAK,IAAI;QACP,IAAI,IAAI,KAAK,OAAO,EAAE;UACpB;UACA,OAAO,OAAO;QACf;MACH;MAEA;MACA,KAAK,KAAK;MACV,KAAK,IAAI;MACT,KAAK,MAAM;MACX,KAAK,OAAO;MACZ,KAAK,WAAW;MAChB,KAAK,aAAa;MAClB,KAAK,UAAU;MACf,KAAK,WAAW;QAAE;UAChB;UACA;UAEA,IAAM,SAAQ,GAAG,WAAW,CAAS,QAAQ,CAAC,OAAO,CAAC,CAAC;UACvD,IAAI,SAAQ,IAAI,CAAC,SAAQ,CAAC,SAAS,EAAE;YACnC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,SAAQ,EAAE,CAAA,CAAE,CAAC,CAAC;UACpC;UACD,OAAO,OAAO;;IACf;EAEL,CAAC,EAAE,EAAE,CAAC;AACR","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { array, isArray } from 'vega-util';\nimport { isArgmaxDef, isArgminDef } from './aggregate';\nimport { isBinned, isBinning } from './bin';\nimport { ANGLE, CHANNELS, COLOR, DESCRIPTION, DETAIL, FILL, FILLOPACITY, getMainChannelFromOffsetChannel, getOffsetScaleChannel, HREF, isChannel, isNonPositionScaleChannel, isSecondaryRangeChannel, isXorY, isXorYOffset, KEY, LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, OPACITY, ORDER, RADIUS, RADIUS2, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH, supportMark, TEXT, THETA, THETA2, TOOLTIP, UNIT_CHANNELS, URL, X, X2, XOFFSET, Y, Y2, YOFFSET } from './channel';\nimport { binRequiresRange, getFieldDef, getGuide, hasConditionalFieldDef, hasConditionalFieldOrDatumDef, initChannelDef, initFieldDef, isConditionalDef, isDatumDef, isFieldDef, isTypedFieldDef, isValueDef, title, vgField } from './channeldef';\nimport * as log from './log';\nimport { isContinuous, isDiscrete, QUANTITATIVE, TEMPORAL } from './type';\nimport { keys, some } from './util';\nimport { isSignalRef } from './vega.schema';\nexport function channelHasField(encoding, channel) {\n    const channelDef = encoding && encoding[channel];\n    if (channelDef) {\n        if (isArray(channelDef)) {\n            return some(channelDef, fieldDef => !!fieldDef.field);\n        }\n        else {\n            return isFieldDef(channelDef) || hasConditionalFieldDef(channelDef);\n        }\n    }\n    return false;\n}\nexport function channelHasFieldOrDatum(encoding, channel) {\n    const channelDef = encoding && encoding[channel];\n    if (channelDef) {\n        if (isArray(channelDef)) {\n            return some(channelDef, fieldDef => !!fieldDef.field);\n        }\n        else {\n            return isFieldDef(channelDef) || isDatumDef(channelDef) || hasConditionalFieldOrDatumDef(channelDef);\n        }\n    }\n    return false;\n}\nexport function channelHasNestedOffsetScale(encoding, channel) {\n    if (isXorY(channel)) {\n        const fieldDef = encoding[channel];\n        if ((isFieldDef(fieldDef) || isDatumDef(fieldDef)) && isDiscrete(fieldDef.type)) {\n            const offsetChannel = getOffsetScaleChannel(channel);\n            return channelHasFieldOrDatum(encoding, offsetChannel);\n        }\n    }\n    return false;\n}\nexport function isAggregate(encoding) {\n    return some(CHANNELS, channel => {\n        if (channelHasField(encoding, channel)) {\n            const channelDef = encoding[channel];\n            if (isArray(channelDef)) {\n                return some(channelDef, fieldDef => !!fieldDef.aggregate);\n            }\n            else {\n                const fieldDef = getFieldDef(channelDef);\n                return fieldDef && !!fieldDef.aggregate;\n            }\n        }\n        return false;\n    });\n}\nexport function extractTransformsFromEncoding(oldEncoding, config) {\n    const groupby = [];\n    const bins = [];\n    const timeUnits = [];\n    const aggregate = [];\n    const encoding = {};\n    forEach(oldEncoding, (channelDef, channel) => {\n        // Extract potential embedded transformations along with remaining properties\n        if (isFieldDef(channelDef)) {\n            const { field, aggregate: aggOp, bin, timeUnit } = channelDef, remaining = __rest(channelDef, [\"field\", \"aggregate\", \"bin\", \"timeUnit\"]);\n            if (aggOp || timeUnit || bin) {\n                const guide = getGuide(channelDef);\n                const isTitleDefined = guide === null || guide === void 0 ? void 0 : guide.title;\n                let newField = vgField(channelDef, { forAs: true });\n                const newFieldDef = Object.assign(Object.assign(Object.assign({}, (isTitleDefined ? [] : { title: title(channelDef, config, { allowDisabling: true }) })), remaining), { \n                    // Always overwrite field\n                    field: newField });\n                if (aggOp) {\n                    let op;\n                    if (isArgmaxDef(aggOp)) {\n                        op = 'argmax';\n                        newField = vgField({ op: 'argmax', field: aggOp.argmax }, { forAs: true });\n                        newFieldDef.field = `${newField}.${field}`;\n                    }\n                    else if (isArgminDef(aggOp)) {\n                        op = 'argmin';\n                        newField = vgField({ op: 'argmin', field: aggOp.argmin }, { forAs: true });\n                        newFieldDef.field = `${newField}.${field}`;\n                    }\n                    else if (aggOp !== 'boxplot' && aggOp !== 'errorbar' && aggOp !== 'errorband') {\n                        op = aggOp;\n                    }\n                    if (op) {\n                        const aggregateEntry = {\n                            op,\n                            as: newField\n                        };\n                        if (field) {\n                            aggregateEntry.field = field;\n                        }\n                        aggregate.push(aggregateEntry);\n                    }\n                }\n                else {\n                    groupby.push(newField);\n                    if (isTypedFieldDef(channelDef) && isBinning(bin)) {\n                        bins.push({ bin, field, as: newField });\n                        // Add additional groupbys for range and end of bins\n                        groupby.push(vgField(channelDef, { binSuffix: 'end' }));\n                        if (binRequiresRange(channelDef, channel)) {\n                            groupby.push(vgField(channelDef, { binSuffix: 'range' }));\n                        }\n                        // Create accompanying 'x2' or 'y2' field if channel is 'x' or 'y' respectively\n                        if (isXorY(channel)) {\n                            const secondaryChannel = {\n                                field: `${newField}_end`\n                            };\n                            encoding[`${channel}2`] = secondaryChannel;\n                        }\n                        newFieldDef.bin = 'binned';\n                        if (!isSecondaryRangeChannel(channel)) {\n                            newFieldDef['type'] = QUANTITATIVE;\n                        }\n                    }\n                    else if (timeUnit) {\n                        timeUnits.push({\n                            timeUnit,\n                            field,\n                            as: newField\n                        });\n                        // define the format type for later compilation\n                        const formatType = isTypedFieldDef(channelDef) && channelDef.type !== TEMPORAL && 'time';\n                        if (formatType) {\n                            if (channel === TEXT || channel === TOOLTIP) {\n                                newFieldDef['formatType'] = formatType;\n                            }\n                            else if (isNonPositionScaleChannel(channel)) {\n                                newFieldDef['legend'] = Object.assign({ formatType }, newFieldDef['legend']);\n                            }\n                            else if (isXorY(channel)) {\n                                newFieldDef['axis'] = Object.assign({ formatType }, newFieldDef['axis']);\n                            }\n                        }\n                    }\n                }\n                // now the field should refer to post-transformed field instead\n                encoding[channel] = newFieldDef;\n            }\n            else {\n                groupby.push(field);\n                encoding[channel] = oldEncoding[channel];\n            }\n        }\n        else {\n            // For value def / signal ref / datum def, just copy\n            encoding[channel] = oldEncoding[channel];\n        }\n    });\n    return {\n        bins,\n        timeUnits,\n        aggregate,\n        groupby,\n        encoding\n    };\n}\nexport function markChannelCompatible(encoding, channel, mark) {\n    const markSupported = supportMark(channel, mark);\n    if (!markSupported) {\n        return false;\n    }\n    else if (markSupported === 'binned') {\n        const primaryFieldDef = encoding[channel === X2 ? X : Y];\n        // circle, point, square and tick only support x2/y2 when their corresponding x/y fieldDef\n        // has \"binned\" data and thus need x2/y2 to specify the bin-end field.\n        if (isFieldDef(primaryFieldDef) && isFieldDef(encoding[channel]) && isBinned(primaryFieldDef.bin)) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    return true;\n}\nexport function initEncoding(encoding, mark, filled, config) {\n    const normalizedEncoding = {};\n    for (const key of keys(encoding)) {\n        if (!isChannel(key)) {\n            // Drop invalid channel\n            log.warn(log.message.invalidEncodingChannel(key));\n        }\n    }\n    for (let channel of UNIT_CHANNELS) {\n        if (!encoding[channel]) {\n            continue;\n        }\n        const channelDef = encoding[channel];\n        if (isXorYOffset(channel)) {\n            const mainChannel = getMainChannelFromOffsetChannel(channel);\n            const positionDef = normalizedEncoding[mainChannel];\n            if (isFieldDef(positionDef)) {\n                if (isContinuous(positionDef.type)) {\n                    if (isFieldDef(channelDef)) {\n                        // TODO: nesting continuous field instead continuous field should\n                        // behave like offsetting the data in data domain\n                        log.warn(log.message.offsetNestedInsideContinuousPositionScaleDropped(mainChannel));\n                        continue;\n                    }\n                }\n            }\n            else {\n                // no x/y, replace it with main channel\n                channel = mainChannel;\n                log.warn(log.message.replaceOffsetWithMainChannel(mainChannel));\n            }\n        }\n        if (channel === 'angle' && mark === 'arc' && !encoding.theta) {\n            log.warn(log.message.REPLACE_ANGLE_WITH_THETA);\n            channel = THETA;\n        }\n        if (!markChannelCompatible(encoding, channel, mark)) {\n            // Drop unsupported channel\n            log.warn(log.message.incompatibleChannel(channel, mark));\n            continue;\n        }\n        // Drop line's size if the field is aggregated.\n        if (channel === SIZE && mark === 'line') {\n            const fieldDef = getFieldDef(encoding[channel]);\n            if (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.aggregate) {\n                log.warn(log.message.LINE_WITH_VARYING_SIZE);\n                continue;\n            }\n        }\n        // Drop color if either fill or stroke is specified\n        if (channel === COLOR && (filled ? 'fill' in encoding : 'stroke' in encoding)) {\n            log.warn(log.message.droppingColor('encoding', { fill: 'fill' in encoding, stroke: 'stroke' in encoding }));\n            continue;\n        }\n        if (channel === DETAIL ||\n            (channel === ORDER && !isArray(channelDef) && !isValueDef(channelDef)) ||\n            (channel === TOOLTIP && isArray(channelDef))) {\n            if (channelDef) {\n                // Array of fieldDefs for detail channel (or production rule)\n                normalizedEncoding[channel] = array(channelDef).reduce((defs, fieldDef) => {\n                    if (!isFieldDef(fieldDef)) {\n                        log.warn(log.message.emptyFieldDef(fieldDef, channel));\n                    }\n                    else {\n                        defs.push(initFieldDef(fieldDef, channel));\n                    }\n                    return defs;\n                }, []);\n            }\n        }\n        else {\n            if (channel === TOOLTIP && channelDef === null) {\n                // Preserve null so we can use it to disable tooltip\n                normalizedEncoding[channel] = null;\n            }\n            else if (!isFieldDef(channelDef) &&\n                !isDatumDef(channelDef) &&\n                !isValueDef(channelDef) &&\n                !isConditionalDef(channelDef) &&\n                !isSignalRef(channelDef)) {\n                log.warn(log.message.emptyFieldDef(channelDef, channel));\n                continue;\n            }\n            normalizedEncoding[channel] = initChannelDef(channelDef, channel, config);\n        }\n    }\n    return normalizedEncoding;\n}\n/**\n * For composite marks, we have to call initChannelDef during init so we can infer types earlier.\n */\nexport function normalizeEncoding(encoding, config) {\n    const normalizedEncoding = {};\n    for (const channel of keys(encoding)) {\n        const newChannelDef = initChannelDef(encoding[channel], channel, config, { compositeMark: true });\n        normalizedEncoding[channel] = newChannelDef;\n    }\n    return normalizedEncoding;\n}\nexport function fieldDefs(encoding) {\n    const arr = [];\n    for (const channel of keys(encoding)) {\n        if (channelHasField(encoding, channel)) {\n            const channelDef = encoding[channel];\n            const channelDefArray = array(channelDef);\n            for (const def of channelDefArray) {\n                if (isFieldDef(def)) {\n                    arr.push(def);\n                }\n                else if (hasConditionalFieldDef(def)) {\n                    arr.push(def.condition);\n                }\n            }\n        }\n    }\n    return arr;\n}\nexport function forEach(mapping, f, thisArg) {\n    if (!mapping) {\n        return;\n    }\n    for (const channel of keys(mapping)) {\n        const el = mapping[channel];\n        if (isArray(el)) {\n            for (const channelDef of el) {\n                f.call(thisArg, channelDef, channel);\n            }\n        }\n        else {\n            f.call(thisArg, el, channel);\n        }\n    }\n}\nexport function reduce(mapping, f, init, thisArg) {\n    if (!mapping) {\n        return init;\n    }\n    return keys(mapping).reduce((r, channel) => {\n        const map = mapping[channel];\n        if (isArray(map)) {\n            return map.reduce((r1, channelDef) => {\n                return f.call(thisArg, r1, channelDef, channel);\n            }, r);\n        }\n        else {\n            return f.call(thisArg, r, map, channel);\n        }\n    }, init);\n}\n/**\n * Returns list of path grouping fields for the given encoding\n */\nexport function pathGroupingFields(mark, encoding) {\n    return keys(encoding).reduce((details, channel) => {\n        switch (channel) {\n            // x, y, x2, y2, lat, long, lat1, long2, order, tooltip, href, aria label, cursor should not cause lines to group\n            case X:\n            case Y:\n            case HREF:\n            case DESCRIPTION:\n            case URL:\n            case X2:\n            case Y2:\n            case XOFFSET:\n            case YOFFSET:\n            case THETA:\n            case THETA2:\n            case RADIUS:\n            case RADIUS2:\n            // falls through\n            case LATITUDE:\n            case LONGITUDE:\n            case LATITUDE2:\n            case LONGITUDE2:\n            // TODO: case 'cursor':\n            // text, shape, shouldn't be a part of line/trail/area [falls through]\n            case TEXT:\n            case SHAPE:\n            case ANGLE:\n            // falls through\n            // tooltip fields should not be added to group by [falls through]\n            case TOOLTIP:\n                return details;\n            case ORDER:\n                // order should not group line / trail\n                if (mark === 'line' || mark === 'trail') {\n                    return details;\n                }\n            // but order should group area for stacking (falls through)\n            case DETAIL:\n            case KEY: {\n                const channelDef = encoding[channel];\n                if (isArray(channelDef) || isFieldDef(channelDef)) {\n                    for (const fieldDef of array(channelDef)) {\n                        if (!fieldDef.aggregate) {\n                            details.push(vgField(fieldDef, {}));\n                        }\n                    }\n                }\n                return details;\n            }\n            case SIZE:\n                if (mark === 'trail') {\n                    // For trail, size should not group trail lines.\n                    return details;\n                }\n            // For line, size should group lines.\n            // falls through\n            case COLOR:\n            case FILL:\n            case STROKE:\n            case OPACITY:\n            case FILLOPACITY:\n            case STROKEOPACITY:\n            case STROKEDASH:\n            case STROKEWIDTH: {\n                // TODO strokeDashOffset:\n                // falls through\n                const fieldDef = getFieldDef(encoding[channel]);\n                if (fieldDef && !fieldDef.aggregate) {\n                    details.push(vgField(fieldDef, {}));\n                }\n                return details;\n            }\n        }\n    }, []);\n}\n//# sourceMappingURL=encoding.js.map"]},"metadata":{},"sourceType":"module"}