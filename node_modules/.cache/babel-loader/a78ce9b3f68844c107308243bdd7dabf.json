{"ast":null,"code":"import { isFunction, isString } from 'vega-util';\nimport { isCountingAggregateOp } from '../../../aggregate';\nimport { isBinned, isBinning } from '../../../bin';\nimport { getMainRangeChannel, X, X2, Y2 } from '../../../channel';\nimport { binRequiresRange, getBandPosition, isDatumDef, isFieldDef, isFieldOrDatumDef, isTypedFieldDef, isValueDef, vgField } from '../../../channeldef';\nimport { dateTimeToExpr, isDateTime } from '../../../datetime';\nimport { isExprRef } from '../../../expr';\nimport * as log from '../../../log';\nimport { isPathMark } from '../../../mark';\nimport { fieldValidPredicate } from '../../../predicate';\nimport { hasDiscreteDomain, isContinuousToContinuous } from '../../../scale';\nimport { TEMPORAL } from '../../../type';\nimport { contains, stringify } from '../../../util';\nimport { isSignalRef } from '../../../vega.schema';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nexport function midPointRefWithPositionInvalidTest(params) {\n  var channel = params.channel,\n    channelDef = params.channelDef,\n    markDef = params.markDef,\n    scale = params.scale,\n    config = params.config;\n  var ref = midPoint(params);\n  // Wrap to check if the positional value is invalid, if so, plot the point on the min value\n  if (\n  // Only this for field def without counting aggregate (as count wouldn't be null)\n  isFieldDef(channelDef) && !isCountingAggregateOp(channelDef.aggregate) &&\n  // and only for continuous scale\n  scale && isContinuousToContinuous(scale.get('type'))) {\n    return wrapPositionInvalidTest({\n      fieldDef: channelDef,\n      channel: channel,\n      markDef: markDef,\n      ref: ref,\n      config: config\n    });\n  }\n  return ref;\n}\nexport function wrapPositionInvalidTest(_ref) {\n  var fieldDef = _ref.fieldDef,\n    channel = _ref.channel,\n    markDef = _ref.markDef,\n    ref = _ref.ref,\n    config = _ref.config;\n  if (isPathMark(markDef.type)) {\n    // path mark already use defined to skip points, no need to do it here.\n    return ref;\n  }\n  var invalid = getMarkPropOrConfig('invalid', markDef, config);\n  if (invalid === null) {\n    // if there is no invalid filter, don't do the invalid test\n    return [fieldInvalidTestValueRef(fieldDef, channel), ref];\n  }\n  return ref;\n}\nexport function fieldInvalidTestValueRef(fieldDef, channel) {\n  var test = fieldInvalidPredicate(fieldDef, true);\n  var mainChannel = getMainRangeChannel(channel); // we can cast here as the output can't be other things.\n  var zeroValueRef = mainChannel === 'y' ? {\n    field: {\n      group: 'height'\n    }\n  } :\n  // x / angle / radius can all use 0\n  {\n    value: 0\n  };\n  return Object.assign({\n    test: test\n  }, zeroValueRef);\n}\nexport function fieldInvalidPredicate(field) {\n  var invalid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return fieldValidPredicate(isString(field) ? field : vgField(field, {\n    expr: 'datum'\n  }), !invalid);\n}\nexport function datumDefToExpr(datumDef) {\n  var datum = datumDef.datum;\n  if (isDateTime(datum)) {\n    return dateTimeToExpr(datum);\n  }\n  return \"\".concat(stringify(datum));\n}\nexport function valueRefForFieldOrDatumDef(fieldDef, scaleName, opt, encode) {\n  var ref = {};\n  if (scaleName) {\n    ref.scale = scaleName;\n  }\n  if (isDatumDef(fieldDef)) {\n    var datum = fieldDef.datum;\n    if (isDateTime(datum)) {\n      ref.signal = dateTimeToExpr(datum);\n    } else if (isSignalRef(datum)) {\n      ref.signal = datum.signal;\n    } else if (isExprRef(datum)) {\n      ref.signal = datum.expr;\n    } else {\n      ref.value = datum;\n    }\n  } else {\n    ref.field = vgField(fieldDef, opt);\n  }\n  if (encode) {\n    var offset = encode.offset,\n      band = encode.band;\n    if (offset) {\n      ref.offset = offset;\n    }\n    if (band) {\n      ref.band = band;\n    }\n  }\n  return ref;\n}\n/**\n * Signal that returns the middle of a bin from start and end field. Should only be used with x and y.\n */\nexport function interpolatedSignalRef(_ref2) {\n  var scaleName = _ref2.scaleName,\n    fieldOrDatumDef = _ref2.fieldOrDatumDef,\n    fieldOrDatumDef2 = _ref2.fieldOrDatumDef2,\n    offset = _ref2.offset,\n    startSuffix = _ref2.startSuffix,\n    _ref2$bandPosition = _ref2.bandPosition,\n    bandPosition = _ref2$bandPosition === void 0 ? 0.5 : _ref2$bandPosition;\n  var expr = 0 < bandPosition && bandPosition < 1 ? 'datum' : undefined;\n  var start = vgField(fieldOrDatumDef, {\n    expr: expr,\n    suffix: startSuffix\n  });\n  var end = fieldOrDatumDef2 !== undefined ? vgField(fieldOrDatumDef2, {\n    expr: expr\n  }) : vgField(fieldOrDatumDef, {\n    suffix: 'end',\n    expr: expr\n  });\n  var ref = {};\n  if (bandPosition === 0 || bandPosition === 1) {\n    ref.scale = scaleName;\n    var val = bandPosition === 0 ? start : end;\n    ref.field = val;\n  } else {\n    var datum = isSignalRef(bandPosition) ? \"\".concat(bandPosition.signal, \" * \").concat(start, \" + (1-\").concat(bandPosition.signal, \") * \").concat(end) : \"\".concat(bandPosition, \" * \").concat(start, \" + \").concat(1 - bandPosition, \" * \").concat(end);\n    ref.signal = \"scale(\\\"\".concat(scaleName, \"\\\", \").concat(datum, \")\");\n  }\n  if (offset) {\n    ref.offset = offset;\n  }\n  return ref;\n}\n/**\n * @returns {VgValueRef} Value Ref for xc / yc or mid point for other channels.\n */\nexport function midPoint(_ref3) {\n  var channel = _ref3.channel,\n    channelDef = _ref3.channelDef,\n    channel2Def = _ref3.channel2Def,\n    markDef = _ref3.markDef,\n    config = _ref3.config,\n    scaleName = _ref3.scaleName,\n    scale = _ref3.scale,\n    stack = _ref3.stack,\n    offset = _ref3.offset,\n    defaultRef = _ref3.defaultRef,\n    bandPosition = _ref3.bandPosition;\n  var _a;\n  // TODO: datum support\n  if (channelDef) {\n    /* istanbul ignore else */\n    if (isFieldOrDatumDef(channelDef)) {\n      var scaleType = scale === null || scale === void 0 ? void 0 : scale.get('type');\n      if (isTypedFieldDef(channelDef)) {\n        bandPosition !== null && bandPosition !== void 0 ? bandPosition : bandPosition = getBandPosition({\n          fieldDef: channelDef,\n          fieldDef2: channel2Def,\n          markDef: markDef,\n          config: config\n        });\n        var bin = channelDef.bin,\n          timeUnit = channelDef.timeUnit,\n          type = channelDef.type;\n        if (isBinning(bin) || bandPosition && timeUnit && type === TEMPORAL) {\n          // Use middle only for x an y to place marks in the center between start and end of the bin range.\n          // We do not use the mid point for other channels (e.g. size) so that properties of legends and marks match.\n          if (stack === null || stack === void 0 ? void 0 : stack.impute) {\n            // For stack, we computed bin_mid so we can impute.\n            return valueRefForFieldOrDatumDef(channelDef, scaleName, {\n              binSuffix: 'mid'\n            }, {\n              offset: offset\n            });\n          }\n          if (bandPosition && !hasDiscreteDomain(scaleType)) {\n            // if band = 0, no need to call interpolation\n            // For non-stack, we can just calculate bin mid on the fly using signal.\n            return interpolatedSignalRef({\n              scaleName: scaleName,\n              fieldOrDatumDef: channelDef,\n              bandPosition: bandPosition,\n              offset: offset\n            });\n          }\n          return valueRefForFieldOrDatumDef(channelDef, scaleName, binRequiresRange(channelDef, channel) ? {\n            binSuffix: 'range'\n          } : {}, {\n            offset: offset\n          });\n        } else if (isBinned(bin)) {\n          if (isFieldDef(channel2Def)) {\n            return interpolatedSignalRef({\n              scaleName: scaleName,\n              fieldOrDatumDef: channelDef,\n              fieldOrDatumDef2: channel2Def,\n              bandPosition: bandPosition,\n              offset: offset\n            });\n          } else {\n            var channel2 = channel === X ? X2 : Y2;\n            log.warn(log.message.channelRequiredForBinned(channel2));\n          }\n        }\n      }\n      return valueRefForFieldOrDatumDef(channelDef, scaleName, hasDiscreteDomain(scaleType) ? {\n        binSuffix: 'range'\n      } : {},\n      // no need for bin suffix if there is no scale\n      {\n        offset: offset,\n        // For band, to get mid point, need to offset by half of the band\n        band: scaleType === 'band' ? (_a = bandPosition !== null && bandPosition !== void 0 ? bandPosition : channelDef.bandPosition) !== null && _a !== void 0 ? _a : 0.5 : undefined\n      });\n    } else if (isValueDef(channelDef)) {\n      var value = channelDef.value;\n      var offsetMixins = offset ? {\n        offset: offset\n      } : {};\n      return Object.assign(Object.assign({}, widthHeightValueOrSignalRef(channel, value)), offsetMixins);\n    }\n    // If channelDef is neither field def or value def, it's a condition-only def.\n    // In such case, we will use default ref.\n  }\n\n  if (isFunction(defaultRef)) {\n    defaultRef = defaultRef();\n  }\n  if (defaultRef) {\n    // for non-position, ref could be undefined.\n    return Object.assign(Object.assign({}, defaultRef), offset ? {\n      offset: offset\n    } : {});\n  }\n  return defaultRef;\n}\n/**\n * Convert special \"width\" and \"height\" values in Vega-Lite into Vega value ref.\n */\nexport function widthHeightValueOrSignalRef(channel, value) {\n  if (contains(['x', 'x2'], channel) && value === 'width') {\n    return {\n      field: {\n        group: 'width'\n      }\n    };\n  } else if (contains(['y', 'y2'], channel) && value === 'height') {\n    return {\n      field: {\n        group: 'height'\n      }\n    };\n  }\n  return signalOrValueRef(value);\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/valueref.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isFunction, isString } from 'vega-util';\nimport { isCountingAggregateOp } from '../../../aggregate';\nimport { isBinned, isBinning } from '../../../bin';\nimport { getMainRangeChannel, X, X2, Y2 } from '../../../channel';\nimport { binRequiresRange, getBandPosition, isDatumDef, isFieldDef, isFieldOrDatumDef, isTypedFieldDef, isValueDef, vgField } from '../../../channeldef';\nimport { dateTimeToExpr, isDateTime } from '../../../datetime';\nimport { isExprRef } from '../../../expr';\nimport * as log from '../../../log';\nimport { isPathMark } from '../../../mark';\nimport { fieldValidPredicate } from '../../../predicate';\nimport { hasDiscreteDomain, isContinuousToContinuous } from '../../../scale';\nimport { TEMPORAL } from '../../../type';\nimport { contains, stringify } from '../../../util';\nimport { isSignalRef } from '../../../vega.schema';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nexport function midPointRefWithPositionInvalidTest(params) {\n    const { channel, channelDef, markDef, scale, config } = params;\n    const ref = midPoint(params);\n    // Wrap to check if the positional value is invalid, if so, plot the point on the min value\n    if (\n    // Only this for field def without counting aggregate (as count wouldn't be null)\n    isFieldDef(channelDef) &&\n        !isCountingAggregateOp(channelDef.aggregate) &&\n        // and only for continuous scale\n        scale &&\n        isContinuousToContinuous(scale.get('type'))) {\n        return wrapPositionInvalidTest({\n            fieldDef: channelDef,\n            channel,\n            markDef,\n            ref,\n            config\n        });\n    }\n    return ref;\n}\nexport function wrapPositionInvalidTest({ fieldDef, channel, markDef, ref, config }) {\n    if (isPathMark(markDef.type)) {\n        // path mark already use defined to skip points, no need to do it here.\n        return ref;\n    }\n    const invalid = getMarkPropOrConfig('invalid', markDef, config);\n    if (invalid === null) {\n        // if there is no invalid filter, don't do the invalid test\n        return [fieldInvalidTestValueRef(fieldDef, channel), ref];\n    }\n    return ref;\n}\nexport function fieldInvalidTestValueRef(fieldDef, channel) {\n    const test = fieldInvalidPredicate(fieldDef, true);\n    const mainChannel = getMainRangeChannel(channel); // we can cast here as the output can't be other things.\n    const zeroValueRef = mainChannel === 'y'\n        ? { field: { group: 'height' } }\n        : // x / angle / radius can all use 0\n            { value: 0 };\n    return Object.assign({ test }, zeroValueRef);\n}\nexport function fieldInvalidPredicate(field, invalid = true) {\n    return fieldValidPredicate(isString(field) ? field : vgField(field, { expr: 'datum' }), !invalid);\n}\nexport function datumDefToExpr(datumDef) {\n    const { datum } = datumDef;\n    if (isDateTime(datum)) {\n        return dateTimeToExpr(datum);\n    }\n    return `${stringify(datum)}`;\n}\nexport function valueRefForFieldOrDatumDef(fieldDef, scaleName, opt, encode) {\n    const ref = {};\n    if (scaleName) {\n        ref.scale = scaleName;\n    }\n    if (isDatumDef(fieldDef)) {\n        const { datum } = fieldDef;\n        if (isDateTime(datum)) {\n            ref.signal = dateTimeToExpr(datum);\n        }\n        else if (isSignalRef(datum)) {\n            ref.signal = datum.signal;\n        }\n        else if (isExprRef(datum)) {\n            ref.signal = datum.expr;\n        }\n        else {\n            ref.value = datum;\n        }\n    }\n    else {\n        ref.field = vgField(fieldDef, opt);\n    }\n    if (encode) {\n        const { offset, band } = encode;\n        if (offset) {\n            ref.offset = offset;\n        }\n        if (band) {\n            ref.band = band;\n        }\n    }\n    return ref;\n}\n/**\n * Signal that returns the middle of a bin from start and end field. Should only be used with x and y.\n */\nexport function interpolatedSignalRef({ scaleName, fieldOrDatumDef, fieldOrDatumDef2, offset, startSuffix, bandPosition = 0.5 }) {\n    const expr = 0 < bandPosition && bandPosition < 1 ? 'datum' : undefined;\n    const start = vgField(fieldOrDatumDef, { expr, suffix: startSuffix });\n    const end = fieldOrDatumDef2 !== undefined\n        ? vgField(fieldOrDatumDef2, { expr })\n        : vgField(fieldOrDatumDef, { suffix: 'end', expr });\n    const ref = {};\n    if (bandPosition === 0 || bandPosition === 1) {\n        ref.scale = scaleName;\n        const val = bandPosition === 0 ? start : end;\n        ref.field = val;\n    }\n    else {\n        const datum = isSignalRef(bandPosition)\n            ? `${bandPosition.signal} * ${start} + (1-${bandPosition.signal}) * ${end}`\n            : `${bandPosition} * ${start} + ${1 - bandPosition} * ${end}`;\n        ref.signal = `scale(\"${scaleName}\", ${datum})`;\n    }\n    if (offset) {\n        ref.offset = offset;\n    }\n    return ref;\n}\n/**\n * @returns {VgValueRef} Value Ref for xc / yc or mid point for other channels.\n */\nexport function midPoint({ channel, channelDef, channel2Def, markDef, config, scaleName, scale, stack, offset, defaultRef, bandPosition }) {\n    var _a;\n    // TODO: datum support\n    if (channelDef) {\n        /* istanbul ignore else */\n        if (isFieldOrDatumDef(channelDef)) {\n            const scaleType = scale === null || scale === void 0 ? void 0 : scale.get('type');\n            if (isTypedFieldDef(channelDef)) {\n                bandPosition !== null && bandPosition !== void 0 ? bandPosition : (bandPosition = getBandPosition({\n                    fieldDef: channelDef,\n                    fieldDef2: channel2Def,\n                    markDef,\n                    config\n                }));\n                const { bin, timeUnit, type } = channelDef;\n                if (isBinning(bin) || (bandPosition && timeUnit && type === TEMPORAL)) {\n                    // Use middle only for x an y to place marks in the center between start and end of the bin range.\n                    // We do not use the mid point for other channels (e.g. size) so that properties of legends and marks match.\n                    if (stack === null || stack === void 0 ? void 0 : stack.impute) {\n                        // For stack, we computed bin_mid so we can impute.\n                        return valueRefForFieldOrDatumDef(channelDef, scaleName, { binSuffix: 'mid' }, { offset });\n                    }\n                    if (bandPosition && !hasDiscreteDomain(scaleType)) {\n                        // if band = 0, no need to call interpolation\n                        // For non-stack, we can just calculate bin mid on the fly using signal.\n                        return interpolatedSignalRef({ scaleName, fieldOrDatumDef: channelDef, bandPosition, offset });\n                    }\n                    return valueRefForFieldOrDatumDef(channelDef, scaleName, binRequiresRange(channelDef, channel) ? { binSuffix: 'range' } : {}, {\n                        offset\n                    });\n                }\n                else if (isBinned(bin)) {\n                    if (isFieldDef(channel2Def)) {\n                        return interpolatedSignalRef({\n                            scaleName,\n                            fieldOrDatumDef: channelDef,\n                            fieldOrDatumDef2: channel2Def,\n                            bandPosition,\n                            offset\n                        });\n                    }\n                    else {\n                        const channel2 = channel === X ? X2 : Y2;\n                        log.warn(log.message.channelRequiredForBinned(channel2));\n                    }\n                }\n            }\n            return valueRefForFieldOrDatumDef(channelDef, scaleName, hasDiscreteDomain(scaleType) ? { binSuffix: 'range' } : {}, // no need for bin suffix if there is no scale\n            {\n                offset,\n                // For band, to get mid point, need to offset by half of the band\n                band: scaleType === 'band' ? (_a = bandPosition !== null && bandPosition !== void 0 ? bandPosition : channelDef.bandPosition) !== null && _a !== void 0 ? _a : 0.5 : undefined\n            });\n        }\n        else if (isValueDef(channelDef)) {\n            const value = channelDef.value;\n            const offsetMixins = offset ? { offset } : {};\n            return Object.assign(Object.assign({}, widthHeightValueOrSignalRef(channel, value)), offsetMixins);\n        }\n        // If channelDef is neither field def or value def, it's a condition-only def.\n        // In such case, we will use default ref.\n    }\n    if (isFunction(defaultRef)) {\n        defaultRef = defaultRef();\n    }\n    if (defaultRef) {\n        // for non-position, ref could be undefined.\n        return Object.assign(Object.assign({}, defaultRef), (offset ? { offset } : {}));\n    }\n    return defaultRef;\n}\n/**\n * Convert special \"width\" and \"height\" values in Vega-Lite into Vega value ref.\n */\nexport function widthHeightValueOrSignalRef(channel, value) {\n    if (contains(['x', 'x2'], channel) && value === 'width') {\n        return { field: { group: 'width' } };\n    }\n    else if (contains(['y', 'y2'], channel) && value === 'height') {\n        return { field: { group: 'height' } };\n    }\n    return signalOrValueRef(value);\n}\n//# sourceMappingURL=valueref.js.map"]},"metadata":{},"sourceType":"module"}