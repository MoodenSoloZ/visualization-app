{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _classCallCheck = require(\"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Bezier = void 0;\n// math-inlining.\nvar abs = Math.abs,\n  cos = Math.cos,\n  sin = Math.sin,\n  acos = Math.acos,\n  atan2 = Math.atan2,\n  sqrt = Math.sqrt,\n  pow = Math.pow; // cube root function yielding real roots\n\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n} // trig constants\n\nvar pi = Math.PI,\n  tau = 2 * pi,\n  quart = pi / 2,\n  // float precision significant decimal\n  epsilon = 0.000001,\n  // extremas used in bbox calculation and similar algorithms\n  nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n  // a zero coordinate, which is surprisingly useful\n  ZERO = {\n    x: 0,\n    y: 0,\n    z: 0\n  }; // Bezier utility functions\n\nvar utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [-0.0640568928626056260850430826247450385909, 0.0640568928626056260850430826247450385909, -0.1911188674736163091586398207570696318404, 0.1911188674736163091586398207570696318404, -0.3150426796961633743867932913198102407864, 0.3150426796961633743867932913198102407864, -0.4337935076260451384870842319133497124524, 0.4337935076260451384870842319133497124524, -0.5454214713888395356583756172183723700107, 0.5454214713888395356583756172183723700107, -0.6480936519369755692524957869107476266696, 0.6480936519369755692524957869107476266696, -0.7401241915785543642438281030999784255232, 0.7401241915785543642438281030999784255232, -0.8200019859739029219539498726697452080761, 0.8200019859739029219539498726697452080761, -0.8864155270044010342131543419821967550873, 0.8864155270044010342131543419821967550873, -0.9382745520027327585236490017087214496548, 0.9382745520027327585236490017087214496548, -0.9747285559713094981983919930081690617411, 0.9747285559713094981983919930081690617411, -0.9951872199970213601799974097007368118745, 0.9951872199970213601799974097007368118745],\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [0.1279381953467521569740561652246953718517, 0.1279381953467521569740561652246953718517, 0.1258374563468282961213753825111836887264, 0.1258374563468282961213753825111836887264, 0.121670472927803391204463153476262425607, 0.121670472927803391204463153476262425607, 0.1155056680537256013533444839067835598622, 0.1155056680537256013533444839067835598622, 0.1074442701159656347825773424466062227946, 0.1074442701159656347825773424466062227946, 0.0976186521041138882698806644642471544279, 0.0976186521041138882698806644642471544279, 0.086190161531953275917185202983742667185, 0.086190161531953275917185202983742667185, 0.0733464814110803057340336152531165181193, 0.0733464814110803057340336152531165181193, 0.0592985849154367807463677585001085845412, 0.0592985849154367807463677585001085845412, 0.0442774388174198061686027482113382288593, 0.0442774388174198061686027482113382288593, 0.0285313886289336631813078159518782864491, 0.0285313886289336631813078159518782864491, 0.0123412297999871995468056670700372915759, 0.0123412297999871995468056670700372915759],\n  arcfn: function arcfn(t, derivativeFn) {\n    var d = derivativeFn(t);\n    var l = d.x * d.x + d.y * d.y;\n    if (typeof d.z !== \"undefined\") {\n      l += d.z * d.z;\n    }\n    return sqrt(l);\n  },\n  compute: function compute(t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n    var order = points.length - 1;\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n    var mt = 1 - t;\n    var p = points; // constant?\n\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    } // linear?\n\n    if (order === 1) {\n      var ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t\n      };\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n      return ret;\n    } // quadratic/cubic curve?\n\n    if (order < 4) {\n      var mt2 = mt * mt,\n        t2 = t * t,\n        a,\n        b,\n        c,\n        d = 0;\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n      var _ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t\n      };\n      if (_3d) {\n        _ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n      return _ret;\n    } // higher order curves: use de Casteljau's computation\n\n    var dCpts = JSON.parse(JSON.stringify(points));\n    while (dCpts.length > 1) {\n      for (var i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t\n        };\n        if (typeof dCpts[i].z !== \"undefined\") {\n          dCpts[i] = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n  computeWithRatios: function computeWithRatios(t, points, ratios, _3d) {\n    var mt = 1 - t,\n      r = ratios,\n      p = points;\n    var f1 = r[0],\n      f2 = r[1],\n      f3 = r[2],\n      f4 = r[3],\n      d; // spec for linear\n\n    f1 *= mt;\n    f2 *= t;\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t\n      };\n    } // upgrade to quadratic\n\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t\n      };\n    } // upgrade to cubic\n\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t\n      };\n    }\n  },\n  derive: function derive(points, _3d) {\n    var dpoints = [];\n    for (var p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      var list = [];\n      for (var j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y)\n        };\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n        list.push(dpt);\n      }\n      dpoints.push(list);\n      p = list;\n    }\n    return dpoints;\n  },\n  between: function between(v, m, M) {\n    return m <= v && v <= M || utils.approximately(v, m) || utils.approximately(v, M);\n  },\n  approximately: function approximately(a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n  length: function length(derivativeFn) {\n    var z = 0.5,\n      len = utils.Tvalues.length;\n    var sum = 0;\n    for (var i = 0, _t; i < len; i++) {\n      _t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(_t, derivativeFn);\n    }\n    return z * sum;\n  },\n  map: function map(v, ds, de, ts, te) {\n    var d1 = de - ds,\n      d2 = te - ts,\n      v2 = v - ds,\n      r = v2 / d1;\n    return ts + d2 * r;\n  },\n  lerp: function lerp(r, v1, v2) {\n    var ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y)\n    };\n    if (!!v1.z && !!v2.z) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n    return ret;\n  },\n  pointToString: function pointToString(p) {\n    var s = p.x + \"/\" + p.y;\n    if (typeof p.z !== \"undefined\") {\n      s += \"/\" + p.z;\n    }\n    return s;\n  },\n  pointsToString: function pointsToString(points) {\n    return \"[\" + points.map(utils.pointToString).join(\", \") + \"]\";\n  },\n  copy: function copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n  angle: function angle(o, v1, v2) {\n    var dx1 = v1.x - o.x,\n      dy1 = v1.y - o.y,\n      dx2 = v2.x - o.x,\n      dy2 = v2.y - o.y,\n      cross = dx1 * dy2 - dy1 * dx2,\n      dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n  // round as string, to avoid rounding errors\n  round: function round(v, d) {\n    var s = \"\" + v;\n    var pos = s.indexOf(\".\");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n  dist: function dist(p1, p2) {\n    var dx = p1.x - p2.x,\n      dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n  closest: function closest(LUT, point) {\n    var mdist = pow(2, 63),\n      mpos,\n      d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return {\n      mdist: mdist,\n      mpos: mpos\n    };\n  },\n  abcratio: function abcratio(t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    var bottom = pow(t, n) + pow(1 - t, n),\n      top = bottom - 1;\n    return abs(top / bottom);\n  },\n  projectionratio: function projectionratio(t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    var top = pow(1 - t, n),\n      bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n  lli8: function lli8(x1, y1, x2, y2, x3, y3, x4, y4) {\n    var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n      d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (d == 0) {\n      return false;\n    }\n    return {\n      x: nx / d,\n      y: ny / d\n    };\n  },\n  lli4: function lli4(p1, p2, p3, p4) {\n    var x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      x3 = p3.x,\n      y3 = p3.y,\n      x4 = p4.x,\n      y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n  lli: function lli(v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n  makeline: function makeline(p1, p2) {\n    var x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      dx = (x2 - x1) / 3,\n      dy = (y2 - y1) / 3;\n    return new Bezier(x1, y1, x1 + dx, y1 + dy, x1 + 2 * dx, y1 + 2 * dy, x2, y2);\n  },\n  findbbox: function findbbox(sections) {\n    var mx = nMax,\n      my = nMax,\n      MX = nMin,\n      MY = nMin;\n    sections.forEach(function (s) {\n      var bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: {\n        min: mx,\n        mid: (mx + MX) / 2,\n        max: MX,\n        size: MX - mx\n      },\n      y: {\n        min: my,\n        mid: (my + MY) / 2,\n        max: MY,\n        size: MY - my\n      }\n    };\n  },\n  shapeintersections: function shapeintersections(s1, bbox1, s2, bbox2, curveIntersectionThreshold) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    var intersections = [];\n    var a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    var a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        var iss = l1.intersects(l2, curveIntersectionThreshold);\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n  makeshape: function makeshape(forward, back, curveIntersectionThreshold) {\n    var bpl = back.points.length;\n    var fpl = forward.points.length;\n    var start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    var end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    var shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end])\n    };\n    shape.intersections = function (s2) {\n      return utils.shapeintersections(shape, shape.bbox, s2, s2.bbox, curveIntersectionThreshold);\n    };\n    return shape;\n  },\n  getminmax: function getminmax(curve, d, list) {\n    if (!list) return {\n      min: 0,\n      max: 0\n    };\n    var min = nMax,\n      max = nMin,\n      t,\n      c;\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n    for (var i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n      if (c[d] < min) {\n        min = c[d];\n      }\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n    return {\n      min: min,\n      mid: (min + max) / 2,\n      max: max,\n      size: max - min\n    };\n  },\n  align: function align(points, line) {\n    var tx = line.p1.x,\n      ty = line.p1.y,\n      a = -atan2(line.p2.y - ty, line.p2.x - tx),\n      d = function d(v) {\n        return {\n          x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n          y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a)\n        };\n      };\n    return points.map(d);\n  },\n  roots: function roots(points, line) {\n    line = line || {\n      p1: {\n        x: 0,\n        y: 0\n      },\n      p2: {\n        x: 1,\n        y: 0\n      }\n    };\n    var order = points.length - 1;\n    var aligned = utils.align(points, line);\n    var reduce = function reduce(t) {\n      return 0 <= t && t <= 1;\n    };\n    if (order === 2) {\n      var _a = aligned[0].y,\n        _b = aligned[1].y,\n        _c = aligned[2].y,\n        _d = _a - 2 * _b + _c;\n      if (_d !== 0) {\n        var m1 = -sqrt(_b * _b - _a * _c),\n          m2 = -_a + _b,\n          _v = -(m1 + m2) / _d,\n          v2 = -(-m1 + m2) / _d;\n        return [_v, v2].filter(reduce);\n      } else if (_b !== _c && _d === 0) {\n        return [(2 * _b - _c) / (2 * _b - 2 * _c)].filter(reduce);\n      }\n      return [];\n    } // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n\n    var pa = aligned[0].y,\n      pb = aligned[1].y,\n      pc = aligned[2].y,\n      pd = aligned[3].y;\n    var d = -pa + 3 * pb - 3 * pc + pd,\n      a = 3 * pa - 6 * pb + 3 * pc,\n      b = -3 * pa + 3 * pb,\n      c = pa;\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        } // linear solution:\n\n        return [-c / b].filter(reduce);\n      } // quadratic solution:\n\n      var _q = sqrt(b * b - 4 * a * c),\n        a2 = 2 * a;\n      return [(_q - b) / a2, (-b - _q) / a2].filter(reduce);\n    } // at this point, we know we need a cubic solution:\n\n    a /= d;\n    b /= d;\n    c /= d;\n    var p = (3 * b - a * a) / 3,\n      p3 = p / 3,\n      q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n      q2 = q / 2,\n      discriminant = q2 * q2 + p3 * p3 * p3;\n    var u1, v1, x1, x2, x3;\n    if (discriminant < 0) {\n      var mp3 = -p / 3,\n        mp33 = mp3 * mp3 * mp3,\n        r = sqrt(mp33),\n        _t2 = -q / (2 * r),\n        cosphi = _t2 < -1 ? -1 : _t2 > 1 ? 1 : _t2,\n        phi = acos(cosphi),\n        crtr = crt(r),\n        t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      var sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n  droots: function droots(p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      var a = p[0],\n        b = p[1],\n        c = p[2],\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        var m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n      return [];\n    } // linear roots are even easier\n\n    if (p.length === 2) {\n      var _a2 = p[0],\n        _b2 = p[1];\n      if (_a2 !== _b2) {\n        return [_a2 / (_a2 - _b2)];\n      }\n      return [];\n    }\n    return [];\n  },\n  curvature: function curvature(t, d1, d2, _3d, kOnly) {\n    var num,\n      dnm,\n      adk,\n      dk,\n      k = 0,\n      r = 0; //\n    // We're using the following formula for curvature:\n    //\n    //              x'y\" - y'x\"\n    //   k(t) = ------------------\n    //           (x'² + y'²)^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y'z\" - y\"z')² + (z'x\" - z\"x')² + (x'y\" - x\"y')²)\n    //   k(t) = -------------------------------------------------------\n    //                     (x'² + y'² + z'²)^(3/2)\n    //\n\n    var d = utils.compute(t, d1);\n    var dd = utils.compute(t, d2);\n    var qdsum = d.x * d.x + d.y * d.y;\n    if (_3d) {\n      num = sqrt(pow(d.y * dd.z - dd.y * d.z, 2) + pow(d.z * dd.x - dd.z * d.x, 2) + pow(d.x * dd.y - dd.x * d.y, 2));\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n    if (num === 0 || dnm === 0) {\n      return {\n        k: 0,\n        r: 0\n      };\n    }\n    k = num / dnm;\n    r = dnm / num; // We're also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we're just going to\n    // ballpark it based on an epsilon.\n\n    if (!kOnly) {\n      // compute k'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      var pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\n      var nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n    return {\n      k: k,\n      r: r,\n      dk: dk,\n      adk: adk\n    };\n  },\n  inflections: function inflections(points) {\n    if (points.length < 4) return []; // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    var p = utils.align(points, {\n        p1: points[0],\n        p2: points.slice(-1)[0]\n      }),\n      a = p[2].x * p[1].y,\n      b = p[3].x * p[1].y,\n      c = p[1].x * p[2].y,\n      d = p[3].x * p[2].y,\n      v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n      v2 = 18 * (3 * a - b - 3 * c),\n      v3 = 18 * (c - a);\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        var _t3 = -v3 / v2;\n        if (0 <= _t3 && _t3 <= 1) return [_t3];\n      }\n      return [];\n    }\n    var trm = v2 * v2 - 4 * v1 * v3,\n      sq = Math.sqrt(trm),\n      d2 = 2 * v1;\n    if (utils.approximately(d2, 0)) return [];\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n  bboxoverlap: function bboxoverlap(b1, b2) {\n    var dims = [\"x\", \"y\"],\n      len = dims.length;\n    for (var i = 0, dim, l, _t4, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      _t4 = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - _t4) >= d) return false;\n    }\n    return true;\n  },\n  expandbox: function expandbox(bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n  pairiteration: function pairiteration(c1, c2, curveIntersectionThreshold) {\n    var c1b = c1.bbox(),\n      c2b = c2.bbox(),\n      r = 100000,\n      threshold = curveIntersectionThreshold || 0.5;\n    if (c1b.x.size + c1b.y.size < threshold && c2b.x.size + c2b.y.size < threshold) {\n      return [(r * (c1._t1 + c1._t2) / 2 | 0) / r + \"/\" + (r * (c2._t1 + c2._t2) / 2 | 0) / r];\n    }\n    var cc1 = c1.split(0.5),\n      cc2 = c2.split(0.5),\n      pairs = [{\n        left: cc1.left,\n        right: cc2.left\n      }, {\n        left: cc1.left,\n        right: cc2.right\n      }, {\n        left: cc1.right,\n        right: cc2.right\n      }, {\n        left: cc1.right,\n        right: cc2.left\n      }];\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n    var results = [];\n    if (pairs.length === 0) return results;\n    pairs.forEach(function (pair) {\n      results = results.concat(utils.pairiteration(pair.left, pair.right, threshold));\n    });\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n    return results;\n  },\n  getccenter: function getccenter(p1, p2, p3) {\n    var dx1 = p2.x - p1.x,\n      dy1 = p2.y - p1.y,\n      dx2 = p3.x - p2.x,\n      dy2 = p3.y - p2.y,\n      dx1p = dx1 * cos(quart) - dy1 * sin(quart),\n      dy1p = dx1 * sin(quart) + dy1 * cos(quart),\n      dx2p = dx2 * cos(quart) - dy2 * sin(quart),\n      dy2p = dx2 * sin(quart) + dy2 * cos(quart),\n      // chord midpoints\n      mx1 = (p1.x + p2.x) / 2,\n      my1 = (p1.y + p2.y) / 2,\n      mx2 = (p2.x + p3.x) / 2,\n      my2 = (p2.y + p3.y) / 2,\n      // midpoint offsets\n      mx1n = mx1 + dx1p,\n      my1n = my1 + dy1p,\n      mx2n = mx2 + dx2p,\n      my2n = my2 + dy2p,\n      // intersection of these lines:\n      arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n      r = utils.dist(arc, p1); // arc start/end values, over mid point:\n\n    var s = atan2(p1.y - arc.y, p1.x - arc.x),\n      m = atan2(p2.y - arc.y, p2.x - arc.x),\n      e = atan2(p3.y - arc.y, p3.x - arc.x),\n      _; // determine arc direction (cw/ccw correction)\n\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    } // assign and done.\n\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n  numberSort: function numberSort(a, b) {\n    return a - b;\n  }\n};\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\nvar PolyBezier = /*#__PURE__*/function () {\n  function PolyBezier(curves) {\n    _classCallCheck(this, PolyBezier);\n    this.curves = [];\n    this._3d = false;\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n  _createClass(PolyBezier, [{\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.toString();\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"[\" + this.curves.map(function (curve) {\n        return utils.pointsToString(curve.points);\n      }).join(\", \") + \"]\";\n    }\n  }, {\n    key: \"addCurve\",\n    value: function addCurve(curve) {\n      this.curves.push(curve);\n      this._3d = this._3d || curve._3d;\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return this.curves.map(function (v) {\n        return v.length();\n      }).reduce(function (a, b) {\n        return a + b;\n      });\n    }\n  }, {\n    key: \"curve\",\n    value: function curve(idx) {\n      return this.curves[idx];\n    }\n  }, {\n    key: \"bbox\",\n    value: function bbox() {\n      var c = this.curves;\n      var bbox = c[0].bbox();\n      for (var i = 1; i < c.length; i++) {\n        utils.expandbox(bbox, c[i].bbox());\n      }\n      return bbox;\n    }\n  }, {\n    key: \"offset\",\n    value: function offset(d) {\n      var offset = [];\n      this.curves.forEach(function (v) {\n        offset.push.apply(offset, _toConsumableArray(v.offset(d)));\n      });\n      return new PolyBezier(offset);\n    }\n  }]);\n  return PolyBezier;\n}();\n/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n// math-inlining.\nvar abs$1 = Math.abs,\n  min = Math.min,\n  max = Math.max,\n  cos$1 = Math.cos,\n  sin$1 = Math.sin,\n  acos$1 = Math.acos,\n  sqrt$1 = Math.sqrt;\nvar pi$1 = Math.PI;\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nvar Bezier = /*#__PURE__*/function () {\n  function Bezier(coords) {\n    _classCallCheck(this, Bezier);\n    var args = coords && coords.forEach ? coords : Array.from(arguments).slice();\n    var coordlen = false;\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      var newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n    var higher = false;\n    var len = args.length;\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");\n        }\n      }\n    }\n    var _3d = this._3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z !== \"undefined\";\n    var points = this.points = [];\n    for (var idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1]\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    var order = this.order = points.length - 1;\n    var dims = this.dims = [\"x\", \"y\"];\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n    var aligned = utils.align(points, {\n      p1: points[0],\n      p2: points[order]\n    });\n    this._linear = !aligned.some(function (p) {\n      return abs$1(p.y) > 0.0001;\n    });\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n  _createClass(Bezier, [{\n    key: \"getUtils\",\n    value: function getUtils() {\n      return Bezier.getUtils();\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.toString();\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return utils.pointsToString(this.points);\n    }\n  }, {\n    key: \"toSVG\",\n    value: function toSVG() {\n      if (this._3d) return false;\n      var p = this.points,\n        x = p[0].x,\n        y = p[0].y,\n        s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n      for (var i = 1, last = p.length; i < last; i++) {\n        s.push(p[i].x);\n        s.push(p[i].y);\n      }\n      return s.join(\" \");\n    }\n  }, {\n    key: \"setRatios\",\n    value: function setRatios(ratios) {\n      if (ratios.length !== this.points.length) {\n        throw new Error(\"incorrect number of ratio values\");\n      }\n      this.ratios = ratios;\n      this._lut = []; //  invalidate any precomputed LUT\n    }\n  }, {\n    key: \"verify\",\n    value: function verify() {\n      var print = this.coordDigest();\n      if (print !== this._print) {\n        this._print = print;\n        this.update();\n      }\n    }\n  }, {\n    key: \"coordDigest\",\n    value: function coordDigest() {\n      return this.points.map(function (c, pos) {\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n      }).join(\"\");\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      // invalidate any precomputed LUT\n      this._lut = [];\n      this.dpoints = utils.derive(this.points, this._3d);\n      this.computedirection();\n    }\n  }, {\n    key: \"computedirection\",\n    value: function computedirection() {\n      var points = this.points;\n      var angle = utils.angle(points[0], points[this.order], points[1]);\n      this.clockwise = angle > 0;\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return utils.length(this.derivative.bind(this));\n    }\n  }, {\n    key: \"getABC\",\n    value: function getABC(t, B) {\n      B = B || this.get(t);\n      var S = this.points[0];\n      var E = this.points[this.order];\n      return Bezier.getABC(this.order, S, B, E, t);\n    }\n  }, {\n    key: \"getLUT\",\n    value: function getLUT(steps) {\n      this.verify();\n      steps = steps || 100;\n      if (this._lut.length === steps) {\n        return this._lut;\n      }\n      this._lut = []; // We want a range from 0 to 1 inclusive, so\n      // we decrement and then use <= rather than <:\n\n      steps--;\n      for (var i = 0, p, _t5; i < steps; i++) {\n        _t5 = i / (steps - 1);\n        p = this.compute(_t5);\n        p.t = _t5;\n        this._lut.push(p);\n      }\n      return this._lut;\n    }\n  }, {\n    key: \"on\",\n    value: function on(point, error) {\n      error = error || 5;\n      var lut = this.getLUT(),\n        hits = [];\n      for (var i = 0, c, _t6 = 0; i < lut.length; i++) {\n        c = lut[i];\n        if (utils.dist(c, point) < error) {\n          hits.push(c);\n          _t6 += i / lut.length;\n        }\n      }\n      if (!hits.length) return false;\n      return t /= hits.length;\n    }\n  }, {\n    key: \"project\",\n    value: function project(point) {\n      // step 1: coarse check\n      var LUT = this.getLUT(),\n        l = LUT.length - 1,\n        closest = utils.closest(LUT, point),\n        mpos = closest.mpos,\n        t1 = (mpos - 1) / l,\n        t2 = (mpos + 1) / l,\n        step = 0.1 / l; // step 2: fine check\n\n      var mdist = closest.mdist,\n        t = t1,\n        ft = t,\n        p;\n      mdist += 1;\n      for (var d; t < t2 + step; t += step) {\n        p = this.compute(t);\n        d = utils.dist(point, p);\n        if (d < mdist) {\n          mdist = d;\n          ft = t;\n        }\n      }\n      ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n      p = this.compute(ft);\n      p.t = ft;\n      p.d = mdist;\n      return p;\n    }\n  }, {\n    key: \"get\",\n    value: function get(t) {\n      return this.compute(t);\n    }\n  }, {\n    key: \"point\",\n    value: function point(idx) {\n      return this.points[idx];\n    }\n  }, {\n    key: \"compute\",\n    value: function compute(t) {\n      if (this.ratios) {\n        return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n      }\n      return utils.compute(t, this.points, this._3d, this.ratios);\n    }\n  }, {\n    key: \"raise\",\n    value: function raise() {\n      var p = this.points,\n        np = [p[0]],\n        k = p.length;\n      for (var i = 1, _pi, pim; i < k; i++) {\n        _pi = p[i];\n        pim = p[i - 1];\n        np[i] = {\n          x: (k - i) / k * _pi.x + i / k * pim.x,\n          y: (k - i) / k * _pi.y + i / k * pim.y\n        };\n      }\n      np[k] = p[k - 1];\n      return new Bezier(np);\n    }\n  }, {\n    key: \"derivative\",\n    value: function derivative(t) {\n      return utils.compute(t, this.dpoints[0]);\n    }\n  }, {\n    key: \"dderivative\",\n    value: function dderivative(t) {\n      return utils.compute(t, this.dpoints[1]);\n    }\n  }, {\n    key: \"align\",\n    value: function align() {\n      var p = this.points;\n      return new Bezier(utils.align(p, {\n        p1: p[0],\n        p2: p[p.length - 1]\n      }));\n    }\n  }, {\n    key: \"curvature\",\n    value: function curvature(t) {\n      return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n    }\n  }, {\n    key: \"inflections\",\n    value: function inflections() {\n      return utils.inflections(this.points);\n    }\n  }, {\n    key: \"normal\",\n    value: function normal(t) {\n      return this._3d ? this.__normal3(t) : this.__normal2(t);\n    }\n  }, {\n    key: \"__normal2\",\n    value: function __normal2(t) {\n      var d = this.derivative(t);\n      var q = sqrt$1(d.x * d.x + d.y * d.y);\n      return {\n        x: -d.y / q,\n        y: d.x / q\n      };\n    }\n  }, {\n    key: \"__normal3\",\n    value: function __normal3(t) {\n      // see http://stackoverflow.com/questions/25453159\n      var r1 = this.derivative(t),\n        r2 = this.derivative(t + 0.01),\n        q1 = sqrt$1(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n        q2 = sqrt$1(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n      r1.x /= q1;\n      r1.y /= q1;\n      r1.z /= q1;\n      r2.x /= q2;\n      r2.y /= q2;\n      r2.z /= q2; // cross product\n\n      var c = {\n        x: r2.y * r1.z - r2.z * r1.y,\n        y: r2.z * r1.x - r2.x * r1.z,\n        z: r2.x * r1.y - r2.y * r1.x\n      };\n      var m = sqrt$1(c.x * c.x + c.y * c.y + c.z * c.z);\n      c.x /= m;\n      c.y /= m;\n      c.z /= m; // rotation matrix\n\n      var R = [c.x * c.x, c.x * c.y - c.z, c.x * c.z + c.y, c.x * c.y + c.z, c.y * c.y, c.y * c.z - c.x, c.x * c.z - c.y, c.y * c.z + c.x, c.z * c.z]; // normal vector:\n\n      var n = {\n        x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n        y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n        z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z\n      };\n      return n;\n    }\n  }, {\n    key: \"hull\",\n    value: function hull(t) {\n      var p = this.points,\n        _p = [],\n        q = [],\n        idx = 0;\n      q[idx++] = p[0];\n      q[idx++] = p[1];\n      q[idx++] = p[2];\n      if (this.order === 3) {\n        q[idx++] = p[3];\n      } // we lerp between all points at each iteration, until we have 1 point left.\n\n      while (p.length > 1) {\n        _p = [];\n        for (var i = 0, pt, l = p.length - 1; i < l; i++) {\n          pt = utils.lerp(t, p[i], p[i + 1]);\n          q[idx++] = pt;\n          _p.push(pt);\n        }\n        p = _p;\n      }\n      return q;\n    }\n  }, {\n    key: \"split\",\n    value: function split(t1, t2) {\n      // shortcuts\n      if (t1 === 0 && !!t2) {\n        return this.split(t2).left;\n      }\n      if (t2 === 1) {\n        return this.split(t1).right;\n      } // no shortcut: use \"de Casteljau\" iteration.\n\n      var q = this.hull(t1);\n      var result = {\n        left: this.order === 2 ? new Bezier([q[0], q[3], q[5]]) : new Bezier([q[0], q[4], q[7], q[9]]),\n        right: this.order === 2 ? new Bezier([q[5], q[4], q[2]]) : new Bezier([q[9], q[8], q[6], q[3]]),\n        span: q\n      }; // make sure we bind _t1/_t2 information!\n\n      result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n      result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n      result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n      result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2); // if we have no t2, we're done\n\n      if (!t2) {\n        return result;\n      } // if we have a t2, split again:\n\n      t2 = utils.map(t2, t1, 1, 0, 1);\n      return result.right.split(t2).left;\n    }\n  }, {\n    key: \"extrema\",\n    value: function extrema() {\n      var result = {};\n      var roots = [];\n      this.dims.forEach(function (dim) {\n        var mfn = function mfn(v) {\n          return v[dim];\n        };\n        var p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this));\n      result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n        return roots.indexOf(v) === idx;\n      });\n      return result;\n    }\n  }, {\n    key: \"bbox\",\n    value: function bbox() {\n      var extrema = this.extrema(),\n        result = {};\n      this.dims.forEach(function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this));\n      return result;\n    }\n  }, {\n    key: \"overlaps\",\n    value: function overlaps(curve) {\n      var lbbox = this.bbox(),\n        tbbox = curve.bbox();\n      return utils.bboxoverlap(lbbox, tbbox);\n    }\n  }, {\n    key: \"offset\",\n    value: function offset(t, d) {\n      if (typeof d !== \"undefined\") {\n        var c = this.get(t),\n          n = this.normal(t);\n        var ret = {\n          c: c,\n          n: n,\n          x: c.x + n.x * d,\n          y: c.y + n.y * d\n        };\n        if (this._3d) {\n          ret.z = c.z + n.z * d;\n        }\n        return ret;\n      }\n      if (this._linear) {\n        var nv = this.normal(0),\n          coords = this.points.map(function (p) {\n            var ret = {\n              x: p.x + t * nv.x,\n              y: p.y + t * nv.y\n            };\n            if (p.z && nv.z) {\n              ret.z = p.z + t * nv.z;\n            }\n            return ret;\n          });\n        return [new Bezier(coords)];\n      }\n      return this.reduce().map(function (s) {\n        if (s._linear) {\n          return s.offset(t)[0];\n        }\n        return s.scale(t);\n      });\n    }\n  }, {\n    key: \"simple\",\n    value: function simple() {\n      if (this.order === 3) {\n        var a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n        var a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n        if (a1 > 0 && a2 < 0 || a1 < 0 && a2 > 0) return false;\n      }\n      var n1 = this.normal(0);\n      var n2 = this.normal(1);\n      var s = n1.x * n2.x + n1.y * n2.y;\n      if (this._3d) {\n        s += n1.z * n2.z;\n      }\n      return abs$1(acos$1(s)) < pi$1 / 3;\n    }\n  }, {\n    key: \"reduce\",\n    value: function reduce() {\n      // TODO: examine these var types in more detail...\n      var i,\n        t1 = 0,\n        t2 = 0,\n        step = 0.01,\n        segment,\n        pass1 = [],\n        pass2 = []; // first pass: split on extrema\n\n      var extrema = this.extrema().values;\n      if (extrema.indexOf(0) === -1) {\n        extrema = [0].concat(extrema);\n      }\n      if (extrema.indexOf(1) === -1) {\n        extrema.push(1);\n      }\n      for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n        t2 = extrema[i];\n        segment = this.split(t1, t2);\n        segment._t1 = t1;\n        segment._t2 = t2;\n        pass1.push(segment);\n        t1 = t2;\n      } // second pass: further reduce these segments to simple segments\n\n      pass1.forEach(function (p1) {\n        t1 = 0;\n        t2 = 0;\n        while (t2 <= 1) {\n          for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n            segment = p1.split(t1, t2);\n            if (!segment.simple()) {\n              t2 -= step;\n              if (abs$1(t1 - t2) < step) {\n                // we can never form a reduction\n                return [];\n              }\n              segment = p1.split(t1, t2);\n              segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n              segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n              pass2.push(segment);\n              t1 = t2;\n              break;\n            }\n          }\n        }\n        if (t1 < 1) {\n          segment = p1.split(t1, 1);\n          segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n          segment._t2 = p1._t2;\n          pass2.push(segment);\n        }\n      });\n      return pass2;\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(d) {\n      var _this = this;\n      var order = this.order;\n      var distanceFn = false;\n      if (typeof d === \"function\") {\n        distanceFn = d;\n      }\n      if (distanceFn && order === 2) {\n        return this.raise().scale(distanceFn);\n      } // TODO: add special handling for degenerate (=linear) curves.\n\n      var clockwise = this.clockwise;\n      var r1 = distanceFn ? distanceFn(0) : d;\n      var r2 = distanceFn ? distanceFn(1) : d;\n      var v = [this.offset(0, 10), this.offset(1, 10)];\n      var points = this.points;\n      var np = [];\n      var o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n      if (!o) {\n        throw new Error(\"cannot scale this curve. Try reducing it first.\");\n      } // move all points by distance 'd' wrt the origin 'o'\n      // move end points by fixed distance along normal.\n\n      [0, 1].forEach(function (t) {\n        var p = np[t * order] = utils.copy(points[t * order]);\n        p.x += (t ? r2 : r1) * v[t].n.x;\n        p.y += (t ? r2 : r1) * v[t].n.y;\n      });\n      if (!distanceFn) {\n        // move control points to lie on the intersection of the offset\n        // derivative vector, and the origin-through-control vector\n        [0, 1].forEach(function (t) {\n          if (order === 2 && !!t) return;\n          var p = np[t * order];\n          var d = _this.derivative(t);\n          var p2 = {\n            x: p.x + d.x,\n            y: p.y + d.y\n          };\n          np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n        });\n        return new Bezier(np);\n      } // move control points by \"however much necessary to\n      // ensure the correct tangent to endpoint\".\n\n      [0, 1].forEach(function (t) {\n        if (order === 2 && !!t) return;\n        var p = points[t + 1];\n        var ov = {\n          x: p.x - o.x,\n          y: p.y - o.y\n        };\n        var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n        if (distanceFn && !clockwise) rc = -rc;\n        var m = sqrt$1(ov.x * ov.x + ov.y * ov.y);\n        ov.x /= m;\n        ov.y /= m;\n        np[t + 1] = {\n          x: p.x + rc * ov.x,\n          y: p.y + rc * ov.y\n        };\n      });\n      return new Bezier(np);\n    }\n  }, {\n    key: \"outline\",\n    value: function outline(d1, d2, d3, d4) {\n      d2 = typeof d2 === \"undefined\" ? d1 : d2;\n      var reduced = this.reduce(),\n        len = reduced.length,\n        fcurves = [];\n      var bcurves = [],\n        p,\n        alen = 0,\n        tlen = this.length();\n      var graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n      function linearDistanceFunction(s, e, tlen, alen, slen) {\n        return function (v) {\n          var f1 = alen / tlen,\n            f2 = (alen + slen) / tlen,\n            d = e - s;\n          return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n        };\n      } // form curve oulines\n\n      reduced.forEach(function (segment) {\n        var slen = segment.length();\n        if (graduated) {\n          fcurves.push(segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen)));\n          bcurves.push(segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen)));\n        } else {\n          fcurves.push(segment.scale(d1));\n          bcurves.push(segment.scale(-d2));\n        }\n        alen += slen;\n      }); // reverse the \"return\" outline\n\n      bcurves = bcurves.map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      }).reverse(); // form the endcaps as lines\n\n      var fs = fcurves[0].points[0],\n        fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n        bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n        be = bcurves[0].points[0],\n        ls = utils.makeline(bs, fs),\n        le = utils.makeline(fe, be),\n        segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n      return new PolyBezier(segments);\n    }\n  }, {\n    key: \"outlineshapes\",\n    value: function outlineshapes(d1, d2, curveIntersectionThreshold) {\n      d2 = d2 || d1;\n      var outline = this.outline(d1, d2).curves;\n      var shapes = [];\n      for (var i = 1, len = outline.length; i < len / 2; i++) {\n        var shape = utils.makeshape(outline[i], outline[len - i], curveIntersectionThreshold);\n        shape.startcap.virtual = i > 1;\n        shape.endcap.virtual = i < len / 2 - 1;\n        shapes.push(shape);\n      }\n      return shapes;\n    }\n  }, {\n    key: \"intersects\",\n    value: function intersects(curve, curveIntersectionThreshold) {\n      if (!curve) return this.selfintersects(curveIntersectionThreshold);\n      if (curve.p1 && curve.p2) {\n        return this.lineIntersects(curve);\n      }\n      if (curve instanceof Bezier) {\n        curve = curve.reduce();\n      }\n      return this.curveintersects(this.reduce(), curve, curveIntersectionThreshold);\n    }\n  }, {\n    key: \"lineIntersects\",\n    value: function lineIntersects(line) {\n      var _this2 = this;\n      var mx = min(line.p1.x, line.p2.x),\n        my = min(line.p1.y, line.p2.y),\n        MX = max(line.p1.x, line.p2.x),\n        MY = max(line.p1.y, line.p2.y);\n      return utils.roots(this.points, line).filter(function (t) {\n        var p = _this2.get(t);\n        return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n      });\n    }\n  }, {\n    key: \"selfintersects\",\n    value: function selfintersects(curveIntersectionThreshold) {\n      // \"simple\" curves cannot intersect with their direct\n      // neighbour, so for each segment X we check whether\n      // it intersects [0:x-2][x+2:last].\n      var reduced = this.reduce(),\n        len = reduced.length - 2,\n        results = [];\n      for (var i = 0, result, left, right; i < len; i++) {\n        left = reduced.slice(i, i + 1);\n        right = reduced.slice(i + 2);\n        result = this.curveintersects(left, right, curveIntersectionThreshold);\n        results.push.apply(results, _toConsumableArray(result));\n      }\n      return results;\n    }\n  }, {\n    key: \"curveintersects\",\n    value: function curveintersects(c1, c2, curveIntersectionThreshold) {\n      var pairs = []; // step 1: pair off any overlapping segments\n\n      c1.forEach(function (l) {\n        c2.forEach(function (r) {\n          if (l.overlaps(r)) {\n            pairs.push({\n              left: l,\n              right: r\n            });\n          }\n        });\n      }); // step 2: for each pairing, run through the convergence algorithm.\n\n      var intersections = [];\n      pairs.forEach(function (pair) {\n        var result = utils.pairiteration(pair.left, pair.right, curveIntersectionThreshold);\n        if (result.length > 0) {\n          intersections = intersections.concat(result);\n        }\n      });\n      return intersections;\n    }\n  }, {\n    key: \"arcs\",\n    value: function arcs(errorThreshold) {\n      errorThreshold = errorThreshold || 0.5;\n      return this._iterate(errorThreshold, []);\n    }\n  }, {\n    key: \"_error\",\n    value: function _error(pc, np1, s, e) {\n      var q = (e - s) / 4,\n        c1 = this.get(s + q),\n        c2 = this.get(e - q),\n        ref = utils.dist(pc, np1),\n        d1 = utils.dist(pc, c1),\n        d2 = utils.dist(pc, c2);\n      return abs$1(d1 - ref) + abs$1(d2 - ref);\n    }\n  }, {\n    key: \"_iterate\",\n    value: function _iterate(errorThreshold, circles) {\n      var t_s = 0,\n        t_e = 1,\n        safety; // we do a binary search to find the \"good `t` closest to no-longer-good\"\n\n      do {\n        safety = 0; // step 1: start with the maximum possible arc\n\n        t_e = 1; // points:\n\n        var np1 = this.get(t_s),\n          np2 = void 0,\n          np3 = void 0,\n          arc = void 0,\n          prev_arc = void 0; // booleans:\n\n        var curr_good = false,\n          prev_good = false,\n          done = void 0; // numbers:\n\n        var t_m = t_e,\n          prev_e = 1; // step 2: find the best possible arc\n\n        do {\n          prev_good = curr_good;\n          prev_arc = arc;\n          t_m = (t_s + t_e) / 2;\n          np2 = this.get(t_m);\n          np3 = this.get(t_e);\n          arc = utils.getccenter(np1, np2, np3); //also save the t values\n\n          arc.interval = {\n            start: t_s,\n            end: t_e\n          };\n          var error = this._error(arc, np1, t_s, t_e);\n          curr_good = error <= errorThreshold;\n          done = prev_good && !curr_good;\n          if (!done) prev_e = t_e; // this arc is fine: we can move 'e' up to see if we can find a wider arc\n\n          if (curr_good) {\n            // if e is already at max, then we're done for this arc.\n            if (t_e >= 1) {\n              // make sure we cap at t=1\n              arc.interval.end = prev_e = 1;\n              prev_arc = arc; // if we capped the arc segment to t=1 we also need to make sure that\n              // the arc's end angle is correct with respect to the bezier end point.\n\n              if (t_e > 1) {\n                var d = {\n                  x: arc.x + arc.r * cos$1(arc.e),\n                  y: arc.y + arc.r * sin$1(arc.e)\n                };\n                arc.e += utils.angle({\n                  x: arc.x,\n                  y: arc.y\n                }, d, this.get(1));\n              }\n              break;\n            } // if not, move it up by half the iteration distance\n\n            t_e = t_e + (t_e - t_s) / 2;\n          } else {\n            // this is a bad arc: we need to move 'e' down to find a good arc\n            t_e = t_m;\n          }\n        } while (!done && safety++ < 100);\n        if (safety >= 100) {\n          break;\n        } // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n        prev_arc = prev_arc ? prev_arc : arc;\n        circles.push(prev_arc);\n        t_s = prev_e;\n      } while (t_e < 1);\n      return circles;\n    }\n  }], [{\n    key: \"quadraticFromPoints\",\n    value: function quadraticFromPoints(p1, p2, p3, t) {\n      if (typeof t === \"undefined\") {\n        t = 0.5;\n      } // shortcuts, although they're really dumb\n\n      if (t === 0) {\n        return new Bezier(p2, p2, p3);\n      }\n      if (t === 1) {\n        return new Bezier(p1, p2, p2);\n      } // real fitting.\n\n      var abc = Bezier.getABC(2, p1, p2, p3, t);\n      return new Bezier(p1, abc.A, p3);\n    }\n  }, {\n    key: \"cubicFromPoints\",\n    value: function cubicFromPoints(S, B, E, t, d1) {\n      if (typeof t === \"undefined\") {\n        t = 0.5;\n      }\n      var abc = Bezier.getABC(3, S, B, E, t);\n      if (typeof d1 === \"undefined\") {\n        d1 = utils.dist(B, abc.C);\n      }\n      var d2 = d1 * (1 - t) / t;\n      var selen = utils.dist(S, E),\n        lx = (E.x - S.x) / selen,\n        ly = (E.y - S.y) / selen,\n        bx1 = d1 * lx,\n        by1 = d1 * ly,\n        bx2 = d2 * lx,\n        by2 = d2 * ly; // derivation of new hull coordinates\n\n      var e1 = {\n          x: B.x - bx1,\n          y: B.y - by1\n        },\n        e2 = {\n          x: B.x + bx2,\n          y: B.y + by2\n        },\n        A = abc.A,\n        v1 = {\n          x: A.x + (e1.x - A.x) / (1 - t),\n          y: A.y + (e1.y - A.y) / (1 - t)\n        },\n        v2 = {\n          x: A.x + (e2.x - A.x) / t,\n          y: A.y + (e2.y - A.y) / t\n        },\n        nc1 = {\n          x: S.x + (v1.x - S.x) / t,\n          y: S.y + (v1.y - S.y) / t\n        },\n        nc2 = {\n          x: E.x + (v2.x - E.x) / (1 - t),\n          y: E.y + (v2.y - E.y) / (1 - t)\n        }; // ...done\n\n      return new Bezier(S, nc1, nc2, E);\n    }\n  }, {\n    key: \"getUtils\",\n    value: function getUtils() {\n      return utils;\n    }\n  }, {\n    key: \"PolyBezier\",\n    get: function get() {\n      return PolyBezier;\n    }\n  }, {\n    key: \"getABC\",\n    value: function getABC() {\n      var order = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n      var S = arguments.length > 1 ? arguments[1] : undefined;\n      var B = arguments.length > 2 ? arguments[2] : undefined;\n      var E = arguments.length > 3 ? arguments[3] : undefined;\n      var t = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n      var u = utils.projectionratio(t, order),\n        um = 1 - u,\n        C = {\n          x: u * S.x + um * E.x,\n          y: u * S.y + um * E.y\n        },\n        s = utils.abcratio(t, order),\n        A = {\n          x: B.x + (B.x - C.x) / s,\n          y: B.y + (B.y - C.y) / s\n        };\n      return {\n        A: A,\n        B: B,\n        C: C,\n        S: S,\n        E: E\n      };\n    }\n  }]);\n  return Bezier;\n}();\nexports.Bezier = Bezier;","map":{"version":3,"names":["Object","defineProperty","exports","value","Bezier","abs","Math","cos","sin","acos","atan2","sqrt","pow","crt","v","pi","PI","tau","quart","epsilon","nMax","Number","MAX_SAFE_INTEGER","nMin","MIN_SAFE_INTEGER","ZERO","x","y","z","utils","Tvalues","Cvalues","arcfn","t","derivativeFn","d","l","compute","points","_3d","order","length","mt","p","ret","mt2","t2","a","b","c","dCpts","JSON","parse","stringify","i","splice","computeWithRatios","ratios","r","f1","f2","f3","f4","derive","dpoints","list","j","dpt","push","between","m","M","approximately","precision","len","sum","map","ds","de","ts","te","d1","d2","v2","lerp","v1","pointToString","s","pointsToString","join","copy","obj","angle","o","dx1","dy1","dx2","dy2","cross","dot","round","pos","indexOf","parseFloat","substring","dist","p1","p2","dx","dy","closest","LUT","point","mdist","mpos","forEach","idx","abcratio","n","bottom","top","projectionratio","lli8","x1","y1","x2","y2","x3","y3","x4","y4","nx","ny","lli4","p3","p4","lli","makeline","findbbox","sections","mx","my","MX","MY","bbox","min","max","mid","size","shapeintersections","s1","bbox1","s2","bbox2","curveIntersectionThreshold","bboxoverlap","intersections","a1","startcap","forward","back","endcap","a2","l1","virtual","l2","iss","intersects","c1","c2","makeshape","bpl","fpl","start","end","shape","getminmax","curve","concat","get","align","line","tx","ty","roots","aligned","reduce","m1","m2","filter","pa","pb","pc","pd","q","q2","discriminant","u1","mp3","mp33","cosphi","phi","crtr","t1","sd","droots","curvature","kOnly","num","dnm","adk","dk","k","dd","qdsum","pk","nk","inflections","slice","v3","trm","sq","b1","b2","dims","dim","expandbox","_bbox","pairiteration","c1b","c2b","threshold","_t1","_t2","cc1","split","cc2","pairs","left","right","pair","results","getccenter","dx1p","dy1p","dx2p","dy2p","mx1","my1","mx2","my2","mx1n","my1n","mx2n","my2n","arc","e","_","numberSort","PolyBezier","curves","toString","offset","abs$1","cos$1","sin$1","acos$1","sqrt$1","pi$1","coords","args","Array","from","arguments","coordlen","newargs","higher","Error","step","dimlen","_linear","some","_lut","update","getUtils","last","print","coordDigest","_print","computedirection","clockwise","derivative","bind","B","S","E","getABC","steps","verify","error","lut","getLUT","hits","ft","np","pim","__normal3","__normal2","r1","r2","q1","R","_p","pt","hull","result","span","mfn","sort","values","extrema","lbbox","tbbox","normal","nv","scale","n1","n2","segment","pass1","pass2","simple","distanceFn","raise","ov","rc","d3","d4","reduced","fcurves","bcurves","alen","tlen","graduated","linearDistanceFunction","slen","reverse","fs","fe","bs","be","ls","le","segments","outline","shapes","selfintersects","lineIntersects","curveintersects","overlaps","errorThreshold","_iterate","np1","ref","circles","t_s","t_e","safety","np2","np3","prev_arc","curr_good","prev_good","done","t_m","prev_e","interval","_error","abc","A","C","selen","lx","ly","bx1","by1","bx2","by2","e1","e2","nc1","nc2","u","um"],"sources":["/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/bezier-js/dist/bezier.common.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Bezier = void 0;\n// math-inlining.\nconst {\n  abs,\n  cos,\n  sin,\n  acos,\n  atan2,\n  sqrt,\n  pow\n} = Math; // cube root function yielding real roots\n\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n} // trig constants\n\n\nconst pi = Math.PI,\n      tau = 2 * pi,\n      quart = pi / 2,\n      // float precision significant decimal\nepsilon = 0.000001,\n      // extremas used in bbox calculation and similar algorithms\nnMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n      nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n      // a zero coordinate, which is surprisingly useful\nZERO = {\n  x: 0,\n  y: 0,\n  z: 0\n}; // Bezier utility functions\n\nconst utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [-0.0640568928626056260850430826247450385909, 0.0640568928626056260850430826247450385909, -0.1911188674736163091586398207570696318404, 0.1911188674736163091586398207570696318404, -0.3150426796961633743867932913198102407864, 0.3150426796961633743867932913198102407864, -0.4337935076260451384870842319133497124524, 0.4337935076260451384870842319133497124524, -0.5454214713888395356583756172183723700107, 0.5454214713888395356583756172183723700107, -0.6480936519369755692524957869107476266696, 0.6480936519369755692524957869107476266696, -0.7401241915785543642438281030999784255232, 0.7401241915785543642438281030999784255232, -0.8200019859739029219539498726697452080761, 0.8200019859739029219539498726697452080761, -0.8864155270044010342131543419821967550873, 0.8864155270044010342131543419821967550873, -0.9382745520027327585236490017087214496548, 0.9382745520027327585236490017087214496548, -0.9747285559713094981983919930081690617411, 0.9747285559713094981983919930081690617411, -0.9951872199970213601799974097007368118745, 0.9951872199970213601799974097007368118745],\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [0.1279381953467521569740561652246953718517, 0.1279381953467521569740561652246953718517, 0.1258374563468282961213753825111836887264, 0.1258374563468282961213753825111836887264, 0.121670472927803391204463153476262425607, 0.121670472927803391204463153476262425607, 0.1155056680537256013533444839067835598622, 0.1155056680537256013533444839067835598622, 0.1074442701159656347825773424466062227946, 0.1074442701159656347825773424466062227946, 0.0976186521041138882698806644642471544279, 0.0976186521041138882698806644642471544279, 0.086190161531953275917185202983742667185, 0.086190161531953275917185202983742667185, 0.0733464814110803057340336152531165181193, 0.0733464814110803057340336152531165181193, 0.0592985849154367807463677585001085845412, 0.0592985849154367807463677585001085845412, 0.0442774388174198061686027482113382288593, 0.0442774388174198061686027482113382288593, 0.0285313886289336631813078159518782864491, 0.0285313886289336631813078159518782864491, 0.0123412297999871995468056670700372915759, 0.0123412297999871995468056670700372915759],\n  arcfn: function (t, derivativeFn) {\n    const d = derivativeFn(t);\n    let l = d.x * d.x + d.y * d.y;\n\n    if (typeof d.z !== \"undefined\") {\n      l += d.z * d.z;\n    }\n\n    return sqrt(l);\n  },\n  compute: function (t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n\n    const order = points.length - 1;\n\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n\n    const mt = 1 - t;\n    let p = points; // constant?\n\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    } // linear?\n\n\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t\n      };\n\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n\n      return ret;\n    } // quadratic/cubic curve?\n\n\n    if (order < 4) {\n      let mt2 = mt * mt,\n          t2 = t * t,\n          a,\n          b,\n          c,\n          d = 0;\n\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t\n      };\n\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n\n      return ret;\n    } // higher order curves: use de Casteljau's computation\n\n\n    const dCpts = JSON.parse(JSON.stringify(points));\n\n    while (dCpts.length > 1) {\n      for (let i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t\n        };\n\n        if (typeof dCpts[i].z !== \"undefined\") {\n          dCpts[i] = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n  computeWithRatios: function (t, points, ratios, _3d) {\n    const mt = 1 - t,\n          r = ratios,\n          p = points;\n    let f1 = r[0],\n        f2 = r[1],\n        f3 = r[2],\n        f4 = r[3],\n        d; // spec for linear\n\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t\n      };\n    } // upgrade to quadratic\n\n\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t\n      };\n    } // upgrade to cubic\n\n\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t\n      };\n    }\n  },\n  derive: function (points, _3d) {\n    const dpoints = [];\n\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      const list = [];\n\n      for (let j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y)\n        };\n\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n\n        list.push(dpt);\n      }\n\n      dpoints.push(list);\n      p = list;\n    }\n\n    return dpoints;\n  },\n  between: function (v, m, M) {\n    return m <= v && v <= M || utils.approximately(v, m) || utils.approximately(v, M);\n  },\n  approximately: function (a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n  length: function (derivativeFn) {\n    const z = 0.5,\n          len = utils.Tvalues.length;\n    let sum = 0;\n\n    for (let i = 0, t; i < len; i++) {\n      t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\n    }\n\n    return z * sum;\n  },\n  map: function (v, ds, de, ts, te) {\n    const d1 = de - ds,\n          d2 = te - ts,\n          v2 = v - ds,\n          r = v2 / d1;\n    return ts + d2 * r;\n  },\n  lerp: function (r, v1, v2) {\n    const ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y)\n    };\n\n    if (!!v1.z && !!v2.z) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n\n    return ret;\n  },\n  pointToString: function (p) {\n    let s = p.x + \"/\" + p.y;\n\n    if (typeof p.z !== \"undefined\") {\n      s += \"/\" + p.z;\n    }\n\n    return s;\n  },\n  pointsToString: function (points) {\n    return \"[\" + points.map(utils.pointToString).join(\", \") + \"]\";\n  },\n  copy: function (obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n  angle: function (o, v1, v2) {\n    const dx1 = v1.x - o.x,\n          dy1 = v1.y - o.y,\n          dx2 = v2.x - o.x,\n          dy2 = v2.y - o.y,\n          cross = dx1 * dy2 - dy1 * dx2,\n          dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n  // round as string, to avoid rounding errors\n  round: function (v, d) {\n    const s = \"\" + v;\n    const pos = s.indexOf(\".\");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n  dist: function (p1, p2) {\n    const dx = p1.x - p2.x,\n          dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n  closest: function (LUT, point) {\n    let mdist = pow(2, 63),\n        mpos,\n        d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return {\n      mdist: mdist,\n      mpos: mpos\n    };\n  },\n  abcratio: function (t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n\n    const bottom = pow(t, n) + pow(1 - t, n),\n          top = bottom - 1;\n    return abs(top / bottom);\n  },\n  projectionratio: function (t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n\n    const top = pow(1 - t, n),\n          bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n          ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n          d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n    if (d == 0) {\n      return false;\n    }\n\n    return {\n      x: nx / d,\n      y: ny / d\n    };\n  },\n  lli4: function (p1, p2, p3, p4) {\n    const x1 = p1.x,\n          y1 = p1.y,\n          x2 = p2.x,\n          y2 = p2.y,\n          x3 = p3.x,\n          y3 = p3.y,\n          x4 = p4.x,\n          y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n  lli: function (v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n  makeline: function (p1, p2) {\n    const x1 = p1.x,\n          y1 = p1.y,\n          x2 = p2.x,\n          y2 = p2.y,\n          dx = (x2 - x1) / 3,\n          dy = (y2 - y1) / 3;\n    return new Bezier(x1, y1, x1 + dx, y1 + dy, x1 + 2 * dx, y1 + 2 * dy, x2, y2);\n  },\n  findbbox: function (sections) {\n    let mx = nMax,\n        my = nMax,\n        MX = nMin,\n        MY = nMin;\n    sections.forEach(function (s) {\n      const bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: {\n        min: mx,\n        mid: (mx + MX) / 2,\n        max: MX,\n        size: MX - mx\n      },\n      y: {\n        min: my,\n        mid: (my + MY) / 2,\n        max: MY,\n        size: MY - my\n      }\n    };\n  },\n  shapeintersections: function (s1, bbox1, s2, bbox2, curveIntersectionThreshold) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    const intersections = [];\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\n\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n  makeshape: function (forward, back, curveIntersectionThreshold) {\n    const bpl = back.points.length;\n    const fpl = forward.points.length;\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    const shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end])\n    };\n\n    shape.intersections = function (s2) {\n      return utils.shapeintersections(shape, shape.bbox, s2, s2.bbox, curveIntersectionThreshold);\n    };\n\n    return shape;\n  },\n  getminmax: function (curve, d, list) {\n    if (!list) return {\n      min: 0,\n      max: 0\n    };\n    let min = nMax,\n        max = nMin,\n        t,\n        c;\n\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n\n    for (let i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n\n      if (c[d] < min) {\n        min = c[d];\n      }\n\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n\n    return {\n      min: min,\n      mid: (min + max) / 2,\n      max: max,\n      size: max - min\n    };\n  },\n  align: function (points, line) {\n    const tx = line.p1.x,\n          ty = line.p1.y,\n          a = -atan2(line.p2.y - ty, line.p2.x - tx),\n          d = function (v) {\n      return {\n        x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n        y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a)\n      };\n    };\n\n    return points.map(d);\n  },\n  roots: function (points, line) {\n    line = line || {\n      p1: {\n        x: 0,\n        y: 0\n      },\n      p2: {\n        x: 1,\n        y: 0\n      }\n    };\n    const order = points.length - 1;\n    const aligned = utils.align(points, line);\n\n    const reduce = function (t) {\n      return 0 <= t && t <= 1;\n    };\n\n    if (order === 2) {\n      const a = aligned[0].y,\n            b = aligned[1].y,\n            c = aligned[2].y,\n            d = a - 2 * b + c;\n\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n              m2 = -a + b,\n              v1 = -(m1 + m2) / d,\n              v2 = -(-m1 + m2) / d;\n        return [v1, v2].filter(reduce);\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\n      }\n\n      return [];\n    } // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n\n\n    const pa = aligned[0].y,\n          pb = aligned[1].y,\n          pc = aligned[2].y,\n          pd = aligned[3].y;\n    let d = -pa + 3 * pb - 3 * pc + pd,\n        a = 3 * pa - 6 * pb + 3 * pc,\n        b = -3 * pa + 3 * pb,\n        c = pa;\n\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        } // linear solution:\n\n\n        return [-c / b].filter(reduce);\n      } // quadratic solution:\n\n\n      const q = sqrt(b * b - 4 * a * c),\n            a2 = 2 * a;\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\n    } // at this point, we know we need a cubic solution:\n\n\n    a /= d;\n    b /= d;\n    c /= d;\n    const p = (3 * b - a * a) / 3,\n          p3 = p / 3,\n          q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n          q2 = q / 2,\n          discriminant = q2 * q2 + p3 * p3 * p3;\n    let u1, v1, x1, x2, x3;\n\n    if (discriminant < 0) {\n      const mp3 = -p / 3,\n            mp33 = mp3 * mp3 * mp3,\n            r = sqrt(mp33),\n            t = -q / (2 * r),\n            cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n            phi = acos(cosphi),\n            crtr = crt(r),\n            t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      const sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n  droots: function (p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      const a = p[0],\n            b = p[1],\n            c = p[2],\n            d = a - 2 * b + c;\n\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n              m2 = -a + b,\n              v1 = -(m1 + m2) / d,\n              v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n\n      return [];\n    } // linear roots are even easier\n\n\n    if (p.length === 2) {\n      const a = p[0],\n            b = p[1];\n\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n\n      return [];\n    }\n\n    return [];\n  },\n  curvature: function (t, d1, d2, _3d, kOnly) {\n    let num,\n        dnm,\n        adk,\n        dk,\n        k = 0,\n        r = 0; //\n    // We're using the following formula for curvature:\n    //\n    //              x'y\" - y'x\"\n    //   k(t) = ------------------\n    //           (x'² + y'²)^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y'z\" - y\"z')² + (z'x\" - z\"x')² + (x'y\" - x\"y')²)\n    //   k(t) = -------------------------------------------------------\n    //                     (x'² + y'² + z'²)^(3/2)\n    //\n\n    const d = utils.compute(t, d1);\n    const dd = utils.compute(t, d2);\n    const qdsum = d.x * d.x + d.y * d.y;\n\n    if (_3d) {\n      num = sqrt(pow(d.y * dd.z - dd.y * d.z, 2) + pow(d.z * dd.x - dd.z * d.x, 2) + pow(d.x * dd.y - dd.x * d.y, 2));\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return {\n        k: 0,\n        r: 0\n      };\n    }\n\n    k = num / dnm;\n    r = dnm / num; // We're also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we're just going to\n    // ballpark it based on an epsilon.\n\n    if (!kOnly) {\n      // compute k'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\n      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n\n    return {\n      k: k,\n      r: r,\n      dk: dk,\n      adk: adk\n    };\n  },\n  inflections: function (points) {\n    if (points.length < 4) return []; // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    const p = utils.align(points, {\n      p1: points[0],\n      p2: points.slice(-1)[0]\n    }),\n          a = p[2].x * p[1].y,\n          b = p[3].x * p[1].y,\n          c = p[1].x * p[2].y,\n          d = p[3].x * p[2].y,\n          v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n          v2 = 18 * (3 * a - b - 3 * c),\n          v3 = 18 * (c - a);\n\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        let t = -v3 / v2;\n        if (0 <= t && t <= 1) return [t];\n      }\n\n      return [];\n    }\n\n    const trm = v2 * v2 - 4 * v1 * v3,\n          sq = Math.sqrt(trm),\n          d2 = 2 * v1;\n    if (utils.approximately(d2, 0)) return [];\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n  bboxoverlap: function (b1, b2) {\n    const dims = [\"x\", \"y\"],\n          len = dims.length;\n\n    for (let i = 0, dim, l, t, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t) >= d) return false;\n    }\n\n    return true;\n  },\n  expandbox: function (bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n  pairiteration: function (c1, c2, curveIntersectionThreshold) {\n    const c1b = c1.bbox(),\n          c2b = c2.bbox(),\n          r = 100000,\n          threshold = curveIntersectionThreshold || 0.5;\n\n    if (c1b.x.size + c1b.y.size < threshold && c2b.x.size + c2b.y.size < threshold) {\n      return [(r * (c1._t1 + c1._t2) / 2 | 0) / r + \"/\" + (r * (c2._t1 + c2._t2) / 2 | 0) / r];\n    }\n\n    let cc1 = c1.split(0.5),\n        cc2 = c2.split(0.5),\n        pairs = [{\n      left: cc1.left,\n      right: cc2.left\n    }, {\n      left: cc1.left,\n      right: cc2.right\n    }, {\n      left: cc1.right,\n      right: cc2.right\n    }, {\n      left: cc1.right,\n      right: cc2.left\n    }];\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n    let results = [];\n    if (pairs.length === 0) return results;\n    pairs.forEach(function (pair) {\n      results = results.concat(utils.pairiteration(pair.left, pair.right, threshold));\n    });\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n    return results;\n  },\n  getccenter: function (p1, p2, p3) {\n    const dx1 = p2.x - p1.x,\n          dy1 = p2.y - p1.y,\n          dx2 = p3.x - p2.x,\n          dy2 = p3.y - p2.y,\n          dx1p = dx1 * cos(quart) - dy1 * sin(quart),\n          dy1p = dx1 * sin(quart) + dy1 * cos(quart),\n          dx2p = dx2 * cos(quart) - dy2 * sin(quart),\n          dy2p = dx2 * sin(quart) + dy2 * cos(quart),\n          // chord midpoints\n    mx1 = (p1.x + p2.x) / 2,\n          my1 = (p1.y + p2.y) / 2,\n          mx2 = (p2.x + p3.x) / 2,\n          my2 = (p2.y + p3.y) / 2,\n          // midpoint offsets\n    mx1n = mx1 + dx1p,\n          my1n = my1 + dy1p,\n          mx2n = mx2 + dx2p,\n          my2n = my2 + dy2p,\n          // intersection of these lines:\n    arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n          r = utils.dist(arc, p1); // arc start/end values, over mid point:\n\n    let s = atan2(p1.y - arc.y, p1.x - arc.x),\n        m = atan2(p2.y - arc.y, p2.x - arc.x),\n        e = atan2(p3.y - arc.y, p3.x - arc.x),\n        _; // determine arc direction (cw/ccw correction)\n\n\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    } // assign and done.\n\n\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n  numberSort: function (a, b) {\n    return a - b;\n  }\n};\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\n\nclass PolyBezier {\n  constructor(curves) {\n    this.curves = [];\n    this._3d = false;\n\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return \"[\" + this.curves.map(function (curve) {\n      return utils.pointsToString(curve.points);\n    }).join(\", \") + \"]\";\n  }\n\n  addCurve(curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n\n  length() {\n    return this.curves.map(function (v) {\n      return v.length();\n    }).reduce(function (a, b) {\n      return a + b;\n    });\n  }\n\n  curve(idx) {\n    return this.curves[idx];\n  }\n\n  bbox() {\n    const c = this.curves;\n    var bbox = c[0].bbox();\n\n    for (var i = 1; i < c.length; i++) {\n      utils.expandbox(bbox, c[i].bbox());\n    }\n\n    return bbox;\n  }\n\n  offset(d) {\n    const offset = [];\n    this.curves.forEach(function (v) {\n      offset.push(...v.offset(d));\n    });\n    return new PolyBezier(offset);\n  }\n\n}\n/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n// math-inlining.\n\n\nconst {\n  abs: abs$1,\n  min,\n  max,\n  cos: cos$1,\n  sin: sin$1,\n  acos: acos$1,\n  sqrt: sqrt$1\n} = Math;\nconst pi$1 = Math.PI;\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\n\nclass Bezier {\n  constructor(coords) {\n    let args = coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");\n        }\n\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");\n        }\n      }\n    }\n\n    const _3d = this._3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z !== \"undefined\";\n\n    const points = this.points = [];\n\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1]\n      };\n\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n\n      points.push(point);\n    }\n\n    const order = this.order = points.length - 1;\n    const dims = this.dims = [\"x\", \"y\"];\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n    const aligned = utils.align(points, {\n      p1: points[0],\n      p2: points[order]\n    });\n    this._linear = !aligned.some(p => abs$1(p.y) > 0.0001);\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } // shortcuts, although they're really dumb\n\n\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    } // real fitting.\n\n\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n\n    const abc = Bezier.getABC(3, S, B, E, t);\n\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n\n    const d2 = d1 * (1 - t) / t;\n    const selen = utils.dist(S, E),\n          lx = (E.x - S.x) / selen,\n          ly = (E.y - S.y) / selen,\n          bx1 = d1 * lx,\n          by1 = d1 * ly,\n          bx2 = d2 * lx,\n          by2 = d2 * ly; // derivation of new hull coordinates\n\n    const e1 = {\n      x: B.x - bx1,\n      y: B.y - by1\n    },\n          e2 = {\n      x: B.x + bx2,\n      y: B.y + by2\n    },\n          A = abc.A,\n          v1 = {\n      x: A.x + (e1.x - A.x) / (1 - t),\n      y: A.y + (e1.y - A.y) / (1 - t)\n    },\n          v2 = {\n      x: A.x + (e2.x - A.x) / t,\n      y: A.y + (e2.y - A.y) / t\n    },\n          nc1 = {\n      x: S.x + (v1.x - S.x) / t,\n      y: S.y + (v1.y - S.y) / t\n    },\n          nc2 = {\n      x: E.x + (v2.x - E.x) / (1 - t),\n      y: E.y + (v2.y - E.y) / (1 - t)\n    }; // ...done\n\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n          x = p[0].x,\n          y = p[0].y,\n          s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points.map(function (c, pos) {\n      return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n    }).join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n          um = 1 - u,\n          C = {\n      x: u * S.x + um * E.x,\n      y: u * S.y + um * E.y\n    },\n          s = utils.abcratio(t, order),\n          A = {\n      x: B.x + (B.x - C.x) / s,\n      y: B.y + (B.y - C.y) / s\n    };\n    return {\n      A,\n      B,\n      C,\n      S,\n      E\n    };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n\n    if (this._lut.length === steps) {\n      return this._lut;\n    }\n\n    this._lut = []; // We want a range from 0 to 1 inclusive, so\n    // we decrement and then use <= rather than <:\n\n    steps--;\n\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n\n      this._lut.push(p);\n    }\n\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n          hits = [];\n\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n\n    if (!hits.length) return false;\n    return t /= hits.length;\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n          l = LUT.length - 1,\n          closest = utils.closest(LUT, point),\n          mpos = closest.mpos,\n          t1 = (mpos - 1) / l,\n          t2 = (mpos + 1) / l,\n          step = 0.1 / l; // step 2: fine check\n\n    let mdist = closest.mdist,\n        t = t1,\n        ft = t,\n        p;\n    mdist += 1;\n\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n          np = [p[0]],\n          k = p.length;\n\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: (k - i) / k * pi.x + i / k * pim.x,\n        y: (k - i) / k * pi.y + i / k * pim.y\n      };\n    }\n\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0]);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1]);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, {\n      p1: p[0],\n      p2: p[p.length - 1]\n    }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt$1(d.x * d.x + d.y * d.y);\n    return {\n      x: -d.y / q,\n      y: d.x / q\n    };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n          r2 = this.derivative(t + 0.01),\n          q1 = sqrt$1(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n          q2 = sqrt$1(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2; // cross product\n\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x\n    };\n    const m = sqrt$1(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m; // rotation matrix\n\n    const R = [c.x * c.x, c.x * c.y - c.z, c.x * c.z + c.y, c.x * c.y + c.z, c.y * c.y, c.y * c.z - c.x, c.x * c.z - c.y, c.y * c.z + c.x, c.z * c.z]; // normal vector:\n\n    const n = {\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n        _p = [],\n        q = [],\n        idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    } // we lerp between all points at each iteration, until we have 1 point left.\n\n\n    while (p.length > 1) {\n      _p = [];\n\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n\n        _p.push(pt);\n      }\n\n      p = _p;\n    }\n\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n\n    if (t2 === 1) {\n      return this.split(t1).right;\n    } // no shortcut: use \"de Casteljau\" iteration.\n\n\n    const q = this.hull(t1);\n    const result = {\n      left: this.order === 2 ? new Bezier([q[0], q[3], q[5]]) : new Bezier([q[0], q[4], q[7], q[9]]),\n      right: this.order === 2 ? new Bezier([q[5], q[4], q[2]]) : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q\n    }; // make sure we bind _t1/_t2 information!\n\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2); // if we have no t2, we're done\n\n    if (!t2) {\n      return result;\n    } // if we have a t2, split again:\n\n\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n    this.dims.forEach(function (dim) {\n      let mfn = function (v) {\n        return v[dim];\n      };\n\n      let p = this.dpoints[0].map(mfn);\n      result[dim] = utils.droots(p);\n\n      if (this.order === 3) {\n        p = this.dpoints[1].map(mfn);\n        result[dim] = result[dim].concat(utils.droots(p));\n      }\n\n      result[dim] = result[dim].filter(function (t) {\n        return t >= 0 && t <= 1;\n      });\n      roots = roots.concat(result[dim].sort(utils.numberSort));\n    }.bind(this));\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n          result = {};\n    this.dims.forEach(function (d) {\n      result[d] = utils.getminmax(this, d, extrema[d]);\n    }.bind(this));\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n          tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n            n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d\n      };\n\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n\n      return ret;\n    }\n\n    if (this._linear) {\n      const nv = this.normal(0),\n            coords = this.points.map(function (p) {\n        const ret = {\n          x: p.x + t * nv.x,\n          y: p.y + t * nv.y\n        };\n\n        if (p.z && nv.z) {\n          ret.z = p.z + t * nv.z;\n        }\n\n        return ret;\n      });\n      return [new Bezier(coords)];\n    }\n\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if (a1 > 0 && a2 < 0 || a1 < 0 && a2 > 0) return false;\n    }\n\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n\n    return abs$1(acos$1(s)) < pi$1 / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n        t1 = 0,\n        t2 = 0,\n        step = 0.01,\n        segment,\n        pass1 = [],\n        pass2 = []; // first pass: split on extrema\n\n    let extrema = this.extrema().values;\n\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    } // second pass: further reduce these segments to simple segments\n\n\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n\n          if (!segment.simple()) {\n            t2 -= step;\n\n            if (abs$1(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    } // TODO: add special handling for degenerate (=linear) curves.\n\n\n    const clockwise = this.clockwise;\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const points = this.points;\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    } // move all points by distance 'd' wrt the origin 'o'\n    // move end points by fixed distance along normal.\n\n\n    [0, 1].forEach(function (t) {\n      const p = np[t * order] = utils.copy(points[t * order]);\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach(t => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = {\n          x: p.x + d.x,\n          y: p.y + d.y\n        };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    } // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n\n\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt$1(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = typeof d2 === \"undefined\" ? d1 : d2;\n    const reduced = this.reduce(),\n          len = reduced.length,\n          fcurves = [];\n    let bcurves = [],\n        p,\n        alen = 0,\n        tlen = this.length();\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n              f2 = (alen + slen) / tlen,\n              d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    } // form curve oulines\n\n\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n\n      if (graduated) {\n        fcurves.push(segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen)));\n        bcurves.push(segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen)));\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n\n      alen += slen;\n    }); // reverse the \"return\" outline\n\n    bcurves = bcurves.map(function (s) {\n      p = s.points;\n\n      if (p[3]) {\n        s.points = [p[3], p[2], p[1], p[0]];\n      } else {\n        s.points = [p[2], p[1], p[0]];\n      }\n\n      return s;\n    }).reverse(); // form the endcaps as lines\n\n    const fs = fcurves[0].points[0],\n          fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n          bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n          be = bcurves[0].points[0],\n          ls = utils.makeline(bs, fs),\n          le = utils.makeline(fe, be),\n          segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(outline[i], outline[len - i], curveIntersectionThreshold);\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n\n    return this.curveintersects(this.reduce(), curve, curveIntersectionThreshold);\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n          my = min(line.p1.y, line.p2.y),\n          MX = max(line.p1.x, line.p2.x),\n          MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter(t => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n    const reduced = this.reduce(),\n          len = reduced.length - 2,\n          results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = []; // step 1: pair off any overlapping segments\n\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({\n            left: l,\n            right: r\n          });\n        }\n      });\n    }); // step 2: for each pairing, run through the convergence algorithm.\n\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(pair.left, pair.right, curveIntersectionThreshold);\n\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n          c1 = this.get(s + q),\n          c2 = this.get(e - q),\n          ref = utils.dist(pc, np1),\n          d1 = utils.dist(pc, c1),\n          d2 = utils.dist(pc, c2);\n    return abs$1(d1 - ref) + abs$1(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n        t_e = 1,\n        safety; // we do a binary search to find the \"good `t` closest to no-longer-good\"\n\n    do {\n      safety = 0; // step 1: start with the maximum possible arc\n\n      t_e = 1; // points:\n\n      let np1 = this.get(t_s),\n          np2,\n          np3,\n          arc,\n          prev_arc; // booleans:\n\n      let curr_good = false,\n          prev_good = false,\n          done; // numbers:\n\n      let t_m = t_e,\n          prev_e = 1; // step 2: find the best possible arc\n\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n        arc = utils.getccenter(np1, np2, np3); //also save the t values\n\n        arc.interval = {\n          start: t_s,\n          end: t_e\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n\n        curr_good = error <= errorThreshold;\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e; // this arc is fine: we can move 'e' up to see if we can find a wider arc\n\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc; // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos$1(arc.e),\n                y: arc.y + arc.r * sin$1(arc.e)\n              };\n              arc.e += utils.angle({\n                x: arc.x,\n                y: arc.y\n              }, d, this.get(1));\n            }\n\n            break;\n          } // if not, move it up by half the iteration distance\n\n\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      } // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n\n    return circles;\n  }\n\n}\n\nexports.Bezier = Bezier;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}