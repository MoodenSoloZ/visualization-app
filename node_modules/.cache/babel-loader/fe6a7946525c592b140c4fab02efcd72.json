{"ast":null,"code":"import _regeneratorRuntime from \"/Users/weihangzhang/Documents/webpage/visualization-app-git/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"/Users/weihangzhang/Documents/webpage/visualization-app-git/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/visualization-app-git/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/visualization-app-git/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport DebugLogger from \"debug\";\nimport { multicast, Observable, Subject } from \"observable-fns\";\nimport { allSettled } from \"../ponyfills\";\nimport { defaultPoolSize } from \"./implementation\";\nimport { PoolEventType } from \"./pool-types\";\nimport { Thread } from \"./thread\";\nexport { PoolEventType, Thread };\nvar nextPoolID = 1;\nfunction createArray(size) {\n  var array = [];\n  for (var index = 0; index < size; index++) {\n    array.push(index);\n  }\n  return array;\n}\nfunction delay(ms) {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, ms);\n  });\n}\nfunction flatMap(array, mapper) {\n  return array.reduce(function (flattened, element) {\n    return [].concat(_toConsumableArray(flattened), _toConsumableArray(mapper(element)));\n  }, []);\n}\nfunction slugify(text) {\n  return text.replace(/\\W/g, \" \").trim().replace(/\\s+/g, \"-\");\n}\nfunction spawnWorkers(spawnWorker, count) {\n  return createArray(count).map(function () {\n    return {\n      init: spawnWorker(),\n      runningTasks: []\n    };\n  });\n}\nvar WorkerPool = /*#__PURE__*/function () {\n  function WorkerPool(spawnWorker, optionsOrSize) {\n    var _this = this;\n    _classCallCheck(this, WorkerPool);\n    this.eventSubject = new Subject();\n    this.initErrors = [];\n    this.isClosing = false;\n    this.nextTaskID = 1;\n    this.taskQueue = [];\n    var options = typeof optionsOrSize === \"number\" ? {\n      size: optionsOrSize\n    } : optionsOrSize || {};\n    var _options$size = options.size,\n      size = _options$size === void 0 ? defaultPoolSize : _options$size;\n    this.debug = DebugLogger(\"threads:pool:\".concat(slugify(options.name || String(nextPoolID++))));\n    this.options = options;\n    this.workers = spawnWorkers(spawnWorker, size);\n    this.eventObservable = multicast(Observable.from(this.eventSubject));\n    Promise.all(this.workers.map(function (worker) {\n      return worker.init;\n    })).then(function () {\n      return _this.eventSubject.next({\n        type: PoolEventType.initialized,\n        size: _this.workers.length\n      });\n    }, function (error) {\n      _this.debug(\"Error while initializing pool worker:\", error);\n      _this.eventSubject.error(error);\n      _this.initErrors.push(error);\n    });\n  }\n  _createClass(WorkerPool, [{\n    key: \"findIdlingWorker\",\n    value: function findIdlingWorker() {\n      var _this$options$concurr = this.options.concurrency,\n        concurrency = _this$options$concurr === void 0 ? 1 : _this$options$concurr;\n      return this.workers.find(function (worker) {\n        return worker.runningTasks.length < concurrency;\n      });\n    }\n  }, {\n    key: \"runPoolTask\",\n    value: function runPoolTask(worker, task) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var workerID, returnValue;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                workerID = this.workers.indexOf(worker) + 1;\n                this.debug(\"Running task #\".concat(task.id, \" on worker #\").concat(workerID, \"...\"));\n                this.eventSubject.next({\n                  type: PoolEventType.taskStart,\n                  taskID: task.id,\n                  workerID: workerID\n                });\n                _context.prev = 3;\n                _context.t0 = task;\n                _context.next = 7;\n                return worker.init;\n              case 7:\n                _context.t1 = _context.sent;\n                _context.next = 10;\n                return _context.t0.run.call(_context.t0, _context.t1);\n              case 10:\n                returnValue = _context.sent;\n                this.debug(\"Task #\".concat(task.id, \" completed successfully\"));\n                this.eventSubject.next({\n                  type: PoolEventType.taskCompleted,\n                  returnValue: returnValue,\n                  taskID: task.id,\n                  workerID: workerID\n                });\n                _context.next = 19;\n                break;\n              case 15:\n                _context.prev = 15;\n                _context.t2 = _context[\"catch\"](3);\n                this.debug(\"Task #\".concat(task.id, \" failed\"));\n                this.eventSubject.next({\n                  type: PoolEventType.taskFailed,\n                  taskID: task.id,\n                  error: _context.t2,\n                  workerID: workerID\n                });\n              case 19:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[3, 15]]);\n      }));\n    }\n  }, {\n    key: \"run\",\n    value: function run(worker, task) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var _this2 = this;\n        var runPromise;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                runPromise = function () {\n                  return __awaiter(_this2, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                    var removeTaskFromWorkersRunningTasks;\n                    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            removeTaskFromWorkersRunningTasks = function removeTaskFromWorkersRunningTasks() {\n                              worker.runningTasks = worker.runningTasks.filter(function (someRunPromise) {\n                                return someRunPromise !== runPromise;\n                              });\n                            }; // Defer task execution by one tick to give handlers time to subscribe\n                            _context2.next = 3;\n                            return delay(0);\n                          case 3:\n                            _context2.prev = 3;\n                            _context2.next = 6;\n                            return this.runPoolTask(worker, task);\n                          case 6:\n                            _context2.prev = 6;\n                            removeTaskFromWorkersRunningTasks();\n                            if (!this.isClosing) {\n                              this.scheduleWork();\n                            }\n                            return _context2.finish(6);\n                          case 10:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2, this, [[3,, 6, 10]]);\n                  }));\n                }();\n                worker.runningTasks.push(runPromise);\n              case 2:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n    }\n  }, {\n    key: \"scheduleWork\",\n    value: function scheduleWork() {\n      this.debug(\"Attempt de-queueing a task in order to run it...\");\n      var availableWorker = this.findIdlingWorker();\n      if (!availableWorker) return;\n      var nextTask = this.taskQueue.shift();\n      if (!nextTask) {\n        this.debug(\"Task queue is empty\");\n        this.eventSubject.next({\n          type: PoolEventType.taskQueueDrained\n        });\n        return;\n      }\n      this.run(availableWorker, nextTask);\n    }\n  }, {\n    key: \"taskCompletion\",\n    value: function taskCompletion(taskID) {\n      var _this3 = this;\n      return new Promise(function (resolve, reject) {\n        var eventSubscription = _this3.events().subscribe(function (event) {\n          if (event.type === PoolEventType.taskCompleted && event.taskID === taskID) {\n            eventSubscription.unsubscribe();\n            resolve(event.returnValue);\n          } else if (event.type === PoolEventType.taskFailed && event.taskID === taskID) {\n            eventSubscription.unsubscribe();\n            reject(event.error);\n          } else if (event.type === PoolEventType.terminated) {\n            eventSubscription.unsubscribe();\n            reject(Error(\"Pool has been terminated before task was run.\"));\n          }\n        });\n      });\n    }\n  }, {\n    key: \"settled\",\n    value: function settled() {\n      var allowResolvingImmediately = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _this4 = this;\n        var getCurrentlyRunningTasks, taskFailures, failureSubscription;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                getCurrentlyRunningTasks = function getCurrentlyRunningTasks() {\n                  return flatMap(_this4.workers, function (worker) {\n                    return worker.runningTasks;\n                  });\n                };\n                taskFailures = [];\n                failureSubscription = this.eventObservable.subscribe(function (event) {\n                  if (event.type === PoolEventType.taskFailed) {\n                    taskFailures.push(event.error);\n                  }\n                });\n                if (!(this.initErrors.length > 0)) {\n                  _context4.next = 5;\n                  break;\n                }\n                return _context4.abrupt(\"return\", Promise.reject(this.initErrors[0]));\n              case 5:\n                if (!(allowResolvingImmediately && this.taskQueue.length === 0)) {\n                  _context4.next = 9;\n                  break;\n                }\n                _context4.next = 8;\n                return allSettled(getCurrentlyRunningTasks());\n              case 8:\n                return _context4.abrupt(\"return\", taskFailures);\n              case 9:\n                _context4.next = 11;\n                return new Promise(function (resolve, reject) {\n                  var subscription = _this4.eventObservable.subscribe({\n                    next: function next(event) {\n                      if (event.type === PoolEventType.taskQueueDrained) {\n                        subscription.unsubscribe();\n                        resolve(void 0);\n                      }\n                    },\n                    error: reject // make a pool-wide error reject the completed() result promise\n                  });\n                });\n              case 11:\n                _context4.next = 13;\n                return allSettled(getCurrentlyRunningTasks());\n              case 13:\n                failureSubscription.unsubscribe();\n                return _context4.abrupt(\"return\", taskFailures);\n              case 15:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n  }, {\n    key: \"completed\",\n    value: function completed() {\n      var allowResolvingImmediately = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var _this5 = this;\n        var settlementPromise, earlyExitPromise, errors;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                settlementPromise = this.settled(allowResolvingImmediately);\n                earlyExitPromise = new Promise(function (resolve, reject) {\n                  var subscription = _this5.eventObservable.subscribe({\n                    next: function next(event) {\n                      if (event.type === PoolEventType.taskQueueDrained) {\n                        subscription.unsubscribe();\n                        resolve(settlementPromise);\n                      } else if (event.type === PoolEventType.taskFailed) {\n                        subscription.unsubscribe();\n                        reject(event.error);\n                      }\n                    },\n                    error: reject // make a pool-wide error reject the completed() result promise\n                  });\n                });\n                _context5.next = 4;\n                return Promise.race([settlementPromise, earlyExitPromise]);\n              case 4:\n                errors = _context5.sent;\n                if (!(errors.length > 0)) {\n                  _context5.next = 7;\n                  break;\n                }\n                throw errors[0];\n              case 7:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n    }\n  }, {\n    key: \"events\",\n    value: function events() {\n      return this.eventObservable;\n    }\n  }, {\n    key: \"queue\",\n    value: function queue(taskFunction) {\n      var _this6 = this;\n      var _this$options$maxQueu = this.options.maxQueuedJobs,\n        maxQueuedJobs = _this$options$maxQueu === void 0 ? Infinity : _this$options$maxQueu;\n      if (this.isClosing) {\n        throw Error(\"Cannot schedule pool tasks after terminate() has been called.\");\n      }\n      if (this.initErrors.length > 0) {\n        throw this.initErrors[0];\n      }\n      var taskID = this.nextTaskID++;\n      var taskCompletion = this.taskCompletion(taskID);\n      taskCompletion.catch(function (error) {\n        // Prevent unhandled rejections here as we assume the user will use\n        // `pool.completed()`, `pool.settled()` or `task.catch()` to handle errors\n        _this6.debug(\"Task #\".concat(taskID, \" errored:\"), error);\n      });\n      var task = {\n        id: taskID,\n        run: taskFunction,\n        cancel: function cancel() {\n          if (_this6.taskQueue.indexOf(task) === -1) return;\n          _this6.taskQueue = _this6.taskQueue.filter(function (someTask) {\n            return someTask !== task;\n          });\n          _this6.eventSubject.next({\n            type: PoolEventType.taskCanceled,\n            taskID: task.id\n          });\n        },\n        then: taskCompletion.then.bind(taskCompletion)\n      };\n      if (this.taskQueue.length >= maxQueuedJobs) {\n        throw Error(\"Maximum number of pool tasks queued. Refusing to queue another one.\\n\" + \"This usually happens for one of two reasons: We are either at peak \" + \"workload right now or some tasks just won't finish, thus blocking the pool.\");\n      }\n      this.debug(\"Queueing task #\".concat(task.id, \"...\"));\n      this.taskQueue.push(task);\n      this.eventSubject.next({\n        type: PoolEventType.taskQueued,\n        taskID: task.id\n      });\n      this.scheduleWork();\n      return task;\n    }\n  }, {\n    key: \"terminate\",\n    value: function terminate(force) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var _this7 = this;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                this.isClosing = true;\n                if (force) {\n                  _context7.next = 4;\n                  break;\n                }\n                _context7.next = 4;\n                return this.completed(true);\n              case 4:\n                this.eventSubject.next({\n                  type: PoolEventType.terminated,\n                  remainingQueue: _toConsumableArray(this.taskQueue)\n                });\n                this.eventSubject.complete();\n                _context7.next = 8;\n                return Promise.all(this.workers.map(function (worker) {\n                  return __awaiter(_this7, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n                    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n                      while (1) {\n                        switch (_context6.prev = _context6.next) {\n                          case 0:\n                            _context6.t0 = Thread;\n                            _context6.next = 3;\n                            return worker.init;\n                          case 3:\n                            _context6.t1 = _context6.sent;\n                            return _context6.abrupt(\"return\", _context6.t0.terminate.call(_context6.t0, _context6.t1));\n                          case 5:\n                          case \"end\":\n                            return _context6.stop();\n                        }\n                      }\n                    }, _callee6);\n                  }));\n                }));\n              case 8:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n    }\n  }]);\n  return WorkerPool;\n}();\nWorkerPool.EventType = PoolEventType;\n/**\n * Thread pool constructor. Creates a new pool and spawns its worker threads.\n */\nfunction PoolConstructor(spawnWorker, optionsOrSize) {\n  // The function exists only so we don't need to use `new` to create a pool (we still can, though).\n  // If the Pool is a class or not is an implementation detail that should not concern the user.\n  return new WorkerPool(spawnWorker, optionsOrSize);\n}\nPoolConstructor.EventType = PoolEventType;\n/**\n * Thread pool constructor. Creates a new pool and spawns its worker threads.\n */\nexport var Pool = PoolConstructor;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","DebugLogger","multicast","Observable","Subject","allSettled","defaultPoolSize","PoolEventType","Thread","nextPoolID","createArray","size","array","index","push","delay","ms","setTimeout","flatMap","mapper","reduce","flattened","element","slugify","text","replace","trim","spawnWorkers","spawnWorker","count","map","init","runningTasks","WorkerPool","optionsOrSize","eventSubject","initErrors","isClosing","nextTaskID","taskQueue","options","debug","name","String","workers","eventObservable","from","all","worker","type","initialized","length","error","concurrency","find","task","workerID","indexOf","id","taskStart","taskID","run","returnValue","taskCompleted","taskFailed","runPromise","removeTaskFromWorkersRunningTasks","filter","someRunPromise","runPoolTask","scheduleWork","availableWorker","findIdlingWorker","nextTask","shift","taskQueueDrained","eventSubscription","events","subscribe","event","unsubscribe","terminated","Error","allowResolvingImmediately","getCurrentlyRunningTasks","taskFailures","failureSubscription","subscription","settlementPromise","settled","earlyExitPromise","race","errors","taskFunction","maxQueuedJobs","Infinity","taskCompletion","catch","cancel","someTask","taskCanceled","bind","taskQueued","force","completed","remainingQueue","complete","terminate","EventType","PoolConstructor","Pool"],"sources":["/Users/weihangzhang/Documents/webpage/visualization-app-git/node_modules/gosling.js/node_modules/threads/dist-esm/master/pool.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport DebugLogger from \"debug\";\nimport { multicast, Observable, Subject } from \"observable-fns\";\nimport { allSettled } from \"../ponyfills\";\nimport { defaultPoolSize } from \"./implementation\";\nimport { PoolEventType } from \"./pool-types\";\nimport { Thread } from \"./thread\";\nexport { PoolEventType, Thread };\nlet nextPoolID = 1;\nfunction createArray(size) {\n    const array = [];\n    for (let index = 0; index < size; index++) {\n        array.push(index);\n    }\n    return array;\n}\nfunction delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\nfunction flatMap(array, mapper) {\n    return array.reduce((flattened, element) => [...flattened, ...mapper(element)], []);\n}\nfunction slugify(text) {\n    return text.replace(/\\W/g, \" \").trim().replace(/\\s+/g, \"-\");\n}\nfunction spawnWorkers(spawnWorker, count) {\n    return createArray(count).map(() => ({\n        init: spawnWorker(),\n        runningTasks: []\n    }));\n}\nclass WorkerPool {\n    constructor(spawnWorker, optionsOrSize) {\n        this.eventSubject = new Subject();\n        this.initErrors = [];\n        this.isClosing = false;\n        this.nextTaskID = 1;\n        this.taskQueue = [];\n        const options = typeof optionsOrSize === \"number\"\n            ? { size: optionsOrSize }\n            : optionsOrSize || {};\n        const { size = defaultPoolSize } = options;\n        this.debug = DebugLogger(`threads:pool:${slugify(options.name || String(nextPoolID++))}`);\n        this.options = options;\n        this.workers = spawnWorkers(spawnWorker, size);\n        this.eventObservable = multicast(Observable.from(this.eventSubject));\n        Promise.all(this.workers.map(worker => worker.init)).then(() => this.eventSubject.next({\n            type: PoolEventType.initialized,\n            size: this.workers.length\n        }), error => {\n            this.debug(\"Error while initializing pool worker:\", error);\n            this.eventSubject.error(error);\n            this.initErrors.push(error);\n        });\n    }\n    findIdlingWorker() {\n        const { concurrency = 1 } = this.options;\n        return this.workers.find(worker => worker.runningTasks.length < concurrency);\n    }\n    runPoolTask(worker, task) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const workerID = this.workers.indexOf(worker) + 1;\n            this.debug(`Running task #${task.id} on worker #${workerID}...`);\n            this.eventSubject.next({\n                type: PoolEventType.taskStart,\n                taskID: task.id,\n                workerID\n            });\n            try {\n                const returnValue = yield task.run(yield worker.init);\n                this.debug(`Task #${task.id} completed successfully`);\n                this.eventSubject.next({\n                    type: PoolEventType.taskCompleted,\n                    returnValue,\n                    taskID: task.id,\n                    workerID\n                });\n            }\n            catch (error) {\n                this.debug(`Task #${task.id} failed`);\n                this.eventSubject.next({\n                    type: PoolEventType.taskFailed,\n                    taskID: task.id,\n                    error,\n                    workerID\n                });\n            }\n        });\n    }\n    run(worker, task) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const runPromise = (() => __awaiter(this, void 0, void 0, function* () {\n                const removeTaskFromWorkersRunningTasks = () => {\n                    worker.runningTasks = worker.runningTasks.filter(someRunPromise => someRunPromise !== runPromise);\n                };\n                // Defer task execution by one tick to give handlers time to subscribe\n                yield delay(0);\n                try {\n                    yield this.runPoolTask(worker, task);\n                }\n                finally {\n                    removeTaskFromWorkersRunningTasks();\n                    if (!this.isClosing) {\n                        this.scheduleWork();\n                    }\n                }\n            }))();\n            worker.runningTasks.push(runPromise);\n        });\n    }\n    scheduleWork() {\n        this.debug(`Attempt de-queueing a task in order to run it...`);\n        const availableWorker = this.findIdlingWorker();\n        if (!availableWorker)\n            return;\n        const nextTask = this.taskQueue.shift();\n        if (!nextTask) {\n            this.debug(`Task queue is empty`);\n            this.eventSubject.next({ type: PoolEventType.taskQueueDrained });\n            return;\n        }\n        this.run(availableWorker, nextTask);\n    }\n    taskCompletion(taskID) {\n        return new Promise((resolve, reject) => {\n            const eventSubscription = this.events().subscribe(event => {\n                if (event.type === PoolEventType.taskCompleted && event.taskID === taskID) {\n                    eventSubscription.unsubscribe();\n                    resolve(event.returnValue);\n                }\n                else if (event.type === PoolEventType.taskFailed && event.taskID === taskID) {\n                    eventSubscription.unsubscribe();\n                    reject(event.error);\n                }\n                else if (event.type === PoolEventType.terminated) {\n                    eventSubscription.unsubscribe();\n                    reject(Error(\"Pool has been terminated before task was run.\"));\n                }\n            });\n        });\n    }\n    settled(allowResolvingImmediately = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const getCurrentlyRunningTasks = () => flatMap(this.workers, worker => worker.runningTasks);\n            const taskFailures = [];\n            const failureSubscription = this.eventObservable.subscribe(event => {\n                if (event.type === PoolEventType.taskFailed) {\n                    taskFailures.push(event.error);\n                }\n            });\n            if (this.initErrors.length > 0) {\n                return Promise.reject(this.initErrors[0]);\n            }\n            if (allowResolvingImmediately && this.taskQueue.length === 0) {\n                yield allSettled(getCurrentlyRunningTasks());\n                return taskFailures;\n            }\n            yield new Promise((resolve, reject) => {\n                const subscription = this.eventObservable.subscribe({\n                    next(event) {\n                        if (event.type === PoolEventType.taskQueueDrained) {\n                            subscription.unsubscribe();\n                            resolve(void 0);\n                        }\n                    },\n                    error: reject // make a pool-wide error reject the completed() result promise\n                });\n            });\n            yield allSettled(getCurrentlyRunningTasks());\n            failureSubscription.unsubscribe();\n            return taskFailures;\n        });\n    }\n    completed(allowResolvingImmediately = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const settlementPromise = this.settled(allowResolvingImmediately);\n            const earlyExitPromise = new Promise((resolve, reject) => {\n                const subscription = this.eventObservable.subscribe({\n                    next(event) {\n                        if (event.type === PoolEventType.taskQueueDrained) {\n                            subscription.unsubscribe();\n                            resolve(settlementPromise);\n                        }\n                        else if (event.type === PoolEventType.taskFailed) {\n                            subscription.unsubscribe();\n                            reject(event.error);\n                        }\n                    },\n                    error: reject // make a pool-wide error reject the completed() result promise\n                });\n            });\n            const errors = yield Promise.race([\n                settlementPromise,\n                earlyExitPromise\n            ]);\n            if (errors.length > 0) {\n                throw errors[0];\n            }\n        });\n    }\n    events() {\n        return this.eventObservable;\n    }\n    queue(taskFunction) {\n        const { maxQueuedJobs = Infinity } = this.options;\n        if (this.isClosing) {\n            throw Error(`Cannot schedule pool tasks after terminate() has been called.`);\n        }\n        if (this.initErrors.length > 0) {\n            throw this.initErrors[0];\n        }\n        const taskID = this.nextTaskID++;\n        const taskCompletion = this.taskCompletion(taskID);\n        taskCompletion.catch((error) => {\n            // Prevent unhandled rejections here as we assume the user will use\n            // `pool.completed()`, `pool.settled()` or `task.catch()` to handle errors\n            this.debug(`Task #${taskID} errored:`, error);\n        });\n        const task = {\n            id: taskID,\n            run: taskFunction,\n            cancel: () => {\n                if (this.taskQueue.indexOf(task) === -1)\n                    return;\n                this.taskQueue = this.taskQueue.filter(someTask => someTask !== task);\n                this.eventSubject.next({\n                    type: PoolEventType.taskCanceled,\n                    taskID: task.id\n                });\n            },\n            then: taskCompletion.then.bind(taskCompletion)\n        };\n        if (this.taskQueue.length >= maxQueuedJobs) {\n            throw Error(\"Maximum number of pool tasks queued. Refusing to queue another one.\\n\" +\n                \"This usually happens for one of two reasons: We are either at peak \" +\n                \"workload right now or some tasks just won't finish, thus blocking the pool.\");\n        }\n        this.debug(`Queueing task #${task.id}...`);\n        this.taskQueue.push(task);\n        this.eventSubject.next({\n            type: PoolEventType.taskQueued,\n            taskID: task.id\n        });\n        this.scheduleWork();\n        return task;\n    }\n    terminate(force) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.isClosing = true;\n            if (!force) {\n                yield this.completed(true);\n            }\n            this.eventSubject.next({\n                type: PoolEventType.terminated,\n                remainingQueue: [...this.taskQueue]\n            });\n            this.eventSubject.complete();\n            yield Promise.all(this.workers.map((worker) => __awaiter(this, void 0, void 0, function* () { return Thread.terminate(yield worker.init); })));\n        });\n    }\n}\nWorkerPool.EventType = PoolEventType;\n/**\n * Thread pool constructor. Creates a new pool and spawns its worker threads.\n */\nfunction PoolConstructor(spawnWorker, optionsOrSize) {\n    // The function exists only so we don't need to use `new` to create a pool (we still can, though).\n    // If the Pool is a class or not is an implementation detail that should not concern the user.\n    return new WorkerPool(spawnWorker, optionsOrSize);\n}\nPoolConstructor.EventType = PoolEventType;\n/**\n * Thread pool constructor. Creates a new pool and spawns its worker threads.\n */\nexport const Pool = PoolConstructor;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}