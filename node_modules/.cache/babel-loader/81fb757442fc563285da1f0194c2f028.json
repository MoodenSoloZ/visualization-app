{"ast":null,"code":"import { stringValue } from 'vega-util';\nimport { TUPLE, unitName } from '.';\nimport { SELECTION_ID } from '../../selection';\nimport { vals } from '../../util';\nimport { BRUSH } from './interval';\nimport { TUPLE_FIELDS } from './project';\nvar point = {\n  defined: function defined(selCmpt) {\n    return selCmpt.type === 'point';\n  },\n  signals: function signals(model, selCmpt, _signals) {\n    var _a;\n    var name = selCmpt.name;\n    var fieldsSg = name + TUPLE_FIELDS;\n    var project = selCmpt.project;\n    var datum = '(item().isVoronoi ? datum.datum : datum)';\n    // Only add a discrete selection to the store if a datum is present _and_\n    // the interaction isn't occurring on a group mark. This guards against\n    // polluting interactive state with invalid values in faceted displays\n    // as the group marks are also data-driven. We force the update to account\n    // for constant null states but varying toggles (e.g., shift-click in\n    // whitespace followed by a click in whitespace; the store should only\n    // be cleared on the second click).\n    var brushes = vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {}).reduce(function (acc, cmpt) {\n      return cmpt.type === 'interval' ? acc.concat(cmpt.name + BRUSH) : acc;\n    }, []).map(function (b) {\n      return \"indexof(item().mark.name, '\".concat(b, \"') < 0\");\n    }).join(' && ');\n    var test = \"datum && item().mark.marktype !== 'group' && indexof(item().mark.role, 'legend') < 0\".concat(brushes ? \" && \".concat(brushes) : '');\n    var update = \"unit: \".concat(unitName(model), \", \");\n    if (selCmpt.project.hasSelectionId) {\n      update += \"\".concat(SELECTION_ID, \": \").concat(datum, \"[\").concat(stringValue(SELECTION_ID), \"]\");\n    } else {\n      var values = project.items.map(function (p) {\n        var fieldDef = model.fieldDef(p.channel);\n        // Binned fields should capture extents, for a range test against the raw field.\n        return (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin) ? \"[\".concat(datum, \"[\").concat(stringValue(model.vgField(p.channel, {})), \"], \") + \"\".concat(datum, \"[\").concat(stringValue(model.vgField(p.channel, {\n          binSuffix: 'end'\n        })), \"]]\") : \"\".concat(datum, \"[\").concat(stringValue(p.field), \"]\");\n      }).join(', ');\n      update += \"fields: \".concat(fieldsSg, \", values: [\").concat(values, \"]\");\n    }\n    var events = selCmpt.events;\n    return _signals.concat([{\n      name: name + TUPLE,\n      on: events ? [{\n        events: events,\n        update: \"\".concat(test, \" ? {\").concat(update, \"} : null\"),\n        force: true\n      }] : []\n    }]);\n  }\n};\nexport default point;","map":{"version":3,"sources":["../../../../src/compile/selection/point.ts"],"names":[],"mappings":"AACA,SAAQ,WAAW,QAAO,WAAW;AACrC,SAA2B,KAAK,EAAE,QAAQ,QAAO,GAAG;AACpD,SAAQ,YAAY,QAAO,iBAAiB;AAC5C,SAAQ,IAAI,QAAO,YAAY;AAC/B,SAAQ,KAAK,QAAO,YAAY;AAChC,SAAQ,YAAY,QAAO,WAAW;AAEtC,IAAM,KAAK,GAA+B;EACxC,OAAO,EAAE,iBAAA,OAAO;IAAA,OAAI,OAAO,CAAC,IAAI,KAAK,OAAO;EAAA;EAE5C,OAAO,EAAE,iBAAC,KAAK,EAAE,OAAO,EAAE,QAAO,EAAI;;IACnC,IAAM,IAAI,GAAG,OAAO,CAAC,IAAI;IACzB,IAAM,QAAQ,GAAG,IAAI,GAAG,YAAY;IACpC,IAAM,OAAO,GAAG,OAAO,CAAC,OAAO;IAC/B,IAAM,KAAK,GAAG,0CAA0C;IAExD;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAM,OAAO,GAAG,IAAI,CAAC,CAAA,EAAA,GAAA,KAAK,CAAC,SAAS,CAAC,SAAS,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,CAAA,CAAE,CAAC,CAClD,MAAM,CAAC,UAAC,GAAG,EAAE,IAAI,EAAI;MACpB,OAAO,IAAI,CAAC,IAAI,KAAK,UAAU,GAAG,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,GAAG,GAAG;IACvE,CAAC,EAAE,EAAE,CAAC,CACL,GAAG,CAAC,UAAA,CAAC;MAAA,4CAAkC,CAAC;IAAA,CAAQ,CAAC,CACjD,IAAI,CAAC,MAAM,CAAC;IAEf,IAAM,IAAI,iGACR,OAAO,iBAAU,OAAO,IAAK,EAC/B,CAAE;IAEF,IAAI,MAAM,mBAAY,QAAQ,CAAC,KAAK,CAAC,OAAI;IAEzC,IAAI,OAAO,CAAC,OAAO,CAAC,cAAc,EAAE;MAClC,MAAM,cAAO,YAAY,eAAK,KAAK,cAAI,WAAW,CAAC,YAAY,CAAC,MAAG;KACpE,MAAM;MACL,IAAM,MAAM,GAAG,OAAO,CAAC,KAAK,CACzB,GAAG,CAAC,UAAA,CAAC,EAAG;QACP,IAAM,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,OAAO,CAAC;QAC1C;QACA,OAAO,CAAA,QAAQ,KAAA,IAAA,IAAR,QAAQ,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAR,QAAQ,CAAE,GAAG,IAChB,WAAI,KAAK,cAAI,WAAW,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,OAAO,EAAE,CAAA,CAAE,CAAC,CAAC,qBACjD,KAAK,cAAI,WAAW,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,OAAO,EAAE;UAAC,SAAS,EAAE;QAAK,CAAC,CAAC,CAAC,OAAI,aACxE,KAAK,cAAI,WAAW,CAAC,CAAC,CAAC,KAAK,CAAC,MAAG;MACzC,CAAC,CAAC,CACD,IAAI,CAAC,IAAI,CAAC;MAEb,MAAM,sBAAe,QAAQ,wBAAc,MAAM,MAAG;IACrD;IAED,IAAM,MAAM,GAAa,OAAO,CAAC,MAAM;IACvC,OAAO,QAAO,CAAC,MAAM,CAAC,CACpB;MACE,IAAI,EAAE,IAAI,GAAG,KAAK;MAClB,EAAE,EAAE,MAAM,GACN,CACE;QACE,MAAM,EAAN,MAAM;QACN,MAAM,YAAK,IAAI,iBAAO,MAAM,aAAU;QACtC,KAAK,EAAE;OACR,CACF,GACD;KACL,CACF,CAAC;EACJ;CACD;AAED,eAAe,KAAK","sourceRoot":"","sourcesContent":["import { stringValue } from 'vega-util';\nimport { TUPLE, unitName } from '.';\nimport { SELECTION_ID } from '../../selection';\nimport { vals } from '../../util';\nimport { BRUSH } from './interval';\nimport { TUPLE_FIELDS } from './project';\nconst point = {\n    defined: selCmpt => selCmpt.type === 'point',\n    signals: (model, selCmpt, signals) => {\n        var _a;\n        const name = selCmpt.name;\n        const fieldsSg = name + TUPLE_FIELDS;\n        const project = selCmpt.project;\n        const datum = '(item().isVoronoi ? datum.datum : datum)';\n        // Only add a discrete selection to the store if a datum is present _and_\n        // the interaction isn't occurring on a group mark. This guards against\n        // polluting interactive state with invalid values in faceted displays\n        // as the group marks are also data-driven. We force the update to account\n        // for constant null states but varying toggles (e.g., shift-click in\n        // whitespace followed by a click in whitespace; the store should only\n        // be cleared on the second click).\n        const brushes = vals((_a = model.component.selection) !== null && _a !== void 0 ? _a : {})\n            .reduce((acc, cmpt) => {\n            return cmpt.type === 'interval' ? acc.concat(cmpt.name + BRUSH) : acc;\n        }, [])\n            .map(b => `indexof(item().mark.name, '${b}') < 0`)\n            .join(' && ');\n        const test = `datum && item().mark.marktype !== 'group' && indexof(item().mark.role, 'legend') < 0${brushes ? ` && ${brushes}` : ''}`;\n        let update = `unit: ${unitName(model)}, `;\n        if (selCmpt.project.hasSelectionId) {\n            update += `${SELECTION_ID}: ${datum}[${stringValue(SELECTION_ID)}]`;\n        }\n        else {\n            const values = project.items\n                .map(p => {\n                const fieldDef = model.fieldDef(p.channel);\n                // Binned fields should capture extents, for a range test against the raw field.\n                return (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin)\n                    ? `[${datum}[${stringValue(model.vgField(p.channel, {}))}], ` +\n                        `${datum}[${stringValue(model.vgField(p.channel, { binSuffix: 'end' }))}]]`\n                    : `${datum}[${stringValue(p.field)}]`;\n            })\n                .join(', ');\n            update += `fields: ${fieldsSg}, values: [${values}]`;\n        }\n        const events = selCmpt.events;\n        return signals.concat([\n            {\n                name: name + TUPLE,\n                on: events\n                    ? [\n                        {\n                            events,\n                            update: `${test} ? {${update}} : null`,\n                            force: true\n                        }\n                    ]\n                    : []\n            }\n        ]);\n    }\n};\nexport default point;\n//# sourceMappingURL=point.js.map"]},"metadata":{},"sourceType":"module"}