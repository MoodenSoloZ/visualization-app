{"ast":null,"code":"import _defineProperty from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { isArray, isBoolean, isNumber, isString } from 'vega-util';\nimport { isAggregateOp, isArgmaxDef, isArgminDef, isCountingAggregateOp } from './aggregate';\nimport { autoMaxBins, binToString, isBinned, isBinning } from './bin';\nimport { ANGLE, COLOR, COLUMN, DESCRIPTION, DETAIL, FACET, FILL, FILLOPACITY, getSizeChannel, HREF, isScaleChannel, isSecondaryRangeChannel, isXorY, KEY, LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, OPACITY, ORDER, RADIUS, RADIUS2, ROW, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH, TEXT, THETA, THETA2, TOOLTIP, URL, X, X2, XOFFSET, Y, Y2, YOFFSET } from './channel';\nimport { getMarkConfig, getMarkPropOrConfig } from './compile/common';\nimport { isCustomFormatType } from './compile/format';\nimport { dateTimeToExpr, isDateTime } from './datetime';\nimport { isExprRef } from './expr';\nimport * as log from './log';\nimport { isRectBasedMark } from './mark';\nimport { hasDiscreteDomain, isContinuousToDiscrete, SCALE_CATEGORY_INDEX } from './scale';\nimport { isSortByChannel } from './sort';\nimport { isFacetFieldDef } from './spec/facet';\nimport { getTimeUnitParts, isLocalSingleTimeUnit, normalizeTimeUnit, timeUnitToString } from './timeunit';\nimport { getFullName, QUANTITATIVE } from './type';\nimport { flatAccessWithDatum, getFirstDefined, internalField, omit, removePathFromField, replacePathInField, stringify, titleCase } from './util';\nimport { isSignalRef } from './vega.schema';\nexport function isConditionalParameter(c) {\n  return c['param'];\n}\nexport function isRepeatRef(field) {\n  return field && !isString(field) && 'repeat' in field;\n}\nexport function toFieldDefBase(fieldDef) {\n  var field = fieldDef.field,\n    timeUnit = fieldDef.timeUnit,\n    bin = fieldDef.bin,\n    aggregate = fieldDef.aggregate;\n  return Object.assign(Object.assign(Object.assign(Object.assign({}, timeUnit ? {\n    timeUnit: timeUnit\n  } : {}), bin ? {\n    bin: bin\n  } : {}), aggregate ? {\n    aggregate: aggregate\n  } : {}), {\n    field: field\n  });\n}\nexport function isSortableFieldDef(fieldDef) {\n  return 'sort' in fieldDef;\n}\nexport function getBandPosition(_ref) {\n  var fieldDef = _ref.fieldDef,\n    fieldDef2 = _ref.fieldDef2,\n    mark = _ref.markDef,\n    config = _ref.config;\n  if (isFieldOrDatumDef(fieldDef) && fieldDef.bandPosition !== undefined) {\n    return fieldDef.bandPosition;\n  }\n  if (isFieldDef(fieldDef)) {\n    var timeUnit = fieldDef.timeUnit,\n      bin = fieldDef.bin;\n    if (timeUnit && !fieldDef2) {\n      return isRectBasedMark(mark.type) ? 0 : getMarkConfig('timeUnitBandPosition', mark, config);\n    } else if (isBinning(bin)) {\n      return 0.5;\n    }\n  }\n  return undefined;\n}\nexport function getBandSize(_ref2) {\n  var channel = _ref2.channel,\n    fieldDef = _ref2.fieldDef,\n    fieldDef2 = _ref2.fieldDef2,\n    mark = _ref2.markDef,\n    config = _ref2.config,\n    scaleType = _ref2.scaleType,\n    useVlSizeChannel = _ref2.useVlSizeChannel;\n  var _a, _b, _c;\n  var sizeChannel = getSizeChannel(channel);\n  var size = getMarkPropOrConfig(useVlSizeChannel ? 'size' : sizeChannel, mark, config, {\n    vgChannel: sizeChannel\n  });\n  if (size !== undefined) {\n    return size;\n  }\n  if (isFieldDef(fieldDef)) {\n    var timeUnit = fieldDef.timeUnit,\n      bin = fieldDef.bin;\n    if (timeUnit && !fieldDef2) {\n      return {\n        band: getMarkConfig('timeUnitBandSize', mark, config)\n      };\n    } else if (isBinning(bin) && !hasDiscreteDomain(scaleType)) {\n      return {\n        band: 1\n      };\n    }\n  }\n  if (isRectBasedMark(mark.type)) {\n    if (scaleType) {\n      if (hasDiscreteDomain(scaleType)) {\n        return ((_a = config[mark.type]) === null || _a === void 0 ? void 0 : _a.discreteBandSize) || {\n          band: 1\n        };\n      } else {\n        return (_b = config[mark.type]) === null || _b === void 0 ? void 0 : _b.continuousBandSize;\n      }\n    }\n    return (_c = config[mark.type]) === null || _c === void 0 ? void 0 : _c.discreteBandSize;\n  }\n  return undefined;\n}\nexport function hasBandEnd(fieldDef, fieldDef2, markDef, config) {\n  if (isBinning(fieldDef.bin) || fieldDef.timeUnit && isTypedFieldDef(fieldDef) && fieldDef.type === 'temporal') {\n    // Need to check bandPosition because non-rect marks (e.g., point) with timeUnit\n    // doesn't have to use bandEnd if there is no bandPosition.\n    return getBandPosition({\n      fieldDef: fieldDef,\n      fieldDef2: fieldDef2,\n      markDef: markDef,\n      config: config\n    }) !== undefined;\n  }\n  return false;\n}\nexport function isConditionalDef(channelDef) {\n  return channelDef && 'condition' in channelDef;\n}\n/**\n * Return if a channelDef is a ConditionalValueDef with ConditionFieldDef\n */\nexport function hasConditionalFieldDef(channelDef) {\n  var condition = channelDef === null || channelDef === void 0 ? void 0 : channelDef['condition'];\n  return !!condition && !isArray(condition) && isFieldDef(condition);\n}\nexport function hasConditionalFieldOrDatumDef(channelDef) {\n  var condition = channelDef === null || channelDef === void 0 ? void 0 : channelDef['condition'];\n  return !!condition && !isArray(condition) && isFieldOrDatumDef(condition);\n}\nexport function hasConditionalValueDef(channelDef) {\n  var condition = channelDef === null || channelDef === void 0 ? void 0 : channelDef['condition'];\n  return !!condition && (isArray(condition) || isValueDef(condition));\n}\nexport function isFieldDef(channelDef) {\n  // TODO: we can't use field in channelDef here as it's somehow failing runtime test\n  return channelDef && (!!channelDef['field'] || channelDef['aggregate'] === 'count');\n}\nexport function channelDefType(channelDef) {\n  return channelDef === null || channelDef === void 0 ? void 0 : channelDef['type'];\n}\nexport function isDatumDef(channelDef) {\n  return channelDef && 'datum' in channelDef;\n}\nexport function isContinuousFieldOrDatumDef(cd) {\n  // TODO: make datum support DateTime object\n  return isTypedFieldDef(cd) && !isDiscrete(cd) || isNumericDataDef(cd);\n}\nexport function isQuantitativeFieldOrDatumDef(cd) {\n  // TODO: make datum support DateTime object\n  return channelDefType(cd) === 'quantitative' || isNumericDataDef(cd);\n}\nexport function isNumericDataDef(cd) {\n  return isDatumDef(cd) && isNumber(cd.datum);\n}\nexport function isFieldOrDatumDef(channelDef) {\n  return isFieldDef(channelDef) || isDatumDef(channelDef);\n}\nexport function isTypedFieldDef(channelDef) {\n  return channelDef && ('field' in channelDef || channelDef['aggregate'] === 'count') && 'type' in channelDef;\n}\nexport function isValueDef(channelDef) {\n  return channelDef && 'value' in channelDef && 'value' in channelDef;\n}\nexport function isScaleFieldDef(channelDef) {\n  return channelDef && ('scale' in channelDef || 'sort' in channelDef);\n}\nexport function isPositionFieldOrDatumDef(channelDef) {\n  return channelDef && ('axis' in channelDef || 'stack' in channelDef || 'impute' in channelDef);\n}\nexport function isMarkPropFieldOrDatumDef(channelDef) {\n  return channelDef && 'legend' in channelDef;\n}\nexport function isStringFieldOrDatumDef(channelDef) {\n  return channelDef && ('format' in channelDef || 'formatType' in channelDef);\n}\nexport function toStringFieldDef(fieldDef) {\n  // omit properties that don't exist in string field defs\n  return omit(fieldDef, ['legend', 'axis', 'header', 'scale']);\n}\nfunction isOpFieldDef(fieldDef) {\n  return 'op' in fieldDef;\n}\n/**\n * Get a Vega field reference from a Vega-Lite field def.\n */\nexport function vgField(fieldDef) {\n  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _a, _b, _c;\n  var field = fieldDef.field;\n  var prefix = opt.prefix;\n  var suffix = opt.suffix;\n  var argAccessor = ''; // for accessing argmin/argmax field at the end without getting escaped\n  if (isCount(fieldDef)) {\n    field = internalField('count');\n  } else {\n    var fn;\n    if (!opt.nofn) {\n      if (isOpFieldDef(fieldDef)) {\n        fn = fieldDef.op;\n      } else {\n        var bin = fieldDef.bin,\n          aggregate = fieldDef.aggregate,\n          timeUnit = fieldDef.timeUnit;\n        if (isBinning(bin)) {\n          fn = binToString(bin);\n          suffix = ((_a = opt.binSuffix) !== null && _a !== void 0 ? _a : '') + ((_b = opt.suffix) !== null && _b !== void 0 ? _b : '');\n        } else if (aggregate) {\n          if (isArgmaxDef(aggregate)) {\n            argAccessor = \"[\\\"\".concat(field, \"\\\"]\");\n            field = \"argmax_\".concat(aggregate.argmax);\n          } else if (isArgminDef(aggregate)) {\n            argAccessor = \"[\\\"\".concat(field, \"\\\"]\");\n            field = \"argmin_\".concat(aggregate.argmin);\n          } else {\n            fn = String(aggregate);\n          }\n        } else if (timeUnit) {\n          fn = timeUnitToString(timeUnit);\n          suffix = (!['range', 'mid'].includes(opt.binSuffix) && opt.binSuffix || '') + ((_c = opt.suffix) !== null && _c !== void 0 ? _c : '');\n        }\n      }\n    }\n    if (fn) {\n      field = field ? \"\".concat(fn, \"_\").concat(field) : fn;\n    }\n  }\n  if (suffix) {\n    field = \"\".concat(field, \"_\").concat(suffix);\n  }\n  if (prefix) {\n    field = \"\".concat(prefix, \"_\").concat(field);\n  }\n  if (opt.forAs) {\n    return removePathFromField(field);\n  } else if (opt.expr) {\n    // Expression to access flattened field. No need to escape dots.\n    return flatAccessWithDatum(field, opt.expr) + argAccessor;\n  } else {\n    // We flattened all fields so paths should have become dot.\n    return replacePathInField(field) + argAccessor;\n  }\n}\nexport function isDiscrete(def) {\n  switch (def.type) {\n    case 'nominal':\n    case 'ordinal':\n    case 'geojson':\n      return true;\n    case 'quantitative':\n      return isFieldDef(def) && !!def.bin;\n    case 'temporal':\n      return false;\n  }\n  throw new Error(log.message.invalidFieldType(def.type));\n}\nexport function isDiscretizing(def) {\n  var _a;\n  return isScaleFieldDef(def) && isContinuousToDiscrete((_a = def.scale) === null || _a === void 0 ? void 0 : _a.type);\n}\nexport function isCount(fieldDef) {\n  return fieldDef.aggregate === 'count';\n}\nexport function verbalTitleFormatter(fieldDef, config) {\n  var _a;\n  var field = fieldDef.field,\n    bin = fieldDef.bin,\n    timeUnit = fieldDef.timeUnit,\n    aggregate = fieldDef.aggregate;\n  if (aggregate === 'count') {\n    return config.countTitle;\n  } else if (isBinning(bin)) {\n    return \"\".concat(field, \" (binned)\");\n  } else if (timeUnit) {\n    var unit = (_a = normalizeTimeUnit(timeUnit)) === null || _a === void 0 ? void 0 : _a.unit;\n    if (unit) {\n      return \"\".concat(field, \" (\").concat(getTimeUnitParts(unit).join('-'), \")\");\n    }\n  } else if (aggregate) {\n    if (isArgmaxDef(aggregate)) {\n      return \"\".concat(field, \" for max \").concat(aggregate.argmax);\n    } else if (isArgminDef(aggregate)) {\n      return \"\".concat(field, \" for min \").concat(aggregate.argmin);\n    } else {\n      return \"\".concat(titleCase(aggregate), \" of \").concat(field);\n    }\n  }\n  return field;\n}\nexport function functionalTitleFormatter(fieldDef) {\n  var aggregate = fieldDef.aggregate,\n    bin = fieldDef.bin,\n    timeUnit = fieldDef.timeUnit,\n    field = fieldDef.field;\n  if (isArgmaxDef(aggregate)) {\n    return \"\".concat(field, \" for argmax(\").concat(aggregate.argmax, \")\");\n  } else if (isArgminDef(aggregate)) {\n    return \"\".concat(field, \" for argmin(\").concat(aggregate.argmin, \")\");\n  }\n  var timeUnitParams = normalizeTimeUnit(timeUnit);\n  var fn = aggregate || (timeUnitParams === null || timeUnitParams === void 0 ? void 0 : timeUnitParams.unit) || (timeUnitParams === null || timeUnitParams === void 0 ? void 0 : timeUnitParams.maxbins) && 'timeunit' || isBinning(bin) && 'bin';\n  if (fn) {\n    return \"\".concat(fn.toUpperCase(), \"(\").concat(field, \")\");\n  } else {\n    return field;\n  }\n}\nexport var defaultTitleFormatter = function defaultTitleFormatter(fieldDef, config) {\n  switch (config.fieldTitle) {\n    case 'plain':\n      return fieldDef.field;\n    case 'functional':\n      return functionalTitleFormatter(fieldDef);\n    default:\n      return verbalTitleFormatter(fieldDef, config);\n  }\n};\nvar titleFormatter = defaultTitleFormatter;\nexport function setTitleFormatter(formatter) {\n  titleFormatter = formatter;\n}\nexport function resetTitleFormatter() {\n  setTitleFormatter(defaultTitleFormatter);\n}\nexport function title(fieldOrDatumDef, config, _ref3) {\n  var allowDisabling = _ref3.allowDisabling,\n    _ref3$includeDefault = _ref3.includeDefault,\n    includeDefault = _ref3$includeDefault === void 0 ? true : _ref3$includeDefault;\n  var _a, _b;\n  var guideTitle = (_a = getGuide(fieldOrDatumDef)) === null || _a === void 0 ? void 0 : _a.title;\n  if (!isFieldDef(fieldOrDatumDef)) {\n    return guideTitle !== null && guideTitle !== void 0 ? guideTitle : fieldOrDatumDef.title;\n  }\n  var fieldDef = fieldOrDatumDef;\n  var def = includeDefault ? defaultTitle(fieldDef, config) : undefined;\n  if (allowDisabling) {\n    return getFirstDefined(guideTitle, fieldDef.title, def);\n  } else {\n    return (_b = guideTitle !== null && guideTitle !== void 0 ? guideTitle : fieldDef.title) !== null && _b !== void 0 ? _b : def;\n  }\n}\nexport function getGuide(fieldDef) {\n  if (isPositionFieldOrDatumDef(fieldDef) && fieldDef.axis) {\n    return fieldDef.axis;\n  } else if (isMarkPropFieldOrDatumDef(fieldDef) && fieldDef.legend) {\n    return fieldDef.legend;\n  } else if (isFacetFieldDef(fieldDef) && fieldDef.header) {\n    return fieldDef.header;\n  }\n  return undefined;\n}\nexport function defaultTitle(fieldDef, config) {\n  return titleFormatter(fieldDef, config);\n}\nexport function getFormatMixins(fieldDef) {\n  var _a;\n  if (isStringFieldOrDatumDef(fieldDef)) {\n    var format = fieldDef.format,\n      formatType = fieldDef.formatType;\n    return {\n      format: format,\n      formatType: formatType\n    };\n  } else {\n    var guide = (_a = getGuide(fieldDef)) !== null && _a !== void 0 ? _a : {};\n    var _format = guide.format,\n      _formatType = guide.formatType;\n    return {\n      format: _format,\n      formatType: _formatType\n    };\n  }\n}\nexport function defaultType(fieldDef, channel) {\n  var _a;\n  switch (channel) {\n    case 'latitude':\n    case 'longitude':\n      return 'quantitative';\n    case 'row':\n    case 'column':\n    case 'facet':\n    case 'shape':\n    case 'strokeDash':\n      return 'nominal';\n    case 'order':\n      return 'ordinal';\n  }\n  if (isSortableFieldDef(fieldDef) && isArray(fieldDef.sort)) {\n    return 'ordinal';\n  }\n  var aggregate = fieldDef.aggregate,\n    bin = fieldDef.bin,\n    timeUnit = fieldDef.timeUnit;\n  if (timeUnit) {\n    return 'temporal';\n  }\n  if (bin || aggregate && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {\n    return 'quantitative';\n  }\n  if (isScaleFieldDef(fieldDef) && ((_a = fieldDef.scale) === null || _a === void 0 ? void 0 : _a.type)) {\n    switch (SCALE_CATEGORY_INDEX[fieldDef.scale.type]) {\n      case 'numeric':\n      case 'discretizing':\n        return 'quantitative';\n      case 'time':\n        return 'temporal';\n    }\n  }\n  return 'nominal';\n}\n/**\n * Returns the fieldDef -- either from the outer channelDef or from the condition of channelDef.\n * @param channelDef\n */\nexport function getFieldDef(channelDef) {\n  if (isFieldDef(channelDef)) {\n    return channelDef;\n  } else if (hasConditionalFieldDef(channelDef)) {\n    return channelDef.condition;\n  }\n  return undefined;\n}\nexport function getFieldOrDatumDef(channelDef) {\n  if (isFieldOrDatumDef(channelDef)) {\n    return channelDef;\n  } else if (hasConditionalFieldOrDatumDef(channelDef)) {\n    return channelDef.condition;\n  }\n  return undefined;\n}\n/**\n * Convert type to full, lowercase type, or augment the fieldDef with a default type if missing.\n */\nexport function initChannelDef(channelDef, channel, config) {\n  var opt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  if (isString(channelDef) || isNumber(channelDef) || isBoolean(channelDef)) {\n    var primitiveType = isString(channelDef) ? 'string' : isNumber(channelDef) ? 'number' : 'boolean';\n    log.warn(log.message.primitiveChannelDef(channel, primitiveType, channelDef));\n    return {\n      value: channelDef\n    };\n  }\n  // If a fieldDef contains a field, we need type.\n  if (isFieldOrDatumDef(channelDef)) {\n    return initFieldOrDatumDef(channelDef, channel, config, opt);\n  } else if (hasConditionalFieldOrDatumDef(channelDef)) {\n    return Object.assign(Object.assign({}, channelDef), {\n      // Need to cast as normalizeFieldDef normally return FieldDef, but here we know that it is definitely Condition<FieldDef>\n      condition: initFieldOrDatumDef(channelDef.condition, channel, config, opt)\n    });\n  }\n  return channelDef;\n}\nexport function initFieldOrDatumDef(fd, channel, config, opt) {\n  if (isStringFieldOrDatumDef(fd)) {\n    var format = fd.format,\n      formatType = fd.formatType,\n      rest = __rest(fd, [\"format\", \"formatType\"]);\n    if (isCustomFormatType(formatType) && !config.customFormatTypes) {\n      log.warn(log.message.customFormatTypeNotAllowed(channel));\n      return initFieldOrDatumDef(rest, channel, config, opt);\n    }\n  } else {\n    var guideType = isPositionFieldOrDatumDef(fd) ? 'axis' : isMarkPropFieldOrDatumDef(fd) ? 'legend' : isFacetFieldDef(fd) ? 'header' : null;\n    if (guideType && fd[guideType]) {\n      var _a = fd[guideType],\n        _format2 = _a.format,\n        _formatType2 = _a.formatType,\n        newGuide = __rest(_a, [\"format\", \"formatType\"]);\n      if (isCustomFormatType(_formatType2) && !config.customFormatTypes) {\n        log.warn(log.message.customFormatTypeNotAllowed(channel));\n        return initFieldOrDatumDef(Object.assign(Object.assign({}, fd), _defineProperty({}, guideType, newGuide)), channel, config, opt);\n      }\n    }\n  }\n  if (isFieldDef(fd)) {\n    return initFieldDef(fd, channel, opt);\n  }\n  return initDatumDef(fd);\n}\nfunction initDatumDef(datumDef) {\n  var type = datumDef['type'];\n  if (type) {\n    return datumDef;\n  }\n  var datum = datumDef.datum;\n  type = isNumber(datum) ? 'quantitative' : isString(datum) ? 'nominal' : isDateTime(datum) ? 'temporal' : undefined;\n  return Object.assign(Object.assign({}, datumDef), {\n    type: type\n  });\n}\nexport function initFieldDef(fd, channel) {\n  var _ref4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref4$compositeMark = _ref4.compositeMark,\n    compositeMark = _ref4$compositeMark === void 0 ? false : _ref4$compositeMark;\n  var aggregate = fd.aggregate,\n    timeUnit = fd.timeUnit,\n    bin = fd.bin,\n    field = fd.field;\n  var fieldDef = Object.assign({}, fd);\n  // Drop invalid aggregate\n  if (!compositeMark && aggregate && !isAggregateOp(aggregate) && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {\n    log.warn(log.message.invalidAggregate(aggregate));\n    delete fieldDef.aggregate;\n  }\n  // Normalize Time Unit\n  if (timeUnit) {\n    fieldDef.timeUnit = normalizeTimeUnit(timeUnit);\n  }\n  if (field) {\n    fieldDef.field = \"\".concat(field);\n  }\n  // Normalize bin\n  if (isBinning(bin)) {\n    fieldDef.bin = normalizeBin(bin, channel);\n  }\n  if (isBinned(bin) && !isXorY(channel)) {\n    log.warn(log.message.channelShouldNotBeUsedForBinned(channel));\n  }\n  // Normalize Type\n  if (isTypedFieldDef(fieldDef)) {\n    var type = fieldDef.type;\n    var fullType = getFullName(type);\n    if (type !== fullType) {\n      // convert short type to full type\n      fieldDef.type = fullType;\n    }\n    if (type !== 'quantitative') {\n      if (isCountingAggregateOp(aggregate)) {\n        log.warn(log.message.invalidFieldTypeForCountAggregate(type, aggregate));\n        fieldDef.type = 'quantitative';\n      }\n    }\n  } else if (!isSecondaryRangeChannel(channel)) {\n    // If type is empty / invalid, then augment with default type\n    var newType = defaultType(fieldDef, channel);\n    fieldDef['type'] = newType;\n  }\n  if (isTypedFieldDef(fieldDef)) {\n    var _ref5 = channelCompatibility(fieldDef, channel) || {},\n      compatible = _ref5.compatible,\n      warning = _ref5.warning;\n    if (compatible === false) {\n      log.warn(warning);\n    }\n  }\n  if (isSortableFieldDef(fieldDef) && isString(fieldDef.sort)) {\n    var sort = fieldDef.sort;\n    if (isSortByChannel(sort)) {\n      return Object.assign(Object.assign({}, fieldDef), {\n        sort: {\n          encoding: sort\n        }\n      });\n    }\n    var sub = sort.substr(1);\n    if (sort.charAt(0) === '-' && isSortByChannel(sub)) {\n      return Object.assign(Object.assign({}, fieldDef), {\n        sort: {\n          encoding: sub,\n          order: 'descending'\n        }\n      });\n    }\n  }\n  if (isFacetFieldDef(fieldDef)) {\n    var header = fieldDef.header;\n    if (header) {\n      var orient = header.orient,\n        rest = __rest(header, [\"orient\"]);\n      if (orient) {\n        return Object.assign(Object.assign({}, fieldDef), {\n          header: Object.assign(Object.assign({}, rest), {\n            labelOrient: header.labelOrient || orient,\n            titleOrient: header.titleOrient || orient\n          })\n        });\n      }\n    }\n  }\n  return fieldDef;\n}\nexport function normalizeBin(bin, channel) {\n  if (isBoolean(bin)) {\n    return {\n      maxbins: autoMaxBins(channel)\n    };\n  } else if (bin === 'binned') {\n    return {\n      binned: true\n    };\n  } else if (!bin.maxbins && !bin.step) {\n    return Object.assign(Object.assign({}, bin), {\n      maxbins: autoMaxBins(channel)\n    });\n  } else {\n    return bin;\n  }\n}\nvar COMPATIBLE = {\n  compatible: true\n};\nexport function channelCompatibility(fieldDef, channel) {\n  var type = fieldDef.type;\n  if (type === 'geojson' && channel !== 'shape') {\n    return {\n      compatible: false,\n      warning: \"Channel \".concat(channel, \" should not be used with a geojson data.\")\n    };\n  }\n  switch (channel) {\n    case ROW:\n    case COLUMN:\n    case FACET:\n      if (!isDiscrete(fieldDef)) {\n        return {\n          compatible: false,\n          warning: log.message.channelShouldBeDiscrete(channel)\n        };\n      }\n      return COMPATIBLE;\n    case X:\n    case Y:\n    case XOFFSET:\n    case YOFFSET:\n    case COLOR:\n    case FILL:\n    case STROKE:\n    case TEXT:\n    case DETAIL:\n    case KEY:\n    case TOOLTIP:\n    case HREF:\n    case URL:\n    case ANGLE:\n    case THETA:\n    case RADIUS:\n    case DESCRIPTION:\n      return COMPATIBLE;\n    case LONGITUDE:\n    case LONGITUDE2:\n    case LATITUDE:\n    case LATITUDE2:\n      if (type !== QUANTITATIVE) {\n        return {\n          compatible: false,\n          warning: \"Channel \".concat(channel, \" should be used with a quantitative field only, not \").concat(fieldDef.type, \" field.\")\n        };\n      }\n      return COMPATIBLE;\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    case STROKEWIDTH:\n    case SIZE:\n    case THETA2:\n    case RADIUS2:\n    case X2:\n    case Y2:\n      if (type === 'nominal' && !fieldDef['sort']) {\n        return {\n          compatible: false,\n          warning: \"Channel \".concat(channel, \" should not be used with an unsorted discrete field.\")\n        };\n      }\n      return COMPATIBLE;\n    case SHAPE:\n    case STROKEDASH:\n      if (!isDiscrete(fieldDef) && !isDiscretizing(fieldDef)) {\n        return {\n          compatible: false,\n          warning: log.message.channelShouldBeDiscreteOrDiscretizing(channel)\n        };\n      }\n      return COMPATIBLE;\n    case ORDER:\n      if (fieldDef.type === 'nominal' && !('sort' in fieldDef)) {\n        return {\n          compatible: false,\n          warning: \"Channel order is inappropriate for nominal field, which has no inherent order.\"\n        };\n      }\n      return COMPATIBLE;\n  }\n}\n/**\n * Check if the field def uses a time format or does not use any format but is temporal\n * (this does not cover field defs that are temporal but use a number format).\n */\nexport function isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) {\n  var _getFormatMixins = getFormatMixins(fieldOrDatumDef),\n    formatType = _getFormatMixins.formatType;\n  return formatType === 'time' || !formatType && isTimeFieldDef(fieldOrDatumDef);\n}\n/**\n * Check if field def has type `temporal`. If you want to also cover field defs that use a time format, use `isTimeFormatFieldDef`.\n */\nexport function isTimeFieldDef(def) {\n  return def && (def['type'] === 'temporal' || isFieldDef(def) && !!def.timeUnit);\n}\n/**\n * Getting a value associated with a fielddef.\n * Convert the value to Vega expression if applicable (for datetime object, or string if the field def is temporal or has timeUnit)\n */\nexport function valueExpr(v, _ref6) {\n  var timeUnit = _ref6.timeUnit,\n    type = _ref6.type,\n    wrapTime = _ref6.wrapTime,\n    undefinedIfExprNotRequired = _ref6.undefinedIfExprNotRequired;\n  var _a;\n  var unit = timeUnit && ((_a = normalizeTimeUnit(timeUnit)) === null || _a === void 0 ? void 0 : _a.unit);\n  var isTime = unit || type === 'temporal';\n  var expr;\n  if (isExprRef(v)) {\n    expr = v.expr;\n  } else if (isSignalRef(v)) {\n    expr = v.signal;\n  } else if (isDateTime(v)) {\n    isTime = true;\n    expr = dateTimeToExpr(v);\n  } else if (isString(v) || isNumber(v)) {\n    if (isTime) {\n      expr = \"datetime(\".concat(stringify(v), \")\");\n      if (isLocalSingleTimeUnit(unit)) {\n        // for single timeUnit, we will use dateTimeToExpr to convert number/string to match the timeUnit\n        if (isNumber(v) && v < 10000 || isString(v) && isNaN(Date.parse(v))) {\n          expr = dateTimeToExpr(_defineProperty({}, unit, v));\n        }\n      }\n    }\n  }\n  if (expr) {\n    return wrapTime && isTime ? \"time(\".concat(expr, \")\") : expr;\n  }\n  // number or boolean or normal string\n  return undefinedIfExprNotRequired ? undefined : stringify(v);\n}\n/**\n * Standardize value array -- convert each value to Vega expression if applicable\n */\nexport function valueArray(fieldOrDatumDef, values) {\n  var type = fieldOrDatumDef.type;\n  return values.map(function (v) {\n    var expr = valueExpr(v, {\n      timeUnit: isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.timeUnit : undefined,\n      type: type,\n      undefinedIfExprNotRequired: true\n    });\n    // return signal for the expression if we need an expression\n    if (expr !== undefined) {\n      return {\n        signal: expr\n      };\n    }\n    // otherwise just return the original value\n    return v;\n  });\n}\n/**\n * Checks whether a fieldDef for a particular channel requires a computed bin range.\n */\nexport function binRequiresRange(fieldDef, channel) {\n  if (!isBinning(fieldDef.bin)) {\n    console.warn('Only call this method for binned field defs.');\n    return false;\n  }\n  // We need the range only when the user explicitly forces a binned field to be use discrete scale. In this case, bin range is used in axis and legend labels.\n  // We could check whether the axis or legend exists (not disabled) but that seems overkill.\n  return isScaleChannel(channel) && ['ordinal', 'nominal'].includes(fieldDef.type);\n}","map":{"version":3,"sources":["../../src/channeldef.ts"],"names":[],"mappings":";;;;;;;;;;;AACA,SAAQ,OAAO,EAAE,SAAS,EAAE,QAAQ,EAAE,QAAQ,QAAO,WAAW;AAChE,SAAmB,aAAa,EAAE,WAAW,EAAE,WAAW,EAAE,qBAAqB,QAAO,aAAa;AAErG,SAAQ,WAAW,EAAkB,WAAW,EAAE,QAAQ,EAAE,SAAS,QAAO,OAAO;AACnF,SACE,KAAK,EAEL,KAAK,EACL,MAAM,EACN,WAAW,EACX,MAAM,EAEN,KAAK,EACL,IAAI,EACJ,WAAW,EACX,cAAc,EACd,IAAI,EACJ,cAAc,EACd,uBAAuB,EACvB,MAAM,EACN,GAAG,EACH,QAAQ,EACR,SAAS,EACT,SAAS,EACT,UAAU,EACV,OAAO,EACP,KAAK,EAGL,MAAM,EACN,OAAO,EACP,GAAG,EACH,KAAK,EACL,IAAI,EACJ,MAAM,EACN,UAAU,EACV,aAAa,EACb,WAAW,EACX,IAAI,EACJ,KAAK,EACL,MAAM,EACN,OAAO,EACP,GAAG,EACH,CAAC,EACD,EAAE,EACF,OAAO,EACP,CAAC,EACD,EAAE,EACF,OAAO,QACF,WAAW;AAClB,SAAQ,aAAa,EAAE,mBAAmB,QAAO,kBAAkB;AACnE,SAAQ,kBAAkB,QAAO,kBAAkB;AAGnD,SAAkB,cAAc,EAAE,UAAU,QAAO,YAAY;AAE/D,SAAiB,SAAS,QAAO,QAAQ;AAIzC,OAAO,KAAK,GAAG,MAAM,OAAO;AAE5B,SAAQ,eAAe,QAAwC,QAAQ;AAEvE,SAAQ,iBAAiB,EAAE,sBAAsB,EAAS,oBAAoB,QAAO,SAAS;AAC9F,SAAQ,eAAe,QAAwB,QAAQ;AACvD,SAAQ,eAAe,QAAO,cAAc;AAE5C,SACE,gBAAgB,EAChB,qBAAqB,EACrB,iBAAiB,EAGjB,gBAAgB,QACX,YAAY;AAEnB,SAAQ,WAAW,EAAE,YAAY,QAA2B,QAAQ;AACpE,SAEE,mBAAmB,EACnB,eAAe,EACf,aAAa,EACb,IAAI,EACJ,mBAAmB,EACnB,kBAAkB,EAClB,SAAS,EACT,SAAS,QACJ,QAAQ;AACf,SAAQ,WAAW,QAAO,eAAe;AAmEzC,OAAM,SAAU,sBAAsB,CAAI,CAAiB,EAAA;EACzD,OAAO,CAAC,CAAC,OAAO,CAAC;AACnB;AA4DA,OAAM,SAAU,WAAW,CAAC,KAAkB,EAAA;EAC5C,OAAO,KAAK,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,QAAQ,IAAI,KAAK;AACvD;AAwDA,OAAM,SAAU,cAAc,CAAC,QAA0B,EAAA;EACvD,IAAO,KAAK,GAA8B,QAAQ,CAA3C,KAAK;IAAE,QAAQ,GAAoB,QAAQ,CAApC,QAAQ;IAAE,GAAG,GAAe,QAAQ,CAA1B,GAAG;IAAE,SAAS,GAAI,QAAQ,CAArB,SAAS;EACtC,OAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EACM,QAAQ,GAAG;IAAC,QAAQ,EAAR;EAAQ,CAAC,GAAG,CAAA,CAAE,CAAC,EAC3B,GAAG,GAAG;IAAC,GAAG,EAAH;EAAG,CAAC,GAAG,CAAA,CAAE,CAAC,EACjB,SAAS,GAAG;IAAC,SAAS,EAAT;EAAS,CAAC,GAAG,CAAA,CAAE,CAAC,EAAA;IACjC,KAAK,EAAL;EAAK,CAAA,CAAA;AAET;AAuEA,OAAM,SAAU,kBAAkB,CAAkB,QAAqB,EAAA;EACvE,OAAO,MAAM,IAAI,QAAQ;AAC3B;AAgKA,OAAM,SAAU,eAAe,OAU9B;EAAA,IATC,QAAQ,QAAR,QAAQ;IACR,SAAS,QAAT,SAAS;IACA,IAAI,QAAb,OAAO;IACP,MAAM,QAAN,MAAM;EAON,IAAI,iBAAiB,CAAC,QAAQ,CAAC,IAAI,QAAQ,CAAC,YAAY,KAAK,SAAS,EAAE;IACtE,OAAO,QAAQ,CAAC,YAAY;EAC7B;EACD,IAAI,UAAU,CAAC,QAAQ,CAAC,EAAE;IACxB,IAAO,QAAQ,GAAS,QAAQ,CAAzB,QAAQ;MAAE,GAAG,GAAI,QAAQ,CAAf,GAAG;IACpB,IAAI,QAAQ,IAAI,CAAC,SAAS,EAAE;MAC1B,OAAO,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,aAAa,CAAC,sBAAsB,EAAE,IAAI,EAAE,MAAM,CAAC;KAC5F,MAAM,IAAI,SAAS,CAAC,GAAG,CAAC,EAAE;MACzB,OAAO,GAAG;IACX;EACF;EAED,OAAO,SAAS;AAClB;AAEA,OAAM,SAAU,WAAW,QAgB1B;EAAA,IAfC,OAAO,SAAP,OAAO;IACP,QAAQ,SAAR,QAAQ;IACR,SAAS,SAAT,SAAS;IACA,IAAI,SAAb,OAAO;IACP,MAAM,SAAN,MAAM;IACN,SAAS,SAAT,SAAS;IACT,gBAAgB,SAAhB,gBAAgB;;EAUhB,IAAM,WAAW,GAAG,cAAc,CAAC,OAAO,CAAC;EAC3C,IAAM,IAAI,GAAG,mBAAmB,CAAC,gBAAgB,GAAG,MAAM,GAAG,WAAW,EAAE,IAAI,EAAE,MAAM,EAAE;IACtF,SAAS,EAAE;GACZ,CAAC;EAEF,IAAI,IAAI,KAAK,SAAS,EAAE;IACtB,OAAO,IAAI;EACZ;EAED,IAAI,UAAU,CAAC,QAAQ,CAAC,EAAE;IACxB,IAAO,QAAQ,GAAS,QAAQ,CAAzB,QAAQ;MAAE,GAAG,GAAI,QAAQ,CAAf,GAAG;IAEpB,IAAI,QAAQ,IAAI,CAAC,SAAS,EAAE;MAC1B,OAAO;QAAC,IAAI,EAAE,aAAa,CAAC,kBAAkB,EAAE,IAAI,EAAE,MAAM;MAAC,CAAC;KAC/D,MAAM,IAAI,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,iBAAiB,CAAC,SAAS,CAAC,EAAE;MAC1D,OAAO;QAAC,IAAI,EAAE;MAAC,CAAC;IACjB;EACF;EAED,IAAI,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;IAC9B,IAAI,SAAS,EAAE;MACb,IAAI,iBAAiB,CAAC,SAAS,CAAC,EAAE;QAChC,OAAO,CAAA,CAAA,EAAA,GAAA,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,gBAAgB,KAAI;UAAC,IAAI,EAAE;QAAC,CAAC;OACxD,MAAM;QACL,OAAO,CAAA,EAAA,GAAA,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,kBAAkB;MAC7C;IACF;IACD,OAAO,CAAA,EAAA,GAAA,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,gBAAgB;EAC3C;EAED,OAAO,SAAS;AAClB;AAEA,OAAM,SAAU,UAAU,CACxB,QAA0B,EAC1B,SAAsC,EACtC,OAAiC,EACjC,MAAyB,EAAA;EAEzB,IAAI,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAK,QAAQ,CAAC,QAAQ,IAAI,eAAe,CAAC,QAAQ,CAAC,IAAI,QAAQ,CAAC,IAAI,KAAK,UAAW,EAAE;IAC/G;IACA;IACA,OAAO,eAAe,CAAC;MAAC,QAAQ,EAAR,QAAQ;MAAE,SAAS,EAAT,SAAS;MAAE,OAAO,EAAP,OAAO;MAAE,MAAM,EAAN;IAAM,CAAC,CAAC,KAAK,SAAS;EAC7E;EACD,OAAO,KAAK;AACd;AA4CA,OAAM,SAAU,gBAAgB,CAC9B,UAAc,EAAA;EAEd,OAAO,UAAU,IAAI,WAAW,IAAI,UAAU;AAChD;AAEA;;AAEG;AACH,OAAM,SAAU,sBAAsB,CACpC,UAAkC,EAAA;EAElC,IAAM,SAAS,GAAG,UAAU,KAAA,IAAA,IAAV,UAAU,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAV,UAAU,CAAG,WAAW,CAAC;EAC3C,OAAO,CAAC,CAAC,SAAS,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,UAAU,CAAC,SAAS,CAAC;AACpE;AAEA,OAAM,SAAU,6BAA6B,CAC3C,UAAyB,EAAA;EAEzB,IAAM,SAAS,GAAG,UAAU,KAAA,IAAA,IAAV,UAAU,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAV,UAAU,CAAG,WAAW,CAAC;EAC3C,OAAO,CAAC,CAAC,SAAS,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,iBAAiB,CAAC,SAAS,CAAC;AAC3E;AAEA,OAAM,SAAU,sBAAsB,CACpC,UAAyB,EAAA;EAEzB,IAAM,SAAS,GAAG,UAAU,KAAA,IAAA,IAAV,UAAU,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAV,UAAU,CAAG,WAAW,CAAC;EAC3C,OAAO,CAAC,CAAC,SAAS,KAAK,OAAO,CAAC,SAAS,CAAC,IAAI,UAAU,CAAC,SAAS,CAAC,CAAC;AACrE;AAEA,OAAM,SAAU,UAAU,CACxB,UAAuE,EAAA;EAEvE;EACA,OAAO,UAAU,KAAK,CAAC,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,UAAU,CAAC,WAAW,CAAC,KAAK,OAAO,CAAC;AACrF;AAEA,OAAM,SAAU,cAAc,CAAkB,UAAyB,EAAA;EACvE,OAAO,UAAU,KAAA,IAAA,IAAV,UAAU,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAV,UAAU,CAAG,MAAM,CAAC;AAC7B;AAEA,OAAM,SAAU,UAAU,CACxB,UAAuE,EAAA;EAEvE,OAAO,UAAU,IAAI,OAAO,IAAI,UAAU;AAC5C;AAEA,OAAM,SAAU,2BAA2B,CACzC,EAAiB,EAAA;EAEjB;EACA,OAAQ,eAAe,CAAC,EAAE,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,IAAK,gBAAgB,CAAC,EAAE,CAAC;AACzE;AAEA,OAAM,SAAU,6BAA6B,CAAkB,EAAiB,EAAA;EAC9E;EACA,OAAO,cAAc,CAAC,EAAE,CAAC,KAAK,cAAc,IAAI,gBAAgB,CAAC,EAAE,CAAC;AACtE;AAEA,OAAM,SAAU,gBAAgB,CAAkB,EAAiB,EAAA;EACjE,OAAO,UAAU,CAAC,EAAE,CAAC,IAAI,QAAQ,CAAC,EAAE,CAAC,KAAK,CAAC;AAC7C;AAEA,OAAM,SAAU,iBAAiB,CAC/B,UAAkC,EAAA;EAElC,OAAO,UAAU,CAAC,UAAU,CAAC,IAAI,UAAU,CAAC,UAAU,CAAC;AACzD;AAEA,OAAM,SAAU,eAAe,CAAkB,UAAyB,EAAA;EACxE,OAAO,UAAU,KAAK,OAAO,IAAI,UAAU,IAAI,UAAU,CAAC,WAAW,CAAC,KAAK,OAAO,CAAC,IAAI,MAAM,IAAI,UAAU;AAC7G;AAEA,OAAM,SAAU,UAAU,CAAkB,UAAkC,EAAA;EAC5E,OAAO,UAAU,IAAI,OAAO,IAAI,UAAU,IAAI,OAAO,IAAI,UAAU;AACrE;AAEA,OAAM,SAAU,eAAe,CAAkB,UAAyB,EAAA;EACxE,OAAO,UAAU,KAAK,OAAO,IAAI,UAAU,IAAI,MAAM,IAAI,UAAU,CAAC;AACtE;AAEA,OAAM,SAAU,yBAAyB,CACvC,UAAyB,EAAA;EAEzB,OAAO,UAAU,KAAK,MAAM,IAAI,UAAU,IAAI,OAAO,IAAI,UAAU,IAAI,QAAQ,IAAI,UAAU,CAAC;AAChG;AAEA,OAAM,SAAU,yBAAyB,CACvC,UAAyB,EAAA;EAEzB,OAAO,UAAU,IAAI,QAAQ,IAAI,UAAU;AAC7C;AAEA,OAAM,SAAU,uBAAuB,CACrC,UAAyB,EAAA;EAEzB,OAAO,UAAU,KAAK,QAAQ,IAAI,UAAU,IAAI,YAAY,IAAI,UAAU,CAAC;AAC7E;AAEA,OAAM,SAAU,gBAAgB,CAAkB,QAAqB,EAAA;EACrE;EACA,OAAO,IAAI,CAAC,QAAQ,EAAE,CAAC,QAAQ,EAAE,MAAM,EAAE,QAAQ,EAAE,OAAO,CAAU,CAAC;AACvE;AAoBA,SAAS,YAAY,CACnB,QAAoE,EAAA;EAEpE,OAAO,IAAI,IAAI,QAAQ;AACzB;AAEA;;AAEG;AACH,OAAM,SAAU,OAAO,CACrB,QAAoE,EAC5C;EAAA,IAAxB,GAAA,uEAAsB,CAAA,CAAE;;EAExB,IAAI,KAAK,GAAG,QAAQ,CAAC,KAAK;EAC1B,IAAM,MAAM,GAAG,GAAG,CAAC,MAAM;EACzB,IAAI,MAAM,GAAG,GAAG,CAAC,MAAM;EAEvB,IAAI,WAAW,GAAG,EAAE,CAAC,CAAC;EAEtB,IAAI,OAAO,CAAC,QAAQ,CAAC,EAAE;IACrB,KAAK,GAAG,aAAa,CAAC,OAAO,CAAC;GAC/B,MAAM;IACL,IAAI,EAAU;IAEd,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE;MACb,IAAI,YAAY,CAAC,QAAQ,CAAC,EAAE;QAC1B,EAAE,GAAG,QAAQ,CAAC,EAAE;OACjB,MAAM;QACL,IAAO,GAAG,GAAyB,QAAQ,CAApC,GAAG;UAAE,SAAS,GAAc,QAAQ,CAA/B,SAAS;UAAE,QAAQ,GAAI,QAAQ,CAApB,QAAQ;QAC/B,IAAI,SAAS,CAAC,GAAG,CAAC,EAAE;UAClB,EAAE,GAAG,WAAW,CAAC,GAAG,CAAC;UACrB,MAAM,GAAG,CAAC,CAAA,EAAA,GAAA,GAAG,CAAC,SAAS,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,EAAE,KAAK,CAAA,EAAA,GAAA,GAAG,CAAC,MAAM,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,EAAE,CAAC;SACpD,MAAM,IAAI,SAAS,EAAE;UACpB,IAAI,WAAW,CAAC,SAAS,CAAC,EAAE;YAC1B,WAAW,gBAAQ,KAAK,QAAI;YAC5B,KAAK,oBAAa,SAAS,CAAC,MAAM,CAAE;WACrC,MAAM,IAAI,WAAW,CAAC,SAAS,CAAC,EAAE;YACjC,WAAW,gBAAQ,KAAK,QAAI;YAC5B,KAAK,oBAAa,SAAS,CAAC,MAAM,CAAE;WACrC,MAAM;YACL,EAAE,GAAG,MAAM,CAAC,SAAS,CAAC;UACvB;SACF,MAAM,IAAI,QAAQ,EAAE;UACnB,EAAE,GAAG,gBAAgB,CAAC,QAAQ,CAAC;UAC/B,MAAM,GAAG,CAAE,CAAC,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,GAAG,CAAC,SAAS,IAAK,EAAE,KAAK,CAAA,EAAA,GAAA,GAAG,CAAC,MAAM,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,EAAE,CAAC;QACnG;MACF;IACF;IAED,IAAI,EAAE,EAAE;MACN,KAAK,GAAG,KAAK,aAAM,EAAE,cAAI,KAAK,IAAK,EAAE;IACtC;EACF;EAED,IAAI,MAAM,EAAE;IACV,KAAK,aAAM,KAAK,cAAI,MAAM,CAAE;EAC7B;EAED,IAAI,MAAM,EAAE;IACV,KAAK,aAAM,MAAM,cAAI,KAAK,CAAE;EAC7B;EAED,IAAI,GAAG,CAAC,KAAK,EAAE;IACb,OAAO,mBAAmB,CAAC,KAAK,CAAC;GAClC,MAAM,IAAI,GAAG,CAAC,IAAI,EAAE;IACnB;IACA,OAAO,mBAAmB,CAAC,KAAK,EAAE,GAAG,CAAC,IAAI,CAAC,GAAG,WAAW;GAC1D,MAAM;IACL;IACA,OAAO,kBAAkB,CAAC,KAAK,CAAC,GAAG,WAAW;EAC/C;AACH;AAEA,OAAM,SAAU,UAAU,CAAC,GAA8C,EAAA;EACvE,QAAQ,GAAG,CAAC,IAAI;IACd,KAAK,SAAS;IACd,KAAK,SAAS;IACd,KAAK,SAAS;MACZ,OAAO,IAAI;IACb,KAAK,cAAc;MACjB,OAAO,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG;IACrC,KAAK,UAAU;MACb,OAAO,KAAK;EAAC;EAEjB,MAAM,IAAI,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,gBAAgB,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AACzD;AAEA,OAAM,SAAU,cAAc,CAAC,GAA8C,EAAA;;EAC3E,OAAO,eAAe,CAAC,GAAG,CAAC,IAAI,sBAAsB,CAAC,CAAA,EAAA,GAAA,GAAG,CAAC,KAAK,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,IAAI,CAAC;AACxE;AAEA,OAAM,SAAU,OAAO,CAAC,QAA6B,EAAA;EACnD,OAAO,QAAQ,CAAC,SAAS,KAAK,OAAO;AACvC;AAIA,OAAM,SAAU,oBAAoB,CAAC,QAA8B,EAAE,MAAc,EAAA;;EACjF,IAAO,KAAK,GAA8B,QAAQ,CAA3C,KAAK;IAAE,GAAG,GAAyB,QAAQ,CAApC,GAAG;IAAE,QAAQ,GAAe,QAAQ,CAA/B,QAAQ;IAAE,SAAS,GAAI,QAAQ,CAArB,SAAS;EACtC,IAAI,SAAS,KAAK,OAAO,EAAE;IACzB,OAAO,MAAM,CAAC,UAAU;GACzB,MAAM,IAAI,SAAS,CAAC,GAAG,CAAC,EAAE;IACzB,iBAAU,KAAK;GAChB,MAAM,IAAI,QAAQ,EAAE;IACnB,IAAM,IAAI,GAAG,CAAA,EAAA,GAAA,iBAAiB,CAAC,QAAQ,CAAC,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,IAAI;IAC9C,IAAI,IAAI,EAAE;MACR,iBAAU,KAAK,eAAK,gBAAgB,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC;IACrD;GACF,MAAM,IAAI,SAAS,EAAE;IACpB,IAAI,WAAW,CAAC,SAAS,CAAC,EAAE;MAC1B,iBAAU,KAAK,sBAAY,SAAS,CAAC,MAAM;KAC5C,MAAM,IAAI,WAAW,CAAC,SAAS,CAAC,EAAE;MACjC,iBAAU,KAAK,sBAAY,SAAS,CAAC,MAAM;KAC5C,MAAM;MACL,iBAAU,SAAS,CAAC,SAAS,CAAC,iBAAO,KAAK;IAC3C;EACF;EACD,OAAO,KAAK;AACd;AAEA,OAAM,SAAU,wBAAwB,CAAC,QAA8B,EAAA;EACrE,IAAO,SAAS,GAA0B,QAAQ,CAA3C,SAAS;IAAE,GAAG,GAAqB,QAAQ,CAAhC,GAAG;IAAE,QAAQ,GAAW,QAAQ,CAA3B,QAAQ;IAAE,KAAK,GAAI,QAAQ,CAAjB,KAAK;EACtC,IAAI,WAAW,CAAC,SAAS,CAAC,EAAE;IAC1B,iBAAU,KAAK,yBAAe,SAAS,CAAC,MAAM;GAC/C,MAAM,IAAI,WAAW,CAAC,SAAS,CAAC,EAAE;IACjC,iBAAU,KAAK,yBAAe,SAAS,CAAC,MAAM;EAC/C;EAED,IAAM,cAAc,GAAG,iBAAiB,CAAC,QAAQ,CAAC;EAElD,IAAM,EAAE,GAAG,SAAS,KAAI,cAAc,KAAA,IAAA,IAAd,cAAc,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAd,cAAc,CAAE,IAAI,CAAA,IAAK,CAAA,cAAc,KAAA,IAAA,IAAd,cAAc,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAd,cAAc,CAAE,OAAO,KAAI,UAAW,IAAK,SAAS,CAAC,GAAG,CAAC,IAAI,KAAM;EACpH,IAAI,EAAE,EAAE;IACN,iBAAU,EAAE,CAAC,WAAW,EAAE,cAAI,KAAK;GACpC,MAAM;IACL,OAAO,KAAK;EACb;AACH;AAEA,OAAO,IAAM,qBAAqB,GAAwB,SAA7C,qBAAqB,CAAyB,QAA8B,EAAE,MAAc,EAAI;EAC3G,QAAQ,MAAM,CAAC,UAAU;IACvB,KAAK,OAAO;MACV,OAAO,QAAQ,CAAC,KAAK;IACvB,KAAK,YAAY;MACf,OAAO,wBAAwB,CAAC,QAAQ,CAAC;IAC3C;MACE,OAAO,oBAAoB,CAAC,QAAQ,EAAE,MAAM,CAAC;EAAC;AAEpD,CAAC;AAED,IAAI,cAAc,GAAG,qBAAqB;AAE1C,OAAM,SAAU,iBAAiB,CAAC,SAA8B,EAAA;EAC9D,cAAc,GAAG,SAAS;AAC5B;AAEA,OAAM,SAAU,mBAAmB,GAAA;EACjC,iBAAiB,CAAC,qBAAqB,CAAC;AAC1C;AAEA,OAAM,SAAU,KAAK,CACnB,eAA6E,EAC7E,MAAc,SAC8E;EAAA,IAA3F,cAAc,SAAd,cAAc;IAAA,6BAAE,cAAc;IAAd,cAAc,qCAAG,IAAI;;EAEtC,IAAM,UAAU,GAAG,CAAA,EAAA,GAAA,QAAQ,CAAC,eAAe,CAAC,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,KAAK;EAEnD,IAAI,CAAC,UAAU,CAAC,eAAe,CAAC,EAAE;IAChC,OAAO,UAAU,KAAA,IAAA,IAAV,UAAU,KAAA,KAAA,CAAA,GAAV,UAAU,GAAI,eAAe,CAAC,KAAK;EAC3C;EACD,IAAM,QAAQ,GAAG,eAAe;EAEhC,IAAM,GAAG,GAAG,cAAc,GAAG,YAAY,CAAC,QAAQ,EAAE,MAAM,CAAC,GAAG,SAAS;EAEvE,IAAI,cAAc,EAAE;IAClB,OAAO,eAAe,CAAC,UAAU,EAAE,QAAQ,CAAC,KAAK,EAAE,GAAG,CAAC;GACxD,MAAM;IACL,OAAO,CAAA,EAAA,GAAA,UAAU,KAAA,IAAA,IAAV,UAAU,KAAA,KAAA,CAAA,GAAV,UAAU,GAAI,QAAQ,CAAC,KAAK,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,GAAG;EAC3C;AACH;AAEA,OAAM,SAAU,QAAQ,CAAC,QAAsE,EAAA;EAC7F,IAAI,yBAAyB,CAAC,QAAQ,CAAC,IAAI,QAAQ,CAAC,IAAI,EAAE;IACxD,OAAO,QAAQ,CAAC,IAAI;GACrB,MAAM,IAAI,yBAAyB,CAAC,QAAQ,CAAC,IAAI,QAAQ,CAAC,MAAM,EAAE;IACjE,OAAO,QAAQ,CAAC,MAAM;GACvB,MAAM,IAAI,eAAe,CAAC,QAAQ,CAAC,IAAI,QAAQ,CAAC,MAAM,EAAE;IACvD,OAAO,QAAQ,CAAC,MAAM;EACvB;EACD,OAAO,SAAS;AAClB;AAEA,OAAM,SAAU,YAAY,CAAC,QAA8B,EAAE,MAAc,EAAA;EACzE,OAAO,cAAc,CAAC,QAAQ,EAAE,MAAM,CAAC;AACzC;AAEA,OAAM,SAAU,eAAe,CAAC,QAA0C,EAAA;;EACxE,IAAI,uBAAuB,CAAC,QAAQ,CAAC,EAAE;IACrC,IAAO,MAAM,GAAgB,QAAQ,CAA9B,MAAM;MAAE,UAAU,GAAI,QAAQ,CAAtB,UAAU;IACzB,OAAO;MAAC,MAAM,EAAN,MAAM;MAAE,UAAU,EAAV;IAAU,CAAC;GAC5B,MAAM;IACL,IAAM,KAAK,GAAG,CAAA,EAAA,GAAA,QAAQ,CAAC,QAAQ,CAAC,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,CAAA,CAAE;IACtC,IAAO,OAAM,GAAgB,KAAK,CAA3B,MAAM;MAAE,WAAU,GAAI,KAAK,CAAnB,UAAU;IACzB,OAAO;MAAC,MAAM,EAAN,OAAM;MAAE,UAAU,EAAV;IAAU,CAAC;EAC5B;AACH;AAEA,OAAM,SAAU,WAAW,CAAiC,QAAW,EAAE,OAAwB,EAAA;;EAC/F,QAAQ,OAAO;IACb,KAAK,UAAU;IACf,KAAK,WAAW;MACd,OAAO,cAAc;IAEvB,KAAK,KAAK;IACV,KAAK,QAAQ;IACb,KAAK,OAAO;IACZ,KAAK,OAAO;IACZ,KAAK,YAAY;MACf,OAAO,SAAS;IAElB,KAAK,OAAO;MACV,OAAO,SAAS;EAAC;EAGrB,IAAI,kBAAkB,CAAC,QAAQ,CAAC,IAAI,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;IAC1D,OAAO,SAAS;EACjB;EAED,IAAO,SAAS,GAAmB,QAAQ,CAApC,SAAS;IAAE,GAAG,GAAc,QAAQ,CAAzB,GAAG;IAAE,QAAQ,GAAI,QAAQ,CAApB,QAAQ;EAC/B,IAAI,QAAQ,EAAE;IACZ,OAAO,UAAU;EAClB;EAED,IAAI,GAAG,IAAK,SAAS,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAE,EAAE;IAC5E,OAAO,cAAc;EACtB;EAED,IAAI,eAAe,CAAC,QAAQ,CAAC,KAAI,CAAA,EAAA,GAAA,QAAQ,CAAC,KAAK,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,IAAI,CAAA,EAAE;IACrD,QAAQ,oBAAoB,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC;MAC/C,KAAK,SAAS;MACd,KAAK,cAAc;QACjB,OAAO,cAAc;MACvB,KAAK,MAAM;QACT,OAAO,UAAU;IAAC;EAEvB;EAED,OAAO,SAAS;AAClB;AAEA;;;AAGG;AAEH,OAAM,SAAU,WAAW,CAAkB,UAAyB,EAAA;EACpE,IAAI,UAAU,CAAC,UAAU,CAAC,EAAE;IAC1B,OAAO,UAAU;GAClB,MAAM,IAAI,sBAAsB,CAAC,UAAU,CAAC,EAAE;IAC7C,OAAO,UAAU,CAAC,SAAS;EAC5B;EACD,OAAO,SAAS;AAClB;AAEA,OAAM,SAAU,kBAAkB,CAChC,UAAc,EAAA;EAEd,IAAI,iBAAiB,CAAI,UAAU,CAAC,EAAE;IACpC,OAAO,UAAU;GAClB,MAAM,IAAI,6BAA6B,CAAC,UAAU,CAAC,EAAE;IACpD,OAAO,UAAU,CAAC,SAAS;EAC5B;EACD,OAAO,SAAS;AAClB;AAEA;;AAEG;AACH,OAAM,SAAU,cAAc,CAC5B,UAA8B,EAC9B,OAAwB,EACxB,MAAc,EACqB;EAAA,IAAnC,GAAA,uEAAiC,CAAA,CAAE;EAEnC,IAAI,QAAQ,CAAC,UAAU,CAAC,IAAI,QAAQ,CAAC,UAAU,CAAC,IAAI,SAAS,CAAC,UAAU,CAAC,EAAE;IACzE,IAAM,aAAa,GAAG,QAAQ,CAAC,UAAU,CAAC,GAAG,QAAQ,GAAG,QAAQ,CAAC,UAAU,CAAC,GAAG,QAAQ,GAAG,SAAS;IACnG,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,mBAAmB,CAAC,OAAO,EAAE,aAAa,EAAE,UAAU,CAAC,CAAC;IAC7E,OAAO;MAAC,KAAK,EAAE;IAAU,CAAkB;EAC5C;EAED;EACA,IAAI,iBAAiB,CAAC,UAAU,CAAC,EAAE;IACjC,OAAO,mBAAmB,CAAC,UAAU,EAAE,OAAO,EAAE,MAAM,EAAE,GAAG,CAAC;GAC7D,MAAM,IAAI,6BAA6B,CAAC,UAAU,CAAC,EAAE;IACpD,OAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EACK,UAAU,CAAA,EAAA;MACb;MACA,SAAS,EAAE,mBAAmB,CAAC,UAAU,CAAC,SAAS,EAAE,OAAO,EAAE,MAAM,EAAE,GAAG;IAAuC,CAAA,CAAA;EAEnH;EACD,OAAO,UAAU;AACnB;AAEA,OAAM,SAAU,mBAAmB,CACjC,EAAoC,EACpC,OAAwB,EACxB,MAAc,EACd,GAA8B,EAAA;EAE9B,IAAI,uBAAuB,CAAC,EAAE,CAAC,EAAE;IAC/B,IAAO,MAAM,GAAyB,EAAE,CAAjC,MAAM;MAAE,UAAU,GAAa,EAAE,CAAzB,UAAU;MAAK,IAAI,GAAA,MAAA,CAAI,EAAE,EAAlC,CAAA,QAAA,EAAA,YAAA,CAA6B,CAAK;IACxC,IAAI,kBAAkB,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,iBAAiB,EAAE;MAC/D,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,0BAA0B,CAAC,OAAO,CAAC,CAAC;MACzD,OAAO,mBAAmB,CAAC,IAAI,EAAE,OAAO,EAAE,MAAM,EAAE,GAAG,CAAC;IACvD;GACF,MAAM;IACL,IAAM,SAAS,GAAG,yBAAyB,CAAC,EAAE,CAAC,GAC3C,MAAM,GACN,yBAAyB,CAAC,EAAE,CAAC,GAC7B,QAAQ,GACR,eAAe,CAAC,EAAE,CAAC,GACnB,QAAQ,GACR,IAAI;IACR,IAAI,SAAS,IAAI,EAAE,CAAC,SAAS,CAAC,EAAE;MACxB,IAAA,EAAA,GAAoC,EAAE,CAAC,SAAS,CAAhD;QAAC,QAAM,GAAY,EAA8B,CAAhD,MAAM;QAAE,YAAU,GAAA,EAA8B,CAAxC,UAAU;QAAK,QAAQ,GAAA,MAAA,CAAA,EAAA,EAAhC,CAAA,QAAA,EAAA,YAAA,CAAiC,CAAgB;MACvD,IAAI,kBAAkB,CAAC,YAAU,CAAC,IAAI,CAAC,MAAM,CAAC,iBAAiB,EAAE;QAC/D,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,0BAA0B,CAAC,OAAO,CAAC,CAAC;QACzD,OAAO,mBAAmB,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,EAAE,CAAA,sBAAG,SAAS,EAAG,QAAQ,EAAA,EAAG,OAAO,EAAE,MAAM,EAAE,GAAG,CAAC;MACjF;IACF;EACF;EAED,IAAI,UAAU,CAAC,EAAE,CAAC,EAAE;IAClB,OAAO,YAAY,CAAC,EAAE,EAAE,OAAO,EAAE,GAAG,CAAC;EACtC;EACD,OAAO,YAAY,CAAC,EAAE,CAAC;AACzB;AAEA,SAAS,YAAY,CAAC,QAAkB,EAAA;EACtC,IAAI,IAAI,GAAG,QAAQ,CAAC,MAAM,CAAC;EAC3B,IAAI,IAAI,EAAE;IACR,OAAO,QAAQ;EAChB;EACD,IAAO,KAAK,GAAI,QAAQ,CAAjB,KAAK;EACZ,IAAI,GAAG,QAAQ,CAAC,KAAK,CAAC,GAAG,cAAc,GAAG,QAAQ,CAAC,KAAK,CAAC,GAAG,SAAS,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,UAAU,GAAG,SAAS;EAElH,OAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAW,QAAQ,CAAA,EAAA;IAAE,IAAI,EAAJ;EAAI,CAAA,CAAA;AAC3B;AAEA,OAAM,SAAU,YAAY,CAC1B,EAAyB,EACzB,OAAwB,EAC+B;EAAA,gFAAF,CAAA,CAAE;IAAA,4BAAtD,aAAa;IAAb,aAAa,oCAAG,KAAK;EAEtB,IAAO,SAAS,GAA0B,EAAE,CAArC,SAAS;IAAE,QAAQ,GAAgB,EAAE,CAA1B,QAAQ;IAAE,GAAG,GAAW,EAAE,CAAhB,GAAG;IAAE,KAAK,GAAI,EAAE,CAAX,KAAK;EACtC,IAAM,QAAQ,GAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAO,EAAE,CAAC;EAExB;EACA,IAAI,CAAC,aAAa,IAAI,SAAS,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,EAAE;IAClH,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC;IACjD,OAAO,QAAQ,CAAC,SAAS;EAC1B;EAED;EACA,IAAI,QAAQ,EAAE;IACZ,QAAQ,CAAC,QAAQ,GAAG,iBAAiB,CAAC,QAAQ,CAAC;EAChD;EAED,IAAI,KAAK,EAAE;IACT,QAAQ,CAAC,KAAK,aAAM,KAAK,CAAE;EAC5B;EAED;EACA,IAAI,SAAS,CAAC,GAAG,CAAC,EAAE;IAClB,QAAQ,CAAC,GAAG,GAAG,YAAY,CAAC,GAAG,EAAE,OAAO,CAAC;EAC1C;EAED,IAAI,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE;IACrC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,+BAA+B,CAAC,OAAO,CAAC,CAAC;EAC/D;EAED;EACA,IAAI,eAAe,CAAC,QAAQ,CAAC,EAAE;IAC7B,IAAO,IAAI,GAAI,QAAQ,CAAhB,IAAI;IACX,IAAM,QAAQ,GAAG,WAAW,CAAC,IAAI,CAAC;IAClC,IAAI,IAAI,KAAK,QAAQ,EAAE;MACrB;MACA,QAAQ,CAAC,IAAI,GAAG,QAAQ;IACzB;IACD,IAAI,IAAI,KAAK,cAAc,EAAE;MAC3B,IAAI,qBAAqB,CAAC,SAAS,CAAC,EAAE;QACpC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,iCAAiC,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;QACxE,QAAQ,CAAC,IAAI,GAAG,cAAc;MAC/B;IACF;GACF,MAAM,IAAI,CAAC,uBAAuB,CAAC,OAAO,CAAC,EAAE;IAC5C;IACA,IAAM,OAAO,GAAG,WAAW,CAAC,QAA8B,EAAE,OAAO,CAAC;IACpE,QAAQ,CAAC,MAAM,CAAC,GAAG,OAAO;EAC3B;EAED,IAAI,eAAe,CAAC,QAAQ,CAAC,EAAE;IAC7B,YAA8B,oBAAoB,CAAC,QAAQ,EAAE,OAAO,CAAC,IAAI,CAAA,CAAE;MAApE,UAAU,SAAV,UAAU;MAAE,OAAO,SAAP,OAAO;IAC1B,IAAI,UAAU,KAAK,KAAK,EAAE;MACxB,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC;IAClB;EACF;EAED,IAAI,kBAAkB,CAAC,QAAQ,CAAC,IAAI,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;IAC3D,IAAO,IAAI,GAAI,QAAQ,CAAhB,IAAI;IACX,IAAI,eAAe,CAAC,IAAI,CAAC,EAAE;MACzB,OAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EACK,QAAQ,CAAA,EAAA;QACX,IAAI,EAAE;UAAC,QAAQ,EAAE;QAAI;MAAC,CAAA,CAAA;IAEzB;IACD,IAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;IAC1B,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI,eAAe,CAAC,GAAG,CAAC,EAAE;MAClD,OAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EACK,QAAQ,CAAA,EAAA;QACX,IAAI,EAAE;UAAC,QAAQ,EAAE,GAAG;UAAE,KAAK,EAAE;QAAY;MAAC,CAAA,CAAA;IAE7C;EACF;EAED,IAAI,eAAe,CAAC,QAAQ,CAAC,EAAE;IAC7B,IAAO,MAAM,GAAI,QAAQ,CAAlB,MAAM;IACb,IAAI,MAAM,EAAE;MACJ,IAAC,MAAM,GAAa,MAAM,CAAzB,MAAM;QAAK,IAAI,GAAA,MAAA,CAAI,MAAM,EAA1B,CAAA,QAAA,CAAiB,CAAS;MAChC,IAAI,MAAM,EAAE;QACV,OAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EACK,QAAQ,CAAA,EAAA;UACX,MAAM,EAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EACD,IAAI,CAAA,EAAA;YACP,WAAW,EAAE,MAAM,CAAC,WAAW,IAAI,MAAM;YACzC,WAAW,EAAE,MAAM,CAAC,WAAW,IAAI;UAAM,CAAA;QAAA,CAAA,CAAA;MAG9C;IACF;EACF;EAED,OAAO,QAAQ;AACjB;AAEA,OAAM,SAAU,YAAY,CAAC,GAAmC,EAAE,OAAyB,EAAA;EACzF,IAAI,SAAS,CAAC,GAAG,CAAC,EAAE;IAClB,OAAO;MAAC,OAAO,EAAE,WAAW,CAAC,OAAO;IAAC,CAAC;GACvC,MAAM,IAAI,GAAG,KAAK,QAAQ,EAAE;IAC3B,OAAO;MACL,MAAM,EAAE;KACT;GACF,MAAM,IAAI,CAAC,GAAG,CAAC,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE;IACpC,OAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAW,GAAG,CAAA,EAAA;MAAE,OAAO,EAAE,WAAW,CAAC,OAAO;IAAC,CAAA,CAAA;GAC9C,MAAM;IACL,OAAO,GAAG;EACX;AACH;AAEA,IAAM,UAAU,GAAG;EAAC,UAAU,EAAE;AAAI,CAAC;AACrC,OAAM,SAAU,oBAAoB,CAClC,QAA8B,EAC9B,OAAwB,EAAA;EAExB,IAAM,IAAI,GAAG,QAAQ,CAAC,IAAI;EAE1B,IAAI,IAAI,KAAK,SAAS,IAAI,OAAO,KAAK,OAAO,EAAE;IAC7C,OAAO;MACL,UAAU,EAAE,KAAK;MACjB,OAAO,oBAAa,OAAO;KAC5B;EACF;EAED,QAAQ,OAAO;IACb,KAAK,GAAG;IACR,KAAK,MAAM;IACX,KAAK,KAAK;MACR,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;QACzB,OAAO;UACL,UAAU,EAAE,KAAK;UACjB,OAAO,EAAE,GAAG,CAAC,OAAO,CAAC,uBAAuB,CAAC,OAAO;SACrD;MACF;MACD,OAAO,UAAU;IAEnB,KAAK,CAAC;IACN,KAAK,CAAC;IACN,KAAK,OAAO;IACZ,KAAK,OAAO;IACZ,KAAK,KAAK;IACV,KAAK,IAAI;IACT,KAAK,MAAM;IACX,KAAK,IAAI;IACT,KAAK,MAAM;IACX,KAAK,GAAG;IACR,KAAK,OAAO;IACZ,KAAK,IAAI;IACT,KAAK,GAAG;IACR,KAAK,KAAK;IACV,KAAK,KAAK;IACV,KAAK,MAAM;IACX,KAAK,WAAW;MACd,OAAO,UAAU;IAEnB,KAAK,SAAS;IACd,KAAK,UAAU;IACf,KAAK,QAAQ;IACb,KAAK,SAAS;MACZ,IAAI,IAAI,KAAK,YAAY,EAAE;QACzB,OAAO;UACL,UAAU,EAAE,KAAK;UACjB,OAAO,oBAAa,OAAO,iEAAuD,QAAQ,CAAC,IAAI;SAChG;MACF;MACD,OAAO,UAAU;IAEnB,KAAK,OAAO;IACZ,KAAK,WAAW;IAChB,KAAK,aAAa;IAClB,KAAK,WAAW;IAChB,KAAK,IAAI;IACT,KAAK,MAAM;IACX,KAAK,OAAO;IACZ,KAAK,EAAE;IACP,KAAK,EAAE;MACL,IAAI,IAAI,KAAK,SAAS,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;QAC3C,OAAO;UACL,UAAU,EAAE,KAAK;UACjB,OAAO,oBAAa,OAAO;SAC5B;MACF;MACD,OAAO,UAAU;IAEnB,KAAK,KAAK;IACV,KAAK,UAAU;MACb,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,EAAE;QACtD,OAAO;UACL,UAAU,EAAE,KAAK;UACjB,OAAO,EAAE,GAAG,CAAC,OAAO,CAAC,qCAAqC,CAAC,OAAO;SACnE;MACF;MACD,OAAO,UAAU;IAEnB,KAAK,KAAK;MACR,IAAI,QAAQ,CAAC,IAAI,KAAK,SAAS,IAAI,EAAE,MAAM,IAAI,QAAQ,CAAC,EAAE;QACxD,OAAO;UACL,UAAU,EAAE,KAAK;UACjB,OAAO;SACR;MACF;MACD,OAAO,UAAU;EAAC;AAExB;AAEA;;;AAGG;AACH,OAAM,SAAU,8BAA8B,CAAC,eAA4C,EAAA;EACzF,uBAAqB,eAAe,CAAC,eAAe,CAAC;IAA9C,UAAU,oBAAV,UAAU;EACjB,OAAO,UAAU,KAAK,MAAM,IAAK,CAAC,UAAU,IAAI,cAAc,CAAC,eAAe,CAAE;AAClF;AAEA;;AAEG;AACH,OAAM,SAAU,cAAc,CAAC,GAA6B,EAAA;EAC1D,OAAO,GAAG,KAAK,GAAG,CAAC,MAAM,CAAC,KAAK,UAAU,IAAK,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,QAAS,CAAC;AACnF;AAEA;;;AAGG;AACH,OAAM,SAAU,SAAS,CACvB,CAAwE,SAWvE;EAAA,IATC,QAAQ,SAAR,QAAQ;IACR,IAAI,SAAJ,IAAI;IACJ,QAAQ,SAAR,QAAQ;IACR,0BAA0B,SAA1B,0BAA0B;;EAQ5B,IAAM,IAAI,GAAG,QAAQ,KAAI,CAAA,EAAA,GAAA,iBAAiB,CAAC,QAAQ,CAAC,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,IAAI,CAAA;EAC1D,IAAI,MAAM,GAAG,IAAI,IAAI,IAAI,KAAK,UAAU;EAExC,IAAI,IAAI;EACR,IAAI,SAAS,CAAC,CAAC,CAAC,EAAE;IAChB,IAAI,GAAG,CAAC,CAAC,IAAI;GACd,MAAM,IAAI,WAAW,CAAC,CAAC,CAAC,EAAE;IACzB,IAAI,GAAG,CAAC,CAAC,MAAM;GAChB,MAAM,IAAI,UAAU,CAAC,CAAC,CAAC,EAAE;IACxB,MAAM,GAAG,IAAI;IACb,IAAI,GAAG,cAAc,CAAC,CAAC,CAAC;GACzB,MAAM,IAAI,QAAQ,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC,CAAC,CAAC,EAAE;IACrC,IAAI,MAAM,EAAE;MACV,IAAI,sBAAe,SAAS,CAAC,CAAC,CAAC,MAAG;MAElC,IAAI,qBAAqB,CAAC,IAAI,CAAC,EAAE;QAC/B;QACA,IAAK,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,KAAK,IAAM,QAAQ,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAE,EAAE;UACvE,IAAI,GAAG,cAAc,qBAAG,IAAI,EAAG,CAAC,EAAE;QACnC;MACF;IACF;EACF;EACD,IAAI,IAAI,EAAE;IACR,OAAO,QAAQ,IAAI,MAAM,kBAAW,IAAI,SAAM,IAAI;EACnD;EACD;EACA,OAAO,0BAA0B,GAAG,SAAS,GAAG,SAAS,CAAC,CAAC,CAAC;AAC9D;AAEA;;AAEG;AACH,OAAM,SAAU,UAAU,CACxB,eAAiD,EACjD,MAAgD,EAAA;EAEhD,IAAO,IAAI,GAAI,eAAe,CAAvB,IAAI;EACX,OAAO,MAAM,CAAC,GAAG,CAAC,UAAA,CAAC,EAAG;IACpB,IAAM,IAAI,GAAG,SAAS,CAAC,CAAC,EAAE;MACxB,QAAQ,EAAE,UAAU,CAAC,eAAe,CAAC,GAAG,eAAe,CAAC,QAAQ,GAAG,SAAS;MAC5E,IAAI,EAAJ,IAAI;MACJ,0BAA0B,EAAE;KAC7B,CAAC;IACF;IACA,IAAI,IAAI,KAAK,SAAS,EAAE;MACtB,OAAO;QAAC,MAAM,EAAE;MAAI,CAAC;IACtB;IACD;IACA,OAAO,CAAC;EACV,CAAC,CAAC;AACJ;AAEA;;AAEG;AACH,OAAM,SAAU,gBAAgB,CAAC,QAA0B,EAAE,OAAgB,EAAA;EAC3E,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;IAC5B,OAAO,CAAC,IAAI,CAAC,8CAA8C,CAAC;IAC5D,OAAO,KAAK;EACb;EAED;EACA;EACA,OAAO,cAAc,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,QAAQ,CAAE,QAAkC,CAAC,IAAI,CAAC;AAC7G","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isArray, isBoolean, isNumber, isString } from 'vega-util';\nimport { isAggregateOp, isArgmaxDef, isArgminDef, isCountingAggregateOp } from './aggregate';\nimport { autoMaxBins, binToString, isBinned, isBinning } from './bin';\nimport { ANGLE, COLOR, COLUMN, DESCRIPTION, DETAIL, FACET, FILL, FILLOPACITY, getSizeChannel, HREF, isScaleChannel, isSecondaryRangeChannel, isXorY, KEY, LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, OPACITY, ORDER, RADIUS, RADIUS2, ROW, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH, TEXT, THETA, THETA2, TOOLTIP, URL, X, X2, XOFFSET, Y, Y2, YOFFSET } from './channel';\nimport { getMarkConfig, getMarkPropOrConfig } from './compile/common';\nimport { isCustomFormatType } from './compile/format';\nimport { dateTimeToExpr, isDateTime } from './datetime';\nimport { isExprRef } from './expr';\nimport * as log from './log';\nimport { isRectBasedMark } from './mark';\nimport { hasDiscreteDomain, isContinuousToDiscrete, SCALE_CATEGORY_INDEX } from './scale';\nimport { isSortByChannel } from './sort';\nimport { isFacetFieldDef } from './spec/facet';\nimport { getTimeUnitParts, isLocalSingleTimeUnit, normalizeTimeUnit, timeUnitToString } from './timeunit';\nimport { getFullName, QUANTITATIVE } from './type';\nimport { flatAccessWithDatum, getFirstDefined, internalField, omit, removePathFromField, replacePathInField, stringify, titleCase } from './util';\nimport { isSignalRef } from './vega.schema';\nexport function isConditionalParameter(c) {\n    return c['param'];\n}\nexport function isRepeatRef(field) {\n    return field && !isString(field) && 'repeat' in field;\n}\nexport function toFieldDefBase(fieldDef) {\n    const { field, timeUnit, bin, aggregate } = fieldDef;\n    return Object.assign(Object.assign(Object.assign(Object.assign({}, (timeUnit ? { timeUnit } : {})), (bin ? { bin } : {})), (aggregate ? { aggregate } : {})), { field });\n}\nexport function isSortableFieldDef(fieldDef) {\n    return 'sort' in fieldDef;\n}\nexport function getBandPosition({ fieldDef, fieldDef2, markDef: mark, config }) {\n    if (isFieldOrDatumDef(fieldDef) && fieldDef.bandPosition !== undefined) {\n        return fieldDef.bandPosition;\n    }\n    if (isFieldDef(fieldDef)) {\n        const { timeUnit, bin } = fieldDef;\n        if (timeUnit && !fieldDef2) {\n            return isRectBasedMark(mark.type) ? 0 : getMarkConfig('timeUnitBandPosition', mark, config);\n        }\n        else if (isBinning(bin)) {\n            return 0.5;\n        }\n    }\n    return undefined;\n}\nexport function getBandSize({ channel, fieldDef, fieldDef2, markDef: mark, config, scaleType, useVlSizeChannel }) {\n    var _a, _b, _c;\n    const sizeChannel = getSizeChannel(channel);\n    const size = getMarkPropOrConfig(useVlSizeChannel ? 'size' : sizeChannel, mark, config, {\n        vgChannel: sizeChannel\n    });\n    if (size !== undefined) {\n        return size;\n    }\n    if (isFieldDef(fieldDef)) {\n        const { timeUnit, bin } = fieldDef;\n        if (timeUnit && !fieldDef2) {\n            return { band: getMarkConfig('timeUnitBandSize', mark, config) };\n        }\n        else if (isBinning(bin) && !hasDiscreteDomain(scaleType)) {\n            return { band: 1 };\n        }\n    }\n    if (isRectBasedMark(mark.type)) {\n        if (scaleType) {\n            if (hasDiscreteDomain(scaleType)) {\n                return ((_a = config[mark.type]) === null || _a === void 0 ? void 0 : _a.discreteBandSize) || { band: 1 };\n            }\n            else {\n                return (_b = config[mark.type]) === null || _b === void 0 ? void 0 : _b.continuousBandSize;\n            }\n        }\n        return (_c = config[mark.type]) === null || _c === void 0 ? void 0 : _c.discreteBandSize;\n    }\n    return undefined;\n}\nexport function hasBandEnd(fieldDef, fieldDef2, markDef, config) {\n    if (isBinning(fieldDef.bin) || (fieldDef.timeUnit && isTypedFieldDef(fieldDef) && fieldDef.type === 'temporal')) {\n        // Need to check bandPosition because non-rect marks (e.g., point) with timeUnit\n        // doesn't have to use bandEnd if there is no bandPosition.\n        return getBandPosition({ fieldDef, fieldDef2, markDef, config }) !== undefined;\n    }\n    return false;\n}\nexport function isConditionalDef(channelDef) {\n    return channelDef && 'condition' in channelDef;\n}\n/**\n * Return if a channelDef is a ConditionalValueDef with ConditionFieldDef\n */\nexport function hasConditionalFieldDef(channelDef) {\n    const condition = channelDef === null || channelDef === void 0 ? void 0 : channelDef['condition'];\n    return !!condition && !isArray(condition) && isFieldDef(condition);\n}\nexport function hasConditionalFieldOrDatumDef(channelDef) {\n    const condition = channelDef === null || channelDef === void 0 ? void 0 : channelDef['condition'];\n    return !!condition && !isArray(condition) && isFieldOrDatumDef(condition);\n}\nexport function hasConditionalValueDef(channelDef) {\n    const condition = channelDef === null || channelDef === void 0 ? void 0 : channelDef['condition'];\n    return !!condition && (isArray(condition) || isValueDef(condition));\n}\nexport function isFieldDef(channelDef) {\n    // TODO: we can't use field in channelDef here as it's somehow failing runtime test\n    return channelDef && (!!channelDef['field'] || channelDef['aggregate'] === 'count');\n}\nexport function channelDefType(channelDef) {\n    return channelDef === null || channelDef === void 0 ? void 0 : channelDef['type'];\n}\nexport function isDatumDef(channelDef) {\n    return channelDef && 'datum' in channelDef;\n}\nexport function isContinuousFieldOrDatumDef(cd) {\n    // TODO: make datum support DateTime object\n    return (isTypedFieldDef(cd) && !isDiscrete(cd)) || isNumericDataDef(cd);\n}\nexport function isQuantitativeFieldOrDatumDef(cd) {\n    // TODO: make datum support DateTime object\n    return channelDefType(cd) === 'quantitative' || isNumericDataDef(cd);\n}\nexport function isNumericDataDef(cd) {\n    return isDatumDef(cd) && isNumber(cd.datum);\n}\nexport function isFieldOrDatumDef(channelDef) {\n    return isFieldDef(channelDef) || isDatumDef(channelDef);\n}\nexport function isTypedFieldDef(channelDef) {\n    return channelDef && ('field' in channelDef || channelDef['aggregate'] === 'count') && 'type' in channelDef;\n}\nexport function isValueDef(channelDef) {\n    return channelDef && 'value' in channelDef && 'value' in channelDef;\n}\nexport function isScaleFieldDef(channelDef) {\n    return channelDef && ('scale' in channelDef || 'sort' in channelDef);\n}\nexport function isPositionFieldOrDatumDef(channelDef) {\n    return channelDef && ('axis' in channelDef || 'stack' in channelDef || 'impute' in channelDef);\n}\nexport function isMarkPropFieldOrDatumDef(channelDef) {\n    return channelDef && 'legend' in channelDef;\n}\nexport function isStringFieldOrDatumDef(channelDef) {\n    return channelDef && ('format' in channelDef || 'formatType' in channelDef);\n}\nexport function toStringFieldDef(fieldDef) {\n    // omit properties that don't exist in string field defs\n    return omit(fieldDef, ['legend', 'axis', 'header', 'scale']);\n}\nfunction isOpFieldDef(fieldDef) {\n    return 'op' in fieldDef;\n}\n/**\n * Get a Vega field reference from a Vega-Lite field def.\n */\nexport function vgField(fieldDef, opt = {}) {\n    var _a, _b, _c;\n    let field = fieldDef.field;\n    const prefix = opt.prefix;\n    let suffix = opt.suffix;\n    let argAccessor = ''; // for accessing argmin/argmax field at the end without getting escaped\n    if (isCount(fieldDef)) {\n        field = internalField('count');\n    }\n    else {\n        let fn;\n        if (!opt.nofn) {\n            if (isOpFieldDef(fieldDef)) {\n                fn = fieldDef.op;\n            }\n            else {\n                const { bin, aggregate, timeUnit } = fieldDef;\n                if (isBinning(bin)) {\n                    fn = binToString(bin);\n                    suffix = ((_a = opt.binSuffix) !== null && _a !== void 0 ? _a : '') + ((_b = opt.suffix) !== null && _b !== void 0 ? _b : '');\n                }\n                else if (aggregate) {\n                    if (isArgmaxDef(aggregate)) {\n                        argAccessor = `[\"${field}\"]`;\n                        field = `argmax_${aggregate.argmax}`;\n                    }\n                    else if (isArgminDef(aggregate)) {\n                        argAccessor = `[\"${field}\"]`;\n                        field = `argmin_${aggregate.argmin}`;\n                    }\n                    else {\n                        fn = String(aggregate);\n                    }\n                }\n                else if (timeUnit) {\n                    fn = timeUnitToString(timeUnit);\n                    suffix = ((!['range', 'mid'].includes(opt.binSuffix) && opt.binSuffix) || '') + ((_c = opt.suffix) !== null && _c !== void 0 ? _c : '');\n                }\n            }\n        }\n        if (fn) {\n            field = field ? `${fn}_${field}` : fn;\n        }\n    }\n    if (suffix) {\n        field = `${field}_${suffix}`;\n    }\n    if (prefix) {\n        field = `${prefix}_${field}`;\n    }\n    if (opt.forAs) {\n        return removePathFromField(field);\n    }\n    else if (opt.expr) {\n        // Expression to access flattened field. No need to escape dots.\n        return flatAccessWithDatum(field, opt.expr) + argAccessor;\n    }\n    else {\n        // We flattened all fields so paths should have become dot.\n        return replacePathInField(field) + argAccessor;\n    }\n}\nexport function isDiscrete(def) {\n    switch (def.type) {\n        case 'nominal':\n        case 'ordinal':\n        case 'geojson':\n            return true;\n        case 'quantitative':\n            return isFieldDef(def) && !!def.bin;\n        case 'temporal':\n            return false;\n    }\n    throw new Error(log.message.invalidFieldType(def.type));\n}\nexport function isDiscretizing(def) {\n    var _a;\n    return isScaleFieldDef(def) && isContinuousToDiscrete((_a = def.scale) === null || _a === void 0 ? void 0 : _a.type);\n}\nexport function isCount(fieldDef) {\n    return fieldDef.aggregate === 'count';\n}\nexport function verbalTitleFormatter(fieldDef, config) {\n    var _a;\n    const { field, bin, timeUnit, aggregate } = fieldDef;\n    if (aggregate === 'count') {\n        return config.countTitle;\n    }\n    else if (isBinning(bin)) {\n        return `${field} (binned)`;\n    }\n    else if (timeUnit) {\n        const unit = (_a = normalizeTimeUnit(timeUnit)) === null || _a === void 0 ? void 0 : _a.unit;\n        if (unit) {\n            return `${field} (${getTimeUnitParts(unit).join('-')})`;\n        }\n    }\n    else if (aggregate) {\n        if (isArgmaxDef(aggregate)) {\n            return `${field} for max ${aggregate.argmax}`;\n        }\n        else if (isArgminDef(aggregate)) {\n            return `${field} for min ${aggregate.argmin}`;\n        }\n        else {\n            return `${titleCase(aggregate)} of ${field}`;\n        }\n    }\n    return field;\n}\nexport function functionalTitleFormatter(fieldDef) {\n    const { aggregate, bin, timeUnit, field } = fieldDef;\n    if (isArgmaxDef(aggregate)) {\n        return `${field} for argmax(${aggregate.argmax})`;\n    }\n    else if (isArgminDef(aggregate)) {\n        return `${field} for argmin(${aggregate.argmin})`;\n    }\n    const timeUnitParams = normalizeTimeUnit(timeUnit);\n    const fn = aggregate || (timeUnitParams === null || timeUnitParams === void 0 ? void 0 : timeUnitParams.unit) || ((timeUnitParams === null || timeUnitParams === void 0 ? void 0 : timeUnitParams.maxbins) && 'timeunit') || (isBinning(bin) && 'bin');\n    if (fn) {\n        return `${fn.toUpperCase()}(${field})`;\n    }\n    else {\n        return field;\n    }\n}\nexport const defaultTitleFormatter = (fieldDef, config) => {\n    switch (config.fieldTitle) {\n        case 'plain':\n            return fieldDef.field;\n        case 'functional':\n            return functionalTitleFormatter(fieldDef);\n        default:\n            return verbalTitleFormatter(fieldDef, config);\n    }\n};\nlet titleFormatter = defaultTitleFormatter;\nexport function setTitleFormatter(formatter) {\n    titleFormatter = formatter;\n}\nexport function resetTitleFormatter() {\n    setTitleFormatter(defaultTitleFormatter);\n}\nexport function title(fieldOrDatumDef, config, { allowDisabling, includeDefault = true }) {\n    var _a, _b;\n    const guideTitle = (_a = getGuide(fieldOrDatumDef)) === null || _a === void 0 ? void 0 : _a.title;\n    if (!isFieldDef(fieldOrDatumDef)) {\n        return guideTitle !== null && guideTitle !== void 0 ? guideTitle : fieldOrDatumDef.title;\n    }\n    const fieldDef = fieldOrDatumDef;\n    const def = includeDefault ? defaultTitle(fieldDef, config) : undefined;\n    if (allowDisabling) {\n        return getFirstDefined(guideTitle, fieldDef.title, def);\n    }\n    else {\n        return (_b = guideTitle !== null && guideTitle !== void 0 ? guideTitle : fieldDef.title) !== null && _b !== void 0 ? _b : def;\n    }\n}\nexport function getGuide(fieldDef) {\n    if (isPositionFieldOrDatumDef(fieldDef) && fieldDef.axis) {\n        return fieldDef.axis;\n    }\n    else if (isMarkPropFieldOrDatumDef(fieldDef) && fieldDef.legend) {\n        return fieldDef.legend;\n    }\n    else if (isFacetFieldDef(fieldDef) && fieldDef.header) {\n        return fieldDef.header;\n    }\n    return undefined;\n}\nexport function defaultTitle(fieldDef, config) {\n    return titleFormatter(fieldDef, config);\n}\nexport function getFormatMixins(fieldDef) {\n    var _a;\n    if (isStringFieldOrDatumDef(fieldDef)) {\n        const { format, formatType } = fieldDef;\n        return { format, formatType };\n    }\n    else {\n        const guide = (_a = getGuide(fieldDef)) !== null && _a !== void 0 ? _a : {};\n        const { format, formatType } = guide;\n        return { format, formatType };\n    }\n}\nexport function defaultType(fieldDef, channel) {\n    var _a;\n    switch (channel) {\n        case 'latitude':\n        case 'longitude':\n            return 'quantitative';\n        case 'row':\n        case 'column':\n        case 'facet':\n        case 'shape':\n        case 'strokeDash':\n            return 'nominal';\n        case 'order':\n            return 'ordinal';\n    }\n    if (isSortableFieldDef(fieldDef) && isArray(fieldDef.sort)) {\n        return 'ordinal';\n    }\n    const { aggregate, bin, timeUnit } = fieldDef;\n    if (timeUnit) {\n        return 'temporal';\n    }\n    if (bin || (aggregate && !isArgmaxDef(aggregate) && !isArgminDef(aggregate))) {\n        return 'quantitative';\n    }\n    if (isScaleFieldDef(fieldDef) && ((_a = fieldDef.scale) === null || _a === void 0 ? void 0 : _a.type)) {\n        switch (SCALE_CATEGORY_INDEX[fieldDef.scale.type]) {\n            case 'numeric':\n            case 'discretizing':\n                return 'quantitative';\n            case 'time':\n                return 'temporal';\n        }\n    }\n    return 'nominal';\n}\n/**\n * Returns the fieldDef -- either from the outer channelDef or from the condition of channelDef.\n * @param channelDef\n */\nexport function getFieldDef(channelDef) {\n    if (isFieldDef(channelDef)) {\n        return channelDef;\n    }\n    else if (hasConditionalFieldDef(channelDef)) {\n        return channelDef.condition;\n    }\n    return undefined;\n}\nexport function getFieldOrDatumDef(channelDef) {\n    if (isFieldOrDatumDef(channelDef)) {\n        return channelDef;\n    }\n    else if (hasConditionalFieldOrDatumDef(channelDef)) {\n        return channelDef.condition;\n    }\n    return undefined;\n}\n/**\n * Convert type to full, lowercase type, or augment the fieldDef with a default type if missing.\n */\nexport function initChannelDef(channelDef, channel, config, opt = {}) {\n    if (isString(channelDef) || isNumber(channelDef) || isBoolean(channelDef)) {\n        const primitiveType = isString(channelDef) ? 'string' : isNumber(channelDef) ? 'number' : 'boolean';\n        log.warn(log.message.primitiveChannelDef(channel, primitiveType, channelDef));\n        return { value: channelDef };\n    }\n    // If a fieldDef contains a field, we need type.\n    if (isFieldOrDatumDef(channelDef)) {\n        return initFieldOrDatumDef(channelDef, channel, config, opt);\n    }\n    else if (hasConditionalFieldOrDatumDef(channelDef)) {\n        return Object.assign(Object.assign({}, channelDef), { \n            // Need to cast as normalizeFieldDef normally return FieldDef, but here we know that it is definitely Condition<FieldDef>\n            condition: initFieldOrDatumDef(channelDef.condition, channel, config, opt) });\n    }\n    return channelDef;\n}\nexport function initFieldOrDatumDef(fd, channel, config, opt) {\n    if (isStringFieldOrDatumDef(fd)) {\n        const { format, formatType } = fd, rest = __rest(fd, [\"format\", \"formatType\"]);\n        if (isCustomFormatType(formatType) && !config.customFormatTypes) {\n            log.warn(log.message.customFormatTypeNotAllowed(channel));\n            return initFieldOrDatumDef(rest, channel, config, opt);\n        }\n    }\n    else {\n        const guideType = isPositionFieldOrDatumDef(fd)\n            ? 'axis'\n            : isMarkPropFieldOrDatumDef(fd)\n                ? 'legend'\n                : isFacetFieldDef(fd)\n                    ? 'header'\n                    : null;\n        if (guideType && fd[guideType]) {\n            const _a = fd[guideType], { format, formatType } = _a, newGuide = __rest(_a, [\"format\", \"formatType\"]);\n            if (isCustomFormatType(formatType) && !config.customFormatTypes) {\n                log.warn(log.message.customFormatTypeNotAllowed(channel));\n                return initFieldOrDatumDef(Object.assign(Object.assign({}, fd), { [guideType]: newGuide }), channel, config, opt);\n            }\n        }\n    }\n    if (isFieldDef(fd)) {\n        return initFieldDef(fd, channel, opt);\n    }\n    return initDatumDef(fd);\n}\nfunction initDatumDef(datumDef) {\n    let type = datumDef['type'];\n    if (type) {\n        return datumDef;\n    }\n    const { datum } = datumDef;\n    type = isNumber(datum) ? 'quantitative' : isString(datum) ? 'nominal' : isDateTime(datum) ? 'temporal' : undefined;\n    return Object.assign(Object.assign({}, datumDef), { type });\n}\nexport function initFieldDef(fd, channel, { compositeMark = false } = {}) {\n    const { aggregate, timeUnit, bin, field } = fd;\n    const fieldDef = Object.assign({}, fd);\n    // Drop invalid aggregate\n    if (!compositeMark && aggregate && !isAggregateOp(aggregate) && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {\n        log.warn(log.message.invalidAggregate(aggregate));\n        delete fieldDef.aggregate;\n    }\n    // Normalize Time Unit\n    if (timeUnit) {\n        fieldDef.timeUnit = normalizeTimeUnit(timeUnit);\n    }\n    if (field) {\n        fieldDef.field = `${field}`;\n    }\n    // Normalize bin\n    if (isBinning(bin)) {\n        fieldDef.bin = normalizeBin(bin, channel);\n    }\n    if (isBinned(bin) && !isXorY(channel)) {\n        log.warn(log.message.channelShouldNotBeUsedForBinned(channel));\n    }\n    // Normalize Type\n    if (isTypedFieldDef(fieldDef)) {\n        const { type } = fieldDef;\n        const fullType = getFullName(type);\n        if (type !== fullType) {\n            // convert short type to full type\n            fieldDef.type = fullType;\n        }\n        if (type !== 'quantitative') {\n            if (isCountingAggregateOp(aggregate)) {\n                log.warn(log.message.invalidFieldTypeForCountAggregate(type, aggregate));\n                fieldDef.type = 'quantitative';\n            }\n        }\n    }\n    else if (!isSecondaryRangeChannel(channel)) {\n        // If type is empty / invalid, then augment with default type\n        const newType = defaultType(fieldDef, channel);\n        fieldDef['type'] = newType;\n    }\n    if (isTypedFieldDef(fieldDef)) {\n        const { compatible, warning } = channelCompatibility(fieldDef, channel) || {};\n        if (compatible === false) {\n            log.warn(warning);\n        }\n    }\n    if (isSortableFieldDef(fieldDef) && isString(fieldDef.sort)) {\n        const { sort } = fieldDef;\n        if (isSortByChannel(sort)) {\n            return Object.assign(Object.assign({}, fieldDef), { sort: { encoding: sort } });\n        }\n        const sub = sort.substr(1);\n        if (sort.charAt(0) === '-' && isSortByChannel(sub)) {\n            return Object.assign(Object.assign({}, fieldDef), { sort: { encoding: sub, order: 'descending' } });\n        }\n    }\n    if (isFacetFieldDef(fieldDef)) {\n        const { header } = fieldDef;\n        if (header) {\n            const { orient } = header, rest = __rest(header, [\"orient\"]);\n            if (orient) {\n                return Object.assign(Object.assign({}, fieldDef), { header: Object.assign(Object.assign({}, rest), { labelOrient: header.labelOrient || orient, titleOrient: header.titleOrient || orient }) });\n            }\n        }\n    }\n    return fieldDef;\n}\nexport function normalizeBin(bin, channel) {\n    if (isBoolean(bin)) {\n        return { maxbins: autoMaxBins(channel) };\n    }\n    else if (bin === 'binned') {\n        return {\n            binned: true\n        };\n    }\n    else if (!bin.maxbins && !bin.step) {\n        return Object.assign(Object.assign({}, bin), { maxbins: autoMaxBins(channel) });\n    }\n    else {\n        return bin;\n    }\n}\nconst COMPATIBLE = { compatible: true };\nexport function channelCompatibility(fieldDef, channel) {\n    const type = fieldDef.type;\n    if (type === 'geojson' && channel !== 'shape') {\n        return {\n            compatible: false,\n            warning: `Channel ${channel} should not be used with a geojson data.`\n        };\n    }\n    switch (channel) {\n        case ROW:\n        case COLUMN:\n        case FACET:\n            if (!isDiscrete(fieldDef)) {\n                return {\n                    compatible: false,\n                    warning: log.message.channelShouldBeDiscrete(channel)\n                };\n            }\n            return COMPATIBLE;\n        case X:\n        case Y:\n        case XOFFSET:\n        case YOFFSET:\n        case COLOR:\n        case FILL:\n        case STROKE:\n        case TEXT:\n        case DETAIL:\n        case KEY:\n        case TOOLTIP:\n        case HREF:\n        case URL:\n        case ANGLE:\n        case THETA:\n        case RADIUS:\n        case DESCRIPTION:\n            return COMPATIBLE;\n        case LONGITUDE:\n        case LONGITUDE2:\n        case LATITUDE:\n        case LATITUDE2:\n            if (type !== QUANTITATIVE) {\n                return {\n                    compatible: false,\n                    warning: `Channel ${channel} should be used with a quantitative field only, not ${fieldDef.type} field.`\n                };\n            }\n            return COMPATIBLE;\n        case OPACITY:\n        case FILLOPACITY:\n        case STROKEOPACITY:\n        case STROKEWIDTH:\n        case SIZE:\n        case THETA2:\n        case RADIUS2:\n        case X2:\n        case Y2:\n            if (type === 'nominal' && !fieldDef['sort']) {\n                return {\n                    compatible: false,\n                    warning: `Channel ${channel} should not be used with an unsorted discrete field.`\n                };\n            }\n            return COMPATIBLE;\n        case SHAPE:\n        case STROKEDASH:\n            if (!isDiscrete(fieldDef) && !isDiscretizing(fieldDef)) {\n                return {\n                    compatible: false,\n                    warning: log.message.channelShouldBeDiscreteOrDiscretizing(channel)\n                };\n            }\n            return COMPATIBLE;\n        case ORDER:\n            if (fieldDef.type === 'nominal' && !('sort' in fieldDef)) {\n                return {\n                    compatible: false,\n                    warning: `Channel order is inappropriate for nominal field, which has no inherent order.`\n                };\n            }\n            return COMPATIBLE;\n    }\n}\n/**\n * Check if the field def uses a time format or does not use any format but is temporal\n * (this does not cover field defs that are temporal but use a number format).\n */\nexport function isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) {\n    const { formatType } = getFormatMixins(fieldOrDatumDef);\n    return formatType === 'time' || (!formatType && isTimeFieldDef(fieldOrDatumDef));\n}\n/**\n * Check if field def has type `temporal`. If you want to also cover field defs that use a time format, use `isTimeFormatFieldDef`.\n */\nexport function isTimeFieldDef(def) {\n    return def && (def['type'] === 'temporal' || (isFieldDef(def) && !!def.timeUnit));\n}\n/**\n * Getting a value associated with a fielddef.\n * Convert the value to Vega expression if applicable (for datetime object, or string if the field def is temporal or has timeUnit)\n */\nexport function valueExpr(v, { timeUnit, type, wrapTime, undefinedIfExprNotRequired }) {\n    var _a;\n    const unit = timeUnit && ((_a = normalizeTimeUnit(timeUnit)) === null || _a === void 0 ? void 0 : _a.unit);\n    let isTime = unit || type === 'temporal';\n    let expr;\n    if (isExprRef(v)) {\n        expr = v.expr;\n    }\n    else if (isSignalRef(v)) {\n        expr = v.signal;\n    }\n    else if (isDateTime(v)) {\n        isTime = true;\n        expr = dateTimeToExpr(v);\n    }\n    else if (isString(v) || isNumber(v)) {\n        if (isTime) {\n            expr = `datetime(${stringify(v)})`;\n            if (isLocalSingleTimeUnit(unit)) {\n                // for single timeUnit, we will use dateTimeToExpr to convert number/string to match the timeUnit\n                if ((isNumber(v) && v < 10000) || (isString(v) && isNaN(Date.parse(v)))) {\n                    expr = dateTimeToExpr({ [unit]: v });\n                }\n            }\n        }\n    }\n    if (expr) {\n        return wrapTime && isTime ? `time(${expr})` : expr;\n    }\n    // number or boolean or normal string\n    return undefinedIfExprNotRequired ? undefined : stringify(v);\n}\n/**\n * Standardize value array -- convert each value to Vega expression if applicable\n */\nexport function valueArray(fieldOrDatumDef, values) {\n    const { type } = fieldOrDatumDef;\n    return values.map(v => {\n        const expr = valueExpr(v, {\n            timeUnit: isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.timeUnit : undefined,\n            type,\n            undefinedIfExprNotRequired: true\n        });\n        // return signal for the expression if we need an expression\n        if (expr !== undefined) {\n            return { signal: expr };\n        }\n        // otherwise just return the original value\n        return v;\n    });\n}\n/**\n * Checks whether a fieldDef for a particular channel requires a computed bin range.\n */\nexport function binRequiresRange(fieldDef, channel) {\n    if (!isBinning(fieldDef.bin)) {\n        console.warn('Only call this method for binned field defs.');\n        return false;\n    }\n    // We need the range only when the user explicitly forces a binned field to be use discrete scale. In this case, bin range is used in axis and legend labels.\n    // We could check whether the axis or legend exists (not disabled) but that seems overkill.\n    return isScaleChannel(channel) && ['ordinal', 'nominal'].includes(fieldDef.type);\n}\n//# sourceMappingURL=channeldef.js.map"]},"metadata":{},"sourceType":"module"}