{"ast":null,"code":"import _defineProperty from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { Transform, rederive, ingest, replace } from 'vega-dataflow';\nimport { error, extent, inherits, identity, isArray, isFunction, isNumber, constant, array, one, accessorName, accessorFields, field, extend, toSet, zero } from 'vega-util';\nimport { tickStep, range, max, sum } from 'd3-array';\nimport { bandwidthNRD } from 'vega-statistics';\nimport { getProjectionPath, projectionProperties, projection } from 'vega-projection';\nimport { geoGraticule } from 'd3-geo';\nimport { rgb } from 'd3-color';\nimport { canvas } from 'vega-canvas';\nfunction noop() {}\nvar cases = [[], [[[1.0, 1.5], [0.5, 1.0]]], [[[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [0.5, 1.0]]], [[[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 0.5], [1.0, 1.5]]], [[[1.0, 0.5], [0.5, 1.0]]], [[[0.5, 1.0], [1.0, 0.5]]], [[[1.0, 1.5], [1.0, 0.5]]], [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [1.0, 0.5]]], [[[0.5, 1.0], [1.5, 1.0]]], [[[1.0, 1.5], [1.5, 1.0]]], [[[0.5, 1.0], [1.0, 1.5]]], []]; // Implementation adapted from d3/d3-contour. Thanks!\n\nfunction contours() {\n  var dx = 1,\n    dy = 1,\n    smooth = smoothLinear;\n  function contours(values, tz) {\n    return tz.map(function (value) {\n      return contour(values, value);\n    });\n  } // Accumulate, smooth contour rings, assign holes to exterior rings.\n  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js\n\n  function contour(values, value) {\n    var polygons = [],\n      holes = [];\n    isorings(values, value, function (ring) {\n      smooth(ring, values, value);\n      if (area(ring) > 0) polygons.push([ring]);else holes.push(ring);\n    });\n    holes.forEach(function (hole) {\n      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {\n        if (contains((polygon = polygons[i])[0], hole) !== -1) {\n          polygon.push(hole);\n          return;\n        }\n      }\n    });\n    return {\n      type: 'MultiPolygon',\n      value: value,\n      coordinates: polygons\n    };\n  } // Marching squares with isolines stitched into rings.\n  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js\n\n  function isorings(values, value, callback) {\n    var fragmentByStart = new Array(),\n      fragmentByEnd = new Array(),\n      x,\n      y,\n      t0,\n      t1,\n      t2,\n      t3; // Special case for the first row (y = -1, t2 = t3 = 0).\n\n    x = y = -1;\n    t1 = values[0] >= value;\n    cases[t1 << 1].forEach(stitch);\n    while (++x < dx - 1) {\n      t0 = t1, t1 = values[x + 1] >= value;\n      cases[t0 | t1 << 1].forEach(stitch);\n    }\n    cases[t1 << 0].forEach(stitch); // General case for the intermediate rows.\n\n    while (++y < dy - 1) {\n      x = -1;\n      t1 = values[y * dx + dx] >= value;\n      t2 = values[y * dx] >= value;\n      cases[t1 << 1 | t2 << 2].forEach(stitch);\n      while (++x < dx - 1) {\n        t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;\n        t3 = t2, t2 = values[y * dx + x + 1] >= value;\n        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);\n      }\n      cases[t1 | t2 << 3].forEach(stitch);\n    } // Special case for the last row (y = dy - 1, t0 = t1 = 0).\n\n    x = -1;\n    t2 = values[y * dx] >= value;\n    cases[t2 << 2].forEach(stitch);\n    while (++x < dx - 1) {\n      t3 = t2, t2 = values[y * dx + x + 1] >= value;\n      cases[t2 << 2 | t3 << 3].forEach(stitch);\n    }\n    cases[t2 << 3].forEach(stitch);\n    function stitch(line) {\n      var start = [line[0][0] + x, line[0][1] + y],\n        end = [line[1][0] + x, line[1][1] + y],\n        startIndex = index(start),\n        endIndex = index(end),\n        f,\n        g;\n      if (f = fragmentByEnd[startIndex]) {\n        if (g = fragmentByStart[endIndex]) {\n          delete fragmentByEnd[f.end];\n          delete fragmentByStart[g.start];\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[f.start] = fragmentByEnd[g.end] = {\n              start: f.start,\n              end: g.end,\n              ring: f.ring.concat(g.ring)\n            };\n          }\n        } else {\n          delete fragmentByEnd[f.end];\n          f.ring.push(end);\n          fragmentByEnd[f.end = endIndex] = f;\n        }\n      } else if (f = fragmentByStart[endIndex]) {\n        if (g = fragmentByEnd[startIndex]) {\n          delete fragmentByStart[f.start];\n          delete fragmentByEnd[g.end];\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[g.start] = fragmentByEnd[f.end] = {\n              start: g.start,\n              end: f.end,\n              ring: g.ring.concat(f.ring)\n            };\n          }\n        } else {\n          delete fragmentByStart[f.start];\n          f.ring.unshift(start);\n          fragmentByStart[f.start = startIndex] = f;\n        }\n      } else {\n        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {\n          start: startIndex,\n          end: endIndex,\n          ring: [start, end]\n        };\n      }\n    }\n  }\n  function index(point) {\n    return point[0] * 2 + point[1] * (dx + 1) * 4;\n  }\n  function smoothLinear(ring, values, value) {\n    ring.forEach(function (point) {\n      var x = point[0],\n        y = point[1],\n        xt = x | 0,\n        yt = y | 0,\n        v0,\n        v1 = values[yt * dx + xt];\n      if (x > 0 && x < dx && xt === x) {\n        v0 = values[yt * dx + xt - 1];\n        point[0] = x + (value - v0) / (v1 - v0) - 0.5;\n      }\n      if (y > 0 && y < dy && yt === y) {\n        v0 = values[(yt - 1) * dx + xt];\n        point[1] = y + (value - v0) / (v1 - v0) - 0.5;\n      }\n    });\n  }\n  contours.contour = contour;\n  contours.size = function (_) {\n    if (!arguments.length) return [dx, dy];\n    var _0 = Math.floor(_[0]),\n      _1 = Math.floor(_[1]);\n    if (!(_0 >= 0 && _1 >= 0)) error('invalid size');\n    return dx = _0, dy = _1, contours;\n  };\n  contours.smooth = function (_) {\n    return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;\n  };\n  return contours;\n}\nfunction area(ring) {\n  var i = 0,\n    n = ring.length,\n    area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];\n  while (++i < n) {\n    area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];\n  }\n  return area;\n}\nfunction contains(ring, hole) {\n  var i = -1,\n    n = hole.length,\n    c;\n  while (++i < n) {\n    if (c = ringContains(ring, hole[i])) return c;\n  }\n  return 0;\n}\nfunction ringContains(ring, point) {\n  var x = point[0],\n    y = point[1],\n    contains = -1;\n  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {\n    var pi = ring[i],\n      xi = pi[0],\n      yi = pi[1],\n      pj = ring[j],\n      xj = pj[0],\n      yj = pj[1];\n    if (segmentContains(pi, pj, point)) return 0;\n    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) contains = -contains;\n  }\n  return contains;\n}\nfunction segmentContains(a, b, c) {\n  var i;\n  return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);\n}\nfunction collinear(a, b, c) {\n  return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);\n}\nfunction within(p, q, r) {\n  return p <= q && q <= r || r <= q && q <= p;\n}\nfunction quantize(k, nice, zero) {\n  return function (values) {\n    var ex = extent(values),\n      start = zero ? Math.min(ex[0], 0) : ex[0],\n      stop = ex[1],\n      span = stop - start,\n      step = nice ? tickStep(start, stop, k) : span / (k + 1);\n    return range(start + step, stop, step);\n  };\n}\n\n/**\n * Generate isocontours (level sets) based on input raster grid data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} [params.field] - The field with raster grid\n *   data. If unspecified, the tuple itself is interpreted as a raster grid.\n * @param {Array<number>} [params.thresholds] - Contour threshold array. If\n *   specified, the levels, nice, resolve, and zero parameters are ignored.\n * @param {number} [params.levels] - The desired number of contour levels.\n * @param {boolean} [params.nice] - Boolean flag indicating if the contour\n *   threshold values should be automatically aligned to \"nice\"\n *   human-friendly values. Setting this flag may cause the number of\n *   thresholds to deviate from the specified levels.\n * @param {string} [params.resolve] - The method for resolving thresholds\n *   across multiple input grids. If 'independent' (the default), threshold\n *   calculation will be performed separately for each grid. If 'shared', a\n *   single set of threshold values will be used for all input grids.\n * @param {boolean} [params.zero] - Boolean flag indicating if the contour\n *   threshold values should include zero.\n * @param {boolean} [params.smooth] - Boolean flag indicating if the contour\n *   polygons should be smoothed using linear interpolation. The default is\n *   true. The parameter is ignored when using density estimation.\n * @param {boolean} [params.scale] - Optional numerical value by which to\n *   scale the output isocontour coordinates. This parameter can be useful\n *   to scale the contours to match a desired output resolution.\n * @param {string} [params.as='contour'] - The output field in which to store\n *   the generated isocontour data (default 'contour').\n */\n\nfunction Isocontour(params) {\n  Transform.call(this, null, params);\n}\nIsocontour.Definition = {\n  'type': 'Isocontour',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'thresholds',\n    'type': 'number',\n    'array': true\n  }, {\n    'name': 'levels',\n    'type': 'number'\n  }, {\n    'name': 'nice',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'resolve',\n    'type': 'enum',\n    'values': ['shared', 'independent'],\n    'default': 'independent'\n  }, {\n    'name': 'zero',\n    'type': 'boolean',\n    'default': true\n  }, {\n    'name': 'smooth',\n    'type': 'boolean',\n    'default': true\n  }, {\n    'name': 'scale',\n    'type': 'number',\n    'expr': true\n  }, {\n    'name': 'translate',\n    'type': 'number',\n    'array': true,\n    'expr': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'null': true,\n    'default': 'contour'\n  }]\n};\ninherits(Isocontour, Transform, {\n  transform: function transform(_, pulse) {\n    if (this.value && !pulse.changed() && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      source = pulse.materialize(pulse.SOURCE).source,\n      field = _.field || identity,\n      contour = contours().smooth(_.smooth !== false),\n      tz = _.thresholds || levels(source, field, _),\n      as = _.as === null ? null : _.as || 'contour',\n      values = [];\n    source.forEach(function (t) {\n      var grid = field(t); // generate contour paths in GeoJSON format\n\n      var paths = contour.size([grid.width, grid.height])(grid.values, isArray(tz) ? tz : tz(grid.values)); // adjust contour path coordinates as needed\n\n      transformPaths(paths, grid, t, _); // ingest; copy source data properties to output\n\n      paths.forEach(function (p) {\n        values.push(rederive(t, ingest(as != null ? _defineProperty({}, as, p) : p)));\n      });\n    });\n    if (this.value) out.rem = this.value;\n    this.value = out.source = out.add = values;\n    return out;\n  }\n});\nfunction levels(values, f, _) {\n  var q = quantize(_.levels || 10, _.nice, _.zero !== false);\n  return _.resolve !== 'shared' ? q : q(values.map(function (t) {\n    return max(f(t).values);\n  }));\n}\nfunction transformPaths(paths, grid, datum, _) {\n  var s = _.scale || grid.scale,\n    t = _.translate || grid.translate;\n  if (isFunction(s)) s = s(datum, _);\n  if (isFunction(t)) t = t(datum, _);\n  if ((s === 1 || s == null) && !t) return;\n  var sx = (isNumber(s) ? s : s[0]) || 1,\n    sy = (isNumber(s) ? s : s[1]) || 1,\n    tx = t && t[0] || 0,\n    ty = t && t[1] || 0;\n  paths.forEach(_transform(grid, sx, sy, tx, ty));\n}\nfunction _transform(grid, sx, sy, tx, ty) {\n  var x1 = grid.x1 || 0,\n    y1 = grid.y1 || 0,\n    flip = sx * sy < 0;\n  function transformPolygon(coordinates) {\n    coordinates.forEach(transformRing);\n  }\n  function transformRing(coordinates) {\n    if (flip) coordinates.reverse(); // maintain winding order\n\n    coordinates.forEach(transformPoint);\n  }\n  function transformPoint(coordinates) {\n    coordinates[0] = (coordinates[0] - x1) * sx + tx;\n    coordinates[1] = (coordinates[1] - y1) * sy + ty;\n  }\n  return function (geometry) {\n    geometry.coordinates.forEach(transformPolygon);\n    return geometry;\n  };\n}\nfunction radius(bw, data, f) {\n  var v = bw >= 0 ? bw : bandwidthNRD(data, f);\n  return Math.round((Math.sqrt(4 * v * v + 1) - 1) / 2);\n}\nfunction number(_) {\n  return isFunction(_) ? _ : constant(+_);\n} // Implementation adapted from d3/d3-contour. Thanks!\n\nfunction density2D() {\n  var x = function x(d) {\n      return d[0];\n    },\n    y = function y(d) {\n      return d[1];\n    },\n    weight = one,\n    bandwidth = [-1, -1],\n    dx = 960,\n    dy = 500,\n    k = 2; // log2(cellSize)\n\n  function density(data, counts) {\n    var rx = radius(bandwidth[0], data, x) >> k,\n      // blur x-radius\n      ry = radius(bandwidth[1], data, y) >> k,\n      // blur y-radius\n      ox = rx ? rx + 2 : 0,\n      // x-offset padding for blur\n      oy = ry ? ry + 2 : 0,\n      // y-offset padding for blur\n      n = 2 * ox + (dx >> k),\n      // grid width\n      m = 2 * oy + (dy >> k),\n      // grid height\n      values0 = new Float32Array(n * m),\n      values1 = new Float32Array(n * m);\n    var values = values0;\n    data.forEach(function (d) {\n      var xi = ox + (+x(d) >> k),\n        yi = oy + (+y(d) >> k);\n      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {\n        values0[xi + yi * n] += +weight(d);\n      }\n    });\n    if (rx > 0 && ry > 0) {\n      blurX(n, m, values0, values1, rx);\n      blurY(n, m, values1, values0, ry);\n      blurX(n, m, values0, values1, rx);\n      blurY(n, m, values1, values0, ry);\n      blurX(n, m, values0, values1, rx);\n      blurY(n, m, values1, values0, ry);\n    } else if (rx > 0) {\n      blurX(n, m, values0, values1, rx);\n      blurX(n, m, values1, values0, rx);\n      blurX(n, m, values0, values1, rx);\n      values = values1;\n    } else if (ry > 0) {\n      blurY(n, m, values0, values1, ry);\n      blurY(n, m, values1, values0, ry);\n      blurY(n, m, values0, values1, ry);\n      values = values1;\n    } // scale density estimates\n    // density in points per square pixel or probability density\n\n    var s = counts ? Math.pow(2, -2 * k) : 1 / sum(values);\n    for (var i = 0, sz = n * m; i < sz; ++i) {\n      values[i] *= s;\n    }\n    return {\n      values: values,\n      scale: 1 << k,\n      width: n,\n      height: m,\n      x1: ox,\n      y1: oy,\n      x2: ox + (dx >> k),\n      y2: oy + (dy >> k)\n    };\n  }\n  density.x = function (_) {\n    return arguments.length ? (x = number(_), density) : x;\n  };\n  density.y = function (_) {\n    return arguments.length ? (y = number(_), density) : y;\n  };\n  density.weight = function (_) {\n    return arguments.length ? (weight = number(_), density) : weight;\n  };\n  density.size = function (_) {\n    if (!arguments.length) return [dx, dy];\n    var _0 = +_[0],\n      _1 = +_[1];\n    if (!(_0 >= 0 && _1 >= 0)) error('invalid size');\n    return dx = _0, dy = _1, density;\n  };\n  density.cellSize = function (_) {\n    if (!arguments.length) return 1 << k;\n    if (!((_ = +_) >= 1)) error('invalid cell size');\n    k = Math.floor(Math.log(_) / Math.LN2);\n    return density;\n  };\n  density.bandwidth = function (_) {\n    if (!arguments.length) return bandwidth;\n    _ = array(_);\n    if (_.length === 1) _ = [+_[0], +_[0]];\n    if (_.length !== 2) error('invalid bandwidth');\n    return bandwidth = _, density;\n  };\n  return density;\n}\nfunction blurX(n, m, source, target, r) {\n  var w = (r << 1) + 1;\n  for (var j = 0; j < m; ++j) {\n    for (var i = 0, sr = 0; i < n + r; ++i) {\n      if (i < n) {\n        sr += source[i + j * n];\n      }\n      if (i >= r) {\n        if (i >= w) {\n          sr -= source[i - w + j * n];\n        }\n        target[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);\n      }\n    }\n  }\n}\nfunction blurY(n, m, source, target, r) {\n  var w = (r << 1) + 1;\n  for (var i = 0; i < n; ++i) {\n    for (var j = 0, sr = 0; j < m + r; ++j) {\n      if (j < m) {\n        sr += source[i + j * n];\n      }\n      if (j >= r) {\n        if (j >= w) {\n          sr -= source[i + (j - w) * n];\n        }\n        target[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);\n      }\n    }\n  }\n}\n\n/**\n * Perform 2D kernel-density estimation of point data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The [width, height] extent (in\n *   units of input pixels) over which to perform density estimation.\n * @param {function(object): number} params.x - The x-coordinate accessor.\n * @param {function(object): number} params.y - The y-coordinate accessor.\n * @param {function(object): number} [params.weight] - The weight accessor.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors\n *   to groupby.\n * @param {number} [params.cellSize] - Contour density calculation cell size.\n *   This parameter determines the level of spatial approximation. For example,\n *   the default value of 4 maps to 2x reductions in both x- and y- dimensions.\n *   A value of 1 will result in an output raster grid whose dimensions exactly\n *   matches the size parameter.\n * @param {Array<number>} [params.bandwidth] - The KDE kernel bandwidths,\n *   in pixels. The input can be a two-element array specifying separate\n *   x and y bandwidths, or a single-element array specifying both. If the\n *   bandwidth is unspecified or less than zero, the bandwidth will be\n *   automatically determined.\n * @param {boolean} [params.counts=false] - A boolean flag indicating if the\n *   output values should be probability estimates (false, default) or\n *   smoothed counts (true).\n * @param {string} [params.as='grid'] - The output field in which to store\n *   the generated raster grid (default 'grid').\n */\n\nfunction KDE2D(params) {\n  Transform.call(this, null, params);\n}\nKDE2D.Definition = {\n  'type': 'KDE2D',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2,\n    'required': true\n  }, {\n    'name': 'x',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'y',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'weight',\n    'type': 'field'\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'cellSize',\n    'type': 'number'\n  }, {\n    'name': 'bandwidth',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'counts',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'grid'\n  }]\n};\nvar PARAMS = ['x', 'y', 'weight', 'size', 'cellSize', 'bandwidth'];\nfunction params(obj, _) {\n  PARAMS.forEach(function (param) {\n    return _[param] != null ? obj[param](_[param]) : 0;\n  });\n  return obj;\n}\ninherits(KDE2D, Transform, {\n  transform: function transform(_, pulse) {\n    if (this.value && !pulse.changed() && !_.modified()) return pulse.StopPropagation;\n    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      source = pulse.materialize(pulse.SOURCE).source,\n      groups = partition(source, _.groupby),\n      names = (_.groupby || []).map(accessorName),\n      kde = params(density2D(), _),\n      as = _.as || 'grid',\n      values = [];\n    function set(t, vals) {\n      for (var i = 0; i < names.length; ++i) {\n        t[names[i]] = vals[i];\n      }\n      return t;\n    } // generate density raster grids\n\n    values = groups.map(function (g) {\n      return ingest(set(_defineProperty({}, as, kde(g, _.counts)), g.dims));\n    });\n    if (this.value) out.rem = this.value;\n    this.value = out.source = out.add = values;\n    return out;\n  }\n});\nfunction partition(data, groupby) {\n  var groups = [],\n    get = function get(f) {\n      return f(t);\n    },\n    map,\n    i,\n    n,\n    t,\n    k,\n    g; // partition data points into groups\n\n  if (groupby == null) {\n    groups.push(data);\n  } else {\n    for (map = {}, i = 0, n = data.length; i < n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n      if (!g) {\n        map[k] = g = [];\n        g.dims = k;\n        groups.push(g);\n      }\n      g.push(t);\n    }\n  }\n  return groups;\n}\n\n/**\n * Generate contours based on kernel-density estimation of point data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The dimensions [width, height] over which to compute contours.\n *  If the values parameter is provided, this must be the dimensions of the input data.\n *  If density estimation is performed, this is the output view dimensions in pixels.\n * @param {Array<number>} [params.values] - An array of numeric values representing an\n *  width x height grid of values over which to compute contours. If unspecified, this\n *  transform will instead attempt to compute contours for the kernel density estimate\n *  using values drawn from data tuples in the input pulse.\n * @param {function(object): number} [params.x] - The pixel x-coordinate accessor for density estimation.\n * @param {function(object): number} [params.y] - The pixel y-coordinate accessor for density estimation.\n * @param {function(object): number} [params.weight] - The data point weight accessor for density estimation.\n * @param {number} [params.cellSize] - Contour density calculation cell size.\n * @param {number} [params.bandwidth] - Kernel density estimation bandwidth.\n * @param {Array<number>} [params.thresholds] - Contour threshold array. If\n *   this parameter is set, the count and nice parameters will be ignored.\n * @param {number} [params.count] - The desired number of contours.\n * @param {boolean} [params.nice] - Boolean flag indicating if the contour\n *   threshold values should be automatically aligned to \"nice\"\n *   human-friendly values. Setting this flag may cause the number of\n *   thresholds to deviate from the specified count.\n * @param {boolean} [params.smooth] - Boolean flag indicating if the contour\n *   polygons should be smoothed using linear interpolation. The default is\n *   true. The parameter is ignored when using density estimation.\n */\n\nfunction Contour(params) {\n  Transform.call(this, null, params);\n}\nContour.Definition = {\n  'type': 'Contour',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2,\n    'required': true\n  }, {\n    'name': 'values',\n    'type': 'number',\n    'array': true\n  }, {\n    'name': 'x',\n    'type': 'field'\n  }, {\n    'name': 'y',\n    'type': 'field'\n  }, {\n    'name': 'weight',\n    'type': 'field'\n  }, {\n    'name': 'cellSize',\n    'type': 'number'\n  }, {\n    'name': 'bandwidth',\n    'type': 'number'\n  }, {\n    'name': 'count',\n    'type': 'number'\n  }, {\n    'name': 'nice',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'thresholds',\n    'type': 'number',\n    'array': true\n  }, {\n    'name': 'smooth',\n    'type': 'boolean',\n    'default': true\n  }]\n};\ninherits(Contour, Transform, {\n  transform: function transform(_, pulse) {\n    if (this.value && !pulse.changed() && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      contour = contours().smooth(_.smooth !== false),\n      values = _.values,\n      thresh = _.thresholds || quantize(_.count || 10, _.nice, !!values),\n      size = _.size,\n      grid,\n      post;\n    if (!values) {\n      values = pulse.materialize(pulse.SOURCE).source;\n      grid = params(density2D(), _)(values, true);\n      post = _transform(grid, grid.scale || 1, grid.scale || 1, 0, 0);\n      size = [grid.width, grid.height];\n      values = grid.values;\n    }\n    thresh = isArray(thresh) ? thresh : thresh(values);\n    values = contour.size(size)(values, thresh);\n    if (post) values.forEach(post);\n    if (this.value) out.rem = this.value;\n    this.value = out.source = out.add = (values || []).map(ingest);\n    return out;\n  }\n});\nvar Feature = 'Feature';\nvar FeatureCollection = 'FeatureCollection';\nvar MultiPoint = 'MultiPoint';\n\n/**\n * Consolidate an array of [longitude, latitude] points or GeoJSON features\n * into a combined GeoJSON object. This transform is particularly useful for\n * combining geo data for a Projection's fit argument. The resulting GeoJSON\n * data is available as this transform's value. Input pulses are unchanged.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} [params.fields] - A two-element array\n *   of field accessors for the longitude and latitude values.\n * @param {function(object): *} params.geojson - A field accessor for\n *   retrieving GeoJSON feature data.\n */\n\nfunction GeoJSON(params) {\n  Transform.call(this, null, params);\n}\nGeoJSON.Definition = {\n  'type': 'GeoJSON',\n  'metadata': {},\n  'params': [{\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'geojson',\n    'type': 'field'\n  }]\n};\ninherits(GeoJSON, Transform, {\n  transform: function transform(_, pulse) {\n    var features = this._features,\n      points = this._points,\n      fields = _.fields,\n      lon = fields && fields[0],\n      lat = fields && fields[1],\n      geojson = _.geojson || !fields && identity,\n      flag = pulse.ADD,\n      mod;\n    mod = _.modified() || pulse.changed(pulse.REM) || pulse.modified(accessorFields(geojson)) || lon && pulse.modified(accessorFields(lon)) || lat && pulse.modified(accessorFields(lat));\n    if (!this.value || mod) {\n      flag = pulse.SOURCE;\n      this._features = features = [];\n      this._points = points = [];\n    }\n    if (geojson) {\n      pulse.visit(flag, function (t) {\n        return features.push(geojson(t));\n      });\n    }\n    if (lon && lat) {\n      pulse.visit(flag, function (t) {\n        var x = lon(t),\n          y = lat(t);\n        if (x != null && y != null && (x = +x) === x && (y = +y) === y) {\n          points.push([x, y]);\n        }\n      });\n      features = features.concat({\n        type: Feature,\n        geometry: {\n          type: MultiPoint,\n          coordinates: points\n        }\n      });\n    }\n    this.value = {\n      type: FeatureCollection,\n      features: features\n    };\n  }\n});\n\n/**\n * Map GeoJSON data to an SVG path string.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(number, number): *} params.projection - The cartographic\n *   projection to apply.\n * @param {function(object): *} [params.field] - The field with GeoJSON data,\n *   or null if the tuple itself is a GeoJSON feature.\n * @param {string} [params.as='path'] - The output field in which to store\n *   the generated path data (default 'path').\n */\n\nfunction GeoPath(params) {\n  Transform.call(this, null, params);\n}\nGeoPath.Definition = {\n  'type': 'GeoPath',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'projection',\n    'type': 'projection'\n  }, {\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'pointRadius',\n    'type': 'number',\n    'expr': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'path'\n  }]\n};\ninherits(GeoPath, Transform, {\n  transform: function transform(_, pulse) {\n    var out = pulse.fork(pulse.ALL),\n      path = this.value,\n      field = _.field || identity,\n      as = _.as || 'path',\n      flag = out.SOURCE;\n    if (!path || _.modified()) {\n      // parameters updated, reset and reflow\n      this.value = path = getProjectionPath(_.projection);\n      out.materialize().reflow();\n    } else {\n      flag = field === identity || pulse.modified(field.fields) ? out.ADD_MOD : out.ADD;\n    }\n    var prev = initPath(path, _.pointRadius);\n    out.visit(flag, function (t) {\n      return t[as] = path(field(t));\n    });\n    path.pointRadius(prev);\n    return out.modifies(as);\n  }\n});\nfunction initPath(path, pointRadius) {\n  var prev = path.pointRadius();\n  path.context(null);\n  if (pointRadius != null) {\n    path.pointRadius(pointRadius);\n  }\n  return prev;\n}\n\n/**\n * Geo-code a longitude/latitude point to an x/y coordinate.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(number, number): *} params.projection - The cartographic\n *   projection to apply.\n * @param {Array<function(object): *>} params.fields - A two-element array of\n *   field accessors for the longitude and latitude values.\n * @param {Array<string>} [params.as] - A two-element array of field names\n *   under which to store the result. Defaults to ['x','y'].\n */\n\nfunction GeoPoint(params) {\n  Transform.call(this, null, params);\n}\nGeoPoint.Definition = {\n  'type': 'GeoPoint',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'projection',\n    'type': 'projection',\n    'required': true\n  }, {\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'required': true,\n    'length': 2\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': ['x', 'y']\n  }]\n};\ninherits(GeoPoint, Transform, {\n  transform: function transform(_, pulse) {\n    var proj = _.projection,\n      lon = _.fields[0],\n      lat = _.fields[1],\n      as = _.as || ['x', 'y'],\n      x = as[0],\n      y = as[1],\n      mod;\n    function set(t) {\n      var xy = proj([lon(t), lat(t)]);\n      if (xy) {\n        t[x] = xy[0];\n        t[y] = xy[1];\n      } else {\n        t[x] = undefined;\n        t[y] = undefined;\n      }\n    }\n    if (_.modified()) {\n      // parameters updated, reflow\n      pulse = pulse.materialize().reflow(true).visit(pulse.SOURCE, set);\n    } else {\n      mod = pulse.modified(lon.fields) || pulse.modified(lat.fields);\n      pulse.visit(mod ? pulse.ADD_MOD : pulse.ADD, set);\n    }\n    return pulse.modifies(as);\n  }\n});\n\n/**\n * Annotate items with a geopath shape generator.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(number, number): *} params.projection - The cartographic\n *   projection to apply.\n * @param {function(object): *} [params.field] - The field with GeoJSON data,\n *   or null if the tuple itself is a GeoJSON feature.\n * @param {string} [params.as='shape'] - The output field in which to store\n *   the generated path data (default 'shape').\n */\n\nfunction GeoShape(params) {\n  Transform.call(this, null, params);\n}\nGeoShape.Definition = {\n  'type': 'GeoShape',\n  'metadata': {\n    'modifies': true,\n    'nomod': true\n  },\n  'params': [{\n    'name': 'projection',\n    'type': 'projection'\n  }, {\n    'name': 'field',\n    'type': 'field',\n    'default': 'datum'\n  }, {\n    'name': 'pointRadius',\n    'type': 'number',\n    'expr': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'shape'\n  }]\n};\ninherits(GeoShape, Transform, {\n  transform: function transform(_, pulse) {\n    var out = pulse.fork(pulse.ALL),\n      shape = this.value,\n      as = _.as || 'shape',\n      flag = out.ADD;\n    if (!shape || _.modified()) {\n      // parameters updated, reset and reflow\n      this.value = shape = shapeGenerator(getProjectionPath(_.projection), _.field || field('datum'), _.pointRadius);\n      out.materialize().reflow();\n      flag = out.SOURCE;\n    }\n    out.visit(flag, function (t) {\n      return t[as] = shape;\n    });\n    return out.modifies(as);\n  }\n});\nfunction shapeGenerator(path, field, pointRadius) {\n  var shape = pointRadius == null ? function (_) {\n    return path(field(_));\n  } : function (_) {\n    var prev = path.pointRadius(),\n      value = path.pointRadius(pointRadius)(field(_));\n    path.pointRadius(prev);\n    return value;\n  };\n  shape.context = function (_) {\n    path.context(_);\n    return shape;\n  };\n  return shape;\n}\n\n/**\n * GeoJSON feature generator for creating graticules.\n * @constructor\n */\n\nfunction Graticule(params) {\n  Transform.call(this, [], params);\n  this.generator = geoGraticule();\n}\nGraticule.Definition = {\n  'type': 'Graticule',\n  'metadata': {\n    'changes': true,\n    'generates': true\n  },\n  'params': [{\n    'name': 'extent',\n    'type': 'array',\n    'array': true,\n    'length': 2,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }, {\n    'name': 'extentMajor',\n    'type': 'array',\n    'array': true,\n    'length': 2,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }, {\n    'name': 'extentMinor',\n    'type': 'array',\n    'array': true,\n    'length': 2,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }, {\n    'name': 'step',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'stepMajor',\n    'type': 'number',\n    'array': true,\n    'length': 2,\n    'default': [90, 360]\n  }, {\n    'name': 'stepMinor',\n    'type': 'number',\n    'array': true,\n    'length': 2,\n    'default': [10, 10]\n  }, {\n    'name': 'precision',\n    'type': 'number',\n    'default': 2.5\n  }]\n};\ninherits(Graticule, Transform, {\n  transform: function transform(_, pulse) {\n    var src = this.value,\n      gen = this.generator,\n      t;\n    if (!src.length || _.modified()) {\n      for (var prop in _) {\n        if (isFunction(gen[prop])) {\n          gen[prop](_[prop]);\n        }\n      }\n    }\n    t = gen();\n    if (src.length) {\n      pulse.mod.push(replace(src[0], t));\n    } else {\n      pulse.add.push(ingest(t));\n    }\n    src[0] = t;\n    return pulse;\n  }\n});\n\n/**\n * Render a heatmap image for input raster grid data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} [params.field] - The field with raster grid\n *   data. If unspecified, the tuple itself is interpreted as a raster grid.\n * @param {string} [params.color] - A constant color value or function for\n *   individual pixel color. If a function, it will be invoked with an input\n *   object that includes $x, $y, $value, and $max fields for the grid.\n * @param {number} [params.opacity] - A constant opacity value or function for\n *   individual pixel opacity. If a function, it will be invoked with an input\n *   object that includes $x, $y, $value, and $max fields for the grid.\n * @param {string} [params.resolve] - The method for resolving maximum values\n *   across multiple input grids. If 'independent' (the default), maximum\n *   calculation will be performed separately for each grid. If 'shared',\n *   a single global maximum will be used for all input grids.\n * @param {string} [params.as='image'] - The output field in which to store\n *   the generated bitmap canvas images (default 'image').\n */\n\nfunction Heatmap(params) {\n  Transform.call(this, null, params);\n}\nHeatmap.Definition = {\n  'type': 'heatmap',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'color',\n    'type': 'string',\n    'expr': true\n  }, {\n    'name': 'opacity',\n    'type': 'number',\n    'expr': true\n  }, {\n    'name': 'resolve',\n    'type': 'enum',\n    'values': ['shared', 'independent'],\n    'default': 'independent'\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'image'\n  }]\n};\ninherits(Heatmap, Transform, {\n  transform: function transform(_, pulse) {\n    if (!pulse.changed() && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n    var source = pulse.materialize(pulse.SOURCE).source,\n      shared = _.resolve === 'shared',\n      field = _.field || identity,\n      opacity = opacity_(_.opacity, _),\n      color = color_(_.color, _),\n      as = _.as || 'image',\n      obj = {\n        $x: 0,\n        $y: 0,\n        $value: 0,\n        $max: shared ? max(source.map(function (t) {\n          return max(field(t).values);\n        })) : 0\n      };\n    source.forEach(function (t) {\n      var v = field(t); // build proxy data object\n\n      var o = extend({}, t, obj); // set maximum value if not globally shared\n\n      if (!shared) o.$max = max(v.values || []); // generate canvas image\n      // optimize color/opacity if not pixel-dependent\n\n      t[as] = toCanvas(v, o, color.dep ? color : constant(color(o)), opacity.dep ? opacity : constant(opacity(o)));\n    });\n    return pulse.reflow(true).modifies(as);\n  }\n}); // get image color function\n\nfunction color_(color, _) {\n  var f;\n  if (isFunction(color)) {\n    f = function f(obj) {\n      return rgb(color(obj, _));\n    };\n    f.dep = dependency(color);\n  } else {\n    // default to mid-grey\n    f = constant(rgb(color || '#888'));\n  }\n  return f;\n} // get image opacity function\n\nfunction opacity_(opacity, _) {\n  var f;\n  if (isFunction(opacity)) {\n    f = function f(obj) {\n      return opacity(obj, _);\n    };\n    f.dep = dependency(opacity);\n  } else if (opacity) {\n    f = constant(opacity);\n  } else {\n    // default to [0, max] opacity gradient\n    f = function f(obj) {\n      return obj.$value / obj.$max || 0;\n    };\n    f.dep = true;\n  }\n  return f;\n} // check if function depends on individual pixel data\n\nfunction dependency(f) {\n  if (!isFunction(f)) return false;\n  var set = toSet(accessorFields(f));\n  return set.$x || set.$y || set.$value || set.$max;\n} // render raster grid to canvas\n\nfunction toCanvas(grid, obj, color, opacity) {\n  var n = grid.width,\n    m = grid.height,\n    x1 = grid.x1 || 0,\n    y1 = grid.y1 || 0,\n    x2 = grid.x2 || n,\n    y2 = grid.y2 || m,\n    val = grid.values,\n    value = val ? function (i) {\n      return val[i];\n    } : zero,\n    can = canvas(x2 - x1, y2 - y1),\n    ctx = can.getContext('2d'),\n    img = ctx.getImageData(0, 0, x2 - x1, y2 - y1),\n    pix = img.data;\n  for (var j = y1, k = 0; j < y2; ++j) {\n    obj.$y = j - y1;\n    for (var i = x1, r = j * n; i < x2; ++i, k += 4) {\n      obj.$x = i - x1;\n      obj.$value = value(i + r);\n      var v = color(obj);\n      pix[k + 0] = v.r;\n      pix[k + 1] = v.g;\n      pix[k + 2] = v.b;\n      pix[k + 3] = ~~(255 * opacity(obj));\n    }\n  }\n  ctx.putImageData(img, 0, 0);\n  return can;\n}\n\n/**\n * Maintains a cartographic projection.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction Projection(params) {\n  Transform.call(this, null, params);\n  this.modified(true); // always treat as modified\n}\n\ninherits(Projection, Transform, {\n  transform: function transform(_, pulse) {\n    var proj = this.value;\n    if (!proj || _.modified('type')) {\n      this.value = proj = create(_.type);\n      projectionProperties.forEach(function (prop) {\n        if (_[prop] != null) set(proj, prop, _[prop]);\n      });\n    } else {\n      projectionProperties.forEach(function (prop) {\n        if (_.modified(prop)) set(proj, prop, _[prop]);\n      });\n    }\n    if (_.pointRadius != null) proj.path.pointRadius(_.pointRadius);\n    if (_.fit) fit(proj, _);\n    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n  }\n});\nfunction fit(proj, _) {\n  var data = collectGeoJSON(_.fit);\n  _.extent ? proj.fitExtent(_.extent, data) : _.size ? proj.fitSize(_.size, data) : 0;\n}\nfunction create(type) {\n  var constructor = projection((type || 'mercator').toLowerCase());\n  if (!constructor) error('Unrecognized projection type: ' + type);\n  return constructor();\n}\nfunction set(proj, key, value) {\n  if (isFunction(proj[key])) proj[key](value);\n}\nfunction collectGeoJSON(data) {\n  data = array(data);\n  return data.length === 1 ? data[0] : {\n    type: FeatureCollection,\n    features: data.reduce(function (a, f) {\n      return a.concat(featurize(f));\n    }, [])\n  };\n}\nfunction featurize(f) {\n  return f.type === FeatureCollection ? f.features : array(f).filter(function (d) {\n    return d != null;\n  }).map(function (d) {\n    return d.type === Feature ? d : {\n      type: Feature,\n      geometry: d\n    };\n  });\n}\nexport { Contour as contour, GeoJSON as geojson, GeoPath as geopath, GeoPoint as geopoint, GeoShape as geoshape, Graticule as graticule, Heatmap as heatmap, Isocontour as isocontour, KDE2D as kde2d, Projection as projection };","map":{"version":3,"names":["Transform","rederive","ingest","replace","error","extent","inherits","identity","isArray","isFunction","isNumber","constant","array","one","accessorName","accessorFields","field","extend","toSet","zero","tickStep","range","max","sum","bandwidthNRD","getProjectionPath","projectionProperties","projection","geoGraticule","rgb","canvas","noop","cases","contours","dx","dy","smooth","smoothLinear","values","tz","map","value","contour","polygons","holes","isorings","ring","area","push","forEach","hole","i","n","length","polygon","contains","type","coordinates","callback","fragmentByStart","Array","fragmentByEnd","x","y","t0","t1","t2","t3","stitch","line","start","end","startIndex","index","endIndex","f","g","concat","unshift","point","xt","yt","v0","v1","size","_","arguments","_0","Math","floor","_1","c","ringContains","j","pi","xi","yi","pj","xj","yj","segmentContains","a","b","collinear","within","p","q","r","quantize","k","nice","ex","min","stop","span","step","Isocontour","params","call","Definition","transform","pulse","changed","modified","StopPropagation","out","fork","NO_SOURCE","NO_FIELDS","source","materialize","SOURCE","thresholds","levels","as","t","grid","paths","width","height","transformPaths","rem","add","resolve","datum","s","scale","translate","sx","sy","tx","ty","x1","y1","flip","transformPolygon","transformRing","reverse","transformPoint","geometry","radius","bw","data","v","round","sqrt","number","density2D","d","weight","bandwidth","density","counts","rx","ry","ox","oy","m","values0","Float32Array","values1","blurX","blurY","pow","sz","x2","y2","cellSize","log","LN2","target","w","sr","KDE2D","PARAMS","obj","param","groups","partition","groupby","names","kde","set","vals","dims","get","Contour","thresh","count","post","Feature","FeatureCollection","MultiPoint","GeoJSON","features","_features","points","_points","fields","lon","lat","geojson","flag","ADD","mod","REM","visit","GeoPath","ALL","path","reflow","ADD_MOD","prev","initPath","pointRadius","modifies","context","GeoPoint","proj","xy","undefined","GeoShape","shape","shapeGenerator","Graticule","generator","src","gen","prop","Heatmap","shared","opacity","opacity_","color","color_","$x","$y","$value","$max","o","toCanvas","dep","dependency","val","can","ctx","getContext","img","getImageData","pix","putImageData","Projection","create","fit","collectGeoJSON","fitExtent","fitSize","constructor","toLowerCase","key","reduce","featurize","filter","geopath","geopoint","geoshape","graticule","heatmap","isocontour","kde2d"],"sources":["/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/vega-geo/build/vega-geo.module.js"],"sourcesContent":["import { Transform, rederive, ingest, replace } from 'vega-dataflow';\nimport { error, extent, inherits, identity, isArray, isFunction, isNumber, constant, array, one, accessorName, accessorFields, field, extend, toSet, zero } from 'vega-util';\nimport { tickStep, range, max, sum } from 'd3-array';\nimport { bandwidthNRD } from 'vega-statistics';\nimport { getProjectionPath, projectionProperties, projection } from 'vega-projection';\nimport { geoGraticule } from 'd3-geo';\nimport { rgb } from 'd3-color';\nimport { canvas } from 'vega-canvas';\n\nfunction noop() {}\n\nconst cases = [[], [[[1.0, 1.5], [0.5, 1.0]]], [[[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [0.5, 1.0]]], [[[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 0.5], [1.0, 1.5]]], [[[1.0, 0.5], [0.5, 1.0]]], [[[0.5, 1.0], [1.0, 0.5]]], [[[1.0, 1.5], [1.0, 0.5]]], [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [1.0, 0.5]]], [[[0.5, 1.0], [1.5, 1.0]]], [[[1.0, 1.5], [1.5, 1.0]]], [[[0.5, 1.0], [1.0, 1.5]]], []]; // Implementation adapted from d3/d3-contour. Thanks!\n\nfunction contours () {\n  var dx = 1,\n      dy = 1,\n      smooth = smoothLinear;\n\n  function contours(values, tz) {\n    return tz.map(value => contour(values, value));\n  } // Accumulate, smooth contour rings, assign holes to exterior rings.\n  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js\n\n\n  function contour(values, value) {\n    var polygons = [],\n        holes = [];\n    isorings(values, value, ring => {\n      smooth(ring, values, value);\n      if (area(ring) > 0) polygons.push([ring]);else holes.push(ring);\n    });\n    holes.forEach(hole => {\n      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {\n        if (contains((polygon = polygons[i])[0], hole) !== -1) {\n          polygon.push(hole);\n          return;\n        }\n      }\n    });\n    return {\n      type: 'MultiPolygon',\n      value: value,\n      coordinates: polygons\n    };\n  } // Marching squares with isolines stitched into rings.\n  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js\n\n\n  function isorings(values, value, callback) {\n    var fragmentByStart = new Array(),\n        fragmentByEnd = new Array(),\n        x,\n        y,\n        t0,\n        t1,\n        t2,\n        t3; // Special case for the first row (y = -1, t2 = t3 = 0).\n\n    x = y = -1;\n    t1 = values[0] >= value;\n    cases[t1 << 1].forEach(stitch);\n\n    while (++x < dx - 1) {\n      t0 = t1, t1 = values[x + 1] >= value;\n      cases[t0 | t1 << 1].forEach(stitch);\n    }\n\n    cases[t1 << 0].forEach(stitch); // General case for the intermediate rows.\n\n    while (++y < dy - 1) {\n      x = -1;\n      t1 = values[y * dx + dx] >= value;\n      t2 = values[y * dx] >= value;\n      cases[t1 << 1 | t2 << 2].forEach(stitch);\n\n      while (++x < dx - 1) {\n        t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;\n        t3 = t2, t2 = values[y * dx + x + 1] >= value;\n        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);\n      }\n\n      cases[t1 | t2 << 3].forEach(stitch);\n    } // Special case for the last row (y = dy - 1, t0 = t1 = 0).\n\n\n    x = -1;\n    t2 = values[y * dx] >= value;\n    cases[t2 << 2].forEach(stitch);\n\n    while (++x < dx - 1) {\n      t3 = t2, t2 = values[y * dx + x + 1] >= value;\n      cases[t2 << 2 | t3 << 3].forEach(stitch);\n    }\n\n    cases[t2 << 3].forEach(stitch);\n\n    function stitch(line) {\n      var start = [line[0][0] + x, line[0][1] + y],\n          end = [line[1][0] + x, line[1][1] + y],\n          startIndex = index(start),\n          endIndex = index(end),\n          f,\n          g;\n\n      if (f = fragmentByEnd[startIndex]) {\n        if (g = fragmentByStart[endIndex]) {\n          delete fragmentByEnd[f.end];\n          delete fragmentByStart[g.start];\n\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[f.start] = fragmentByEnd[g.end] = {\n              start: f.start,\n              end: g.end,\n              ring: f.ring.concat(g.ring)\n            };\n          }\n        } else {\n          delete fragmentByEnd[f.end];\n          f.ring.push(end);\n          fragmentByEnd[f.end = endIndex] = f;\n        }\n      } else if (f = fragmentByStart[endIndex]) {\n        if (g = fragmentByEnd[startIndex]) {\n          delete fragmentByStart[f.start];\n          delete fragmentByEnd[g.end];\n\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[g.start] = fragmentByEnd[f.end] = {\n              start: g.start,\n              end: f.end,\n              ring: g.ring.concat(f.ring)\n            };\n          }\n        } else {\n          delete fragmentByStart[f.start];\n          f.ring.unshift(start);\n          fragmentByStart[f.start = startIndex] = f;\n        }\n      } else {\n        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {\n          start: startIndex,\n          end: endIndex,\n          ring: [start, end]\n        };\n      }\n    }\n  }\n\n  function index(point) {\n    return point[0] * 2 + point[1] * (dx + 1) * 4;\n  }\n\n  function smoothLinear(ring, values, value) {\n    ring.forEach(point => {\n      var x = point[0],\n          y = point[1],\n          xt = x | 0,\n          yt = y | 0,\n          v0,\n          v1 = values[yt * dx + xt];\n\n      if (x > 0 && x < dx && xt === x) {\n        v0 = values[yt * dx + xt - 1];\n        point[0] = x + (value - v0) / (v1 - v0) - 0.5;\n      }\n\n      if (y > 0 && y < dy && yt === y) {\n        v0 = values[(yt - 1) * dx + xt];\n        point[1] = y + (value - v0) / (v1 - v0) - 0.5;\n      }\n    });\n  }\n\n  contours.contour = contour;\n\n  contours.size = function (_) {\n    if (!arguments.length) return [dx, dy];\n\n    var _0 = Math.floor(_[0]),\n        _1 = Math.floor(_[1]);\n\n    if (!(_0 >= 0 && _1 >= 0)) error('invalid size');\n    return dx = _0, dy = _1, contours;\n  };\n\n  contours.smooth = function (_) {\n    return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;\n  };\n\n  return contours;\n}\n\nfunction area(ring) {\n  var i = 0,\n      n = ring.length,\n      area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];\n\n  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];\n\n  return area;\n}\n\nfunction contains(ring, hole) {\n  var i = -1,\n      n = hole.length,\n      c;\n\n  while (++i < n) if (c = ringContains(ring, hole[i])) return c;\n\n  return 0;\n}\n\nfunction ringContains(ring, point) {\n  var x = point[0],\n      y = point[1],\n      contains = -1;\n\n  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {\n    var pi = ring[i],\n        xi = pi[0],\n        yi = pi[1],\n        pj = ring[j],\n        xj = pj[0],\n        yj = pj[1];\n    if (segmentContains(pi, pj, point)) return 0;\n    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) contains = -contains;\n  }\n\n  return contains;\n}\n\nfunction segmentContains(a, b, c) {\n  var i;\n  return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);\n}\n\nfunction collinear(a, b, c) {\n  return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);\n}\n\nfunction within(p, q, r) {\n  return p <= q && q <= r || r <= q && q <= p;\n}\n\nfunction quantize (k, nice, zero) {\n  return function (values) {\n    var ex = extent(values),\n        start = zero ? Math.min(ex[0], 0) : ex[0],\n        stop = ex[1],\n        span = stop - start,\n        step = nice ? tickStep(start, stop, k) : span / (k + 1);\n    return range(start + step, stop, step);\n  };\n}\n\n/**\n * Generate isocontours (level sets) based on input raster grid data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} [params.field] - The field with raster grid\n *   data. If unspecified, the tuple itself is interpreted as a raster grid.\n * @param {Array<number>} [params.thresholds] - Contour threshold array. If\n *   specified, the levels, nice, resolve, and zero parameters are ignored.\n * @param {number} [params.levels] - The desired number of contour levels.\n * @param {boolean} [params.nice] - Boolean flag indicating if the contour\n *   threshold values should be automatically aligned to \"nice\"\n *   human-friendly values. Setting this flag may cause the number of\n *   thresholds to deviate from the specified levels.\n * @param {string} [params.resolve] - The method for resolving thresholds\n *   across multiple input grids. If 'independent' (the default), threshold\n *   calculation will be performed separately for each grid. If 'shared', a\n *   single set of threshold values will be used for all input grids.\n * @param {boolean} [params.zero] - Boolean flag indicating if the contour\n *   threshold values should include zero.\n * @param {boolean} [params.smooth] - Boolean flag indicating if the contour\n *   polygons should be smoothed using linear interpolation. The default is\n *   true. The parameter is ignored when using density estimation.\n * @param {boolean} [params.scale] - Optional numerical value by which to\n *   scale the output isocontour coordinates. This parameter can be useful\n *   to scale the contours to match a desired output resolution.\n * @param {string} [params.as='contour'] - The output field in which to store\n *   the generated isocontour data (default 'contour').\n */\n\nfunction Isocontour(params) {\n  Transform.call(this, null, params);\n}\nIsocontour.Definition = {\n  'type': 'Isocontour',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'thresholds',\n    'type': 'number',\n    'array': true\n  }, {\n    'name': 'levels',\n    'type': 'number'\n  }, {\n    'name': 'nice',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'resolve',\n    'type': 'enum',\n    'values': ['shared', 'independent'],\n    'default': 'independent'\n  }, {\n    'name': 'zero',\n    'type': 'boolean',\n    'default': true\n  }, {\n    'name': 'smooth',\n    'type': 'boolean',\n    'default': true\n  }, {\n    'name': 'scale',\n    'type': 'number',\n    'expr': true\n  }, {\n    'name': 'translate',\n    'type': 'number',\n    'array': true,\n    'expr': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'null': true,\n    'default': 'contour'\n  }]\n};\ninherits(Isocontour, Transform, {\n  transform(_, pulse) {\n    if (this.value && !pulse.changed() && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n\n    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n        source = pulse.materialize(pulse.SOURCE).source,\n        field = _.field || identity,\n        contour = contours().smooth(_.smooth !== false),\n        tz = _.thresholds || levels(source, field, _),\n        as = _.as === null ? null : _.as || 'contour',\n        values = [];\n    source.forEach(t => {\n      const grid = field(t); // generate contour paths in GeoJSON format\n\n      const paths = contour.size([grid.width, grid.height])(grid.values, isArray(tz) ? tz : tz(grid.values)); // adjust contour path coordinates as needed\n\n      transformPaths(paths, grid, t, _); // ingest; copy source data properties to output\n\n      paths.forEach(p => {\n        values.push(rederive(t, ingest(as != null ? {\n          [as]: p\n        } : p)));\n      });\n    });\n    if (this.value) out.rem = this.value;\n    this.value = out.source = out.add = values;\n    return out;\n  }\n\n});\n\nfunction levels(values, f, _) {\n  const q = quantize(_.levels || 10, _.nice, _.zero !== false);\n  return _.resolve !== 'shared' ? q : q(values.map(t => max(f(t).values)));\n}\n\nfunction transformPaths(paths, grid, datum, _) {\n  let s = _.scale || grid.scale,\n      t = _.translate || grid.translate;\n  if (isFunction(s)) s = s(datum, _);\n  if (isFunction(t)) t = t(datum, _);\n  if ((s === 1 || s == null) && !t) return;\n  const sx = (isNumber(s) ? s : s[0]) || 1,\n        sy = (isNumber(s) ? s : s[1]) || 1,\n        tx = t && t[0] || 0,\n        ty = t && t[1] || 0;\n  paths.forEach(transform(grid, sx, sy, tx, ty));\n}\n\nfunction transform(grid, sx, sy, tx, ty) {\n  const x1 = grid.x1 || 0,\n        y1 = grid.y1 || 0,\n        flip = sx * sy < 0;\n\n  function transformPolygon(coordinates) {\n    coordinates.forEach(transformRing);\n  }\n\n  function transformRing(coordinates) {\n    if (flip) coordinates.reverse(); // maintain winding order\n\n    coordinates.forEach(transformPoint);\n  }\n\n  function transformPoint(coordinates) {\n    coordinates[0] = (coordinates[0] - x1) * sx + tx;\n    coordinates[1] = (coordinates[1] - y1) * sy + ty;\n  }\n\n  return function (geometry) {\n    geometry.coordinates.forEach(transformPolygon);\n    return geometry;\n  };\n}\n\nfunction radius(bw, data, f) {\n  const v = bw >= 0 ? bw : bandwidthNRD(data, f);\n  return Math.round((Math.sqrt(4 * v * v + 1) - 1) / 2);\n}\n\nfunction number(_) {\n  return isFunction(_) ? _ : constant(+_);\n} // Implementation adapted from d3/d3-contour. Thanks!\n\n\nfunction density2D () {\n  var x = d => d[0],\n      y = d => d[1],\n      weight = one,\n      bandwidth = [-1, -1],\n      dx = 960,\n      dy = 500,\n      k = 2; // log2(cellSize)\n\n\n  function density(data, counts) {\n    const rx = radius(bandwidth[0], data, x) >> k,\n          // blur x-radius\n    ry = radius(bandwidth[1], data, y) >> k,\n          // blur y-radius\n    ox = rx ? rx + 2 : 0,\n          // x-offset padding for blur\n    oy = ry ? ry + 2 : 0,\n          // y-offset padding for blur\n    n = 2 * ox + (dx >> k),\n          // grid width\n    m = 2 * oy + (dy >> k),\n          // grid height\n    values0 = new Float32Array(n * m),\n          values1 = new Float32Array(n * m);\n    let values = values0;\n    data.forEach(d => {\n      const xi = ox + (+x(d) >> k),\n            yi = oy + (+y(d) >> k);\n\n      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {\n        values0[xi + yi * n] += +weight(d);\n      }\n    });\n\n    if (rx > 0 && ry > 0) {\n      blurX(n, m, values0, values1, rx);\n      blurY(n, m, values1, values0, ry);\n      blurX(n, m, values0, values1, rx);\n      blurY(n, m, values1, values0, ry);\n      blurX(n, m, values0, values1, rx);\n      blurY(n, m, values1, values0, ry);\n    } else if (rx > 0) {\n      blurX(n, m, values0, values1, rx);\n      blurX(n, m, values1, values0, rx);\n      blurX(n, m, values0, values1, rx);\n      values = values1;\n    } else if (ry > 0) {\n      blurY(n, m, values0, values1, ry);\n      blurY(n, m, values1, values0, ry);\n      blurY(n, m, values0, values1, ry);\n      values = values1;\n    } // scale density estimates\n    // density in points per square pixel or probability density\n\n\n    const s = counts ? Math.pow(2, -2 * k) : 1 / sum(values);\n\n    for (let i = 0, sz = n * m; i < sz; ++i) values[i] *= s;\n\n    return {\n      values: values,\n      scale: 1 << k,\n      width: n,\n      height: m,\n      x1: ox,\n      y1: oy,\n      x2: ox + (dx >> k),\n      y2: oy + (dy >> k)\n    };\n  }\n\n  density.x = function (_) {\n    return arguments.length ? (x = number(_), density) : x;\n  };\n\n  density.y = function (_) {\n    return arguments.length ? (y = number(_), density) : y;\n  };\n\n  density.weight = function (_) {\n    return arguments.length ? (weight = number(_), density) : weight;\n  };\n\n  density.size = function (_) {\n    if (!arguments.length) return [dx, dy];\n\n    var _0 = +_[0],\n        _1 = +_[1];\n\n    if (!(_0 >= 0 && _1 >= 0)) error('invalid size');\n    return dx = _0, dy = _1, density;\n  };\n\n  density.cellSize = function (_) {\n    if (!arguments.length) return 1 << k;\n    if (!((_ = +_) >= 1)) error('invalid cell size');\n    k = Math.floor(Math.log(_) / Math.LN2);\n    return density;\n  };\n\n  density.bandwidth = function (_) {\n    if (!arguments.length) return bandwidth;\n    _ = array(_);\n    if (_.length === 1) _ = [+_[0], +_[0]];\n    if (_.length !== 2) error('invalid bandwidth');\n    return bandwidth = _, density;\n  };\n\n  return density;\n}\n\nfunction blurX(n, m, source, target, r) {\n  const w = (r << 1) + 1;\n\n  for (let j = 0; j < m; ++j) {\n    for (let i = 0, sr = 0; i < n + r; ++i) {\n      if (i < n) {\n        sr += source[i + j * n];\n      }\n\n      if (i >= r) {\n        if (i >= w) {\n          sr -= source[i - w + j * n];\n        }\n\n        target[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);\n      }\n    }\n  }\n}\n\nfunction blurY(n, m, source, target, r) {\n  const w = (r << 1) + 1;\n\n  for (let i = 0; i < n; ++i) {\n    for (let j = 0, sr = 0; j < m + r; ++j) {\n      if (j < m) {\n        sr += source[i + j * n];\n      }\n\n      if (j >= r) {\n        if (j >= w) {\n          sr -= source[i + (j - w) * n];\n        }\n\n        target[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);\n      }\n    }\n  }\n}\n\n/**\n * Perform 2D kernel-density estimation of point data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The [width, height] extent (in\n *   units of input pixels) over which to perform density estimation.\n * @param {function(object): number} params.x - The x-coordinate accessor.\n * @param {function(object): number} params.y - The y-coordinate accessor.\n * @param {function(object): number} [params.weight] - The weight accessor.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors\n *   to groupby.\n * @param {number} [params.cellSize] - Contour density calculation cell size.\n *   This parameter determines the level of spatial approximation. For example,\n *   the default value of 4 maps to 2x reductions in both x- and y- dimensions.\n *   A value of 1 will result in an output raster grid whose dimensions exactly\n *   matches the size parameter.\n * @param {Array<number>} [params.bandwidth] - The KDE kernel bandwidths,\n *   in pixels. The input can be a two-element array specifying separate\n *   x and y bandwidths, or a single-element array specifying both. If the\n *   bandwidth is unspecified or less than zero, the bandwidth will be\n *   automatically determined.\n * @param {boolean} [params.counts=false] - A boolean flag indicating if the\n *   output values should be probability estimates (false, default) or\n *   smoothed counts (true).\n * @param {string} [params.as='grid'] - The output field in which to store\n *   the generated raster grid (default 'grid').\n */\n\nfunction KDE2D(params) {\n  Transform.call(this, null, params);\n}\nKDE2D.Definition = {\n  'type': 'KDE2D',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2,\n    'required': true\n  }, {\n    'name': 'x',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'y',\n    'type': 'field',\n    'required': true\n  }, {\n    'name': 'weight',\n    'type': 'field'\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'cellSize',\n    'type': 'number'\n  }, {\n    'name': 'bandwidth',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'counts',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'grid'\n  }]\n};\nconst PARAMS = ['x', 'y', 'weight', 'size', 'cellSize', 'bandwidth'];\nfunction params(obj, _) {\n  PARAMS.forEach(param => _[param] != null ? obj[param](_[param]) : 0);\n  return obj;\n}\ninherits(KDE2D, Transform, {\n  transform(_, pulse) {\n    if (this.value && !pulse.changed() && !_.modified()) return pulse.StopPropagation;\n    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n        source = pulse.materialize(pulse.SOURCE).source,\n        groups = partition(source, _.groupby),\n        names = (_.groupby || []).map(accessorName),\n        kde = params(density2D(), _),\n        as = _.as || 'grid',\n        values = [];\n\n    function set(t, vals) {\n      for (let i = 0; i < names.length; ++i) t[names[i]] = vals[i];\n\n      return t;\n    } // generate density raster grids\n\n\n    values = groups.map(g => ingest(set({\n      [as]: kde(g, _.counts)\n    }, g.dims)));\n    if (this.value) out.rem = this.value;\n    this.value = out.source = out.add = values;\n    return out;\n  }\n\n});\nfunction partition(data, groupby) {\n  var groups = [],\n      get = f => f(t),\n      map,\n      i,\n      n,\n      t,\n      k,\n      g; // partition data points into groups\n\n\n  if (groupby == null) {\n    groups.push(data);\n  } else {\n    for (map = {}, i = 0, n = data.length; i < n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n\n      if (!g) {\n        map[k] = g = [];\n        g.dims = k;\n        groups.push(g);\n      }\n\n      g.push(t);\n    }\n  }\n\n  return groups;\n}\n\n/**\n * Generate contours based on kernel-density estimation of point data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The dimensions [width, height] over which to compute contours.\n *  If the values parameter is provided, this must be the dimensions of the input data.\n *  If density estimation is performed, this is the output view dimensions in pixels.\n * @param {Array<number>} [params.values] - An array of numeric values representing an\n *  width x height grid of values over which to compute contours. If unspecified, this\n *  transform will instead attempt to compute contours for the kernel density estimate\n *  using values drawn from data tuples in the input pulse.\n * @param {function(object): number} [params.x] - The pixel x-coordinate accessor for density estimation.\n * @param {function(object): number} [params.y] - The pixel y-coordinate accessor for density estimation.\n * @param {function(object): number} [params.weight] - The data point weight accessor for density estimation.\n * @param {number} [params.cellSize] - Contour density calculation cell size.\n * @param {number} [params.bandwidth] - Kernel density estimation bandwidth.\n * @param {Array<number>} [params.thresholds] - Contour threshold array. If\n *   this parameter is set, the count and nice parameters will be ignored.\n * @param {number} [params.count] - The desired number of contours.\n * @param {boolean} [params.nice] - Boolean flag indicating if the contour\n *   threshold values should be automatically aligned to \"nice\"\n *   human-friendly values. Setting this flag may cause the number of\n *   thresholds to deviate from the specified count.\n * @param {boolean} [params.smooth] - Boolean flag indicating if the contour\n *   polygons should be smoothed using linear interpolation. The default is\n *   true. The parameter is ignored when using density estimation.\n */\n\nfunction Contour(params) {\n  Transform.call(this, null, params);\n}\nContour.Definition = {\n  'type': 'Contour',\n  'metadata': {\n    'generates': true\n  },\n  'params': [{\n    'name': 'size',\n    'type': 'number',\n    'array': true,\n    'length': 2,\n    'required': true\n  }, {\n    'name': 'values',\n    'type': 'number',\n    'array': true\n  }, {\n    'name': 'x',\n    'type': 'field'\n  }, {\n    'name': 'y',\n    'type': 'field'\n  }, {\n    'name': 'weight',\n    'type': 'field'\n  }, {\n    'name': 'cellSize',\n    'type': 'number'\n  }, {\n    'name': 'bandwidth',\n    'type': 'number'\n  }, {\n    'name': 'count',\n    'type': 'number'\n  }, {\n    'name': 'nice',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'thresholds',\n    'type': 'number',\n    'array': true\n  }, {\n    'name': 'smooth',\n    'type': 'boolean',\n    'default': true\n  }]\n};\ninherits(Contour, Transform, {\n  transform(_, pulse) {\n    if (this.value && !pulse.changed() && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n\n    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n        contour = contours().smooth(_.smooth !== false),\n        values = _.values,\n        thresh = _.thresholds || quantize(_.count || 10, _.nice, !!values),\n        size = _.size,\n        grid,\n        post;\n\n    if (!values) {\n      values = pulse.materialize(pulse.SOURCE).source;\n      grid = params(density2D(), _)(values, true);\n      post = transform(grid, grid.scale || 1, grid.scale || 1, 0, 0);\n      size = [grid.width, grid.height];\n      values = grid.values;\n    }\n\n    thresh = isArray(thresh) ? thresh : thresh(values);\n    values = contour.size(size)(values, thresh);\n    if (post) values.forEach(post);\n    if (this.value) out.rem = this.value;\n    this.value = out.source = out.add = (values || []).map(ingest);\n    return out;\n  }\n\n});\n\nconst Feature = 'Feature';\nconst FeatureCollection = 'FeatureCollection';\nconst MultiPoint = 'MultiPoint';\n\n/**\n * Consolidate an array of [longitude, latitude] points or GeoJSON features\n * into a combined GeoJSON object. This transform is particularly useful for\n * combining geo data for a Projection's fit argument. The resulting GeoJSON\n * data is available as this transform's value. Input pulses are unchanged.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} [params.fields] - A two-element array\n *   of field accessors for the longitude and latitude values.\n * @param {function(object): *} params.geojson - A field accessor for\n *   retrieving GeoJSON feature data.\n */\n\nfunction GeoJSON(params) {\n  Transform.call(this, null, params);\n}\nGeoJSON.Definition = {\n  'type': 'GeoJSON',\n  'metadata': {},\n  'params': [{\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'geojson',\n    'type': 'field'\n  }]\n};\ninherits(GeoJSON, Transform, {\n  transform(_, pulse) {\n    var features = this._features,\n        points = this._points,\n        fields = _.fields,\n        lon = fields && fields[0],\n        lat = fields && fields[1],\n        geojson = _.geojson || !fields && identity,\n        flag = pulse.ADD,\n        mod;\n    mod = _.modified() || pulse.changed(pulse.REM) || pulse.modified(accessorFields(geojson)) || lon && pulse.modified(accessorFields(lon)) || lat && pulse.modified(accessorFields(lat));\n\n    if (!this.value || mod) {\n      flag = pulse.SOURCE;\n      this._features = features = [];\n      this._points = points = [];\n    }\n\n    if (geojson) {\n      pulse.visit(flag, t => features.push(geojson(t)));\n    }\n\n    if (lon && lat) {\n      pulse.visit(flag, t => {\n        var x = lon(t),\n            y = lat(t);\n\n        if (x != null && y != null && (x = +x) === x && (y = +y) === y) {\n          points.push([x, y]);\n        }\n      });\n      features = features.concat({\n        type: Feature,\n        geometry: {\n          type: MultiPoint,\n          coordinates: points\n        }\n      });\n    }\n\n    this.value = {\n      type: FeatureCollection,\n      features: features\n    };\n  }\n\n});\n\n/**\n * Map GeoJSON data to an SVG path string.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(number, number): *} params.projection - The cartographic\n *   projection to apply.\n * @param {function(object): *} [params.field] - The field with GeoJSON data,\n *   or null if the tuple itself is a GeoJSON feature.\n * @param {string} [params.as='path'] - The output field in which to store\n *   the generated path data (default 'path').\n */\n\nfunction GeoPath(params) {\n  Transform.call(this, null, params);\n}\nGeoPath.Definition = {\n  'type': 'GeoPath',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'projection',\n    'type': 'projection'\n  }, {\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'pointRadius',\n    'type': 'number',\n    'expr': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'path'\n  }]\n};\ninherits(GeoPath, Transform, {\n  transform(_, pulse) {\n    var out = pulse.fork(pulse.ALL),\n        path = this.value,\n        field = _.field || identity,\n        as = _.as || 'path',\n        flag = out.SOURCE;\n\n    if (!path || _.modified()) {\n      // parameters updated, reset and reflow\n      this.value = path = getProjectionPath(_.projection);\n      out.materialize().reflow();\n    } else {\n      flag = field === identity || pulse.modified(field.fields) ? out.ADD_MOD : out.ADD;\n    }\n\n    const prev = initPath(path, _.pointRadius);\n    out.visit(flag, t => t[as] = path(field(t)));\n    path.pointRadius(prev);\n    return out.modifies(as);\n  }\n\n});\n\nfunction initPath(path, pointRadius) {\n  const prev = path.pointRadius();\n  path.context(null);\n\n  if (pointRadius != null) {\n    path.pointRadius(pointRadius);\n  }\n\n  return prev;\n}\n\n/**\n * Geo-code a longitude/latitude point to an x/y coordinate.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(number, number): *} params.projection - The cartographic\n *   projection to apply.\n * @param {Array<function(object): *>} params.fields - A two-element array of\n *   field accessors for the longitude and latitude values.\n * @param {Array<string>} [params.as] - A two-element array of field names\n *   under which to store the result. Defaults to ['x','y'].\n */\n\nfunction GeoPoint(params) {\n  Transform.call(this, null, params);\n}\nGeoPoint.Definition = {\n  'type': 'GeoPoint',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'projection',\n    'type': 'projection',\n    'required': true\n  }, {\n    'name': 'fields',\n    'type': 'field',\n    'array': true,\n    'required': true,\n    'length': 2\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': ['x', 'y']\n  }]\n};\ninherits(GeoPoint, Transform, {\n  transform(_, pulse) {\n    var proj = _.projection,\n        lon = _.fields[0],\n        lat = _.fields[1],\n        as = _.as || ['x', 'y'],\n        x = as[0],\n        y = as[1],\n        mod;\n\n    function set(t) {\n      const xy = proj([lon(t), lat(t)]);\n\n      if (xy) {\n        t[x] = xy[0];\n        t[y] = xy[1];\n      } else {\n        t[x] = undefined;\n        t[y] = undefined;\n      }\n    }\n\n    if (_.modified()) {\n      // parameters updated, reflow\n      pulse = pulse.materialize().reflow(true).visit(pulse.SOURCE, set);\n    } else {\n      mod = pulse.modified(lon.fields) || pulse.modified(lat.fields);\n      pulse.visit(mod ? pulse.ADD_MOD : pulse.ADD, set);\n    }\n\n    return pulse.modifies(as);\n  }\n\n});\n\n/**\n * Annotate items with a geopath shape generator.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(number, number): *} params.projection - The cartographic\n *   projection to apply.\n * @param {function(object): *} [params.field] - The field with GeoJSON data,\n *   or null if the tuple itself is a GeoJSON feature.\n * @param {string} [params.as='shape'] - The output field in which to store\n *   the generated path data (default 'shape').\n */\n\nfunction GeoShape(params) {\n  Transform.call(this, null, params);\n}\nGeoShape.Definition = {\n  'type': 'GeoShape',\n  'metadata': {\n    'modifies': true,\n    'nomod': true\n  },\n  'params': [{\n    'name': 'projection',\n    'type': 'projection'\n  }, {\n    'name': 'field',\n    'type': 'field',\n    'default': 'datum'\n  }, {\n    'name': 'pointRadius',\n    'type': 'number',\n    'expr': true\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'shape'\n  }]\n};\ninherits(GeoShape, Transform, {\n  transform(_, pulse) {\n    var out = pulse.fork(pulse.ALL),\n        shape = this.value,\n        as = _.as || 'shape',\n        flag = out.ADD;\n\n    if (!shape || _.modified()) {\n      // parameters updated, reset and reflow\n      this.value = shape = shapeGenerator(getProjectionPath(_.projection), _.field || field('datum'), _.pointRadius);\n      out.materialize().reflow();\n      flag = out.SOURCE;\n    }\n\n    out.visit(flag, t => t[as] = shape);\n    return out.modifies(as);\n  }\n\n});\n\nfunction shapeGenerator(path, field, pointRadius) {\n  const shape = pointRadius == null ? _ => path(field(_)) : _ => {\n    var prev = path.pointRadius(),\n        value = path.pointRadius(pointRadius)(field(_));\n    path.pointRadius(prev);\n    return value;\n  };\n\n  shape.context = _ => {\n    path.context(_);\n    return shape;\n  };\n\n  return shape;\n}\n\n/**\n * GeoJSON feature generator for creating graticules.\n * @constructor\n */\n\nfunction Graticule(params) {\n  Transform.call(this, [], params);\n  this.generator = geoGraticule();\n}\nGraticule.Definition = {\n  'type': 'Graticule',\n  'metadata': {\n    'changes': true,\n    'generates': true\n  },\n  'params': [{\n    'name': 'extent',\n    'type': 'array',\n    'array': true,\n    'length': 2,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }, {\n    'name': 'extentMajor',\n    'type': 'array',\n    'array': true,\n    'length': 2,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }, {\n    'name': 'extentMinor',\n    'type': 'array',\n    'array': true,\n    'length': 2,\n    'content': {\n      'type': 'number',\n      'array': true,\n      'length': 2\n    }\n  }, {\n    'name': 'step',\n    'type': 'number',\n    'array': true,\n    'length': 2\n  }, {\n    'name': 'stepMajor',\n    'type': 'number',\n    'array': true,\n    'length': 2,\n    'default': [90, 360]\n  }, {\n    'name': 'stepMinor',\n    'type': 'number',\n    'array': true,\n    'length': 2,\n    'default': [10, 10]\n  }, {\n    'name': 'precision',\n    'type': 'number',\n    'default': 2.5\n  }]\n};\ninherits(Graticule, Transform, {\n  transform(_, pulse) {\n    var src = this.value,\n        gen = this.generator,\n        t;\n\n    if (!src.length || _.modified()) {\n      for (const prop in _) {\n        if (isFunction(gen[prop])) {\n          gen[prop](_[prop]);\n        }\n      }\n    }\n\n    t = gen();\n\n    if (src.length) {\n      pulse.mod.push(replace(src[0], t));\n    } else {\n      pulse.add.push(ingest(t));\n    }\n\n    src[0] = t;\n    return pulse;\n  }\n\n});\n\n/**\n * Render a heatmap image for input raster grid data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} [params.field] - The field with raster grid\n *   data. If unspecified, the tuple itself is interpreted as a raster grid.\n * @param {string} [params.color] - A constant color value or function for\n *   individual pixel color. If a function, it will be invoked with an input\n *   object that includes $x, $y, $value, and $max fields for the grid.\n * @param {number} [params.opacity] - A constant opacity value or function for\n *   individual pixel opacity. If a function, it will be invoked with an input\n *   object that includes $x, $y, $value, and $max fields for the grid.\n * @param {string} [params.resolve] - The method for resolving maximum values\n *   across multiple input grids. If 'independent' (the default), maximum\n *   calculation will be performed separately for each grid. If 'shared',\n *   a single global maximum will be used for all input grids.\n * @param {string} [params.as='image'] - The output field in which to store\n *   the generated bitmap canvas images (default 'image').\n */\n\nfunction Heatmap(params) {\n  Transform.call(this, null, params);\n}\nHeatmap.Definition = {\n  'type': 'heatmap',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'color',\n    'type': 'string',\n    'expr': true\n  }, {\n    'name': 'opacity',\n    'type': 'number',\n    'expr': true\n  }, {\n    'name': 'resolve',\n    'type': 'enum',\n    'values': ['shared', 'independent'],\n    'default': 'independent'\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'image'\n  }]\n};\ninherits(Heatmap, Transform, {\n  transform(_, pulse) {\n    if (!pulse.changed() && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n\n    var source = pulse.materialize(pulse.SOURCE).source,\n        shared = _.resolve === 'shared',\n        field = _.field || identity,\n        opacity = opacity_(_.opacity, _),\n        color = color_(_.color, _),\n        as = _.as || 'image',\n        obj = {\n      $x: 0,\n      $y: 0,\n      $value: 0,\n      $max: shared ? max(source.map(t => max(field(t).values))) : 0\n    };\n    source.forEach(t => {\n      const v = field(t); // build proxy data object\n\n      const o = extend({}, t, obj); // set maximum value if not globally shared\n\n      if (!shared) o.$max = max(v.values || []); // generate canvas image\n      // optimize color/opacity if not pixel-dependent\n\n      t[as] = toCanvas(v, o, color.dep ? color : constant(color(o)), opacity.dep ? opacity : constant(opacity(o)));\n    });\n    return pulse.reflow(true).modifies(as);\n  }\n\n}); // get image color function\n\nfunction color_(color, _) {\n  let f;\n\n  if (isFunction(color)) {\n    f = obj => rgb(color(obj, _));\n\n    f.dep = dependency(color);\n  } else {\n    // default to mid-grey\n    f = constant(rgb(color || '#888'));\n  }\n\n  return f;\n} // get image opacity function\n\n\nfunction opacity_(opacity, _) {\n  let f;\n\n  if (isFunction(opacity)) {\n    f = obj => opacity(obj, _);\n\n    f.dep = dependency(opacity);\n  } else if (opacity) {\n    f = constant(opacity);\n  } else {\n    // default to [0, max] opacity gradient\n    f = obj => obj.$value / obj.$max || 0;\n\n    f.dep = true;\n  }\n\n  return f;\n} // check if function depends on individual pixel data\n\n\nfunction dependency(f) {\n  if (!isFunction(f)) return false;\n  const set = toSet(accessorFields(f));\n  return set.$x || set.$y || set.$value || set.$max;\n} // render raster grid to canvas\n\n\nfunction toCanvas(grid, obj, color, opacity) {\n  const n = grid.width,\n        m = grid.height,\n        x1 = grid.x1 || 0,\n        y1 = grid.y1 || 0,\n        x2 = grid.x2 || n,\n        y2 = grid.y2 || m,\n        val = grid.values,\n        value = val ? i => val[i] : zero,\n        can = canvas(x2 - x1, y2 - y1),\n        ctx = can.getContext('2d'),\n        img = ctx.getImageData(0, 0, x2 - x1, y2 - y1),\n        pix = img.data;\n\n  for (let j = y1, k = 0; j < y2; ++j) {\n    obj.$y = j - y1;\n\n    for (let i = x1, r = j * n; i < x2; ++i, k += 4) {\n      obj.$x = i - x1;\n      obj.$value = value(i + r);\n      const v = color(obj);\n      pix[k + 0] = v.r;\n      pix[k + 1] = v.g;\n      pix[k + 2] = v.b;\n      pix[k + 3] = ~~(255 * opacity(obj));\n    }\n  }\n\n  ctx.putImageData(img, 0, 0);\n  return can;\n}\n\n/**\n * Maintains a cartographic projection.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction Projection(params) {\n  Transform.call(this, null, params);\n  this.modified(true); // always treat as modified\n}\ninherits(Projection, Transform, {\n  transform(_, pulse) {\n    let proj = this.value;\n\n    if (!proj || _.modified('type')) {\n      this.value = proj = create(_.type);\n      projectionProperties.forEach(prop => {\n        if (_[prop] != null) set(proj, prop, _[prop]);\n      });\n    } else {\n      projectionProperties.forEach(prop => {\n        if (_.modified(prop)) set(proj, prop, _[prop]);\n      });\n    }\n\n    if (_.pointRadius != null) proj.path.pointRadius(_.pointRadius);\n    if (_.fit) fit(proj, _);\n    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n  }\n\n});\n\nfunction fit(proj, _) {\n  const data = collectGeoJSON(_.fit);\n  _.extent ? proj.fitExtent(_.extent, data) : _.size ? proj.fitSize(_.size, data) : 0;\n}\n\nfunction create(type) {\n  const constructor = projection((type || 'mercator').toLowerCase());\n  if (!constructor) error('Unrecognized projection type: ' + type);\n  return constructor();\n}\n\nfunction set(proj, key, value) {\n  if (isFunction(proj[key])) proj[key](value);\n}\n\nfunction collectGeoJSON(data) {\n  data = array(data);\n  return data.length === 1 ? data[0] : {\n    type: FeatureCollection,\n    features: data.reduce((a, f) => a.concat(featurize(f)), [])\n  };\n}\n\nfunction featurize(f) {\n  return f.type === FeatureCollection ? f.features : array(f).filter(d => d != null).map(d => d.type === Feature ? d : {\n    type: Feature,\n    geometry: d\n  });\n}\n\nexport { Contour as contour, GeoJSON as geojson, GeoPath as geopath, GeoPoint as geopoint, GeoShape as geoshape, Graticule as graticule, Heatmap as heatmap, Isocontour as isocontour, KDE2D as kde2d, Projection as projection };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}