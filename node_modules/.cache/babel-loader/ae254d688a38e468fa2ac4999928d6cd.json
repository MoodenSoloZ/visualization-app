{"ast":null,"code":"import _slicedToArray from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { entries, isEmpty } from '../../../util';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { VG_MARK_INDEX } from './../../../vega.schema';\nimport { wrapCondition } from './conditional';\nimport { textRef } from './text';\nimport { tooltipData } from './tooltip';\nexport function aria(model) {\n  var markDef = model.markDef,\n    config = model.config;\n  var enableAria = getMarkPropOrConfig('aria', markDef, config);\n  // We can ignore other aria properties if ariaHidden is true.\n  if (enableAria === false) {\n    // getMarkGroups sets aria to false already so we don't have to set it in the encode block\n    return {};\n  }\n  return Object.assign(Object.assign(Object.assign({}, enableAria ? {\n    aria: enableAria\n  } : {}), ariaRoleDescription(model)), description(model));\n}\nfunction ariaRoleDescription(model) {\n  var mark = model.mark,\n    markDef = model.markDef,\n    config = model.config;\n  if (config.aria === false) {\n    return {};\n  }\n  var ariaRoleDesc = getMarkPropOrConfig('ariaRoleDescription', markDef, config);\n  if (ariaRoleDesc != null) {\n    return {\n      ariaRoleDescription: {\n        value: ariaRoleDesc\n      }\n    };\n  }\n  return mark in VG_MARK_INDEX ? {} : {\n    ariaRoleDescription: {\n      value: mark\n    }\n  };\n}\nexport function description(model) {\n  var encoding = model.encoding,\n    markDef = model.markDef,\n    config = model.config,\n    stack = model.stack;\n  var channelDef = encoding.description;\n  if (channelDef) {\n    return wrapCondition(model, channelDef, 'description', function (cDef) {\n      return textRef(cDef, model.config);\n    });\n  }\n  // Use default from mark def or config if defined.\n  // Functions in encode usually just return undefined but since we are defining a default below, we need to check the default here.\n  var descriptionValue = getMarkPropOrConfig('description', markDef, config);\n  if (descriptionValue != null) {\n    return {\n      description: signalOrValueRef(descriptionValue)\n    };\n  }\n  if (config.aria === false) {\n    return {};\n  }\n  var data = tooltipData(encoding, stack, config);\n  if (isEmpty(data)) {\n    return undefined;\n  }\n  return {\n    description: {\n      signal: entries(data).map(function (_ref, index) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          key = _ref2[0],\n          value = _ref2[1];\n        return \"\\\"\".concat(index > 0 ? '; ' : '').concat(key, \": \\\" + (\").concat(value, \")\");\n      }).join(' + ')\n    }\n  };\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/aria.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { entries, isEmpty } from '../../../util';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { VG_MARK_INDEX } from './../../../vega.schema';\nimport { wrapCondition } from './conditional';\nimport { textRef } from './text';\nimport { tooltipData } from './tooltip';\nexport function aria(model) {\n    const { markDef, config } = model;\n    const enableAria = getMarkPropOrConfig('aria', markDef, config);\n    // We can ignore other aria properties if ariaHidden is true.\n    if (enableAria === false) {\n        // getMarkGroups sets aria to false already so we don't have to set it in the encode block\n        return {};\n    }\n    return Object.assign(Object.assign(Object.assign({}, (enableAria ? { aria: enableAria } : {})), ariaRoleDescription(model)), description(model));\n}\nfunction ariaRoleDescription(model) {\n    const { mark, markDef, config } = model;\n    if (config.aria === false) {\n        return {};\n    }\n    const ariaRoleDesc = getMarkPropOrConfig('ariaRoleDescription', markDef, config);\n    if (ariaRoleDesc != null) {\n        return { ariaRoleDescription: { value: ariaRoleDesc } };\n    }\n    return mark in VG_MARK_INDEX ? {} : { ariaRoleDescription: { value: mark } };\n}\nexport function description(model) {\n    const { encoding, markDef, config, stack } = model;\n    const channelDef = encoding.description;\n    if (channelDef) {\n        return wrapCondition(model, channelDef, 'description', cDef => textRef(cDef, model.config));\n    }\n    // Use default from mark def or config if defined.\n    // Functions in encode usually just return undefined but since we are defining a default below, we need to check the default here.\n    const descriptionValue = getMarkPropOrConfig('description', markDef, config);\n    if (descriptionValue != null) {\n        return {\n            description: signalOrValueRef(descriptionValue)\n        };\n    }\n    if (config.aria === false) {\n        return {};\n    }\n    const data = tooltipData(encoding, stack, config);\n    if (isEmpty(data)) {\n        return undefined;\n    }\n    return {\n        description: {\n            signal: entries(data)\n                .map(([key, value], index) => `\"${index > 0 ? '; ' : ''}${key}: \" + (${value})`)\n                .join(' + ')\n        }\n    };\n}\n//# sourceMappingURL=aria.js.map"]},"metadata":{},"sourceType":"module"}