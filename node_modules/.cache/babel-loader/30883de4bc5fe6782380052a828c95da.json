{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { stringValue } from 'vega-util';\nimport { VL_SELECTION_RESOLVE } from '.';\nimport { isScaleChannel } from '../../channel';\nimport * as log from '../../log';\nimport { hasContinuousDomain } from '../../scale';\nimport { isLayerModel } from '../model';\nimport { replacePathInField } from '../../util';\nvar scaleBindings = {\n  defined: function defined(selCmpt) {\n    return selCmpt.type === 'interval' && selCmpt.resolve === 'global' && selCmpt.bind && selCmpt.bind === 'scales';\n  },\n  parse: function parse(model, selCmpt) {\n    var bound = selCmpt.scales = [];\n    var _iterator = _createForOfIteratorHelper(selCmpt.project.items),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var proj = _step.value;\n        var channel = proj.channel;\n        if (!isScaleChannel(channel)) {\n          continue;\n        }\n        var scale = model.getScaleComponent(channel);\n        var scaleType = scale ? scale.get('type') : undefined;\n        if (!scale || !hasContinuousDomain(scaleType)) {\n          log.warn(log.message.SCALE_BINDINGS_CONTINUOUS);\n          continue;\n        }\n        scale.set('selectionExtent', {\n          param: selCmpt.name,\n          field: proj.field\n        }, true);\n        bound.push(proj);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  },\n  topLevelSignals: function topLevelSignals(model, selCmpt, signals) {\n    var bound = selCmpt.scales.filter(function (proj) {\n      return signals.filter(function (s) {\n        return s.name === proj.signals.data;\n      }).length === 0;\n    });\n    // Top-level signals are only needed for multiview displays and if this\n    // view's top-level signals haven't already been generated.\n    if (!model.parent || isTopLevelLayer(model) || bound.length === 0) {\n      return signals;\n    }\n    // vlSelectionResolve does not account for the behavior of bound scales in\n    // multiview displays. Each unit view adds a tuple to the store, but the\n    // state of the selection is the unit selection most recently updated. This\n    // state is captured by the top-level signals that we insert and \"push\n    // outer\" to from within the units. We need to reassemble this state into\n    // the top-level named signal, except no single selCmpt has a global view.\n    var namedSg = signals.filter(function (s) {\n      return s.name === selCmpt.name;\n    })[0];\n    var update = namedSg.update;\n    if (update.indexOf(VL_SELECTION_RESOLVE) >= 0) {\n      namedSg.update = \"{\".concat(bound.map(function (proj) {\n        return \"\".concat(stringValue(replacePathInField(proj.field)), \": \").concat(proj.signals.data);\n      }).join(', '), \"}\");\n    } else {\n      var _iterator2 = _createForOfIteratorHelper(bound),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var proj = _step2.value;\n          var mapping = \"\".concat(stringValue(replacePathInField(proj.field)), \": \").concat(proj.signals.data);\n          if (!update.includes(mapping)) {\n            update = \"\".concat(update.substring(0, update.length - 1), \", \").concat(mapping, \"}\");\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      namedSg.update = update;\n    }\n    return signals.concat(bound.map(function (proj) {\n      return {\n        name: proj.signals.data\n      };\n    }));\n  },\n  signals: function signals(model, selCmpt, _signals) {\n    // Nested signals need only push to top-level signals with multiview displays.\n    if (model.parent && !isTopLevelLayer(model)) {\n      var _iterator3 = _createForOfIteratorHelper(selCmpt.scales),\n        _step3;\n      try {\n        var _loop = function _loop() {\n          var proj = _step3.value;\n          var signal = _signals.filter(function (s) {\n            return s.name === proj.signals.data;\n          })[0];\n          signal.push = 'outer';\n          delete signal.value;\n          delete signal.update;\n        };\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n    return _signals;\n  }\n};\nexport default scaleBindings;\nexport function domain(model, channel) {\n  var scale = stringValue(model.scaleName(channel));\n  return \"domain(\".concat(scale, \")\");\n}\nfunction isTopLevelLayer(model) {\n  var _a;\n  return model.parent && isLayerModel(model.parent) && ((_a = !model.parent.parent) !== null && _a !== void 0 ? _a : isTopLevelLayer(model.parent.parent));\n}","map":{"version":3,"sources":["../../../../src/compile/selection/scales.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { stringValue } from 'vega-util';\nimport { VL_SELECTION_RESOLVE } from '.';\nimport { isScaleChannel } from '../../channel';\nimport * as log from '../../log';\nimport { hasContinuousDomain } from '../../scale';\nimport { isLayerModel } from '../model';\nimport { replacePathInField } from '../../util';\nconst scaleBindings = {\n    defined: selCmpt => {\n        return selCmpt.type === 'interval' && selCmpt.resolve === 'global' && selCmpt.bind && selCmpt.bind === 'scales';\n    },\n    parse: (model, selCmpt) => {\n        const bound = (selCmpt.scales = []);\n        for (const proj of selCmpt.project.items) {\n            const channel = proj.channel;\n            if (!isScaleChannel(channel)) {\n                continue;\n            }\n            const scale = model.getScaleComponent(channel);\n            const scaleType = scale ? scale.get('type') : undefined;\n            if (!scale || !hasContinuousDomain(scaleType)) {\n                log.warn(log.message.SCALE_BINDINGS_CONTINUOUS);\n                continue;\n            }\n            scale.set('selectionExtent', { param: selCmpt.name, field: proj.field }, true);\n            bound.push(proj);\n        }\n    },\n    topLevelSignals: (model, selCmpt, signals) => {\n        const bound = selCmpt.scales.filter(proj => signals.filter(s => s.name === proj.signals.data).length === 0);\n        // Top-level signals are only needed for multiview displays and if this\n        // view's top-level signals haven't already been generated.\n        if (!model.parent || isTopLevelLayer(model) || bound.length === 0) {\n            return signals;\n        }\n        // vlSelectionResolve does not account for the behavior of bound scales in\n        // multiview displays. Each unit view adds a tuple to the store, but the\n        // state of the selection is the unit selection most recently updated. This\n        // state is captured by the top-level signals that we insert and \"push\n        // outer\" to from within the units. We need to reassemble this state into\n        // the top-level named signal, except no single selCmpt has a global view.\n        const namedSg = signals.filter(s => s.name === selCmpt.name)[0];\n        let update = namedSg.update;\n        if (update.indexOf(VL_SELECTION_RESOLVE) >= 0) {\n            namedSg.update = `{${bound\n                .map(proj => `${stringValue(replacePathInField(proj.field))}: ${proj.signals.data}`)\n                .join(', ')}}`;\n        }\n        else {\n            for (const proj of bound) {\n                const mapping = `${stringValue(replacePathInField(proj.field))}: ${proj.signals.data}`;\n                if (!update.includes(mapping)) {\n                    update = `${update.substring(0, update.length - 1)}, ${mapping}}`;\n                }\n            }\n            namedSg.update = update;\n        }\n        return signals.concat(bound.map(proj => ({ name: proj.signals.data })));\n    },\n    signals: (model, selCmpt, signals) => {\n        // Nested signals need only push to top-level signals with multiview displays.\n        if (model.parent && !isTopLevelLayer(model)) {\n            for (const proj of selCmpt.scales) {\n                const signal = signals.filter(s => s.name === proj.signals.data)[0];\n                signal.push = 'outer';\n                delete signal.value;\n                delete signal.update;\n            }\n        }\n        return signals;\n    }\n};\nexport default scaleBindings;\nexport function domain(model, channel) {\n    const scale = stringValue(model.scaleName(channel));\n    return `domain(${scale})`;\n}\nfunction isTopLevelLayer(model) {\n    var _a;\n    return model.parent && isLayerModel(model.parent) && ((_a = !model.parent.parent) !== null && _a !== void 0 ? _a : isTopLevelLayer(model.parent.parent));\n}\n//# sourceMappingURL=scales.js.map"]},"metadata":{},"sourceType":"module"}