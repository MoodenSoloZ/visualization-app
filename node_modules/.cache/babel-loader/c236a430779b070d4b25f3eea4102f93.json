{"ast":null,"code":"import _slicedToArray from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { isUrlData } from '../../data';\nimport { AggregateNode } from './aggregate';\nimport { BinNode } from './bin';\nimport { CalculateNode } from './calculate';\nimport { OutputNode } from './dataflow';\nimport { DensityTransformNode } from './density';\nimport { FacetNode } from './facet';\nimport { FilterNode } from './filter';\nimport { FilterInvalidNode } from './filterinvalid';\nimport { FlattenTransformNode } from './flatten';\nimport { FoldTransformNode } from './fold';\nimport { ParseNode } from './formatparse';\nimport { GeoJSONNode } from './geojson';\nimport { GeoPointNode } from './geopoint';\nimport { GraticuleNode } from './graticule';\nimport { IdentifierNode } from './identifier';\nimport { ImputeNode } from './impute';\nimport { JoinAggregateTransformNode } from './joinaggregate';\nimport { LoessTransformNode } from './loess';\nimport { LookupNode } from './lookup';\nimport { QuantileTransformNode } from './quantile';\nimport { RegressionTransformNode } from './regression';\nimport { PivotTransformNode } from './pivot';\nimport { SampleTransformNode } from './sample';\nimport { SequenceNode } from './sequence';\nimport { SourceNode } from './source';\nimport { StackNode } from './stack';\nimport { TimeUnitNode } from './timeunit';\nimport { WindowTransformNode } from './window';\nfunction makeWalkTree(data) {\n  // to name datasources\n  var datasetIndex = 0;\n  /**\n   * Recursively walk down the tree.\n   */\n  function walkTree(node, dataSource) {\n    var _a;\n    if (node instanceof SourceNode) {\n      // If the source is a named data source or a data source with values, we need\n      // to put it in a different data source. Otherwise, Vega may override the data.\n      if (!node.isGenerator && !isUrlData(node.data)) {\n        data.push(dataSource);\n        var newData = {\n          name: null,\n          source: dataSource.name,\n          transform: []\n        };\n        dataSource = newData;\n      }\n    }\n    if (node instanceof ParseNode) {\n      if (node.parent instanceof SourceNode && !dataSource.source) {\n        var _dataSource$transform;\n        // If node's parent is a root source and the data source does not refer to another data source, use normal format parse\n        dataSource.format = Object.assign(Object.assign({}, (_a = dataSource.format) !== null && _a !== void 0 ? _a : {}), {\n          parse: node.assembleFormatParse()\n        });\n        // add calculates for all nested fields\n        (_dataSource$transform = dataSource.transform).push.apply(_dataSource$transform, _toConsumableArray(node.assembleTransforms(true)));\n      } else {\n        var _dataSource$transform2;\n        // Otherwise use Vega expression to parse\n        (_dataSource$transform2 = dataSource.transform).push.apply(_dataSource$transform2, _toConsumableArray(node.assembleTransforms()));\n      }\n    }\n    if (node instanceof FacetNode) {\n      if (!dataSource.name) {\n        dataSource.name = \"data_\".concat(datasetIndex++);\n      }\n      if (!dataSource.source || dataSource.transform.length > 0) {\n        data.push(dataSource);\n        node.data = dataSource.name;\n      } else {\n        node.data = dataSource.source;\n      }\n      data.push.apply(data, _toConsumableArray(node.assemble()));\n      // break here because the rest of the tree has to be taken care of by the facet.\n      return;\n    }\n    if (node instanceof GraticuleNode || node instanceof SequenceNode || node instanceof FilterInvalidNode || node instanceof FilterNode || node instanceof CalculateNode || node instanceof GeoPointNode || node instanceof AggregateNode || node instanceof LookupNode || node instanceof WindowTransformNode || node instanceof JoinAggregateTransformNode || node instanceof FoldTransformNode || node instanceof FlattenTransformNode || node instanceof DensityTransformNode || node instanceof LoessTransformNode || node instanceof QuantileTransformNode || node instanceof RegressionTransformNode || node instanceof IdentifierNode || node instanceof SampleTransformNode || node instanceof PivotTransformNode) {\n      dataSource.transform.push(node.assemble());\n    }\n    if (node instanceof BinNode || node instanceof TimeUnitNode || node instanceof ImputeNode || node instanceof StackNode || node instanceof GeoJSONNode) {\n      var _dataSource$transform3;\n      (_dataSource$transform3 = dataSource.transform).push.apply(_dataSource$transform3, _toConsumableArray(node.assemble()));\n    }\n    if (node instanceof OutputNode) {\n      if (dataSource.source && dataSource.transform.length === 0) {\n        node.setSource(dataSource.source);\n      } else if (node.parent instanceof OutputNode) {\n        // Note that an output node may be required but we still do not assemble a\n        // separate data source for it.\n        node.setSource(dataSource.name);\n      } else {\n        if (!dataSource.name) {\n          dataSource.name = \"data_\".concat(datasetIndex++);\n        }\n        // Here we set the name of the datasource we generated. From now on\n        // other assemblers can use it.\n        node.setSource(dataSource.name);\n        // if this node has more than one child, we will add a datasource automatically\n        if (node.numChildren() === 1) {\n          data.push(dataSource);\n          var _newData = {\n            name: null,\n            source: dataSource.name,\n            transform: []\n          };\n          dataSource = _newData;\n        }\n      }\n    }\n    switch (node.numChildren()) {\n      case 0:\n        // done\n        if (node instanceof OutputNode && (!dataSource.source || dataSource.transform.length > 0)) {\n          // do not push empty datasources that are simply references\n          data.push(dataSource);\n        }\n        break;\n      case 1:\n        walkTree(node.children[0], dataSource);\n        break;\n      default:\n        {\n          if (!dataSource.name) {\n            dataSource.name = \"data_\".concat(datasetIndex++);\n          }\n          var source = dataSource.name;\n          if (!dataSource.source || dataSource.transform.length > 0) {\n            data.push(dataSource);\n          } else {\n            source = dataSource.source;\n          }\n          var _iterator = _createForOfIteratorHelper(node.children),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var child = _step.value;\n              var _newData2 = {\n                name: null,\n                source: source,\n                transform: []\n              };\n              walkTree(child, _newData2);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          break;\n        }\n    }\n  }\n  return walkTree;\n}\n/**\n * Assemble data sources that are derived from faceted data.\n */\nexport function assembleFacetData(root) {\n  var data = [];\n  var walkTree = makeWalkTree(data);\n  var _iterator2 = _createForOfIteratorHelper(root.children),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var child = _step2.value;\n      walkTree(child, {\n        source: root.name,\n        name: null,\n        transform: []\n      });\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return data;\n}\n/**\n * Create Vega data array from a given compiled model and append all of them to the given array\n *\n * @param  model\n * @param  data array\n * @return modified data array\n */\nexport function assembleRootData(dataComponent, datasets) {\n  var _a, _b;\n  var data = [];\n  // dataComponent.sources.forEach(debug);\n  // draw(dataComponent.sources);\n  var walkTree = makeWalkTree(data);\n  var sourceIndex = 0;\n  var _iterator3 = _createForOfIteratorHelper(dataComponent.sources),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var root = _step3.value;\n      // assign a name if the source does not have a name yet\n      if (!root.hasName()) {\n        root.dataName = \"source_\".concat(sourceIndex++);\n      }\n      var newData = root.assemble();\n      walkTree(root, newData);\n    }\n    // remove empty transform arrays for cleaner output\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  for (var _i = 0, _data = data; _i < _data.length; _i++) {\n    var d = _data[_i];\n    if (d.transform.length === 0) {\n      delete d.transform;\n    }\n  }\n  // move sources without transforms (the ones that are potentially used in lookups) to the beginning\n  var whereTo = 0;\n  var _iterator4 = _createForOfIteratorHelper(data.entries()),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var _step4$value = _slicedToArray(_step4.value, 2),\n        i = _step4$value[0],\n        _d3 = _step4$value[1];\n      if (((_a = _d3.transform) !== null && _a !== void 0 ? _a : []).length === 0 && !_d3.source) {\n        data.splice(whereTo++, 0, data.splice(i, 1)[0]);\n      }\n    }\n    // now fix the from references in lookup transforms\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  for (var _i2 = 0, _data2 = data; _i2 < _data2.length; _i2++) {\n    var _d = _data2[_i2];\n    var _iterator5 = _createForOfIteratorHelper((_b = _d.transform) !== null && _b !== void 0 ? _b : []),\n      _step5;\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var t = _step5.value;\n        if (t.type === 'lookup') {\n          t.from = dataComponent.outputNodes[t.from].getSource();\n        }\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n  }\n  // inline values for datasets that are in the datastore\n  for (var _i3 = 0, _data3 = data; _i3 < _data3.length; _i3++) {\n    var _d2 = _data3[_i3];\n    if (_d2.name in datasets) {\n      _d2.values = datasets[_d2.name];\n    }\n  }\n  return data;\n}","map":{"version":3,"sources":["../../../../src/compile/data/assemble.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isUrlData } from '../../data';\nimport { AggregateNode } from './aggregate';\nimport { BinNode } from './bin';\nimport { CalculateNode } from './calculate';\nimport { OutputNode } from './dataflow';\nimport { DensityTransformNode } from './density';\nimport { FacetNode } from './facet';\nimport { FilterNode } from './filter';\nimport { FilterInvalidNode } from './filterinvalid';\nimport { FlattenTransformNode } from './flatten';\nimport { FoldTransformNode } from './fold';\nimport { ParseNode } from './formatparse';\nimport { GeoJSONNode } from './geojson';\nimport { GeoPointNode } from './geopoint';\nimport { GraticuleNode } from './graticule';\nimport { IdentifierNode } from './identifier';\nimport { ImputeNode } from './impute';\nimport { JoinAggregateTransformNode } from './joinaggregate';\nimport { LoessTransformNode } from './loess';\nimport { LookupNode } from './lookup';\nimport { QuantileTransformNode } from './quantile';\nimport { RegressionTransformNode } from './regression';\nimport { PivotTransformNode } from './pivot';\nimport { SampleTransformNode } from './sample';\nimport { SequenceNode } from './sequence';\nimport { SourceNode } from './source';\nimport { StackNode } from './stack';\nimport { TimeUnitNode } from './timeunit';\nimport { WindowTransformNode } from './window';\nfunction makeWalkTree(data) {\n    // to name datasources\n    let datasetIndex = 0;\n    /**\n     * Recursively walk down the tree.\n     */\n    function walkTree(node, dataSource) {\n        var _a;\n        if (node instanceof SourceNode) {\n            // If the source is a named data source or a data source with values, we need\n            // to put it in a different data source. Otherwise, Vega may override the data.\n            if (!node.isGenerator && !isUrlData(node.data)) {\n                data.push(dataSource);\n                const newData = {\n                    name: null,\n                    source: dataSource.name,\n                    transform: []\n                };\n                dataSource = newData;\n            }\n        }\n        if (node instanceof ParseNode) {\n            if (node.parent instanceof SourceNode && !dataSource.source) {\n                // If node's parent is a root source and the data source does not refer to another data source, use normal format parse\n                dataSource.format = Object.assign(Object.assign({}, ((_a = dataSource.format) !== null && _a !== void 0 ? _a : {})), { parse: node.assembleFormatParse() });\n                // add calculates for all nested fields\n                dataSource.transform.push(...node.assembleTransforms(true));\n            }\n            else {\n                // Otherwise use Vega expression to parse\n                dataSource.transform.push(...node.assembleTransforms());\n            }\n        }\n        if (node instanceof FacetNode) {\n            if (!dataSource.name) {\n                dataSource.name = `data_${datasetIndex++}`;\n            }\n            if (!dataSource.source || dataSource.transform.length > 0) {\n                data.push(dataSource);\n                node.data = dataSource.name;\n            }\n            else {\n                node.data = dataSource.source;\n            }\n            data.push(...node.assemble());\n            // break here because the rest of the tree has to be taken care of by the facet.\n            return;\n        }\n        if (node instanceof GraticuleNode ||\n            node instanceof SequenceNode ||\n            node instanceof FilterInvalidNode ||\n            node instanceof FilterNode ||\n            node instanceof CalculateNode ||\n            node instanceof GeoPointNode ||\n            node instanceof AggregateNode ||\n            node instanceof LookupNode ||\n            node instanceof WindowTransformNode ||\n            node instanceof JoinAggregateTransformNode ||\n            node instanceof FoldTransformNode ||\n            node instanceof FlattenTransformNode ||\n            node instanceof DensityTransformNode ||\n            node instanceof LoessTransformNode ||\n            node instanceof QuantileTransformNode ||\n            node instanceof RegressionTransformNode ||\n            node instanceof IdentifierNode ||\n            node instanceof SampleTransformNode ||\n            node instanceof PivotTransformNode) {\n            dataSource.transform.push(node.assemble());\n        }\n        if (node instanceof BinNode ||\n            node instanceof TimeUnitNode ||\n            node instanceof ImputeNode ||\n            node instanceof StackNode ||\n            node instanceof GeoJSONNode) {\n            dataSource.transform.push(...node.assemble());\n        }\n        if (node instanceof OutputNode) {\n            if (dataSource.source && dataSource.transform.length === 0) {\n                node.setSource(dataSource.source);\n            }\n            else if (node.parent instanceof OutputNode) {\n                // Note that an output node may be required but we still do not assemble a\n                // separate data source for it.\n                node.setSource(dataSource.name);\n            }\n            else {\n                if (!dataSource.name) {\n                    dataSource.name = `data_${datasetIndex++}`;\n                }\n                // Here we set the name of the datasource we generated. From now on\n                // other assemblers can use it.\n                node.setSource(dataSource.name);\n                // if this node has more than one child, we will add a datasource automatically\n                if (node.numChildren() === 1) {\n                    data.push(dataSource);\n                    const newData = {\n                        name: null,\n                        source: dataSource.name,\n                        transform: []\n                    };\n                    dataSource = newData;\n                }\n            }\n        }\n        switch (node.numChildren()) {\n            case 0:\n                // done\n                if (node instanceof OutputNode && (!dataSource.source || dataSource.transform.length > 0)) {\n                    // do not push empty datasources that are simply references\n                    data.push(dataSource);\n                }\n                break;\n            case 1:\n                walkTree(node.children[0], dataSource);\n                break;\n            default: {\n                if (!dataSource.name) {\n                    dataSource.name = `data_${datasetIndex++}`;\n                }\n                let source = dataSource.name;\n                if (!dataSource.source || dataSource.transform.length > 0) {\n                    data.push(dataSource);\n                }\n                else {\n                    source = dataSource.source;\n                }\n                for (const child of node.children) {\n                    const newData = {\n                        name: null,\n                        source,\n                        transform: []\n                    };\n                    walkTree(child, newData);\n                }\n                break;\n            }\n        }\n    }\n    return walkTree;\n}\n/**\n * Assemble data sources that are derived from faceted data.\n */\nexport function assembleFacetData(root) {\n    const data = [];\n    const walkTree = makeWalkTree(data);\n    for (const child of root.children) {\n        walkTree(child, {\n            source: root.name,\n            name: null,\n            transform: []\n        });\n    }\n    return data;\n}\n/**\n * Create Vega data array from a given compiled model and append all of them to the given array\n *\n * @param  model\n * @param  data array\n * @return modified data array\n */\nexport function assembleRootData(dataComponent, datasets) {\n    var _a, _b;\n    const data = [];\n    // dataComponent.sources.forEach(debug);\n    // draw(dataComponent.sources);\n    const walkTree = makeWalkTree(data);\n    let sourceIndex = 0;\n    for (const root of dataComponent.sources) {\n        // assign a name if the source does not have a name yet\n        if (!root.hasName()) {\n            root.dataName = `source_${sourceIndex++}`;\n        }\n        const newData = root.assemble();\n        walkTree(root, newData);\n    }\n    // remove empty transform arrays for cleaner output\n    for (const d of data) {\n        if (d.transform.length === 0) {\n            delete d.transform;\n        }\n    }\n    // move sources without transforms (the ones that are potentially used in lookups) to the beginning\n    let whereTo = 0;\n    for (const [i, d] of data.entries()) {\n        if (((_a = d.transform) !== null && _a !== void 0 ? _a : []).length === 0 && !d.source) {\n            data.splice(whereTo++, 0, data.splice(i, 1)[0]);\n        }\n    }\n    // now fix the from references in lookup transforms\n    for (const d of data) {\n        for (const t of (_b = d.transform) !== null && _b !== void 0 ? _b : []) {\n            if (t.type === 'lookup') {\n                t.from = dataComponent.outputNodes[t.from].getSource();\n            }\n        }\n    }\n    // inline values for datasets that are in the datastore\n    for (const d of data) {\n        if (d.name in datasets) {\n            d.values = datasets[d.name];\n        }\n    }\n    return data;\n}\n//# sourceMappingURL=assemble.js.map"]},"metadata":{},"sourceType":"module"}