{"ast":null,"code":"import _classCallCheck from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { isString } from 'vega-util';\nimport { LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2 } from '../../channel';\nimport { getFieldOrDatumDef, isDatumDef, isFieldDef, isValueDef } from '../../channeldef';\nimport { duplicate, hash as _hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport var GeoPointNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(GeoPointNode, _DataFlowNode);\n  var _super = _createSuper(GeoPointNode);\n  function GeoPointNode(parent, projection, fields, as) {\n    var _this;\n    _classCallCheck(this, GeoPointNode);\n    _this = _super.call(this, parent);\n    _this.projection = projection;\n    _this.fields = fields;\n    _this.as = as;\n    return _this;\n  }\n  _createClass(GeoPointNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new GeoPointNode(null, this.projection, duplicate(this.fields), duplicate(this.as));\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return new Set(this.fields.filter(isString));\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set(this.as);\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"Geopoint \".concat(this.projection, \" \").concat(_hash(this.fields), \" \").concat(_hash(this.as));\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      return {\n        type: 'geopoint',\n        projection: this.projection,\n        fields: this.fields,\n        as: this.as\n      };\n    }\n  }], [{\n    key: \"parseAll\",\n    value: function parseAll(parent, model) {\n      if (!model.projectionName()) {\n        return parent;\n      }\n      for (var _i = 0, _arr = [[LONGITUDE, LATITUDE], [LONGITUDE2, LATITUDE2]]; _i < _arr.length; _i++) {\n        var coordinates = _arr[_i];\n        var pair = coordinates.map(function (channel) {\n          var def = getFieldOrDatumDef(model.encoding[channel]);\n          return isFieldDef(def) ? def.field : isDatumDef(def) ? {\n            expr: \"\".concat(def.datum)\n          } : isValueDef(def) ? {\n            expr: \"\".concat(def['value'])\n          } : undefined;\n        });\n        var suffix = coordinates[0] === LONGITUDE2 ? '2' : '';\n        if (pair[0] || pair[1]) {\n          parent = new GeoPointNode(parent, model.projectionName(), pair, [model.getName(\"x\".concat(suffix)), model.getName(\"y\".concat(suffix))]);\n        }\n      }\n      return parent;\n    }\n  }]);\n  return GeoPointNode;\n}(DataFlowNode);","map":{"version":3,"sources":["../../../../src/compile/data/geopoint.ts"],"names":[],"mappings":";;;;AACA,SAAQ,QAAQ,QAAO,WAAW;AAClC,SAA4B,QAAQ,EAAE,SAAS,EAAE,SAAS,EAAE,UAAU,QAAO,eAAe;AAC5F,SAAQ,kBAAkB,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,QAAO,kBAAkB;AACvF,SAAQ,SAAS,EAAE,IAAI,IAAJ,KAAI,QAAO,YAAY;AAG1C,SAAQ,YAAY,QAAO,YAAY;AAEvC,WAAa,YAAa;EAAA;EAAA;EAKxB,sBACE,MAAoB,EACZ,UAAkB,EAClB,MAAgD,EAChD,EAAoB,EAAA;IAAA;IAAA;IAE5B,0BAAM,MAAM;IAJJ,MAAA,UAAU,GAAV,UAAU;IACV,MAAA,MAAM,GAAN,MAAM;IACN,MAAA,EAAE,GAAF,EAAE;IAAkB;EAG9B;EAAC;IAAA;IAAA,OAXM,iBAAK;MACV,OAAO,IAAI,YAAY,CAAC,IAAI,EAAE,IAAI,CAAC,UAAU,EAAE,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAC5F;EAAC;IAAA;IAAA,OA4CM,2BAAe;MACpB,OAAO,IAAI,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;IAC9C;EAAC;IAAA;IAAA,OAEM,0BAAc;MACnB,OAAO,IAAI,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC;IACzB;EAAC;IAAA;IAAA,OAEM,gBAAI;MACT,0BAAmB,IAAI,CAAC,UAAU,cAAI,KAAI,CAAC,IAAI,CAAC,MAAM,CAAC,cAAI,KAAI,CAAC,IAAI,CAAC,EAAE,CAAC;IAC1E;EAAC;IAAA;IAAA,OAEM,oBAAQ;MACb,OAAO;QACL,IAAI,EAAE,UAAU;QAChB,UAAU,EAAE,IAAI,CAAC,UAAU;QAC3B,MAAM,EAAE,IAAI,CAAC,MAAM;QACnB,EAAE,EAAE,IAAI,CAAC;OACV;IACH;EAAC;IAAA;IAAA,OApDM,kBAAgB,MAAoB,EAAE,KAAgB,EAAA;MAC3D,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE,EAAE;QAC3B,OAAO,MAAM;MACd;MAED,wBAA0B,CACxB,CAAC,SAAS,EAAE,QAAQ,CAAC,EACrB,CAAC,UAAU,EAAE,SAAS,CAAC,CACS,0BAAE;QAH/B,IAAM,WAAW;QAIpB,IAAM,IAAI,GAAG,WAAW,CAAC,GAAG,CAAC,UAAA,OAAO,EAAG;UACrC,IAAM,GAAG,GAAG,kBAAkB,CAAC,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;UACvD,OAAO,UAAU,CAAC,GAAG,CAAC,GAClB,GAAG,CAAC,KAAK,GACT,UAAU,CAAC,GAAG,CAAC,GACf;YAAC,IAAI,YAAK,GAAG,CAAC,KAAK;UAAE,CAAC,GACtB,UAAU,CAAC,GAAG,CAAC,GACf;YAAC,IAAI,YAAK,GAAG,CAAC,OAAO,CAAC;UAAE,CAAC,GACzB,SAAS;QACf,CAAC,CAA6C;QAE9C,IAAM,MAAM,GAAG,WAAW,CAAC,CAAC,CAAC,KAAK,UAAU,GAAG,GAAG,GAAG,EAAE;QAEvD,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,EAAE;UACtB,MAAM,GAAG,IAAI,YAAY,CAAC,MAAM,EAAE,KAAK,CAAC,cAAc,EAAE,EAAE,IAAI,EAAE,CAC9D,KAAK,CAAC,OAAO,YAAK,MAAM,EAAG,EAC3B,KAAK,CAAC,OAAO,YAAK,MAAM,EAAG,CAC5B,CAAC;QACH;MACF;MAED,OAAO,MAAM;IACf;EAAC;EAAA;AAAA,EA7C+B,YAAY","sourceRoot":"","sourcesContent":["import { isString } from 'vega-util';\nimport { LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2 } from '../../channel';\nimport { getFieldOrDatumDef, isDatumDef, isFieldDef, isValueDef } from '../../channeldef';\nimport { duplicate, hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class GeoPointNode extends DataFlowNode {\n    constructor(parent, projection, fields, as) {\n        super(parent);\n        this.projection = projection;\n        this.fields = fields;\n        this.as = as;\n    }\n    clone() {\n        return new GeoPointNode(null, this.projection, duplicate(this.fields), duplicate(this.as));\n    }\n    static parseAll(parent, model) {\n        if (!model.projectionName()) {\n            return parent;\n        }\n        for (const coordinates of [\n            [LONGITUDE, LATITUDE],\n            [LONGITUDE2, LATITUDE2]\n        ]) {\n            const pair = coordinates.map(channel => {\n                const def = getFieldOrDatumDef(model.encoding[channel]);\n                return isFieldDef(def)\n                    ? def.field\n                    : isDatumDef(def)\n                        ? { expr: `${def.datum}` }\n                        : isValueDef(def)\n                            ? { expr: `${def['value']}` }\n                            : undefined;\n            });\n            const suffix = coordinates[0] === LONGITUDE2 ? '2' : '';\n            if (pair[0] || pair[1]) {\n                parent = new GeoPointNode(parent, model.projectionName(), pair, [\n                    model.getName(`x${suffix}`),\n                    model.getName(`y${suffix}`)\n                ]);\n            }\n        }\n        return parent;\n    }\n    dependentFields() {\n        return new Set(this.fields.filter(isString));\n    }\n    producedFields() {\n        return new Set(this.as);\n    }\n    hash() {\n        return `Geopoint ${this.projection} ${hash(this.fields)} ${hash(this.as)}`;\n    }\n    assemble() {\n        return {\n            type: 'geopoint',\n            projection: this.projection,\n            fields: this.fields,\n            as: this.as\n        };\n    }\n}\n//# sourceMappingURL=geopoint.js.map"]},"metadata":{},"sourceType":"module"}