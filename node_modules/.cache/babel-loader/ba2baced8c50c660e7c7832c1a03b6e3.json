{"ast":null,"code":"import { isString } from 'vega-util';\nimport { isBinning } from '../bin';\nimport { channelDefType, isFieldDef, isFieldOrDatumDefForTimeFormat, isPositionFieldOrDatumDef, isScaleFieldDef, vgField } from '../channeldef';\nimport { fieldValidPredicate } from '../predicate';\nimport { ScaleType } from '../scale';\nimport { formatExpression, normalizeTimeUnit, timeUnitSpecifierExpression } from '../timeunit';\nimport { QUANTITATIVE } from '../type';\nimport { stringify } from '../util';\nimport { isSignalRef } from '../vega.schema';\nimport { datumDefToExpr } from './mark/encode/valueref';\nexport function isCustomFormatType(formatType) {\n  return formatType && formatType !== 'number' && formatType !== 'time';\n}\nfunction customFormatExpr(formatType, field, format) {\n  return \"\".concat(formatType, \"(\").concat(field).concat(format ? \", \".concat(stringify(format)) : '', \")\");\n}\nexport var BIN_RANGE_DELIMITER = \" \\u2013 \";\nexport function formatSignalRef(_ref) {\n  var fieldOrDatumDef = _ref.fieldOrDatumDef,\n    format = _ref.format,\n    formatType = _ref.formatType,\n    expr = _ref.expr,\n    normalizeStack = _ref.normalizeStack,\n    config = _ref.config;\n  var _a, _b;\n  if (isCustomFormatType(formatType)) {\n    return formatCustomType({\n      fieldOrDatumDef: fieldOrDatumDef,\n      format: format,\n      formatType: formatType,\n      expr: expr,\n      config: config\n    });\n  }\n  var field = fieldToFormat(fieldOrDatumDef, expr, normalizeStack);\n  var type = channelDefType(fieldOrDatumDef);\n  if (format === undefined && formatType === undefined && config.customFormatTypes) {\n    if (type === 'quantitative') {\n      if (normalizeStack && config.normalizedNumberFormatType) return formatCustomType({\n        fieldOrDatumDef: fieldOrDatumDef,\n        format: config.normalizedNumberFormat,\n        formatType: config.normalizedNumberFormatType,\n        expr: expr,\n        config: config\n      });\n      if (config.numberFormatType) {\n        return formatCustomType({\n          fieldOrDatumDef: fieldOrDatumDef,\n          format: config.numberFormat,\n          formatType: config.numberFormatType,\n          expr: expr,\n          config: config\n        });\n      }\n    }\n    if (type === 'temporal' && config.timeFormatType && isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit === undefined) {\n      return formatCustomType({\n        fieldOrDatumDef: fieldOrDatumDef,\n        format: config.timeFormat,\n        formatType: config.timeFormatType,\n        expr: expr,\n        config: config\n      });\n    }\n  }\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {\n    var signal = timeFormatExpression({\n      field: field,\n      timeUnit: isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : undefined,\n      format: format,\n      formatType: config.timeFormatType,\n      rawTimeFormat: config.timeFormat,\n      isUTCScale: isScaleFieldDef(fieldOrDatumDef) && ((_b = fieldOrDatumDef.scale) === null || _b === void 0 ? void 0 : _b.type) === ScaleType.UTC\n    });\n    return signal ? {\n      signal: signal\n    } : undefined;\n  }\n  format = numberFormat({\n    type: type,\n    specifiedFormat: format,\n    config: config,\n    normalizeStack: normalizeStack\n  });\n  if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {\n    var endField = vgField(fieldOrDatumDef, {\n      expr: expr,\n      binSuffix: 'end'\n    });\n    return {\n      signal: binFormatExpression(field, endField, format, formatType, config)\n    };\n  } else if (format || channelDefType(fieldOrDatumDef) === 'quantitative') {\n    return {\n      signal: \"\".concat(formatExpr(field, format))\n    };\n  } else {\n    return {\n      signal: \"isValid(\".concat(field, \") ? \").concat(field, \" : \\\"\\\"+\").concat(field)\n    };\n  }\n}\nfunction fieldToFormat(fieldOrDatumDef, expr, normalizeStack) {\n  if (isFieldDef(fieldOrDatumDef)) {\n    if (normalizeStack) {\n      return \"\".concat(vgField(fieldOrDatumDef, {\n        expr: expr,\n        suffix: 'end'\n      }), \"-\").concat(vgField(fieldOrDatumDef, {\n        expr: expr,\n        suffix: 'start'\n      }));\n    } else {\n      return vgField(fieldOrDatumDef, {\n        expr: expr\n      });\n    }\n  } else {\n    return datumDefToExpr(fieldOrDatumDef);\n  }\n}\nexport function formatCustomType(_ref2) {\n  var fieldOrDatumDef = _ref2.fieldOrDatumDef,\n    format = _ref2.format,\n    formatType = _ref2.formatType,\n    expr = _ref2.expr,\n    normalizeStack = _ref2.normalizeStack,\n    config = _ref2.config,\n    field = _ref2.field;\n  field !== null && field !== void 0 ? field : field = fieldToFormat(fieldOrDatumDef, expr, normalizeStack);\n  if (field !== 'datum.value' &&\n  // For axis/legend, we can't correctly know the end of the bin from `datum`\n  isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {\n    var endField = vgField(fieldOrDatumDef, {\n      expr: expr,\n      binSuffix: 'end'\n    });\n    return {\n      signal: binFormatExpression(field, endField, format, formatType, config)\n    };\n  }\n  return {\n    signal: customFormatExpr(formatType, field, format)\n  };\n}\nexport function guideFormat(fieldOrDatumDef, type, format, formatType, config, omitTimeFormatConfig // axis doesn't use config.timeFormat\n) {\n  var _a;\n  if (isCustomFormatType(formatType)) {\n    return undefined; // handled in encode block\n  } else if (format === undefined && formatType === undefined && config.customFormatTypes) {\n    if (channelDefType(fieldOrDatumDef) === 'quantitative') {\n      if (config.normalizedNumberFormatType && isPositionFieldOrDatumDef(fieldOrDatumDef) && fieldOrDatumDef.stack === 'normalize') {\n        return undefined; // handled in encode block\n      }\n\n      if (config.numberFormatType) {\n        return undefined; // handled in encode block\n      }\n    }\n  }\n\n  if (isPositionFieldOrDatumDef(fieldOrDatumDef) && fieldOrDatumDef.stack === 'normalize' && config.normalizedNumberFormat) {\n    return numberFormat({\n      type: 'quantitative',\n      config: config,\n      normalizeStack: true\n    });\n  }\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {\n    var timeUnit = isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : undefined;\n    if (timeUnit === undefined && config.customFormatTypes && config.timeFormatType) {\n      return undefined; // hanlded in encode block\n    }\n\n    return timeFormat({\n      specifiedFormat: format,\n      timeUnit: timeUnit,\n      config: config,\n      omitTimeFormatConfig: omitTimeFormatConfig\n    });\n  }\n  return numberFormat({\n    type: type,\n    specifiedFormat: format,\n    config: config\n  });\n}\nexport function guideFormatType(formatType, fieldOrDatumDef, scaleType) {\n  var _a;\n  if (formatType && (isSignalRef(formatType) || formatType === 'number' || formatType === 'time')) {\n    return formatType;\n  }\n  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) && scaleType !== 'time' && scaleType !== 'utc') {\n    return isFieldDef(fieldOrDatumDef) && ((_a = normalizeTimeUnit(fieldOrDatumDef === null || fieldOrDatumDef === void 0 ? void 0 : fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.utc) ? 'utc' : 'time';\n  }\n  return undefined;\n}\n/**\n * Returns number format for a fieldDef.\n */\nexport function numberFormat(_ref3) {\n  var type = _ref3.type,\n    specifiedFormat = _ref3.specifiedFormat,\n    config = _ref3.config,\n    normalizeStack = _ref3.normalizeStack;\n  // Specified format in axis/legend has higher precedence than fieldDef.format\n  if (isString(specifiedFormat)) {\n    return specifiedFormat;\n  }\n  if (type === QUANTITATIVE) {\n    // we only apply the default if the field is quantitative\n    return normalizeStack ? config.normalizedNumberFormat : config.numberFormat;\n  }\n  return undefined;\n}\n/**\n * Returns time format for a fieldDef for use in guides.\n */\nexport function timeFormat(_ref4) {\n  var specifiedFormat = _ref4.specifiedFormat,\n    timeUnit = _ref4.timeUnit,\n    config = _ref4.config,\n    omitTimeFormatConfig = _ref4.omitTimeFormatConfig;\n  if (specifiedFormat) {\n    return specifiedFormat;\n  }\n  if (timeUnit) {\n    return {\n      signal: timeUnitSpecifierExpression(timeUnit)\n    };\n  }\n  return omitTimeFormatConfig ? undefined : config.timeFormat;\n}\nfunction formatExpr(field, format) {\n  return \"format(\".concat(field, \", \\\"\").concat(format || '', \"\\\")\");\n}\nfunction binNumberFormatExpr(field, format, formatType, config) {\n  var _a;\n  if (isCustomFormatType(formatType)) {\n    return customFormatExpr(formatType, field, format);\n  }\n  return formatExpr(field, (_a = isString(format) ? format : undefined) !== null && _a !== void 0 ? _a : config.numberFormat);\n}\nexport function binFormatExpression(startField, endField, format, formatType, config) {\n  if (format === undefined && formatType === undefined && config.customFormatTypes && config.numberFormatType) {\n    return binFormatExpression(startField, endField, config.numberFormat, config.numberFormatType, config);\n  }\n  var start = binNumberFormatExpr(startField, format, formatType, config);\n  var end = binNumberFormatExpr(endField, format, formatType, config);\n  return \"\".concat(fieldValidPredicate(startField, false), \" ? \\\"null\\\" : \").concat(start, \" + \\\"\").concat(BIN_RANGE_DELIMITER, \"\\\" + \").concat(end);\n}\n/**\n * Returns the time expression used for axis/legend labels or text mark for a temporal field\n */\nexport function timeFormatExpression(_ref5) {\n  var field = _ref5.field,\n    timeUnit = _ref5.timeUnit,\n    format = _ref5.format,\n    formatType = _ref5.formatType,\n    rawTimeFormat = _ref5.rawTimeFormat,\n    isUTCScale = _ref5.isUTCScale;\n  if (!timeUnit || format) {\n    // If there is no time unit, or if user explicitly specifies format for axis/legend/text.\n    if (!timeUnit && formatType) {\n      return \"\".concat(formatType, \"(\").concat(field, \", '\").concat(format, \"')\");\n    }\n    format = isString(format) ? format : rawTimeFormat; // only use provided timeFormat if there is no timeUnit.\n    return \"\".concat(isUTCScale ? 'utc' : 'time', \"Format(\").concat(field, \", '\").concat(format, \"')\");\n  } else {\n    return formatExpression(timeUnit, field, isUTCScale);\n  }\n}","map":{"version":3,"sources":["../../../src/compile/format.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isString } from 'vega-util';\nimport { isBinning } from '../bin';\nimport { channelDefType, isFieldDef, isFieldOrDatumDefForTimeFormat, isPositionFieldOrDatumDef, isScaleFieldDef, vgField } from '../channeldef';\nimport { fieldValidPredicate } from '../predicate';\nimport { ScaleType } from '../scale';\nimport { formatExpression, normalizeTimeUnit, timeUnitSpecifierExpression } from '../timeunit';\nimport { QUANTITATIVE } from '../type';\nimport { stringify } from '../util';\nimport { isSignalRef } from '../vega.schema';\nimport { datumDefToExpr } from './mark/encode/valueref';\nexport function isCustomFormatType(formatType) {\n    return formatType && formatType !== 'number' && formatType !== 'time';\n}\nfunction customFormatExpr(formatType, field, format) {\n    return `${formatType}(${field}${format ? `, ${stringify(format)}` : ''})`;\n}\nexport const BIN_RANGE_DELIMITER = ' \\u2013 ';\nexport function formatSignalRef({ fieldOrDatumDef, format, formatType, expr, normalizeStack, config }) {\n    var _a, _b;\n    if (isCustomFormatType(formatType)) {\n        return formatCustomType({\n            fieldOrDatumDef,\n            format,\n            formatType,\n            expr,\n            config\n        });\n    }\n    const field = fieldToFormat(fieldOrDatumDef, expr, normalizeStack);\n    const type = channelDefType(fieldOrDatumDef);\n    if (format === undefined && formatType === undefined && config.customFormatTypes) {\n        if (type === 'quantitative') {\n            if (normalizeStack && config.normalizedNumberFormatType)\n                return formatCustomType({\n                    fieldOrDatumDef,\n                    format: config.normalizedNumberFormat,\n                    formatType: config.normalizedNumberFormatType,\n                    expr,\n                    config\n                });\n            if (config.numberFormatType) {\n                return formatCustomType({\n                    fieldOrDatumDef,\n                    format: config.numberFormat,\n                    formatType: config.numberFormatType,\n                    expr,\n                    config\n                });\n            }\n        }\n        if (type === 'temporal' &&\n            config.timeFormatType &&\n            isFieldDef(fieldOrDatumDef) &&\n            fieldOrDatumDef.timeUnit === undefined) {\n            return formatCustomType({\n                fieldOrDatumDef,\n                format: config.timeFormat,\n                formatType: config.timeFormatType,\n                expr,\n                config\n            });\n        }\n    }\n    if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {\n        const signal = timeFormatExpression({\n            field,\n            timeUnit: isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : undefined,\n            format,\n            formatType: config.timeFormatType,\n            rawTimeFormat: config.timeFormat,\n            isUTCScale: isScaleFieldDef(fieldOrDatumDef) && ((_b = fieldOrDatumDef.scale) === null || _b === void 0 ? void 0 : _b.type) === ScaleType.UTC\n        });\n        return signal ? { signal } : undefined;\n    }\n    format = numberFormat({ type, specifiedFormat: format, config, normalizeStack });\n    if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {\n        const endField = vgField(fieldOrDatumDef, { expr, binSuffix: 'end' });\n        return {\n            signal: binFormatExpression(field, endField, format, formatType, config)\n        };\n    }\n    else if (format || channelDefType(fieldOrDatumDef) === 'quantitative') {\n        return {\n            signal: `${formatExpr(field, format)}`\n        };\n    }\n    else {\n        return { signal: `isValid(${field}) ? ${field} : \"\"+${field}` };\n    }\n}\nfunction fieldToFormat(fieldOrDatumDef, expr, normalizeStack) {\n    if (isFieldDef(fieldOrDatumDef)) {\n        if (normalizeStack) {\n            return `${vgField(fieldOrDatumDef, { expr, suffix: 'end' })}-${vgField(fieldOrDatumDef, {\n                expr,\n                suffix: 'start'\n            })}`;\n        }\n        else {\n            return vgField(fieldOrDatumDef, { expr });\n        }\n    }\n    else {\n        return datumDefToExpr(fieldOrDatumDef);\n    }\n}\nexport function formatCustomType({ fieldOrDatumDef, format, formatType, expr, normalizeStack, config, field }) {\n    field !== null && field !== void 0 ? field : (field = fieldToFormat(fieldOrDatumDef, expr, normalizeStack));\n    if (field !== 'datum.value' && // For axis/legend, we can't correctly know the end of the bin from `datum`\n        isFieldDef(fieldOrDatumDef) &&\n        isBinning(fieldOrDatumDef.bin)) {\n        const endField = vgField(fieldOrDatumDef, { expr, binSuffix: 'end' });\n        return {\n            signal: binFormatExpression(field, endField, format, formatType, config)\n        };\n    }\n    return { signal: customFormatExpr(formatType, field, format) };\n}\nexport function guideFormat(fieldOrDatumDef, type, format, formatType, config, omitTimeFormatConfig // axis doesn't use config.timeFormat\n) {\n    var _a;\n    if (isCustomFormatType(formatType)) {\n        return undefined; // handled in encode block\n    }\n    else if (format === undefined && formatType === undefined && config.customFormatTypes) {\n        if (channelDefType(fieldOrDatumDef) === 'quantitative') {\n            if (config.normalizedNumberFormatType &&\n                isPositionFieldOrDatumDef(fieldOrDatumDef) &&\n                fieldOrDatumDef.stack === 'normalize') {\n                return undefined; // handled in encode block\n            }\n            if (config.numberFormatType) {\n                return undefined; // handled in encode block\n            }\n        }\n    }\n    if (isPositionFieldOrDatumDef(fieldOrDatumDef) &&\n        fieldOrDatumDef.stack === 'normalize' &&\n        config.normalizedNumberFormat) {\n        return numberFormat({\n            type: 'quantitative',\n            config,\n            normalizeStack: true\n        });\n    }\n    if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {\n        const timeUnit = isFieldDef(fieldOrDatumDef) ? (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit : undefined;\n        if (timeUnit === undefined && config.customFormatTypes && config.timeFormatType) {\n            return undefined; // hanlded in encode block\n        }\n        return timeFormat({ specifiedFormat: format, timeUnit, config, omitTimeFormatConfig });\n    }\n    return numberFormat({ type, specifiedFormat: format, config });\n}\nexport function guideFormatType(formatType, fieldOrDatumDef, scaleType) {\n    var _a;\n    if (formatType && (isSignalRef(formatType) || formatType === 'number' || formatType === 'time')) {\n        return formatType;\n    }\n    if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) && scaleType !== 'time' && scaleType !== 'utc') {\n        return isFieldDef(fieldOrDatumDef) && ((_a = normalizeTimeUnit(fieldOrDatumDef === null || fieldOrDatumDef === void 0 ? void 0 : fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.utc) ? 'utc' : 'time';\n    }\n    return undefined;\n}\n/**\n * Returns number format for a fieldDef.\n */\nexport function numberFormat({ type, specifiedFormat, config, normalizeStack }) {\n    // Specified format in axis/legend has higher precedence than fieldDef.format\n    if (isString(specifiedFormat)) {\n        return specifiedFormat;\n    }\n    if (type === QUANTITATIVE) {\n        // we only apply the default if the field is quantitative\n        return normalizeStack ? config.normalizedNumberFormat : config.numberFormat;\n    }\n    return undefined;\n}\n/**\n * Returns time format for a fieldDef for use in guides.\n */\nexport function timeFormat({ specifiedFormat, timeUnit, config, omitTimeFormatConfig }) {\n    if (specifiedFormat) {\n        return specifiedFormat;\n    }\n    if (timeUnit) {\n        return {\n            signal: timeUnitSpecifierExpression(timeUnit)\n        };\n    }\n    return omitTimeFormatConfig ? undefined : config.timeFormat;\n}\nfunction formatExpr(field, format) {\n    return `format(${field}, \"${format || ''}\")`;\n}\nfunction binNumberFormatExpr(field, format, formatType, config) {\n    var _a;\n    if (isCustomFormatType(formatType)) {\n        return customFormatExpr(formatType, field, format);\n    }\n    return formatExpr(field, (_a = (isString(format) ? format : undefined)) !== null && _a !== void 0 ? _a : config.numberFormat);\n}\nexport function binFormatExpression(startField, endField, format, formatType, config) {\n    if (format === undefined && formatType === undefined && config.customFormatTypes && config.numberFormatType) {\n        return binFormatExpression(startField, endField, config.numberFormat, config.numberFormatType, config);\n    }\n    const start = binNumberFormatExpr(startField, format, formatType, config);\n    const end = binNumberFormatExpr(endField, format, formatType, config);\n    return `${fieldValidPredicate(startField, false)} ? \"null\" : ${start} + \"${BIN_RANGE_DELIMITER}\" + ${end}`;\n}\n/**\n * Returns the time expression used for axis/legend labels or text mark for a temporal field\n */\nexport function timeFormatExpression({ field, timeUnit, format, formatType, rawTimeFormat, isUTCScale }) {\n    if (!timeUnit || format) {\n        // If there is no time unit, or if user explicitly specifies format for axis/legend/text.\n        if (!timeUnit && formatType) {\n            return `${formatType}(${field}, '${format}')`;\n        }\n        format = isString(format) ? format : rawTimeFormat; // only use provided timeFormat if there is no timeUnit.\n        return `${isUTCScale ? 'utc' : 'time'}Format(${field}, '${format}')`;\n    }\n    else {\n        return formatExpression(timeUnit, field, isUTCScale);\n    }\n}\n//# sourceMappingURL=format.js.map"]},"metadata":{},"sourceType":"module"}