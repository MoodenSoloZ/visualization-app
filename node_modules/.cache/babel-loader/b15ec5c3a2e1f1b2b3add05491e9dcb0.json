{"ast":null,"code":"import _inherits from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport * as log from '../../log';\nimport { uniqueId } from '../../util';\n/**\n * A node in the dataflow tree.\n */\nexport var DataFlowNode = /*#__PURE__*/function () {\n  function DataFlowNode(parent, debugName) {\n    _classCallCheck(this, DataFlowNode);\n    this.debugName = debugName;\n    this._children = [];\n    this._parent = null;\n    if (parent) {\n      this.parent = parent;\n    }\n  }\n  /**\n   * Clone this node with a deep copy but don't clone links to children or parents.\n   */\n  _createClass(DataFlowNode, [{\n    key: \"clone\",\n    value: function clone() {\n      throw new Error('Cannot clone node');\n    }\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this._parent;\n    }\n    /**\n     * Set the parent of the node and also add this node to the parent's children.\n     */,\n    set: function set(parent) {\n      this._parent = parent;\n      if (parent) {\n        parent.addChild(this);\n      }\n    }\n  }, {\n    key: \"children\",\n    get: function get() {\n      return this._children;\n    }\n  }, {\n    key: \"numChildren\",\n    value: function numChildren() {\n      return this._children.length;\n    }\n  }, {\n    key: \"addChild\",\n    value: function addChild(child, loc) {\n      // do not add the same child twice\n      if (this._children.includes(child)) {\n        log.warn(log.message.ADD_SAME_CHILD_TWICE);\n        return;\n      }\n      if (loc !== undefined) {\n        this._children.splice(loc, 0, child);\n      } else {\n        this._children.push(child);\n      }\n    }\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(oldChild) {\n      var loc = this._children.indexOf(oldChild);\n      this._children.splice(loc, 1);\n      return loc;\n    }\n    /**\n     * Remove node from the dataflow.\n     */\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var loc = this._parent.removeChild(this);\n      var _iterator = _createForOfIteratorHelper(this._children),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var child = _step.value;\n          // do not use the set method because we want to insert at a particular location\n          child._parent = this._parent;\n          this._parent.addChild(child, loc++);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Insert another node as a parent of this node.\n     */\n  }, {\n    key: \"insertAsParentOf\",\n    value: function insertAsParentOf(other) {\n      var parent = other.parent;\n      parent.removeChild(this);\n      this.parent = parent;\n      other.parent = this;\n    }\n  }, {\n    key: \"swapWithParent\",\n    value: function swapWithParent() {\n      var parent = this._parent;\n      var newParent = parent.parent;\n      // reconnect the children\n      var _iterator2 = _createForOfIteratorHelper(this._children),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var child = _step2.value;\n          child.parent = parent;\n        }\n        // remove old links\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      this._children = []; // equivalent to removing every child link one by one\n      parent.removeChild(this);\n      var loc = parent.parent.removeChild(parent);\n      // swap two nodes but maintain order in children\n      this._parent = newParent;\n      newParent.addChild(this, loc);\n      parent.parent = this;\n    }\n  }]);\n  return DataFlowNode;\n}();\nexport var OutputNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(OutputNode, _DataFlowNode);\n  var _super = _createSuper(OutputNode);\n  /**\n   * @param source The name of the source. Will change in assemble.\n   * @param type The type of the output node.\n   * @param refCounts A global ref counter map.\n   */\n  function OutputNode(parent, source, type, refCounts) {\n    var _this;\n    _classCallCheck(this, OutputNode);\n    _this = _super.call(this, parent, source);\n    _this.type = type;\n    _this.refCounts = refCounts;\n    _this._source = _this._name = source;\n    if (_this.refCounts && !(_this._name in _this.refCounts)) {\n      _this.refCounts[_this._name] = 0;\n    }\n    return _this;\n  }\n  _createClass(OutputNode, [{\n    key: \"clone\",\n    value: function clone() {\n      var cloneObj = new this.constructor();\n      cloneObj.debugName = \"clone_\".concat(this.debugName);\n      cloneObj._source = this._source;\n      cloneObj._name = \"clone_\".concat(this._name);\n      cloneObj.type = this.type;\n      cloneObj.refCounts = this.refCounts;\n      cloneObj.refCounts[cloneObj._name] = 0;\n      return cloneObj;\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return new Set();\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set();\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      if (this._hash === undefined) {\n        this._hash = \"Output \".concat(uniqueId());\n      }\n      return this._hash;\n    }\n    /**\n     * Request the datasource name and increase the ref counter.\n     *\n     * During the parsing phase, this will return the simple name such as 'main' or 'raw'.\n     * It is crucial to request the name from an output node to mark it as a required node.\n     * If nobody ever requests the name, this datasource will not be instantiated in the assemble phase.\n     *\n     * In the assemble phase, this will return the correct name.\n     */\n  }, {\n    key: \"getSource\",\n    value: function getSource() {\n      this.refCounts[this._name]++;\n      return this._source;\n    }\n  }, {\n    key: \"isRequired\",\n    value: function isRequired() {\n      return !!this.refCounts[this._name];\n    }\n  }, {\n    key: \"setSource\",\n    value: function setSource(source) {\n      this._source = source;\n    }\n  }]);\n  return OutputNode;\n}(DataFlowNode);","map":{"version":3,"sources":["../../../../src/compile/data/dataflow.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as log from '../../log';\nimport { uniqueId } from '../../util';\n/**\n * A node in the dataflow tree.\n */\nexport class DataFlowNode {\n    constructor(parent, debugName) {\n        this.debugName = debugName;\n        this._children = [];\n        this._parent = null;\n        if (parent) {\n            this.parent = parent;\n        }\n    }\n    /**\n     * Clone this node with a deep copy but don't clone links to children or parents.\n     */\n    clone() {\n        throw new Error('Cannot clone node');\n    }\n    get parent() {\n        return this._parent;\n    }\n    /**\n     * Set the parent of the node and also add this node to the parent's children.\n     */\n    set parent(parent) {\n        this._parent = parent;\n        if (parent) {\n            parent.addChild(this);\n        }\n    }\n    get children() {\n        return this._children;\n    }\n    numChildren() {\n        return this._children.length;\n    }\n    addChild(child, loc) {\n        // do not add the same child twice\n        if (this._children.includes(child)) {\n            log.warn(log.message.ADD_SAME_CHILD_TWICE);\n            return;\n        }\n        if (loc !== undefined) {\n            this._children.splice(loc, 0, child);\n        }\n        else {\n            this._children.push(child);\n        }\n    }\n    removeChild(oldChild) {\n        const loc = this._children.indexOf(oldChild);\n        this._children.splice(loc, 1);\n        return loc;\n    }\n    /**\n     * Remove node from the dataflow.\n     */\n    remove() {\n        let loc = this._parent.removeChild(this);\n        for (const child of this._children) {\n            // do not use the set method because we want to insert at a particular location\n            child._parent = this._parent;\n            this._parent.addChild(child, loc++);\n        }\n    }\n    /**\n     * Insert another node as a parent of this node.\n     */\n    insertAsParentOf(other) {\n        const parent = other.parent;\n        parent.removeChild(this);\n        this.parent = parent;\n        other.parent = this;\n    }\n    swapWithParent() {\n        const parent = this._parent;\n        const newParent = parent.parent;\n        // reconnect the children\n        for (const child of this._children) {\n            child.parent = parent;\n        }\n        // remove old links\n        this._children = []; // equivalent to removing every child link one by one\n        parent.removeChild(this);\n        const loc = parent.parent.removeChild(parent);\n        // swap two nodes but maintain order in children\n        this._parent = newParent;\n        newParent.addChild(this, loc);\n        parent.parent = this;\n    }\n}\nexport class OutputNode extends DataFlowNode {\n    /**\n     * @param source The name of the source. Will change in assemble.\n     * @param type The type of the output node.\n     * @param refCounts A global ref counter map.\n     */\n    constructor(parent, source, type, refCounts) {\n        super(parent, source);\n        this.type = type;\n        this.refCounts = refCounts;\n        this._source = this._name = source;\n        if (this.refCounts && !(this._name in this.refCounts)) {\n            this.refCounts[this._name] = 0;\n        }\n    }\n    clone() {\n        const cloneObj = new this.constructor();\n        cloneObj.debugName = `clone_${this.debugName}`;\n        cloneObj._source = this._source;\n        cloneObj._name = `clone_${this._name}`;\n        cloneObj.type = this.type;\n        cloneObj.refCounts = this.refCounts;\n        cloneObj.refCounts[cloneObj._name] = 0;\n        return cloneObj;\n    }\n    dependentFields() {\n        return new Set();\n    }\n    producedFields() {\n        return new Set();\n    }\n    hash() {\n        if (this._hash === undefined) {\n            this._hash = `Output ${uniqueId()}`;\n        }\n        return this._hash;\n    }\n    /**\n     * Request the datasource name and increase the ref counter.\n     *\n     * During the parsing phase, this will return the simple name such as 'main' or 'raw'.\n     * It is crucial to request the name from an output node to mark it as a required node.\n     * If nobody ever requests the name, this datasource will not be instantiated in the assemble phase.\n     *\n     * In the assemble phase, this will return the correct name.\n     */\n    getSource() {\n        this.refCounts[this._name]++;\n        return this._source;\n    }\n    isRequired() {\n        return !!this.refCounts[this._name];\n    }\n    setSource(source) {\n        this._source = source;\n    }\n}\n//# sourceMappingURL=dataflow.js.map"]},"metadata":{},"sourceType":"module"}