{"ast":null,"code":"import _defineProperty from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { getMainRangeChannel, getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel, isXorY } from '../../../channel';\nimport { isFieldDef, isFieldOrDatumDef } from '../../../channeldef';\nimport { ScaleType } from '../../../scale';\nimport { contains } from '../../../util';\nimport { getMarkPropOrConfig } from '../../common';\nimport { positionOffset } from './offset';\nimport * as ref from './valueref';\n/**\n * Return encode for point (non-band) position channels.\n */\nexport function pointPosition(channel, model, _ref) {\n  var defaultPos = _ref.defaultPos,\n    vgChannel = _ref.vgChannel;\n  var encoding = model.encoding,\n    markDef = model.markDef,\n    config = model.config,\n    stack = model.stack;\n  var channelDef = encoding[channel];\n  var channel2Def = encoding[getSecondaryRangeChannel(channel)];\n  var scaleName = model.scaleName(channel);\n  var scale = model.getScaleComponent(channel);\n  var _positionOffset = positionOffset({\n      channel: channel,\n      markDef: markDef,\n      encoding: encoding,\n      model: model,\n      bandPosition: 0.5\n    }),\n    offset = _positionOffset.offset,\n    offsetType = _positionOffset.offsetType;\n  // Get default position or position from mark def\n  var defaultRef = pointPositionDefaultRef({\n    model: model,\n    defaultPos: defaultPos,\n    channel: channel,\n    scaleName: scaleName,\n    scale: scale\n  });\n  var valueRef = !channelDef && isXorY(channel) && (encoding.latitude || encoding.longitude) ?\n  // use geopoint output if there are lat/long and there is no point position overriding lat/long.\n  {\n    field: model.getName(channel)\n  } : positionRef({\n    channel: channel,\n    channelDef: channelDef,\n    channel2Def: channel2Def,\n    markDef: markDef,\n    config: config,\n    scaleName: scaleName,\n    scale: scale,\n    stack: stack,\n    offset: offset,\n    defaultRef: defaultRef,\n    bandPosition: offsetType === 'encoding' ? 0 : undefined\n  });\n  return valueRef ? _defineProperty({}, vgChannel || channel, valueRef) : undefined;\n}\n// TODO: we need to find a way to refactor these so that scaleName is a part of scale\n// but that's complicated. For now, this is a huge step moving forward.\n/**\n * @return Vega ValueRef for normal x- or y-position without projection\n */\nexport function positionRef(params) {\n  var channel = params.channel,\n    channelDef = params.channelDef,\n    scaleName = params.scaleName,\n    stack = params.stack,\n    offset = params.offset,\n    markDef = params.markDef;\n  // This isn't a part of midPoint because we use midPoint for non-position too\n  if (isFieldOrDatumDef(channelDef) && stack && channel === stack.fieldChannel) {\n    if (isFieldDef(channelDef)) {\n      var bandPosition = channelDef.bandPosition;\n      if (bandPosition === undefined && markDef.type === 'text' && (channel === 'radius' || channel === 'theta')) {\n        // theta and radius of text mark should use bandPosition = 0.5 by default\n        // so that labels for arc marks are centered automatically\n        bandPosition = 0.5;\n      }\n      if (bandPosition !== undefined) {\n        return ref.interpolatedSignalRef({\n          scaleName: scaleName,\n          fieldOrDatumDef: channelDef,\n          startSuffix: 'start',\n          bandPosition: bandPosition,\n          offset: offset\n        });\n      }\n    }\n    // x or y use stack_end so that stacked line's point mark use stack_end too.\n    return ref.valueRefForFieldOrDatumDef(channelDef, scaleName, {\n      suffix: 'end'\n    }, {\n      offset: offset\n    });\n  }\n  return ref.midPointRefWithPositionInvalidTest(params);\n}\nexport function pointPositionDefaultRef(_ref3) {\n  var model = _ref3.model,\n    defaultPos = _ref3.defaultPos,\n    channel = _ref3.channel,\n    scaleName = _ref3.scaleName,\n    scale = _ref3.scale;\n  var markDef = model.markDef,\n    config = model.config;\n  return function () {\n    var mainChannel = getMainRangeChannel(channel);\n    var vgChannel = getVgPositionChannel(channel);\n    var definedValueOrConfig = getMarkPropOrConfig(channel, markDef, config, {\n      vgChannel: vgChannel\n    });\n    if (definedValueOrConfig !== undefined) {\n      return ref.widthHeightValueOrSignalRef(channel, definedValueOrConfig);\n    }\n    switch (defaultPos) {\n      case 'zeroOrMin':\n      case 'zeroOrMax':\n        if (scaleName) {\n          var scaleType = scale.get('type');\n          if (contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType)) {\n            // Log scales cannot have zero.\n            // Zero in time scale is arbitrary, and does not affect ratio.\n            // (Time is an interval level of measurement, not ratio).\n            // See https://en.wikipedia.org/wiki/Level_of_measurement for more info.\n          } else {\n            if (scale.domainDefinitelyIncludesZero()) {\n              return {\n                scale: scaleName,\n                value: 0\n              };\n            }\n          }\n        }\n        if (defaultPos === 'zeroOrMin') {\n          return mainChannel === 'y' ? {\n            field: {\n              group: 'height'\n            }\n          } : {\n            value: 0\n          };\n        } else {\n          // zeroOrMax\n          switch (mainChannel) {\n            case 'radius':\n              // max of radius is min(width, height) / 2\n              return {\n                signal: \"min(\".concat(model.width.signal, \",\").concat(model.height.signal, \")/2\")\n              };\n            case 'theta':\n              return {\n                signal: '2*PI'\n              };\n            case 'x':\n              return {\n                field: {\n                  group: 'width'\n                }\n              };\n            case 'y':\n              return {\n                value: 0\n              };\n          }\n        }\n        break;\n      case 'mid':\n        {\n          var sizeRef = model[getSizeChannel(channel)];\n          return Object.assign(Object.assign({}, sizeRef), {\n            mult: 0.5\n          });\n        }\n    }\n    // defaultPos === null\n    return undefined;\n  };\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/position-point.ts"],"names":[],"mappings":";AAAA,SACE,mBAAmB,EACnB,wBAAwB,EACxB,cAAc,EACd,oBAAoB,EACpB,MAAM,QAGD,kBAAkB;AACzB,SAAQ,UAAU,EAAE,iBAAiB,QAAsB,qBAAqB;AAChF,SAAQ,SAAS,QAAO,gBAAgB;AACxC,SAAQ,QAAQ,QAAO,eAAe;AAEtC,SAAQ,mBAAmB,QAAO,cAAc;AAGhD,SAAQ,cAAc,QAAO,UAAU;AACvC,OAAO,KAAK,GAAG,MAAM,YAAY;AAEjC;;AAEG;AACH,OAAM,SAAU,aAAa,CAC3B,OAAuC,EACvC,KAAgB,QAOf;EAAA,IALC,UAAU,QAAV,UAAU;IACV,SAAS,QAAT,SAAS;EAMX,IAAO,QAAQ,GAA4B,KAAK,CAAzC,QAAQ;IAAE,OAAO,GAAmB,KAAK,CAA/B,OAAO;IAAE,MAAM,GAAW,KAAK,CAAtB,MAAM;IAAE,KAAK,GAAI,KAAK,CAAd,KAAK;EAEvC,IAAM,UAAU,GAAG,QAAQ,CAAC,OAAO,CAAC;EACpC,IAAM,WAAW,GAAG,QAAQ,CAAC,wBAAwB,CAAC,OAAO,CAAC,CAAC;EAC/D,IAAM,SAAS,GAAG,KAAK,CAAC,SAAS,CAAC,OAAO,CAAC;EAC1C,IAAM,KAAK,GAAG,KAAK,CAAC,iBAAiB,CAAC,OAAO,CAAC;EAE9C,sBAA6B,cAAc,CAAC;MAC1C,OAAO,EAAP,OAAO;MACP,OAAO,EAAP,OAAO;MACP,QAAQ,EAAR,QAAQ;MACR,KAAK,EAAL,KAAK;MACL,YAAY,EAAE;KACf,CAAC;IANK,MAAM,mBAAN,MAAM;IAAE,UAAU,mBAAV,UAAU;EAQzB;EACA,IAAM,UAAU,GAAG,uBAAuB,CAAC;IACzC,KAAK,EAAL,KAAK;IACL,UAAU,EAAV,UAAU;IACV,OAAO,EAAP,OAAO;IACP,SAAS,EAAT,SAAS;IACT,KAAK,EAAL;GACD,CAAC;EAEF,IAAM,QAAQ,GACZ,CAAC,UAAU,IAAI,MAAM,CAAC,OAAO,CAAC,KAAK,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,SAAS,CAAC;EACvE;EACA;IAAC,KAAK,EAAE,KAAK,CAAC,OAAO,CAAC,OAAO;EAAC,CAAC,GAC/B,WAAW,CAAC;IACV,OAAO,EAAP,OAAO;IACP,UAAU,EAAV,UAAU;IACV,WAAW,EAAX,WAAW;IACX,OAAO,EAAP,OAAO;IACP,MAAM,EAAN,MAAM;IACN,SAAS,EAAT,SAAS;IACT,KAAK,EAAL,KAAK;IACL,KAAK,EAAL,KAAK;IACL,MAAM,EAAN,MAAM;IACN,UAAU,EAAV,UAAU;IACV,YAAY,EAAE,UAAU,KAAK,UAAU,GAAG,CAAC,GAAG;GAC/C,CAAC;EAER,OAAO,QAAQ,uBAAK,SAAS,IAAI,OAAO,EAAG,QAAQ,IAAI,SAAS;AAClE;AAEA;AACA;AAEA;;AAEG;AACH,OAAM,SAAU,WAAW,CACzB,MAEC,EAAA;EAED,IAAO,OAAO,GAAmD,MAAM,CAAhE,OAAO;IAAE,UAAU,GAAuC,MAAM,CAAvD,UAAU;IAAE,SAAS,GAA4B,MAAM,CAA3C,SAAS;IAAE,KAAK,GAAqB,MAAM,CAAhC,KAAK;IAAE,MAAM,GAAa,MAAM,CAAzB,MAAM;IAAE,OAAO,GAAI,MAAM,CAAjB,OAAO;EAE7D;EACA,IAAI,iBAAiB,CAAC,UAAU,CAAC,IAAI,KAAK,IAAI,OAAO,KAAK,KAAK,CAAC,YAAY,EAAE;IAC5E,IAAI,UAAU,CAAC,UAAU,CAAC,EAAE;MAC1B,IAAI,YAAY,GAAG,UAAU,CAAC,YAAY;MAE1C,IAAI,YAAY,KAAK,SAAS,IAAI,OAAO,CAAC,IAAI,KAAK,MAAM,KAAK,OAAO,KAAK,QAAQ,IAAI,OAAO,KAAK,OAAO,CAAC,EAAE;QAC1G;QACA;QACA,YAAY,GAAG,GAAG;MACnB;MAED,IAAI,YAAY,KAAK,SAAS,EAAE;QAC9B,OAAO,GAAG,CAAC,qBAAqB,CAAC;UAC/B,SAAS,EAAT,SAAS;UACT,eAAe,EAAE,UAAmC;UACpD,WAAW,EAAE,OAAO;UACpB,YAAY,EAAZ,YAAY;UACZ,MAAM,EAAN;SACD,CAAC;MACH;IACF;IACD;IACA,OAAO,GAAG,CAAC,0BAA0B,CAAC,UAAU,EAAE,SAAS,EAAE;MAAC,MAAM,EAAE;IAAK,CAAC,EAAE;MAAC,MAAM,EAAN;IAAM,CAAC,CAAC;EACxF;EAED,OAAO,GAAG,CAAC,kCAAkC,CAAC,MAAM,CAAC;AACvD;AAEA,OAAM,SAAU,uBAAuB,QAYtC;EAAA,IAXC,KAAK,SAAL,KAAK;IACL,UAAU,SAAV,UAAU;IACV,OAAO,SAAP,OAAO;IACP,SAAS,SAAT,SAAS;IACT,KAAK,SAAL,KAAK;EAQL,IAAO,OAAO,GAAY,KAAK,CAAxB,OAAO;IAAE,MAAM,GAAI,KAAK,CAAf,MAAM;EACtB,OAAO,YAAK;IACV,IAAM,WAAW,GAAG,mBAAmB,CAAC,OAAO,CAAC;IAChD,IAAM,SAAS,GAAG,oBAAoB,CAAC,OAAO,CAAC;IAE/C,IAAM,oBAAoB,GAAG,mBAAmB,CAAC,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE;MAAC,SAAS,EAAT;IAAS,CAAC,CAAC;IACvF,IAAI,oBAAoB,KAAK,SAAS,EAAE;MACtC,OAAO,GAAG,CAAC,2BAA2B,CAAC,OAAO,EAAE,oBAAoB,CAAC;IACtE;IAED,QAAQ,UAAU;MAChB,KAAK,WAAW;MAChB,KAAK,WAAW;QACd,IAAI,SAAS,EAAE;UACb,IAAM,SAAS,GAAG,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC;UACnC,IAAI,QAAQ,CAAC,CAAC,SAAS,CAAC,GAAG,EAAE,SAAS,CAAC,IAAI,EAAE,SAAS,CAAC,GAAG,CAAC,EAAE,SAAS,CAAC,EAAE;YACvE;YACA;YACA;YACA;WACD,MAAM;YACL,IAAI,KAAK,CAAC,4BAA4B,EAAE,EAAE;cACxC,OAAO;gBACL,KAAK,EAAE,SAAS;gBAChB,KAAK,EAAE;eACR;YACF;UACF;QACF;QAED,IAAI,UAAU,KAAK,WAAW,EAAE;UAC9B,OAAO,WAAW,KAAK,GAAG,GAAG;YAAC,KAAK,EAAE;cAAC,KAAK,EAAE;YAAQ;UAAC,CAAC,GAAG;YAAC,KAAK,EAAE;UAAC,CAAC;SACrE,MAAM;UACL;UACA,QAAQ,WAAW;YACjB,KAAK,QAAQ;cACX;cACA,OAAO;gBACL,MAAM,gBAAS,KAAK,CAAC,KAAK,CAAC,MAAM,cAAI,KAAK,CAAC,MAAM,CAAC,MAAM;eACzD;YACH,KAAK,OAAO;cACV,OAAO;gBAAC,MAAM,EAAE;cAAM,CAAC;YACzB,KAAK,GAAG;cACN,OAAO;gBAAC,KAAK,EAAE;kBAAC,KAAK,EAAE;gBAAO;cAAC,CAAC;YAClC,KAAK,GAAG;cACN,OAAO;gBAAC,KAAK,EAAE;cAAC,CAAC;UAAC;QAEvB;QACD;MACF,KAAK,KAAK;QAAE;UACV,IAAM,OAAO,GAAG,KAAK,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;UAC9C,OAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAW,OAAO,CAAA,EAAA;YAAE,IAAI,EAAE;UAAG,CAAA,CAAA;;IAC9B;IAEH;IACA,OAAO,SAAS;EAClB,CAAC;AACH","sourceRoot":"","sourcesContent":["import { getMainRangeChannel, getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel, isXorY } from '../../../channel';\nimport { isFieldDef, isFieldOrDatumDef } from '../../../channeldef';\nimport { ScaleType } from '../../../scale';\nimport { contains } from '../../../util';\nimport { getMarkPropOrConfig } from '../../common';\nimport { positionOffset } from './offset';\nimport * as ref from './valueref';\n/**\n * Return encode for point (non-band) position channels.\n */\nexport function pointPosition(channel, model, { defaultPos, vgChannel }) {\n    const { encoding, markDef, config, stack } = model;\n    const channelDef = encoding[channel];\n    const channel2Def = encoding[getSecondaryRangeChannel(channel)];\n    const scaleName = model.scaleName(channel);\n    const scale = model.getScaleComponent(channel);\n    const { offset, offsetType } = positionOffset({\n        channel,\n        markDef,\n        encoding,\n        model,\n        bandPosition: 0.5\n    });\n    // Get default position or position from mark def\n    const defaultRef = pointPositionDefaultRef({\n        model,\n        defaultPos,\n        channel,\n        scaleName,\n        scale\n    });\n    const valueRef = !channelDef && isXorY(channel) && (encoding.latitude || encoding.longitude)\n        ? // use geopoint output if there are lat/long and there is no point position overriding lat/long.\n            { field: model.getName(channel) }\n        : positionRef({\n            channel,\n            channelDef,\n            channel2Def,\n            markDef,\n            config,\n            scaleName,\n            scale,\n            stack,\n            offset,\n            defaultRef,\n            bandPosition: offsetType === 'encoding' ? 0 : undefined\n        });\n    return valueRef ? { [vgChannel || channel]: valueRef } : undefined;\n}\n// TODO: we need to find a way to refactor these so that scaleName is a part of scale\n// but that's complicated. For now, this is a huge step moving forward.\n/**\n * @return Vega ValueRef for normal x- or y-position without projection\n */\nexport function positionRef(params) {\n    const { channel, channelDef, scaleName, stack, offset, markDef } = params;\n    // This isn't a part of midPoint because we use midPoint for non-position too\n    if (isFieldOrDatumDef(channelDef) && stack && channel === stack.fieldChannel) {\n        if (isFieldDef(channelDef)) {\n            let bandPosition = channelDef.bandPosition;\n            if (bandPosition === undefined && markDef.type === 'text' && (channel === 'radius' || channel === 'theta')) {\n                // theta and radius of text mark should use bandPosition = 0.5 by default\n                // so that labels for arc marks are centered automatically\n                bandPosition = 0.5;\n            }\n            if (bandPosition !== undefined) {\n                return ref.interpolatedSignalRef({\n                    scaleName,\n                    fieldOrDatumDef: channelDef,\n                    startSuffix: 'start',\n                    bandPosition,\n                    offset\n                });\n            }\n        }\n        // x or y use stack_end so that stacked line's point mark use stack_end too.\n        return ref.valueRefForFieldOrDatumDef(channelDef, scaleName, { suffix: 'end' }, { offset });\n    }\n    return ref.midPointRefWithPositionInvalidTest(params);\n}\nexport function pointPositionDefaultRef({ model, defaultPos, channel, scaleName, scale }) {\n    const { markDef, config } = model;\n    return () => {\n        const mainChannel = getMainRangeChannel(channel);\n        const vgChannel = getVgPositionChannel(channel);\n        const definedValueOrConfig = getMarkPropOrConfig(channel, markDef, config, { vgChannel });\n        if (definedValueOrConfig !== undefined) {\n            return ref.widthHeightValueOrSignalRef(channel, definedValueOrConfig);\n        }\n        switch (defaultPos) {\n            case 'zeroOrMin':\n            case 'zeroOrMax':\n                if (scaleName) {\n                    const scaleType = scale.get('type');\n                    if (contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType)) {\n                        // Log scales cannot have zero.\n                        // Zero in time scale is arbitrary, and does not affect ratio.\n                        // (Time is an interval level of measurement, not ratio).\n                        // See https://en.wikipedia.org/wiki/Level_of_measurement for more info.\n                    }\n                    else {\n                        if (scale.domainDefinitelyIncludesZero()) {\n                            return {\n                                scale: scaleName,\n                                value: 0\n                            };\n                        }\n                    }\n                }\n                if (defaultPos === 'zeroOrMin') {\n                    return mainChannel === 'y' ? { field: { group: 'height' } } : { value: 0 };\n                }\n                else {\n                    // zeroOrMax\n                    switch (mainChannel) {\n                        case 'radius':\n                            // max of radius is min(width, height) / 2\n                            return {\n                                signal: `min(${model.width.signal},${model.height.signal})/2`\n                            };\n                        case 'theta':\n                            return { signal: '2*PI' };\n                        case 'x':\n                            return { field: { group: 'width' } };\n                        case 'y':\n                            return { value: 0 };\n                    }\n                }\n                break;\n            case 'mid': {\n                const sizeRef = model[getSizeChannel(channel)];\n                return Object.assign(Object.assign({}, sizeRef), { mult: 0.5 });\n            }\n        }\n        // defaultPos === null\n        return undefined;\n    };\n}\n//# sourceMappingURL=position-point.js.map"]},"metadata":{},"sourceType":"module"}