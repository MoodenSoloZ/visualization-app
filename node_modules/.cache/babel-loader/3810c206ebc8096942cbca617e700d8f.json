{"ast":null,"code":"import _defineProperty from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { getMainRangeChannel, getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel } from '../../../channel';\nimport { isFieldOrDatumDef } from '../../../channeldef';\nimport * as log from '../../../log';\nimport { isRelativeBandSize } from '../../../mark';\nimport { getMarkStyleConfig } from '../../common';\nimport { positionOffset } from './offset';\nimport { vgAlignedPositionChannel } from './position-align';\nimport { pointPosition, pointPositionDefaultRef } from './position-point';\nimport * as ref from './valueref';\n/**\n * Utility for area/rule position, which can be either point or range.\n * (One of the axes should be point and the other should be range.)\n */\nexport function pointOrRangePosition(channel, model, _ref) {\n  var defaultPos = _ref.defaultPos,\n    defaultPos2 = _ref.defaultPos2,\n    range = _ref.range;\n  if (range) {\n    return rangePosition(channel, model, {\n      defaultPos: defaultPos,\n      defaultPos2: defaultPos2\n    });\n  }\n  return pointPosition(channel, model, {\n    defaultPos: defaultPos\n  });\n}\nexport function rangePosition(channel, model, _ref2) {\n  var defaultPos = _ref2.defaultPos,\n    defaultPos2 = _ref2.defaultPos2;\n  var markDef = model.markDef,\n    config = model.config;\n  var channel2 = getSecondaryRangeChannel(channel);\n  var sizeChannel = getSizeChannel(channel);\n  var pos2Mixins = pointPosition2OrSize(model, defaultPos2, channel2);\n  var vgChannel = pos2Mixins[sizeChannel] ?\n  // If there is width/height, we need to position the marks based on the alignment.\n  vgAlignedPositionChannel(channel, markDef, config) :\n  // Otherwise, make sure to apply to the right Vg Channel (for arc mark)\n  getVgPositionChannel(channel);\n  return Object.assign(Object.assign({}, pointPosition(channel, model, {\n    defaultPos: defaultPos,\n    vgChannel: vgChannel\n  })), pos2Mixins);\n}\n/**\n * Return encode for x2, y2.\n * If channel is not specified, return one channel based on orientation.\n */\nfunction pointPosition2OrSize(model, defaultPos, channel) {\n  var _position2orSize;\n  var encoding = model.encoding,\n    mark = model.mark,\n    markDef = model.markDef,\n    stack = model.stack,\n    config = model.config;\n  var baseChannel = getMainRangeChannel(channel);\n  var sizeChannel = getSizeChannel(channel);\n  var vgChannel = getVgPositionChannel(channel);\n  var channelDef = encoding[baseChannel];\n  var scaleName = model.scaleName(baseChannel);\n  var scale = model.getScaleComponent(baseChannel);\n  var _ref3 = channel in encoding || channel in markDef ? positionOffset({\n      channel: channel,\n      markDef: markDef,\n      encoding: encoding,\n      model: model\n    }) : positionOffset({\n      channel: baseChannel,\n      markDef: markDef,\n      encoding: encoding,\n      model: model\n    }),\n    offset = _ref3.offset;\n  if (!channelDef && (channel === 'x2' || channel === 'y2') && (encoding.latitude || encoding.longitude)) {\n    var vgSizeChannel = getSizeChannel(channel);\n    var size = model.markDef[vgSizeChannel];\n    if (size != null) {\n      return _defineProperty({}, vgSizeChannel, {\n        value: size\n      });\n    } else {\n      return _defineProperty({}, vgChannel, {\n        field: model.getName(channel)\n      });\n    }\n  }\n  var valueRef = position2Ref({\n    channel: channel,\n    channelDef: channelDef,\n    channel2Def: encoding[channel],\n    markDef: markDef,\n    config: config,\n    scaleName: scaleName,\n    scale: scale,\n    stack: stack,\n    offset: offset,\n    defaultRef: undefined\n  });\n  if (valueRef !== undefined) {\n    return _defineProperty({}, vgChannel, valueRef);\n  }\n  // TODO: check width/height encoding here once we add them\n  // no x2/y2 encoding, then try to read x2/y2 or width/height based on precedence:\n  // markDef > config.style > mark-specific config (config[mark]) > general mark config (config.mark)\n  return position2orSize(channel, markDef) || position2orSize(channel, (_position2orSize = {}, _defineProperty(_position2orSize, channel, getMarkStyleConfig(channel, markDef, config.style)), _defineProperty(_position2orSize, sizeChannel, getMarkStyleConfig(sizeChannel, markDef, config.style)), _position2orSize)) || position2orSize(channel, config[mark]) || position2orSize(channel, config.mark) || _defineProperty({}, vgChannel, pointPositionDefaultRef({\n    model: model,\n    defaultPos: defaultPos,\n    channel: channel,\n    scaleName: scaleName,\n    scale: scale\n  })());\n}\nexport function position2Ref(_ref8) {\n  var channel = _ref8.channel,\n    channelDef = _ref8.channelDef,\n    channel2Def = _ref8.channel2Def,\n    markDef = _ref8.markDef,\n    config = _ref8.config,\n    scaleName = _ref8.scaleName,\n    scale = _ref8.scale,\n    stack = _ref8.stack,\n    offset = _ref8.offset,\n    defaultRef = _ref8.defaultRef;\n  if (isFieldOrDatumDef(channelDef) && stack &&\n  // If fieldChannel is X and channel is X2 (or Y and Y2)\n  channel.charAt(0) === stack.fieldChannel.charAt(0)) {\n    return ref.valueRefForFieldOrDatumDef(channelDef, scaleName, {\n      suffix: 'start'\n    }, {\n      offset: offset\n    });\n  }\n  return ref.midPointRefWithPositionInvalidTest({\n    channel: channel,\n    channelDef: channel2Def,\n    scaleName: scaleName,\n    scale: scale,\n    stack: stack,\n    markDef: markDef,\n    config: config,\n    offset: offset,\n    defaultRef: defaultRef\n  });\n}\nfunction position2orSize(channel, markDef) {\n  var sizeChannel = getSizeChannel(channel);\n  var vgChannel = getVgPositionChannel(channel);\n  if (markDef[vgChannel] !== undefined) {\n    return _defineProperty({}, vgChannel, ref.widthHeightValueOrSignalRef(channel, markDef[vgChannel]));\n  } else if (markDef[channel] !== undefined) {\n    return _defineProperty({}, vgChannel, ref.widthHeightValueOrSignalRef(channel, markDef[channel]));\n  } else if (markDef[sizeChannel]) {\n    var dimensionSize = markDef[sizeChannel];\n    if (isRelativeBandSize(dimensionSize)) {\n      log.warn(log.message.relativeBandSizeNotSupported(sizeChannel));\n    } else {\n      return _defineProperty({}, sizeChannel, ref.widthHeightValueOrSignalRef(channel, dimensionSize));\n    }\n  }\n  return undefined;\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/position-range.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { getMainRangeChannel, getSecondaryRangeChannel, getSizeChannel, getVgPositionChannel } from '../../../channel';\nimport { isFieldOrDatumDef } from '../../../channeldef';\nimport * as log from '../../../log';\nimport { isRelativeBandSize } from '../../../mark';\nimport { getMarkStyleConfig } from '../../common';\nimport { positionOffset } from './offset';\nimport { vgAlignedPositionChannel } from './position-align';\nimport { pointPosition, pointPositionDefaultRef } from './position-point';\nimport * as ref from './valueref';\n/**\n * Utility for area/rule position, which can be either point or range.\n * (One of the axes should be point and the other should be range.)\n */\nexport function pointOrRangePosition(channel, model, { defaultPos, defaultPos2, range }) {\n    if (range) {\n        return rangePosition(channel, model, { defaultPos, defaultPos2 });\n    }\n    return pointPosition(channel, model, { defaultPos });\n}\nexport function rangePosition(channel, model, { defaultPos, defaultPos2 }) {\n    const { markDef, config } = model;\n    const channel2 = getSecondaryRangeChannel(channel);\n    const sizeChannel = getSizeChannel(channel);\n    const pos2Mixins = pointPosition2OrSize(model, defaultPos2, channel2);\n    const vgChannel = pos2Mixins[sizeChannel]\n        ? // If there is width/height, we need to position the marks based on the alignment.\n            vgAlignedPositionChannel(channel, markDef, config)\n        : // Otherwise, make sure to apply to the right Vg Channel (for arc mark)\n            getVgPositionChannel(channel);\n    return Object.assign(Object.assign({}, pointPosition(channel, model, { defaultPos, vgChannel })), pos2Mixins);\n}\n/**\n * Return encode for x2, y2.\n * If channel is not specified, return one channel based on orientation.\n */\nfunction pointPosition2OrSize(model, defaultPos, channel) {\n    const { encoding, mark, markDef, stack, config } = model;\n    const baseChannel = getMainRangeChannel(channel);\n    const sizeChannel = getSizeChannel(channel);\n    const vgChannel = getVgPositionChannel(channel);\n    const channelDef = encoding[baseChannel];\n    const scaleName = model.scaleName(baseChannel);\n    const scale = model.getScaleComponent(baseChannel);\n    const { offset } = channel in encoding || channel in markDef\n        ? positionOffset({ channel, markDef, encoding, model })\n        : positionOffset({ channel: baseChannel, markDef, encoding, model });\n    if (!channelDef && (channel === 'x2' || channel === 'y2') && (encoding.latitude || encoding.longitude)) {\n        const vgSizeChannel = getSizeChannel(channel);\n        const size = model.markDef[vgSizeChannel];\n        if (size != null) {\n            return {\n                [vgSizeChannel]: { value: size }\n            };\n        }\n        else {\n            return {\n                [vgChannel]: { field: model.getName(channel) }\n            };\n        }\n    }\n    const valueRef = position2Ref({\n        channel,\n        channelDef,\n        channel2Def: encoding[channel],\n        markDef,\n        config,\n        scaleName,\n        scale,\n        stack,\n        offset,\n        defaultRef: undefined\n    });\n    if (valueRef !== undefined) {\n        return { [vgChannel]: valueRef };\n    }\n    // TODO: check width/height encoding here once we add them\n    // no x2/y2 encoding, then try to read x2/y2 or width/height based on precedence:\n    // markDef > config.style > mark-specific config (config[mark]) > general mark config (config.mark)\n    return (position2orSize(channel, markDef) ||\n        position2orSize(channel, {\n            [channel]: getMarkStyleConfig(channel, markDef, config.style),\n            [sizeChannel]: getMarkStyleConfig(sizeChannel, markDef, config.style)\n        }) ||\n        position2orSize(channel, config[mark]) ||\n        position2orSize(channel, config.mark) || {\n        [vgChannel]: pointPositionDefaultRef({\n            model,\n            defaultPos,\n            channel,\n            scaleName,\n            scale\n        })()\n    });\n}\nexport function position2Ref({ channel, channelDef, channel2Def, markDef, config, scaleName, scale, stack, offset, defaultRef }) {\n    if (isFieldOrDatumDef(channelDef) &&\n        stack &&\n        // If fieldChannel is X and channel is X2 (or Y and Y2)\n        channel.charAt(0) === stack.fieldChannel.charAt(0)) {\n        return ref.valueRefForFieldOrDatumDef(channelDef, scaleName, { suffix: 'start' }, { offset });\n    }\n    return ref.midPointRefWithPositionInvalidTest({\n        channel,\n        channelDef: channel2Def,\n        scaleName,\n        scale,\n        stack,\n        markDef,\n        config,\n        offset,\n        defaultRef\n    });\n}\nfunction position2orSize(channel, markDef) {\n    const sizeChannel = getSizeChannel(channel);\n    const vgChannel = getVgPositionChannel(channel);\n    if (markDef[vgChannel] !== undefined) {\n        return { [vgChannel]: ref.widthHeightValueOrSignalRef(channel, markDef[vgChannel]) };\n    }\n    else if (markDef[channel] !== undefined) {\n        return { [vgChannel]: ref.widthHeightValueOrSignalRef(channel, markDef[channel]) };\n    }\n    else if (markDef[sizeChannel]) {\n        const dimensionSize = markDef[sizeChannel];\n        if (isRelativeBandSize(dimensionSize)) {\n            log.warn(log.message.relativeBandSizeNotSupported(sizeChannel));\n        }\n        else {\n            return { [sizeChannel]: ref.widthHeightValueOrSignalRef(channel, dimensionSize) };\n        }\n    }\n    return undefined;\n}\n//# sourceMappingURL=position-range.js.map"]},"metadata":{},"sourceType":"module"}