{"ast":null,"code":"import _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { isArray } from 'vega-util';\nimport { isBinning } from '../../bin';\nimport { COLUMN, FACET_CHANNELS, POSITION_SCALE_CHANNELS, ROW } from '../../channel';\nimport { vgField } from '../../channeldef';\nimport * as log from '../../log';\nimport { hasDiscreteDomain } from '../../scale';\nimport { DEFAULT_SORT_OP, isSortField } from '../../sort';\nimport { hash as _hash } from '../../util';\nimport { isVgRangeStep } from '../../vega.schema';\nimport { HEADER_CHANNELS, HEADER_TYPES } from '../header/component';\nimport { assembleDomain, getFieldFromDomain } from '../scale/domain';\nimport { sortArrayIndexField } from './calculate';\nimport { DataFlowNode } from './dataflow';\n/**\n * A node that helps us track what fields we are faceting by.\n */\nexport var FacetNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(FacetNode, _DataFlowNode);\n  var _super = _createSuper(FacetNode);\n  /**\n   * @param model The facet model.\n   * @param name The name that this facet source will have.\n   * @param data The source data for this facet data.\n   */\n  function FacetNode(parent, model, name, data) {\n    var _this;\n    _classCallCheck(this, FacetNode);\n    _this = _super.call(this, parent);\n    _this.model = model;\n    _this.name = name;\n    _this.data = data;\n    var _iterator = _createForOfIteratorHelper(FACET_CHANNELS),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var channel = _step.value;\n        var fieldDef = model.facet[channel];\n        if (fieldDef) {\n          var bin = fieldDef.bin,\n            sort = fieldDef.sort;\n          _this[channel] = Object.assign({\n            name: model.getName(\"\".concat(channel, \"_domain\")),\n            fields: [vgField(fieldDef)].concat(_toConsumableArray(isBinning(bin) ? [vgField(fieldDef, {\n              binSuffix: 'end'\n            })] : []))\n          }, isSortField(sort) ? {\n            sortField: sort\n          } : isArray(sort) ? {\n            sortIndexField: sortArrayIndexField(fieldDef, channel)\n          } : {});\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    _this.childModel = model.child;\n    return _this;\n  }\n  _createClass(FacetNode, [{\n    key: \"hash\",\n    value: function hash() {\n      var out = \"Facet\";\n      var _iterator2 = _createForOfIteratorHelper(FACET_CHANNELS),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var channel = _step2.value;\n          if (this[channel]) {\n            out += \" \".concat(channel.charAt(0), \":\").concat(_hash(this[channel]));\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return out;\n    }\n  }, {\n    key: \"fields\",\n    get: function get() {\n      var _a;\n      var f = [];\n      var _iterator3 = _createForOfIteratorHelper(FACET_CHANNELS),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var channel = _step3.value;\n          if ((_a = this[channel]) === null || _a === void 0 ? void 0 : _a.fields) {\n            f.push.apply(f, _toConsumableArray(this[channel].fields));\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return f;\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      var depFields = new Set(this.fields);\n      var _iterator4 = _createForOfIteratorHelper(FACET_CHANNELS),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var channel = _step4.value;\n          if (this[channel]) {\n            if (this[channel].sortField) {\n              depFields.add(this[channel].sortField.field);\n            }\n            if (this[channel].sortIndexField) {\n              depFields.add(this[channel].sortIndexField);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      return depFields;\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set(); // facet does not produce any new fields\n    }\n    /**\n     * The name to reference this source is its name.\n     */\n  }, {\n    key: \"getSource\",\n    value: function getSource() {\n      return this.name;\n    }\n  }, {\n    key: \"getChildIndependentFieldsWithStep\",\n    value: function getChildIndependentFieldsWithStep() {\n      var childIndependentFieldsWithStep = {};\n      var _iterator5 = _createForOfIteratorHelper(POSITION_SCALE_CHANNELS),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var channel = _step5.value;\n          var childScaleComponent = this.childModel.component.scales[channel];\n          if (childScaleComponent && !childScaleComponent.merged) {\n            // independent scale\n            var type = childScaleComponent.get('type');\n            var range = childScaleComponent.get('range');\n            if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n              var domain = assembleDomain(this.childModel, channel);\n              var field = getFieldFromDomain(domain);\n              if (field) {\n                childIndependentFieldsWithStep[channel] = field;\n              } else {\n                log.warn(log.message.unknownField(channel));\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      return childIndependentFieldsWithStep;\n    }\n  }, {\n    key: \"assembleRowColumnHeaderData\",\n    value: function assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep) {\n      var childChannel = {\n        row: 'y',\n        column: 'x',\n        facet: undefined\n      }[channel];\n      var fields = [];\n      var ops = [];\n      var as = [];\n      if (childChannel && childIndependentFieldsWithStep && childIndependentFieldsWithStep[childChannel]) {\n        if (crossedDataName) {\n          // If there is a crossed data, calculate max\n          fields.push(\"distinct_\".concat(childIndependentFieldsWithStep[childChannel]));\n          ops.push('max');\n        } else {\n          // If there is no crossed data, just calculate distinct\n          fields.push(childIndependentFieldsWithStep[childChannel]);\n          ops.push('distinct');\n        }\n        // Although it is technically a max, just name it distinct so it's easier to refer to it\n        as.push(\"distinct_\".concat(childIndependentFieldsWithStep[childChannel]));\n      }\n      var _this$channel = this[channel],\n        sortField = _this$channel.sortField,\n        sortIndexField = _this$channel.sortIndexField;\n      if (sortField) {\n        var _sortField$op = sortField.op,\n          op = _sortField$op === void 0 ? DEFAULT_SORT_OP : _sortField$op,\n          field = sortField.field;\n        fields.push(field);\n        ops.push(op);\n        as.push(vgField(sortField, {\n          forAs: true\n        }));\n      } else if (sortIndexField) {\n        fields.push(sortIndexField);\n        ops.push('max');\n        as.push(sortIndexField);\n      }\n      return {\n        name: this[channel].name,\n        // Use data from the crossed one if it exist\n        source: crossedDataName !== null && crossedDataName !== void 0 ? crossedDataName : this.data,\n        transform: [Object.assign({\n          type: 'aggregate',\n          groupby: this[channel].fields\n        }, fields.length ? {\n          fields: fields,\n          ops: ops,\n          as: as\n        } : {})]\n      };\n    }\n  }, {\n    key: \"assembleFacetHeaderData\",\n    value: function assembleFacetHeaderData(childIndependentFieldsWithStep) {\n      var _a, _b;\n      var columns = this.model.layout.columns;\n      var layoutHeaders = this.model.component.layoutHeaders;\n      var data = [];\n      var hasSharedAxis = {};\n      var _iterator6 = _createForOfIteratorHelper(HEADER_CHANNELS),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var headerChannel = _step6.value;\n          var _iterator7 = _createForOfIteratorHelper(HEADER_TYPES),\n            _step7;\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var headerType = _step7.value;\n              var headers = (_a = layoutHeaders[headerChannel] && layoutHeaders[headerChannel][headerType]) !== null && _a !== void 0 ? _a : [];\n              var _iterator8 = _createForOfIteratorHelper(headers),\n                _step8;\n              try {\n                for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                  var header = _step8.value;\n                  if (((_b = header.axes) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n                    hasSharedAxis[headerChannel] = true;\n                    break;\n                  }\n                }\n              } catch (err) {\n                _iterator8.e(err);\n              } finally {\n                _iterator8.f();\n              }\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n          if (hasSharedAxis[headerChannel]) {\n            var cardinality = \"length(data(\\\"\".concat(this.facet.name, \"\\\"))\");\n            var stop = headerChannel === 'row' ? columns ? {\n              signal: \"ceil(\".concat(cardinality, \" / \").concat(columns, \")\")\n            } : 1 : columns ? {\n              signal: \"min(\".concat(cardinality, \", \").concat(columns, \")\")\n            } : {\n              signal: cardinality\n            };\n            data.push({\n              name: \"\".concat(this.facet.name, \"_\").concat(headerChannel),\n              transform: [{\n                type: 'sequence',\n                start: 0,\n                stop: stop\n              }]\n            });\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      var row = hasSharedAxis.row,\n        column = hasSharedAxis.column;\n      if (row || column) {\n        data.unshift(this.assembleRowColumnHeaderData('facet', null, childIndependentFieldsWithStep));\n      }\n      return data;\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      var _a, _b;\n      var data = [];\n      var crossedDataName = null;\n      var childIndependentFieldsWithStep = this.getChildIndependentFieldsWithStep();\n      var column = this.column,\n        row = this.row,\n        facet = this.facet;\n      if (column && row && (childIndependentFieldsWithStep.x || childIndependentFieldsWithStep.y)) {\n        // Need to create a cross dataset to correctly calculate cardinality\n        crossedDataName = \"cross_\".concat(this.column.name, \"_\").concat(this.row.name);\n        var fields = [].concat((_a = childIndependentFieldsWithStep.x) !== null && _a !== void 0 ? _a : [], (_b = childIndependentFieldsWithStep.y) !== null && _b !== void 0 ? _b : []);\n        var ops = fields.map(function () {\n          return 'distinct';\n        });\n        data.push({\n          name: crossedDataName,\n          source: this.data,\n          transform: [{\n            type: 'aggregate',\n            groupby: this.fields,\n            fields: fields,\n            ops: ops\n          }]\n        });\n      }\n      for (var _i = 0, _arr = [COLUMN, ROW]; _i < _arr.length; _i++) {\n        var channel = _arr[_i];\n        if (this[channel]) {\n          data.push(this.assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep));\n        }\n      }\n      if (facet) {\n        var facetData = this.assembleFacetHeaderData(childIndependentFieldsWithStep);\n        if (facetData) {\n          data.push.apply(data, _toConsumableArray(facetData));\n        }\n      }\n      return data;\n    }\n  }]);\n  return FacetNode;\n}(DataFlowNode);","map":{"version":3,"sources":["../../../../src/compile/data/facet.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray } from 'vega-util';\nimport { isBinning } from '../../bin';\nimport { COLUMN, FACET_CHANNELS, POSITION_SCALE_CHANNELS, ROW } from '../../channel';\nimport { vgField } from '../../channeldef';\nimport * as log from '../../log';\nimport { hasDiscreteDomain } from '../../scale';\nimport { DEFAULT_SORT_OP, isSortField } from '../../sort';\nimport { hash } from '../../util';\nimport { isVgRangeStep } from '../../vega.schema';\nimport { HEADER_CHANNELS, HEADER_TYPES } from '../header/component';\nimport { assembleDomain, getFieldFromDomain } from '../scale/domain';\nimport { sortArrayIndexField } from './calculate';\nimport { DataFlowNode } from './dataflow';\n/**\n * A node that helps us track what fields we are faceting by.\n */\nexport class FacetNode extends DataFlowNode {\n    /**\n     * @param model The facet model.\n     * @param name The name that this facet source will have.\n     * @param data The source data for this facet data.\n     */\n    constructor(parent, model, name, data) {\n        super(parent);\n        this.model = model;\n        this.name = name;\n        this.data = data;\n        for (const channel of FACET_CHANNELS) {\n            const fieldDef = model.facet[channel];\n            if (fieldDef) {\n                const { bin, sort } = fieldDef;\n                this[channel] = Object.assign({ name: model.getName(`${channel}_domain`), fields: [vgField(fieldDef), ...(isBinning(bin) ? [vgField(fieldDef, { binSuffix: 'end' })] : [])] }, (isSortField(sort)\n                    ? { sortField: sort }\n                    : isArray(sort)\n                        ? { sortIndexField: sortArrayIndexField(fieldDef, channel) }\n                        : {}));\n            }\n        }\n        this.childModel = model.child;\n    }\n    hash() {\n        let out = `Facet`;\n        for (const channel of FACET_CHANNELS) {\n            if (this[channel]) {\n                out += ` ${channel.charAt(0)}:${hash(this[channel])}`;\n            }\n        }\n        return out;\n    }\n    get fields() {\n        var _a;\n        const f = [];\n        for (const channel of FACET_CHANNELS) {\n            if ((_a = this[channel]) === null || _a === void 0 ? void 0 : _a.fields) {\n                f.push(...this[channel].fields);\n            }\n        }\n        return f;\n    }\n    dependentFields() {\n        const depFields = new Set(this.fields);\n        for (const channel of FACET_CHANNELS) {\n            if (this[channel]) {\n                if (this[channel].sortField) {\n                    depFields.add(this[channel].sortField.field);\n                }\n                if (this[channel].sortIndexField) {\n                    depFields.add(this[channel].sortIndexField);\n                }\n            }\n        }\n        return depFields;\n    }\n    producedFields() {\n        return new Set(); // facet does not produce any new fields\n    }\n    /**\n     * The name to reference this source is its name.\n     */\n    getSource() {\n        return this.name;\n    }\n    getChildIndependentFieldsWithStep() {\n        const childIndependentFieldsWithStep = {};\n        for (const channel of POSITION_SCALE_CHANNELS) {\n            const childScaleComponent = this.childModel.component.scales[channel];\n            if (childScaleComponent && !childScaleComponent.merged) {\n                // independent scale\n                const type = childScaleComponent.get('type');\n                const range = childScaleComponent.get('range');\n                if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n                    const domain = assembleDomain(this.childModel, channel);\n                    const field = getFieldFromDomain(domain);\n                    if (field) {\n                        childIndependentFieldsWithStep[channel] = field;\n                    }\n                    else {\n                        log.warn(log.message.unknownField(channel));\n                    }\n                }\n            }\n        }\n        return childIndependentFieldsWithStep;\n    }\n    assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep) {\n        const childChannel = { row: 'y', column: 'x', facet: undefined }[channel];\n        const fields = [];\n        const ops = [];\n        const as = [];\n        if (childChannel && childIndependentFieldsWithStep && childIndependentFieldsWithStep[childChannel]) {\n            if (crossedDataName) {\n                // If there is a crossed data, calculate max\n                fields.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);\n                ops.push('max');\n            }\n            else {\n                // If there is no crossed data, just calculate distinct\n                fields.push(childIndependentFieldsWithStep[childChannel]);\n                ops.push('distinct');\n            }\n            // Although it is technically a max, just name it distinct so it's easier to refer to it\n            as.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);\n        }\n        const { sortField, sortIndexField } = this[channel];\n        if (sortField) {\n            const { op = DEFAULT_SORT_OP, field } = sortField;\n            fields.push(field);\n            ops.push(op);\n            as.push(vgField(sortField, { forAs: true }));\n        }\n        else if (sortIndexField) {\n            fields.push(sortIndexField);\n            ops.push('max');\n            as.push(sortIndexField);\n        }\n        return {\n            name: this[channel].name,\n            // Use data from the crossed one if it exist\n            source: crossedDataName !== null && crossedDataName !== void 0 ? crossedDataName : this.data,\n            transform: [\n                Object.assign({ type: 'aggregate', groupby: this[channel].fields }, (fields.length\n                    ? {\n                        fields,\n                        ops,\n                        as\n                    }\n                    : {}))\n            ]\n        };\n    }\n    assembleFacetHeaderData(childIndependentFieldsWithStep) {\n        var _a, _b;\n        const { columns } = this.model.layout;\n        const { layoutHeaders } = this.model.component;\n        const data = [];\n        const hasSharedAxis = {};\n        for (const headerChannel of HEADER_CHANNELS) {\n            for (const headerType of HEADER_TYPES) {\n                const headers = (_a = (layoutHeaders[headerChannel] && layoutHeaders[headerChannel][headerType])) !== null && _a !== void 0 ? _a : [];\n                for (const header of headers) {\n                    if (((_b = header.axes) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n                        hasSharedAxis[headerChannel] = true;\n                        break;\n                    }\n                }\n            }\n            if (hasSharedAxis[headerChannel]) {\n                const cardinality = `length(data(\"${this.facet.name}\"))`;\n                const stop = headerChannel === 'row'\n                    ? columns\n                        ? { signal: `ceil(${cardinality} / ${columns})` }\n                        : 1\n                    : columns\n                        ? { signal: `min(${cardinality}, ${columns})` }\n                        : { signal: cardinality };\n                data.push({\n                    name: `${this.facet.name}_${headerChannel}`,\n                    transform: [\n                        {\n                            type: 'sequence',\n                            start: 0,\n                            stop\n                        }\n                    ]\n                });\n            }\n        }\n        const { row, column } = hasSharedAxis;\n        if (row || column) {\n            data.unshift(this.assembleRowColumnHeaderData('facet', null, childIndependentFieldsWithStep));\n        }\n        return data;\n    }\n    assemble() {\n        var _a, _b;\n        const data = [];\n        let crossedDataName = null;\n        const childIndependentFieldsWithStep = this.getChildIndependentFieldsWithStep();\n        const { column, row, facet } = this;\n        if (column && row && (childIndependentFieldsWithStep.x || childIndependentFieldsWithStep.y)) {\n            // Need to create a cross dataset to correctly calculate cardinality\n            crossedDataName = `cross_${this.column.name}_${this.row.name}`;\n            const fields = [].concat((_a = childIndependentFieldsWithStep.x) !== null && _a !== void 0 ? _a : [], (_b = childIndependentFieldsWithStep.y) !== null && _b !== void 0 ? _b : []);\n            const ops = fields.map(() => 'distinct');\n            data.push({\n                name: crossedDataName,\n                source: this.data,\n                transform: [\n                    {\n                        type: 'aggregate',\n                        groupby: this.fields,\n                        fields,\n                        ops\n                    }\n                ]\n            });\n        }\n        for (const channel of [COLUMN, ROW]) {\n            if (this[channel]) {\n                data.push(this.assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep));\n            }\n        }\n        if (facet) {\n            const facetData = this.assembleFacetHeaderData(childIndependentFieldsWithStep);\n            if (facetData) {\n                data.push(...facetData);\n            }\n        }\n        return data;\n    }\n}\n//# sourceMappingURL=facet.js.map"]},"metadata":{},"sourceType":"module"}