{"ast":null,"code":"import _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { isArray } from 'vega-util';\nimport { isConditionalAxisValue } from '../axis';\nimport { GEOPOSITION_CHANNELS, NONPOSITION_SCALE_CHANNELS, POSITION_SCALE_CHANNELS, SCALE_CHANNELS, supportLegend, X, Y } from '../channel';\nimport { getFieldDef, getFieldOrDatumDef, isFieldOrDatumDef, isTypedFieldDef } from '../channeldef';\nimport { isGraticuleGenerator } from '../data';\nimport * as vlEncoding from '../encoding';\nimport { initEncoding } from '../encoding';\nimport { replaceExprRef } from '../expr';\nimport { GEOSHAPE, isMarkDef } from '../mark';\nimport { isSelectionParameter } from '../selection';\nimport { isFrameMixins } from '../spec/base';\nimport { stack } from '../stack';\nimport { keys } from '../util';\nimport { assembleAxisSignals } from './axis/assemble';\nimport { parseUnitAxes } from './axis/parse';\nimport { signalOrValueRefWithCondition, signalRefOrValue } from './common';\nimport { parseData as _parseData } from './data/parse';\nimport { assembleLayoutSignals as _assembleLayoutSignals } from './layoutsize/assemble';\nimport { initLayoutSize } from './layoutsize/init';\nimport { parseUnitLayoutSize } from './layoutsize/parse';\nimport { defaultFilled, initMarkdef } from './mark/init';\nimport { parseMarkGroups } from './mark/mark';\nimport { isLayerModel, ModelWithField } from './model';\nimport { assembleTopLevelSignals, assembleUnitSelectionData, assembleUnitSelectionMarks, assembleUnitSelectionSignals } from './selection/assemble';\nimport { parseUnitSelection } from './selection/parse';\n/**\n * Internal model of Vega-Lite specification for the compiler.\n */\nexport var UnitModel = /*#__PURE__*/function (_ModelWithField) {\n  _inherits(UnitModel, _ModelWithField);\n  var _super = _createSuper(UnitModel);\n  function UnitModel(spec, parent, parentGivenName) {\n    var _this;\n    var parentGivenSize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var config = arguments.length > 4 ? arguments[4] : undefined;\n    _classCallCheck(this, UnitModel);\n    var _a;\n    _this = _super.call(this, spec, 'unit', parent, parentGivenName, config, undefined, isFrameMixins(spec) ? spec.view : undefined);\n    _this.specifiedScales = {};\n    _this.specifiedAxes = {};\n    _this.specifiedLegends = {};\n    _this.specifiedProjection = {};\n    _this.selection = [];\n    _this.children = [];\n    var markDef = isMarkDef(spec.mark) ? Object.assign({}, spec.mark) : {\n      type: spec.mark\n    };\n    var mark = markDef.type;\n    // Need to init filled before other mark properties because encoding depends on filled but other mark properties depend on types inside encoding\n    if (markDef.filled === undefined) {\n      markDef.filled = defaultFilled(markDef, config, {\n        graticule: spec.data && isGraticuleGenerator(spec.data)\n      });\n    }\n    var encoding = _this.encoding = initEncoding(spec.encoding || {}, mark, markDef.filled, config);\n    _this.markDef = initMarkdef(markDef, encoding, config);\n    _this.size = initLayoutSize({\n      encoding: encoding,\n      size: isFrameMixins(spec) ? Object.assign(Object.assign(Object.assign({}, parentGivenSize), spec.width ? {\n        width: spec.width\n      } : {}), spec.height ? {\n        height: spec.height\n      } : {}) : parentGivenSize\n    });\n    // calculate stack properties\n    _this.stack = stack(mark, encoding);\n    _this.specifiedScales = _this.initScales(mark, encoding);\n    _this.specifiedAxes = _this.initAxes(encoding);\n    _this.specifiedLegends = _this.initLegends(encoding);\n    _this.specifiedProjection = spec.projection;\n    // Selections will be initialized upon parse.\n    _this.selection = ((_a = spec.params) !== null && _a !== void 0 ? _a : []).filter(function (p) {\n      return isSelectionParameter(p);\n    });\n    return _this;\n  }\n  _createClass(UnitModel, [{\n    key: \"hasProjection\",\n    get: function get() {\n      var encoding = this.encoding;\n      var isGeoShapeMark = this.mark === GEOSHAPE;\n      var hasGeoPosition = encoding && GEOPOSITION_CHANNELS.some(function (channel) {\n        return isFieldOrDatumDef(encoding[channel]);\n      });\n      return isGeoShapeMark || hasGeoPosition;\n    }\n    /**\n     * Return specified Vega-Lite scale domain for a particular channel\n     * @param channel\n     */\n  }, {\n    key: \"scaleDomain\",\n    value: function scaleDomain(channel) {\n      var scale = this.specifiedScales[channel];\n      return scale ? scale.domain : undefined;\n    }\n  }, {\n    key: \"axis\",\n    value: function axis(channel) {\n      return this.specifiedAxes[channel];\n    }\n  }, {\n    key: \"legend\",\n    value: function legend(channel) {\n      return this.specifiedLegends[channel];\n    }\n  }, {\n    key: \"initScales\",\n    value: function initScales(mark, encoding) {\n      var _this2 = this;\n      return SCALE_CHANNELS.reduce(function (scales, channel) {\n        var _a;\n        var fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n        if (fieldOrDatumDef) {\n          scales[channel] = _this2.initScale((_a = fieldOrDatumDef.scale) !== null && _a !== void 0 ? _a : {});\n        }\n        return scales;\n      }, {});\n    }\n  }, {\n    key: \"initScale\",\n    value: function initScale(scale) {\n      var domain = scale.domain,\n        range = scale.range;\n      // TODO: we could simplify this function if we had a recursive replace function\n      var scaleInternal = replaceExprRef(scale);\n      if (isArray(domain)) {\n        scaleInternal.domain = domain.map(signalRefOrValue);\n      }\n      if (isArray(range)) {\n        scaleInternal.range = range.map(signalRefOrValue);\n      }\n      return scaleInternal;\n    }\n  }, {\n    key: \"initAxes\",\n    value: function initAxes(encoding) {\n      var _this3 = this;\n      return POSITION_SCALE_CHANNELS.reduce(function (_axis, channel) {\n        // Position Axis\n        // TODO: handle ConditionFieldDef\n        var channelDef = encoding[channel];\n        if (isFieldOrDatumDef(channelDef) || channel === X && isFieldOrDatumDef(encoding.x2) || channel === Y && isFieldOrDatumDef(encoding.y2)) {\n          var axisSpec = isFieldOrDatumDef(channelDef) ? channelDef.axis : undefined;\n          _axis[channel] = axisSpec ? _this3.initAxis(Object.assign({}, axisSpec)) // convert truthy value to object\n          : axisSpec;\n        }\n        return _axis;\n      }, {});\n    }\n  }, {\n    key: \"initAxis\",\n    value: function initAxis(axis) {\n      var props = keys(axis);\n      var axisInternal = {};\n      var _iterator = _createForOfIteratorHelper(props),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var prop = _step.value;\n          var val = axis[prop];\n          axisInternal[prop] = isConditionalAxisValue(val) ? signalOrValueRefWithCondition(val) : signalRefOrValue(val);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return axisInternal;\n    }\n  }, {\n    key: \"initLegends\",\n    value: function initLegends(encoding) {\n      return NONPOSITION_SCALE_CHANNELS.reduce(function (_legend, channel) {\n        var fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n        if (fieldOrDatumDef && supportLegend(channel)) {\n          var legend = fieldOrDatumDef.legend;\n          _legend[channel] = legend ? replaceExprRef(legend) // convert truthy value to object\n          : legend;\n        }\n        return _legend;\n      }, {});\n    }\n  }, {\n    key: \"parseData\",\n    value: function parseData() {\n      this.component.data = _parseData(this);\n    }\n  }, {\n    key: \"parseLayoutSize\",\n    value: function parseLayoutSize() {\n      parseUnitLayoutSize(this);\n    }\n  }, {\n    key: \"parseSelections\",\n    value: function parseSelections() {\n      this.component.selection = parseUnitSelection(this, this.selection);\n    }\n  }, {\n    key: \"parseMarkGroup\",\n    value: function parseMarkGroup() {\n      this.component.mark = parseMarkGroups(this);\n    }\n  }, {\n    key: \"parseAxesAndHeaders\",\n    value: function parseAxesAndHeaders() {\n      this.component.axes = parseUnitAxes(this);\n    }\n  }, {\n    key: \"assembleSelectionTopLevelSignals\",\n    value: function assembleSelectionTopLevelSignals(signals) {\n      return assembleTopLevelSignals(this, signals);\n    }\n  }, {\n    key: \"assembleSignals\",\n    value: function assembleSignals() {\n      return [].concat(_toConsumableArray(assembleAxisSignals(this)), _toConsumableArray(assembleUnitSelectionSignals(this, [])));\n    }\n  }, {\n    key: \"assembleSelectionData\",\n    value: function assembleSelectionData(data) {\n      return assembleUnitSelectionData(this, data);\n    }\n  }, {\n    key: \"assembleLayout\",\n    value: function assembleLayout() {\n      return null;\n    }\n  }, {\n    key: \"assembleLayoutSignals\",\n    value: function assembleLayoutSignals() {\n      return _assembleLayoutSignals(this);\n    }\n  }, {\n    key: \"assembleMarks\",\n    value: function assembleMarks() {\n      var _a;\n      var marks = (_a = this.component.mark) !== null && _a !== void 0 ? _a : [];\n      // If this unit is part of a layer, selections should augment\n      // all in concert rather than each unit individually. This\n      // ensures correct interleaving of clipping and brushed marks.\n      if (!this.parent || !isLayerModel(this.parent)) {\n        marks = assembleUnitSelectionMarks(this, marks);\n      }\n      return marks.map(this.correctDataNames);\n    }\n  }, {\n    key: \"assembleGroupStyle\",\n    value: function assembleGroupStyle() {\n      var _ref = this.view || {},\n        style = _ref.style;\n      if (style !== undefined) {\n        return style;\n      }\n      if (this.encoding.x || this.encoding.y) {\n        return 'cell';\n      } else {\n        return undefined;\n      }\n    }\n  }, {\n    key: \"getMapping\",\n    value: function getMapping() {\n      return this.encoding;\n    }\n  }, {\n    key: \"mark\",\n    get: function get() {\n      return this.markDef.type;\n    }\n  }, {\n    key: \"channelHasField\",\n    value: function channelHasField(channel) {\n      return vlEncoding.channelHasField(this.encoding, channel);\n    }\n  }, {\n    key: \"fieldDef\",\n    value: function fieldDef(channel) {\n      var channelDef = this.encoding[channel];\n      return getFieldDef(channelDef);\n    }\n  }, {\n    key: \"typedFieldDef\",\n    value: function typedFieldDef(channel) {\n      var fieldDef = this.fieldDef(channel);\n      if (isTypedFieldDef(fieldDef)) {\n        return fieldDef;\n      }\n      return null;\n    }\n  }]);\n  return UnitModel;\n}(ModelWithField);","map":{"version":3,"sources":["../../../src/compile/unit.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray } from 'vega-util';\nimport { isConditionalAxisValue } from '../axis';\nimport { GEOPOSITION_CHANNELS, NONPOSITION_SCALE_CHANNELS, POSITION_SCALE_CHANNELS, SCALE_CHANNELS, supportLegend, X, Y } from '../channel';\nimport { getFieldDef, getFieldOrDatumDef, isFieldOrDatumDef, isTypedFieldDef } from '../channeldef';\nimport { isGraticuleGenerator } from '../data';\nimport * as vlEncoding from '../encoding';\nimport { initEncoding } from '../encoding';\nimport { replaceExprRef } from '../expr';\nimport { GEOSHAPE, isMarkDef } from '../mark';\nimport { isSelectionParameter } from '../selection';\nimport { isFrameMixins } from '../spec/base';\nimport { stack } from '../stack';\nimport { keys } from '../util';\nimport { assembleAxisSignals } from './axis/assemble';\nimport { parseUnitAxes } from './axis/parse';\nimport { signalOrValueRefWithCondition, signalRefOrValue } from './common';\nimport { parseData } from './data/parse';\nimport { assembleLayoutSignals } from './layoutsize/assemble';\nimport { initLayoutSize } from './layoutsize/init';\nimport { parseUnitLayoutSize } from './layoutsize/parse';\nimport { defaultFilled, initMarkdef } from './mark/init';\nimport { parseMarkGroups } from './mark/mark';\nimport { isLayerModel, ModelWithField } from './model';\nimport { assembleTopLevelSignals, assembleUnitSelectionData, assembleUnitSelectionMarks, assembleUnitSelectionSignals } from './selection/assemble';\nimport { parseUnitSelection } from './selection/parse';\n/**\n * Internal model of Vega-Lite specification for the compiler.\n */\nexport class UnitModel extends ModelWithField {\n    constructor(spec, parent, parentGivenName, parentGivenSize = {}, config) {\n        var _a;\n        super(spec, 'unit', parent, parentGivenName, config, undefined, isFrameMixins(spec) ? spec.view : undefined);\n        this.specifiedScales = {};\n        this.specifiedAxes = {};\n        this.specifiedLegends = {};\n        this.specifiedProjection = {};\n        this.selection = [];\n        this.children = [];\n        const markDef = isMarkDef(spec.mark) ? Object.assign({}, spec.mark) : { type: spec.mark };\n        const mark = markDef.type;\n        // Need to init filled before other mark properties because encoding depends on filled but other mark properties depend on types inside encoding\n        if (markDef.filled === undefined) {\n            markDef.filled = defaultFilled(markDef, config, {\n                graticule: spec.data && isGraticuleGenerator(spec.data)\n            });\n        }\n        const encoding = (this.encoding = initEncoding(spec.encoding || {}, mark, markDef.filled, config));\n        this.markDef = initMarkdef(markDef, encoding, config);\n        this.size = initLayoutSize({\n            encoding,\n            size: isFrameMixins(spec)\n                ? Object.assign(Object.assign(Object.assign({}, parentGivenSize), (spec.width ? { width: spec.width } : {})), (spec.height ? { height: spec.height } : {})) : parentGivenSize\n        });\n        // calculate stack properties\n        this.stack = stack(mark, encoding);\n        this.specifiedScales = this.initScales(mark, encoding);\n        this.specifiedAxes = this.initAxes(encoding);\n        this.specifiedLegends = this.initLegends(encoding);\n        this.specifiedProjection = spec.projection;\n        // Selections will be initialized upon parse.\n        this.selection = ((_a = spec.params) !== null && _a !== void 0 ? _a : []).filter(p => isSelectionParameter(p));\n    }\n    get hasProjection() {\n        const { encoding } = this;\n        const isGeoShapeMark = this.mark === GEOSHAPE;\n        const hasGeoPosition = encoding && GEOPOSITION_CHANNELS.some(channel => isFieldOrDatumDef(encoding[channel]));\n        return isGeoShapeMark || hasGeoPosition;\n    }\n    /**\n     * Return specified Vega-Lite scale domain for a particular channel\n     * @param channel\n     */\n    scaleDomain(channel) {\n        const scale = this.specifiedScales[channel];\n        return scale ? scale.domain : undefined;\n    }\n    axis(channel) {\n        return this.specifiedAxes[channel];\n    }\n    legend(channel) {\n        return this.specifiedLegends[channel];\n    }\n    initScales(mark, encoding) {\n        return SCALE_CHANNELS.reduce((scales, channel) => {\n            var _a;\n            const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n            if (fieldOrDatumDef) {\n                scales[channel] = this.initScale((_a = fieldOrDatumDef.scale) !== null && _a !== void 0 ? _a : {});\n            }\n            return scales;\n        }, {});\n    }\n    initScale(scale) {\n        const { domain, range } = scale;\n        // TODO: we could simplify this function if we had a recursive replace function\n        const scaleInternal = replaceExprRef(scale);\n        if (isArray(domain)) {\n            scaleInternal.domain = domain.map(signalRefOrValue);\n        }\n        if (isArray(range)) {\n            scaleInternal.range = range.map(signalRefOrValue);\n        }\n        return scaleInternal;\n    }\n    initAxes(encoding) {\n        return POSITION_SCALE_CHANNELS.reduce((_axis, channel) => {\n            // Position Axis\n            // TODO: handle ConditionFieldDef\n            const channelDef = encoding[channel];\n            if (isFieldOrDatumDef(channelDef) ||\n                (channel === X && isFieldOrDatumDef(encoding.x2)) ||\n                (channel === Y && isFieldOrDatumDef(encoding.y2))) {\n                const axisSpec = isFieldOrDatumDef(channelDef) ? channelDef.axis : undefined;\n                _axis[channel] = axisSpec\n                    ? this.initAxis(Object.assign({}, axisSpec)) // convert truthy value to object\n                    : axisSpec;\n            }\n            return _axis;\n        }, {});\n    }\n    initAxis(axis) {\n        const props = keys(axis);\n        const axisInternal = {};\n        for (const prop of props) {\n            const val = axis[prop];\n            axisInternal[prop] = isConditionalAxisValue(val)\n                ? signalOrValueRefWithCondition(val)\n                : signalRefOrValue(val);\n        }\n        return axisInternal;\n    }\n    initLegends(encoding) {\n        return NONPOSITION_SCALE_CHANNELS.reduce((_legend, channel) => {\n            const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n            if (fieldOrDatumDef && supportLegend(channel)) {\n                const legend = fieldOrDatumDef.legend;\n                _legend[channel] = legend\n                    ? replaceExprRef(legend) // convert truthy value to object\n                    : legend;\n            }\n            return _legend;\n        }, {});\n    }\n    parseData() {\n        this.component.data = parseData(this);\n    }\n    parseLayoutSize() {\n        parseUnitLayoutSize(this);\n    }\n    parseSelections() {\n        this.component.selection = parseUnitSelection(this, this.selection);\n    }\n    parseMarkGroup() {\n        this.component.mark = parseMarkGroups(this);\n    }\n    parseAxesAndHeaders() {\n        this.component.axes = parseUnitAxes(this);\n    }\n    assembleSelectionTopLevelSignals(signals) {\n        return assembleTopLevelSignals(this, signals);\n    }\n    assembleSignals() {\n        return [...assembleAxisSignals(this), ...assembleUnitSelectionSignals(this, [])];\n    }\n    assembleSelectionData(data) {\n        return assembleUnitSelectionData(this, data);\n    }\n    assembleLayout() {\n        return null;\n    }\n    assembleLayoutSignals() {\n        return assembleLayoutSignals(this);\n    }\n    assembleMarks() {\n        var _a;\n        let marks = (_a = this.component.mark) !== null && _a !== void 0 ? _a : [];\n        // If this unit is part of a layer, selections should augment\n        // all in concert rather than each unit individually. This\n        // ensures correct interleaving of clipping and brushed marks.\n        if (!this.parent || !isLayerModel(this.parent)) {\n            marks = assembleUnitSelectionMarks(this, marks);\n        }\n        return marks.map(this.correctDataNames);\n    }\n    assembleGroupStyle() {\n        const { style } = this.view || {};\n        if (style !== undefined) {\n            return style;\n        }\n        if (this.encoding.x || this.encoding.y) {\n            return 'cell';\n        }\n        else {\n            return undefined;\n        }\n    }\n    getMapping() {\n        return this.encoding;\n    }\n    get mark() {\n        return this.markDef.type;\n    }\n    channelHasField(channel) {\n        return vlEncoding.channelHasField(this.encoding, channel);\n    }\n    fieldDef(channel) {\n        const channelDef = this.encoding[channel];\n        return getFieldDef(channelDef);\n    }\n    typedFieldDef(channel) {\n        const fieldDef = this.fieldDef(channel);\n        if (isTypedFieldDef(fieldDef)) {\n            return fieldDef;\n        }\n        return null;\n    }\n}\n//# sourceMappingURL=unit.js.map"]},"metadata":{},"sourceType":"module"}