{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { isObject } from 'vega-util';\nimport { isBinned } from '../bin';\nimport { getMainRangeChannel, SECONDARY_RANGE_CHANNEL } from '../channel';\nimport { isDatumDef, isFieldDef } from '../channeldef';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { isUnitSpec } from '../spec/unit';\nexport var RuleForRangedLineNormalizer = /*#__PURE__*/function () {\n  function RuleForRangedLineNormalizer() {\n    _classCallCheck(this, RuleForRangedLineNormalizer);\n    this.name = 'RuleForRangedLine';\n  }\n  _createClass(RuleForRangedLineNormalizer, [{\n    key: \"hasMatchingType\",\n    value: function hasMatchingType(spec) {\n      if (isUnitSpec(spec)) {\n        var encoding = spec.encoding,\n          mark = spec.mark;\n        if (mark === 'line' || isMarkDef(mark) && mark.type === 'line') {\n          var _iterator = _createForOfIteratorHelper(SECONDARY_RANGE_CHANNEL),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var channel = _step.value;\n              var mainChannel = getMainRangeChannel(channel);\n              var mainChannelDef = encoding[mainChannel];\n              if (encoding[channel]) {\n                if (isFieldDef(mainChannelDef) && !isBinned(mainChannelDef.bin) || isDatumDef(mainChannelDef)) {\n                  return true;\n                }\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"run\",\n    value: function run(spec, params, normalize) {\n      var encoding = spec.encoding,\n        mark = spec.mark;\n      log.warn(log.message.lineWithRange(!!encoding.x2, !!encoding.y2));\n      return normalize(Object.assign(Object.assign({}, spec), {\n        mark: isObject(mark) ? Object.assign(Object.assign({}, mark), {\n          type: 'rule'\n        }) : 'rule'\n      }), params);\n    }\n  }]);\n  return RuleForRangedLineNormalizer;\n}();","map":{"version":3,"sources":["../../../src/normalize/ruleforrangedline.ts"],"names":[],"mappings":";;;AAAA,SAAQ,QAAQ,QAAO,WAAW;AAClC,SAAQ,QAAQ,QAAO,QAAQ;AAC/B,SAAQ,mBAAmB,EAAE,uBAAuB,QAAO,YAAY;AACvE,SAAe,UAAU,EAAE,UAAU,QAAO,eAAe;AAE3D,OAAO,KAAK,GAAG,MAAM,QAAQ;AAC7B,SAAQ,SAAS,QAAO,SAAS;AAEjC,SAAyB,UAAU,QAAO,cAAc;AAaxD,WAAa,2BAA2B;EAAxC,uCAAA;IAAA;IACS,IAAA,CAAA,IAAI,GAAG,mBAAmB;EAiCnC;EAAC;IAAA;IAAA,OA/BQ,yBAAgB,IAAqC,EAAA;MAC1D,IAAI,UAAU,CAAC,IAAI,CAAC,EAAE;QACpB,IAAO,QAAQ,GAAU,IAAI,CAAtB,QAAQ;UAAE,IAAI,GAAI,IAAI,CAAZ,IAAI;QACrB,IAAI,IAAI,KAAK,MAAM,IAAK,SAAS,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,KAAK,MAAO,EAAE;UAAA,2CAC1C,uBAAuB;YAAA;UAAA;YAA7C,oDAA+C;cAAA,IAApC,OAAO;cAChB,IAAM,WAAW,GAAG,mBAAmB,CAAC,OAAO,CAAC;cAChD,IAAM,cAAc,GAAG,QAAQ,CAAC,WAAW,CAAC;cAE5C,IAAI,QAAQ,CAAC,OAAO,CAAC,EAAE;gBACrB,IAAK,UAAU,CAAC,cAAc,CAAC,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,GAAG,CAAC,IAAK,UAAU,CAAC,cAAc,CAAC,EAAE;kBAC/F,OAAO,IAAI;gBACZ;cACF;;UACF;YAAA;UAAA;YAAA;UAAA;QACF;MACF;MACD,OAAO,KAAK;IACd;EAAC;IAAA;IAAA,OAEM,aAAI,IAAoB,EAAE,MAAwB,EAAE,SAA+B,EAAA;MACxF,IAAO,QAAQ,GAAU,IAAI,CAAtB,QAAQ;QAAE,IAAI,GAAI,IAAI,CAAZ,IAAI;MACrB,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;MAEjE,OAAO,SAAS,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAET,IAAI,CAAA,EAAA;QACP,IAAI,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAE,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAK,IAAI,CAAA,EAAA;UAAE,IAAI,EAAE;QAAM,CAAA,CAAA,GAAI;MAAM,CAAA,CAAA,EAEzD,MAAM,CACP;IACH;EAAC;EAAA;AAAA","sourceRoot":"","sourcesContent":["import { isObject } from 'vega-util';\nimport { isBinned } from '../bin';\nimport { getMainRangeChannel, SECONDARY_RANGE_CHANNEL } from '../channel';\nimport { isDatumDef, isFieldDef } from '../channeldef';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { isUnitSpec } from '../spec/unit';\nexport class RuleForRangedLineNormalizer {\n    constructor() {\n        this.name = 'RuleForRangedLine';\n    }\n    hasMatchingType(spec) {\n        if (isUnitSpec(spec)) {\n            const { encoding, mark } = spec;\n            if (mark === 'line' || (isMarkDef(mark) && mark.type === 'line')) {\n                for (const channel of SECONDARY_RANGE_CHANNEL) {\n                    const mainChannel = getMainRangeChannel(channel);\n                    const mainChannelDef = encoding[mainChannel];\n                    if (encoding[channel]) {\n                        if ((isFieldDef(mainChannelDef) && !isBinned(mainChannelDef.bin)) || isDatumDef(mainChannelDef)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    run(spec, params, normalize) {\n        const { encoding, mark } = spec;\n        log.warn(log.message.lineWithRange(!!encoding.x2, !!encoding.y2));\n        return normalize(Object.assign(Object.assign({}, spec), { mark: isObject(mark) ? Object.assign(Object.assign({}, mark), { type: 'rule' }) : 'rule' }), params);\n    }\n}\n//# sourceMappingURL=ruleforrangedline.js.map"]},"metadata":{},"sourceType":"module"}