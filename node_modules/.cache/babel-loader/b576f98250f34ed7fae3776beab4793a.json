{"ast":null,"code":"import { stringValue } from 'vega-util';\nimport { disableDirectManipulation, TUPLE } from '.';\nimport { varName } from '../../util';\nimport { assembleInit } from './assemble';\nimport nearest from './nearest';\nimport { TUPLE_FIELDS } from './project';\nimport { isLegendBinding } from '../../selection';\nvar inputBindings = {\n  defined: function defined(selCmpt) {\n    return selCmpt.type === 'point' && selCmpt.resolve === 'global' && selCmpt.bind && selCmpt.bind !== 'scales' && !isLegendBinding(selCmpt.bind);\n  },\n  parse: function parse(model, selCmpt, selDef) {\n    return disableDirectManipulation(selCmpt, selDef);\n  },\n  topLevelSignals: function topLevelSignals(model, selCmpt, signals) {\n    var name = selCmpt.name;\n    var proj = selCmpt.project;\n    var bind = selCmpt.bind;\n    var init = selCmpt.init && selCmpt.init[0]; // Can only exist on single selections (one initial value).\n    var datum = nearest.defined(selCmpt) ? '(item().isVoronoi ? datum.datum : datum)' : 'datum';\n    proj.items.forEach(function (p, i) {\n      var _a, _b;\n      var sgname = varName(\"\".concat(name, \"_\").concat(p.field));\n      var hasSignal = signals.filter(function (s) {\n        return s.name === sgname;\n      });\n      if (!hasSignal.length) {\n        signals.unshift(Object.assign(Object.assign({\n          name: sgname\n        }, init ? {\n          init: assembleInit(init[i])\n        } : {\n          value: null\n        }), {\n          on: selCmpt.events ? [{\n            events: selCmpt.events,\n            update: \"datum && item().mark.marktype !== 'group' ? \".concat(datum, \"[\").concat(stringValue(p.field), \"] : null\")\n          }] : [],\n          bind: (_b = (_a = bind[p.field]) !== null && _a !== void 0 ? _a : bind[p.channel]) !== null && _b !== void 0 ? _b : bind\n        }));\n      }\n    });\n    return signals;\n  },\n  signals: function signals(model, selCmpt, _signals) {\n    var name = selCmpt.name;\n    var proj = selCmpt.project;\n    var signal = _signals.filter(function (s) {\n      return s.name === name + TUPLE;\n    })[0];\n    var fields = name + TUPLE_FIELDS;\n    var values = proj.items.map(function (p) {\n      return varName(\"\".concat(name, \"_\").concat(p.field));\n    });\n    var valid = values.map(function (v) {\n      return \"\".concat(v, \" !== null\");\n    }).join(' && ');\n    if (values.length) {\n      signal.update = \"\".concat(valid, \" ? {fields: \").concat(fields, \", values: [\").concat(values.join(', '), \"]} : null\");\n    }\n    delete signal.value;\n    delete signal.on;\n    return _signals;\n  }\n};\nexport default inputBindings;","map":{"version":3,"sources":["../../../../src/compile/selection/inputs.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { stringValue } from 'vega-util';\nimport { disableDirectManipulation, TUPLE } from '.';\nimport { varName } from '../../util';\nimport { assembleInit } from './assemble';\nimport nearest from './nearest';\nimport { TUPLE_FIELDS } from './project';\nimport { isLegendBinding } from '../../selection';\nconst inputBindings = {\n    defined: selCmpt => {\n        return (selCmpt.type === 'point' &&\n            selCmpt.resolve === 'global' &&\n            selCmpt.bind &&\n            selCmpt.bind !== 'scales' &&\n            !isLegendBinding(selCmpt.bind));\n    },\n    parse: (model, selCmpt, selDef) => disableDirectManipulation(selCmpt, selDef),\n    topLevelSignals: (model, selCmpt, signals) => {\n        const name = selCmpt.name;\n        const proj = selCmpt.project;\n        const bind = selCmpt.bind;\n        const init = selCmpt.init && selCmpt.init[0]; // Can only exist on single selections (one initial value).\n        const datum = nearest.defined(selCmpt) ? '(item().isVoronoi ? datum.datum : datum)' : 'datum';\n        proj.items.forEach((p, i) => {\n            var _a, _b;\n            const sgname = varName(`${name}_${p.field}`);\n            const hasSignal = signals.filter(s => s.name === sgname);\n            if (!hasSignal.length) {\n                signals.unshift(Object.assign(Object.assign({ name: sgname }, (init ? { init: assembleInit(init[i]) } : { value: null })), { on: selCmpt.events\n                        ? [\n                            {\n                                events: selCmpt.events,\n                                update: `datum && item().mark.marktype !== 'group' ? ${datum}[${stringValue(p.field)}] : null`\n                            }\n                        ]\n                        : [], bind: (_b = (_a = bind[p.field]) !== null && _a !== void 0 ? _a : bind[p.channel]) !== null && _b !== void 0 ? _b : bind }));\n            }\n        });\n        return signals;\n    },\n    signals: (model, selCmpt, signals) => {\n        const name = selCmpt.name;\n        const proj = selCmpt.project;\n        const signal = signals.filter(s => s.name === name + TUPLE)[0];\n        const fields = name + TUPLE_FIELDS;\n        const values = proj.items.map(p => varName(`${name}_${p.field}`));\n        const valid = values.map(v => `${v} !== null`).join(' && ');\n        if (values.length) {\n            signal.update = `${valid} ? {fields: ${fields}, values: [${values.join(', ')}]} : null`;\n        }\n        delete signal.value;\n        delete signal.on;\n        return signals;\n    }\n};\nexport default inputBindings;\n//# sourceMappingURL=inputs.js.map"]},"metadata":{},"sourceType":"module"}