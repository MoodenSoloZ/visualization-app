{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { valueExpr, vgField } from './channeldef';\nimport { fieldExpr as timeUnitFieldExpr, normalizeTimeUnit } from './timeunit';\nimport { stringify } from './util';\nimport { isSignalRef } from './vega.schema';\nexport function isSelectionPredicate(predicate) {\n  return predicate === null || predicate === void 0 ? void 0 : predicate['param'];\n}\nexport function isFieldEqualPredicate(predicate) {\n  return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && predicate.equal !== undefined;\n}\nexport function isFieldLTPredicate(predicate) {\n  return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && predicate.lt !== undefined;\n}\nexport function isFieldLTEPredicate(predicate) {\n  return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && predicate.lte !== undefined;\n}\nexport function isFieldGTPredicate(predicate) {\n  return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && predicate.gt !== undefined;\n}\nexport function isFieldGTEPredicate(predicate) {\n  return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && predicate.gte !== undefined;\n}\nexport function isFieldRangePredicate(predicate) {\n  if (predicate === null || predicate === void 0 ? void 0 : predicate.field) {\n    if (isArray(predicate.range) && predicate.range.length === 2) {\n      return true;\n    } else if (isSignalRef(predicate.range)) {\n      return true;\n    }\n  }\n  return false;\n}\nexport function isFieldOneOfPredicate(predicate) {\n  return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && (isArray(predicate.oneOf) || isArray(predicate.in)) // backward compatibility\n  ;\n}\n\nexport function isFieldValidPredicate(predicate) {\n  return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && predicate.valid !== undefined;\n}\nexport function isFieldPredicate(predicate) {\n  return isFieldOneOfPredicate(predicate) || isFieldEqualPredicate(predicate) || isFieldRangePredicate(predicate) || isFieldLTPredicate(predicate) || isFieldGTPredicate(predicate) || isFieldLTEPredicate(predicate) || isFieldGTEPredicate(predicate);\n}\nfunction predicateValueExpr(v, timeUnit) {\n  return valueExpr(v, {\n    timeUnit: timeUnit,\n    wrapTime: true\n  });\n}\nfunction predicateValuesExpr(vals, timeUnit) {\n  return vals.map(function (v) {\n    return predicateValueExpr(v, timeUnit);\n  });\n}\n// This method is used by Voyager. Do not change its behavior without changing Voyager.\nexport function fieldFilterExpression(predicate) {\n  var useInRange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var _a;\n  var field = predicate.field;\n  var timeUnit = (_a = normalizeTimeUnit(predicate.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit;\n  var fieldExpr = timeUnit ? // For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.\n  // TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline\n  // TODO: support utc\n  \"time(\".concat(timeUnitFieldExpr(timeUnit, field), \")\") : vgField(predicate, {\n    expr: 'datum'\n  });\n  if (isFieldEqualPredicate(predicate)) {\n    return \"\".concat(fieldExpr, \"===\").concat(predicateValueExpr(predicate.equal, timeUnit));\n  } else if (isFieldLTPredicate(predicate)) {\n    var upper = predicate.lt;\n    return \"\".concat(fieldExpr, \"<\").concat(predicateValueExpr(upper, timeUnit));\n  } else if (isFieldGTPredicate(predicate)) {\n    var lower = predicate.gt;\n    return \"\".concat(fieldExpr, \">\").concat(predicateValueExpr(lower, timeUnit));\n  } else if (isFieldLTEPredicate(predicate)) {\n    var _upper = predicate.lte;\n    return \"\".concat(fieldExpr, \"<=\").concat(predicateValueExpr(_upper, timeUnit));\n  } else if (isFieldGTEPredicate(predicate)) {\n    var _lower = predicate.gte;\n    return \"\".concat(fieldExpr, \">=\").concat(predicateValueExpr(_lower, timeUnit));\n  } else if (isFieldOneOfPredicate(predicate)) {\n    return \"indexof([\".concat(predicateValuesExpr(predicate.oneOf, timeUnit).join(','), \"], \").concat(fieldExpr, \") !== -1\");\n  } else if (isFieldValidPredicate(predicate)) {\n    return fieldValidPredicate(fieldExpr, predicate.valid);\n  } else if (isFieldRangePredicate(predicate)) {\n    var range = predicate.range;\n    var _lower2 = isSignalRef(range) ? {\n      signal: \"\".concat(range.signal, \"[0]\")\n    } : range[0];\n    var _upper2 = isSignalRef(range) ? {\n      signal: \"\".concat(range.signal, \"[1]\")\n    } : range[1];\n    if (_lower2 !== null && _upper2 !== null && useInRange) {\n      return 'inrange(' + fieldExpr + ', [' + predicateValueExpr(_lower2, timeUnit) + ', ' + predicateValueExpr(_upper2, timeUnit) + '])';\n    }\n    var exprs = [];\n    if (_lower2 !== null) {\n      exprs.push(\"\".concat(fieldExpr, \" >= \").concat(predicateValueExpr(_lower2, timeUnit)));\n    }\n    if (_upper2 !== null) {\n      exprs.push(\"\".concat(fieldExpr, \" <= \").concat(predicateValueExpr(_upper2, timeUnit)));\n    }\n    return exprs.length > 0 ? exprs.join(' && ') : 'true';\n  }\n  /* istanbul ignore next: it should never reach here */\n  throw new Error(\"Invalid field predicate: \".concat(stringify(predicate)));\n}\nexport function fieldValidPredicate(fieldExpr) {\n  var valid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (valid) {\n    return \"isValid(\".concat(fieldExpr, \") && isFinite(+\").concat(fieldExpr, \")\");\n  } else {\n    return \"!isValid(\".concat(fieldExpr, \") || !isFinite(+\").concat(fieldExpr, \")\");\n  }\n}\nexport function normalizePredicate(f) {\n  var _a;\n  if (isFieldPredicate(f) && f.timeUnit) {\n    return Object.assign(Object.assign({}, f), {\n      timeUnit: (_a = normalizeTimeUnit(f.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit\n    });\n  }\n  return f;\n}","map":{"version":3,"sources":["../../src/predicate.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray } from 'vega-util';\nimport { valueExpr, vgField } from './channeldef';\nimport { fieldExpr as timeUnitFieldExpr, normalizeTimeUnit } from './timeunit';\nimport { stringify } from './util';\nimport { isSignalRef } from './vega.schema';\nexport function isSelectionPredicate(predicate) {\n    return predicate === null || predicate === void 0 ? void 0 : predicate['param'];\n}\nexport function isFieldEqualPredicate(predicate) {\n    return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && predicate.equal !== undefined;\n}\nexport function isFieldLTPredicate(predicate) {\n    return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && predicate.lt !== undefined;\n}\nexport function isFieldLTEPredicate(predicate) {\n    return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && predicate.lte !== undefined;\n}\nexport function isFieldGTPredicate(predicate) {\n    return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && predicate.gt !== undefined;\n}\nexport function isFieldGTEPredicate(predicate) {\n    return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && predicate.gte !== undefined;\n}\nexport function isFieldRangePredicate(predicate) {\n    if (predicate === null || predicate === void 0 ? void 0 : predicate.field) {\n        if (isArray(predicate.range) && predicate.range.length === 2) {\n            return true;\n        }\n        else if (isSignalRef(predicate.range)) {\n            return true;\n        }\n    }\n    return false;\n}\nexport function isFieldOneOfPredicate(predicate) {\n    return (!!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && (isArray(predicate.oneOf) || isArray(predicate.in)) // backward compatibility\n    );\n}\nexport function isFieldValidPredicate(predicate) {\n    return !!(predicate === null || predicate === void 0 ? void 0 : predicate.field) && predicate.valid !== undefined;\n}\nexport function isFieldPredicate(predicate) {\n    return (isFieldOneOfPredicate(predicate) ||\n        isFieldEqualPredicate(predicate) ||\n        isFieldRangePredicate(predicate) ||\n        isFieldLTPredicate(predicate) ||\n        isFieldGTPredicate(predicate) ||\n        isFieldLTEPredicate(predicate) ||\n        isFieldGTEPredicate(predicate));\n}\nfunction predicateValueExpr(v, timeUnit) {\n    return valueExpr(v, { timeUnit, wrapTime: true });\n}\nfunction predicateValuesExpr(vals, timeUnit) {\n    return vals.map(v => predicateValueExpr(v, timeUnit));\n}\n// This method is used by Voyager. Do not change its behavior without changing Voyager.\nexport function fieldFilterExpression(predicate, useInRange = true) {\n    var _a;\n    const { field } = predicate;\n    const timeUnit = (_a = normalizeTimeUnit(predicate.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit;\n    const fieldExpr = timeUnit\n        ? // For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.\n            // TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline\n            // TODO: support utc\n            `time(${timeUnitFieldExpr(timeUnit, field)})`\n        : vgField(predicate, { expr: 'datum' });\n    if (isFieldEqualPredicate(predicate)) {\n        return `${fieldExpr}===${predicateValueExpr(predicate.equal, timeUnit)}`;\n    }\n    else if (isFieldLTPredicate(predicate)) {\n        const upper = predicate.lt;\n        return `${fieldExpr}<${predicateValueExpr(upper, timeUnit)}`;\n    }\n    else if (isFieldGTPredicate(predicate)) {\n        const lower = predicate.gt;\n        return `${fieldExpr}>${predicateValueExpr(lower, timeUnit)}`;\n    }\n    else if (isFieldLTEPredicate(predicate)) {\n        const upper = predicate.lte;\n        return `${fieldExpr}<=${predicateValueExpr(upper, timeUnit)}`;\n    }\n    else if (isFieldGTEPredicate(predicate)) {\n        const lower = predicate.gte;\n        return `${fieldExpr}>=${predicateValueExpr(lower, timeUnit)}`;\n    }\n    else if (isFieldOneOfPredicate(predicate)) {\n        return `indexof([${predicateValuesExpr(predicate.oneOf, timeUnit).join(',')}], ${fieldExpr}) !== -1`;\n    }\n    else if (isFieldValidPredicate(predicate)) {\n        return fieldValidPredicate(fieldExpr, predicate.valid);\n    }\n    else if (isFieldRangePredicate(predicate)) {\n        const { range } = predicate;\n        const lower = isSignalRef(range) ? { signal: `${range.signal}[0]` } : range[0];\n        const upper = isSignalRef(range) ? { signal: `${range.signal}[1]` } : range[1];\n        if (lower !== null && upper !== null && useInRange) {\n            return ('inrange(' +\n                fieldExpr +\n                ', [' +\n                predicateValueExpr(lower, timeUnit) +\n                ', ' +\n                predicateValueExpr(upper, timeUnit) +\n                '])');\n        }\n        const exprs = [];\n        if (lower !== null) {\n            exprs.push(`${fieldExpr} >= ${predicateValueExpr(lower, timeUnit)}`);\n        }\n        if (upper !== null) {\n            exprs.push(`${fieldExpr} <= ${predicateValueExpr(upper, timeUnit)}`);\n        }\n        return exprs.length > 0 ? exprs.join(' && ') : 'true';\n    }\n    /* istanbul ignore next: it should never reach here */\n    throw new Error(`Invalid field predicate: ${stringify(predicate)}`);\n}\nexport function fieldValidPredicate(fieldExpr, valid = true) {\n    if (valid) {\n        return `isValid(${fieldExpr}) && isFinite(+${fieldExpr})`;\n    }\n    else {\n        return `!isValid(${fieldExpr}) || !isFinite(+${fieldExpr})`;\n    }\n}\nexport function normalizePredicate(f) {\n    var _a;\n    if (isFieldPredicate(f) && f.timeUnit) {\n        return Object.assign(Object.assign({}, f), { timeUnit: (_a = normalizeTimeUnit(f.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit });\n    }\n    return f;\n}\n//# sourceMappingURL=predicate.js.map"]},"metadata":{},"sourceType":"module"}