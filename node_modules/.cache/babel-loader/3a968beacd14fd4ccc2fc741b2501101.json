{"ast":null,"code":"import _classCallCheck from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n/**\n * Based on <https://raw.githubusercontent.com/zenparsing/zen-observable/master/src/Observable.js>\n * At commit: f63849a8c60af5d514efc8e9d6138d8273c49ad6\n */\nimport \"./symbols\";\nimport { getSymbol, hasSymbol, hasSymbols } from \"./_symbols\";\nvar SymbolIterator = getSymbol(\"iterator\");\nvar SymbolObservable = getSymbol(\"observable\");\nvar SymbolSpecies = getSymbol(\"species\");\n// === Abstract Operations ===\nfunction getMethod(obj, key) {\n  var value = obj[key];\n  if (value == null) {\n    return undefined;\n  }\n  if (typeof value !== \"function\") {\n    throw new TypeError(value + \" is not a function\");\n  }\n  return value;\n}\nfunction getSpecies(obj) {\n  var ctor = obj.constructor;\n  if (ctor !== undefined) {\n    ctor = ctor[SymbolSpecies];\n    if (ctor === null) {\n      ctor = undefined;\n    }\n  }\n  return ctor !== undefined ? ctor : Observable;\n}\nfunction isObservable(x) {\n  return x instanceof Observable; // SPEC: Brand check\n}\n\nfunction hostReportError(error) {\n  if (hostReportError.log) {\n    hostReportError.log(error);\n  } else {\n    setTimeout(function () {\n      throw error;\n    }, 0);\n  }\n}\nfunction enqueue(fn) {\n  Promise.resolve().then(function () {\n    try {\n      fn();\n    } catch (e) {\n      hostReportError(e);\n    }\n  });\n}\nfunction cleanupSubscription(subscription) {\n  var cleanup = subscription._cleanup;\n  if (cleanup === undefined) {\n    return;\n  }\n  subscription._cleanup = undefined;\n  if (!cleanup) {\n    return;\n  }\n  try {\n    if (typeof cleanup === \"function\") {\n      cleanup();\n    } else {\n      var unsubscribe = getMethod(cleanup, \"unsubscribe\");\n      if (unsubscribe) {\n        unsubscribe.call(cleanup);\n      }\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n}\nfunction closeSubscription(subscription) {\n  subscription._observer = undefined;\n  subscription._queue = undefined;\n  subscription._state = \"closed\";\n}\nfunction flushSubscription(subscription) {\n  var queue = subscription._queue;\n  if (!queue) {\n    return;\n  }\n  subscription._queue = undefined;\n  subscription._state = \"ready\";\n  var _iterator = _createForOfIteratorHelper(queue),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n      notifySubscription(subscription, item.type, item.value);\n      if (subscription._state === \"closed\") {\n        break;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nfunction notifySubscription(subscription, type, value) {\n  subscription._state = \"running\";\n  var observer = subscription._observer;\n  try {\n    var m = observer ? getMethod(observer, type) : undefined;\n    switch (type) {\n      case \"next\":\n        if (m) m.call(observer, value);\n        break;\n      case \"error\":\n        closeSubscription(subscription);\n        if (m) m.call(observer, value);else throw value;\n        break;\n      case \"complete\":\n        closeSubscription(subscription);\n        if (m) m.call(observer);\n        break;\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n  if (subscription._state === \"closed\") {\n    cleanupSubscription(subscription);\n  } else if (subscription._state === \"running\") {\n    subscription._state = \"ready\";\n  }\n}\nfunction onNotify(subscription, type, value) {\n  if (subscription._state === \"closed\") {\n    return;\n  }\n  if (subscription._state === \"buffering\") {\n    subscription._queue = subscription._queue || [];\n    subscription._queue.push({\n      type: type,\n      value: value\n    });\n    return;\n  }\n  if (subscription._state !== \"ready\") {\n    subscription._state = \"buffering\";\n    subscription._queue = [{\n      type: type,\n      value: value\n    }];\n    enqueue(function () {\n      return flushSubscription(subscription);\n    });\n    return;\n  }\n  notifySubscription(subscription, type, value);\n}\nexport var Subscription = /*#__PURE__*/function () {\n  function Subscription(observer, subscriber) {\n    _classCallCheck(this, Subscription);\n    // ASSERT: observer is an object\n    // ASSERT: subscriber is callable\n    this._cleanup = undefined;\n    this._observer = observer;\n    this._queue = undefined;\n    this._state = \"initializing\";\n    var subscriptionObserver = new SubscriptionObserver(this);\n    try {\n      this._cleanup = subscriber.call(undefined, subscriptionObserver);\n    } catch (e) {\n      subscriptionObserver.error(e);\n    }\n    if (this._state === \"initializing\") {\n      this._state = \"ready\";\n    }\n  }\n  _createClass(Subscription, [{\n    key: \"closed\",\n    get: function get() {\n      return this._state === \"closed\";\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      if (this._state !== \"closed\") {\n        closeSubscription(this);\n        cleanupSubscription(this);\n      }\n    }\n  }]);\n  return Subscription;\n}();\nexport var SubscriptionObserver = /*#__PURE__*/function () {\n  function SubscriptionObserver(subscription) {\n    _classCallCheck(this, SubscriptionObserver);\n    this._subscription = subscription;\n  }\n  _createClass(SubscriptionObserver, [{\n    key: \"closed\",\n    get: function get() {\n      return this._subscription._state === \"closed\";\n    }\n  }, {\n    key: \"next\",\n    value: function next(value) {\n      onNotify(this._subscription, \"next\", value);\n    }\n  }, {\n    key: \"error\",\n    value: function error(value) {\n      onNotify(this._subscription, \"error\", value);\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      onNotify(this._subscription, \"complete\");\n    }\n  }]);\n  return SubscriptionObserver;\n}();\n/**\n * The basic Observable class. This primitive is used to wrap asynchronous\n * data streams in a common standardized data type that is interoperable\n * between libraries and can be composed to represent more complex processes.\n */\nexport var Observable = /*#__PURE__*/function (_ref) {\n  function Observable(subscriber) {\n    _classCallCheck(this, Observable);\n    if (!(this instanceof Observable)) {\n      throw new TypeError(\"Observable cannot be called as a function\");\n    }\n    if (typeof subscriber !== \"function\") {\n      throw new TypeError(\"Observable initializer must be a function\");\n    }\n    this._subscriber = subscriber;\n  }\n  _createClass(Observable, [{\n    key: \"subscribe\",\n    value: function subscribe(nextOrObserver, onError, onComplete) {\n      if (typeof nextOrObserver !== \"object\" || nextOrObserver === null) {\n        nextOrObserver = {\n          next: nextOrObserver,\n          error: onError,\n          complete: onComplete\n        };\n      }\n      return new Subscription(nextOrObserver, this._subscriber);\n    }\n  }, {\n    key: \"pipe\",\n    value: function pipe(first) {\n      // tslint:disable-next-line no-this-assignment\n      var intermediate = this;\n      for (var _len = arguments.length, mappers = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        mappers[_key - 1] = arguments[_key];\n      }\n      for (var _i = 0, _arr = [first].concat(mappers); _i < _arr.length; _i++) {\n        var mapper = _arr[_i];\n        intermediate = mapper(intermediate);\n      }\n      return intermediate;\n    }\n  }, {\n    key: \"tap\",\n    value: function tap(nextOrObserver, onError, onComplete) {\n      var _this = this;\n      var tapObserver = typeof nextOrObserver !== \"object\" || nextOrObserver === null ? {\n        next: nextOrObserver,\n        error: onError,\n        complete: onComplete\n      } : nextOrObserver;\n      return new Observable(function (observer) {\n        return _this.subscribe({\n          next: function next(value) {\n            tapObserver.next && tapObserver.next(value);\n            observer.next(value);\n          },\n          error: function error(_error) {\n            tapObserver.error && tapObserver.error(_error);\n            observer.error(_error);\n          },\n          complete: function complete() {\n            tapObserver.complete && tapObserver.complete();\n            observer.complete();\n          },\n          start: function start(subscription) {\n            tapObserver.start && tapObserver.start(subscription);\n          }\n        });\n      });\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(fn) {\n      var _this2 = this;\n      return new Promise(function (resolve, reject) {\n        if (typeof fn !== \"function\") {\n          reject(new TypeError(fn + \" is not a function\"));\n          return;\n        }\n        function done() {\n          subscription.unsubscribe();\n          resolve(undefined);\n        }\n        var subscription = _this2.subscribe({\n          next: function next(value) {\n            try {\n              fn(value, done);\n            } catch (e) {\n              reject(e);\n              subscription.unsubscribe();\n            }\n          },\n          error: function error(_error2) {\n            reject(_error2);\n          },\n          complete: function complete() {\n            resolve(undefined);\n          }\n        });\n      });\n    }\n  }, {\n    key: \"map\",\n    value: function map(fn) {\n      var _this3 = this;\n      if (typeof fn !== \"function\") {\n        throw new TypeError(fn + \" is not a function\");\n      }\n      var C = getSpecies(this);\n      return new C(function (observer) {\n        return _this3.subscribe({\n          next: function next(value) {\n            var propagatedValue = value;\n            try {\n              propagatedValue = fn(value);\n            } catch (e) {\n              return observer.error(e);\n            }\n            observer.next(propagatedValue);\n          },\n          error: function error(e) {\n            observer.error(e);\n          },\n          complete: function complete() {\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(fn) {\n      var _this4 = this;\n      if (typeof fn !== \"function\") {\n        throw new TypeError(fn + \" is not a function\");\n      }\n      var C = getSpecies(this);\n      return new C(function (observer) {\n        return _this4.subscribe({\n          next: function next(value) {\n            try {\n              if (!fn(value)) return;\n            } catch (e) {\n              return observer.error(e);\n            }\n            observer.next(value);\n          },\n          error: function error(e) {\n            observer.error(e);\n          },\n          complete: function complete() {\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: \"reduce\",\n    value: function reduce(fn, seed) {\n      var _this5 = this;\n      if (typeof fn !== \"function\") {\n        throw new TypeError(fn + \" is not a function\");\n      }\n      var C = getSpecies(this);\n      var hasSeed = arguments.length > 1;\n      var hasValue = false;\n      var acc = seed;\n      return new C(function (observer) {\n        return _this5.subscribe({\n          next: function next(value) {\n            var first = !hasValue;\n            hasValue = true;\n            if (!first || hasSeed) {\n              try {\n                acc = fn(acc, value);\n              } catch (e) {\n                return observer.error(e);\n              }\n            } else {\n              acc = value;\n            }\n          },\n          error: function error(e) {\n            observer.error(e);\n          },\n          complete: function complete() {\n            if (!hasValue && !hasSeed) {\n              return observer.error(new TypeError(\"Cannot reduce an empty sequence\"));\n            }\n            observer.next(acc);\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: \"concat\",\n    value: function concat() {\n      var _this6 = this;\n      for (var _len2 = arguments.length, sources = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        sources[_key2] = arguments[_key2];\n      }\n      var C = getSpecies(this);\n      return new C(function (observer) {\n        var subscription;\n        var index = 0;\n        function startNext(next) {\n          subscription = next.subscribe({\n            next: function next(v) {\n              observer.next(v);\n            },\n            error: function error(e) {\n              observer.error(e);\n            },\n            complete: function complete() {\n              if (index === sources.length) {\n                subscription = undefined;\n                observer.complete();\n              } else {\n                startNext(C.from(sources[index++]));\n              }\n            }\n          });\n        }\n        startNext(_this6);\n        return function () {\n          if (subscription) {\n            subscription.unsubscribe();\n            subscription = undefined;\n          }\n        };\n      });\n    }\n  }, {\n    key: \"flatMap\",\n    value: function flatMap(fn) {\n      var _this7 = this;\n      if (typeof fn !== \"function\") {\n        throw new TypeError(fn + \" is not a function\");\n      }\n      var C = getSpecies(this);\n      return new C(function (observer) {\n        var subscriptions = [];\n        var outer = _this7.subscribe({\n          next: function next(value) {\n            var normalizedValue;\n            if (fn) {\n              try {\n                normalizedValue = fn(value);\n              } catch (e) {\n                return observer.error(e);\n              }\n            } else {\n              normalizedValue = value;\n            }\n            var inner = C.from(normalizedValue).subscribe({\n              next: function next(innerValue) {\n                observer.next(innerValue);\n              },\n              error: function error(e) {\n                observer.error(e);\n              },\n              complete: function complete() {\n                var i = subscriptions.indexOf(inner);\n                if (i >= 0) subscriptions.splice(i, 1);\n                completeIfDone();\n              }\n            });\n            subscriptions.push(inner);\n          },\n          error: function error(e) {\n            observer.error(e);\n          },\n          complete: function complete() {\n            completeIfDone();\n          }\n        });\n        function completeIfDone() {\n          if (outer.closed && subscriptions.length === 0) {\n            observer.complete();\n          }\n        }\n        return function () {\n          subscriptions.forEach(function (s) {\n            return s.unsubscribe();\n          });\n          outer.unsubscribe();\n        };\n      });\n    }\n  }, {\n    key: _ref,\n    value: function value() {\n      return this;\n    }\n  }], [{\n    key: \"from\",\n    value: function from(x) {\n      var C = typeof this === \"function\" ? this : Observable;\n      if (x == null) {\n        throw new TypeError(x + \" is not an object\");\n      }\n      var observableMethod = getMethod(x, SymbolObservable);\n      if (observableMethod) {\n        var observable = observableMethod.call(x);\n        if (Object(observable) !== observable) {\n          throw new TypeError(observable + \" is not an object\");\n        }\n        if (isObservable(observable) && observable.constructor === C) {\n          return observable;\n        }\n        return new C(function (observer) {\n          return observable.subscribe(observer);\n        });\n      }\n      if (hasSymbol(\"iterator\")) {\n        var iteratorMethod = getMethod(x, SymbolIterator);\n        if (iteratorMethod) {\n          return new C(function (observer) {\n            enqueue(function () {\n              if (observer.closed) return;\n              var _iterator2 = _createForOfIteratorHelper(iteratorMethod.call(x)),\n                _step2;\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  var item = _step2.value;\n                  observer.next(item);\n                  if (observer.closed) return;\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n              observer.complete();\n            });\n          });\n        }\n      }\n      if (Array.isArray(x)) {\n        return new C(function (observer) {\n          enqueue(function () {\n            if (observer.closed) return;\n            var _iterator3 = _createForOfIteratorHelper(x),\n              _step3;\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var item = _step3.value;\n                observer.next(item);\n                if (observer.closed) return;\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n            observer.complete();\n          });\n        });\n      }\n      throw new TypeError(x + \" is not observable\");\n    }\n  }, {\n    key: \"of\",\n    value: function of() {\n      for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        items[_key3] = arguments[_key3];\n      }\n      var C = typeof this === \"function\" ? this : Observable;\n      return new C(function (observer) {\n        enqueue(function () {\n          if (observer.closed) return;\n          var _iterator4 = _createForOfIteratorHelper(items),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var item = _step4.value;\n              observer.next(item);\n              if (observer.closed) return;\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n          observer.complete();\n        });\n      });\n    }\n  }, {\n    key: SymbolSpecies,\n    get: function get() {\n      return this;\n    }\n  }]);\n  return Observable;\n}((Symbol.observable, SymbolObservable));\nif (hasSymbols()) {\n  Object.defineProperty(Observable, Symbol(\"extensions\"), {\n    value: {\n      symbol: SymbolObservable,\n      hostReportError: hostReportError\n    },\n    configurable: true\n  });\n}\nexport default Observable;","map":{"version":3,"names":["getSymbol","hasSymbol","hasSymbols","SymbolIterator","SymbolObservable","SymbolSpecies","getMethod","obj","key","value","undefined","TypeError","getSpecies","ctor","constructor","Observable","isObservable","x","hostReportError","error","log","setTimeout","enqueue","fn","Promise","resolve","then","e","cleanupSubscription","subscription","cleanup","_cleanup","unsubscribe","call","closeSubscription","_observer","_queue","_state","flushSubscription","queue","item","notifySubscription","type","observer","m","onNotify","push","Subscription","subscriber","subscriptionObserver","SubscriptionObserver","_subscription","_subscriber","nextOrObserver","onError","onComplete","next","complete","first","intermediate","mappers","mapper","tapObserver","subscribe","start","reject","done","C","propagatedValue","seed","hasSeed","arguments","length","hasValue","acc","sources","index","startNext","v","from","subscriptions","outer","normalizedValue","inner","innerValue","i","indexOf","splice","completeIfDone","closed","forEach","s","observableMethod","observable","Object","iteratorMethod","Array","isArray","items","Symbol","defineProperty","symbol","configurable"],"sources":["/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/observable-fns/dist.esm/observable.js"],"sourcesContent":["/**\n * Based on <https://raw.githubusercontent.com/zenparsing/zen-observable/master/src/Observable.js>\n * At commit: f63849a8c60af5d514efc8e9d6138d8273c49ad6\n */\nimport \"./symbols\";\nimport { getSymbol, hasSymbol, hasSymbols } from \"./_symbols\";\nconst SymbolIterator = getSymbol(\"iterator\");\nconst SymbolObservable = getSymbol(\"observable\");\nconst SymbolSpecies = getSymbol(\"species\");\n// === Abstract Operations ===\nfunction getMethod(obj, key) {\n    const value = obj[key];\n    if (value == null) {\n        return undefined;\n    }\n    if (typeof value !== \"function\") {\n        throw new TypeError(value + \" is not a function\");\n    }\n    return value;\n}\nfunction getSpecies(obj) {\n    let ctor = obj.constructor;\n    if (ctor !== undefined) {\n        ctor = ctor[SymbolSpecies];\n        if (ctor === null) {\n            ctor = undefined;\n        }\n    }\n    return ctor !== undefined ? ctor : Observable;\n}\nfunction isObservable(x) {\n    return x instanceof Observable; // SPEC: Brand check\n}\nfunction hostReportError(error) {\n    if (hostReportError.log) {\n        hostReportError.log(error);\n    }\n    else {\n        setTimeout(() => { throw error; }, 0);\n    }\n}\nfunction enqueue(fn) {\n    Promise.resolve().then(() => {\n        try {\n            fn();\n        }\n        catch (e) {\n            hostReportError(e);\n        }\n    });\n}\nfunction cleanupSubscription(subscription) {\n    const cleanup = subscription._cleanup;\n    if (cleanup === undefined) {\n        return;\n    }\n    subscription._cleanup = undefined;\n    if (!cleanup) {\n        return;\n    }\n    try {\n        if (typeof cleanup === \"function\") {\n            cleanup();\n        }\n        else {\n            const unsubscribe = getMethod(cleanup, \"unsubscribe\");\n            if (unsubscribe) {\n                unsubscribe.call(cleanup);\n            }\n        }\n    }\n    catch (e) {\n        hostReportError(e);\n    }\n}\nfunction closeSubscription(subscription) {\n    subscription._observer = undefined;\n    subscription._queue = undefined;\n    subscription._state = \"closed\";\n}\nfunction flushSubscription(subscription) {\n    const queue = subscription._queue;\n    if (!queue) {\n        return;\n    }\n    subscription._queue = undefined;\n    subscription._state = \"ready\";\n    for (const item of queue) {\n        notifySubscription(subscription, item.type, item.value);\n        if (subscription._state === \"closed\") {\n            break;\n        }\n    }\n}\nfunction notifySubscription(subscription, type, value) {\n    subscription._state = \"running\";\n    const observer = subscription._observer;\n    try {\n        const m = observer ? getMethod(observer, type) : undefined;\n        switch (type) {\n            case \"next\":\n                if (m)\n                    m.call(observer, value);\n                break;\n            case \"error\":\n                closeSubscription(subscription);\n                if (m)\n                    m.call(observer, value);\n                else\n                    throw value;\n                break;\n            case \"complete\":\n                closeSubscription(subscription);\n                if (m)\n                    m.call(observer);\n                break;\n        }\n    }\n    catch (e) {\n        hostReportError(e);\n    }\n    if (subscription._state === \"closed\") {\n        cleanupSubscription(subscription);\n    }\n    else if (subscription._state === \"running\") {\n        subscription._state = \"ready\";\n    }\n}\nfunction onNotify(subscription, type, value) {\n    if (subscription._state === \"closed\") {\n        return;\n    }\n    if (subscription._state === \"buffering\") {\n        subscription._queue = subscription._queue || [];\n        subscription._queue.push({ type, value });\n        return;\n    }\n    if (subscription._state !== \"ready\") {\n        subscription._state = \"buffering\";\n        subscription._queue = [{ type, value }];\n        enqueue(() => flushSubscription(subscription));\n        return;\n    }\n    notifySubscription(subscription, type, value);\n}\nexport class Subscription {\n    constructor(observer, subscriber) {\n        // ASSERT: observer is an object\n        // ASSERT: subscriber is callable\n        this._cleanup = undefined;\n        this._observer = observer;\n        this._queue = undefined;\n        this._state = \"initializing\";\n        const subscriptionObserver = new SubscriptionObserver(this);\n        try {\n            this._cleanup = subscriber.call(undefined, subscriptionObserver);\n        }\n        catch (e) {\n            subscriptionObserver.error(e);\n        }\n        if (this._state === \"initializing\") {\n            this._state = \"ready\";\n        }\n    }\n    get closed() {\n        return this._state === \"closed\";\n    }\n    unsubscribe() {\n        if (this._state !== \"closed\") {\n            closeSubscription(this);\n            cleanupSubscription(this);\n        }\n    }\n}\nexport class SubscriptionObserver {\n    constructor(subscription) { this._subscription = subscription; }\n    get closed() { return this._subscription._state === \"closed\"; }\n    next(value) { onNotify(this._subscription, \"next\", value); }\n    error(value) { onNotify(this._subscription, \"error\", value); }\n    complete() { onNotify(this._subscription, \"complete\"); }\n}\n/**\n * The basic Observable class. This primitive is used to wrap asynchronous\n * data streams in a common standardized data type that is interoperable\n * between libraries and can be composed to represent more complex processes.\n */\nexport class Observable {\n    constructor(subscriber) {\n        if (!(this instanceof Observable)) {\n            throw new TypeError(\"Observable cannot be called as a function\");\n        }\n        if (typeof subscriber !== \"function\") {\n            throw new TypeError(\"Observable initializer must be a function\");\n        }\n        this._subscriber = subscriber;\n    }\n    subscribe(nextOrObserver, onError, onComplete) {\n        if (typeof nextOrObserver !== \"object\" || nextOrObserver === null) {\n            nextOrObserver = {\n                next: nextOrObserver,\n                error: onError,\n                complete: onComplete\n            };\n        }\n        return new Subscription(nextOrObserver, this._subscriber);\n    }\n    pipe(first, ...mappers) {\n        // tslint:disable-next-line no-this-assignment\n        let intermediate = this;\n        for (const mapper of [first, ...mappers]) {\n            intermediate = mapper(intermediate);\n        }\n        return intermediate;\n    }\n    tap(nextOrObserver, onError, onComplete) {\n        const tapObserver = typeof nextOrObserver !== \"object\" || nextOrObserver === null\n            ? {\n                next: nextOrObserver,\n                error: onError,\n                complete: onComplete\n            }\n            : nextOrObserver;\n        return new Observable(observer => {\n            return this.subscribe({\n                next(value) {\n                    tapObserver.next && tapObserver.next(value);\n                    observer.next(value);\n                },\n                error(error) {\n                    tapObserver.error && tapObserver.error(error);\n                    observer.error(error);\n                },\n                complete() {\n                    tapObserver.complete && tapObserver.complete();\n                    observer.complete();\n                },\n                start(subscription) {\n                    tapObserver.start && tapObserver.start(subscription);\n                }\n            });\n        });\n    }\n    forEach(fn) {\n        return new Promise((resolve, reject) => {\n            if (typeof fn !== \"function\") {\n                reject(new TypeError(fn + \" is not a function\"));\n                return;\n            }\n            function done() {\n                subscription.unsubscribe();\n                resolve(undefined);\n            }\n            const subscription = this.subscribe({\n                next(value) {\n                    try {\n                        fn(value, done);\n                    }\n                    catch (e) {\n                        reject(e);\n                        subscription.unsubscribe();\n                    }\n                },\n                error(error) {\n                    reject(error);\n                },\n                complete() {\n                    resolve(undefined);\n                }\n            });\n        });\n    }\n    map(fn) {\n        if (typeof fn !== \"function\") {\n            throw new TypeError(fn + \" is not a function\");\n        }\n        const C = getSpecies(this);\n        return new C(observer => this.subscribe({\n            next(value) {\n                let propagatedValue = value;\n                try {\n                    propagatedValue = fn(value);\n                }\n                catch (e) {\n                    return observer.error(e);\n                }\n                observer.next(propagatedValue);\n            },\n            error(e) { observer.error(e); },\n            complete() { observer.complete(); },\n        }));\n    }\n    filter(fn) {\n        if (typeof fn !== \"function\") {\n            throw new TypeError(fn + \" is not a function\");\n        }\n        const C = getSpecies(this);\n        return new C(observer => this.subscribe({\n            next(value) {\n                try {\n                    if (!fn(value))\n                        return;\n                }\n                catch (e) {\n                    return observer.error(e);\n                }\n                observer.next(value);\n            },\n            error(e) { observer.error(e); },\n            complete() { observer.complete(); },\n        }));\n    }\n    reduce(fn, seed) {\n        if (typeof fn !== \"function\") {\n            throw new TypeError(fn + \" is not a function\");\n        }\n        const C = getSpecies(this);\n        const hasSeed = arguments.length > 1;\n        let hasValue = false;\n        let acc = seed;\n        return new C(observer => this.subscribe({\n            next(value) {\n                const first = !hasValue;\n                hasValue = true;\n                if (!first || hasSeed) {\n                    try {\n                        acc = fn(acc, value);\n                    }\n                    catch (e) {\n                        return observer.error(e);\n                    }\n                }\n                else {\n                    acc = value;\n                }\n            },\n            error(e) { observer.error(e); },\n            complete() {\n                if (!hasValue && !hasSeed) {\n                    return observer.error(new TypeError(\"Cannot reduce an empty sequence\"));\n                }\n                observer.next(acc);\n                observer.complete();\n            },\n        }));\n    }\n    concat(...sources) {\n        const C = getSpecies(this);\n        return new C(observer => {\n            let subscription;\n            let index = 0;\n            function startNext(next) {\n                subscription = next.subscribe({\n                    next(v) { observer.next(v); },\n                    error(e) { observer.error(e); },\n                    complete() {\n                        if (index === sources.length) {\n                            subscription = undefined;\n                            observer.complete();\n                        }\n                        else {\n                            startNext(C.from(sources[index++]));\n                        }\n                    },\n                });\n            }\n            startNext(this);\n            return () => {\n                if (subscription) {\n                    subscription.unsubscribe();\n                    subscription = undefined;\n                }\n            };\n        });\n    }\n    flatMap(fn) {\n        if (typeof fn !== \"function\") {\n            throw new TypeError(fn + \" is not a function\");\n        }\n        const C = getSpecies(this);\n        return new C(observer => {\n            const subscriptions = [];\n            const outer = this.subscribe({\n                next(value) {\n                    let normalizedValue;\n                    if (fn) {\n                        try {\n                            normalizedValue = fn(value);\n                        }\n                        catch (e) {\n                            return observer.error(e);\n                        }\n                    }\n                    else {\n                        normalizedValue = value;\n                    }\n                    const inner = C.from(normalizedValue).subscribe({\n                        next(innerValue) { observer.next(innerValue); },\n                        error(e) { observer.error(e); },\n                        complete() {\n                            const i = subscriptions.indexOf(inner);\n                            if (i >= 0)\n                                subscriptions.splice(i, 1);\n                            completeIfDone();\n                        },\n                    });\n                    subscriptions.push(inner);\n                },\n                error(e) { observer.error(e); },\n                complete() { completeIfDone(); },\n            });\n            function completeIfDone() {\n                if (outer.closed && subscriptions.length === 0) {\n                    observer.complete();\n                }\n            }\n            return () => {\n                subscriptions.forEach(s => s.unsubscribe());\n                outer.unsubscribe();\n            };\n        });\n    }\n    [(Symbol.observable, SymbolObservable)]() { return this; }\n    static from(x) {\n        const C = (typeof this === \"function\" ? this : Observable);\n        if (x == null) {\n            throw new TypeError(x + \" is not an object\");\n        }\n        const observableMethod = getMethod(x, SymbolObservable);\n        if (observableMethod) {\n            const observable = observableMethod.call(x);\n            if (Object(observable) !== observable) {\n                throw new TypeError(observable + \" is not an object\");\n            }\n            if (isObservable(observable) && observable.constructor === C) {\n                return observable;\n            }\n            return new C(observer => observable.subscribe(observer));\n        }\n        if (hasSymbol(\"iterator\")) {\n            const iteratorMethod = getMethod(x, SymbolIterator);\n            if (iteratorMethod) {\n                return new C(observer => {\n                    enqueue(() => {\n                        if (observer.closed)\n                            return;\n                        for (const item of iteratorMethod.call(x)) {\n                            observer.next(item);\n                            if (observer.closed)\n                                return;\n                        }\n                        observer.complete();\n                    });\n                });\n            }\n        }\n        if (Array.isArray(x)) {\n            return new C(observer => {\n                enqueue(() => {\n                    if (observer.closed)\n                        return;\n                    for (const item of x) {\n                        observer.next(item);\n                        if (observer.closed)\n                            return;\n                    }\n                    observer.complete();\n                });\n            });\n        }\n        throw new TypeError(x + \" is not observable\");\n    }\n    static of(...items) {\n        const C = (typeof this === \"function\" ? this : Observable);\n        return new C(observer => {\n            enqueue(() => {\n                if (observer.closed)\n                    return;\n                for (const item of items) {\n                    observer.next(item);\n                    if (observer.closed)\n                        return;\n                }\n                observer.complete();\n            });\n        });\n    }\n    static get [SymbolSpecies]() { return this; }\n}\nif (hasSymbols()) {\n    Object.defineProperty(Observable, Symbol(\"extensions\"), {\n        value: {\n            symbol: SymbolObservable,\n            hostReportError,\n        },\n        configurable: true,\n    });\n}\nexport default Observable;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}