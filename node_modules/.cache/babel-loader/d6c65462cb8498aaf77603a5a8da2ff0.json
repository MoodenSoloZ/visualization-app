{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isColorChannel } from '../../channel';\nimport { title as fieldDefTitle, valueArray } from '../../channeldef';\nimport { isContinuousToContinuous } from '../../scale';\nimport { contains, getFirstDefined } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { guideFormat, guideFormatType } from '../format';\nimport { getFirstConditionValue } from './encode';\nexport var legendRules = {\n  direction: function direction(_ref) {\n    var _direction = _ref.direction;\n    return _direction;\n  },\n  format: function format(_ref2) {\n    var fieldOrDatumDef = _ref2.fieldOrDatumDef,\n      legend = _ref2.legend,\n      config = _ref2.config;\n    var format = legend.format,\n      formatType = legend.formatType;\n    return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format, formatType, config, false);\n  },\n  formatType: function formatType(_ref3) {\n    var legend = _ref3.legend,\n      fieldOrDatumDef = _ref3.fieldOrDatumDef,\n      scaleType = _ref3.scaleType;\n    var formatType = legend.formatType;\n    return guideFormatType(formatType, fieldOrDatumDef, scaleType);\n  },\n  gradientLength: function gradientLength(params) {\n    var _a, _b;\n    var legend = params.legend,\n      legendConfig = params.legendConfig;\n    return (_b = (_a = legend.gradientLength) !== null && _a !== void 0 ? _a : legendConfig.gradientLength) !== null && _b !== void 0 ? _b : defaultGradientLength(params);\n  },\n  labelOverlap: function labelOverlap(_ref4) {\n    var legend = _ref4.legend,\n      legendConfig = _ref4.legendConfig,\n      scaleType = _ref4.scaleType;\n    var _a, _b;\n    return (_b = (_a = legend.labelOverlap) !== null && _a !== void 0 ? _a : legendConfig.labelOverlap) !== null && _b !== void 0 ? _b : defaultLabelOverlap(scaleType);\n  },\n  symbolType: function symbolType(_ref5) {\n    var legend = _ref5.legend,\n      markDef = _ref5.markDef,\n      channel = _ref5.channel,\n      encoding = _ref5.encoding;\n    var _a;\n    return (_a = legend.symbolType) !== null && _a !== void 0 ? _a : defaultSymbolType(markDef.type, channel, encoding.shape, markDef.shape);\n  },\n  title: function title(_ref6) {\n    var fieldOrDatumDef = _ref6.fieldOrDatumDef,\n      config = _ref6.config;\n    return fieldDefTitle(fieldOrDatumDef, config, {\n      allowDisabling: true\n    });\n  },\n  type: function type(_ref7) {\n    var legendType = _ref7.legendType,\n      scaleType = _ref7.scaleType,\n      channel = _ref7.channel;\n    if (isColorChannel(channel) && isContinuousToContinuous(scaleType)) {\n      if (legendType === 'gradient') {\n        return undefined;\n      }\n    } else if (legendType === 'symbol') {\n      return undefined;\n    }\n    return legendType;\n  },\n  values: function values(_ref8) {\n    var fieldOrDatumDef = _ref8.fieldOrDatumDef,\n      legend = _ref8.legend;\n    return _values(legend, fieldOrDatumDef);\n  }\n};\nfunction _values(legend, fieldOrDatumDef) {\n  var vals = legend.values;\n  if (isArray(vals)) {\n    return valueArray(fieldOrDatumDef, vals);\n  } else if (isSignalRef(vals)) {\n    return vals;\n  }\n  return undefined;\n}\nexport { _values as values };\nexport function defaultSymbolType(mark, channel, shapeChannelDef, markShape) {\n  var _a;\n  if (channel !== 'shape') {\n    // use the value from the shape encoding or the mark config if they exist\n    var shape = (_a = getFirstConditionValue(shapeChannelDef)) !== null && _a !== void 0 ? _a : markShape;\n    if (shape) {\n      return shape;\n    }\n  }\n  switch (mark) {\n    case 'bar':\n    case 'rect':\n    case 'image':\n    case 'square':\n      return 'square';\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return 'stroke';\n    case 'arc':\n    case 'point':\n    case 'circle':\n    case 'tick':\n    case 'geoshape':\n    case 'area':\n    case 'text':\n      return 'circle';\n  }\n}\nexport function clipHeight(legendType) {\n  if (legendType === 'gradient') {\n    return 20;\n  }\n  return undefined;\n}\nexport function getLegendType(params) {\n  var legend = params.legend;\n  return getFirstDefined(legend.type, defaultType(params));\n}\nexport function defaultType(_ref9) {\n  var channel = _ref9.channel,\n    timeUnit = _ref9.timeUnit,\n    scaleType = _ref9.scaleType;\n  // Following the logic in https://github.com/vega/vega-parser/blob/master/src/parsers/legend.js\n  if (isColorChannel(channel)) {\n    if (contains(['quarter', 'month', 'day'], timeUnit)) {\n      return 'symbol';\n    }\n    if (isContinuousToContinuous(scaleType)) {\n      return 'gradient';\n    }\n  }\n  return 'symbol';\n}\nexport function getDirection(_ref10) {\n  var legendConfig = _ref10.legendConfig,\n    legendType = _ref10.legendType,\n    orient = _ref10.orient,\n    legend = _ref10.legend;\n  var _a, _b;\n  return (_b = (_a = legend.direction) !== null && _a !== void 0 ? _a : legendConfig[legendType ? 'gradientDirection' : 'symbolDirection']) !== null && _b !== void 0 ? _b : defaultDirection(orient, legendType);\n}\nexport function defaultDirection(orient, legendType) {\n  switch (orient) {\n    case 'top':\n    case 'bottom':\n      return 'horizontal';\n    case 'left':\n    case 'right':\n    case 'none':\n    case undefined:\n      // undefined = \"right\" in Vega\n      return undefined;\n    // vertical is Vega's default\n    default:\n      // top-left / ...\n      // For inner legend, uses compact layout like Tableau\n      return legendType === 'gradient' ? 'horizontal' : undefined;\n  }\n}\nexport function defaultGradientLength(_ref11) {\n  var legendConfig = _ref11.legendConfig,\n    model = _ref11.model,\n    direction = _ref11.direction,\n    orient = _ref11.orient,\n    scaleType = _ref11.scaleType;\n  var gradientHorizontalMaxLength = legendConfig.gradientHorizontalMaxLength,\n    gradientHorizontalMinLength = legendConfig.gradientHorizontalMinLength,\n    gradientVerticalMaxLength = legendConfig.gradientVerticalMaxLength,\n    gradientVerticalMinLength = legendConfig.gradientVerticalMinLength;\n  if (isContinuousToContinuous(scaleType)) {\n    if (direction === 'horizontal') {\n      if (orient === 'top' || orient === 'bottom') {\n        return gradientLengthSignal(model, 'width', gradientHorizontalMinLength, gradientHorizontalMaxLength);\n      } else {\n        return gradientHorizontalMinLength;\n      }\n    } else {\n      // vertical / undefined (Vega uses vertical by default)\n      return gradientLengthSignal(model, 'height', gradientVerticalMinLength, gradientVerticalMaxLength);\n    }\n  }\n  return undefined;\n}\nfunction gradientLengthSignal(model, sizeType, min, max) {\n  var sizeSignal = model.getSizeSignalRef(sizeType).signal;\n  return {\n    signal: \"clamp(\".concat(sizeSignal, \", \").concat(min, \", \").concat(max, \")\")\n  };\n}\nexport function defaultLabelOverlap(scaleType) {\n  if (contains(['quantile', 'threshold', 'log', 'symlog'], scaleType)) {\n    return 'greedy';\n  }\n  return undefined;\n}","map":{"version":3,"sources":["../../../../src/compile/legend/properties.ts"],"names":[],"mappings":"AACA,SAAQ,OAAO,QAAO,WAAW;AACjC,SAAQ,cAAc,QAAO,eAAe;AAC5C,SAA2C,KAAK,IAAI,aAAa,EAAiB,UAAU,QAAO,kBAAkB;AAKrH,SAAQ,wBAAwB,QAAkB,aAAa;AAE/D,SAAQ,QAAQ,EAAE,eAAe,QAAO,YAAY;AACpD,SAAQ,WAAW,QAAO,mBAAmB;AAC7C,SAAQ,WAAW,EAAE,eAAe,QAAO,WAAW;AAKtD,SAAQ,sBAAsB,QAAO,UAAU;AAiB/C,OAAO,IAAM,WAAW,GAEpB;EACF,SAAS,EAAE;IAAA,IAAE,UAAS,QAAT,SAAS;IAAA,OAAM,UAAS;EAAA;EAErC,MAAM,EAAE,uBAAsC;IAAA,IAApC,eAAe,SAAf,eAAe;MAAE,MAAM,SAAN,MAAM;MAAE,MAAM,SAAN,MAAM;IACvC,IAAO,MAAM,GAAgB,MAAM,CAA5B,MAAM;MAAE,UAAU,GAAI,MAAM,CAApB,UAAU;IACzB,OAAO,WAAW,CAAC,eAAe,EAAE,eAAe,CAAC,IAAI,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM,EAAE,KAAK,CAAC;EAC9F,CAAC;EAED,UAAU,EAAE,2BAAyC;IAAA,IAAvC,MAAM,SAAN,MAAM;MAAE,eAAe,SAAf,eAAe;MAAE,SAAS,SAAT,SAAS;IAC9C,IAAO,UAAU,GAAI,MAAM,CAApB,UAAU;IACjB,OAAO,eAAe,CAAC,UAAU,EAAE,eAAe,EAAE,SAAS,CAAC;EAChE,CAAC;EAED,cAAc,EAAE,wBAAA,MAAM,EAAG;;IACvB,IAAO,MAAM,GAAkB,MAAM,CAA9B,MAAM;MAAE,YAAY,GAAI,MAAM,CAAtB,YAAY;IAC3B,OAAO,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,MAAM,CAAC,cAAc,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,YAAY,CAAC,cAAc,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,qBAAqB,CAAC,MAAM,CAAC;EAC9F,CAAC;EAED,YAAY,EAAE,6BAAsC;IAAA,IAApC,MAAM,SAAN,MAAM;MAAE,YAAY,SAAZ,YAAY;MAAE,SAAS,SAAT,SAAS;IAAK,IAAA,EAAA,EAAA,EAAA;IAClD,OAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,MAAM,CAAC,YAAY,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,YAAY,CAAC,YAAY,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,mBAAmB,CAAC,SAAS,CAAC;EAAA,CAAA;EAEpF,UAAU,EAAE,2BAAyC;IAAA,IAAvC,MAAM,SAAN,MAAM;MAAE,OAAO,SAAP,OAAO;MAAE,OAAO,SAAP,OAAO;MAAE,QAAQ,SAAR,QAAQ;IAAK,IAAA,EAAA;IACnD,OAAA,CAAA,EAAA,GAAA,MAAM,CAAC,UAAU,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,iBAAiB,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,EAAE,QAAQ,CAAC,KAAK,EAAE,OAAO,CAAC,KAAK,CAAC;EAAA,CAAA;EAE9F,KAAK,EAAE;IAAA,IAAE,eAAe,SAAf,eAAe;MAAE,MAAM,SAAN,MAAM;IAAA,OAAM,aAAa,CAAC,eAAe,EAAE,MAAM,EAAE;MAAC,cAAc,EAAE;IAAI,CAAC,CAAC;EAAA;EAEpG,IAAI,EAAE,qBAAqC;IAAA,IAAnC,UAAU,SAAV,UAAU;MAAE,SAAS,SAAT,SAAS;MAAE,OAAO,SAAP,OAAO;IACpC,IAAI,cAAc,CAAC,OAAO,CAAC,IAAI,wBAAwB,CAAC,SAAS,CAAC,EAAE;MAClE,IAAI,UAAU,KAAK,UAAU,EAAE;QAC7B,OAAO,SAAS;MACjB;KACF,MAAM,IAAI,UAAU,KAAK,QAAQ,EAAE;MAClC,OAAO,SAAS;IACjB;IACD,OAAO,UAAU;EACnB,CAAC;EAED,MAAM,EAAE;IAAA,IAAE,eAAe,SAAf,eAAe;MAAE,MAAM,SAAN,MAAM;IAAA,OAAM,OAAM,CAAC,MAAM,EAAE,eAAe,CAAC;EAAA;CACvE;AAEK,SAAU,OAAM,CAAC,MAAsB,EAAE,eAAiD,EAAA;EAC9F,IAAM,IAAI,GAAG,MAAM,CAAC,MAAM;EAE1B,IAAI,OAAO,CAAC,IAAI,CAAC,EAAE;IACjB,OAAO,UAAU,CAAC,eAAe,EAAE,IAAI,CAAC;GACzC,MAAM,IAAI,WAAW,CAAC,IAAI,CAAC,EAAE;IAC5B,OAAO,IAAI;EACZ;EACD,OAAO,SAAS;AAClB;AAAC;AAED,OAAM,SAAU,iBAAiB,CAC/B,IAAU,EACV,OAAgC,EAChC,eAA0C,EAC1C,SAAkC,EAAA;;EAElC,IAAI,OAAO,KAAK,OAAO,EAAE;IACvB;IACA,IAAM,KAAK,GAAG,CAAA,EAAA,GAAA,sBAAsB,CAAS,eAAe,CAAC,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,SAAS;IAC1E,IAAI,KAAK,EAAE;MACT,OAAO,KAAK;IACb;EACF;EAED,QAAQ,IAAI;IACV,KAAK,KAAK;IACV,KAAK,MAAM;IACX,KAAK,OAAO;IACZ,KAAK,QAAQ;MACX,OAAO,QAAQ;IACjB,KAAK,MAAM;IACX,KAAK,OAAO;IACZ,KAAK,MAAM;MACT,OAAO,QAAQ;IACjB,KAAK,KAAK;IACV,KAAK,OAAO;IACZ,KAAK,QAAQ;IACb,KAAK,MAAM;IACX,KAAK,UAAU;IACf,KAAK,MAAM;IACX,KAAK,MAAM;MACT,OAAO,QAAQ;EAAC;AAEtB;AAEA,OAAM,SAAU,UAAU,CAAC,UAAsB,EAAA;EAC/C,IAAI,UAAU,KAAK,UAAU,EAAE;IAC7B,OAAO,EAAE;EACV;EACD,OAAO,SAAS;AAClB;AAEA,OAAM,SAAU,aAAa,CAAC,MAK7B,EAAA;EACC,IAAO,MAAM,GAAI,MAAM,CAAhB,MAAM;EAEb,OAAO,eAAe,CAAC,MAAM,CAAC,IAAI,EAAE,WAAW,CAAC,MAAM,CAAC,CAAC;AAC1D;AAEA,OAAM,SAAU,WAAW,QAQ1B;EAAA,IAPC,OAAO,SAAP,OAAO;IACP,QAAQ,SAAR,QAAQ;IACR,SAAS,SAAT,SAAS;EAMT;EAEA,IAAI,cAAc,CAAC,OAAO,CAAC,EAAE;IAC3B,IAAI,QAAQ,CAAC,CAAC,SAAS,EAAE,OAAO,EAAE,KAAK,CAAC,EAAE,QAAQ,CAAC,EAAE;MACnD,OAAO,QAAQ;IAChB;IAED,IAAI,wBAAwB,CAAC,SAAS,CAAC,EAAE;MACvC,OAAO,UAAU;IAClB;EACF;EACD,OAAO,QAAQ;AACjB;AAEA,OAAM,SAAU,YAAY,SAU3B;EAAA,IATC,YAAY,UAAZ,YAAY;IACZ,UAAU,UAAV,UAAU;IACV,MAAM,UAAN,MAAM;IACN,MAAM,UAAN,MAAM;;EAON,OACE,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,MAAM,CAAC,SAAS,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAChB,YAAY,CAAC,UAAU,GAAG,mBAAmB,GAAG,iBAAiB,CAAC,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAClE,gBAAgB,CAAC,MAAM,EAAE,UAAU,CAAC;AAExC;AAEA,OAAM,SAAU,gBAAgB,CAAC,MAAoB,EAAE,UAAsB,EAAA;EAC3E,QAAQ,MAAM;IACZ,KAAK,KAAK;IACV,KAAK,QAAQ;MACX,OAAO,YAAY;IAErB,KAAK,MAAM;IACX,KAAK,OAAO;IACZ,KAAK,MAAM;IACX,KAAK,SAAS;MAAE;MACd,OAAO,SAAS;IAAE;IACpB;MACE;MACA;MACA,OAAO,UAAU,KAAK,UAAU,GAAG,YAAY,GAAG,SAAS;EAAC;AAElE;AAEA,OAAM,SAAU,qBAAqB,SAYpC;EAAA,IAXC,YAAY,UAAZ,YAAY;IACZ,KAAK,UAAL,KAAK;IACL,SAAS,UAAT,SAAS;IACT,MAAM,UAAN,MAAM;IACN,SAAS,UAAT,SAAS;EAQT,IACE,2BAA2B,GAIzB,YAAY,CAJd,2BAA2B;IAC3B,2BAA2B,GAGzB,YAAY,CAHd,2BAA2B;IAC3B,yBAAyB,GAEvB,YAAY,CAFd,yBAAyB;IACzB,yBAAyB,GACvB,YAAY,CADd,yBAAyB;EAE3B,IAAI,wBAAwB,CAAC,SAAS,CAAC,EAAE;IACvC,IAAI,SAAS,KAAK,YAAY,EAAE;MAC9B,IAAI,MAAM,KAAK,KAAK,IAAI,MAAM,KAAK,QAAQ,EAAE;QAC3C,OAAO,oBAAoB,CAAC,KAAK,EAAE,OAAO,EAAE,2BAA2B,EAAE,2BAA2B,CAAC;OACtG,MAAM;QACL,OAAO,2BAA2B;MACnC;KACF,MAAM;MACL;MACA,OAAO,oBAAoB,CAAC,KAAK,EAAE,QAAQ,EAAE,yBAAyB,EAAE,yBAAyB,CAAC;IACnG;EACF;EACD,OAAO,SAAS;AAClB;AAEA,SAAS,oBAAoB,CAAC,KAAY,EAAE,QAA4B,EAAE,GAAW,EAAE,GAAW,EAAA;EAChG,IAAM,UAAU,GAAG,KAAK,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC,MAAM;EAC1D,OAAO;IAAC,MAAM,kBAAW,UAAU,eAAK,GAAG,eAAK,GAAG;EAAG,CAAC;AACzD;AAEA,OAAM,SAAU,mBAAmB,CAAC,SAAoB,EAAA;EACtD,IAAI,QAAQ,CAAC,CAAC,UAAU,EAAE,WAAW,EAAE,KAAK,EAAE,QAAQ,CAAC,EAAE,SAAS,CAAC,EAAE;IACnE,OAAO,QAAQ;EAChB;EACD,OAAO,SAAS;AAClB","sourceRoot":"","sourcesContent":["import { isArray } from 'vega-util';\nimport { isColorChannel } from '../../channel';\nimport { title as fieldDefTitle, valueArray } from '../../channeldef';\nimport { isContinuousToContinuous } from '../../scale';\nimport { contains, getFirstDefined } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { guideFormat, guideFormatType } from '../format';\nimport { getFirstConditionValue } from './encode';\nexport const legendRules = {\n    direction: ({ direction }) => direction,\n    format: ({ fieldOrDatumDef, legend, config }) => {\n        const { format, formatType } = legend;\n        return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format, formatType, config, false);\n    },\n    formatType: ({ legend, fieldOrDatumDef, scaleType }) => {\n        const { formatType } = legend;\n        return guideFormatType(formatType, fieldOrDatumDef, scaleType);\n    },\n    gradientLength: params => {\n        var _a, _b;\n        const { legend, legendConfig } = params;\n        return (_b = (_a = legend.gradientLength) !== null && _a !== void 0 ? _a : legendConfig.gradientLength) !== null && _b !== void 0 ? _b : defaultGradientLength(params);\n    },\n    labelOverlap: ({ legend, legendConfig, scaleType }) => { var _a, _b; return (_b = (_a = legend.labelOverlap) !== null && _a !== void 0 ? _a : legendConfig.labelOverlap) !== null && _b !== void 0 ? _b : defaultLabelOverlap(scaleType); },\n    symbolType: ({ legend, markDef, channel, encoding }) => { var _a; return (_a = legend.symbolType) !== null && _a !== void 0 ? _a : defaultSymbolType(markDef.type, channel, encoding.shape, markDef.shape); },\n    title: ({ fieldOrDatumDef, config }) => fieldDefTitle(fieldOrDatumDef, config, { allowDisabling: true }),\n    type: ({ legendType, scaleType, channel }) => {\n        if (isColorChannel(channel) && isContinuousToContinuous(scaleType)) {\n            if (legendType === 'gradient') {\n                return undefined;\n            }\n        }\n        else if (legendType === 'symbol') {\n            return undefined;\n        }\n        return legendType;\n    },\n    values: ({ fieldOrDatumDef, legend }) => values(legend, fieldOrDatumDef)\n};\nexport function values(legend, fieldOrDatumDef) {\n    const vals = legend.values;\n    if (isArray(vals)) {\n        return valueArray(fieldOrDatumDef, vals);\n    }\n    else if (isSignalRef(vals)) {\n        return vals;\n    }\n    return undefined;\n}\nexport function defaultSymbolType(mark, channel, shapeChannelDef, markShape) {\n    var _a;\n    if (channel !== 'shape') {\n        // use the value from the shape encoding or the mark config if they exist\n        const shape = (_a = getFirstConditionValue(shapeChannelDef)) !== null && _a !== void 0 ? _a : markShape;\n        if (shape) {\n            return shape;\n        }\n    }\n    switch (mark) {\n        case 'bar':\n        case 'rect':\n        case 'image':\n        case 'square':\n            return 'square';\n        case 'line':\n        case 'trail':\n        case 'rule':\n            return 'stroke';\n        case 'arc':\n        case 'point':\n        case 'circle':\n        case 'tick':\n        case 'geoshape':\n        case 'area':\n        case 'text':\n            return 'circle';\n    }\n}\nexport function clipHeight(legendType) {\n    if (legendType === 'gradient') {\n        return 20;\n    }\n    return undefined;\n}\nexport function getLegendType(params) {\n    const { legend } = params;\n    return getFirstDefined(legend.type, defaultType(params));\n}\nexport function defaultType({ channel, timeUnit, scaleType }) {\n    // Following the logic in https://github.com/vega/vega-parser/blob/master/src/parsers/legend.js\n    if (isColorChannel(channel)) {\n        if (contains(['quarter', 'month', 'day'], timeUnit)) {\n            return 'symbol';\n        }\n        if (isContinuousToContinuous(scaleType)) {\n            return 'gradient';\n        }\n    }\n    return 'symbol';\n}\nexport function getDirection({ legendConfig, legendType, orient, legend }) {\n    var _a, _b;\n    return ((_b = (_a = legend.direction) !== null && _a !== void 0 ? _a : legendConfig[legendType ? 'gradientDirection' : 'symbolDirection']) !== null && _b !== void 0 ? _b : defaultDirection(orient, legendType));\n}\nexport function defaultDirection(orient, legendType) {\n    switch (orient) {\n        case 'top':\n        case 'bottom':\n            return 'horizontal';\n        case 'left':\n        case 'right':\n        case 'none':\n        case undefined: // undefined = \"right\" in Vega\n            return undefined; // vertical is Vega's default\n        default:\n            // top-left / ...\n            // For inner legend, uses compact layout like Tableau\n            return legendType === 'gradient' ? 'horizontal' : undefined;\n    }\n}\nexport function defaultGradientLength({ legendConfig, model, direction, orient, scaleType }) {\n    const { gradientHorizontalMaxLength, gradientHorizontalMinLength, gradientVerticalMaxLength, gradientVerticalMinLength } = legendConfig;\n    if (isContinuousToContinuous(scaleType)) {\n        if (direction === 'horizontal') {\n            if (orient === 'top' || orient === 'bottom') {\n                return gradientLengthSignal(model, 'width', gradientHorizontalMinLength, gradientHorizontalMaxLength);\n            }\n            else {\n                return gradientHorizontalMinLength;\n            }\n        }\n        else {\n            // vertical / undefined (Vega uses vertical by default)\n            return gradientLengthSignal(model, 'height', gradientVerticalMinLength, gradientVerticalMaxLength);\n        }\n    }\n    return undefined;\n}\nfunction gradientLengthSignal(model, sizeType, min, max) {\n    const sizeSignal = model.getSizeSignalRef(sizeType).signal;\n    return { signal: `clamp(${sizeSignal}, ${min}, ${max})` };\n}\nexport function defaultLabelOverlap(scaleType) {\n    if (contains(['quantile', 'threshold', 'log', 'symlog'], scaleType)) {\n        return 'greedy';\n    }\n    return undefined;\n}\n//# sourceMappingURL=properties.js.map"]},"metadata":{},"sourceType":"module"}