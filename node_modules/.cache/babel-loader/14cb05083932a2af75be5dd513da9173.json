{"ast":null,"code":"import { isBoolean, isObject } from 'vega-util';\nimport { COLOR, COLUMN, FILL, FILLOPACITY, OPACITY, ROW, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH } from './channel';\nimport { normalizeBin } from './channeldef';\nimport { entries, keys, varName } from './util';\n/**\n * Create a key for the bin configuration. Not for prebinned bin.\n */\nexport function binToString(bin) {\n  if (isBoolean(bin)) {\n    bin = normalizeBin(bin, undefined);\n  }\n  return 'bin' + keys(bin).map(function (p) {\n    return isParameterExtent(bin[p]) ? varName(\"_\".concat(p, \"_\").concat(entries(bin[p]))) : varName(\"_\".concat(p, \"_\").concat(bin[p]));\n  }).join('');\n}\n/**\n * Vega-Lite should bin the data.\n */\nexport function isBinning(bin) {\n  return bin === true || isBinParams(bin) && !bin.binned;\n}\n/**\n * The data is already binned and so Vega-Lite should not bin it again.\n */\nexport function isBinned(bin) {\n  return bin === 'binned' || isBinParams(bin) && bin.binned === true;\n}\nexport function isBinParams(bin) {\n  return isObject(bin);\n}\nexport function isParameterExtent(extent) {\n  return extent === null || extent === void 0 ? void 0 : extent['param'];\n}\nexport function autoMaxBins(channel) {\n  switch (channel) {\n    case ROW:\n    case COLUMN:\n    case SIZE:\n    case COLOR:\n    case FILL:\n    case STROKE:\n    case STROKEWIDTH:\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    // Facets and Size shouldn't have too many bins\n    // We choose 6 like shape to simplify the rule [falls through]\n    case SHAPE:\n      return 6;\n    // Vega's \"shape\" has 6 distinct values\n    case STROKEDASH:\n      return 4;\n    // We only provide 5 different stroke dash values (but 4 is more effective)\n    default:\n      return 10;\n  }\n}","map":{"version":3,"sources":["../../src/bin.ts"],"names":[],"mappings":"AAAA,SAAQ,SAAS,EAAE,QAAQ,QAAO,WAAW;AAC7C,SACE,KAAK,EACL,MAAM,EAEN,IAAI,EACJ,WAAW,EACX,OAAO,EACP,GAAG,EACH,KAAK,EACL,IAAI,EACJ,MAAM,EACN,UAAU,EACV,aAAa,EACb,WAAW,QACN,WAAW;AAClB,SAAQ,YAAY,QAAO,cAAc;AAEzC,SAAQ,OAAO,EAAE,IAAI,EAAE,OAAO,QAAO,QAAQ;AA0E7C;;AAEG;AACH,OAAM,SAAU,WAAW,CAAC,GAAqB,EAAA;EAC/C,IAAI,SAAS,CAAC,GAAG,CAAC,EAAE;IAClB,GAAG,GAAG,YAAY,CAAC,GAAG,EAAE,SAAS,CAAC;EACnC;EACD,OACE,KAAK,GACL,IAAI,CAAC,GAAG,CAAC,CACN,GAAG,CAAC,UAAA,CAAC;IAAA,OAAK,iBAAiB,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,OAAO,YAAK,CAAC,cAAI,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAG,GAAG,OAAO,YAAK,CAAC,cAAI,GAAG,CAAC,CAAC,CAAC,EAAG;EAAA,CAAC,CAAC,CACxG,IAAI,CAAC,EAAE,CAAC;AAEf;AAEA;;AAEG;AACH,OAAM,SAAU,SAAS,CAAC,GAAmC,EAAA;EAC3D,OAAO,GAAG,KAAK,IAAI,IAAK,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,MAAO;AAC1D;AAEA;;AAEG;AACH,OAAM,SAAU,QAAQ,CAAC,GAAmC,EAAA;EAC1D,OAAO,GAAG,KAAK,QAAQ,IAAK,WAAW,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,MAAM,KAAK,IAAK;AACtE;AAEA,OAAM,SAAU,WAAW,CAAC,GAAmC,EAAA;EAC7D,OAAO,QAAQ,CAAC,GAAG,CAAC;AACtB;AAEA,OAAM,SAAU,iBAAiB,CAAC,MAAiB,EAAA;EACjD,OAAO,MAAM,KAAA,IAAA,IAAN,MAAM,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAN,MAAM,CAAG,OAAO,CAAC;AAC1B;AAEA,OAAM,SAAU,WAAW,CAAC,OAAyB,EAAA;EACnD,QAAQ,OAAO;IACb,KAAK,GAAG;IACR,KAAK,MAAM;IACX,KAAK,IAAI;IACT,KAAK,KAAK;IACV,KAAK,IAAI;IACT,KAAK,MAAM;IACX,KAAK,WAAW;IAChB,KAAK,OAAO;IACZ,KAAK,WAAW;IAChB,KAAK,aAAa;IAClB;IACA;IACA,KAAK,KAAK;MACR,OAAO,CAAC;IAAE;IACZ,KAAK,UAAU;MACb,OAAO,CAAC;IAAE;IACZ;MACE,OAAO,EAAE;EAAC;AAEhB","sourceRoot":"","sourcesContent":["import { isBoolean, isObject } from 'vega-util';\nimport { COLOR, COLUMN, FILL, FILLOPACITY, OPACITY, ROW, SHAPE, SIZE, STROKE, STROKEDASH, STROKEOPACITY, STROKEWIDTH } from './channel';\nimport { normalizeBin } from './channeldef';\nimport { entries, keys, varName } from './util';\n/**\n * Create a key for the bin configuration. Not for prebinned bin.\n */\nexport function binToString(bin) {\n    if (isBoolean(bin)) {\n        bin = normalizeBin(bin, undefined);\n    }\n    return ('bin' +\n        keys(bin)\n            .map(p => (isParameterExtent(bin[p]) ? varName(`_${p}_${entries(bin[p])}`) : varName(`_${p}_${bin[p]}`)))\n            .join(''));\n}\n/**\n * Vega-Lite should bin the data.\n */\nexport function isBinning(bin) {\n    return bin === true || (isBinParams(bin) && !bin.binned);\n}\n/**\n * The data is already binned and so Vega-Lite should not bin it again.\n */\nexport function isBinned(bin) {\n    return bin === 'binned' || (isBinParams(bin) && bin.binned === true);\n}\nexport function isBinParams(bin) {\n    return isObject(bin);\n}\nexport function isParameterExtent(extent) {\n    return extent === null || extent === void 0 ? void 0 : extent['param'];\n}\nexport function autoMaxBins(channel) {\n    switch (channel) {\n        case ROW:\n        case COLUMN:\n        case SIZE:\n        case COLOR:\n        case FILL:\n        case STROKE:\n        case STROKEWIDTH:\n        case OPACITY:\n        case FILLOPACITY:\n        case STROKEOPACITY:\n        // Facets and Size shouldn't have too many bins\n        // We choose 6 like shape to simplify the rule [falls through]\n        case SHAPE:\n            return 6; // Vega's \"shape\" has 6 distinct values\n        case STROKEDASH:\n            return 4; // We only provide 5 different stroke dash values (but 4 is more effective)\n        default:\n            return 10;\n    }\n}\n//# sourceMappingURL=bin.js.map"]},"metadata":{},"sourceType":"module"}