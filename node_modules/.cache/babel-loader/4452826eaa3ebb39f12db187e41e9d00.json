{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { isContinuousFieldOrDatumDef, isFieldOrDatumDef, title } from '../channeldef';\nimport { extractTransformsFromEncoding, normalizeEncoding } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { replaceAll, titleCase } from '../util';\nimport { CompositeMarkNormalizer } from './base';\nimport { compositeMarkContinuousAxis, compositeMarkOrient, getCompositeMarkTooltip, makeCompositeAggregatePartFactory } from './common';\nexport var ERRORBAR = 'errorbar';\nexport var ERRORBAR_PARTS = ['ticks', 'rule'];\nexport var errorBarNormalizer = new CompositeMarkNormalizer(ERRORBAR, normalizeErrorBar);\nexport function normalizeErrorBar(spec, _ref) {\n  var config = _ref.config;\n  // Need to initEncoding first so we can infer type\n  spec = Object.assign(Object.assign({}, spec), {\n    encoding: normalizeEncoding(spec.encoding, config)\n  });\n  var _errorBarParams = errorBarParams(spec, ERRORBAR, config),\n    transform = _errorBarParams.transform,\n    continuousAxisChannelDef = _errorBarParams.continuousAxisChannelDef,\n    continuousAxis = _errorBarParams.continuousAxis,\n    encodingWithoutContinuousAxis = _errorBarParams.encodingWithoutContinuousAxis,\n    ticksOrient = _errorBarParams.ticksOrient,\n    markDef = _errorBarParams.markDef,\n    outerSpec = _errorBarParams.outerSpec,\n    tooltipEncoding = _errorBarParams.tooltipEncoding;\n  delete encodingWithoutContinuousAxis['size'];\n  var makeErrorBarPart = makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, config.errorbar);\n  var thickness = markDef.thickness;\n  var size = markDef.size;\n  var tick = Object.assign(Object.assign({\n    type: 'tick',\n    orient: ticksOrient,\n    aria: false\n  }, thickness !== undefined ? {\n    thickness: thickness\n  } : {}), size !== undefined ? {\n    size: size\n  } : {});\n  var layer = [].concat(_toConsumableArray(makeErrorBarPart({\n    partName: 'ticks',\n    mark: tick,\n    positionPrefix: 'lower',\n    extraEncoding: tooltipEncoding\n  })), _toConsumableArray(makeErrorBarPart({\n    partName: 'ticks',\n    mark: tick,\n    positionPrefix: 'upper',\n    extraEncoding: tooltipEncoding\n  })), _toConsumableArray(makeErrorBarPart({\n    partName: 'rule',\n    mark: Object.assign({\n      type: 'rule',\n      ariaRoleDescription: 'errorbar'\n    }, thickness !== undefined ? {\n      size: thickness\n    } : {}),\n    positionPrefix: 'lower',\n    endPositionPrefix: 'upper',\n    extraEncoding: tooltipEncoding\n  })));\n  return Object.assign(Object.assign(Object.assign({}, outerSpec), {\n    transform: transform\n  }), layer.length > 1 ? {\n    layer: layer\n  } : Object.assign({}, layer[0]));\n}\nfunction errorBarOrientAndInputType(spec, compositeMark) {\n  var encoding = spec.encoding;\n  if (errorBarIsInputTypeRaw(encoding)) {\n    return {\n      orient: compositeMarkOrient(spec, compositeMark),\n      inputType: 'raw'\n    };\n  }\n  var isTypeAggregatedUpperLower = errorBarIsInputTypeAggregatedUpperLower(encoding);\n  var isTypeAggregatedError = errorBarIsInputTypeAggregatedError(encoding);\n  var x = encoding.x;\n  var y = encoding.y;\n  if (isTypeAggregatedUpperLower) {\n    // type is aggregated-upper-lower\n    if (isTypeAggregatedError) {\n      throw new Error(\"\".concat(compositeMark, \" cannot be both type aggregated-upper-lower and aggregated-error\"));\n    }\n    var x2 = encoding.x2;\n    var y2 = encoding.y2;\n    if (isFieldOrDatumDef(x2) && isFieldOrDatumDef(y2)) {\n      // having both x, x2 and y, y2\n      throw new Error(\"\".concat(compositeMark, \" cannot have both x2 and y2\"));\n    } else if (isFieldOrDatumDef(x2)) {\n      if (isContinuousFieldOrDatumDef(x)) {\n        // having x, x2 quantitative and field y, y2 are not specified\n        return {\n          orient: 'horizontal',\n          inputType: 'aggregated-upper-lower'\n        };\n      } else {\n        // having x, x2 that are not both quantitative\n        throw new Error(\"Both x and x2 have to be quantitative in \".concat(compositeMark));\n      }\n    } else if (isFieldOrDatumDef(y2)) {\n      // y2 is a FieldDef\n      if (isContinuousFieldOrDatumDef(y)) {\n        // having y, y2 quantitative and field x, x2 are not specified\n        return {\n          orient: 'vertical',\n          inputType: 'aggregated-upper-lower'\n        };\n      } else {\n        // having y, y2 that are not both quantitative\n        throw new Error(\"Both y and y2 have to be quantitative in \".concat(compositeMark));\n      }\n    }\n    throw new Error('No ranged axis');\n  } else {\n    // type is aggregated-error\n    var xError = encoding.xError;\n    var xError2 = encoding.xError2;\n    var yError = encoding.yError;\n    var yError2 = encoding.yError2;\n    if (isFieldOrDatumDef(xError2) && !isFieldOrDatumDef(xError)) {\n      // having xError2 without xError\n      throw new Error(\"\".concat(compositeMark, \" cannot have xError2 without xError\"));\n    }\n    if (isFieldOrDatumDef(yError2) && !isFieldOrDatumDef(yError)) {\n      // having yError2 without yError\n      throw new Error(\"\".concat(compositeMark, \" cannot have yError2 without yError\"));\n    }\n    if (isFieldOrDatumDef(xError) && isFieldOrDatumDef(yError)) {\n      // having both xError and yError\n      throw new Error(\"\".concat(compositeMark, \" cannot have both xError and yError with both are quantiative\"));\n    } else if (isFieldOrDatumDef(xError)) {\n      if (isContinuousFieldOrDatumDef(x)) {\n        // having x and xError that are all quantitative\n        return {\n          orient: 'horizontal',\n          inputType: 'aggregated-error'\n        };\n      } else {\n        // having x, xError, and xError2 that are not all quantitative\n        throw new Error('All x, xError, and xError2 (if exist) have to be quantitative');\n      }\n    } else if (isFieldOrDatumDef(yError)) {\n      if (isContinuousFieldOrDatumDef(y)) {\n        // having y and yError that are all quantitative\n        return {\n          orient: 'vertical',\n          inputType: 'aggregated-error'\n        };\n      } else {\n        // having y, yError, and yError2 that are not all quantitative\n        throw new Error('All y, yError, and yError2 (if exist) have to be quantitative');\n      }\n    }\n    throw new Error('No ranged axis');\n  }\n}\nfunction errorBarIsInputTypeRaw(encoding) {\n  return (isFieldOrDatumDef(encoding.x) || isFieldOrDatumDef(encoding.y)) && !isFieldOrDatumDef(encoding.x2) && !isFieldOrDatumDef(encoding.y2) && !isFieldOrDatumDef(encoding.xError) && !isFieldOrDatumDef(encoding.xError2) && !isFieldOrDatumDef(encoding.yError) && !isFieldOrDatumDef(encoding.yError2);\n}\nfunction errorBarIsInputTypeAggregatedUpperLower(encoding) {\n  return isFieldOrDatumDef(encoding.x2) || isFieldOrDatumDef(encoding.y2);\n}\nfunction errorBarIsInputTypeAggregatedError(encoding) {\n  return isFieldOrDatumDef(encoding.xError) || isFieldOrDatumDef(encoding.xError2) || isFieldOrDatumDef(encoding.yError) || isFieldOrDatumDef(encoding.yError2);\n}\nexport function errorBarParams(spec, compositeMark, config) {\n  var _a;\n  // TODO: use selection\n  var mark = spec.mark,\n    encoding = spec.encoding,\n    params = spec.params,\n    _p = spec.projection,\n    outerSpec = __rest(spec, [\"mark\", \"encoding\", \"params\", \"projection\"]);\n  var markDef = isMarkDef(mark) ? mark : {\n    type: mark\n  };\n  // TODO(https://github.com/vega/vega-lite/issues/3702): add selection support\n  if (params) {\n    log.warn(log.message.selectionNotSupported(compositeMark));\n  }\n  var _errorBarOrientAndInp = errorBarOrientAndInputType(spec, compositeMark),\n    orient = _errorBarOrientAndInp.orient,\n    inputType = _errorBarOrientAndInp.inputType;\n  var _compositeMarkContinu = compositeMarkContinuousAxis(spec, orient, compositeMark),\n    continuousAxisChannelDef = _compositeMarkContinu.continuousAxisChannelDef,\n    continuousAxisChannelDef2 = _compositeMarkContinu.continuousAxisChannelDef2,\n    continuousAxisChannelDefError = _compositeMarkContinu.continuousAxisChannelDefError,\n    continuousAxisChannelDefError2 = _compositeMarkContinu.continuousAxisChannelDefError2,\n    continuousAxis = _compositeMarkContinu.continuousAxis;\n  var _errorBarAggregationA = errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config),\n    errorBarSpecificAggregate = _errorBarAggregationA.errorBarSpecificAggregate,\n    postAggregateCalculates = _errorBarAggregationA.postAggregateCalculates,\n    tooltipSummary = _errorBarAggregationA.tooltipSummary,\n    tooltipTitleWithFieldName = _errorBarAggregationA.tooltipTitleWithFieldName;\n  var _b = encoding,\n    _c = continuousAxis,\n    oldContinuousAxisChannelDef = _b[_c],\n    _d = continuousAxis === 'x' ? 'x2' : 'y2',\n    oldContinuousAxisChannelDef2 = _b[_d],\n    _e = continuousAxis === 'x' ? 'xError' : 'yError',\n    oldContinuousAxisChannelDefError = _b[_e],\n    _f = continuousAxis === 'x' ? 'xError2' : 'yError2',\n    oldContinuousAxisChannelDefError2 = _b[_f],\n    oldEncodingWithoutContinuousAxis = __rest(_b, [typeof _c === \"symbol\" ? _c : _c + \"\", typeof _d === \"symbol\" ? _d : _d + \"\", typeof _e === \"symbol\" ? _e : _e + \"\", typeof _f === \"symbol\" ? _f : _f + \"\"]);\n  var _extractTransformsFro = extractTransformsFromEncoding(oldEncodingWithoutContinuousAxis, config),\n    bins = _extractTransformsFro.bins,\n    timeUnits = _extractTransformsFro.timeUnits,\n    oldAggregate = _extractTransformsFro.aggregate,\n    oldGroupBy = _extractTransformsFro.groupby,\n    encodingWithoutContinuousAxis = _extractTransformsFro.encoding;\n  var aggregate = [].concat(_toConsumableArray(oldAggregate), _toConsumableArray(errorBarSpecificAggregate));\n  var groupby = inputType !== 'raw' ? [] : oldGroupBy;\n  var tooltipEncoding = getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, tooltipTitleWithFieldName);\n  return {\n    transform: [].concat(_toConsumableArray((_a = outerSpec.transform) !== null && _a !== void 0 ? _a : []), _toConsumableArray(bins), _toConsumableArray(timeUnits), _toConsumableArray(aggregate.length === 0 ? [] : [{\n      aggregate: aggregate,\n      groupby: groupby\n    }]), _toConsumableArray(postAggregateCalculates)),\n    groupby: groupby,\n    continuousAxisChannelDef: continuousAxisChannelDef,\n    continuousAxis: continuousAxis,\n    encodingWithoutContinuousAxis: encodingWithoutContinuousAxis,\n    ticksOrient: orient === 'vertical' ? 'horizontal' : 'vertical',\n    markDef: markDef,\n    outerSpec: outerSpec,\n    tooltipEncoding: tooltipEncoding\n  };\n}\nfunction errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config) {\n  var errorBarSpecificAggregate = [];\n  var postAggregateCalculates = [];\n  var continuousFieldName = continuousAxisChannelDef.field;\n  var tooltipSummary;\n  var tooltipTitleWithFieldName = false;\n  if (inputType === 'raw') {\n    var center = markDef.center ? markDef.center : markDef.extent ? markDef.extent === 'iqr' ? 'median' : 'mean' : config.errorbar.center;\n    var extent = markDef.extent ? markDef.extent : center === 'mean' ? 'stderr' : 'iqr';\n    if (center === 'median' !== (extent === 'iqr')) {\n      log.warn(log.message.errorBarCenterIsUsedWithWrongExtent(center, extent, compositeMark));\n    }\n    if (extent === 'stderr' || extent === 'stdev') {\n      errorBarSpecificAggregate = [{\n        op: extent,\n        field: continuousFieldName,\n        as: \"extent_\".concat(continuousFieldName)\n      }, {\n        op: center,\n        field: continuousFieldName,\n        as: \"center_\".concat(continuousFieldName)\n      }];\n      postAggregateCalculates = [{\n        calculate: \"datum[\\\"center_\".concat(continuousFieldName, \"\\\"] + datum[\\\"extent_\").concat(continuousFieldName, \"\\\"]\"),\n        as: \"upper_\".concat(continuousFieldName)\n      }, {\n        calculate: \"datum[\\\"center_\".concat(continuousFieldName, \"\\\"] - datum[\\\"extent_\").concat(continuousFieldName, \"\\\"]\"),\n        as: \"lower_\".concat(continuousFieldName)\n      }];\n      tooltipSummary = [{\n        fieldPrefix: 'center_',\n        titlePrefix: titleCase(center)\n      }, {\n        fieldPrefix: 'upper_',\n        titlePrefix: getTitlePrefix(center, extent, '+')\n      }, {\n        fieldPrefix: 'lower_',\n        titlePrefix: getTitlePrefix(center, extent, '-')\n      }];\n      tooltipTitleWithFieldName = true;\n    } else {\n      var centerOp;\n      var lowerExtentOp;\n      var upperExtentOp;\n      if (extent === 'ci') {\n        centerOp = 'mean';\n        lowerExtentOp = 'ci0';\n        upperExtentOp = 'ci1';\n      } else {\n        centerOp = 'median';\n        lowerExtentOp = 'q1';\n        upperExtentOp = 'q3';\n      }\n      errorBarSpecificAggregate = [{\n        op: lowerExtentOp,\n        field: continuousFieldName,\n        as: \"lower_\".concat(continuousFieldName)\n      }, {\n        op: upperExtentOp,\n        field: continuousFieldName,\n        as: \"upper_\".concat(continuousFieldName)\n      }, {\n        op: centerOp,\n        field: continuousFieldName,\n        as: \"center_\".concat(continuousFieldName)\n      }];\n      tooltipSummary = [{\n        fieldPrefix: 'upper_',\n        titlePrefix: title({\n          field: continuousFieldName,\n          aggregate: upperExtentOp,\n          type: 'quantitative'\n        }, config, {\n          allowDisabling: false\n        })\n      }, {\n        fieldPrefix: 'lower_',\n        titlePrefix: title({\n          field: continuousFieldName,\n          aggregate: lowerExtentOp,\n          type: 'quantitative'\n        }, config, {\n          allowDisabling: false\n        })\n      }, {\n        fieldPrefix: 'center_',\n        titlePrefix: title({\n          field: continuousFieldName,\n          aggregate: centerOp,\n          type: 'quantitative'\n        }, config, {\n          allowDisabling: false\n        })\n      }];\n    }\n  } else {\n    if (markDef.center || markDef.extent) {\n      log.warn(log.message.errorBarCenterAndExtentAreNotNeeded(markDef.center, markDef.extent));\n    }\n    if (inputType === 'aggregated-upper-lower') {\n      tooltipSummary = [];\n      postAggregateCalculates = [{\n        calculate: \"datum[\\\"\".concat(continuousAxisChannelDef2.field, \"\\\"]\"),\n        as: \"upper_\".concat(continuousFieldName)\n      }, {\n        calculate: \"datum[\\\"\".concat(continuousFieldName, \"\\\"]\"),\n        as: \"lower_\".concat(continuousFieldName)\n      }];\n    } else if (inputType === 'aggregated-error') {\n      tooltipSummary = [{\n        fieldPrefix: '',\n        titlePrefix: continuousFieldName\n      }];\n      postAggregateCalculates = [{\n        calculate: \"datum[\\\"\".concat(continuousFieldName, \"\\\"] + datum[\\\"\").concat(continuousAxisChannelDefError.field, \"\\\"]\"),\n        as: \"upper_\".concat(continuousFieldName)\n      }];\n      if (continuousAxisChannelDefError2) {\n        postAggregateCalculates.push({\n          calculate: \"datum[\\\"\".concat(continuousFieldName, \"\\\"] + datum[\\\"\").concat(continuousAxisChannelDefError2.field, \"\\\"]\"),\n          as: \"lower_\".concat(continuousFieldName)\n        });\n      } else {\n        postAggregateCalculates.push({\n          calculate: \"datum[\\\"\".concat(continuousFieldName, \"\\\"] - datum[\\\"\").concat(continuousAxisChannelDefError.field, \"\\\"]\"),\n          as: \"lower_\".concat(continuousFieldName)\n        });\n      }\n    }\n    var _iterator = _createForOfIteratorHelper(postAggregateCalculates),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var postAggregateCalculate = _step.value;\n        tooltipSummary.push({\n          fieldPrefix: postAggregateCalculate.as.substring(0, 6),\n          titlePrefix: replaceAll(replaceAll(postAggregateCalculate.calculate, 'datum[\"', ''), '\"]', '')\n        });\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return {\n    postAggregateCalculates: postAggregateCalculates,\n    errorBarSpecificAggregate: errorBarSpecificAggregate,\n    tooltipSummary: tooltipSummary,\n    tooltipTitleWithFieldName: tooltipTitleWithFieldName\n  };\n}\nfunction getTitlePrefix(center, extent, operation) {\n  return \"\".concat(titleCase(center), \" \").concat(operation, \" \").concat(extent);\n}","map":{"version":3,"sources":["../../../src/compositemark/errorbar.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isContinuousFieldOrDatumDef, isFieldOrDatumDef, title } from '../channeldef';\nimport { extractTransformsFromEncoding, normalizeEncoding } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { replaceAll, titleCase } from '../util';\nimport { CompositeMarkNormalizer } from './base';\nimport { compositeMarkContinuousAxis, compositeMarkOrient, getCompositeMarkTooltip, makeCompositeAggregatePartFactory } from './common';\nexport const ERRORBAR = 'errorbar';\nexport const ERRORBAR_PARTS = ['ticks', 'rule'];\nexport const errorBarNormalizer = new CompositeMarkNormalizer(ERRORBAR, normalizeErrorBar);\nexport function normalizeErrorBar(spec, { config }) {\n    // Need to initEncoding first so we can infer type\n    spec = Object.assign(Object.assign({}, spec), { encoding: normalizeEncoding(spec.encoding, config) });\n    const { transform, continuousAxisChannelDef, continuousAxis, encodingWithoutContinuousAxis, ticksOrient, markDef, outerSpec, tooltipEncoding } = errorBarParams(spec, ERRORBAR, config);\n    delete encodingWithoutContinuousAxis['size'];\n    const makeErrorBarPart = makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, config.errorbar);\n    const thickness = markDef.thickness;\n    const size = markDef.size;\n    const tick = Object.assign(Object.assign({ type: 'tick', orient: ticksOrient, aria: false }, (thickness !== undefined ? { thickness } : {})), (size !== undefined ? { size } : {}));\n    const layer = [\n        ...makeErrorBarPart({\n            partName: 'ticks',\n            mark: tick,\n            positionPrefix: 'lower',\n            extraEncoding: tooltipEncoding\n        }),\n        ...makeErrorBarPart({\n            partName: 'ticks',\n            mark: tick,\n            positionPrefix: 'upper',\n            extraEncoding: tooltipEncoding\n        }),\n        ...makeErrorBarPart({\n            partName: 'rule',\n            mark: Object.assign({ type: 'rule', ariaRoleDescription: 'errorbar' }, (thickness !== undefined ? { size: thickness } : {})),\n            positionPrefix: 'lower',\n            endPositionPrefix: 'upper',\n            extraEncoding: tooltipEncoding\n        })\n    ];\n    return Object.assign(Object.assign(Object.assign({}, outerSpec), { transform }), (layer.length > 1 ? { layer } : Object.assign({}, layer[0])));\n}\nfunction errorBarOrientAndInputType(spec, compositeMark) {\n    const { encoding } = spec;\n    if (errorBarIsInputTypeRaw(encoding)) {\n        return {\n            orient: compositeMarkOrient(spec, compositeMark),\n            inputType: 'raw'\n        };\n    }\n    const isTypeAggregatedUpperLower = errorBarIsInputTypeAggregatedUpperLower(encoding);\n    const isTypeAggregatedError = errorBarIsInputTypeAggregatedError(encoding);\n    const x = encoding.x;\n    const y = encoding.y;\n    if (isTypeAggregatedUpperLower) {\n        // type is aggregated-upper-lower\n        if (isTypeAggregatedError) {\n            throw new Error(`${compositeMark} cannot be both type aggregated-upper-lower and aggregated-error`);\n        }\n        const x2 = encoding.x2;\n        const y2 = encoding.y2;\n        if (isFieldOrDatumDef(x2) && isFieldOrDatumDef(y2)) {\n            // having both x, x2 and y, y2\n            throw new Error(`${compositeMark} cannot have both x2 and y2`);\n        }\n        else if (isFieldOrDatumDef(x2)) {\n            if (isContinuousFieldOrDatumDef(x)) {\n                // having x, x2 quantitative and field y, y2 are not specified\n                return { orient: 'horizontal', inputType: 'aggregated-upper-lower' };\n            }\n            else {\n                // having x, x2 that are not both quantitative\n                throw new Error(`Both x and x2 have to be quantitative in ${compositeMark}`);\n            }\n        }\n        else if (isFieldOrDatumDef(y2)) {\n            // y2 is a FieldDef\n            if (isContinuousFieldOrDatumDef(y)) {\n                // having y, y2 quantitative and field x, x2 are not specified\n                return { orient: 'vertical', inputType: 'aggregated-upper-lower' };\n            }\n            else {\n                // having y, y2 that are not both quantitative\n                throw new Error(`Both y and y2 have to be quantitative in ${compositeMark}`);\n            }\n        }\n        throw new Error('No ranged axis');\n    }\n    else {\n        // type is aggregated-error\n        const xError = encoding.xError;\n        const xError2 = encoding.xError2;\n        const yError = encoding.yError;\n        const yError2 = encoding.yError2;\n        if (isFieldOrDatumDef(xError2) && !isFieldOrDatumDef(xError)) {\n            // having xError2 without xError\n            throw new Error(`${compositeMark} cannot have xError2 without xError`);\n        }\n        if (isFieldOrDatumDef(yError2) && !isFieldOrDatumDef(yError)) {\n            // having yError2 without yError\n            throw new Error(`${compositeMark} cannot have yError2 without yError`);\n        }\n        if (isFieldOrDatumDef(xError) && isFieldOrDatumDef(yError)) {\n            // having both xError and yError\n            throw new Error(`${compositeMark} cannot have both xError and yError with both are quantiative`);\n        }\n        else if (isFieldOrDatumDef(xError)) {\n            if (isContinuousFieldOrDatumDef(x)) {\n                // having x and xError that are all quantitative\n                return { orient: 'horizontal', inputType: 'aggregated-error' };\n            }\n            else {\n                // having x, xError, and xError2 that are not all quantitative\n                throw new Error('All x, xError, and xError2 (if exist) have to be quantitative');\n            }\n        }\n        else if (isFieldOrDatumDef(yError)) {\n            if (isContinuousFieldOrDatumDef(y)) {\n                // having y and yError that are all quantitative\n                return { orient: 'vertical', inputType: 'aggregated-error' };\n            }\n            else {\n                // having y, yError, and yError2 that are not all quantitative\n                throw new Error('All y, yError, and yError2 (if exist) have to be quantitative');\n            }\n        }\n        throw new Error('No ranged axis');\n    }\n}\nfunction errorBarIsInputTypeRaw(encoding) {\n    return ((isFieldOrDatumDef(encoding.x) || isFieldOrDatumDef(encoding.y)) &&\n        !isFieldOrDatumDef(encoding.x2) &&\n        !isFieldOrDatumDef(encoding.y2) &&\n        !isFieldOrDatumDef(encoding.xError) &&\n        !isFieldOrDatumDef(encoding.xError2) &&\n        !isFieldOrDatumDef(encoding.yError) &&\n        !isFieldOrDatumDef(encoding.yError2));\n}\nfunction errorBarIsInputTypeAggregatedUpperLower(encoding) {\n    return isFieldOrDatumDef(encoding.x2) || isFieldOrDatumDef(encoding.y2);\n}\nfunction errorBarIsInputTypeAggregatedError(encoding) {\n    return (isFieldOrDatumDef(encoding.xError) ||\n        isFieldOrDatumDef(encoding.xError2) ||\n        isFieldOrDatumDef(encoding.yError) ||\n        isFieldOrDatumDef(encoding.yError2));\n}\nexport function errorBarParams(spec, compositeMark, config) {\n    var _a;\n    // TODO: use selection\n    const { mark, encoding, params, projection: _p } = spec, outerSpec = __rest(spec, [\"mark\", \"encoding\", \"params\", \"projection\"]);\n    const markDef = isMarkDef(mark) ? mark : { type: mark };\n    // TODO(https://github.com/vega/vega-lite/issues/3702): add selection support\n    if (params) {\n        log.warn(log.message.selectionNotSupported(compositeMark));\n    }\n    const { orient, inputType } = errorBarOrientAndInputType(spec, compositeMark);\n    const { continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, continuousAxis } = compositeMarkContinuousAxis(spec, orient, compositeMark);\n    const { errorBarSpecificAggregate, postAggregateCalculates, tooltipSummary, tooltipTitleWithFieldName } = errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config);\n    const _b = encoding, _c = continuousAxis, oldContinuousAxisChannelDef = _b[_c], _d = continuousAxis === 'x' ? 'x2' : 'y2', oldContinuousAxisChannelDef2 = _b[_d], _e = continuousAxis === 'x' ? 'xError' : 'yError', oldContinuousAxisChannelDefError = _b[_e], _f = continuousAxis === 'x' ? 'xError2' : 'yError2', oldContinuousAxisChannelDefError2 = _b[_f], oldEncodingWithoutContinuousAxis = __rest(_b, [typeof _c === \"symbol\" ? _c : _c + \"\", typeof _d === \"symbol\" ? _d : _d + \"\", typeof _e === \"symbol\" ? _e : _e + \"\", typeof _f === \"symbol\" ? _f : _f + \"\"]);\n    const { bins, timeUnits, aggregate: oldAggregate, groupby: oldGroupBy, encoding: encodingWithoutContinuousAxis } = extractTransformsFromEncoding(oldEncodingWithoutContinuousAxis, config);\n    const aggregate = [...oldAggregate, ...errorBarSpecificAggregate];\n    const groupby = inputType !== 'raw' ? [] : oldGroupBy;\n    const tooltipEncoding = getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, tooltipTitleWithFieldName);\n    return {\n        transform: [\n            ...((_a = outerSpec.transform) !== null && _a !== void 0 ? _a : []),\n            ...bins,\n            ...timeUnits,\n            ...(aggregate.length === 0 ? [] : [{ aggregate, groupby }]),\n            ...postAggregateCalculates\n        ],\n        groupby,\n        continuousAxisChannelDef,\n        continuousAxis,\n        encodingWithoutContinuousAxis,\n        ticksOrient: orient === 'vertical' ? 'horizontal' : 'vertical',\n        markDef,\n        outerSpec,\n        tooltipEncoding\n    };\n}\nfunction errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config) {\n    let errorBarSpecificAggregate = [];\n    let postAggregateCalculates = [];\n    const continuousFieldName = continuousAxisChannelDef.field;\n    let tooltipSummary;\n    let tooltipTitleWithFieldName = false;\n    if (inputType === 'raw') {\n        const center = markDef.center\n            ? markDef.center\n            : markDef.extent\n                ? markDef.extent === 'iqr'\n                    ? 'median'\n                    : 'mean'\n                : config.errorbar.center;\n        const extent = markDef.extent ? markDef.extent : center === 'mean' ? 'stderr' : 'iqr';\n        if ((center === 'median') !== (extent === 'iqr')) {\n            log.warn(log.message.errorBarCenterIsUsedWithWrongExtent(center, extent, compositeMark));\n        }\n        if (extent === 'stderr' || extent === 'stdev') {\n            errorBarSpecificAggregate = [\n                { op: extent, field: continuousFieldName, as: `extent_${continuousFieldName}` },\n                { op: center, field: continuousFieldName, as: `center_${continuousFieldName}` }\n            ];\n            postAggregateCalculates = [\n                {\n                    calculate: `datum[\"center_${continuousFieldName}\"] + datum[\"extent_${continuousFieldName}\"]`,\n                    as: `upper_${continuousFieldName}`\n                },\n                {\n                    calculate: `datum[\"center_${continuousFieldName}\"] - datum[\"extent_${continuousFieldName}\"]`,\n                    as: `lower_${continuousFieldName}`\n                }\n            ];\n            tooltipSummary = [\n                { fieldPrefix: 'center_', titlePrefix: titleCase(center) },\n                { fieldPrefix: 'upper_', titlePrefix: getTitlePrefix(center, extent, '+') },\n                { fieldPrefix: 'lower_', titlePrefix: getTitlePrefix(center, extent, '-') }\n            ];\n            tooltipTitleWithFieldName = true;\n        }\n        else {\n            let centerOp;\n            let lowerExtentOp;\n            let upperExtentOp;\n            if (extent === 'ci') {\n                centerOp = 'mean';\n                lowerExtentOp = 'ci0';\n                upperExtentOp = 'ci1';\n            }\n            else {\n                centerOp = 'median';\n                lowerExtentOp = 'q1';\n                upperExtentOp = 'q3';\n            }\n            errorBarSpecificAggregate = [\n                { op: lowerExtentOp, field: continuousFieldName, as: `lower_${continuousFieldName}` },\n                { op: upperExtentOp, field: continuousFieldName, as: `upper_${continuousFieldName}` },\n                { op: centerOp, field: continuousFieldName, as: `center_${continuousFieldName}` }\n            ];\n            tooltipSummary = [\n                {\n                    fieldPrefix: 'upper_',\n                    titlePrefix: title({ field: continuousFieldName, aggregate: upperExtentOp, type: 'quantitative' }, config, {\n                        allowDisabling: false\n                    })\n                },\n                {\n                    fieldPrefix: 'lower_',\n                    titlePrefix: title({ field: continuousFieldName, aggregate: lowerExtentOp, type: 'quantitative' }, config, {\n                        allowDisabling: false\n                    })\n                },\n                {\n                    fieldPrefix: 'center_',\n                    titlePrefix: title({ field: continuousFieldName, aggregate: centerOp, type: 'quantitative' }, config, {\n                        allowDisabling: false\n                    })\n                }\n            ];\n        }\n    }\n    else {\n        if (markDef.center || markDef.extent) {\n            log.warn(log.message.errorBarCenterAndExtentAreNotNeeded(markDef.center, markDef.extent));\n        }\n        if (inputType === 'aggregated-upper-lower') {\n            tooltipSummary = [];\n            postAggregateCalculates = [\n                { calculate: `datum[\"${continuousAxisChannelDef2.field}\"]`, as: `upper_${continuousFieldName}` },\n                { calculate: `datum[\"${continuousFieldName}\"]`, as: `lower_${continuousFieldName}` }\n            ];\n        }\n        else if (inputType === 'aggregated-error') {\n            tooltipSummary = [{ fieldPrefix: '', titlePrefix: continuousFieldName }];\n            postAggregateCalculates = [\n                {\n                    calculate: `datum[\"${continuousFieldName}\"] + datum[\"${continuousAxisChannelDefError.field}\"]`,\n                    as: `upper_${continuousFieldName}`\n                }\n            ];\n            if (continuousAxisChannelDefError2) {\n                postAggregateCalculates.push({\n                    calculate: `datum[\"${continuousFieldName}\"] + datum[\"${continuousAxisChannelDefError2.field}\"]`,\n                    as: `lower_${continuousFieldName}`\n                });\n            }\n            else {\n                postAggregateCalculates.push({\n                    calculate: `datum[\"${continuousFieldName}\"] - datum[\"${continuousAxisChannelDefError.field}\"]`,\n                    as: `lower_${continuousFieldName}`\n                });\n            }\n        }\n        for (const postAggregateCalculate of postAggregateCalculates) {\n            tooltipSummary.push({\n                fieldPrefix: postAggregateCalculate.as.substring(0, 6),\n                titlePrefix: replaceAll(replaceAll(postAggregateCalculate.calculate, 'datum[\"', ''), '\"]', '')\n            });\n        }\n    }\n    return { postAggregateCalculates, errorBarSpecificAggregate, tooltipSummary, tooltipTitleWithFieldName };\n}\nfunction getTitlePrefix(center, extent, operation) {\n    return `${titleCase(center)} ${operation} ${extent}`;\n}\n//# sourceMappingURL=errorbar.js.map"]},"metadata":{},"sourceType":"module"}