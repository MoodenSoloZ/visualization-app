{"ast":null,"code":"/*\n * Constants and utilities for encoding channels (Visual variables)\n * such as 'x', 'y', 'color'.\n */\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { keys } from './util';\n// Facet\nexport var ROW = 'row';\nexport var COLUMN = 'column';\nexport var FACET = 'facet';\n// Position\nexport var X = 'x';\nexport var Y = 'y';\nexport var X2 = 'x2';\nexport var Y2 = 'y2';\n// Position Offset\nexport var XOFFSET = 'xOffset';\nexport var YOFFSET = 'yOffset';\n// Arc-Position\nexport var RADIUS = 'radius';\nexport var RADIUS2 = 'radius2';\nexport var THETA = 'theta';\nexport var THETA2 = 'theta2';\n// Geo Position\nexport var LATITUDE = 'latitude';\nexport var LONGITUDE = 'longitude';\nexport var LATITUDE2 = 'latitude2';\nexport var LONGITUDE2 = 'longitude2';\n// Mark property with scale\nexport var COLOR = 'color';\nexport var FILL = 'fill';\nexport var STROKE = 'stroke';\nexport var SHAPE = 'shape';\nexport var SIZE = 'size';\nexport var ANGLE = 'angle';\nexport var OPACITY = 'opacity';\nexport var FILLOPACITY = 'fillOpacity';\nexport var STROKEOPACITY = 'strokeOpacity';\nexport var STROKEWIDTH = 'strokeWidth';\nexport var STROKEDASH = 'strokeDash';\n// Non-scale channel\nexport var TEXT = 'text';\nexport var ORDER = 'order';\nexport var DETAIL = 'detail';\nexport var KEY = 'key';\nexport var TOOLTIP = 'tooltip';\nexport var HREF = 'href';\nexport var URL = 'url';\nexport var DESCRIPTION = 'description';\nvar POSITION_CHANNEL_INDEX = {\n  x: 1,\n  y: 1,\n  x2: 1,\n  y2: 1\n};\nvar POLAR_POSITION_CHANNEL_INDEX = {\n  theta: 1,\n  theta2: 1,\n  radius: 1,\n  radius2: 1\n};\nexport function isPolarPositionChannel(c) {\n  return c in POLAR_POSITION_CHANNEL_INDEX;\n}\nvar GEO_POSIITON_CHANNEL_INDEX = {\n  longitude: 1,\n  longitude2: 1,\n  latitude: 1,\n  latitude2: 1\n};\nexport function getPositionChannelFromLatLong(channel) {\n  switch (channel) {\n    case LATITUDE:\n      return 'y';\n    case LATITUDE2:\n      return 'y2';\n    case LONGITUDE:\n      return 'x';\n    case LONGITUDE2:\n      return 'x2';\n  }\n}\nexport function isGeoPositionChannel(c) {\n  return c in GEO_POSIITON_CHANNEL_INDEX;\n}\nexport var GEOPOSITION_CHANNELS = keys(GEO_POSIITON_CHANNEL_INDEX);\nvar UNIT_CHANNEL_INDEX = Object.assign(Object.assign(Object.assign(Object.assign({}, POSITION_CHANNEL_INDEX), POLAR_POSITION_CHANNEL_INDEX), GEO_POSIITON_CHANNEL_INDEX), {\n  xOffset: 1,\n  yOffset: 1,\n  // color\n  color: 1,\n  fill: 1,\n  stroke: 1,\n  // other non-position with scale\n  opacity: 1,\n  fillOpacity: 1,\n  strokeOpacity: 1,\n  strokeWidth: 1,\n  strokeDash: 1,\n  size: 1,\n  angle: 1,\n  shape: 1,\n  // channels without scales\n  order: 1,\n  text: 1,\n  detail: 1,\n  key: 1,\n  tooltip: 1,\n  href: 1,\n  url: 1,\n  description: 1\n});\nexport function isColorChannel(channel) {\n  return channel === COLOR || channel === FILL || channel === STROKE;\n}\nvar FACET_CHANNEL_INDEX = {\n  row: 1,\n  column: 1,\n  facet: 1\n};\nexport var FACET_CHANNELS = keys(FACET_CHANNEL_INDEX);\nvar CHANNEL_INDEX = Object.assign(Object.assign({}, UNIT_CHANNEL_INDEX), FACET_CHANNEL_INDEX);\nexport var CHANNELS = keys(CHANNEL_INDEX);\nvar _o = CHANNEL_INDEX.order,\n  _d = CHANNEL_INDEX.detail,\n  _tt1 = CHANNEL_INDEX.tooltip,\n  SINGLE_DEF_CHANNEL_INDEX = __rest(CHANNEL_INDEX, [\"order\", \"detail\", \"tooltip\"]);\nvar _r = SINGLE_DEF_CHANNEL_INDEX.row,\n  _c = SINGLE_DEF_CHANNEL_INDEX.column,\n  _f = SINGLE_DEF_CHANNEL_INDEX.facet,\n  SINGLE_DEF_UNIT_CHANNEL_INDEX = __rest(SINGLE_DEF_CHANNEL_INDEX, [\"row\", \"column\", \"facet\"]);\n/**\n * Channels that cannot have an array of channelDef.\n * model.fieldDef, getFieldDef only work for these channels.\n *\n * (The only two channels that can have an array of channelDefs are \"detail\" and \"order\".\n * Since there can be multiple fieldDefs for detail and order, getFieldDef/model.fieldDef\n * are not applicable for them. Similarly, selection projection won't work with \"detail\" and \"order\".)\n */\nexport var SINGLE_DEF_CHANNELS = keys(SINGLE_DEF_CHANNEL_INDEX);\nexport var SINGLE_DEF_UNIT_CHANNELS = keys(SINGLE_DEF_UNIT_CHANNEL_INDEX);\nexport function isSingleDefUnitChannel(str) {\n  return !!SINGLE_DEF_UNIT_CHANNEL_INDEX[str];\n}\nexport function isChannel(str) {\n  return !!CHANNEL_INDEX[str];\n}\nexport var SECONDARY_RANGE_CHANNEL = [X2, Y2, LATITUDE2, LONGITUDE2, THETA2, RADIUS2];\nexport function isSecondaryRangeChannel(c) {\n  var main = getMainRangeChannel(c);\n  return main !== c;\n}\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\nexport function getMainRangeChannel(channel) {\n  switch (channel) {\n    case X2:\n      return X;\n    case Y2:\n      return Y;\n    case LATITUDE2:\n      return LATITUDE;\n    case LONGITUDE2:\n      return LONGITUDE;\n    case THETA2:\n      return THETA;\n    case RADIUS2:\n      return RADIUS;\n  }\n  return channel;\n}\nexport function getVgPositionChannel(channel) {\n  if (isPolarPositionChannel(channel)) {\n    switch (channel) {\n      case THETA:\n        return 'startAngle';\n      case THETA2:\n        return 'endAngle';\n      case RADIUS:\n        return 'outerRadius';\n      case RADIUS2:\n        return 'innerRadius';\n    }\n  }\n  return channel;\n}\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\nexport function getSecondaryRangeChannel(channel) {\n  switch (channel) {\n    case X:\n      return X2;\n    case Y:\n      return Y2;\n    case LATITUDE:\n      return LATITUDE2;\n    case LONGITUDE:\n      return LONGITUDE2;\n    case THETA:\n      return THETA2;\n    case RADIUS:\n      return RADIUS2;\n  }\n  return undefined;\n}\nexport function getSizeChannel(channel) {\n  switch (channel) {\n    case X:\n    case X2:\n      return 'width';\n    case Y:\n    case Y2:\n      return 'height';\n  }\n  return undefined;\n}\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\nexport function getOffsetChannel(channel) {\n  switch (channel) {\n    case X:\n      return 'xOffset';\n    case Y:\n      return 'yOffset';\n    case X2:\n      return 'x2Offset';\n    case Y2:\n      return 'y2Offset';\n    case THETA:\n      return 'thetaOffset';\n    case RADIUS:\n      return 'radiusOffset';\n    case THETA2:\n      return 'theta2Offset';\n    case RADIUS2:\n      return 'radius2Offset';\n  }\n  return undefined;\n}\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\nexport function getOffsetScaleChannel(channel) {\n  switch (channel) {\n    case X:\n      return 'xOffset';\n    case Y:\n      return 'yOffset';\n  }\n  return undefined;\n}\nexport function getMainChannelFromOffsetChannel(channel) {\n  switch (channel) {\n    case 'xOffset':\n      return 'x';\n    case 'yOffset':\n      return 'y';\n  }\n}\n// CHANNELS without COLUMN, ROW\nexport var UNIT_CHANNELS = keys(UNIT_CHANNEL_INDEX);\n// NONPOSITION_CHANNELS = UNIT_CHANNELS without X, Y, X2, Y2;\nvar _x = UNIT_CHANNEL_INDEX.x,\n  _y = UNIT_CHANNEL_INDEX.y,\n  _x2 = UNIT_CHANNEL_INDEX.x2,\n  _y2 = UNIT_CHANNEL_INDEX.y2,\n  _xo = UNIT_CHANNEL_INDEX.xOffset,\n  _yo = UNIT_CHANNEL_INDEX.yOffset,\n  _latitude = UNIT_CHANNEL_INDEX.latitude,\n  _longitude = UNIT_CHANNEL_INDEX.longitude,\n  _latitude2 = UNIT_CHANNEL_INDEX.latitude2,\n  _longitude2 = UNIT_CHANNEL_INDEX.longitude2,\n  _theta = UNIT_CHANNEL_INDEX.theta,\n  _theta2 = UNIT_CHANNEL_INDEX.theta2,\n  _radius = UNIT_CHANNEL_INDEX.radius,\n  _radius2 = UNIT_CHANNEL_INDEX.radius2,\n  NONPOSITION_CHANNEL_INDEX = __rest(UNIT_CHANNEL_INDEX, [\"x\", \"y\", \"x2\", \"y2\", \"xOffset\", \"yOffset\", \"latitude\", \"longitude\", \"latitude2\", \"longitude2\", \"theta\", \"theta2\", \"radius\", \"radius2\"]);\nexport var NONPOSITION_CHANNELS = keys(NONPOSITION_CHANNEL_INDEX);\nvar POSITION_SCALE_CHANNEL_INDEX = {\n  x: 1,\n  y: 1\n};\nexport var POSITION_SCALE_CHANNELS = keys(POSITION_SCALE_CHANNEL_INDEX);\nexport function isXorY(channel) {\n  return channel in POSITION_SCALE_CHANNEL_INDEX;\n}\nexport var POLAR_POSITION_SCALE_CHANNEL_INDEX = {\n  theta: 1,\n  radius: 1\n};\nexport var POLAR_POSITION_SCALE_CHANNELS = keys(POLAR_POSITION_SCALE_CHANNEL_INDEX);\nexport function getPositionScaleChannel(sizeType) {\n  return sizeType === 'width' ? X : Y;\n}\nvar OFFSET_SCALE_CHANNEL_INDEX = {\n  xOffset: 1,\n  yOffset: 1\n};\nexport var OFFSET_SCALE_CHANNELS = keys(OFFSET_SCALE_CHANNEL_INDEX);\nexport function isXorYOffset(channel) {\n  return channel in OFFSET_SCALE_CHANNEL_INDEX;\n}\n// NON_POSITION_SCALE_CHANNEL = SCALE_CHANNELS without position / offset\nvar _t = NONPOSITION_CHANNEL_INDEX.text,\n  _tt = NONPOSITION_CHANNEL_INDEX.tooltip,\n  _hr = NONPOSITION_CHANNEL_INDEX.href,\n  _u = NONPOSITION_CHANNEL_INDEX.url,\n  _al = NONPOSITION_CHANNEL_INDEX.description,\n  _dd = NONPOSITION_CHANNEL_INDEX.detail,\n  _k = NONPOSITION_CHANNEL_INDEX.key,\n  _oo = NONPOSITION_CHANNEL_INDEX.order,\n  NONPOSITION_SCALE_CHANNEL_INDEX = __rest(NONPOSITION_CHANNEL_INDEX, [\"text\", \"tooltip\", \"href\", \"url\", \"description\", \"detail\", \"key\", \"order\"]);\nexport var NONPOSITION_SCALE_CHANNELS = keys(NONPOSITION_SCALE_CHANNEL_INDEX);\nexport function isNonPositionScaleChannel(channel) {\n  return !!NONPOSITION_CHANNEL_INDEX[channel];\n}\n/**\n * @returns whether Vega supports legends for a particular channel\n */\nexport function supportLegend(channel) {\n  switch (channel) {\n    case COLOR:\n    case FILL:\n    case STROKE:\n    case SIZE:\n    case SHAPE:\n    case OPACITY:\n    case STROKEWIDTH:\n    case STROKEDASH:\n      return true;\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    case ANGLE:\n      return false;\n  }\n}\n// Declare SCALE_CHANNEL_INDEX\nvar SCALE_CHANNEL_INDEX = Object.assign(Object.assign(Object.assign(Object.assign({}, POSITION_SCALE_CHANNEL_INDEX), POLAR_POSITION_SCALE_CHANNEL_INDEX), OFFSET_SCALE_CHANNEL_INDEX), NONPOSITION_SCALE_CHANNEL_INDEX);\n/** List of channels with scales */\nexport var SCALE_CHANNELS = keys(SCALE_CHANNEL_INDEX);\nexport function isScaleChannel(channel) {\n  return !!SCALE_CHANNEL_INDEX[channel];\n}\n/**\n * Return whether a channel supports a particular mark type.\n * @param channel  channel name\n * @param mark the mark type\n * @return whether the mark supports the channel\n */\nexport function supportMark(channel, mark) {\n  return getSupportedMark(channel)[mark];\n}\nvar ALL_MARKS = {\n  // all marks\n  arc: 'always',\n  area: 'always',\n  bar: 'always',\n  circle: 'always',\n  geoshape: 'always',\n  image: 'always',\n  line: 'always',\n  rule: 'always',\n  point: 'always',\n  rect: 'always',\n  square: 'always',\n  trail: 'always',\n  text: 'always',\n  tick: 'always'\n};\nvar _g = ALL_MARKS.geoshape,\n  ALL_MARKS_EXCEPT_GEOSHAPE = __rest(ALL_MARKS, [\"geoshape\"]);\n/**\n * Return a dictionary showing whether a channel supports mark type.\n * @param channel\n * @return A dictionary mapping mark types to 'always', 'binned', or undefined\n */\nfunction getSupportedMark(channel) {\n  switch (channel) {\n    case COLOR:\n    case FILL:\n    case STROKE:\n    // falls through\n    case DESCRIPTION:\n    case DETAIL:\n    case KEY:\n    case TOOLTIP:\n    case HREF:\n    case ORDER: // TODO: revise (order might not support rect, which is not stackable?)\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    case STROKEWIDTH:\n    // falls through\n    case FACET:\n    case ROW: // falls through\n    case COLUMN:\n      return ALL_MARKS;\n    case X:\n    case Y:\n    case XOFFSET:\n    case YOFFSET:\n    case LATITUDE:\n    case LONGITUDE:\n      // all marks except geoshape. geoshape does not use X, Y -- it uses a projection\n      return ALL_MARKS_EXCEPT_GEOSHAPE;\n    case X2:\n    case Y2:\n    case LATITUDE2:\n    case LONGITUDE2:\n      return {\n        area: 'always',\n        bar: 'always',\n        image: 'always',\n        rect: 'always',\n        rule: 'always',\n        circle: 'binned',\n        point: 'binned',\n        square: 'binned',\n        tick: 'binned',\n        line: 'binned',\n        trail: 'binned'\n      };\n    case SIZE:\n      return {\n        point: 'always',\n        tick: 'always',\n        rule: 'always',\n        circle: 'always',\n        square: 'always',\n        bar: 'always',\n        text: 'always',\n        line: 'always',\n        trail: 'always'\n      };\n    case STROKEDASH:\n      return {\n        line: 'always',\n        point: 'always',\n        tick: 'always',\n        rule: 'always',\n        circle: 'always',\n        square: 'always',\n        bar: 'always',\n        geoshape: 'always'\n      };\n    case SHAPE:\n      return {\n        point: 'always',\n        geoshape: 'always'\n      };\n    case TEXT:\n      return {\n        text: 'always'\n      };\n    case ANGLE:\n      return {\n        point: 'always',\n        square: 'always',\n        text: 'always'\n      };\n    case URL:\n      return {\n        image: 'always'\n      };\n    case THETA:\n      return {\n        text: 'always',\n        arc: 'always'\n      };\n    case RADIUS:\n      return {\n        text: 'always',\n        arc: 'always'\n      };\n    case THETA2:\n    case RADIUS2:\n      return {\n        arc: 'always'\n      };\n  }\n}\nexport function rangeType(channel) {\n  switch (channel) {\n    case X:\n    case Y:\n    case THETA:\n    case RADIUS:\n    case XOFFSET:\n    case YOFFSET:\n    case SIZE:\n    case ANGLE:\n    case STROKEWIDTH:\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    // X2 and Y2 use X and Y scales, so they similarly have continuous range. [falls through]\n    case X2:\n    case Y2:\n    case THETA2:\n    case RADIUS2:\n      return undefined;\n    case FACET:\n    case ROW:\n    case COLUMN:\n    case SHAPE:\n    case STROKEDASH:\n    // TEXT, TOOLTIP, URL, and HREF have no scale but have discrete output [falls through]\n    case TEXT:\n    case TOOLTIP:\n    case HREF:\n    case URL:\n    case DESCRIPTION:\n      return 'discrete';\n    // Color can be either continuous or discrete, depending on scale type.\n    case COLOR:\n    case FILL:\n    case STROKE:\n      return 'flexible';\n    // No scale, no range type.\n    case LATITUDE:\n    case LONGITUDE:\n    case LATITUDE2:\n    case LONGITUDE2:\n    case DETAIL:\n    case KEY:\n    case ORDER:\n      return undefined;\n  }\n}","map":{"version":3,"sources":["../../src/channel.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Constants and utilities for encoding channels (Visual variables)\n * such as 'x', 'y', 'color'.\n */\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { keys } from './util';\n// Facet\nexport const ROW = 'row';\nexport const COLUMN = 'column';\nexport const FACET = 'facet';\n// Position\nexport const X = 'x';\nexport const Y = 'y';\nexport const X2 = 'x2';\nexport const Y2 = 'y2';\n// Position Offset\nexport const XOFFSET = 'xOffset';\nexport const YOFFSET = 'yOffset';\n// Arc-Position\nexport const RADIUS = 'radius';\nexport const RADIUS2 = 'radius2';\nexport const THETA = 'theta';\nexport const THETA2 = 'theta2';\n// Geo Position\nexport const LATITUDE = 'latitude';\nexport const LONGITUDE = 'longitude';\nexport const LATITUDE2 = 'latitude2';\nexport const LONGITUDE2 = 'longitude2';\n// Mark property with scale\nexport const COLOR = 'color';\nexport const FILL = 'fill';\nexport const STROKE = 'stroke';\nexport const SHAPE = 'shape';\nexport const SIZE = 'size';\nexport const ANGLE = 'angle';\nexport const OPACITY = 'opacity';\nexport const FILLOPACITY = 'fillOpacity';\nexport const STROKEOPACITY = 'strokeOpacity';\nexport const STROKEWIDTH = 'strokeWidth';\nexport const STROKEDASH = 'strokeDash';\n// Non-scale channel\nexport const TEXT = 'text';\nexport const ORDER = 'order';\nexport const DETAIL = 'detail';\nexport const KEY = 'key';\nexport const TOOLTIP = 'tooltip';\nexport const HREF = 'href';\nexport const URL = 'url';\nexport const DESCRIPTION = 'description';\nconst POSITION_CHANNEL_INDEX = {\n    x: 1,\n    y: 1,\n    x2: 1,\n    y2: 1\n};\nconst POLAR_POSITION_CHANNEL_INDEX = {\n    theta: 1,\n    theta2: 1,\n    radius: 1,\n    radius2: 1\n};\nexport function isPolarPositionChannel(c) {\n    return c in POLAR_POSITION_CHANNEL_INDEX;\n}\nconst GEO_POSIITON_CHANNEL_INDEX = {\n    longitude: 1,\n    longitude2: 1,\n    latitude: 1,\n    latitude2: 1\n};\nexport function getPositionChannelFromLatLong(channel) {\n    switch (channel) {\n        case LATITUDE:\n            return 'y';\n        case LATITUDE2:\n            return 'y2';\n        case LONGITUDE:\n            return 'x';\n        case LONGITUDE2:\n            return 'x2';\n    }\n}\nexport function isGeoPositionChannel(c) {\n    return c in GEO_POSIITON_CHANNEL_INDEX;\n}\nexport const GEOPOSITION_CHANNELS = keys(GEO_POSIITON_CHANNEL_INDEX);\nconst UNIT_CHANNEL_INDEX = Object.assign(Object.assign(Object.assign(Object.assign({}, POSITION_CHANNEL_INDEX), POLAR_POSITION_CHANNEL_INDEX), GEO_POSIITON_CHANNEL_INDEX), { xOffset: 1, yOffset: 1, \n    // color\n    color: 1, fill: 1, stroke: 1, \n    // other non-position with scale\n    opacity: 1, fillOpacity: 1, strokeOpacity: 1, strokeWidth: 1, strokeDash: 1, size: 1, angle: 1, shape: 1, \n    // channels without scales\n    order: 1, text: 1, detail: 1, key: 1, tooltip: 1, href: 1, url: 1, description: 1 });\nexport function isColorChannel(channel) {\n    return channel === COLOR || channel === FILL || channel === STROKE;\n}\nconst FACET_CHANNEL_INDEX = {\n    row: 1,\n    column: 1,\n    facet: 1\n};\nexport const FACET_CHANNELS = keys(FACET_CHANNEL_INDEX);\nconst CHANNEL_INDEX = Object.assign(Object.assign({}, UNIT_CHANNEL_INDEX), FACET_CHANNEL_INDEX);\nexport const CHANNELS = keys(CHANNEL_INDEX);\nconst { order: _o, detail: _d, tooltip: _tt1 } = CHANNEL_INDEX, SINGLE_DEF_CHANNEL_INDEX = __rest(CHANNEL_INDEX, [\"order\", \"detail\", \"tooltip\"]);\nconst { row: _r, column: _c, facet: _f } = SINGLE_DEF_CHANNEL_INDEX, SINGLE_DEF_UNIT_CHANNEL_INDEX = __rest(SINGLE_DEF_CHANNEL_INDEX, [\"row\", \"column\", \"facet\"]);\n/**\n * Channels that cannot have an array of channelDef.\n * model.fieldDef, getFieldDef only work for these channels.\n *\n * (The only two channels that can have an array of channelDefs are \"detail\" and \"order\".\n * Since there can be multiple fieldDefs for detail and order, getFieldDef/model.fieldDef\n * are not applicable for them. Similarly, selection projection won't work with \"detail\" and \"order\".)\n */\nexport const SINGLE_DEF_CHANNELS = keys(SINGLE_DEF_CHANNEL_INDEX);\nexport const SINGLE_DEF_UNIT_CHANNELS = keys(SINGLE_DEF_UNIT_CHANNEL_INDEX);\nexport function isSingleDefUnitChannel(str) {\n    return !!SINGLE_DEF_UNIT_CHANNEL_INDEX[str];\n}\nexport function isChannel(str) {\n    return !!CHANNEL_INDEX[str];\n}\nexport const SECONDARY_RANGE_CHANNEL = [X2, Y2, LATITUDE2, LONGITUDE2, THETA2, RADIUS2];\nexport function isSecondaryRangeChannel(c) {\n    const main = getMainRangeChannel(c);\n    return main !== c;\n}\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\nexport function getMainRangeChannel(channel) {\n    switch (channel) {\n        case X2:\n            return X;\n        case Y2:\n            return Y;\n        case LATITUDE2:\n            return LATITUDE;\n        case LONGITUDE2:\n            return LONGITUDE;\n        case THETA2:\n            return THETA;\n        case RADIUS2:\n            return RADIUS;\n    }\n    return channel;\n}\nexport function getVgPositionChannel(channel) {\n    if (isPolarPositionChannel(channel)) {\n        switch (channel) {\n            case THETA:\n                return 'startAngle';\n            case THETA2:\n                return 'endAngle';\n            case RADIUS:\n                return 'outerRadius';\n            case RADIUS2:\n                return 'innerRadius';\n        }\n    }\n    return channel;\n}\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\nexport function getSecondaryRangeChannel(channel) {\n    switch (channel) {\n        case X:\n            return X2;\n        case Y:\n            return Y2;\n        case LATITUDE:\n            return LATITUDE2;\n        case LONGITUDE:\n            return LONGITUDE2;\n        case THETA:\n            return THETA2;\n        case RADIUS:\n            return RADIUS2;\n    }\n    return undefined;\n}\nexport function getSizeChannel(channel) {\n    switch (channel) {\n        case X:\n        case X2:\n            return 'width';\n        case Y:\n        case Y2:\n            return 'height';\n    }\n    return undefined;\n}\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\nexport function getOffsetChannel(channel) {\n    switch (channel) {\n        case X:\n            return 'xOffset';\n        case Y:\n            return 'yOffset';\n        case X2:\n            return 'x2Offset';\n        case Y2:\n            return 'y2Offset';\n        case THETA:\n            return 'thetaOffset';\n        case RADIUS:\n            return 'radiusOffset';\n        case THETA2:\n            return 'theta2Offset';\n        case RADIUS2:\n            return 'radius2Offset';\n    }\n    return undefined;\n}\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\nexport function getOffsetScaleChannel(channel) {\n    switch (channel) {\n        case X:\n            return 'xOffset';\n        case Y:\n            return 'yOffset';\n    }\n    return undefined;\n}\nexport function getMainChannelFromOffsetChannel(channel) {\n    switch (channel) {\n        case 'xOffset':\n            return 'x';\n        case 'yOffset':\n            return 'y';\n    }\n}\n// CHANNELS without COLUMN, ROW\nexport const UNIT_CHANNELS = keys(UNIT_CHANNEL_INDEX);\n// NONPOSITION_CHANNELS = UNIT_CHANNELS without X, Y, X2, Y2;\nconst { x: _x, y: _y, \n// x2 and y2 share the same scale as x and y\nx2: _x2, y2: _y2, \n//\nxOffset: _xo, yOffset: _yo, latitude: _latitude, longitude: _longitude, latitude2: _latitude2, longitude2: _longitude2, theta: _theta, theta2: _theta2, radius: _radius, radius2: _radius2 } = UNIT_CHANNEL_INDEX, \n// The rest of unit channels then have scale\nNONPOSITION_CHANNEL_INDEX = __rest(UNIT_CHANNEL_INDEX, [\"x\", \"y\", \"x2\", \"y2\", \"xOffset\", \"yOffset\", \"latitude\", \"longitude\", \"latitude2\", \"longitude2\", \"theta\", \"theta2\", \"radius\", \"radius2\"]);\nexport const NONPOSITION_CHANNELS = keys(NONPOSITION_CHANNEL_INDEX);\nconst POSITION_SCALE_CHANNEL_INDEX = {\n    x: 1,\n    y: 1\n};\nexport const POSITION_SCALE_CHANNELS = keys(POSITION_SCALE_CHANNEL_INDEX);\nexport function isXorY(channel) {\n    return channel in POSITION_SCALE_CHANNEL_INDEX;\n}\nexport const POLAR_POSITION_SCALE_CHANNEL_INDEX = {\n    theta: 1,\n    radius: 1\n};\nexport const POLAR_POSITION_SCALE_CHANNELS = keys(POLAR_POSITION_SCALE_CHANNEL_INDEX);\nexport function getPositionScaleChannel(sizeType) {\n    return sizeType === 'width' ? X : Y;\n}\nconst OFFSET_SCALE_CHANNEL_INDEX = { xOffset: 1, yOffset: 1 };\nexport const OFFSET_SCALE_CHANNELS = keys(OFFSET_SCALE_CHANNEL_INDEX);\nexport function isXorYOffset(channel) {\n    return channel in OFFSET_SCALE_CHANNEL_INDEX;\n}\n// NON_POSITION_SCALE_CHANNEL = SCALE_CHANNELS without position / offset\nconst { \n// x2 and y2 share the same scale as x and y\n// text and tooltip have format instead of scale,\n// href has neither format, nor scale\ntext: _t, tooltip: _tt, href: _hr, url: _u, description: _al, \n// detail and order have no scale\ndetail: _dd, key: _k, order: _oo } = NONPOSITION_CHANNEL_INDEX, NONPOSITION_SCALE_CHANNEL_INDEX = __rest(NONPOSITION_CHANNEL_INDEX, [\"text\", \"tooltip\", \"href\", \"url\", \"description\", \"detail\", \"key\", \"order\"]);\nexport const NONPOSITION_SCALE_CHANNELS = keys(NONPOSITION_SCALE_CHANNEL_INDEX);\nexport function isNonPositionScaleChannel(channel) {\n    return !!NONPOSITION_CHANNEL_INDEX[channel];\n}\n/**\n * @returns whether Vega supports legends for a particular channel\n */\nexport function supportLegend(channel) {\n    switch (channel) {\n        case COLOR:\n        case FILL:\n        case STROKE:\n        case SIZE:\n        case SHAPE:\n        case OPACITY:\n        case STROKEWIDTH:\n        case STROKEDASH:\n            return true;\n        case FILLOPACITY:\n        case STROKEOPACITY:\n        case ANGLE:\n            return false;\n    }\n}\n// Declare SCALE_CHANNEL_INDEX\nconst SCALE_CHANNEL_INDEX = Object.assign(Object.assign(Object.assign(Object.assign({}, POSITION_SCALE_CHANNEL_INDEX), POLAR_POSITION_SCALE_CHANNEL_INDEX), OFFSET_SCALE_CHANNEL_INDEX), NONPOSITION_SCALE_CHANNEL_INDEX);\n/** List of channels with scales */\nexport const SCALE_CHANNELS = keys(SCALE_CHANNEL_INDEX);\nexport function isScaleChannel(channel) {\n    return !!SCALE_CHANNEL_INDEX[channel];\n}\n/**\n * Return whether a channel supports a particular mark type.\n * @param channel  channel name\n * @param mark the mark type\n * @return whether the mark supports the channel\n */\nexport function supportMark(channel, mark) {\n    return getSupportedMark(channel)[mark];\n}\nconst ALL_MARKS = {\n    // all marks\n    arc: 'always',\n    area: 'always',\n    bar: 'always',\n    circle: 'always',\n    geoshape: 'always',\n    image: 'always',\n    line: 'always',\n    rule: 'always',\n    point: 'always',\n    rect: 'always',\n    square: 'always',\n    trail: 'always',\n    text: 'always',\n    tick: 'always'\n};\nconst { geoshape: _g } = ALL_MARKS, ALL_MARKS_EXCEPT_GEOSHAPE = __rest(ALL_MARKS, [\"geoshape\"]);\n/**\n * Return a dictionary showing whether a channel supports mark type.\n * @param channel\n * @return A dictionary mapping mark types to 'always', 'binned', or undefined\n */\nfunction getSupportedMark(channel) {\n    switch (channel) {\n        case COLOR:\n        case FILL:\n        case STROKE:\n        // falls through\n        case DESCRIPTION:\n        case DETAIL:\n        case KEY:\n        case TOOLTIP:\n        case HREF:\n        case ORDER: // TODO: revise (order might not support rect, which is not stackable?)\n        case OPACITY:\n        case FILLOPACITY:\n        case STROKEOPACITY:\n        case STROKEWIDTH:\n        // falls through\n        case FACET:\n        case ROW: // falls through\n        case COLUMN:\n            return ALL_MARKS;\n        case X:\n        case Y:\n        case XOFFSET:\n        case YOFFSET:\n        case LATITUDE:\n        case LONGITUDE:\n            // all marks except geoshape. geoshape does not use X, Y -- it uses a projection\n            return ALL_MARKS_EXCEPT_GEOSHAPE;\n        case X2:\n        case Y2:\n        case LATITUDE2:\n        case LONGITUDE2:\n            return {\n                area: 'always',\n                bar: 'always',\n                image: 'always',\n                rect: 'always',\n                rule: 'always',\n                circle: 'binned',\n                point: 'binned',\n                square: 'binned',\n                tick: 'binned',\n                line: 'binned',\n                trail: 'binned'\n            };\n        case SIZE:\n            return {\n                point: 'always',\n                tick: 'always',\n                rule: 'always',\n                circle: 'always',\n                square: 'always',\n                bar: 'always',\n                text: 'always',\n                line: 'always',\n                trail: 'always'\n            };\n        case STROKEDASH:\n            return {\n                line: 'always',\n                point: 'always',\n                tick: 'always',\n                rule: 'always',\n                circle: 'always',\n                square: 'always',\n                bar: 'always',\n                geoshape: 'always'\n            };\n        case SHAPE:\n            return { point: 'always', geoshape: 'always' };\n        case TEXT:\n            return { text: 'always' };\n        case ANGLE:\n            return { point: 'always', square: 'always', text: 'always' };\n        case URL:\n            return { image: 'always' };\n        case THETA:\n            return { text: 'always', arc: 'always' };\n        case RADIUS:\n            return { text: 'always', arc: 'always' };\n        case THETA2:\n        case RADIUS2:\n            return { arc: 'always' };\n    }\n}\nexport function rangeType(channel) {\n    switch (channel) {\n        case X:\n        case Y:\n        case THETA:\n        case RADIUS:\n        case XOFFSET:\n        case YOFFSET:\n        case SIZE:\n        case ANGLE:\n        case STROKEWIDTH:\n        case OPACITY:\n        case FILLOPACITY:\n        case STROKEOPACITY:\n        // X2 and Y2 use X and Y scales, so they similarly have continuous range. [falls through]\n        case X2:\n        case Y2:\n        case THETA2:\n        case RADIUS2:\n            return undefined;\n        case FACET:\n        case ROW:\n        case COLUMN:\n        case SHAPE:\n        case STROKEDASH:\n        // TEXT, TOOLTIP, URL, and HREF have no scale but have discrete output [falls through]\n        case TEXT:\n        case TOOLTIP:\n        case HREF:\n        case URL:\n        case DESCRIPTION:\n            return 'discrete';\n        // Color can be either continuous or discrete, depending on scale type.\n        case COLOR:\n        case FILL:\n        case STROKE:\n            return 'flexible';\n        // No scale, no range type.\n        case LATITUDE:\n        case LONGITUDE:\n        case LATITUDE2:\n        case LONGITUDE2:\n        case DETAIL:\n        case KEY:\n        case ORDER:\n            return undefined;\n    }\n}\n//# sourceMappingURL=channel.js.map"]},"metadata":{},"sourceType":"module"}