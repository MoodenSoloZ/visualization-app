{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport * as log from '../../log';\nimport { isPathMark } from '../../mark';\nimport { tooltip } from '../mark/encode';\nvar VORONOI = 'voronoi';\nvar nearest = {\n  defined: function defined(selCmpt) {\n    return selCmpt.type === 'point' && selCmpt.nearest;\n  },\n  parse: function parse(model, selCmpt) {\n    // Scope selection events to the voronoi mark to prevent capturing\n    // events that occur on the group mark (https://github.com/vega/vega/issues/2112).\n    if (selCmpt.events) {\n      var _iterator = _createForOfIteratorHelper(selCmpt.events),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var s = _step.value;\n          s.markname = model.getName(VORONOI);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  },\n  marks: function marks(model, selCmpt, _marks) {\n    var _selCmpt$project$hasC = selCmpt.project.hasChannel,\n      x = _selCmpt$project$hasC.x,\n      y = _selCmpt$project$hasC.y;\n    var markType = model.mark;\n    if (isPathMark(markType)) {\n      log.warn(log.message.nearestNotSupportForContinuous(markType));\n      return _marks;\n    }\n    var cellDef = {\n      name: model.getName(VORONOI),\n      type: 'path',\n      interactive: true,\n      from: {\n        data: model.getName('marks')\n      },\n      encode: {\n        update: Object.assign({\n          fill: {\n            value: 'transparent'\n          },\n          strokeWidth: {\n            value: 0.35\n          },\n          stroke: {\n            value: 'transparent'\n          },\n          isVoronoi: {\n            value: true\n          }\n        }, tooltip(model, {\n          reactiveGeom: true\n        }))\n      },\n      transform: [{\n        type: 'voronoi',\n        x: {\n          expr: x || !y ? 'datum.datum.x || 0' : '0'\n        },\n        y: {\n          expr: y || !x ? 'datum.datum.y || 0' : '0'\n        },\n        size: [model.getSizeSignalRef('width'), model.getSizeSignalRef('height')]\n      }]\n    };\n    var index = 0;\n    var exists = false;\n    _marks.forEach(function (mark, i) {\n      var _a;\n      var name = (_a = mark.name) !== null && _a !== void 0 ? _a : '';\n      if (name === model.component.mark[0].name) {\n        index = i;\n      } else if (name.indexOf(VORONOI) >= 0) {\n        exists = true;\n      }\n    });\n    if (!exists) {\n      _marks.splice(index + 1, 0, cellDef);\n    }\n    return _marks;\n  }\n};\nexport default nearest;","map":{"version":3,"sources":["../../../../src/compile/selection/nearest.ts"],"names":[],"mappings":";AAAA,OAAO,KAAK,GAAG,MAAM,WAAW;AAChC,SAAQ,UAAU,QAAO,YAAY;AACrC,SAAQ,OAAO,QAAO,gBAAgB;AAGtC,IAAM,OAAO,GAAG,SAAS;AAEzB,IAAM,OAAO,GAA+B;EAC1C,OAAO,EAAE,iBAAA,OAAO,EAAG;IACjB,OAAO,OAAO,CAAC,IAAI,KAAK,OAAO,IAAI,OAAO,CAAC,OAAO;EACpD,CAAC;EAED,KAAK,EAAE,eAAC,KAAK,EAAE,OAAO,EAAI;IACxB;IACA;IACA,IAAI,OAAO,CAAC,MAAM,EAAE;MAAA,2CACF,OAAO,CAAC,MAAM;QAAA;MAAA;QAA9B,oDAAgC;UAAA,IAArB,CAAC;UACV,CAAC,CAAC,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC;;MACpC;QAAA;MAAA;QAAA;MAAA;IACF;EACH,CAAC;EAED,KAAK,EAAE,eAAC,KAAK,EAAE,OAAO,EAAE,MAAK,EAAI;IAC/B,4BAAe,OAAO,CAAC,OAAO,CAAC,UAAU;MAAlC,CAAC,yBAAD,CAAC;MAAE,CAAC,yBAAD,CAAC;IACX,IAAM,QAAQ,GAAG,KAAK,CAAC,IAAI;IAC3B,IAAI,UAAU,CAAC,QAAQ,CAAC,EAAE;MACxB,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,8BAA8B,CAAC,QAAQ,CAAC,CAAC;MAC9D,OAAO,MAAK;IACb;IAED,IAAM,OAAO,GAAG;MACd,IAAI,EAAE,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC;MAC5B,IAAI,EAAE,MAAM;MACZ,WAAW,EAAE,IAAI;MACjB,IAAI,EAAE;QAAC,IAAI,EAAE,KAAK,CAAC,OAAO,CAAC,OAAO;MAAC,CAAC;MACpC,MAAM,EAAE;QACN,MAAM,EAAA,MAAA,CAAA,MAAA,CAAA;UACJ,IAAI,EAAE;YAAC,KAAK,EAAE;UAAa,CAAC;UAC5B,WAAW,EAAE;YAAC,KAAK,EAAE;UAAI,CAAC;UAC1B,MAAM,EAAE;YAAC,KAAK,EAAE;UAAa,CAAC;UAC9B,SAAS,EAAE;YAAC,KAAK,EAAE;UAAI;QAAC,CAAA,EACrB,OAAO,CAAC,KAAK,EAAE;UAAC,YAAY,EAAE;QAAI,CAAC,CAAC;OAE1C;MACD,SAAS,EAAE,CACT;QACE,IAAI,EAAE,SAAS;QACf,CAAC,EAAE;UAAC,IAAI,EAAE,CAAC,IAAI,CAAC,CAAC,GAAG,oBAAoB,GAAG;QAAG,CAAC;QAC/C,CAAC,EAAE;UAAC,IAAI,EAAE,CAAC,IAAI,CAAC,CAAC,GAAG,oBAAoB,GAAG;QAAG,CAAC;QAC/C,IAAI,EAAE,CAAC,KAAK,CAAC,gBAAgB,CAAC,OAAO,CAAC,EAAE,KAAK,CAAC,gBAAgB,CAAC,QAAQ,CAAC;OACzE;KAEJ;IAED,IAAI,KAAK,GAAG,CAAC;IACb,IAAI,MAAM,GAAG,KAAK;IAClB,MAAK,CAAC,OAAO,CAAC,UAAC,IAAI,EAAE,CAAC,EAAI;;MACxB,IAAM,IAAI,GAAG,CAAA,EAAA,GAAA,IAAI,CAAC,IAAI,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,EAAE;MAC5B,IAAI,IAAI,KAAK,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;QACzC,KAAK,GAAG,CAAC;OACV,MAAM,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;QACrC,MAAM,GAAG,IAAI;MACd;IACH,CAAC,CAAC;IAEF,IAAI,CAAC,MAAM,EAAE;MACX,MAAK,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,EAAE,CAAC,EAAE,OAAO,CAAC;IACpC;IAED,OAAO,MAAK;EACd;CACD;AAED,eAAe,OAAO","sourceRoot":"","sourcesContent":["import * as log from '../../log';\nimport { isPathMark } from '../../mark';\nimport { tooltip } from '../mark/encode';\nconst VORONOI = 'voronoi';\nconst nearest = {\n    defined: selCmpt => {\n        return selCmpt.type === 'point' && selCmpt.nearest;\n    },\n    parse: (model, selCmpt) => {\n        // Scope selection events to the voronoi mark to prevent capturing\n        // events that occur on the group mark (https://github.com/vega/vega/issues/2112).\n        if (selCmpt.events) {\n            for (const s of selCmpt.events) {\n                s.markname = model.getName(VORONOI);\n            }\n        }\n    },\n    marks: (model, selCmpt, marks) => {\n        const { x, y } = selCmpt.project.hasChannel;\n        const markType = model.mark;\n        if (isPathMark(markType)) {\n            log.warn(log.message.nearestNotSupportForContinuous(markType));\n            return marks;\n        }\n        const cellDef = {\n            name: model.getName(VORONOI),\n            type: 'path',\n            interactive: true,\n            from: { data: model.getName('marks') },\n            encode: {\n                update: Object.assign({ fill: { value: 'transparent' }, strokeWidth: { value: 0.35 }, stroke: { value: 'transparent' }, isVoronoi: { value: true } }, tooltip(model, { reactiveGeom: true }))\n            },\n            transform: [\n                {\n                    type: 'voronoi',\n                    x: { expr: x || !y ? 'datum.datum.x || 0' : '0' },\n                    y: { expr: y || !x ? 'datum.datum.y || 0' : '0' },\n                    size: [model.getSizeSignalRef('width'), model.getSizeSignalRef('height')]\n                }\n            ]\n        };\n        let index = 0;\n        let exists = false;\n        marks.forEach((mark, i) => {\n            var _a;\n            const name = (_a = mark.name) !== null && _a !== void 0 ? _a : '';\n            if (name === model.component.mark[0].name) {\n                index = i;\n            }\n            else if (name.indexOf(VORONOI) >= 0) {\n                exists = true;\n            }\n        });\n        if (!exists) {\n            marks.splice(index + 1, 0, cellDef);\n        }\n        return marks;\n    }\n};\nexport default nearest;\n//# sourceMappingURL=nearest.js.map"]},"metadata":{},"sourceType":"module"}