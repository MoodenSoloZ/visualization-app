{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { isBinned, isBinning } from '../../bin';\nimport { isContinuousFieldOrDatumDef, isFieldDef, isNumericDataDef } from '../../channeldef';\nimport { isAggregate } from '../../encoding';\nimport { replaceExprRef } from '../../expr';\nimport * as log from '../../log';\nimport { AREA, BAR, BAR_CORNER_RADIUS_INDEX as BAR_CORNER_RADIUS_END_INDEX, CIRCLE, IMAGE, LINE, POINT, RECT, RULE, SQUARE, TEXT, TICK } from '../../mark';\nimport { QUANTITATIVE, TEMPORAL } from '../../type';\nimport { contains, getFirstDefined } from '../../util';\nimport { getMarkConfig, getMarkPropOrConfig } from '../common';\nexport function initMarkdef(originalMarkDef, encoding, config) {\n  // FIXME: markDef expects that exprRefs are replaced recursively but replaceExprRef only replaces the top level\n  var markDef = replaceExprRef(originalMarkDef);\n  // set orient, which can be overridden by rules as sometimes the specified orient is invalid.\n  var specifiedOrient = getMarkPropOrConfig('orient', markDef, config);\n  markDef.orient = orient(markDef.type, encoding, specifiedOrient);\n  if (specifiedOrient !== undefined && specifiedOrient !== markDef.orient) {\n    log.warn(log.message.orientOverridden(markDef.orient, specifiedOrient));\n  }\n  if (markDef.type === 'bar' && markDef.orient) {\n    var cornerRadiusEnd = getMarkPropOrConfig('cornerRadiusEnd', markDef, config);\n    if (cornerRadiusEnd !== undefined) {\n      var newProps = markDef.orient === 'horizontal' && encoding.x2 || markDef.orient === 'vertical' && encoding.y2 ? ['cornerRadius'] : BAR_CORNER_RADIUS_END_INDEX[markDef.orient];\n      var _iterator = _createForOfIteratorHelper(newProps),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var newProp = _step.value;\n          markDef[newProp] = cornerRadiusEnd;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      if (markDef.cornerRadiusEnd !== undefined) {\n        delete markDef.cornerRadiusEnd; // no need to keep the original cap cornerRadius\n      }\n    }\n  }\n  // set opacity and filled if not specified in mark config\n  var specifiedOpacity = getMarkPropOrConfig('opacity', markDef, config);\n  if (specifiedOpacity === undefined) {\n    markDef.opacity = opacity(markDef.type, encoding);\n  }\n  // set cursor, which should be pointer if href channel is present unless otherwise specified\n  var specifiedCursor = getMarkPropOrConfig('cursor', markDef, config);\n  if (specifiedCursor === undefined) {\n    markDef.cursor = cursor(markDef, encoding, config);\n  }\n  return markDef;\n}\nfunction cursor(markDef, encoding, config) {\n  if (encoding.href || markDef.href || getMarkPropOrConfig('href', markDef, config)) {\n    return 'pointer';\n  }\n  return markDef.cursor;\n}\nfunction opacity(mark, encoding) {\n  if (contains([POINT, TICK, CIRCLE, SQUARE], mark)) {\n    // point-based marks\n    if (!isAggregate(encoding)) {\n      return 0.7;\n    }\n  }\n  return undefined;\n}\nexport function defaultFilled(markDef, config, _ref) {\n  var graticule = _ref.graticule;\n  if (graticule) {\n    return false;\n  }\n  var filledConfig = getMarkConfig('filled', markDef, config);\n  var mark = markDef.type;\n  return getFirstDefined(filledConfig, mark !== POINT && mark !== LINE && mark !== RULE);\n}\nfunction orient(mark, encoding, specifiedOrient) {\n  switch (mark) {\n    case POINT:\n    case CIRCLE:\n    case SQUARE:\n    case TEXT:\n    case RECT:\n    case IMAGE:\n      // orient is meaningless for these marks.\n      return undefined;\n  }\n  var x = encoding.x,\n    y = encoding.y,\n    x2 = encoding.x2,\n    y2 = encoding.y2;\n  switch (mark) {\n    case BAR:\n      if (isFieldDef(x) && (isBinned(x.bin) || isFieldDef(y) && y.aggregate && !x.aggregate)) {\n        return 'vertical';\n      }\n      if (isFieldDef(y) && (isBinned(y.bin) || isFieldDef(x) && x.aggregate && !y.aggregate)) {\n        return 'horizontal';\n      }\n      if (y2 || x2) {\n        // Ranged bar does not always have clear orientation, so we allow overriding\n        if (specifiedOrient) {\n          return specifiedOrient;\n        }\n        // If y is range and x is non-range, non-bin Q\n        if (!x2) {\n          if (isFieldDef(x) && x.type === QUANTITATIVE && !isBinning(x.bin) || isNumericDataDef(x)) {\n            if (isFieldDef(y) && isBinned(y.bin)) {\n              return 'horizontal';\n            }\n          }\n          return 'vertical';\n        }\n        // If x is range and y is non-range, non-bin Q\n        if (!y2) {\n          if (isFieldDef(y) && y.type === QUANTITATIVE && !isBinning(y.bin) || isNumericDataDef(y)) {\n            if (isFieldDef(x) && isBinned(x.bin)) {\n              return 'vertical';\n            }\n          }\n          return 'horizontal';\n        }\n      }\n    // falls through\n    case RULE:\n      // return undefined for line segment rule and bar with both axis ranged\n      // we have to ignore the case that the data are already binned\n      if (x2 && !(isFieldDef(x) && isBinned(x.bin)) && y2 && !(isFieldDef(y) && isBinned(y.bin))) {\n        return undefined;\n      }\n    // falls through\n    case AREA:\n      // If there are range for both x and y, y (vertical) has higher precedence.\n      if (y2) {\n        if (isFieldDef(y) && isBinned(y.bin)) {\n          return 'horizontal';\n        } else {\n          return 'vertical';\n        }\n      } else if (x2) {\n        if (isFieldDef(x) && isBinned(x.bin)) {\n          return 'vertical';\n        } else {\n          return 'horizontal';\n        }\n      } else if (mark === RULE) {\n        if (x && !y) {\n          return 'vertical';\n        } else if (y && !x) {\n          return 'horizontal';\n        }\n      }\n    // falls through\n    case LINE:\n    case TICK:\n      {\n        // Tick is opposite to bar, line, area and never have ranged mark.\n        var xIsContinuous = isContinuousFieldOrDatumDef(x);\n        var yIsContinuous = isContinuousFieldOrDatumDef(y);\n        if (specifiedOrient) {\n          return specifiedOrient;\n        } else if (xIsContinuous && !yIsContinuous) {\n          return mark !== 'tick' ? 'horizontal' : 'vertical';\n        } else if (!xIsContinuous && yIsContinuous) {\n          return mark !== 'tick' ? 'vertical' : 'horizontal';\n        } else if (xIsContinuous && yIsContinuous) {\n          var xDef = x; // we can cast here since they are surely fieldDef\n          var yDef = y;\n          var xIsTemporal = xDef.type === TEMPORAL;\n          var yIsTemporal = yDef.type === TEMPORAL;\n          // temporal without timeUnit is considered continuous, but better serves as dimension\n          if (xIsTemporal && !yIsTemporal) {\n            return mark !== 'tick' ? 'vertical' : 'horizontal';\n          } else if (!xIsTemporal && yIsTemporal) {\n            return mark !== 'tick' ? 'horizontal' : 'vertical';\n          }\n          if (!xDef.aggregate && yDef.aggregate) {\n            return mark !== 'tick' ? 'vertical' : 'horizontal';\n          } else if (xDef.aggregate && !yDef.aggregate) {\n            return mark !== 'tick' ? 'horizontal' : 'vertical';\n          }\n          return 'vertical';\n        } else {\n          return undefined;\n        }\n      }\n  }\n  return 'vertical';\n}","map":{"version":3,"sources":["../../../../src/compile/mark/init.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isBinned, isBinning } from '../../bin';\nimport { isContinuousFieldOrDatumDef, isFieldDef, isNumericDataDef } from '../../channeldef';\nimport { isAggregate } from '../../encoding';\nimport { replaceExprRef } from '../../expr';\nimport * as log from '../../log';\nimport { AREA, BAR, BAR_CORNER_RADIUS_INDEX as BAR_CORNER_RADIUS_END_INDEX, CIRCLE, IMAGE, LINE, POINT, RECT, RULE, SQUARE, TEXT, TICK } from '../../mark';\nimport { QUANTITATIVE, TEMPORAL } from '../../type';\nimport { contains, getFirstDefined } from '../../util';\nimport { getMarkConfig, getMarkPropOrConfig } from '../common';\nexport function initMarkdef(originalMarkDef, encoding, config) {\n    // FIXME: markDef expects that exprRefs are replaced recursively but replaceExprRef only replaces the top level\n    const markDef = replaceExprRef(originalMarkDef);\n    // set orient, which can be overridden by rules as sometimes the specified orient is invalid.\n    const specifiedOrient = getMarkPropOrConfig('orient', markDef, config);\n    markDef.orient = orient(markDef.type, encoding, specifiedOrient);\n    if (specifiedOrient !== undefined && specifiedOrient !== markDef.orient) {\n        log.warn(log.message.orientOverridden(markDef.orient, specifiedOrient));\n    }\n    if (markDef.type === 'bar' && markDef.orient) {\n        const cornerRadiusEnd = getMarkPropOrConfig('cornerRadiusEnd', markDef, config);\n        if (cornerRadiusEnd !== undefined) {\n            const newProps = (markDef.orient === 'horizontal' && encoding.x2) || (markDef.orient === 'vertical' && encoding.y2)\n                ? ['cornerRadius']\n                : BAR_CORNER_RADIUS_END_INDEX[markDef.orient];\n            for (const newProp of newProps) {\n                markDef[newProp] = cornerRadiusEnd;\n            }\n            if (markDef.cornerRadiusEnd !== undefined) {\n                delete markDef.cornerRadiusEnd; // no need to keep the original cap cornerRadius\n            }\n        }\n    }\n    // set opacity and filled if not specified in mark config\n    const specifiedOpacity = getMarkPropOrConfig('opacity', markDef, config);\n    if (specifiedOpacity === undefined) {\n        markDef.opacity = opacity(markDef.type, encoding);\n    }\n    // set cursor, which should be pointer if href channel is present unless otherwise specified\n    const specifiedCursor = getMarkPropOrConfig('cursor', markDef, config);\n    if (specifiedCursor === undefined) {\n        markDef.cursor = cursor(markDef, encoding, config);\n    }\n    return markDef;\n}\nfunction cursor(markDef, encoding, config) {\n    if (encoding.href || markDef.href || getMarkPropOrConfig('href', markDef, config)) {\n        return 'pointer';\n    }\n    return markDef.cursor;\n}\nfunction opacity(mark, encoding) {\n    if (contains([POINT, TICK, CIRCLE, SQUARE], mark)) {\n        // point-based marks\n        if (!isAggregate(encoding)) {\n            return 0.7;\n        }\n    }\n    return undefined;\n}\nexport function defaultFilled(markDef, config, { graticule }) {\n    if (graticule) {\n        return false;\n    }\n    const filledConfig = getMarkConfig('filled', markDef, config);\n    const mark = markDef.type;\n    return getFirstDefined(filledConfig, mark !== POINT && mark !== LINE && mark !== RULE);\n}\nfunction orient(mark, encoding, specifiedOrient) {\n    switch (mark) {\n        case POINT:\n        case CIRCLE:\n        case SQUARE:\n        case TEXT:\n        case RECT:\n        case IMAGE:\n            // orient is meaningless for these marks.\n            return undefined;\n    }\n    const { x, y, x2, y2 } = encoding;\n    switch (mark) {\n        case BAR:\n            if (isFieldDef(x) && (isBinned(x.bin) || (isFieldDef(y) && y.aggregate && !x.aggregate))) {\n                return 'vertical';\n            }\n            if (isFieldDef(y) && (isBinned(y.bin) || (isFieldDef(x) && x.aggregate && !y.aggregate))) {\n                return 'horizontal';\n            }\n            if (y2 || x2) {\n                // Ranged bar does not always have clear orientation, so we allow overriding\n                if (specifiedOrient) {\n                    return specifiedOrient;\n                }\n                // If y is range and x is non-range, non-bin Q\n                if (!x2) {\n                    if ((isFieldDef(x) && x.type === QUANTITATIVE && !isBinning(x.bin)) || isNumericDataDef(x)) {\n                        if (isFieldDef(y) && isBinned(y.bin)) {\n                            return 'horizontal';\n                        }\n                    }\n                    return 'vertical';\n                }\n                // If x is range and y is non-range, non-bin Q\n                if (!y2) {\n                    if ((isFieldDef(y) && y.type === QUANTITATIVE && !isBinning(y.bin)) || isNumericDataDef(y)) {\n                        if (isFieldDef(x) && isBinned(x.bin)) {\n                            return 'vertical';\n                        }\n                    }\n                    return 'horizontal';\n                }\n            }\n        // falls through\n        case RULE:\n            // return undefined for line segment rule and bar with both axis ranged\n            // we have to ignore the case that the data are already binned\n            if (x2 && !(isFieldDef(x) && isBinned(x.bin)) && y2 && !(isFieldDef(y) && isBinned(y.bin))) {\n                return undefined;\n            }\n        // falls through\n        case AREA:\n            // If there are range for both x and y, y (vertical) has higher precedence.\n            if (y2) {\n                if (isFieldDef(y) && isBinned(y.bin)) {\n                    return 'horizontal';\n                }\n                else {\n                    return 'vertical';\n                }\n            }\n            else if (x2) {\n                if (isFieldDef(x) && isBinned(x.bin)) {\n                    return 'vertical';\n                }\n                else {\n                    return 'horizontal';\n                }\n            }\n            else if (mark === RULE) {\n                if (x && !y) {\n                    return 'vertical';\n                }\n                else if (y && !x) {\n                    return 'horizontal';\n                }\n            }\n        // falls through\n        case LINE:\n        case TICK: {\n            // Tick is opposite to bar, line, area and never have ranged mark.\n            const xIsContinuous = isContinuousFieldOrDatumDef(x);\n            const yIsContinuous = isContinuousFieldOrDatumDef(y);\n            if (specifiedOrient) {\n                return specifiedOrient;\n            }\n            else if (xIsContinuous && !yIsContinuous) {\n                return mark !== 'tick' ? 'horizontal' : 'vertical';\n            }\n            else if (!xIsContinuous && yIsContinuous) {\n                return mark !== 'tick' ? 'vertical' : 'horizontal';\n            }\n            else if (xIsContinuous && yIsContinuous) {\n                const xDef = x; // we can cast here since they are surely fieldDef\n                const yDef = y;\n                const xIsTemporal = xDef.type === TEMPORAL;\n                const yIsTemporal = yDef.type === TEMPORAL;\n                // temporal without timeUnit is considered continuous, but better serves as dimension\n                if (xIsTemporal && !yIsTemporal) {\n                    return mark !== 'tick' ? 'vertical' : 'horizontal';\n                }\n                else if (!xIsTemporal && yIsTemporal) {\n                    return mark !== 'tick' ? 'horizontal' : 'vertical';\n                }\n                if (!xDef.aggregate && yDef.aggregate) {\n                    return mark !== 'tick' ? 'vertical' : 'horizontal';\n                }\n                else if (xDef.aggregate && !yDef.aggregate) {\n                    return mark !== 'tick' ? 'horizontal' : 'vertical';\n                }\n                return 'vertical';\n            }\n            else {\n                return undefined;\n            }\n        }\n    }\n    return 'vertical';\n}\n//# sourceMappingURL=init.js.map"]},"metadata":{},"sourceType":"module"}