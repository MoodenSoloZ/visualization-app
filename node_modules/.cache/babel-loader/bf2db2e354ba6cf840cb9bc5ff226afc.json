{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport * as log from '../log';\nimport { deepEqual, duplicate, getFirstDefined, keys } from '../util';\n/**\n * Generic class for storing properties that are explicitly specified\n * and implicitly determined by the compiler.\n * This is important for scale/axis/legend merging as\n * we want to prioritize properties that users explicitly specified.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport var Split = /*#__PURE__*/function () {\n  function Split() {\n    var explicit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var implicit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, Split);\n    this.explicit = explicit;\n    this.implicit = implicit;\n  }\n  _createClass(Split, [{\n    key: \"clone\",\n    value: function clone() {\n      return new Split(duplicate(this.explicit), duplicate(this.implicit));\n    }\n  }, {\n    key: \"combine\",\n    value: function combine() {\n      return Object.assign(Object.assign({}, this.explicit), this.implicit);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      // Explicit has higher precedence\n      return getFirstDefined(this.explicit[key], this.implicit[key]);\n    }\n  }, {\n    key: \"getWithExplicit\",\n    value: function getWithExplicit(key) {\n      // Explicit has higher precedence\n      if (this.explicit[key] !== undefined) {\n        return {\n          explicit: true,\n          value: this.explicit[key]\n        };\n      } else if (this.implicit[key] !== undefined) {\n        return {\n          explicit: false,\n          value: this.implicit[key]\n        };\n      }\n      return {\n        explicit: false,\n        value: undefined\n      };\n    }\n  }, {\n    key: \"setWithExplicit\",\n    value: function setWithExplicit(key, _ref) {\n      var value = _ref.value,\n        explicit = _ref.explicit;\n      if (value !== undefined) {\n        this.set(key, value, explicit);\n      }\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value, explicit) {\n      delete this[explicit ? 'implicit' : 'explicit'][key];\n      this[explicit ? 'explicit' : 'implicit'][key] = value;\n      return this;\n    }\n  }, {\n    key: \"copyKeyFromSplit\",\n    value: function copyKeyFromSplit(key, _ref2) {\n      var explicit = _ref2.explicit,\n        implicit = _ref2.implicit;\n      // Explicit has higher precedence\n      if (explicit[key] !== undefined) {\n        this.set(key, explicit[key], true);\n      } else if (implicit[key] !== undefined) {\n        this.set(key, implicit[key], false);\n      }\n    }\n  }, {\n    key: \"copyKeyFromObject\",\n    value: function copyKeyFromObject(key, s) {\n      // Explicit has higher precedence\n      if (s[key] !== undefined) {\n        this.set(key, s[key], true);\n      }\n    }\n    /**\n     * Merge split object into this split object. Properties from the other split\n     * overwrite properties from this split.\n     */\n  }, {\n    key: \"copyAll\",\n    value: function copyAll(other) {\n      var _iterator = _createForOfIteratorHelper(keys(other.combine())),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          var val = other.getWithExplicit(key);\n          this.setWithExplicit(key, val);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }]);\n  return Split;\n}();\nexport function makeExplicit(value) {\n  return {\n    explicit: true,\n    value: value\n  };\n}\nexport function makeImplicit(value) {\n  return {\n    explicit: false,\n    value: value\n  };\n}\nexport function tieBreakByComparing(compare) {\n  return function (v1, v2, property, propertyOf) {\n    var diff = compare(v1.value, v2.value);\n    if (diff > 0) {\n      return v1;\n    } else if (diff < 0) {\n      return v2;\n    }\n    return defaultTieBreaker(v1, v2, property, propertyOf);\n  };\n}\nexport function defaultTieBreaker(v1, v2, property, propertyOf) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingProperty(property, propertyOf, v1.value, v2.value));\n  }\n  // If equal score, prefer v1.\n  return v1;\n}\nexport function mergeValuesWithExplicit(v1, v2, property, propertyOf) {\n  var tieBreaker = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : defaultTieBreaker;\n  if (v1 === undefined || v1.value === undefined) {\n    // For first run\n    return v2;\n  }\n  if (v1.explicit && !v2.explicit) {\n    return v1;\n  } else if (v2.explicit && !v1.explicit) {\n    return v2;\n  } else if (deepEqual(v1.value, v2.value)) {\n    return v1;\n  } else {\n    return tieBreaker(v1, v2, property, propertyOf);\n  }\n}","map":{"version":3,"sources":["../../../src/compile/split.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as log from '../log';\nimport { deepEqual, duplicate, getFirstDefined, keys } from '../util';\n/**\n * Generic class for storing properties that are explicitly specified\n * and implicitly determined by the compiler.\n * This is important for scale/axis/legend merging as\n * we want to prioritize properties that users explicitly specified.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport class Split {\n    constructor(explicit = {}, implicit = {}) {\n        this.explicit = explicit;\n        this.implicit = implicit;\n    }\n    clone() {\n        return new Split(duplicate(this.explicit), duplicate(this.implicit));\n    }\n    combine() {\n        return Object.assign(Object.assign({}, this.explicit), this.implicit);\n    }\n    get(key) {\n        // Explicit has higher precedence\n        return getFirstDefined(this.explicit[key], this.implicit[key]);\n    }\n    getWithExplicit(key) {\n        // Explicit has higher precedence\n        if (this.explicit[key] !== undefined) {\n            return { explicit: true, value: this.explicit[key] };\n        }\n        else if (this.implicit[key] !== undefined) {\n            return { explicit: false, value: this.implicit[key] };\n        }\n        return { explicit: false, value: undefined };\n    }\n    setWithExplicit(key, { value, explicit }) {\n        if (value !== undefined) {\n            this.set(key, value, explicit);\n        }\n    }\n    set(key, value, explicit) {\n        delete this[explicit ? 'implicit' : 'explicit'][key];\n        this[explicit ? 'explicit' : 'implicit'][key] = value;\n        return this;\n    }\n    copyKeyFromSplit(key, { explicit, implicit }) {\n        // Explicit has higher precedence\n        if (explicit[key] !== undefined) {\n            this.set(key, explicit[key], true);\n        }\n        else if (implicit[key] !== undefined) {\n            this.set(key, implicit[key], false);\n        }\n    }\n    copyKeyFromObject(key, s) {\n        // Explicit has higher precedence\n        if (s[key] !== undefined) {\n            this.set(key, s[key], true);\n        }\n    }\n    /**\n     * Merge split object into this split object. Properties from the other split\n     * overwrite properties from this split.\n     */\n    copyAll(other) {\n        for (const key of keys(other.combine())) {\n            const val = other.getWithExplicit(key);\n            this.setWithExplicit(key, val);\n        }\n    }\n}\nexport function makeExplicit(value) {\n    return {\n        explicit: true,\n        value\n    };\n}\nexport function makeImplicit(value) {\n    return {\n        explicit: false,\n        value\n    };\n}\nexport function tieBreakByComparing(compare) {\n    return (v1, v2, property, propertyOf) => {\n        const diff = compare(v1.value, v2.value);\n        if (diff > 0) {\n            return v1;\n        }\n        else if (diff < 0) {\n            return v2;\n        }\n        return defaultTieBreaker(v1, v2, property, propertyOf);\n    };\n}\nexport function defaultTieBreaker(v1, v2, property, propertyOf) {\n    if (v1.explicit && v2.explicit) {\n        log.warn(log.message.mergeConflictingProperty(property, propertyOf, v1.value, v2.value));\n    }\n    // If equal score, prefer v1.\n    return v1;\n}\nexport function mergeValuesWithExplicit(v1, v2, property, propertyOf, tieBreaker = defaultTieBreaker) {\n    if (v1 === undefined || v1.value === undefined) {\n        // For first run\n        return v2;\n    }\n    if (v1.explicit && !v2.explicit) {\n        return v1;\n    }\n    else if (v2.explicit && !v1.explicit) {\n        return v2;\n    }\n    else if (deepEqual(v1.value, v2.value)) {\n        return v1;\n    }\n    else {\n        return tieBreaker(v1, v2, property, propertyOf);\n    }\n}\n//# sourceMappingURL=split.js.map"]},"metadata":{},"sourceType":"module"}