{"ast":null,"code":"import _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { isArray } from 'vega-util';\nimport { isBinned, isBinning, isBinParams } from '../../bin';\nimport { COLOR, FILL, getSecondaryRangeChannel, isXorY, isXorYOffset, POLAR_POSITION_SCALE_CHANNELS, POSITION_SCALE_CHANNELS, STROKE } from '../../channel';\nimport { getFieldDef, getFieldOrDatumDef, isFieldDef, valueExpr } from '../../channeldef';\nimport { isDateTime } from '../../datetime';\nimport { channelHasNestedOffsetScale } from '../../encoding';\nimport * as log from '../../log';\nimport { channelScalePropertyIncompatability, hasContinuousDomain, isContinuousToContinuous, isContinuousToDiscrete, ScaleType, scaleTypeSupportProperty } from '../../scale';\nimport * as util from '../../util';\nimport { contains, getFirstDefined, keys } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { getBinSignalName } from '../data/bin';\nimport { isUnitModel } from '../model';\nimport { SignalRefWrapper } from '../signal';\nimport { mergeValuesWithExplicit, tieBreakByComparing } from '../split';\nimport { parseUnitScaleRange } from './range';\nexport function parseScaleProperty(model, property) {\n  if (isUnitModel(model)) {\n    parseUnitScaleProperty(model, property);\n  } else {\n    parseNonUnitScaleProperty(model, property);\n  }\n}\nfunction parseUnitScaleProperty(model, property) {\n  var localScaleComponents = model.component.scales;\n  var config = model.config,\n    encoding = model.encoding,\n    markDef = model.markDef,\n    specifiedScales = model.specifiedScales;\n  var _iterator = _createForOfIteratorHelper(keys(localScaleComponents)),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var channel = _step.value;\n      var specifiedScale = specifiedScales[channel];\n      var localScaleCmpt = localScaleComponents[channel];\n      var mergedScaleCmpt = model.getScaleComponent(channel);\n      var fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n      var specifiedValue = specifiedScale[property];\n      var scaleType = mergedScaleCmpt.get('type');\n      var scalePadding = mergedScaleCmpt.get('padding');\n      var scalePaddingInner = mergedScaleCmpt.get('paddingInner');\n      var supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n      var channelIncompatability = channelScalePropertyIncompatability(channel, property);\n      if (specifiedValue !== undefined) {\n        // If there is a specified value, check if it is compatible with scale type and channel\n        if (!supportedByScaleType) {\n          log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n        } else if (channelIncompatability) {\n          // channel\n          log.warn(channelIncompatability);\n        }\n      }\n      if (supportedByScaleType && channelIncompatability === undefined) {\n        if (specifiedValue !== undefined) {\n          var timeUnit = fieldOrDatumDef['timeUnit'];\n          var type = fieldOrDatumDef.type;\n          switch (property) {\n            // domainMax/Min to signal if the value is a datetime object\n            case 'domainMax':\n            case 'domainMin':\n              if (isDateTime(specifiedScale[property]) || type === 'temporal' || timeUnit) {\n                localScaleCmpt.set(property, {\n                  signal: valueExpr(specifiedScale[property], {\n                    type: type,\n                    timeUnit: timeUnit\n                  })\n                }, true);\n              } else {\n                localScaleCmpt.set(property, specifiedScale[property], true);\n              }\n              break;\n            default:\n              localScaleCmpt.copyKeyFromObject(property, specifiedScale);\n          }\n        } else {\n          var value = property in scaleRules ? scaleRules[property]({\n            model: model,\n            channel: channel,\n            fieldOrDatumDef: fieldOrDatumDef,\n            scaleType: scaleType,\n            scalePadding: scalePadding,\n            scalePaddingInner: scalePaddingInner,\n            domain: specifiedScale.domain,\n            domainMin: specifiedScale.domainMin,\n            domainMax: specifiedScale.domainMax,\n            markDef: markDef,\n            config: config,\n            hasNestedOffsetScale: channelHasNestedOffsetScale(encoding, channel),\n            hasSecondaryRangeChannel: !!encoding[getSecondaryRangeChannel(channel)]\n          }) : config.scale[property];\n          if (value !== undefined) {\n            localScaleCmpt.set(property, value, false);\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nexport var scaleRules = {\n  bins: function bins(_ref) {\n    var model = _ref.model,\n      fieldOrDatumDef = _ref.fieldOrDatumDef;\n    return isFieldDef(fieldOrDatumDef) ? _bins(model, fieldOrDatumDef) : undefined;\n  },\n  interpolate: function interpolate(_ref2) {\n    var channel = _ref2.channel,\n      fieldOrDatumDef = _ref2.fieldOrDatumDef;\n    return _interpolate(channel, fieldOrDatumDef.type);\n  },\n  nice: function nice(_ref3) {\n    var scaleType = _ref3.scaleType,\n      channel = _ref3.channel,\n      domain = _ref3.domain,\n      domainMin = _ref3.domainMin,\n      domainMax = _ref3.domainMax,\n      fieldOrDatumDef = _ref3.fieldOrDatumDef;\n    return _nice(scaleType, channel, domain, domainMin, domainMax, fieldOrDatumDef);\n  },\n  padding: function padding(_ref4) {\n    var channel = _ref4.channel,\n      scaleType = _ref4.scaleType,\n      fieldOrDatumDef = _ref4.fieldOrDatumDef,\n      markDef = _ref4.markDef,\n      config = _ref4.config;\n    return _padding(channel, scaleType, config.scale, fieldOrDatumDef, markDef, config.bar);\n  },\n  paddingInner: function paddingInner(_ref5) {\n    var scalePadding = _ref5.scalePadding,\n      channel = _ref5.channel,\n      markDef = _ref5.markDef,\n      scaleType = _ref5.scaleType,\n      config = _ref5.config,\n      hasNestedOffsetScale = _ref5.hasNestedOffsetScale;\n    return _paddingInner(scalePadding, channel, markDef.type, scaleType, config.scale, hasNestedOffsetScale);\n  },\n  paddingOuter: function paddingOuter(_ref6) {\n    var scalePadding = _ref6.scalePadding,\n      channel = _ref6.channel,\n      scaleType = _ref6.scaleType,\n      scalePaddingInner = _ref6.scalePaddingInner,\n      config = _ref6.config,\n      hasNestedOffsetScale = _ref6.hasNestedOffsetScale;\n    return _paddingOuter(scalePadding, channel, scaleType, scalePaddingInner, config.scale, hasNestedOffsetScale);\n  },\n  reverse: function reverse(_ref7) {\n    var fieldOrDatumDef = _ref7.fieldOrDatumDef,\n      scaleType = _ref7.scaleType,\n      channel = _ref7.channel,\n      config = _ref7.config;\n    var sort = isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : undefined;\n    return _reverse(scaleType, sort, channel, config.scale);\n  },\n  zero: function zero(_ref8) {\n    var channel = _ref8.channel,\n      fieldOrDatumDef = _ref8.fieldOrDatumDef,\n      domain = _ref8.domain,\n      markDef = _ref8.markDef,\n      scaleType = _ref8.scaleType,\n      config = _ref8.config,\n      hasSecondaryRangeChannel = _ref8.hasSecondaryRangeChannel;\n    return _zero(channel, fieldOrDatumDef, domain, markDef, scaleType, config.scale, hasSecondaryRangeChannel);\n  }\n};\n// This method is here rather than in range.ts to avoid circular dependency.\nexport function parseScaleRange(model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleRange(model);\n  } else {\n    parseNonUnitScaleProperty(model, 'range');\n  }\n}\nexport function parseNonUnitScaleProperty(model, property) {\n  var localScaleComponents = model.component.scales;\n  var _iterator2 = _createForOfIteratorHelper(model.children),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var child = _step2.value;\n      if (property === 'range') {\n        parseScaleRange(child);\n      } else {\n        parseScaleProperty(child, property);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  var _iterator3 = _createForOfIteratorHelper(keys(localScaleComponents)),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var channel = _step3.value;\n      var valueWithExplicit = void 0;\n      var _iterator4 = _createForOfIteratorHelper(model.children),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _child = _step4.value;\n          var childComponent = _child.component.scales[channel];\n          if (childComponent) {\n            var childValueWithExplicit = childComponent.getWithExplicit(property);\n            valueWithExplicit = mergeValuesWithExplicit(valueWithExplicit, childValueWithExplicit, property, 'scale', tieBreakByComparing(function (v1, v2) {\n              switch (property) {\n                case 'range':\n                  // For step, prefer larger step\n                  if (v1.step && v2.step) {\n                    return v1.step - v2.step;\n                  }\n                  return 0;\n                // TODO: precedence rule for other properties\n              }\n\n              return 0;\n            }));\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      localScaleComponents[channel].setWithExplicit(property, valueWithExplicit);\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n}\nfunction _bins(model, fieldDef) {\n  var bin = fieldDef.bin;\n  if (isBinning(bin)) {\n    var binSignal = getBinSignalName(model, fieldDef.field, bin);\n    return new SignalRefWrapper(function () {\n      return model.getSignalName(binSignal);\n    });\n  } else if (isBinned(bin) && isBinParams(bin) && bin.step !== undefined) {\n    // start and stop will be determined from the scale domain\n    return {\n      step: bin.step\n    };\n  }\n  return undefined;\n}\nexport { _bins as bins };\nfunction _interpolate(channel, type) {\n  if (contains([COLOR, FILL, STROKE], channel) && type !== 'nominal') {\n    return 'hcl';\n  }\n  return undefined;\n}\nexport { _interpolate as interpolate };\nfunction _nice(scaleType, channel, specifiedDomain, domainMin, domainMax, fieldOrDatumDef) {\n  var _a;\n  if (((_a = getFieldDef(fieldOrDatumDef)) === null || _a === void 0 ? void 0 : _a.bin) || isArray(specifiedDomain) || domainMax != null || domainMin != null || util.contains([ScaleType.TIME, ScaleType.UTC], scaleType)) {\n    return undefined;\n  }\n  return isXorY(channel) ? true : undefined;\n}\nexport { _nice as nice };\nfunction _padding(channel, scaleType, scaleConfig, fieldOrDatumDef, markDef, barConfig) {\n  if (isXorY(channel)) {\n    if (isContinuousToContinuous(scaleType)) {\n      if (scaleConfig.continuousPadding !== undefined) {\n        return scaleConfig.continuousPadding;\n      }\n      var type = markDef.type,\n        orient = markDef.orient;\n      if (type === 'bar' && !(isFieldDef(fieldOrDatumDef) && (fieldOrDatumDef.bin || fieldOrDatumDef.timeUnit))) {\n        if (orient === 'vertical' && channel === 'x' || orient === 'horizontal' && channel === 'y') {\n          return barConfig.continuousBandSize;\n        }\n      }\n    }\n    if (scaleType === ScaleType.POINT) {\n      return scaleConfig.pointPadding;\n    }\n  }\n  return undefined;\n}\nexport { _padding as padding };\nfunction _paddingInner(paddingValue, channel, mark, scaleType, scaleConfig) {\n  var hasNestedOffsetScale = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingInner.\n    return undefined;\n  }\n  if (isXorY(channel)) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n    // paddingOuter would only be called if it's a band scale, just return the default for bandScale.\n    var bandPaddingInner = scaleConfig.bandPaddingInner,\n      barBandPaddingInner = scaleConfig.barBandPaddingInner,\n      rectBandPaddingInner = scaleConfig.rectBandPaddingInner,\n      bandWithNestedOffsetPaddingInner = scaleConfig.bandWithNestedOffsetPaddingInner;\n    if (hasNestedOffsetScale) {\n      return bandWithNestedOffsetPaddingInner;\n    }\n    return getFirstDefined(bandPaddingInner, mark === 'bar' ? barBandPaddingInner : rectBandPaddingInner);\n  } else if (isXorYOffset(channel)) {\n    if (scaleType === ScaleType.BAND) {\n      return scaleConfig.offsetBandPaddingInner;\n    }\n  }\n  return undefined;\n}\nexport { _paddingInner as paddingInner };\nfunction _paddingOuter(paddingValue, channel, scaleType, paddingInnerValue, scaleConfig) {\n  var hasNestedOffsetScale = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingOuter.\n    return undefined;\n  }\n  if (isXorY(channel)) {\n    var bandPaddingOuter = scaleConfig.bandPaddingOuter,\n      bandWithNestedOffsetPaddingOuter = scaleConfig.bandWithNestedOffsetPaddingOuter;\n    if (hasNestedOffsetScale) {\n      return bandWithNestedOffsetPaddingOuter;\n    }\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n    if (scaleType === ScaleType.BAND) {\n      return getFirstDefined(bandPaddingOuter,\n      /* By default, paddingOuter is paddingInner / 2. The reason is that\n        size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).\n        and we want the width/height to be integer by default.\n        Note that step (by default) and cardinality are integers.) */\n      isSignalRef(paddingInnerValue) ? {\n        signal: \"\".concat(paddingInnerValue.signal, \"/2\")\n      } : paddingInnerValue / 2);\n    }\n  } else if (isXorYOffset(channel)) {\n    if (scaleType === ScaleType.POINT) {\n      return 0.5; // so the point positions align with centers of band scales.\n    } else if (scaleType === ScaleType.BAND) {\n      return scaleConfig.offsetBandPaddingOuter;\n    }\n  }\n  return undefined;\n}\nexport { _paddingOuter as paddingOuter };\nfunction _reverse(scaleType, sort, channel, scaleConfig) {\n  if (channel === 'x' && scaleConfig.xReverse !== undefined) {\n    if (hasContinuousDomain(scaleType) && sort === 'descending') {\n      if (isSignalRef(scaleConfig.xReverse)) {\n        return {\n          signal: \"!\".concat(scaleConfig.xReverse.signal)\n        };\n      } else {\n        return !scaleConfig.xReverse;\n      }\n    }\n    return scaleConfig.xReverse;\n  }\n  if (hasContinuousDomain(scaleType) && sort === 'descending') {\n    // For continuous domain scales, Vega does not support domain sort.\n    // Thus, we reverse range instead if sort is descending\n    return true;\n  }\n  return undefined;\n}\nexport { _reverse as reverse };\nfunction _zero(channel, fieldDef, specifiedDomain, markDef, scaleType, scaleConfig, hasSecondaryRangeChannel) {\n  // If users explicitly provide a domain, we should not augment zero as that will be unexpected.\n  var hasCustomDomain = !!specifiedDomain && specifiedDomain !== 'unaggregated';\n  if (hasCustomDomain) {\n    if (hasContinuousDomain(scaleType)) {\n      if (isArray(specifiedDomain)) {\n        var first = specifiedDomain[0];\n        var last = specifiedDomain[specifiedDomain.length - 1];\n        if (first <= 0 && last >= 0) {\n          // if the domain includes zero, make zero remains true\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n  // If there is no custom domain, return configZero value (=`true` as default) only for the following cases:\n  // 1) using quantitative field with size\n  // While this can be either ratio or interval fields, our assumption is that\n  // ratio are more common. However, if the scaleType is discretizing scale, we want to return\n  // false so that range doesn't start at zero\n  if (channel === 'size' && fieldDef.type === 'quantitative' && !isContinuousToDiscrete(scaleType)) {\n    return true;\n  }\n  // 2) non-binned, quantitative x-scale or y-scale\n  // (For binning, we should not include zero by default because binning are calculated without zero.)\n  // (For area/bar charts with ratio scale chart, we should always include zero.)\n  if (!(isFieldDef(fieldDef) && fieldDef.bin) && util.contains([].concat(_toConsumableArray(POSITION_SCALE_CHANNELS), _toConsumableArray(POLAR_POSITION_SCALE_CHANNELS)), channel)) {\n    var orient = markDef.orient,\n      type = markDef.type;\n    if (contains(['bar', 'area', 'line', 'trail'], type)) {\n      if (orient === 'horizontal' && channel === 'y' || orient === 'vertical' && channel === 'x') {\n        return false;\n      }\n    }\n    if (contains(['bar', 'area'], type) && !hasSecondaryRangeChannel) {\n      return true;\n    }\n    return scaleConfig === null || scaleConfig === void 0 ? void 0 : scaleConfig.zero;\n  }\n  return false;\n}\nexport { _zero as zero };","map":{"version":3,"sources":["../../../../src/compile/scale/properties.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isArray } from 'vega-util';\nimport { isBinned, isBinning, isBinParams } from '../../bin';\nimport { COLOR, FILL, getSecondaryRangeChannel, isXorY, isXorYOffset, POLAR_POSITION_SCALE_CHANNELS, POSITION_SCALE_CHANNELS, STROKE } from '../../channel';\nimport { getFieldDef, getFieldOrDatumDef, isFieldDef, valueExpr } from '../../channeldef';\nimport { isDateTime } from '../../datetime';\nimport { channelHasNestedOffsetScale } from '../../encoding';\nimport * as log from '../../log';\nimport { channelScalePropertyIncompatability, hasContinuousDomain, isContinuousToContinuous, isContinuousToDiscrete, ScaleType, scaleTypeSupportProperty } from '../../scale';\nimport * as util from '../../util';\nimport { contains, getFirstDefined, keys } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { getBinSignalName } from '../data/bin';\nimport { isUnitModel } from '../model';\nimport { SignalRefWrapper } from '../signal';\nimport { mergeValuesWithExplicit, tieBreakByComparing } from '../split';\nimport { parseUnitScaleRange } from './range';\nexport function parseScaleProperty(model, property) {\n    if (isUnitModel(model)) {\n        parseUnitScaleProperty(model, property);\n    }\n    else {\n        parseNonUnitScaleProperty(model, property);\n    }\n}\nfunction parseUnitScaleProperty(model, property) {\n    const localScaleComponents = model.component.scales;\n    const { config, encoding, markDef, specifiedScales } = model;\n    for (const channel of keys(localScaleComponents)) {\n        const specifiedScale = specifiedScales[channel];\n        const localScaleCmpt = localScaleComponents[channel];\n        const mergedScaleCmpt = model.getScaleComponent(channel);\n        const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);\n        const specifiedValue = specifiedScale[property];\n        const scaleType = mergedScaleCmpt.get('type');\n        const scalePadding = mergedScaleCmpt.get('padding');\n        const scalePaddingInner = mergedScaleCmpt.get('paddingInner');\n        const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n        const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n        if (specifiedValue !== undefined) {\n            // If there is a specified value, check if it is compatible with scale type and channel\n            if (!supportedByScaleType) {\n                log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n            }\n            else if (channelIncompatability) {\n                // channel\n                log.warn(channelIncompatability);\n            }\n        }\n        if (supportedByScaleType && channelIncompatability === undefined) {\n            if (specifiedValue !== undefined) {\n                const timeUnit = fieldOrDatumDef['timeUnit'];\n                const type = fieldOrDatumDef.type;\n                switch (property) {\n                    // domainMax/Min to signal if the value is a datetime object\n                    case 'domainMax':\n                    case 'domainMin':\n                        if (isDateTime(specifiedScale[property]) || type === 'temporal' || timeUnit) {\n                            localScaleCmpt.set(property, { signal: valueExpr(specifiedScale[property], { type, timeUnit }) }, true);\n                        }\n                        else {\n                            localScaleCmpt.set(property, specifiedScale[property], true);\n                        }\n                        break;\n                    default:\n                        localScaleCmpt.copyKeyFromObject(property, specifiedScale);\n                }\n            }\n            else {\n                const value = property in scaleRules\n                    ? scaleRules[property]({\n                        model,\n                        channel,\n                        fieldOrDatumDef,\n                        scaleType,\n                        scalePadding,\n                        scalePaddingInner,\n                        domain: specifiedScale.domain,\n                        domainMin: specifiedScale.domainMin,\n                        domainMax: specifiedScale.domainMax,\n                        markDef,\n                        config,\n                        hasNestedOffsetScale: channelHasNestedOffsetScale(encoding, channel),\n                        hasSecondaryRangeChannel: !!encoding[getSecondaryRangeChannel(channel)]\n                    })\n                    : config.scale[property];\n                if (value !== undefined) {\n                    localScaleCmpt.set(property, value, false);\n                }\n            }\n        }\n    }\n}\nexport const scaleRules = {\n    bins: ({ model, fieldOrDatumDef }) => (isFieldDef(fieldOrDatumDef) ? bins(model, fieldOrDatumDef) : undefined),\n    interpolate: ({ channel, fieldOrDatumDef }) => interpolate(channel, fieldOrDatumDef.type),\n    nice: ({ scaleType, channel, domain, domainMin, domainMax, fieldOrDatumDef }) => nice(scaleType, channel, domain, domainMin, domainMax, fieldOrDatumDef),\n    padding: ({ channel, scaleType, fieldOrDatumDef, markDef, config }) => padding(channel, scaleType, config.scale, fieldOrDatumDef, markDef, config.bar),\n    paddingInner: ({ scalePadding, channel, markDef, scaleType, config, hasNestedOffsetScale }) => paddingInner(scalePadding, channel, markDef.type, scaleType, config.scale, hasNestedOffsetScale),\n    paddingOuter: ({ scalePadding, channel, scaleType, scalePaddingInner, config, hasNestedOffsetScale }) => paddingOuter(scalePadding, channel, scaleType, scalePaddingInner, config.scale, hasNestedOffsetScale),\n    reverse: ({ fieldOrDatumDef, scaleType, channel, config }) => {\n        const sort = isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : undefined;\n        return reverse(scaleType, sort, channel, config.scale);\n    },\n    zero: ({ channel, fieldOrDatumDef, domain, markDef, scaleType, config, hasSecondaryRangeChannel }) => zero(channel, fieldOrDatumDef, domain, markDef, scaleType, config.scale, hasSecondaryRangeChannel)\n};\n// This method is here rather than in range.ts to avoid circular dependency.\nexport function parseScaleRange(model) {\n    if (isUnitModel(model)) {\n        parseUnitScaleRange(model);\n    }\n    else {\n        parseNonUnitScaleProperty(model, 'range');\n    }\n}\nexport function parseNonUnitScaleProperty(model, property) {\n    const localScaleComponents = model.component.scales;\n    for (const child of model.children) {\n        if (property === 'range') {\n            parseScaleRange(child);\n        }\n        else {\n            parseScaleProperty(child, property);\n        }\n    }\n    for (const channel of keys(localScaleComponents)) {\n        let valueWithExplicit;\n        for (const child of model.children) {\n            const childComponent = child.component.scales[channel];\n            if (childComponent) {\n                const childValueWithExplicit = childComponent.getWithExplicit(property);\n                valueWithExplicit = mergeValuesWithExplicit(valueWithExplicit, childValueWithExplicit, property, 'scale', tieBreakByComparing((v1, v2) => {\n                    switch (property) {\n                        case 'range':\n                            // For step, prefer larger step\n                            if (v1.step && v2.step) {\n                                return v1.step - v2.step;\n                            }\n                            return 0;\n                        // TODO: precedence rule for other properties\n                    }\n                    return 0;\n                }));\n            }\n        }\n        localScaleComponents[channel].setWithExplicit(property, valueWithExplicit);\n    }\n}\nexport function bins(model, fieldDef) {\n    const bin = fieldDef.bin;\n    if (isBinning(bin)) {\n        const binSignal = getBinSignalName(model, fieldDef.field, bin);\n        return new SignalRefWrapper(() => {\n            return model.getSignalName(binSignal);\n        });\n    }\n    else if (isBinned(bin) && isBinParams(bin) && bin.step !== undefined) {\n        // start and stop will be determined from the scale domain\n        return {\n            step: bin.step\n        };\n    }\n    return undefined;\n}\nexport function interpolate(channel, type) {\n    if (contains([COLOR, FILL, STROKE], channel) && type !== 'nominal') {\n        return 'hcl';\n    }\n    return undefined;\n}\nexport function nice(scaleType, channel, specifiedDomain, domainMin, domainMax, fieldOrDatumDef) {\n    var _a;\n    if (((_a = getFieldDef(fieldOrDatumDef)) === null || _a === void 0 ? void 0 : _a.bin) ||\n        isArray(specifiedDomain) ||\n        domainMax != null ||\n        domainMin != null ||\n        util.contains([ScaleType.TIME, ScaleType.UTC], scaleType)) {\n        return undefined;\n    }\n    return isXorY(channel) ? true : undefined;\n}\nexport function padding(channel, scaleType, scaleConfig, fieldOrDatumDef, markDef, barConfig) {\n    if (isXorY(channel)) {\n        if (isContinuousToContinuous(scaleType)) {\n            if (scaleConfig.continuousPadding !== undefined) {\n                return scaleConfig.continuousPadding;\n            }\n            const { type, orient } = markDef;\n            if (type === 'bar' && !(isFieldDef(fieldOrDatumDef) && (fieldOrDatumDef.bin || fieldOrDatumDef.timeUnit))) {\n                if ((orient === 'vertical' && channel === 'x') || (orient === 'horizontal' && channel === 'y')) {\n                    return barConfig.continuousBandSize;\n                }\n            }\n        }\n        if (scaleType === ScaleType.POINT) {\n            return scaleConfig.pointPadding;\n        }\n    }\n    return undefined;\n}\nexport function paddingInner(paddingValue, channel, mark, scaleType, scaleConfig, hasNestedOffsetScale = false) {\n    if (paddingValue !== undefined) {\n        // If user has already manually specified \"padding\", no need to add default paddingInner.\n        return undefined;\n    }\n    if (isXorY(channel)) {\n        // Padding is only set for X and Y by default.\n        // Basically it doesn't make sense to add padding for color and size.\n        // paddingOuter would only be called if it's a band scale, just return the default for bandScale.\n        const { bandPaddingInner, barBandPaddingInner, rectBandPaddingInner, bandWithNestedOffsetPaddingInner } = scaleConfig;\n        if (hasNestedOffsetScale) {\n            return bandWithNestedOffsetPaddingInner;\n        }\n        return getFirstDefined(bandPaddingInner, mark === 'bar' ? barBandPaddingInner : rectBandPaddingInner);\n    }\n    else if (isXorYOffset(channel)) {\n        if (scaleType === ScaleType.BAND) {\n            return scaleConfig.offsetBandPaddingInner;\n        }\n    }\n    return undefined;\n}\nexport function paddingOuter(paddingValue, channel, scaleType, paddingInnerValue, scaleConfig, hasNestedOffsetScale = false) {\n    if (paddingValue !== undefined) {\n        // If user has already manually specified \"padding\", no need to add default paddingOuter.\n        return undefined;\n    }\n    if (isXorY(channel)) {\n        const { bandPaddingOuter, bandWithNestedOffsetPaddingOuter } = scaleConfig;\n        if (hasNestedOffsetScale) {\n            return bandWithNestedOffsetPaddingOuter;\n        }\n        // Padding is only set for X and Y by default.\n        // Basically it doesn't make sense to add padding for color and size.\n        if (scaleType === ScaleType.BAND) {\n            return getFirstDefined(bandPaddingOuter, \n            /* By default, paddingOuter is paddingInner / 2. The reason is that\n              size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).\n              and we want the width/height to be integer by default.\n              Note that step (by default) and cardinality are integers.) */\n            isSignalRef(paddingInnerValue) ? { signal: `${paddingInnerValue.signal}/2` } : paddingInnerValue / 2);\n        }\n    }\n    else if (isXorYOffset(channel)) {\n        if (scaleType === ScaleType.POINT) {\n            return 0.5; // so the point positions align with centers of band scales.\n        }\n        else if (scaleType === ScaleType.BAND) {\n            return scaleConfig.offsetBandPaddingOuter;\n        }\n    }\n    return undefined;\n}\nexport function reverse(scaleType, sort, channel, scaleConfig) {\n    if (channel === 'x' && scaleConfig.xReverse !== undefined) {\n        if (hasContinuousDomain(scaleType) && sort === 'descending') {\n            if (isSignalRef(scaleConfig.xReverse)) {\n                return { signal: `!${scaleConfig.xReverse.signal}` };\n            }\n            else {\n                return !scaleConfig.xReverse;\n            }\n        }\n        return scaleConfig.xReverse;\n    }\n    if (hasContinuousDomain(scaleType) && sort === 'descending') {\n        // For continuous domain scales, Vega does not support domain sort.\n        // Thus, we reverse range instead if sort is descending\n        return true;\n    }\n    return undefined;\n}\nexport function zero(channel, fieldDef, specifiedDomain, markDef, scaleType, scaleConfig, hasSecondaryRangeChannel) {\n    // If users explicitly provide a domain, we should not augment zero as that will be unexpected.\n    const hasCustomDomain = !!specifiedDomain && specifiedDomain !== 'unaggregated';\n    if (hasCustomDomain) {\n        if (hasContinuousDomain(scaleType)) {\n            if (isArray(specifiedDomain)) {\n                const first = specifiedDomain[0];\n                const last = specifiedDomain[specifiedDomain.length - 1];\n                if (first <= 0 && last >= 0) {\n                    // if the domain includes zero, make zero remains true\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n    // If there is no custom domain, return configZero value (=`true` as default) only for the following cases:\n    // 1) using quantitative field with size\n    // While this can be either ratio or interval fields, our assumption is that\n    // ratio are more common. However, if the scaleType is discretizing scale, we want to return\n    // false so that range doesn't start at zero\n    if (channel === 'size' && fieldDef.type === 'quantitative' && !isContinuousToDiscrete(scaleType)) {\n        return true;\n    }\n    // 2) non-binned, quantitative x-scale or y-scale\n    // (For binning, we should not include zero by default because binning are calculated without zero.)\n    // (For area/bar charts with ratio scale chart, we should always include zero.)\n    if (!(isFieldDef(fieldDef) && fieldDef.bin) &&\n        util.contains([...POSITION_SCALE_CHANNELS, ...POLAR_POSITION_SCALE_CHANNELS], channel)) {\n        const { orient, type } = markDef;\n        if (contains(['bar', 'area', 'line', 'trail'], type)) {\n            if ((orient === 'horizontal' && channel === 'y') || (orient === 'vertical' && channel === 'x')) {\n                return false;\n            }\n        }\n        if (contains(['bar', 'area'], type) && !hasSecondaryRangeChannel) {\n            return true;\n        }\n        return scaleConfig === null || scaleConfig === void 0 ? void 0 : scaleConfig.zero;\n    }\n    return false;\n}\n//# sourceMappingURL=properties.js.map"]},"metadata":{},"sourceType":"module"}