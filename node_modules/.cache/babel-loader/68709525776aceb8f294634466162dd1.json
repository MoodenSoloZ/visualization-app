{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Observable } from \"observable-fns\";\nvar doNothing = function doNothing() {\n  return undefined;\n};\nvar returnInput = function returnInput(input) {\n  return input;\n};\nvar runDeferred = function runDeferred(fn) {\n  return Promise.resolve().then(fn);\n};\nfunction fail(error) {\n  throw error;\n}\nfunction isThenable(thing) {\n  return thing && typeof thing.then === \"function\";\n}\n/**\n * Creates a hybrid, combining the APIs of an Observable and a Promise.\n *\n * It is used to proxy async process states when we are initially not sure\n * if that async process will yield values once (-> Promise) or multiple\n * times (-> Observable).\n *\n * Note that the observable promise inherits some of the observable's characteristics:\n * The `init` function will be called *once for every time anyone subscribes to it*.\n *\n * If this is undesired, derive a hot observable from it using `makeHot()` and\n * subscribe to that.\n */\nexport var ObservablePromise = /*#__PURE__*/function (_Observable) {\n  _inherits(ObservablePromise, _Observable);\n  var _super = _createSuper(ObservablePromise);\n  function ObservablePromise(init) {\n    var _this;\n    _classCallCheck(this, ObservablePromise);\n    _this = _super.call(this, function (originalObserver) {\n      // tslint:disable-next-line no-this-assignment\n      var self = _assertThisInitialized(_this);\n      var observer = Object.assign(Object.assign({}, originalObserver), {\n        complete: function complete() {\n          originalObserver.complete();\n          self.onCompletion();\n        },\n        error: function error(_error) {\n          originalObserver.error(_error);\n          self.onError(_error);\n        },\n        next: function next(value) {\n          originalObserver.next(value);\n          self.onNext(value);\n        }\n      });\n      try {\n        _this.initHasRun = true;\n        return init(observer);\n      } catch (error) {\n        observer.error(error);\n      }\n    });\n    _this.initHasRun = false;\n    _this.fulfillmentCallbacks = [];\n    _this.rejectionCallbacks = [];\n    _this.firstValueSet = false;\n    _this.state = \"pending\";\n    return _this;\n  }\n  _createClass(ObservablePromise, [{\n    key: \"onNext\",\n    value: function onNext(value) {\n      if (!this.firstValueSet) {\n        this.firstValue = value;\n        this.firstValueSet = true;\n      }\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(error) {\n      this.state = \"rejected\";\n      this.rejection = error;\n      var _iterator = _createForOfIteratorHelper(this.rejectionCallbacks),\n        _step;\n      try {\n        var _loop = function _loop() {\n          var onRejected = _step.value;\n          // Promisifying the call to turn errors into unhandled promise rejections\n          // instead of them failing sync and cancelling the iteration\n          runDeferred(function () {\n            return onRejected(error);\n          });\n        };\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"onCompletion\",\n    value: function onCompletion() {\n      var _this2 = this;\n      this.state = \"fulfilled\";\n      var _iterator2 = _createForOfIteratorHelper(this.fulfillmentCallbacks),\n        _step2;\n      try {\n        var _loop2 = function _loop2() {\n          var onFulfilled = _step2.value;\n          // Promisifying the call to turn errors into unhandled promise rejections\n          // instead of them failing sync and cancelling the iteration\n          runDeferred(function () {\n            return onFulfilled(_this2.firstValue);\n          });\n        };\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          _loop2();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"then\",\n    value: function then(onFulfilledRaw, onRejectedRaw) {\n      var _this3 = this;\n      var onFulfilled = onFulfilledRaw || returnInput;\n      var onRejected = onRejectedRaw || fail;\n      var onRejectedCalled = false;\n      return new Promise(function (resolve, reject) {\n        var rejectionCallback = function rejectionCallback(error) {\n          if (onRejectedCalled) return;\n          onRejectedCalled = true;\n          try {\n            resolve(onRejected(error));\n          } catch (anotherError) {\n            reject(anotherError);\n          }\n        };\n        var fulfillmentCallback = function fulfillmentCallback(value) {\n          try {\n            resolve(onFulfilled(value));\n          } catch (error) {\n            rejectionCallback(error);\n          }\n        };\n        if (!_this3.initHasRun) {\n          _this3.subscribe({\n            error: rejectionCallback\n          });\n        }\n        if (_this3.state === \"fulfilled\") {\n          return resolve(onFulfilled(_this3.firstValue));\n        }\n        if (_this3.state === \"rejected\") {\n          onRejectedCalled = true;\n          return resolve(onRejected(_this3.rejection));\n        }\n        _this3.fulfillmentCallbacks.push(fulfillmentCallback);\n        _this3.rejectionCallbacks.push(rejectionCallback);\n      });\n    }\n  }, {\n    key: \"catch\",\n    value: function _catch(onRejected) {\n      return this.then(undefined, onRejected);\n    }\n  }, {\n    key: \"finally\",\n    value: function _finally(onCompleted) {\n      var handler = onCompleted || doNothing;\n      return this.then(function (value) {\n        handler();\n        return value;\n      }, function () {\n        return handler();\n      });\n    }\n  }], [{\n    key: \"from\",\n    value: function from(thing) {\n      if (isThenable(thing)) {\n        return new ObservablePromise(function (observer) {\n          var onFulfilled = function onFulfilled(value) {\n            observer.next(value);\n            observer.complete();\n          };\n          var onRejected = function onRejected(error) {\n            observer.error(error);\n          };\n          thing.then(onFulfilled, onRejected);\n        });\n      } else {\n        return _get(_getPrototypeOf(ObservablePromise), \"from\", this).call(this, thing);\n      }\n    }\n  }]);\n  return ObservablePromise;\n}(Observable);","map":{"version":3,"names":["Observable","doNothing","undefined","returnInput","input","runDeferred","fn","Promise","resolve","then","fail","error","isThenable","thing","ObservablePromise","init","originalObserver","self","observer","Object","assign","complete","onCompletion","onError","next","value","onNext","initHasRun","fulfillmentCallbacks","rejectionCallbacks","firstValueSet","state","firstValue","rejection","onRejected","onFulfilled","onFulfilledRaw","onRejectedRaw","onRejectedCalled","reject","rejectionCallback","anotherError","fulfillmentCallback","subscribe","push","onCompleted","handler"],"sources":["/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/gosling.js/node_modules/threads/dist-esm/observable-promise.js"],"sourcesContent":["import { Observable } from \"observable-fns\";\nconst doNothing = () => undefined;\nconst returnInput = (input) => input;\nconst runDeferred = (fn) => Promise.resolve().then(fn);\nfunction fail(error) {\n    throw error;\n}\nfunction isThenable(thing) {\n    return thing && typeof thing.then === \"function\";\n}\n/**\n * Creates a hybrid, combining the APIs of an Observable and a Promise.\n *\n * It is used to proxy async process states when we are initially not sure\n * if that async process will yield values once (-> Promise) or multiple\n * times (-> Observable).\n *\n * Note that the observable promise inherits some of the observable's characteristics:\n * The `init` function will be called *once for every time anyone subscribes to it*.\n *\n * If this is undesired, derive a hot observable from it using `makeHot()` and\n * subscribe to that.\n */\nexport class ObservablePromise extends Observable {\n    constructor(init) {\n        super((originalObserver) => {\n            // tslint:disable-next-line no-this-assignment\n            const self = this;\n            const observer = Object.assign(Object.assign({}, originalObserver), { complete() {\n                    originalObserver.complete();\n                    self.onCompletion();\n                }, error(error) {\n                    originalObserver.error(error);\n                    self.onError(error);\n                },\n                next(value) {\n                    originalObserver.next(value);\n                    self.onNext(value);\n                } });\n            try {\n                this.initHasRun = true;\n                return init(observer);\n            }\n            catch (error) {\n                observer.error(error);\n            }\n        });\n        this.initHasRun = false;\n        this.fulfillmentCallbacks = [];\n        this.rejectionCallbacks = [];\n        this.firstValueSet = false;\n        this.state = \"pending\";\n    }\n    onNext(value) {\n        if (!this.firstValueSet) {\n            this.firstValue = value;\n            this.firstValueSet = true;\n        }\n    }\n    onError(error) {\n        this.state = \"rejected\";\n        this.rejection = error;\n        for (const onRejected of this.rejectionCallbacks) {\n            // Promisifying the call to turn errors into unhandled promise rejections\n            // instead of them failing sync and cancelling the iteration\n            runDeferred(() => onRejected(error));\n        }\n    }\n    onCompletion() {\n        this.state = \"fulfilled\";\n        for (const onFulfilled of this.fulfillmentCallbacks) {\n            // Promisifying the call to turn errors into unhandled promise rejections\n            // instead of them failing sync and cancelling the iteration\n            runDeferred(() => onFulfilled(this.firstValue));\n        }\n    }\n    then(onFulfilledRaw, onRejectedRaw) {\n        const onFulfilled = onFulfilledRaw || returnInput;\n        const onRejected = onRejectedRaw || fail;\n        let onRejectedCalled = false;\n        return new Promise((resolve, reject) => {\n            const rejectionCallback = (error) => {\n                if (onRejectedCalled)\n                    return;\n                onRejectedCalled = true;\n                try {\n                    resolve(onRejected(error));\n                }\n                catch (anotherError) {\n                    reject(anotherError);\n                }\n            };\n            const fulfillmentCallback = (value) => {\n                try {\n                    resolve(onFulfilled(value));\n                }\n                catch (error) {\n                    rejectionCallback(error);\n                }\n            };\n            if (!this.initHasRun) {\n                this.subscribe({ error: rejectionCallback });\n            }\n            if (this.state === \"fulfilled\") {\n                return resolve(onFulfilled(this.firstValue));\n            }\n            if (this.state === \"rejected\") {\n                onRejectedCalled = true;\n                return resolve(onRejected(this.rejection));\n            }\n            this.fulfillmentCallbacks.push(fulfillmentCallback);\n            this.rejectionCallbacks.push(rejectionCallback);\n        });\n    }\n    catch(onRejected) {\n        return this.then(undefined, onRejected);\n    }\n    finally(onCompleted) {\n        const handler = onCompleted || doNothing;\n        return this.then((value) => {\n            handler();\n            return value;\n        }, () => handler());\n    }\n    static from(thing) {\n        if (isThenable(thing)) {\n            return new ObservablePromise(observer => {\n                const onFulfilled = (value) => {\n                    observer.next(value);\n                    observer.complete();\n                };\n                const onRejected = (error) => {\n                    observer.error(error);\n                };\n                thing.then(onFulfilled, onRejected);\n            });\n        }\n        else {\n            return super.from(thing);\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}