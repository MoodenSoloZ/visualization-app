{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { isObject, isArray, extend, hasOwnProperty, array, stringValue, peek, isString, error, splitAccessPath, mergeConfig } from 'vega-util';\nimport { parseExpression } from 'vega-functions';\nimport { parseSelector } from 'vega-event-selector';\nimport { isValidScaleType, isDiscrete, isQuantile, isDiscretizing, isContinuous } from 'vega-scale';\nimport { definition as definition$1 } from 'vega-dataflow';\nfunction parseAutosize(spec) {\n  return isObject(spec) ? spec : {\n    type: spec || 'pad'\n  };\n}\nvar number = function number(_) {\n  return +_ || 0;\n};\nvar paddingObject = function paddingObject(_) {\n  return {\n    top: _,\n    bottom: _,\n    left: _,\n    right: _\n  };\n};\nfunction parsePadding(spec) {\n  return !isObject(spec) ? paddingObject(number(spec)) : spec.signal ? spec : {\n    top: number(spec.top),\n    bottom: number(spec.bottom),\n    left: number(spec.left),\n    right: number(spec.right)\n  };\n}\nvar encoder = function encoder(_) {\n  return isObject(_) && !isArray(_) ? extend({}, _) : {\n    value: _\n  };\n};\nfunction addEncode(object, name, value, set) {\n  if (value != null) {\n    var isEncoder = isObject(value) && !isArray(value) || isArray(value) && value.length && isObject(value[0]); // Always assign signal to update, even if the signal is from the enter block\n\n    if (isEncoder) {\n      object.update[name] = value;\n    } else {\n      object[set || 'enter'][name] = {\n        value: value\n      };\n    }\n    return 1;\n  } else {\n    return 0;\n  }\n}\nfunction addEncoders(object, enter, update) {\n  for (var name in enter) {\n    addEncode(object, name, enter[name]);\n  }\n  for (var _name in update) {\n    addEncode(object, _name, update[_name], 'update');\n  }\n}\nfunction extendEncode(encode, extra, skip) {\n  for (var name in extra) {\n    if (skip && hasOwnProperty(skip, name)) continue;\n    encode[name] = extend(encode[name] || {}, extra[name]);\n  }\n  return encode;\n}\nfunction has(key, encode) {\n  return encode && (encode.enter && encode.enter[key] || encode.update && encode.update[key]);\n}\nvar MarkRole = 'mark';\nvar FrameRole = 'frame';\nvar ScopeRole = 'scope';\nvar AxisRole = 'axis';\nvar AxisDomainRole = 'axis-domain';\nvar AxisGridRole = 'axis-grid';\nvar AxisLabelRole = 'axis-label';\nvar AxisTickRole = 'axis-tick';\nvar AxisTitleRole = 'axis-title';\nvar LegendRole = 'legend';\nvar LegendBandRole = 'legend-band';\nvar LegendEntryRole = 'legend-entry';\nvar LegendGradientRole = 'legend-gradient';\nvar LegendLabelRole = 'legend-label';\nvar LegendSymbolRole = 'legend-symbol';\nvar LegendTitleRole = 'legend-title';\nvar TitleRole = 'title';\nvar TitleTextRole = 'title-text';\nvar TitleSubtitleRole = 'title-subtitle';\nfunction applyDefaults(encode, type, role, style, config) {\n  var defaults = {},\n    enter = {};\n  var update, key, skip, props; // if text mark, apply global lineBreak settings (#2370)\n\n  key = 'lineBreak';\n  if (type === 'text' && config[key] != null && !has(key, encode)) {\n    applyDefault(defaults, key, config[key]);\n  } // ignore legend and axis roles\n\n  if (role == 'legend' || String(role).startsWith('axis')) {\n    role = null;\n  } // resolve mark config\n\n  props = role === FrameRole ? config.group : role === MarkRole ? extend({}, config.mark, config[type]) : null;\n  for (key in props) {\n    // do not apply defaults if relevant fields are defined\n    skip = has(key, encode) || (key === 'fill' || key === 'stroke') && (has('fill', encode) || has('stroke', encode));\n    if (!skip) applyDefault(defaults, key, props[key]);\n  } // resolve styles, apply with increasing precedence\n\n  array(style).forEach(function (name) {\n    var props = config.style && config.style[name];\n    for (var _key in props) {\n      if (!has(_key, encode)) {\n        applyDefault(defaults, _key, props[_key]);\n      }\n    }\n  });\n  encode = extend({}, encode); // defensive copy\n\n  for (key in defaults) {\n    props = defaults[key];\n    if (props.signal) {\n      (update = update || {})[key] = props;\n    } else {\n      enter[key] = props;\n    }\n  }\n  encode.enter = extend(enter, encode.enter);\n  if (update) encode.update = extend(update, encode.update);\n  return encode;\n}\nfunction applyDefault(defaults, key, value) {\n  defaults[key] = value && value.signal ? {\n    signal: value.signal\n  } : {\n    value: value\n  };\n}\nvar scaleRef = function scaleRef(scale) {\n  return isString(scale) ? stringValue(scale) : scale.signal ? \"(\".concat(scale.signal, \")\") : field(scale);\n};\nfunction entry$1(enc) {\n  if (enc.gradient != null) {\n    return gradient(enc);\n  }\n  var value = enc.signal ? \"(\".concat(enc.signal, \")\") : enc.color ? color(enc.color) : enc.field != null ? field(enc.field) : enc.value !== undefined ? stringValue(enc.value) : undefined;\n  if (enc.scale != null) {\n    value = scale(enc, value);\n  }\n  if (value === undefined) {\n    value = null;\n  }\n  if (enc.exponent != null) {\n    value = \"pow(\".concat(value, \",\").concat(property(enc.exponent), \")\");\n  }\n  if (enc.mult != null) {\n    value += \"*\".concat(property(enc.mult));\n  }\n  if (enc.offset != null) {\n    value += \"+\".concat(property(enc.offset));\n  }\n  if (enc.round) {\n    value = \"round(\".concat(value, \")\");\n  }\n  return value;\n}\nvar _color = function _color(type, x, y, z) {\n  return \"(\".concat(type, \"(\").concat([x, y, z].map(entry$1).join(','), \")+'')\");\n};\nfunction color(enc) {\n  return enc.c ? _color('hcl', enc.h, enc.c, enc.l) : enc.h || enc.s ? _color('hsl', enc.h, enc.s, enc.l) : enc.l || enc.a ? _color('lab', enc.l, enc.a, enc.b) : enc.r || enc.g || enc.b ? _color('rgb', enc.r, enc.g, enc.b) : null;\n}\nfunction gradient(enc) {\n  // map undefined to null; expression lang does not allow undefined\n  var args = [enc.start, enc.stop, enc.count].map(function (_) {\n    return _ == null ? null : stringValue(_);\n  }); // trim null inputs from the end\n\n  while (args.length && peek(args) == null) {\n    args.pop();\n  }\n  args.unshift(scaleRef(enc.gradient));\n  return \"gradient(\".concat(args.join(','), \")\");\n}\nfunction property(property) {\n  return isObject(property) ? '(' + entry$1(property) + ')' : property;\n}\nfunction field(ref) {\n  return resolveField(isObject(ref) ? ref : {\n    datum: ref\n  });\n}\nfunction resolveField(ref) {\n  var object, level, field;\n  if (ref.signal) {\n    object = 'datum';\n    field = ref.signal;\n  } else if (ref.group || ref.parent) {\n    level = Math.max(1, ref.level || 1);\n    object = 'item';\n    while (level-- > 0) {\n      object += '.mark.group';\n    }\n    if (ref.parent) {\n      field = ref.parent;\n      object += '.datum';\n    } else {\n      field = ref.group;\n    }\n  } else if (ref.datum) {\n    object = 'datum';\n    field = ref.datum;\n  } else {\n    error('Invalid field reference: ' + stringValue(ref));\n  }\n  if (!ref.signal) {\n    field = isString(field) ? splitAccessPath(field).map(stringValue).join('][') : resolveField(field);\n  }\n  return object + '[' + field + ']';\n}\nfunction scale(enc, value) {\n  var scale = scaleRef(enc.scale);\n  if (enc.range != null) {\n    // pull value from scale range\n    value = \"lerp(_range(\".concat(scale, \"), \").concat(+enc.range, \")\");\n  } else {\n    // run value through scale and/or pull scale bandwidth\n    if (value !== undefined) value = \"_scale(\".concat(scale, \", \").concat(value, \")\");\n    if (enc.band) {\n      value = (value ? value + '+' : '') + \"_bandwidth(\".concat(scale, \")\") + (+enc.band === 1 ? '' : '*' + property(enc.band));\n      if (enc.extra) {\n        // include logic to handle extraneous elements\n        value = \"(datum.extra ? _scale(\".concat(scale, \", datum.extra.value) : \").concat(value, \")\");\n      }\n    }\n    if (value == null) value = '0';\n  }\n  return value;\n}\nfunction rule(enc) {\n  var code = '';\n  enc.forEach(function (rule) {\n    var value = entry$1(rule);\n    code += rule.test ? \"(\".concat(rule.test, \")?\").concat(value, \":\") : value;\n  }); // if no else clause, terminate with null (#1366)\n\n  if (peek(code) === ':') {\n    code += 'null';\n  }\n  return code;\n}\nfunction parseEncode(encode, type, role, style, scope, params) {\n  var enc = {};\n  params = params || {};\n  params.encoders = {\n    $encode: enc\n  };\n  encode = applyDefaults(encode, type, role, style, scope.config);\n  for (var key in encode) {\n    enc[key] = parseBlock(encode[key], type, params, scope);\n  }\n  return params;\n}\nfunction parseBlock(block, marktype, params, scope) {\n  var channels = {},\n    fields = {};\n  for (var name in block) {\n    if (block[name] != null) {\n      // skip any null entries\n      channels[name] = parse$1(expr(block[name]), scope, params, fields);\n    }\n  }\n  return {\n    $expr: {\n      marktype: marktype,\n      channels: channels\n    },\n    $fields: Object.keys(fields),\n    $output: Object.keys(block)\n  };\n}\nfunction expr(enc) {\n  return isArray(enc) ? rule(enc) : entry$1(enc);\n}\nfunction parse$1(code, scope, params, fields) {\n  var expr = parseExpression(code, scope);\n  expr.$fields.forEach(function (name) {\n    return fields[name] = 1;\n  });\n  extend(params, expr.$params);\n  return expr.$expr;\n}\nvar OUTER = 'outer',\n  OUTER_INVALID = ['value', 'update', 'init', 'react', 'bind'];\nfunction outerError(prefix, name) {\n  error(prefix + ' for \"outer\" push: ' + stringValue(name));\n}\nfunction parseSignal(signal, scope) {\n  var name = signal.name;\n  if (signal.push === OUTER) {\n    // signal must already be defined, raise error if not\n    if (!scope.signals[name]) outerError('No prior signal definition', name); // signal push must not use properties reserved for standard definition\n\n    OUTER_INVALID.forEach(function (prop) {\n      if (signal[prop] !== undefined) outerError('Invalid property ', prop);\n    });\n  } else {\n    // define a new signal in the current scope\n    var op = scope.addSignal(name, signal.value);\n    if (signal.react === false) op.react = false;\n    if (signal.bind) scope.addBinding(name, signal.bind);\n  }\n}\nfunction Entry(type, value, params, parent) {\n  this.id = -1;\n  this.type = type;\n  this.value = value;\n  this.params = params;\n  if (parent) this.parent = parent;\n}\nfunction entry(type, value, params, parent) {\n  return new Entry(type, value, params, parent);\n}\nfunction operator(value, params) {\n  return entry('operator', value, params);\n} // -----\n\nfunction ref(op) {\n  var ref = {\n    $ref: op.id\n  }; // if operator not yet registered, cache ref to resolve later\n\n  if (op.id < 0) (op.refs = op.refs || []).push(ref);\n  return ref;\n}\nfunction fieldRef$1(field, name) {\n  return name ? {\n    $field: field,\n    $name: name\n  } : {\n    $field: field\n  };\n}\nvar keyFieldRef = fieldRef$1('key');\nfunction _compareRef(fields, orders) {\n  return {\n    $compare: fields,\n    $order: orders\n  };\n}\nfunction _keyRef(fields, flat) {\n  var ref = {\n    $key: fields\n  };\n  if (flat) ref.$flat = true;\n  return ref;\n} // -----\n\nvar Ascending = 'ascending';\nvar Descending = 'descending';\nfunction sortKey(sort) {\n  return !isObject(sort) ? '' : (sort.order === Descending ? '-' : '+') + aggrField(sort.op, sort.field);\n}\nfunction aggrField(op, field) {\n  return (op && op.signal ? '$' + op.signal : op || '') + (op && field ? '_' : '') + (field && field.signal ? '$' + field.signal : field || '');\n} // -----\n\nvar Scope$1 = 'scope';\nvar View = 'view';\nfunction isSignal(_) {\n  return _ && _.signal;\n}\nfunction isExpr$1(_) {\n  return _ && _.expr;\n}\nfunction hasSignal(_) {\n  if (isSignal(_)) return true;\n  if (isObject(_)) for (var key in _) {\n    if (hasSignal(_[key])) return true;\n  }\n  return false;\n}\nfunction value(specValue, defaultValue) {\n  return specValue != null ? specValue : defaultValue;\n}\nfunction deref(v) {\n  return v && v.signal || v;\n}\nvar Timer = 'timer';\nfunction parseStream(stream, scope) {\n  var method = stream.merge ? mergeStream : stream.stream ? nestedStream : stream.type ? eventStream : error('Invalid stream specification: ' + stringValue(stream));\n  return method(stream, scope);\n}\nfunction eventSource(source) {\n  return source === Scope$1 ? View : source || View;\n}\nfunction mergeStream(stream, scope) {\n  var list = stream.merge.map(function (s) {\n      return parseStream(s, scope);\n    }),\n    entry = streamParameters({\n      merge: list\n    }, stream, scope);\n  return scope.addStream(entry).id;\n}\nfunction nestedStream(stream, scope) {\n  var id = parseStream(stream.stream, scope),\n    entry = streamParameters({\n      stream: id\n    }, stream, scope);\n  return scope.addStream(entry).id;\n}\nfunction eventStream(stream, scope) {\n  var id;\n  if (stream.type === Timer) {\n    id = scope.event(Timer, stream.throttle);\n    stream = {\n      between: stream.between,\n      filter: stream.filter\n    };\n  } else {\n    id = scope.event(eventSource(stream.source), stream.type);\n  }\n  var entry = streamParameters({\n    stream: id\n  }, stream, scope);\n  return Object.keys(entry).length === 1 ? id : scope.addStream(entry).id;\n}\nfunction streamParameters(entry, stream, scope) {\n  var param = stream.between;\n  if (param) {\n    if (param.length !== 2) {\n      error('Stream \"between\" parameter must have 2 entries: ' + stringValue(stream));\n    }\n    entry.between = [parseStream(param[0], scope), parseStream(param[1], scope)];\n  }\n  param = stream.filter ? [].concat(stream.filter) : [];\n  if (stream.marktype || stream.markname || stream.markrole) {\n    // add filter for mark type, name and/or role\n    param.push(filterMark(stream.marktype, stream.markname, stream.markrole));\n  }\n  if (stream.source === Scope$1) {\n    // add filter to limit events from sub-scope only\n    param.push('inScope(event.item)');\n  }\n  if (param.length) {\n    entry.filter = parseExpression('(' + param.join(')&&(') + ')', scope).$expr;\n  }\n  if ((param = stream.throttle) != null) {\n    entry.throttle = +param;\n  }\n  if ((param = stream.debounce) != null) {\n    entry.debounce = +param;\n  }\n  if (stream.consume) {\n    entry.consume = true;\n  }\n  return entry;\n}\nfunction filterMark(type, name, role) {\n  var item = 'event.item';\n  return item + (type && type !== '*' ? '&&' + item + '.mark.marktype===\\'' + type + '\\'' : '') + (role ? '&&' + item + '.mark.role===\\'' + role + '\\'' : '') + (name ? '&&' + item + '.mark.name===\\'' + name + '\\'' : '');\n}\nvar OP_VALUE_EXPR = {\n  code: '_.$value',\n  ast: {\n    type: 'Identifier',\n    value: 'value'\n  }\n};\nfunction parseUpdate(spec, scope, target) {\n  var encode = spec.encode,\n    entry = {\n      target: target\n    };\n  var events = spec.events,\n    update = spec.update,\n    sources = [];\n  if (!events) {\n    error('Signal update missing events specification.');\n  } // interpret as an event selector string\n\n  if (isString(events)) {\n    events = parseSelector(events, scope.isSubscope() ? Scope$1 : View);\n  } // separate event streams from signal updates\n\n  events = array(events).filter(function (s) {\n    return s.signal || s.scale ? (sources.push(s), 0) : 1;\n  }); // merge internal operator listeners\n\n  if (sources.length > 1) {\n    sources = [mergeSources(sources)];\n  } // merge event streams, include as source\n\n  if (events.length) {\n    sources.push(events.length > 1 ? {\n      merge: events\n    } : events[0]);\n  }\n  if (encode != null) {\n    if (update) error('Signal encode and update are mutually exclusive.');\n    update = 'encode(item(),' + stringValue(encode) + ')';\n  } // resolve update value\n\n  entry.update = isString(update) ? parseExpression(update, scope) : update.expr != null ? parseExpression(update.expr, scope) : update.value != null ? update.value : update.signal != null ? {\n    $expr: OP_VALUE_EXPR,\n    $params: {\n      $value: scope.signalRef(update.signal)\n    }\n  } : error('Invalid signal update specification.');\n  if (spec.force) {\n    entry.options = {\n      force: true\n    };\n  }\n  sources.forEach(function (source) {\n    return scope.addUpdate(extend(streamSource(source, scope), entry));\n  });\n}\nfunction streamSource(stream, scope) {\n  return {\n    source: stream.signal ? scope.signalRef(stream.signal) : stream.scale ? scope.scaleRef(stream.scale) : parseStream(stream, scope)\n  };\n}\nfunction mergeSources(sources) {\n  return {\n    signal: '[' + sources.map(function (s) {\n      return s.scale ? 'scale(\"' + s.scale + '\")' : s.signal;\n    }) + ']'\n  };\n}\nfunction parseSignalUpdates(signal, scope) {\n  var op = scope.getSignal(signal.name);\n  var expr = signal.update;\n  if (signal.init) {\n    if (expr) {\n      error('Signals can not include both init and update expressions.');\n    } else {\n      expr = signal.init;\n      op.initonly = true;\n    }\n  }\n  if (expr) {\n    expr = parseExpression(expr, scope);\n    op.update = expr.$expr;\n    op.params = expr.$params;\n  }\n  if (signal.on) {\n    signal.on.forEach(function (_) {\n      return parseUpdate(_, scope, op.id);\n    });\n  }\n}\nvar transform = function transform(name) {\n  return function (params, value, parent) {\n    return entry(name, value, params || undefined, parent);\n  };\n};\nvar Aggregate = transform('aggregate');\nvar AxisTicks = transform('axisticks');\nvar Bound = transform('bound');\nvar Collect = transform('collect');\nvar Compare = transform('compare');\nvar DataJoin = transform('datajoin');\nvar Encode = transform('encode');\nvar Expression = transform('expression');\nvar Facet = transform('facet');\nvar Field = transform('field');\nvar Key = transform('key');\nvar LegendEntries = transform('legendentries');\nvar Load = transform('load');\nvar Mark = transform('mark');\nvar MultiExtent = transform('multiextent');\nvar MultiValues = transform('multivalues');\nvar Overlap = transform('overlap');\nvar Params = transform('params');\nvar PreFacet = transform('prefacet');\nvar Projection = transform('projection');\nvar Proxy = transform('proxy');\nvar Relay = transform('relay');\nvar Render = transform('render');\nvar Scale = transform('scale');\nvar Sieve = transform('sieve');\nvar SortItems = transform('sortitems');\nvar ViewLayout = transform('viewlayout');\nvar Values = transform('values');\nvar FIELD_REF_ID = 0;\nvar MULTIDOMAIN_SORT_OPS = {\n  min: 'min',\n  max: 'max',\n  count: 'sum'\n};\nfunction initScale(spec, scope) {\n  var type = spec.type || 'linear';\n  if (!isValidScaleType(type)) {\n    error('Unrecognized scale type: ' + stringValue(type));\n  }\n  scope.addScale(spec.name, {\n    type: type,\n    domain: undefined\n  });\n}\nfunction parseScale(spec, scope) {\n  var params = scope.getScale(spec.name).params;\n  var key;\n  params.domain = parseScaleDomain(spec.domain, spec, scope);\n  if (spec.range != null) {\n    params.range = parseScaleRange(spec, scope, params);\n  }\n  if (spec.interpolate != null) {\n    parseScaleInterpolate(spec.interpolate, params);\n  }\n  if (spec.nice != null) {\n    params.nice = parseScaleNice(spec.nice);\n  }\n  if (spec.bins != null) {\n    params.bins = parseScaleBins(spec.bins, scope);\n  }\n  for (key in spec) {\n    if (hasOwnProperty(params, key) || key === 'name') continue;\n    params[key] = parseLiteral(spec[key], scope);\n  }\n}\nfunction parseLiteral(v, scope) {\n  return !isObject(v) ? v : v.signal ? scope.signalRef(v.signal) : error('Unsupported object: ' + stringValue(v));\n}\nfunction parseArray(v, scope) {\n  return v.signal ? scope.signalRef(v.signal) : v.map(function (v) {\n    return parseLiteral(v, scope);\n  });\n}\nfunction dataLookupError(name) {\n  error('Can not find data set: ' + stringValue(name));\n} // -- SCALE DOMAIN ----\n\nfunction parseScaleDomain(domain, spec, scope) {\n  if (!domain) {\n    if (spec.domainMin != null || spec.domainMax != null) {\n      error('No scale domain defined for domainMin/domainMax to override.');\n    }\n    return; // default domain\n  }\n\n  return domain.signal ? scope.signalRef(domain.signal) : (isArray(domain) ? explicitDomain : domain.fields ? multipleDomain : singularDomain)(domain, spec, scope);\n}\nfunction explicitDomain(domain, spec, scope) {\n  return domain.map(function (v) {\n    return parseLiteral(v, scope);\n  });\n}\nfunction singularDomain(domain, spec, scope) {\n  var data = scope.getData(domain.data);\n  if (!data) dataLookupError(domain.data);\n  return isDiscrete(spec.type) ? data.valuesRef(scope, domain.field, parseSort(domain.sort, false)) : isQuantile(spec.type) ? data.domainRef(scope, domain.field) : data.extentRef(scope, domain.field);\n}\nfunction multipleDomain(domain, spec, scope) {\n  var data = domain.data,\n    fields = domain.fields.reduce(function (dom, d) {\n      d = isString(d) ? {\n        data: data,\n        field: d\n      } : isArray(d) || d.signal ? fieldRef(d, scope) : d;\n      dom.push(d);\n      return dom;\n    }, []);\n  return (isDiscrete(spec.type) ? ordinalMultipleDomain : isQuantile(spec.type) ? quantileMultipleDomain : numericMultipleDomain)(domain, scope, fields);\n}\nfunction fieldRef(data, scope) {\n  var name = '_:vega:_' + FIELD_REF_ID++,\n    coll = Collect({});\n  if (isArray(data)) {\n    coll.value = {\n      $ingest: data\n    };\n  } else if (data.signal) {\n    var code = 'setdata(' + stringValue(name) + ',' + data.signal + ')';\n    coll.params.input = scope.signalRef(code);\n  }\n  scope.addDataPipeline(name, [coll, Sieve({})]);\n  return {\n    data: name,\n    field: 'data'\n  };\n}\nfunction ordinalMultipleDomain(domain, scope, fields) {\n  var sort = parseSort(domain.sort, true);\n  var a, v; // get value counts for each domain field\n\n  var counts = fields.map(function (f) {\n    var data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.countsRef(scope, f.field, sort);\n  }); // aggregate the results from each domain field\n\n  var p = {\n    groupby: keyFieldRef,\n    pulse: counts\n  };\n  if (sort) {\n    a = sort.op || 'count';\n    v = sort.field ? aggrField(a, sort.field) : 'count';\n    p.ops = [MULTIDOMAIN_SORT_OPS[a]];\n    p.fields = [scope.fieldRef(v)];\n    p.as = [v];\n  }\n  a = scope.add(Aggregate(p)); // collect aggregate output\n\n  var c = scope.add(Collect({\n    pulse: ref(a)\n  })); // extract values for combined domain\n\n  v = scope.add(Values({\n    field: keyFieldRef,\n    sort: scope.sortRef(sort),\n    pulse: ref(c)\n  }));\n  return ref(v);\n}\nfunction parseSort(sort, multidomain) {\n  if (sort) {\n    if (!sort.field && !sort.op) {\n      if (isObject(sort)) sort.field = 'key';else sort = {\n        field: 'key'\n      };\n    } else if (!sort.field && sort.op !== 'count') {\n      error('No field provided for sort aggregate op: ' + sort.op);\n    } else if (multidomain && sort.field) {\n      if (sort.op && !MULTIDOMAIN_SORT_OPS[sort.op]) {\n        error('Multiple domain scales can not be sorted using ' + sort.op);\n      }\n    }\n  }\n  return sort;\n}\nfunction quantileMultipleDomain(domain, scope, fields) {\n  // get value arrays for each domain field\n  var values = fields.map(function (f) {\n    var data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.domainRef(scope, f.field);\n  }); // combine value arrays\n\n  return ref(scope.add(MultiValues({\n    values: values\n  })));\n}\nfunction numericMultipleDomain(domain, scope, fields) {\n  // get extents for each domain field\n  var extents = fields.map(function (f) {\n    var data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.extentRef(scope, f.field);\n  }); // combine extents\n\n  return ref(scope.add(MultiExtent({\n    extents: extents\n  })));\n} // -- SCALE BINS -----\n\nfunction parseScaleBins(v, scope) {\n  return v.signal || isArray(v) ? parseArray(v, scope) : scope.objectProperty(v);\n} // -- SCALE NICE -----\n\nfunction parseScaleNice(nice) {\n  return isObject(nice) ? {\n    interval: parseLiteral(nice.interval),\n    step: parseLiteral(nice.step)\n  } : parseLiteral(nice);\n} // -- SCALE INTERPOLATION -----\n\nfunction parseScaleInterpolate(interpolate, params) {\n  params.interpolate = parseLiteral(interpolate.type || interpolate);\n  if (interpolate.gamma != null) {\n    params.interpolateGamma = parseLiteral(interpolate.gamma);\n  }\n} // -- SCALE RANGE -----\n\nfunction parseScaleRange(spec, scope, params) {\n  var config = scope.config.range;\n  var range = spec.range;\n  if (range.signal) {\n    return scope.signalRef(range.signal);\n  } else if (isString(range)) {\n    if (config && hasOwnProperty(config, range)) {\n      spec = extend({}, spec, {\n        range: config[range]\n      });\n      return parseScaleRange(spec, scope, params);\n    } else if (range === 'width') {\n      range = [0, {\n        signal: 'width'\n      }];\n    } else if (range === 'height') {\n      range = isDiscrete(spec.type) ? [0, {\n        signal: 'height'\n      }] : [{\n        signal: 'height'\n      }, 0];\n    } else {\n      error('Unrecognized scale range value: ' + stringValue(range));\n    }\n  } else if (range.scheme) {\n    params.scheme = isArray(range.scheme) ? parseArray(range.scheme, scope) : parseLiteral(range.scheme, scope);\n    if (range.extent) params.schemeExtent = parseArray(range.extent, scope);\n    if (range.count) params.schemeCount = parseLiteral(range.count, scope);\n    return;\n  } else if (range.step) {\n    params.rangeStep = parseLiteral(range.step, scope);\n    return;\n  } else if (isDiscrete(spec.type) && !isArray(range)) {\n    return parseScaleDomain(range, spec, scope);\n  } else if (!isArray(range)) {\n    error('Unsupported range type: ' + stringValue(range));\n  }\n  return range.map(function (v) {\n    return (isArray(v) ? parseArray : parseLiteral)(v, scope);\n  });\n}\nfunction parseProjection(proj, scope) {\n  var config = scope.config.projection || {},\n    params = {};\n  for (var name in proj) {\n    if (name === 'name') continue;\n    params[name] = parseParameter$1(proj[name], name, scope);\n  } // apply projection defaults from config\n\n  for (var _name2 in config) {\n    if (params[_name2] == null) {\n      params[_name2] = parseParameter$1(config[_name2], _name2, scope);\n    }\n  }\n  scope.addProjection(proj.name, params);\n}\nfunction parseParameter$1(_, name, scope) {\n  return isArray(_) ? _.map(function (_) {\n    return parseParameter$1(_, name, scope);\n  }) : !isObject(_) ? _ : _.signal ? scope.signalRef(_.signal) : name === 'fit' ? _ : error('Unsupported parameter object: ' + stringValue(_));\n}\nvar Top = 'top';\nvar Left = 'left';\nvar Right = 'right';\nvar Bottom = 'bottom';\nvar Center = 'center';\nvar Vertical = 'vertical';\nvar Start = 'start';\nvar Middle = 'middle';\nvar End = 'end';\nvar Index = 'index';\nvar Label = 'label';\nvar Offset = 'offset';\nvar Perc = 'perc';\nvar Perc2 = 'perc2';\nvar Value = 'value';\nvar GuideLabelStyle = 'guide-label';\nvar GuideTitleStyle = 'guide-title';\nvar GroupTitleStyle = 'group-title';\nvar GroupSubtitleStyle = 'group-subtitle';\nvar Symbols = 'symbol';\nvar Gradient = 'gradient';\nvar Discrete = 'discrete';\nvar Size = 'size';\nvar Shape = 'shape';\nvar Fill = 'fill';\nvar Stroke = 'stroke';\nvar StrokeWidth = 'strokeWidth';\nvar StrokeDash = 'strokeDash';\nvar Opacity = 'opacity'; // Encoding channels supported by legends\n// In priority order of 'canonical' scale\n\nvar LegendScales = [Size, Shape, Fill, Stroke, StrokeWidth, StrokeDash, Opacity];\nvar Skip = {\n  name: 1,\n  style: 1,\n  interactive: 1\n};\nvar zero = {\n  value: 0\n};\nvar one = {\n  value: 1\n};\nvar GroupMark = 'group';\nvar RectMark = 'rect';\nvar RuleMark = 'rule';\nvar SymbolMark = 'symbol';\nvar TextMark = 'text';\nfunction guideGroup(mark) {\n  mark.type = GroupMark;\n  mark.interactive = mark.interactive || false;\n  return mark;\n}\nfunction lookup(spec, config) {\n  var _ = function _(name, dflt) {\n    return value(spec[name], value(config[name], dflt));\n  };\n  _.isVertical = function (s) {\n    return Vertical === value(spec.direction, config.direction || (s ? config.symbolDirection : config.gradientDirection));\n  };\n  _.gradientLength = function () {\n    return value(spec.gradientLength, config.gradientLength || config.gradientWidth);\n  };\n  _.gradientThickness = function () {\n    return value(spec.gradientThickness, config.gradientThickness || config.gradientHeight);\n  };\n  _.entryColumns = function () {\n    return value(spec.columns, value(config.columns, +_.isVertical(true)));\n  };\n  return _;\n}\nfunction getEncoding(name, encode) {\n  var v = encode && (encode.update && encode.update[name] || encode.enter && encode.enter[name]);\n  return v && v.signal ? v : v ? v.value : null;\n}\nfunction getStyle(name, scope, style) {\n  var s = scope.config.style[style];\n  return s && s[name];\n}\nfunction anchorExpr(s, e, m) {\n  return \"item.anchor === '\".concat(Start, \"' ? \").concat(s, \" : item.anchor === '\").concat(End, \"' ? \").concat(e, \" : \").concat(m);\n}\nvar alignExpr$1 = anchorExpr(stringValue(Left), stringValue(Right), stringValue(Center));\nfunction tickBand(_) {\n  var v = _('tickBand');\n  var offset = _('tickOffset'),\n    band,\n    extra;\n  if (!v) {\n    // if no tick band entry, fall back on other properties\n    band = _('bandPosition');\n    extra = _('tickExtra');\n  } else if (v.signal) {\n    // if signal, augment code to interpret values\n    band = {\n      signal: \"(\".concat(v.signal, \") === 'extent' ? 1 : 0.5\")\n    };\n    extra = {\n      signal: \"(\".concat(v.signal, \") === 'extent'\")\n    };\n    if (!isObject(offset)) {\n      offset = {\n        signal: \"(\".concat(v.signal, \") === 'extent' ? 0 : \").concat(offset)\n      };\n    }\n  } else if (v === 'extent') {\n    // if constant, simply set values\n    band = 1;\n    extra = true;\n    offset = 0;\n  } else {\n    band = 0.5;\n    extra = false;\n  }\n  return {\n    extra: extra,\n    band: band,\n    offset: offset\n  };\n}\nfunction extendOffset(value, offset) {\n  return !offset ? value : !value ? offset : !isObject(value) ? {\n    value: value,\n    offset: offset\n  } : Object.assign({}, value, {\n    offset: extendOffset(value.offset, offset)\n  });\n}\nfunction guideMark(mark, extras) {\n  if (extras) {\n    mark.name = extras.name;\n    mark.style = extras.style || mark.style;\n    mark.interactive = !!extras.interactive;\n    mark.encode = extendEncode(mark.encode, extras, Skip);\n  } else {\n    mark.interactive = false;\n  }\n  return mark;\n}\nfunction legendGradient(spec, scale, config, userEncode) {\n  var _ = lookup(spec, config),\n    vertical = _.isVertical(),\n    thickness = _.gradientThickness(),\n    length = _.gradientLength();\n  var enter, start, stop, width, height;\n  if (vertical) {\n    start = [0, 1];\n    stop = [0, 0];\n    width = thickness;\n    height = length;\n  } else {\n    start = [0, 0];\n    stop = [1, 0];\n    width = length;\n    height = thickness;\n  }\n  var encode = {\n    enter: enter = {\n      opacity: zero,\n      x: zero,\n      y: zero,\n      width: encoder(width),\n      height: encoder(height)\n    },\n    update: extend({}, enter, {\n      opacity: one,\n      fill: {\n        gradient: scale,\n        start: start,\n        stop: stop\n      }\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, {\n    // update\n    opacity: _('gradientOpacity')\n  });\n  return guideMark({\n    type: RectMark,\n    role: LegendGradientRole,\n    encode: encode\n  }, userEncode);\n}\nfunction legendGradientDiscrete(spec, scale, config, userEncode, dataRef) {\n  var _ = lookup(spec, config),\n    vertical = _.isVertical(),\n    thickness = _.gradientThickness(),\n    length = _.gradientLength();\n  var u,\n    v,\n    uu,\n    vv,\n    adjust = '';\n  vertical ? (u = 'y', uu = 'y2', v = 'x', vv = 'width', adjust = '1-') : (u = 'x', uu = 'x2', v = 'y', vv = 'height');\n  var enter = {\n    opacity: zero,\n    fill: {\n      scale: scale,\n      field: Value\n    }\n  };\n  enter[u] = {\n    signal: adjust + 'datum.' + Perc,\n    mult: length\n  };\n  enter[v] = zero;\n  enter[uu] = {\n    signal: adjust + 'datum.' + Perc2,\n    mult: length\n  };\n  enter[vv] = encoder(thickness);\n  var encode = {\n    enter: enter,\n    update: extend({}, enter, {\n      opacity: one\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, {\n    // update\n    opacity: _('gradientOpacity')\n  });\n  return guideMark({\n    type: RectMark,\n    role: LegendBandRole,\n    key: Value,\n    from: dataRef,\n    encode: encode\n  }, userEncode);\n}\nvar alignExpr = \"datum.\".concat(Perc, \"<=0?\\\"\").concat(Left, \"\\\":datum.\").concat(Perc, \">=1?\\\"\").concat(Right, \"\\\":\\\"\").concat(Center, \"\\\"\"),\n  baselineExpr = \"datum.\".concat(Perc, \"<=0?\\\"\").concat(Bottom, \"\\\":datum.\").concat(Perc, \">=1?\\\"\").concat(Top, \"\\\":\\\"\").concat(Middle, \"\\\"\");\nfunction legendGradientLabels(spec, config, userEncode, dataRef) {\n  var _ = lookup(spec, config),\n    vertical = _.isVertical(),\n    thickness = encoder(_.gradientThickness()),\n    length = _.gradientLength();\n  var overlap = _('labelOverlap'),\n    enter,\n    update,\n    u,\n    v,\n    adjust = '';\n  var encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontStyle: _('labelFontStyle'),\n    fontWeight: _('labelFontWeight'),\n    limit: value(spec.labelLimit, config.gradientLabelLimit)\n  });\n  if (vertical) {\n    enter.align = {\n      value: 'left'\n    };\n    enter.baseline = update.baseline = {\n      signal: baselineExpr\n    };\n    u = 'y';\n    v = 'x';\n    adjust = '1-';\n  } else {\n    enter.align = update.align = {\n      signal: alignExpr\n    };\n    enter.baseline = {\n      value: 'top'\n    };\n    u = 'x';\n    v = 'y';\n  }\n  enter[u] = update[u] = {\n    signal: adjust + 'datum.' + Perc,\n    mult: length\n  };\n  enter[v] = update[v] = thickness;\n  thickness.offset = value(spec.labelOffset, config.gradientLabelOffset) || 0;\n  overlap = overlap ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.' + Index\n  } : undefined; // type, role, style, key, dataRef, encode, extras\n\n  return guideMark({\n    type: TextMark,\n    role: LegendLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: dataRef,\n    encode: encode,\n    overlap: overlap\n  }, userEncode);\n}\nfunction legendSymbolGroups(spec, config, userEncode, dataRef, columns) {\n  var _ = lookup(spec, config),\n    entries = userEncode.entries,\n    interactive = !!(entries && entries.interactive),\n    name = entries ? entries.name : undefined,\n    height = _('clipHeight'),\n    symbolOffset = _('symbolOffset'),\n    valueRef = {\n      data: 'value'\n    },\n    xSignal = \"(\".concat(columns, \") ? datum.\").concat(Offset, \" : datum.\").concat(Size),\n    yEncode = height ? encoder(height) : {\n      field: Size\n    },\n    index = \"datum.\".concat(Index),\n    ncols = \"max(1, \".concat(columns, \")\");\n  var encode, enter, update, nrows, sort;\n  yEncode.mult = 0.5; // -- LEGEND SYMBOLS --\n\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: {\n        signal: xSignal,\n        mult: 0.5,\n        offset: symbolOffset\n      },\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  var baseFill = null,\n    baseStroke = null;\n  if (!spec.fill) {\n    baseFill = config.symbolBaseFillColor;\n    baseStroke = config.symbolBaseStrokeColor;\n  }\n  addEncoders(encode, {\n    fill: _('symbolFillColor', baseFill),\n    shape: _('symbolType'),\n    size: _('symbolSize'),\n    stroke: _('symbolStrokeColor', baseStroke),\n    strokeDash: _('symbolDash'),\n    strokeDashOffset: _('symbolDashOffset'),\n    strokeWidth: _('symbolStrokeWidth')\n  }, {\n    // update\n    opacity: _('symbolOpacity')\n  });\n  LegendScales.forEach(function (scale) {\n    if (spec[scale]) {\n      update[scale] = enter[scale] = {\n        scale: spec[scale],\n        field: Value\n      };\n    }\n  });\n  var symbols = guideMark({\n    type: SymbolMark,\n    role: LegendSymbolRole,\n    key: Value,\n    from: valueRef,\n    clip: height ? true : undefined,\n    encode: encode\n  }, userEncode.symbols); // -- LEGEND LABELS --\n\n  var labelOffset = encoder(symbolOffset);\n  labelOffset.offset = _('labelOffset');\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: {\n        signal: xSignal,\n        offset: labelOffset\n      },\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      },\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    align: _('labelAlign'),\n    baseline: _('labelBaseline'),\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontStyle: _('labelFontStyle'),\n    fontWeight: _('labelFontWeight'),\n    limit: _('labelLimit')\n  });\n  var labels = guideMark({\n    type: TextMark,\n    role: LegendLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: valueRef,\n    encode: encode\n  }, userEncode.labels); // -- LEGEND ENTRY GROUPS --\n\n  encode = {\n    enter: {\n      noBound: {\n        value: !height\n      },\n      // ignore width/height in bounds calc\n      width: zero,\n      height: height ? encoder(height) : zero,\n      opacity: zero\n    },\n    exit: {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one,\n      row: {\n        signal: null\n      },\n      column: {\n        signal: null\n      }\n    }\n  }; // annotate and sort groups to ensure correct ordering\n\n  if (_.isVertical(true)) {\n    nrows = \"ceil(item.mark.items.length / \".concat(ncols, \")\");\n    update.row.signal = \"\".concat(index, \"%\").concat(nrows);\n    update.column.signal = \"floor(\".concat(index, \" / \").concat(nrows, \")\");\n    sort = {\n      field: ['row', index]\n    };\n  } else {\n    update.row.signal = \"floor(\".concat(index, \" / \").concat(ncols, \")\");\n    update.column.signal = \"\".concat(index, \" % \").concat(ncols);\n    sort = {\n      field: index\n    };\n  } // handle zero column case (implies infinite columns)\n\n  update.column.signal = \"(\".concat(columns, \")?\").concat(update.column.signal, \":\").concat(index); // facet legend entries into sub-groups\n\n  dataRef = {\n    facet: {\n      data: dataRef,\n      name: 'value',\n      groupby: Index\n    }\n  };\n  return guideGroup({\n    role: ScopeRole,\n    from: dataRef,\n    encode: extendEncode(encode, entries, Skip),\n    marks: [symbols, labels],\n    name: name,\n    interactive: interactive,\n    sort: sort\n  });\n}\nfunction legendSymbolLayout(spec, config) {\n  var _ = lookup(spec, config); // layout parameters for legend entries\n\n  return {\n    align: _('gridAlign'),\n    columns: _.entryColumns(),\n    center: {\n      row: true,\n      column: false\n    },\n    padding: {\n      row: _('rowPadding'),\n      column: _('columnPadding')\n    }\n  };\n}\nvar isL = 'item.orient === \"left\"',\n  isR = 'item.orient === \"right\"',\n  isLR = \"(\".concat(isL, \" || \").concat(isR, \")\"),\n  isVG = \"datum.vgrad && \".concat(isLR),\n  baseline = anchorExpr('\"top\"', '\"bottom\"', '\"middle\"'),\n  alignFlip = anchorExpr('\"right\"', '\"left\"', '\"center\"'),\n  exprAlign = \"datum.vgrad && \".concat(isR, \" ? (\").concat(alignFlip, \") : (\").concat(isLR, \" && !(datum.vgrad && \").concat(isL, \")) ? \\\"left\\\" : \").concat(alignExpr$1),\n  exprAnchor = \"item._anchor || (\".concat(isLR, \" ? \\\"middle\\\" : \\\"start\\\")\"),\n  exprAngle = \"\".concat(isVG, \" ? (\").concat(isL, \" ? -90 : 90) : 0\"),\n  exprBaseline = \"\".concat(isLR, \" ? (datum.vgrad ? (\").concat(isR, \" ? \\\"bottom\\\" : \\\"top\\\") : \").concat(baseline, \") : \\\"top\\\"\");\nfunction legendTitle(spec, config, userEncode, dataRef) {\n  var _ = lookup(spec, config);\n  var encode = {\n    enter: {\n      opacity: zero\n    },\n    update: {\n      opacity: one,\n      x: {\n        field: {\n          group: 'padding'\n        }\n      },\n      y: {\n        field: {\n          group: 'padding'\n        }\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    orient: _('titleOrient'),\n    _anchor: _('titleAnchor'),\n    anchor: {\n      signal: exprAnchor\n    },\n    angle: {\n      signal: exprAngle\n    },\n    align: {\n      signal: exprAlign\n    },\n    baseline: {\n      signal: exprBaseline\n    },\n    text: spec.title,\n    fill: _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font: _('titleFont'),\n    fontSize: _('titleFontSize'),\n    fontStyle: _('titleFontStyle'),\n    fontWeight: _('titleFontWeight'),\n    limit: _('titleLimit'),\n    lineHeight: _('titleLineHeight')\n  }, {\n    // require update\n    align: _('titleAlign'),\n    baseline: _('titleBaseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: LegendTitleRole,\n    style: GuideTitleStyle,\n    from: dataRef,\n    encode: encode\n  }, userEncode);\n}\nfunction clip(clip, scope) {\n  var expr;\n  if (isObject(clip)) {\n    if (clip.signal) {\n      expr = clip.signal;\n    } else if (clip.path) {\n      expr = 'pathShape(' + param(clip.path) + ')';\n    } else if (clip.sphere) {\n      expr = 'geoShape(' + param(clip.sphere) + ', {type: \"Sphere\"})';\n    }\n  }\n  return expr ? scope.signalRef(expr) : !!clip;\n}\nfunction param(value) {\n  return isObject(value) && value.signal ? value.signal : stringValue(value);\n}\nfunction getRole(spec) {\n  var role = spec.role || '';\n  return !role.indexOf('axis') || !role.indexOf('legend') || !role.indexOf('title') ? role : spec.type === GroupMark ? ScopeRole : role || MarkRole;\n}\nfunction definition(spec) {\n  return {\n    marktype: spec.type,\n    name: spec.name || undefined,\n    role: spec.role || getRole(spec),\n    zindex: +spec.zindex || undefined,\n    aria: spec.aria,\n    description: spec.description\n  };\n}\nfunction interactive(spec, scope) {\n  return spec && spec.signal ? scope.signalRef(spec.signal) : spec === false ? false : true;\n}\n\n/**\n * Parse a data transform specification.\n */\n\nfunction parseTransform(spec, scope) {\n  var def = definition$1(spec.type);\n  if (!def) error('Unrecognized transform type: ' + stringValue(spec.type));\n  var t = entry(def.type.toLowerCase(), null, parseParameters(def, spec, scope));\n  if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t));\n  t.metadata = def.metadata || {};\n  return t;\n}\n/**\n * Parse all parameters of a data transform.\n */\n\nfunction parseParameters(def, spec, scope) {\n  var params = {},\n    n = def.params.length;\n  for (var i = 0; i < n; ++i) {\n    var pdef = def.params[i];\n    params[pdef.name] = parseParameter(pdef, spec, scope);\n  }\n  return params;\n}\n/**\n * Parse a data transform parameter.\n */\n\nfunction parseParameter(def, spec, scope) {\n  var type = def.type,\n    value = spec[def.name];\n  if (type === 'index') {\n    return parseIndexParameter(def, spec, scope);\n  } else if (value === undefined) {\n    if (def.required) {\n      error('Missing required ' + stringValue(spec.type) + ' parameter: ' + stringValue(def.name));\n    }\n    return;\n  } else if (type === 'param') {\n    return parseSubParameters(def, spec, scope);\n  } else if (type === 'projection') {\n    return scope.projectionRef(spec[def.name]);\n  }\n  return def.array && !isSignal(value) ? value.map(function (v) {\n    return parameterValue(def, v, scope);\n  }) : parameterValue(def, value, scope);\n}\n/**\n * Parse a single parameter value.\n */\n\nfunction parameterValue(def, value, scope) {\n  var type = def.type;\n  if (isSignal(value)) {\n    return isExpr(type) ? error('Expression references can not be signals.') : isField(type) ? scope.fieldRef(value) : isCompare(type) ? scope.compareRef(value) : scope.signalRef(value.signal);\n  } else {\n    var _expr = def.expr || isField(type);\n    return _expr && outerExpr(value) ? scope.exprRef(value.expr, value.as) : _expr && outerField(value) ? fieldRef$1(value.field, value.as) : isExpr(type) ? parseExpression(value, scope) : isData(type) ? ref(scope.getData(value).values) : isField(type) ? fieldRef$1(value) : isCompare(type) ? scope.compareRef(value) : value;\n  }\n}\n/**\n * Parse parameter for accessing an index of another data set.\n */\n\nfunction parseIndexParameter(def, spec, scope) {\n  if (!isString(spec.from)) {\n    error('Lookup \"from\" parameter must be a string literal.');\n  }\n  return scope.getData(spec.from).lookupRef(scope, spec.key);\n}\n/**\n * Parse a parameter that contains one or more sub-parameter objects.\n */\n\nfunction parseSubParameters(def, spec, scope) {\n  var value = spec[def.name];\n  if (def.array) {\n    if (!isArray(value)) {\n      // signals not allowed!\n      error('Expected an array of sub-parameters. Instead: ' + stringValue(value));\n    }\n    return value.map(function (v) {\n      return parseSubParameter(def, v, scope);\n    });\n  } else {\n    return parseSubParameter(def, value, scope);\n  }\n}\n/**\n * Parse a sub-parameter object.\n */\n\nfunction parseSubParameter(def, value, scope) {\n  var n = def.params.length;\n  var pdef; // loop over defs to find matching key\n\n  for (var i = 0; i < n; ++i) {\n    pdef = def.params[i];\n    for (var k in pdef.key) {\n      if (pdef.key[k] !== value[k]) {\n        pdef = null;\n        break;\n      }\n    }\n    if (pdef) break;\n  } // raise error if matching key not found\n\n  if (!pdef) error('Unsupported parameter: ' + stringValue(value)); // parse params, create Params transform, return ref\n\n  var params = extend(parseParameters(pdef, value, scope), pdef.key);\n  return ref(scope.add(Params(params)));\n} // -- Utilities -----\n\nvar outerExpr = function outerExpr(_) {\n  return _ && _.expr;\n};\nvar outerField = function outerField(_) {\n  return _ && _.field;\n};\nvar isData = function isData(_) {\n  return _ === 'data';\n};\nvar isExpr = function isExpr(_) {\n  return _ === 'expr';\n};\nvar isField = function isField(_) {\n  return _ === 'field';\n};\nvar isCompare = function isCompare(_) {\n  return _ === 'compare';\n};\nfunction parseData$1(from, group, scope) {\n  var facet, key, op, dataRef, parent; // if no source data, generate singleton datum\n\n  if (!from) {\n    dataRef = ref(scope.add(Collect(null, [{}])));\n  } // if faceted, process facet specification\n  else if (facet = from.facet) {\n    if (!group) error('Only group marks can be faceted.'); // use pre-faceted source data, if available\n\n    if (facet.field != null) {\n      dataRef = parent = getDataRef(facet, scope);\n    } else {\n      // generate facet aggregates if no direct data specification\n      if (!from.data) {\n        op = parseTransform(extend({\n          type: 'aggregate',\n          groupby: array(facet.groupby)\n        }, facet.aggregate), scope);\n        op.params.key = scope.keyRef(facet.groupby);\n        op.params.pulse = getDataRef(facet, scope);\n        dataRef = parent = ref(scope.add(op));\n      } else {\n        parent = ref(scope.getData(from.data).aggregate);\n      }\n      key = scope.keyRef(facet.groupby, true);\n    }\n  } // if not yet defined, get source data reference\n\n  if (!dataRef) {\n    dataRef = getDataRef(from, scope);\n  }\n  return {\n    key: key,\n    pulse: dataRef,\n    parent: parent\n  };\n}\nfunction getDataRef(from, scope) {\n  return from.$ref ? from : from.data && from.data.$ref ? from.data : ref(scope.getData(from.data).output);\n}\nfunction DataScope(scope, input, output, values, aggr) {\n  this.scope = scope; // parent scope object\n\n  this.input = input; // first operator in pipeline (tuple input)\n\n  this.output = output; // last operator in pipeline (tuple output)\n\n  this.values = values; // operator for accessing tuples (but not tuple flow)\n  // last aggregate in transform pipeline\n\n  this.aggregate = aggr; // lookup table of field indices\n\n  this.index = {};\n}\nDataScope.fromEntries = function (scope, entries) {\n  var n = entries.length,\n    values = entries[n - 1],\n    output = entries[n - 2];\n  var input = entries[0],\n    aggr = null,\n    i = 1;\n  if (input && input.type === 'load') {\n    input = entries[1];\n  } // add operator entries to this scope, wire up pulse chain\n\n  scope.add(entries[0]);\n  for (; i < n; ++i) {\n    entries[i].params.pulse = ref(entries[i - 1]);\n    scope.add(entries[i]);\n    if (entries[i].type === 'aggregate') aggr = entries[i];\n  }\n  return new DataScope(scope, input, output, values, aggr);\n};\nfunction fieldKey(field) {\n  return isString(field) ? field : null;\n}\nfunction addSortField(scope, p, sort) {\n  var as = aggrField(sort.op, sort.field);\n  var s;\n  if (p.ops) {\n    for (var i = 0, n = p.as.length; i < n; ++i) {\n      if (p.as[i] === as) return;\n    }\n  } else {\n    p.ops = ['count'];\n    p.fields = [null];\n    p.as = ['count'];\n  }\n  if (sort.op) {\n    p.ops.push((s = sort.op.signal) ? scope.signalRef(s) : sort.op);\n    p.fields.push(scope.fieldRef(sort.field));\n    p.as.push(as);\n  }\n}\nfunction cache(scope, ds, name, optype, field, counts, index) {\n  var cache = ds[name] || (ds[name] = {}),\n    sort = sortKey(counts);\n  var k = fieldKey(field),\n    v,\n    op;\n  if (k != null) {\n    scope = ds.scope;\n    k = k + (sort ? '|' + sort : '');\n    v = cache[k];\n  }\n  if (!v) {\n    var params = counts ? {\n      field: keyFieldRef,\n      pulse: ds.countsRef(scope, field, counts)\n    } : {\n      field: scope.fieldRef(field),\n      pulse: ref(ds.output)\n    };\n    if (sort) params.sort = scope.sortRef(counts);\n    op = scope.add(entry(optype, undefined, params));\n    if (index) ds.index[field] = op;\n    v = ref(op);\n    if (k != null) cache[k] = v;\n  }\n  return v;\n}\nDataScope.prototype = {\n  countsRef: function countsRef(scope, field, sort) {\n    var ds = this,\n      cache = ds.counts || (ds.counts = {}),\n      k = fieldKey(field);\n    var v, a, p;\n    if (k != null) {\n      scope = ds.scope;\n      v = cache[k];\n    }\n    if (!v) {\n      p = {\n        groupby: scope.fieldRef(field, 'key'),\n        pulse: ref(ds.output)\n      };\n      if (sort && sort.field) addSortField(scope, p, sort);\n      a = scope.add(Aggregate(p));\n      v = scope.add(Collect({\n        pulse: ref(a)\n      }));\n      v = {\n        agg: a,\n        ref: ref(v)\n      };\n      if (k != null) cache[k] = v;\n    } else if (sort && sort.field) {\n      addSortField(scope, v.agg.params, sort);\n    }\n    return v.ref;\n  },\n  tuplesRef: function tuplesRef() {\n    return ref(this.values);\n  },\n  extentRef: function extentRef(scope, field) {\n    return cache(scope, this, 'extent', 'extent', field, false);\n  },\n  domainRef: function domainRef(scope, field) {\n    return cache(scope, this, 'domain', 'values', field, false);\n  },\n  valuesRef: function valuesRef(scope, field, sort) {\n    return cache(scope, this, 'vals', 'values', field, sort || true);\n  },\n  lookupRef: function lookupRef(scope, field) {\n    return cache(scope, this, 'lookup', 'tupleindex', field, false);\n  },\n  indataRef: function indataRef(scope, field) {\n    return cache(scope, this, 'indata', 'tupleindex', field, true, true);\n  }\n};\nfunction parseFacet(spec, scope, group) {\n  var facet = spec.from.facet,\n    name = facet.name,\n    data = getDataRef(facet, scope);\n  var op;\n  if (!facet.name) {\n    error('Facet must have a name: ' + stringValue(facet));\n  }\n  if (!facet.data) {\n    error('Facet must reference a data set: ' + stringValue(facet));\n  }\n  if (facet.field) {\n    op = scope.add(PreFacet({\n      field: scope.fieldRef(facet.field),\n      pulse: data\n    }));\n  } else if (facet.groupby) {\n    op = scope.add(Facet({\n      key: scope.keyRef(facet.groupby),\n      group: ref(scope.proxy(group.parent)),\n      pulse: data\n    }));\n  } else {\n    error('Facet must specify groupby or field: ' + stringValue(facet));\n  } // initialize facet subscope\n\n  var subscope = scope.fork(),\n    source = subscope.add(Collect()),\n    values = subscope.add(Sieve({\n      pulse: ref(source)\n    }));\n  subscope.addData(name, new DataScope(subscope, source, source, values));\n  subscope.addSignal('parent', null); // parse faceted subflow\n\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\nfunction parseSubflow(spec, scope, input) {\n  var op = scope.add(PreFacet({\n      pulse: input.pulse\n    })),\n    subscope = scope.fork();\n  subscope.add(Sieve());\n  subscope.addSignal('parent', null); // parse group mark subflow\n\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\nfunction parseTrigger(spec, scope, name) {\n  var remove = spec.remove,\n    insert = spec.insert,\n    toggle = spec.toggle,\n    modify = spec.modify,\n    values = spec.values,\n    op = scope.add(operator());\n  var update = 'if(' + spec.trigger + ',modify(\"' + name + '\",' + [insert, remove, toggle, modify, values].map(function (_) {\n    return _ == null ? 'null' : _;\n  }).join(',') + '),0)';\n  var expr = parseExpression(update, scope);\n  op.update = expr.$expr;\n  op.params = expr.$params;\n}\nfunction parseMark(spec, scope) {\n  var role = getRole(spec),\n    group = spec.type === GroupMark,\n    facet = spec.from && spec.from.facet,\n    overlap = spec.overlap;\n  var layout = spec.layout || role === ScopeRole || role === FrameRole,\n    ops,\n    op,\n    store,\n    enc,\n    name,\n    layoutRef,\n    boundRef;\n  var nested = role === MarkRole || layout || facet; // resolve input data\n\n  var input = parseData$1(spec.from, group, scope); // data join to map tuples to visual items\n\n  op = scope.add(DataJoin({\n    key: input.key || (spec.key ? fieldRef$1(spec.key) : undefined),\n    pulse: input.pulse,\n    clean: !group\n  }));\n  var joinRef = ref(op); // collect visual items\n\n  op = store = scope.add(Collect({\n    pulse: joinRef\n  })); // connect visual items to scenegraph\n\n  op = scope.add(Mark({\n    markdef: definition(spec),\n    interactive: interactive(spec.interactive, scope),\n    clip: clip(spec.clip, scope),\n    context: {\n      $context: true\n    },\n    groups: scope.lookup(),\n    parent: scope.signals.parent ? scope.signalRef('parent') : null,\n    index: scope.markpath(),\n    pulse: ref(op)\n  }));\n  var markRef = ref(op); // add visual encoders\n\n  op = enc = scope.add(Encode(parseEncode(spec.encode, spec.type, role, spec.style, scope, {\n    mod: false,\n    pulse: markRef\n  }))); // monitor parent marks to propagate changes\n\n  op.params.parent = scope.encode(); // add post-encoding transforms, if defined\n\n  if (spec.transform) {\n    spec.transform.forEach(function (_) {\n      var tx = parseTransform(_, scope),\n        md = tx.metadata;\n      if (md.generates || md.changes) {\n        error('Mark transforms should not generate new data.');\n      }\n      if (!md.nomod) enc.params.mod = true; // update encode mod handling\n\n      tx.params.pulse = ref(op);\n      scope.add(op = tx);\n    });\n  } // if item sort specified, perform post-encoding\n\n  if (spec.sort) {\n    op = scope.add(SortItems({\n      sort: scope.compareRef(spec.sort),\n      pulse: ref(op)\n    }));\n  }\n  var encodeRef = ref(op); // add view layout operator if needed\n\n  if (facet || layout) {\n    layout = scope.add(ViewLayout({\n      layout: scope.objectProperty(spec.layout),\n      legends: scope.legends,\n      mark: markRef,\n      pulse: encodeRef\n    }));\n    layoutRef = ref(layout);\n  } // compute bounding boxes\n\n  var bound = scope.add(Bound({\n    mark: markRef,\n    pulse: layoutRef || encodeRef\n  }));\n  boundRef = ref(bound); // if group mark, recurse to parse nested content\n\n  if (group) {\n    // juggle layout & bounds to ensure they run *after* any faceting transforms\n    if (nested) {\n      ops = scope.operators;\n      ops.pop();\n      if (layout) ops.pop();\n    }\n    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);\n    facet ? parseFacet(spec, scope, input) // explicit facet\n    : nested ? parseSubflow(spec, scope, input) // standard mark group\n    : scope.parse(spec); // guide group, we can avoid nested scopes\n\n    scope.popState();\n    if (nested) {\n      if (layout) ops.push(layout);\n      ops.push(bound);\n    }\n  } // if requested, add overlap removal transform\n\n  if (overlap) {\n    boundRef = parseOverlap(overlap, boundRef, scope);\n  } // render / sieve items\n\n  var render = scope.add(Render({\n      pulse: boundRef\n    })),\n    sieve = scope.add(Sieve({\n      pulse: ref(render)\n    }, undefined, scope.parent())); // if mark is named, make accessible as reactive geometry\n  // add trigger updates if defined\n\n  if (spec.name != null) {\n    name = spec.name;\n    scope.addData(name, new DataScope(scope, store, render, sieve));\n    if (spec.on) spec.on.forEach(function (on) {\n      if (on.insert || on.remove || on.toggle) {\n        error('Marks only support modify triggers.');\n      }\n      parseTrigger(on, scope, name);\n    });\n  }\n}\nfunction parseOverlap(overlap, source, scope) {\n  var method = overlap.method,\n    bound = overlap.bound,\n    sep = overlap.separation;\n  var params = {\n    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,\n    method: isSignal(method) ? scope.signalRef(method.signal) : method,\n    pulse: source\n  };\n  if (overlap.order) {\n    params.sort = scope.compareRef({\n      field: overlap.order\n    });\n  }\n  if (bound) {\n    var tol = bound.tolerance;\n    params.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;\n    params.boundScale = scope.scaleRef(bound.scale);\n    params.boundOrient = bound.orient;\n  }\n  return ref(scope.add(Overlap(params)));\n}\nfunction parseLegend(spec, scope) {\n  var config = scope.config.legend,\n    encode = spec.encode || {},\n    _ = lookup(spec, config),\n    legendEncode = encode.legend || {},\n    name = legendEncode.name || undefined,\n    interactive = legendEncode.interactive,\n    style = legendEncode.style,\n    scales = {};\n  var scale = 0,\n    entryLayout,\n    params,\n    children; // resolve scales and 'canonical' scale name\n\n  LegendScales.forEach(function (s) {\n    return spec[s] ? (scales[s] = spec[s], scale = scale || spec[s]) : 0;\n  });\n  if (!scale) error('Missing valid scale for legend.'); // resolve legend type (symbol, gradient, or discrete gradient)\n\n  var type = legendType(spec, scope.scaleType(scale)); // single-element data source for legend group\n\n  var datum = {\n    title: spec.title != null,\n    scales: scales,\n    type: type,\n    vgrad: type !== 'symbol' && _.isVertical()\n  };\n  var dataRef = ref(scope.add(Collect(null, [datum]))); // encoding properties for legend entry sub-group\n\n  var entryEncode = {\n    enter: {\n      x: {\n        value: 0\n      },\n      y: {\n        value: 0\n      }\n    }\n  }; // data source for legend values\n\n  var entryRef = ref(scope.add(LegendEntries(params = {\n    type: type,\n    scale: scope.scaleRef(scale),\n    count: scope.objectProperty(_('tickCount')),\n    limit: scope.property(_('symbolLimit')),\n    values: scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  }))); // continuous gradient legend\n\n  if (type === Gradient) {\n    children = [legendGradient(spec, scale, config, encode.gradient), legendGradientLabels(spec, config, encode.labels, entryRef)]; // adjust default tick count based on the gradient length\n\n    params.count = params.count || scope.signalRef(\"max(2,2*floor((\".concat(deref(_.gradientLength()), \")/100))\"));\n  } // discrete gradient legend\n  else if (type === Discrete) {\n    children = [legendGradientDiscrete(spec, scale, config, encode.gradient, entryRef), legendGradientLabels(spec, config, encode.labels, entryRef)];\n  } // symbol legend\n  else {\n    // determine legend symbol group layout\n    entryLayout = legendSymbolLayout(spec, config);\n    children = [legendSymbolGroups(spec, config, encode, entryRef, deref(entryLayout.columns))]; // pass symbol size information to legend entry generator\n\n    params.size = sizeExpression(spec, scope, children[0].marks);\n  } // generate legend marks\n\n  children = [guideGroup({\n    role: LegendEntryRole,\n    from: dataRef,\n    encode: entryEncode,\n    marks: children,\n    layout: entryLayout,\n    interactive: interactive\n  })]; // include legend title if defined\n\n  if (datum.title) {\n    children.push(legendTitle(spec, config, encode.title, dataRef));\n  } // parse legend specification\n\n  return parseMark(guideGroup({\n    role: LegendRole,\n    from: dataRef,\n    encode: extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name: name,\n    interactive: interactive,\n    style: style\n  }), scope);\n}\nfunction legendType(spec, scaleType) {\n  var type = spec.type || Symbols;\n  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {\n    type = isContinuous(scaleType) ? Gradient : isDiscretizing(scaleType) ? Discrete : Symbols;\n  }\n  return type !== Gradient ? type : isDiscretizing(scaleType) ? Discrete : Gradient;\n}\nfunction scaleCount(spec) {\n  return LegendScales.reduce(function (count, type) {\n    return count + (spec[type] ? 1 : 0);\n  }, 0);\n}\nfunction buildLegendEncode(_, spec, config) {\n  var encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    offset: _('offset'),\n    padding: _('padding'),\n    titlePadding: _('titlePadding'),\n    cornerRadius: _('cornerRadius'),\n    fill: _('fillColor'),\n    stroke: _('strokeColor'),\n    strokeWidth: config.strokeWidth,\n    strokeDash: config.strokeDash,\n    x: _('legendX'),\n    y: _('legendY'),\n    // accessibility support\n    format: spec.format,\n    formatType: spec.formatType\n  });\n  return encode;\n}\nfunction sizeExpression(spec, scope, marks) {\n  var size = deref(getChannel('size', spec, marks)),\n    strokeWidth = deref(getChannel('strokeWidth', spec, marks)),\n    fontSize = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));\n  return parseExpression(\"max(ceil(sqrt(\".concat(size, \")+\").concat(strokeWidth, \"),\").concat(fontSize, \")\"), scope);\n}\nfunction getChannel(name, spec, marks) {\n  return spec[name] ? \"scale(\\\"\".concat(spec[name], \"\\\",datum)\") : getEncoding(name, marks[0].encode);\n}\nfunction getFontSize(encode, scope, style) {\n  return getEncoding('fontSize', encode) || getStyle('fontSize', scope, style);\n}\nvar angleExpr = \"item.orient===\\\"\".concat(Left, \"\\\"?-90:item.orient===\\\"\").concat(Right, \"\\\"?90:0\");\nfunction parseTitle(spec, scope) {\n  spec = isString(spec) ? {\n    text: spec\n  } : spec;\n  var _ = lookup(spec, scope.config.title),\n    encode = spec.encode || {},\n    userEncode = encode.group || {},\n    name = userEncode.name || undefined,\n    interactive = userEncode.interactive,\n    style = userEncode.style,\n    children = []; // single-element data source for group title\n\n  var datum = {},\n    dataRef = ref(scope.add(Collect(null, [datum]))); // include title text\n\n  children.push(buildTitle(spec, _, titleEncode(spec), dataRef)); // include subtitle text\n\n  if (spec.subtitle) {\n    children.push(buildSubTitle(spec, _, encode.subtitle, dataRef));\n  } // parse title specification\n\n  return parseMark(guideGroup({\n    role: TitleRole,\n    from: dataRef,\n    encode: groupEncode(_, userEncode),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name: name,\n    interactive: interactive,\n    style: style\n  }), scope);\n} // provide backwards-compatibility for title custom encode;\n// the top-level encode block has been *deprecated*.\n\nfunction titleEncode(spec) {\n  var encode = spec.encode;\n  return encode && encode.title || extend({\n    name: spec.name,\n    interactive: spec.interactive,\n    style: spec.style\n  }, encode);\n}\nfunction groupEncode(_, userEncode) {\n  var encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    anchor: _('anchor'),\n    align: {\n      signal: alignExpr$1\n    },\n    angle: {\n      signal: angleExpr\n    },\n    limit: _('limit'),\n    frame: _('frame'),\n    offset: _('offset') || 0,\n    padding: _('subtitlePadding')\n  });\n  return extendEncode(encode, userEncode, Skip);\n}\nfunction buildTitle(spec, _, userEncode, dataRef) {\n  var zero = {\n      value: 0\n    },\n    text = spec.text,\n    encode = {\n      enter: {\n        opacity: zero\n      },\n      update: {\n        opacity: {\n          value: 1\n        }\n      },\n      exit: {\n        opacity: zero\n      }\n    };\n  addEncoders(encode, {\n    text: text,\n    align: {\n      signal: 'item.mark.group.align'\n    },\n    angle: {\n      signal: 'item.mark.group.angle'\n    },\n    limit: {\n      signal: 'item.mark.group.limit'\n    },\n    baseline: 'top',\n    dx: _('dx'),\n    dy: _('dy'),\n    fill: _('color'),\n    font: _('font'),\n    fontSize: _('fontSize'),\n    fontStyle: _('fontStyle'),\n    fontWeight: _('fontWeight'),\n    lineHeight: _('lineHeight')\n  }, {\n    // update\n    align: _('align'),\n    angle: _('angle'),\n    baseline: _('baseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: TitleTextRole,\n    style: GroupTitleStyle,\n    from: dataRef,\n    encode: encode\n  }, userEncode);\n}\nfunction buildSubTitle(spec, _, userEncode, dataRef) {\n  var zero = {\n      value: 0\n    },\n    text = spec.subtitle,\n    encode = {\n      enter: {\n        opacity: zero\n      },\n      update: {\n        opacity: {\n          value: 1\n        }\n      },\n      exit: {\n        opacity: zero\n      }\n    };\n  addEncoders(encode, {\n    text: text,\n    align: {\n      signal: 'item.mark.group.align'\n    },\n    angle: {\n      signal: 'item.mark.group.angle'\n    },\n    limit: {\n      signal: 'item.mark.group.limit'\n    },\n    baseline: 'top',\n    dx: _('dx'),\n    dy: _('dy'),\n    fill: _('subtitleColor'),\n    font: _('subtitleFont'),\n    fontSize: _('subtitleFontSize'),\n    fontStyle: _('subtitleFontStyle'),\n    fontWeight: _('subtitleFontWeight'),\n    lineHeight: _('subtitleLineHeight')\n  }, {\n    // update\n    align: _('align'),\n    angle: _('angle'),\n    baseline: _('baseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: TitleSubtitleRole,\n    style: GroupSubtitleStyle,\n    from: dataRef,\n    encode: encode\n  }, userEncode);\n}\nfunction parseData(data, scope) {\n  var transforms = [];\n  if (data.transform) {\n    data.transform.forEach(function (tx) {\n      transforms.push(parseTransform(tx, scope));\n    });\n  }\n  if (data.on) {\n    data.on.forEach(function (on) {\n      parseTrigger(on, scope, data.name);\n    });\n  }\n  scope.addDataPipeline(data.name, analyze(data, scope, transforms));\n}\n/**\n * Analyze a data pipeline, add needed operators.\n */\n\nfunction analyze(data, scope, ops) {\n  var output = [];\n  var source = null,\n    modify = false,\n    generate = false,\n    upstream,\n    i,\n    n,\n    t,\n    m;\n  if (data.values) {\n    // hard-wired input data set\n    if (isSignal(data.values) || hasSignal(data.format)) {\n      // if either values is signal or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, ingest upon dataflow init\n      output.push(source = collect({\n        $ingest: data.values,\n        $format: data.format\n      }));\n    }\n  } else if (data.url) {\n    // load data from external source\n    if (hasSignal(data.url) || hasSignal(data.format)) {\n      // if either url or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, request load upon dataflow init\n      output.push(source = collect({\n        $request: data.url,\n        $format: data.format\n      }));\n    }\n  } else if (data.source) {\n    // derives from one or more other data sets\n    source = upstream = array(data.source).map(function (d) {\n      return ref(scope.getData(d).output);\n    });\n    output.push(null); // populate later\n  } // scan data transforms, add collectors as needed\n\n  for (i = 0, n = ops.length; i < n; ++i) {\n    t = ops[i];\n    m = t.metadata;\n    if (!source && !m.source) {\n      output.push(source = collect());\n    }\n    output.push(t);\n    if (m.generates) generate = true;\n    if (m.modifies && !generate) modify = true;\n    if (m.source) source = t;else if (m.changes) source = null;\n  }\n  if (upstream) {\n    n = upstream.length - 1;\n    output[0] = Relay({\n      derive: modify,\n      pulse: n ? upstream : upstream[0]\n    });\n    if (modify || n) {\n      // collect derived and multi-pulse tuples\n      output.splice(1, 0, collect());\n    }\n  }\n  if (!source) output.push(collect());\n  output.push(Sieve({}));\n  return output;\n}\nfunction collect(values) {\n  var s = Collect({}, values);\n  s.metadata = {\n    source: true\n  };\n  return s;\n}\nfunction load(scope, data) {\n  return Load({\n    url: data.url ? scope.property(data.url) : undefined,\n    async: data.async ? scope.property(data.async) : undefined,\n    values: data.values ? scope.property(data.values) : undefined,\n    format: scope.objectProperty(data.format)\n  });\n}\nvar isX = function isX(orient) {\n  return orient === Bottom || orient === Top;\n}; // get sign coefficient based on axis orient\n\nvar getSign = function getSign(orient, a, b) {\n  return isSignal(orient) ? ifLeftTopExpr(orient.signal, a, b) : orient === Left || orient === Top ? a : b;\n}; // condition on axis x-direction\n\nvar ifX = function ifX(orient, a, b) {\n  return isSignal(orient) ? ifXEnc(orient.signal, a, b) : isX(orient) ? a : b;\n}; // condition on axis y-direction\n\nvar ifY = function ifY(orient, a, b) {\n  return isSignal(orient) ? ifYEnc(orient.signal, a, b) : isX(orient) ? b : a;\n};\nvar ifTop = function ifTop(orient, a, b) {\n  return isSignal(orient) ? ifTopExpr(orient.signal, a, b) : orient === Top ? {\n    value: a\n  } : {\n    value: b\n  };\n};\nvar ifRight = function ifRight(orient, a, b) {\n  return isSignal(orient) ? ifRightExpr(orient.signal, a, b) : orient === Right ? {\n    value: a\n  } : {\n    value: b\n  };\n};\nvar ifXEnc = function ifXEnc($orient, a, b) {\n  return ifEnc(\"\".concat($orient, \" === '\").concat(Top, \"' || \").concat($orient, \" === '\").concat(Bottom, \"'\"), a, b);\n};\nvar ifYEnc = function ifYEnc($orient, a, b) {\n  return ifEnc(\"\".concat($orient, \" !== '\").concat(Top, \"' && \").concat($orient, \" !== '\").concat(Bottom, \"'\"), a, b);\n};\nvar ifLeftTopExpr = function ifLeftTopExpr($orient, a, b) {\n  return ifExpr(\"\".concat($orient, \" === '\").concat(Left, \"' || \").concat($orient, \" === '\").concat(Top, \"'\"), a, b);\n};\nvar ifTopExpr = function ifTopExpr($orient, a, b) {\n  return ifExpr(\"\".concat($orient, \" === '\").concat(Top, \"'\"), a, b);\n};\nvar ifRightExpr = function ifRightExpr($orient, a, b) {\n  return ifExpr(\"\".concat($orient, \" === '\").concat(Right, \"'\"), a, b);\n};\nvar ifEnc = function ifEnc(test, a, b) {\n  // ensure inputs are encoder objects (or null)\n  a = a != null ? encoder(a) : a;\n  b = b != null ? encoder(b) : b;\n  if (isSimple(a) && isSimple(b)) {\n    // if possible generate simple signal expression\n    a = a ? a.signal || stringValue(a.value) : null;\n    b = b ? b.signal || stringValue(b.value) : null;\n    return {\n      signal: \"\".concat(test, \" ? (\").concat(a, \") : (\").concat(b, \")\")\n    };\n  } else {\n    // otherwise generate rule set\n    return [extend({\n      test: test\n    }, a)].concat(b || []);\n  }\n};\nvar isSimple = function isSimple(enc) {\n  return enc == null || Object.keys(enc).length === 1;\n};\nvar ifExpr = function ifExpr(test, a, b) {\n  return {\n    signal: \"\".concat(test, \" ? (\").concat(toExpr(a), \") : (\").concat(toExpr(b), \")\")\n  };\n};\nvar ifOrient = function ifOrient($orient, t, b, l, r) {\n  return {\n    signal: (l != null ? \"\".concat($orient, \" === '\").concat(Left, \"' ? (\").concat(toExpr(l), \") : \") : '') + (b != null ? \"\".concat($orient, \" === '\").concat(Bottom, \"' ? (\").concat(toExpr(b), \") : \") : '') + (r != null ? \"\".concat($orient, \" === '\").concat(Right, \"' ? (\").concat(toExpr(r), \") : \") : '') + (t != null ? \"\".concat($orient, \" === '\").concat(Top, \"' ? (\").concat(toExpr(t), \") : \") : '') + '(null)'\n  };\n};\nvar toExpr = function toExpr(v) {\n  return isSignal(v) ? v.signal : v == null ? null : stringValue(v);\n};\nvar mult = function mult(sign, value) {\n  return value === 0 ? 0 : isSignal(sign) ? {\n    signal: \"(\".concat(sign.signal, \") * \").concat(value)\n  } : {\n    value: sign * value\n  };\n};\nvar patch = function patch(value, base) {\n  var s = value.signal;\n  return s && s.endsWith('(null)') ? {\n    signal: s.slice(0, -6) + base.signal\n  } : value;\n};\nfunction fallback(prop, config, axisConfig, style) {\n  var styleProp;\n  if (config && hasOwnProperty(config, prop)) {\n    return config[prop];\n  } else if (hasOwnProperty(axisConfig, prop)) {\n    return axisConfig[prop];\n  } else if (prop.startsWith('title')) {\n    switch (prop) {\n      case 'titleColor':\n        styleProp = 'fill';\n        break;\n      case 'titleFont':\n      case 'titleFontSize':\n      case 'titleFontWeight':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n    return style[GuideTitleStyle][styleProp];\n  } else if (prop.startsWith('label')) {\n    switch (prop) {\n      case 'labelColor':\n        styleProp = 'fill';\n        break;\n      case 'labelFont':\n      case 'labelFontSize':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n    return style[GuideLabelStyle][styleProp];\n  }\n  return null;\n}\nfunction keys(objects) {\n  var map = {};\n  var _iterator = _createForOfIteratorHelper(objects),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var obj = _step.value;\n      if (!obj) continue;\n      for (var key in obj) {\n        map[key] = 1;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return Object.keys(map);\n}\nfunction axisConfig(spec, scope) {\n  var config = scope.config,\n    style = config.style,\n    axis = config.axis,\n    band = scope.scaleType(spec.scale) === 'band' && config.axisBand,\n    orient = spec.orient,\n    xy,\n    or,\n    key;\n  if (isSignal(orient)) {\n    var xyKeys = keys([config.axisX, config.axisY]),\n      orientKeys = keys([config.axisTop, config.axisBottom, config.axisLeft, config.axisRight]);\n    xy = {};\n    var _iterator2 = _createForOfIteratorHelper(xyKeys),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        key = _step2.value;\n        xy[key] = ifX(orient, fallback(key, config.axisX, axis, style), fallback(key, config.axisY, axis, style));\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    or = {};\n    var _iterator3 = _createForOfIteratorHelper(orientKeys),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        key = _step3.value;\n        or[key] = ifOrient(orient.signal, fallback(key, config.axisTop, axis, style), fallback(key, config.axisBottom, axis, style), fallback(key, config.axisLeft, axis, style), fallback(key, config.axisRight, axis, style));\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  } else {\n    xy = orient === Top || orient === Bottom ? config.axisX : config.axisY;\n    or = config['axis' + orient[0].toUpperCase() + orient.slice(1)];\n  }\n  var result = xy || or || band ? extend({}, axis, xy, or, band) : axis;\n  return result;\n}\nfunction axisDomain(spec, config, userEncode, dataRef) {\n  var _ = lookup(spec, config),\n    orient = spec.orient;\n  var enter, update;\n  var encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('domainColor'),\n    strokeCap: _('domainCap'),\n    strokeDash: _('domainDash'),\n    strokeDashOffset: _('domainDashOffset'),\n    strokeWidth: _('domainWidth'),\n    strokeOpacity: _('domainOpacity')\n  });\n  var pos0 = position(spec, 0);\n  var pos1 = position(spec, 1);\n  enter.x = update.x = ifX(orient, pos0, zero);\n  enter.x2 = update.x2 = ifX(orient, pos1);\n  enter.y = update.y = ifY(orient, pos0, zero);\n  enter.y2 = update.y2 = ifY(orient, pos1);\n  return guideMark({\n    type: RuleMark,\n    role: AxisDomainRole,\n    from: dataRef,\n    encode: encode\n  }, userEncode);\n}\nfunction position(spec, pos) {\n  return {\n    scale: spec.scale,\n    range: pos\n  };\n}\nfunction axisGrid(spec, config, userEncode, dataRef, band) {\n  var _ = lookup(spec, config),\n    orient = spec.orient,\n    vscale = spec.gridScale,\n    sign = getSign(orient, 1, -1),\n    offset = offsetValue(spec.offset, sign);\n  var enter, exit, update;\n  var encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: exit = {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gridColor'),\n    strokeCap: _('gridCap'),\n    strokeDash: _('gridDash'),\n    strokeDashOffset: _('gridDashOffset'),\n    strokeOpacity: _('gridOpacity'),\n    strokeWidth: _('gridWidth')\n  });\n  var tickPos = {\n    scale: spec.scale,\n    field: Value,\n    band: band.band,\n    extra: band.extra,\n    offset: band.offset,\n    round: _('tickRound')\n  };\n  var sz = ifX(orient, {\n    signal: 'height'\n  }, {\n    signal: 'width'\n  });\n  var gridStart = vscale ? {\n    scale: vscale,\n    range: 0,\n    mult: sign,\n    offset: offset\n  } : {\n    value: 0,\n    offset: offset\n  };\n  var gridEnd = vscale ? {\n    scale: vscale,\n    range: 1,\n    mult: sign,\n    offset: offset\n  } : extend(sz, {\n    mult: sign,\n    offset: offset\n  });\n  enter.x = update.x = ifX(orient, tickPos, gridStart);\n  enter.y = update.y = ifY(orient, tickPos, gridStart);\n  enter.x2 = update.x2 = ifY(orient, gridEnd);\n  enter.y2 = update.y2 = ifX(orient, gridEnd);\n  exit.x = ifX(orient, tickPos);\n  exit.y = ifY(orient, tickPos);\n  return guideMark({\n    type: RuleMark,\n    role: AxisGridRole,\n    key: Value,\n    from: dataRef,\n    encode: encode\n  }, userEncode);\n}\nfunction offsetValue(offset, sign) {\n  if (sign === 1) ;else if (!isObject(offset)) {\n    offset = isSignal(sign) ? {\n      signal: \"(\".concat(sign.signal, \") * (\").concat(offset || 0, \")\")\n    } : sign * (offset || 0);\n  } else {\n    var _entry = offset = extend({}, offset);\n    while (_entry.mult != null) {\n      if (!isObject(_entry.mult)) {\n        _entry.mult = isSignal(sign) // no offset if sign === 1\n        ? {\n          signal: \"(\".concat(_entry.mult, \") * (\").concat(sign.signal, \")\")\n        } : _entry.mult * sign;\n        return offset;\n      } else {\n        _entry = _entry.mult = extend({}, _entry.mult);\n      }\n    }\n    _entry.mult = sign;\n  }\n  return offset;\n}\nfunction axisTicks(spec, config, userEncode, dataRef, size, band) {\n  var _ = lookup(spec, config),\n    orient = spec.orient,\n    sign = getSign(orient, -1, 1);\n  var enter, exit, update;\n  var encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: exit = {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('tickColor'),\n    strokeCap: _('tickCap'),\n    strokeDash: _('tickDash'),\n    strokeDashOffset: _('tickDashOffset'),\n    strokeOpacity: _('tickOpacity'),\n    strokeWidth: _('tickWidth')\n  });\n  var tickSize = encoder(size);\n  tickSize.mult = sign;\n  var tickPos = {\n    scale: spec.scale,\n    field: Value,\n    band: band.band,\n    extra: band.extra,\n    offset: band.offset,\n    round: _('tickRound')\n  };\n  update.y = enter.y = ifX(orient, zero, tickPos);\n  update.y2 = enter.y2 = ifX(orient, tickSize);\n  exit.x = ifX(orient, tickPos);\n  update.x = enter.x = ifY(orient, zero, tickPos);\n  update.x2 = enter.x2 = ifY(orient, tickSize);\n  exit.y = ifY(orient, tickPos);\n  return guideMark({\n    type: RuleMark,\n    role: AxisTickRole,\n    key: Value,\n    from: dataRef,\n    encode: encode\n  }, userEncode);\n}\nfunction flushExpr(scale, threshold, a, b, c) {\n  return {\n    signal: 'flush(range(\"' + scale + '\"), ' + 'scale(\"' + scale + '\", datum.value), ' + threshold + ',' + a + ',' + b + ',' + c + ')'\n  };\n}\nfunction axisLabels(spec, config, userEncode, dataRef, size, band) {\n  var _ = lookup(spec, config),\n    orient = spec.orient,\n    scale = spec.scale,\n    sign = getSign(orient, -1, 1),\n    flush = deref(_('labelFlush')),\n    flushOffset = deref(_('labelFlushOffset')),\n    labelAlign = _('labelAlign'),\n    labelBaseline = _('labelBaseline');\n  var flushOn = flush === 0 || !!flush,\n    update;\n  var tickSize = encoder(size);\n  tickSize.mult = sign;\n  tickSize.offset = encoder(_('labelPadding') || 0);\n  tickSize.offset.mult = sign;\n  var tickPos = {\n    scale: scale,\n    field: Value,\n    band: 0.5,\n    offset: extendOffset(band.offset, _('labelOffset'))\n  };\n  var align = ifX(orient, flushOn ? flushExpr(scale, flush, '\"left\"', '\"right\"', '\"center\"') : {\n    value: 'center'\n  }, ifRight(orient, 'left', 'right'));\n  var baseline = ifX(orient, ifTop(orient, 'bottom', 'top'), flushOn ? flushExpr(scale, flush, '\"top\"', '\"bottom\"', '\"middle\"') : {\n    value: 'middle'\n  });\n  var offsetExpr = flushExpr(scale, flush, \"-(\".concat(flushOffset, \")\"), flushOffset, 0);\n  flushOn = flushOn && flushOffset;\n  var enter = {\n    opacity: zero,\n    x: ifX(orient, tickPos, tickSize),\n    y: ifY(orient, tickPos, tickSize)\n  };\n  var encode = {\n    enter: enter,\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      },\n      x: enter.x,\n      y: enter.y,\n      align: align,\n      baseline: baseline\n    },\n    exit: {\n      opacity: zero,\n      x: enter.x,\n      y: enter.y\n    }\n  };\n  addEncoders(encode, {\n    dx: !labelAlign && flushOn ? ifX(orient, offsetExpr) : null,\n    dy: !labelBaseline && flushOn ? ifY(orient, offsetExpr) : null\n  });\n  addEncoders(encode, {\n    angle: _('labelAngle'),\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontWeight: _('labelFontWeight'),\n    fontStyle: _('labelFontStyle'),\n    limit: _('labelLimit'),\n    lineHeight: _('labelLineHeight')\n  }, {\n    align: labelAlign,\n    baseline: labelBaseline\n  });\n  var bound = _('labelBound');\n  var overlap = _('labelOverlap'); // if overlap method or bound defined, request label overlap removal\n\n  overlap = overlap || bound ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.index',\n    bound: bound ? {\n      scale: scale,\n      orient: orient,\n      tolerance: bound\n    } : null\n  } : undefined;\n  if (update.align !== align) {\n    update.align = patch(update.align, align);\n  }\n  if (update.baseline !== baseline) {\n    update.baseline = patch(update.baseline, baseline);\n  }\n  return guideMark({\n    type: TextMark,\n    role: AxisLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: dataRef,\n    encode: encode,\n    overlap: overlap\n  }, userEncode);\n}\nfunction axisTitle(spec, config, userEncode, dataRef) {\n  var _ = lookup(spec, config),\n    orient = spec.orient,\n    sign = getSign(orient, -1, 1);\n  var enter, update;\n  var encode = {\n    enter: enter = {\n      opacity: zero,\n      anchor: encoder(_('titleAnchor', null)),\n      align: {\n        signal: alignExpr$1\n      }\n    },\n    update: update = extend({}, enter, {\n      opacity: one,\n      text: encoder(spec.title)\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  var titlePos = {\n    signal: \"lerp(range(\\\"\".concat(spec.scale, \"\\\"), \").concat(anchorExpr(0, 1, 0.5), \")\")\n  };\n  update.x = ifX(orient, titlePos);\n  update.y = ifY(orient, titlePos);\n  enter.angle = ifX(orient, zero, mult(sign, 90));\n  enter.baseline = ifX(orient, ifTop(orient, Bottom, Top), {\n    value: Bottom\n  });\n  update.angle = enter.angle;\n  update.baseline = enter.baseline;\n  addEncoders(encode, {\n    fill: _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font: _('titleFont'),\n    fontSize: _('titleFontSize'),\n    fontStyle: _('titleFontStyle'),\n    fontWeight: _('titleFontWeight'),\n    limit: _('titleLimit'),\n    lineHeight: _('titleLineHeight')\n  }, {\n    // require update\n    align: _('titleAlign'),\n    angle: _('titleAngle'),\n    baseline: _('titleBaseline')\n  });\n  autoLayout(_, orient, encode, userEncode);\n  encode.update.align = patch(encode.update.align, enter.align);\n  encode.update.angle = patch(encode.update.angle, enter.angle);\n  encode.update.baseline = patch(encode.update.baseline, enter.baseline);\n  return guideMark({\n    type: TextMark,\n    role: AxisTitleRole,\n    style: GuideTitleStyle,\n    from: dataRef,\n    encode: encode\n  }, userEncode);\n}\nfunction autoLayout(_, orient, encode, userEncode) {\n  var auto = function auto(value, dim) {\n    return value != null ? (encode.update[dim] = patch(encoder(value), encode.update[dim]), false) : !has(dim, userEncode) ? true : false;\n  };\n  var autoY = auto(_('titleX'), 'x'),\n    autoX = auto(_('titleY'), 'y');\n  encode.enter.auto = autoX === autoY ? encoder(autoX) : ifX(orient, encoder(autoX), encoder(autoY));\n}\nfunction parseAxis(spec, scope) {\n  var config = axisConfig(spec, scope),\n    encode = spec.encode || {},\n    axisEncode = encode.axis || {},\n    name = axisEncode.name || undefined,\n    interactive = axisEncode.interactive,\n    style = axisEncode.style,\n    _ = lookup(spec, config),\n    band = tickBand(_); // single-element data source for axis group\n\n  var datum = {\n    scale: spec.scale,\n    ticks: !!_('ticks'),\n    labels: !!_('labels'),\n    grid: !!_('grid'),\n    domain: !!_('domain'),\n    title: spec.title != null\n  };\n  var dataRef = ref(scope.add(Collect({}, [datum]))); // data source for axis ticks\n\n  var ticksRef = ref(scope.add(AxisTicks({\n    scale: scope.scaleRef(spec.scale),\n    extra: scope.property(band.extra),\n    count: scope.objectProperty(spec.tickCount),\n    values: scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  }))); // generate axis marks\n\n  var children = [];\n  var size; // include axis gridlines if requested\n\n  if (datum.grid) {\n    children.push(axisGrid(spec, config, encode.grid, ticksRef, band));\n  } // include axis ticks if requested\n\n  if (datum.ticks) {\n    size = _('tickSize');\n    children.push(axisTicks(spec, config, encode.ticks, ticksRef, size, band));\n  } // include axis labels if requested\n\n  if (datum.labels) {\n    size = datum.ticks ? size : 0;\n    children.push(axisLabels(spec, config, encode.labels, ticksRef, size, band));\n  } // include axis domain path if requested\n\n  if (datum.domain) {\n    children.push(axisDomain(spec, config, encode.domain, dataRef));\n  } // include axis title if defined\n\n  if (datum.title) {\n    children.push(axisTitle(spec, config, encode.title, dataRef));\n  } // parse axis specification\n\n  return parseMark(guideGroup({\n    role: AxisRole,\n    from: dataRef,\n    encode: extendEncode(buildAxisEncode(_, spec), axisEncode, Skip),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name: name,\n    interactive: interactive,\n    style: style\n  }), scope);\n}\nfunction buildAxisEncode(_, spec) {\n  var encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    offset: _('offset') || 0,\n    position: value(spec.position, 0),\n    titlePadding: _('titlePadding'),\n    minExtent: _('minExtent'),\n    maxExtent: _('maxExtent'),\n    range: {\n      signal: \"abs(span(range(\\\"\".concat(spec.scale, \"\\\")))\")\n    },\n    translate: _('translate'),\n    // accessibility support\n    format: spec.format,\n    formatType: spec.formatType\n  });\n  return encode;\n}\nfunction parseScope(spec, scope, preprocessed) {\n  var signals = array(spec.signals),\n    scales = array(spec.scales); // parse signal definitions, if not already preprocessed\n\n  if (!preprocessed) signals.forEach(function (_) {\n    return parseSignal(_, scope);\n  }); // parse cartographic projection definitions\n\n  array(spec.projections).forEach(function (_) {\n    return parseProjection(_, scope);\n  }); // initialize scale references\n\n  scales.forEach(function (_) {\n    return initScale(_, scope);\n  }); // parse data sources\n\n  array(spec.data).forEach(function (_) {\n    return parseData(_, scope);\n  }); // parse scale definitions\n\n  scales.forEach(function (_) {\n    return parseScale(_, scope);\n  }); // parse signal updates\n\n  (preprocessed || signals).forEach(function (_) {\n    return parseSignalUpdates(_, scope);\n  }); // parse axis definitions\n\n  array(spec.axes).forEach(function (_) {\n    return parseAxis(_, scope);\n  }); // parse mark definitions\n\n  array(spec.marks).forEach(function (_) {\n    return parseMark(_, scope);\n  }); // parse legend definitions\n\n  array(spec.legends).forEach(function (_) {\n    return parseLegend(_, scope);\n  }); // parse title, if defined\n\n  if (spec.title) parseTitle(spec.title, scope); // parse collected lambda (anonymous) expressions\n\n  scope.parseLambdas();\n  return scope;\n}\nvar rootEncode = function rootEncode(spec) {\n  return extendEncode({\n    enter: {\n      x: {\n        value: 0\n      },\n      y: {\n        value: 0\n      }\n    },\n    update: {\n      width: {\n        signal: 'width'\n      },\n      height: {\n        signal: 'height'\n      }\n    }\n  }, spec);\n};\nfunction parseView(spec, scope) {\n  var config = scope.config; // add scenegraph root\n\n  var root = ref(scope.root = scope.add(operator())); // parse top-level signal definitions\n\n  var signals = collectSignals(spec, config);\n  signals.forEach(function (_) {\n    return parseSignal(_, scope);\n  }); // assign description, event, legend, and locale configuration\n\n  scope.description = spec.description || config.description;\n  scope.eventConfig = config.events;\n  scope.legends = scope.objectProperty(config.legend && config.legend.layout);\n  scope.locale = config.locale; // store root group item\n\n  var input = scope.add(Collect()); // encode root group item\n\n  var encode = scope.add(Encode(parseEncode(rootEncode(spec.encode), GroupMark, FrameRole, spec.style, scope, {\n    pulse: ref(input)\n  }))); // perform view layout\n\n  var parent = scope.add(ViewLayout({\n    layout: scope.objectProperty(spec.layout),\n    legends: scope.legends,\n    autosize: scope.signalRef('autosize'),\n    mark: root,\n    pulse: ref(encode)\n  }));\n  scope.operators.pop(); // parse remainder of specification\n\n  scope.pushState(ref(encode), ref(parent), null);\n  parseScope(spec, scope, signals);\n  scope.operators.push(parent); // bound / render / sieve root item\n\n  var op = scope.add(Bound({\n    mark: root,\n    pulse: ref(parent)\n  }));\n  op = scope.add(Render({\n    pulse: ref(op)\n  }));\n  op = scope.add(Sieve({\n    pulse: ref(op)\n  })); // track metadata for root item\n\n  scope.addData('root', new DataScope(scope, input, input, op));\n  return scope;\n}\nfunction signalObject(name, value) {\n  return value && value.signal ? {\n    name: name,\n    update: value.signal\n  } : {\n    name: name,\n    value: value\n  };\n}\n/**\n * Collect top-level signals, merging values as needed. Signals\n * defined in the config signals arrays are added only if that\n * signal is not explicitly defined in the specification.\n * Built-in signals (autosize, background, padding, width, height)\n * receive special treatment. They are initialized using the\n * top-level spec property, or, if undefined in the spec, using\n * the corresponding top-level config property. If this property\n * is a signal reference object, the signal expression maps to the\n * signal 'update' property. If the spec's top-level signal array\n * contains an entry that matches a built-in signal, that entry\n * will be merged with the built-in specification, potentially\n * overwriting existing 'value' or 'update' properties.\n */\n\nfunction collectSignals(spec, config) {\n  var _ = function _(name) {\n      return value(spec[name], config[name]);\n    },\n    signals = [signalObject('background', _('background')), signalObject('autosize', parseAutosize(_('autosize'))), signalObject('padding', parsePadding(_('padding'))), signalObject('width', _('width') || 0), signalObject('height', _('height') || 0)],\n    pre = signals.reduce(function (p, s) {\n      return p[s.name] = s, p;\n    }, {}),\n    map = {}; // add spec signal array\n\n  array(spec.signals).forEach(function (s) {\n    if (hasOwnProperty(pre, s.name)) {\n      // merge if built-in signal\n      s = extend(pre[s.name], s);\n    } else {\n      // otherwise add to signal list\n      signals.push(s);\n    }\n    map[s.name] = s;\n  }); // add config signal array\n\n  array(config.signals).forEach(function (s) {\n    if (!hasOwnProperty(map, s.name) && !hasOwnProperty(pre, s.name)) {\n      // add to signal list if not already defined\n      signals.push(s);\n    }\n  });\n  return signals;\n}\nfunction Scope(config, options) {\n  this.config = config || {};\n  this.options = options || {};\n  this.bindings = [];\n  this.field = {};\n  this.signals = {};\n  this.lambdas = {};\n  this.scales = {};\n  this.events = {};\n  this.data = {};\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this.eventConfig = null;\n  this.locale = null;\n  this._id = 0;\n  this._subid = 0;\n  this._nextsub = [0];\n  this._parent = [];\n  this._encode = [];\n  this._lookup = [];\n  this._markpath = [];\n}\nfunction Subscope(scope) {\n  this.config = scope.config;\n  this.options = scope.options;\n  this.legends = scope.legends;\n  this.field = Object.create(scope.field);\n  this.signals = Object.create(scope.signals);\n  this.lambdas = Object.create(scope.lambdas);\n  this.scales = Object.create(scope.scales);\n  this.events = Object.create(scope.events);\n  this.data = Object.create(scope.data);\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this._id = 0;\n  this._subid = ++scope._nextsub[0];\n  this._nextsub = scope._nextsub;\n  this._parent = scope._parent.slice();\n  this._encode = scope._encode.slice();\n  this._lookup = scope._lookup.slice();\n  this._markpath = scope._markpath;\n}\nScope.prototype = Subscope.prototype = {\n  parse: function parse(spec) {\n    return parseScope(spec, this);\n  },\n  fork: function fork() {\n    return new Subscope(this);\n  },\n  isSubscope: function isSubscope() {\n    return this._subid > 0;\n  },\n  toRuntime: function toRuntime() {\n    this.finish();\n    return {\n      description: this.description,\n      operators: this.operators,\n      streams: this.streams,\n      updates: this.updates,\n      bindings: this.bindings,\n      eventConfig: this.eventConfig,\n      locale: this.locale\n    };\n  },\n  id: function id() {\n    return (this._subid ? this._subid + ':' : 0) + this._id++;\n  },\n  add: function add(op) {\n    this.operators.push(op);\n    op.id = this.id(); // if pre-registration references exist, resolve them now\n\n    if (op.refs) {\n      op.refs.forEach(function (ref) {\n        ref.$ref = op.id;\n      });\n      op.refs = null;\n    }\n    return op;\n  },\n  proxy: function proxy(op) {\n    var vref = op instanceof Entry ? ref(op) : op;\n    return this.add(Proxy({\n      value: vref\n    }));\n  },\n  addStream: function addStream(stream) {\n    this.streams.push(stream);\n    stream.id = this.id();\n    return stream;\n  },\n  addUpdate: function addUpdate(update) {\n    this.updates.push(update);\n    return update;\n  },\n  // Apply metadata\n  finish: function finish() {\n    var name, ds; // annotate root\n\n    if (this.root) this.root.root = true; // annotate signals\n\n    for (name in this.signals) {\n      this.signals[name].signal = name;\n    } // annotate scales\n\n    for (name in this.scales) {\n      this.scales[name].scale = name;\n    } // annotate data sets\n\n    function annotate(op, name, type) {\n      var data, list;\n      if (op) {\n        data = op.data || (op.data = {});\n        list = data[name] || (data[name] = []);\n        list.push(type);\n      }\n    }\n    for (name in this.data) {\n      ds = this.data[name];\n      annotate(ds.input, name, 'input');\n      annotate(ds.output, name, 'output');\n      annotate(ds.values, name, 'values');\n      for (var _field in ds.index) {\n        annotate(ds.index[_field], name, 'index:' + _field);\n      }\n    }\n    return this;\n  },\n  // ----\n  pushState: function pushState(encode, parent, lookup) {\n    this._encode.push(ref(this.add(Sieve({\n      pulse: encode\n    }))));\n    this._parent.push(parent);\n    this._lookup.push(lookup ? ref(this.proxy(lookup)) : null);\n    this._markpath.push(-1);\n  },\n  popState: function popState() {\n    this._encode.pop();\n    this._parent.pop();\n    this._lookup.pop();\n    this._markpath.pop();\n  },\n  parent: function parent() {\n    return peek(this._parent);\n  },\n  encode: function encode() {\n    return peek(this._encode);\n  },\n  lookup: function lookup() {\n    return peek(this._lookup);\n  },\n  markpath: function markpath() {\n    var p = this._markpath;\n    return ++p[p.length - 1];\n  },\n  // ----\n  fieldRef: function fieldRef(field, name) {\n    if (isString(field)) return fieldRef$1(field, name);\n    if (!field.signal) {\n      error('Unsupported field reference: ' + stringValue(field));\n    }\n    var s = field.signal;\n    var f = this.field[s];\n    if (!f) {\n      var params = {\n        name: this.signalRef(s)\n      };\n      if (name) params.as = name;\n      this.field[s] = f = ref(this.add(Field(params)));\n    }\n    return f;\n  },\n  compareRef: function compareRef(cmp) {\n    var _this = this;\n    var signal = false;\n    var check = function check(_) {\n      return isSignal(_) ? (signal = true, _this.signalRef(_.signal)) : isExpr$1(_) ? (signal = true, _this.exprRef(_.expr)) : _;\n    };\n    var fields = array(cmp.field).map(check),\n      orders = array(cmp.order).map(check);\n    return signal ? ref(this.add(Compare({\n      fields: fields,\n      orders: orders\n    }))) : _compareRef(fields, orders);\n  },\n  keyRef: function keyRef(fields, flat) {\n    var signal = false;\n    var check = function check(_) {\n      return isSignal(_) ? (signal = true, ref(sig[_.signal])) : _;\n    };\n    var sig = this.signals;\n    fields = array(fields).map(check);\n    return signal ? ref(this.add(Key({\n      fields: fields,\n      flat: flat\n    }))) : _keyRef(fields, flat);\n  },\n  sortRef: function sortRef(sort) {\n    if (!sort) return sort; // including id ensures stable sorting\n\n    var a = aggrField(sort.op, sort.field),\n      o = sort.order || Ascending;\n    return o.signal ? ref(this.add(Compare({\n      fields: a,\n      orders: this.signalRef(o.signal)\n    }))) : _compareRef(a, o);\n  },\n  // ----\n  event: function event(source, type) {\n    var key = source + ':' + type;\n    if (!this.events[key]) {\n      var id = this.id();\n      this.streams.push({\n        id: id,\n        source: source,\n        type: type\n      });\n      this.events[key] = id;\n    }\n    return this.events[key];\n  },\n  // ----\n  hasOwnSignal: function hasOwnSignal(name) {\n    return hasOwnProperty(this.signals, name);\n  },\n  addSignal: function addSignal(name, value) {\n    if (this.hasOwnSignal(name)) {\n      error('Duplicate signal name: ' + stringValue(name));\n    }\n    var op = value instanceof Entry ? value : this.add(operator(value));\n    return this.signals[name] = op;\n  },\n  getSignal: function getSignal(name) {\n    if (!this.signals[name]) {\n      error('Unrecognized signal name: ' + stringValue(name));\n    }\n    return this.signals[name];\n  },\n  signalRef: function signalRef(s) {\n    if (this.signals[s]) {\n      return ref(this.signals[s]);\n    } else if (!hasOwnProperty(this.lambdas, s)) {\n      this.lambdas[s] = this.add(operator(null));\n    }\n    return ref(this.lambdas[s]);\n  },\n  parseLambdas: function parseLambdas() {\n    var code = Object.keys(this.lambdas);\n    for (var i = 0, n = code.length; i < n; ++i) {\n      var s = code[i],\n        e = parseExpression(s, this),\n        op = this.lambdas[s];\n      op.params = e.$params;\n      op.update = e.$expr;\n    }\n  },\n  property: function property(spec) {\n    return spec && spec.signal ? this.signalRef(spec.signal) : spec;\n  },\n  objectProperty: function objectProperty(spec) {\n    return !spec || !isObject(spec) ? spec : this.signalRef(spec.signal || propertyLambda(spec));\n  },\n  exprRef: function exprRef(code, name) {\n    var params = {\n      expr: parseExpression(code, this)\n    };\n    if (name) params.expr.$name = name;\n    return ref(this.add(Expression(params)));\n  },\n  addBinding: function addBinding(name, bind) {\n    if (!this.bindings) {\n      error('Nested signals do not support binding: ' + stringValue(name));\n    }\n    this.bindings.push(extend({\n      signal: name\n    }, bind));\n  },\n  // ----\n  addScaleProj: function addScaleProj(name, transform) {\n    if (hasOwnProperty(this.scales, name)) {\n      error('Duplicate scale or projection name: ' + stringValue(name));\n    }\n    this.scales[name] = this.add(transform);\n  },\n  addScale: function addScale(name, params) {\n    this.addScaleProj(name, Scale(params));\n  },\n  addProjection: function addProjection(name, params) {\n    this.addScaleProj(name, Projection(params));\n  },\n  getScale: function getScale(name) {\n    if (!this.scales[name]) {\n      error('Unrecognized scale name: ' + stringValue(name));\n    }\n    return this.scales[name];\n  },\n  scaleRef: function scaleRef(name) {\n    return ref(this.getScale(name));\n  },\n  scaleType: function scaleType(name) {\n    return this.getScale(name).params.type;\n  },\n  projectionRef: function projectionRef(name) {\n    return this.scaleRef(name);\n  },\n  projectionType: function projectionType(name) {\n    return this.scaleType(name);\n  },\n  // ----\n  addData: function addData(name, dataScope) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n    return this.data[name] = dataScope;\n  },\n  getData: function getData(name) {\n    if (!this.data[name]) {\n      error('Undefined data set name: ' + stringValue(name));\n    }\n    return this.data[name];\n  },\n  addDataPipeline: function addDataPipeline(name, entries) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n    return this.addData(name, DataScope.fromEntries(this, entries));\n  }\n};\nfunction propertyLambda(spec) {\n  return (isArray(spec) ? arrayLambda : objectLambda)(spec);\n}\nfunction arrayLambda(array) {\n  var n = array.length;\n  var code = '[';\n  for (var i = 0; i < n; ++i) {\n    var _value = array[i];\n    code += (i > 0 ? ',' : '') + (isObject(_value) ? _value.signal || propertyLambda(_value) : stringValue(_value));\n  }\n  return code + ']';\n}\nfunction objectLambda(obj) {\n  var code = '{',\n    i = 0,\n    key,\n    value;\n  for (key in obj) {\n    value = obj[key];\n    code += (++i > 1 ? ',' : '') + stringValue(key) + ':' + (isObject(value) ? value.signal || propertyLambda(value) : stringValue(value));\n  }\n  return code + '}';\n}\n\n/**\n * Standard configuration defaults for Vega specification parsing.\n * Users can provide their own (sub-)set of these default values\n * by passing in a config object to the top-level parse method.\n */\nfunction defaults() {\n  var defaultFont = 'sans-serif',\n    defaultSymbolSize = 30,\n    defaultStrokeWidth = 2,\n    defaultColor = '#4c78a8',\n    black = '#000',\n    gray = '#888',\n    lightGray = '#ddd';\n  return {\n    // default visualization description\n    description: 'Vega visualization',\n    // default padding around visualization\n    padding: 0,\n    // default for automatic sizing; options: 'none', 'pad', 'fit'\n    // or provide an object (e.g., {'type': 'pad', 'resize': true})\n    autosize: 'pad',\n    // default view background color\n    // covers the entire view component\n    background: null,\n    // default event handling configuration\n    // preventDefault for view-sourced event types except 'wheel'\n    events: {\n      defaults: {\n        allow: ['wheel']\n      }\n    },\n    // defaults for top-level group marks\n    // accepts mark properties (fill, stroke, etc)\n    // covers the data rectangle within group width/height\n    group: null,\n    // defaults for basic mark types\n    // each subset accepts mark properties (fill, stroke, etc)\n    mark: null,\n    arc: {\n      fill: defaultColor\n    },\n    area: {\n      fill: defaultColor\n    },\n    image: null,\n    line: {\n      stroke: defaultColor,\n      strokeWidth: defaultStrokeWidth\n    },\n    path: {\n      stroke: defaultColor\n    },\n    rect: {\n      fill: defaultColor\n    },\n    rule: {\n      stroke: black\n    },\n    shape: {\n      stroke: defaultColor\n    },\n    symbol: {\n      fill: defaultColor,\n      size: 64\n    },\n    text: {\n      fill: black,\n      font: defaultFont,\n      fontSize: 11\n    },\n    trail: {\n      fill: defaultColor,\n      size: defaultStrokeWidth\n    },\n    // style definitions\n    style: {\n      // axis & legend labels\n      'guide-label': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 10\n      },\n      // axis & legend titles\n      'guide-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 11,\n        fontWeight: 'bold'\n      },\n      // headers, including chart title\n      'group-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 13,\n        fontWeight: 'bold'\n      },\n      // chart subtitle\n      'group-subtitle': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 12\n      },\n      // defaults for styled point marks in Vega-Lite\n      point: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'circle'\n      },\n      circle: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth\n      },\n      square: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'square'\n      },\n      // defaults for styled group marks in Vega-Lite\n      cell: {\n        fill: 'transparent',\n        stroke: lightGray\n      }\n    },\n    // defaults for title\n    title: {\n      orient: 'top',\n      anchor: 'middle',\n      offset: 4,\n      subtitlePadding: 3\n    },\n    // defaults for axes\n    axis: {\n      minExtent: 0,\n      maxExtent: 200,\n      bandPosition: 0.5,\n      domain: true,\n      domainWidth: 1,\n      domainColor: gray,\n      grid: false,\n      gridWidth: 1,\n      gridColor: lightGray,\n      labels: true,\n      labelAngle: 0,\n      labelLimit: 180,\n      labelOffset: 0,\n      labelPadding: 2,\n      ticks: true,\n      tickColor: gray,\n      tickOffset: 0,\n      tickRound: true,\n      tickSize: 5,\n      tickWidth: 1,\n      titlePadding: 4\n    },\n    // correction for centering bias\n    axisBand: {\n      tickOffset: -0.5\n    },\n    // defaults for cartographic projection\n    projection: {\n      type: 'mercator'\n    },\n    // defaults for legends\n    legend: {\n      orient: 'right',\n      padding: 0,\n      gridAlign: 'each',\n      columnPadding: 10,\n      rowPadding: 2,\n      symbolDirection: 'vertical',\n      gradientDirection: 'vertical',\n      gradientLength: 200,\n      gradientThickness: 16,\n      gradientStrokeColor: lightGray,\n      gradientStrokeWidth: 0,\n      gradientLabelOffset: 2,\n      labelAlign: 'left',\n      labelBaseline: 'middle',\n      labelLimit: 160,\n      labelOffset: 4,\n      labelOverlap: true,\n      symbolLimit: 30,\n      symbolType: 'circle',\n      symbolSize: 100,\n      symbolOffset: 0,\n      symbolStrokeWidth: 1.5,\n      symbolBaseFillColor: 'transparent',\n      symbolBaseStrokeColor: gray,\n      titleLimit: 180,\n      titleOrient: 'top',\n      titlePadding: 5,\n      layout: {\n        offset: 18,\n        direction: 'horizontal',\n        left: {\n          direction: 'vertical'\n        },\n        right: {\n          direction: 'vertical'\n        }\n      }\n    },\n    // defaults for scale ranges\n    range: {\n      category: {\n        scheme: 'tableau10'\n      },\n      ordinal: {\n        scheme: 'blues'\n      },\n      heatmap: {\n        scheme: 'yellowgreenblue'\n      },\n      ramp: {\n        scheme: 'blues'\n      },\n      diverging: {\n        scheme: 'blueorange',\n        extent: [1, 0]\n      },\n      symbol: ['circle', 'square', 'triangle-up', 'cross', 'diamond', 'triangle-right', 'triangle-down', 'triangle-left']\n    }\n  };\n}\nfunction parse(spec, config, options) {\n  if (!isObject(spec)) {\n    error('Input Vega specification must be an object.');\n  }\n  config = mergeConfig(defaults(), config, spec.config);\n  return parseView(spec, new Scope(config, options)).toRuntime();\n}\nexport { AxisDomainRole, AxisGridRole, AxisLabelRole, AxisRole, AxisTickRole, AxisTitleRole, DataScope, FrameRole, LegendEntryRole, LegendLabelRole, LegendRole, LegendSymbolRole, LegendTitleRole, MarkRole, Scope, ScopeRole, defaults as config, parse, parseSignal as signal, parseSignalUpdates as signalUpdates, parseStream as stream };","map":{"version":3,"names":["isObject","isArray","extend","hasOwnProperty","array","stringValue","peek","isString","error","splitAccessPath","mergeConfig","parseExpression","parseSelector","isValidScaleType","isDiscrete","isQuantile","isDiscretizing","isContinuous","definition","definition$1","parseAutosize","spec","type","number","_","paddingObject","top","bottom","left","right","parsePadding","signal","encoder","value","addEncode","object","name","set","isEncoder","length","update","addEncoders","enter","extendEncode","encode","extra","skip","has","key","MarkRole","FrameRole","ScopeRole","AxisRole","AxisDomainRole","AxisGridRole","AxisLabelRole","AxisTickRole","AxisTitleRole","LegendRole","LegendBandRole","LegendEntryRole","LegendGradientRole","LegendLabelRole","LegendSymbolRole","LegendTitleRole","TitleRole","TitleTextRole","TitleSubtitleRole","applyDefaults","role","style","config","defaults","props","applyDefault","String","startsWith","group","mark","forEach","scaleRef","scale","field","entry$1","enc","gradient","color","undefined","exponent","property","mult","offset","round","_color","x","y","z","map","join","c","h","l","s","a","b","r","g","args","start","stop","count","pop","unshift","ref","resolveField","datum","level","parent","Math","max","range","band","rule","code","test","parseEncode","scope","params","encoders","$encode","parseBlock","block","marktype","channels","fields","parse$1","expr","$expr","$fields","Object","keys","$output","$params","OUTER","OUTER_INVALID","outerError","prefix","parseSignal","push","signals","prop","op","addSignal","react","bind","addBinding","Entry","id","entry","operator","$ref","refs","fieldRef$1","$field","$name","keyFieldRef","compareRef","orders","$compare","$order","keyRef","flat","$key","$flat","Ascending","Descending","sortKey","sort","order","aggrField","Scope$1","View","isSignal","isExpr$1","hasSignal","specValue","defaultValue","deref","v","Timer","parseStream","stream","method","merge","mergeStream","nestedStream","eventStream","eventSource","source","list","streamParameters","addStream","event","throttle","between","filter","param","concat","markname","markrole","filterMark","debounce","consume","item","OP_VALUE_EXPR","ast","parseUpdate","target","events","sources","isSubscope","mergeSources","$value","signalRef","force","options","addUpdate","streamSource","parseSignalUpdates","getSignal","init","initonly","on","transform","Aggregate","AxisTicks","Bound","Collect","Compare","DataJoin","Encode","Expression","Facet","Field","Key","LegendEntries","Load","Mark","MultiExtent","MultiValues","Overlap","Params","PreFacet","Projection","Proxy","Relay","Render","Scale","Sieve","SortItems","ViewLayout","Values","FIELD_REF_ID","MULTIDOMAIN_SORT_OPS","min","initScale","addScale","domain","parseScale","getScale","parseScaleDomain","parseScaleRange","interpolate","parseScaleInterpolate","nice","parseScaleNice","bins","parseScaleBins","parseLiteral","parseArray","dataLookupError","domainMin","domainMax","explicitDomain","multipleDomain","singularDomain","data","getData","valuesRef","parseSort","domainRef","extentRef","reduce","dom","d","fieldRef","ordinalMultipleDomain","quantileMultipleDomain","numericMultipleDomain","coll","$ingest","input","addDataPipeline","counts","f","countsRef","p","groupby","pulse","ops","as","add","sortRef","multidomain","values","extents","objectProperty","interval","step","gamma","interpolateGamma","scheme","extent","schemeExtent","schemeCount","rangeStep","parseProjection","proj","projection","parseParameter$1","addProjection","Top","Left","Right","Bottom","Center","Vertical","Start","Middle","End","Index","Label","Offset","Perc","Perc2","Value","GuideLabelStyle","GuideTitleStyle","GroupTitleStyle","GroupSubtitleStyle","Symbols","Gradient","Discrete","Size","Shape","Fill","Stroke","StrokeWidth","StrokeDash","Opacity","LegendScales","Skip","interactive","zero","one","GroupMark","RectMark","RuleMark","SymbolMark","TextMark","guideGroup","lookup","dflt","isVertical","direction","symbolDirection","gradientDirection","gradientLength","gradientWidth","gradientThickness","gradientHeight","entryColumns","columns","getEncoding","getStyle","anchorExpr","e","m","alignExpr$1","tickBand","extendOffset","assign","guideMark","extras","legendGradient","userEncode","vertical","thickness","width","height","opacity","fill","exit","stroke","strokeWidth","legendGradientDiscrete","dataRef","u","uu","vv","adjust","from","alignExpr","baselineExpr","legendGradientLabels","overlap","text","fillOpacity","font","fontSize","fontStyle","fontWeight","limit","labelLimit","gradientLabelLimit","align","baseline","labelOffset","gradientLabelOffset","separation","legendSymbolGroups","entries","symbolOffset","valueRef","xSignal","yEncode","index","ncols","nrows","baseFill","baseStroke","symbolBaseFillColor","symbolBaseStrokeColor","shape","size","strokeDash","strokeDashOffset","symbols","clip","labels","noBound","row","column","facet","marks","legendSymbolLayout","center","padding","isL","isR","isLR","isVG","alignFlip","exprAlign","exprAnchor","exprAngle","exprBaseline","legendTitle","orient","_anchor","anchor","angle","title","lineHeight","path","sphere","getRole","indexOf","zindex","aria","description","parseTransform","def","t","toLowerCase","parseParameters","proxy","metadata","n","i","pdef","parseParameter","parseIndexParameter","required","parseSubParameters","projectionRef","parameterValue","isExpr","isField","isCompare","outerExpr","exprRef","outerField","isData","lookupRef","parseSubParameter","k","parseData$1","getDataRef","aggregate","output","DataScope","aggr","fromEntries","fieldKey","addSortField","cache","ds","optype","prototype","agg","tuplesRef","indataRef","parseFacet","subscope","fork","addData","subflow","$subflow","parse","toRuntime","parseSubflow","parseTrigger","remove","insert","toggle","modify","trigger","parseMark","layout","store","layoutRef","boundRef","nested","clean","joinRef","markdef","context","$context","groups","markpath","markRef","mod","tx","md","generates","changes","nomod","encodeRef","legends","bound","operators","pushState","popState","parseOverlap","render","sieve","sep","tol","tolerance","boundTolerance","boundScale","boundOrient","parseLegend","legend","legendEncode","scales","entryLayout","children","legendType","scaleType","vgrad","entryEncode","entryRef","minstep","tickMinStep","formatType","formatSpecifier","format","sizeExpression","buildLegendEncode","scaleCount","titlePadding","cornerRadius","getChannel","getFontSize","angleExpr","parseTitle","buildTitle","titleEncode","subtitle","buildSubTitle","groupEncode","frame","dx","dy","parseData","transforms","analyze","generate","upstream","load","collect","$format","url","$request","modifies","derive","splice","async","isX","getSign","ifLeftTopExpr","ifX","ifXEnc","ifY","ifYEnc","ifTop","ifTopExpr","ifRight","ifRightExpr","$orient","ifEnc","ifExpr","isSimple","toExpr","ifOrient","sign","patch","base","endsWith","slice","fallback","axisConfig","styleProp","objects","obj","axis","axisBand","xy","or","xyKeys","axisX","axisY","orientKeys","axisTop","axisBottom","axisLeft","axisRight","toUpperCase","result","axisDomain","strokeCap","strokeOpacity","pos0","position","pos1","x2","y2","pos","axisGrid","vscale","gridScale","offsetValue","tickPos","sz","gridStart","gridEnd","axisTicks","tickSize","flushExpr","threshold","axisLabels","flush","flushOffset","labelAlign","labelBaseline","flushOn","offsetExpr","axisTitle","titlePos","autoLayout","auto","dim","autoY","autoX","parseAxis","axisEncode","ticks","grid","ticksRef","tickCount","buildAxisEncode","minExtent","maxExtent","translate","parseScope","preprocessed","projections","axes","parseLambdas","rootEncode","parseView","root","collectSignals","eventConfig","locale","autosize","signalObject","pre","Scope","bindings","lambdas","streams","updates","_id","_subid","_nextsub","_parent","_encode","_lookup","_markpath","Subscope","create","finish","vref","annotate","cmp","check","sig","o","hasOwnSignal","propertyLambda","addScaleProj","projectionType","dataScope","arrayLambda","objectLambda","defaultFont","defaultSymbolSize","defaultStrokeWidth","defaultColor","black","gray","lightGray","background","allow","arc","area","image","line","rect","symbol","trail","point","circle","square","cell","subtitlePadding","bandPosition","domainWidth","domainColor","gridWidth","gridColor","labelAngle","labelPadding","tickColor","tickOffset","tickRound","tickWidth","gridAlign","columnPadding","rowPadding","gradientStrokeColor","gradientStrokeWidth","labelOverlap","symbolLimit","symbolType","symbolSize","symbolStrokeWidth","titleLimit","titleOrient","category","ordinal","heatmap","ramp","diverging","signalUpdates"],"sources":["/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/vega-parser/build/vega-parser.module.js"],"sourcesContent":["import { isObject, isArray, extend, hasOwnProperty, array, stringValue, peek, isString, error, splitAccessPath, mergeConfig } from 'vega-util';\nimport { parseExpression } from 'vega-functions';\nimport { parseSelector } from 'vega-event-selector';\nimport { isValidScaleType, isDiscrete, isQuantile, isDiscretizing, isContinuous } from 'vega-scale';\nimport { definition as definition$1 } from 'vega-dataflow';\n\nfunction parseAutosize (spec) {\n  return isObject(spec) ? spec : {\n    type: spec || 'pad'\n  };\n}\n\nconst number = _ => +_ || 0;\n\nconst paddingObject = _ => ({\n  top: _,\n  bottom: _,\n  left: _,\n  right: _\n});\n\nfunction parsePadding (spec) {\n  return !isObject(spec) ? paddingObject(number(spec)) : spec.signal ? spec : {\n    top: number(spec.top),\n    bottom: number(spec.bottom),\n    left: number(spec.left),\n    right: number(spec.right)\n  };\n}\n\nconst encoder = _ => isObject(_) && !isArray(_) ? extend({}, _) : {\n  value: _\n};\nfunction addEncode(object, name, value, set) {\n  if (value != null) {\n    const isEncoder = isObject(value) && !isArray(value) || isArray(value) && value.length && isObject(value[0]); // Always assign signal to update, even if the signal is from the enter block\n\n    if (isEncoder) {\n      object.update[name] = value;\n    } else {\n      object[set || 'enter'][name] = {\n        value: value\n      };\n    }\n\n    return 1;\n  } else {\n    return 0;\n  }\n}\nfunction addEncoders(object, enter, update) {\n  for (const name in enter) {\n    addEncode(object, name, enter[name]);\n  }\n\n  for (const name in update) {\n    addEncode(object, name, update[name], 'update');\n  }\n}\nfunction extendEncode(encode, extra, skip) {\n  for (const name in extra) {\n    if (skip && hasOwnProperty(skip, name)) continue;\n    encode[name] = extend(encode[name] || {}, extra[name]);\n  }\n\n  return encode;\n}\nfunction has(key, encode) {\n  return encode && (encode.enter && encode.enter[key] || encode.update && encode.update[key]);\n}\n\nconst MarkRole = 'mark';\nconst FrameRole = 'frame';\nconst ScopeRole = 'scope';\nconst AxisRole = 'axis';\nconst AxisDomainRole = 'axis-domain';\nconst AxisGridRole = 'axis-grid';\nconst AxisLabelRole = 'axis-label';\nconst AxisTickRole = 'axis-tick';\nconst AxisTitleRole = 'axis-title';\nconst LegendRole = 'legend';\nconst LegendBandRole = 'legend-band';\nconst LegendEntryRole = 'legend-entry';\nconst LegendGradientRole = 'legend-gradient';\nconst LegendLabelRole = 'legend-label';\nconst LegendSymbolRole = 'legend-symbol';\nconst LegendTitleRole = 'legend-title';\nconst TitleRole = 'title';\nconst TitleTextRole = 'title-text';\nconst TitleSubtitleRole = 'title-subtitle';\n\nfunction applyDefaults (encode, type, role, style, config) {\n  const defaults = {},\n        enter = {};\n  let update, key, skip, props; // if text mark, apply global lineBreak settings (#2370)\n\n  key = 'lineBreak';\n\n  if (type === 'text' && config[key] != null && !has(key, encode)) {\n    applyDefault(defaults, key, config[key]);\n  } // ignore legend and axis roles\n\n\n  if (role == 'legend' || String(role).startsWith('axis')) {\n    role = null;\n  } // resolve mark config\n\n\n  props = role === FrameRole ? config.group : role === MarkRole ? extend({}, config.mark, config[type]) : null;\n\n  for (key in props) {\n    // do not apply defaults if relevant fields are defined\n    skip = has(key, encode) || (key === 'fill' || key === 'stroke') && (has('fill', encode) || has('stroke', encode));\n    if (!skip) applyDefault(defaults, key, props[key]);\n  } // resolve styles, apply with increasing precedence\n\n\n  array(style).forEach(name => {\n    const props = config.style && config.style[name];\n\n    for (const key in props) {\n      if (!has(key, encode)) {\n        applyDefault(defaults, key, props[key]);\n      }\n    }\n  });\n  encode = extend({}, encode); // defensive copy\n\n  for (key in defaults) {\n    props = defaults[key];\n\n    if (props.signal) {\n      (update = update || {})[key] = props;\n    } else {\n      enter[key] = props;\n    }\n  }\n\n  encode.enter = extend(enter, encode.enter);\n  if (update) encode.update = extend(update, encode.update);\n  return encode;\n}\n\nfunction applyDefault(defaults, key, value) {\n  defaults[key] = value && value.signal ? {\n    signal: value.signal\n  } : {\n    value: value\n  };\n}\n\nconst scaleRef = scale => isString(scale) ? stringValue(scale) : scale.signal ? `(${scale.signal})` : field(scale);\n\nfunction entry$1(enc) {\n  if (enc.gradient != null) {\n    return gradient(enc);\n  }\n\n  let value = enc.signal ? `(${enc.signal})` : enc.color ? color(enc.color) : enc.field != null ? field(enc.field) : enc.value !== undefined ? stringValue(enc.value) : undefined;\n\n  if (enc.scale != null) {\n    value = scale(enc, value);\n  }\n\n  if (value === undefined) {\n    value = null;\n  }\n\n  if (enc.exponent != null) {\n    value = `pow(${value},${property(enc.exponent)})`;\n  }\n\n  if (enc.mult != null) {\n    value += `*${property(enc.mult)}`;\n  }\n\n  if (enc.offset != null) {\n    value += `+${property(enc.offset)}`;\n  }\n\n  if (enc.round) {\n    value = `round(${value})`;\n  }\n\n  return value;\n}\n\nconst _color = (type, x, y, z) => `(${type}(${[x, y, z].map(entry$1).join(',')})+'')`;\n\nfunction color(enc) {\n  return enc.c ? _color('hcl', enc.h, enc.c, enc.l) : enc.h || enc.s ? _color('hsl', enc.h, enc.s, enc.l) : enc.l || enc.a ? _color('lab', enc.l, enc.a, enc.b) : enc.r || enc.g || enc.b ? _color('rgb', enc.r, enc.g, enc.b) : null;\n}\n\nfunction gradient(enc) {\n  // map undefined to null; expression lang does not allow undefined\n  const args = [enc.start, enc.stop, enc.count].map(_ => _ == null ? null : stringValue(_)); // trim null inputs from the end\n\n  while (args.length && peek(args) == null) args.pop();\n\n  args.unshift(scaleRef(enc.gradient));\n  return `gradient(${args.join(',')})`;\n}\n\nfunction property(property) {\n  return isObject(property) ? '(' + entry$1(property) + ')' : property;\n}\n\nfunction field(ref) {\n  return resolveField(isObject(ref) ? ref : {\n    datum: ref\n  });\n}\n\nfunction resolveField(ref) {\n  let object, level, field;\n\n  if (ref.signal) {\n    object = 'datum';\n    field = ref.signal;\n  } else if (ref.group || ref.parent) {\n    level = Math.max(1, ref.level || 1);\n    object = 'item';\n\n    while (level-- > 0) {\n      object += '.mark.group';\n    }\n\n    if (ref.parent) {\n      field = ref.parent;\n      object += '.datum';\n    } else {\n      field = ref.group;\n    }\n  } else if (ref.datum) {\n    object = 'datum';\n    field = ref.datum;\n  } else {\n    error('Invalid field reference: ' + stringValue(ref));\n  }\n\n  if (!ref.signal) {\n    field = isString(field) ? splitAccessPath(field).map(stringValue).join('][') : resolveField(field);\n  }\n\n  return object + '[' + field + ']';\n}\n\nfunction scale(enc, value) {\n  const scale = scaleRef(enc.scale);\n\n  if (enc.range != null) {\n    // pull value from scale range\n    value = `lerp(_range(${scale}), ${+enc.range})`;\n  } else {\n    // run value through scale and/or pull scale bandwidth\n    if (value !== undefined) value = `_scale(${scale}, ${value})`;\n\n    if (enc.band) {\n      value = (value ? value + '+' : '') + `_bandwidth(${scale})` + (+enc.band === 1 ? '' : '*' + property(enc.band));\n\n      if (enc.extra) {\n        // include logic to handle extraneous elements\n        value = `(datum.extra ? _scale(${scale}, datum.extra.value) : ${value})`;\n      }\n    }\n\n    if (value == null) value = '0';\n  }\n\n  return value;\n}\n\nfunction rule (enc) {\n  let code = '';\n  enc.forEach(rule => {\n    const value = entry$1(rule);\n    code += rule.test ? `(${rule.test})?${value}:` : value;\n  }); // if no else clause, terminate with null (#1366)\n\n  if (peek(code) === ':') {\n    code += 'null';\n  }\n\n  return code;\n}\n\nfunction parseEncode (encode, type, role, style, scope, params) {\n  const enc = {};\n  params = params || {};\n  params.encoders = {\n    $encode: enc\n  };\n  encode = applyDefaults(encode, type, role, style, scope.config);\n\n  for (const key in encode) {\n    enc[key] = parseBlock(encode[key], type, params, scope);\n  }\n\n  return params;\n}\n\nfunction parseBlock(block, marktype, params, scope) {\n  const channels = {},\n        fields = {};\n\n  for (const name in block) {\n    if (block[name] != null) {\n      // skip any null entries\n      channels[name] = parse$1(expr(block[name]), scope, params, fields);\n    }\n  }\n\n  return {\n    $expr: {\n      marktype,\n      channels\n    },\n    $fields: Object.keys(fields),\n    $output: Object.keys(block)\n  };\n}\n\nfunction expr(enc) {\n  return isArray(enc) ? rule(enc) : entry$1(enc);\n}\n\nfunction parse$1(code, scope, params, fields) {\n  const expr = parseExpression(code, scope);\n  expr.$fields.forEach(name => fields[name] = 1);\n  extend(params, expr.$params);\n  return expr.$expr;\n}\n\nconst OUTER = 'outer',\n      OUTER_INVALID = ['value', 'update', 'init', 'react', 'bind'];\n\nfunction outerError(prefix, name) {\n  error(prefix + ' for \"outer\" push: ' + stringValue(name));\n}\n\nfunction parseSignal (signal, scope) {\n  const name = signal.name;\n\n  if (signal.push === OUTER) {\n    // signal must already be defined, raise error if not\n    if (!scope.signals[name]) outerError('No prior signal definition', name); // signal push must not use properties reserved for standard definition\n\n    OUTER_INVALID.forEach(prop => {\n      if (signal[prop] !== undefined) outerError('Invalid property ', prop);\n    });\n  } else {\n    // define a new signal in the current scope\n    const op = scope.addSignal(name, signal.value);\n    if (signal.react === false) op.react = false;\n    if (signal.bind) scope.addBinding(name, signal.bind);\n  }\n}\n\nfunction Entry(type, value, params, parent) {\n  this.id = -1;\n  this.type = type;\n  this.value = value;\n  this.params = params;\n  if (parent) this.parent = parent;\n}\nfunction entry(type, value, params, parent) {\n  return new Entry(type, value, params, parent);\n}\nfunction operator(value, params) {\n  return entry('operator', value, params);\n} // -----\n\nfunction ref(op) {\n  const ref = {\n    $ref: op.id\n  }; // if operator not yet registered, cache ref to resolve later\n\n  if (op.id < 0) (op.refs = op.refs || []).push(ref);\n  return ref;\n}\nfunction fieldRef$1(field, name) {\n  return name ? {\n    $field: field,\n    $name: name\n  } : {\n    $field: field\n  };\n}\nconst keyFieldRef = fieldRef$1('key');\nfunction compareRef(fields, orders) {\n  return {\n    $compare: fields,\n    $order: orders\n  };\n}\nfunction keyRef(fields, flat) {\n  const ref = {\n    $key: fields\n  };\n  if (flat) ref.$flat = true;\n  return ref;\n} // -----\n\nconst Ascending = 'ascending';\nconst Descending = 'descending';\nfunction sortKey(sort) {\n  return !isObject(sort) ? '' : (sort.order === Descending ? '-' : '+') + aggrField(sort.op, sort.field);\n}\nfunction aggrField(op, field) {\n  return (op && op.signal ? '$' + op.signal : op || '') + (op && field ? '_' : '') + (field && field.signal ? '$' + field.signal : field || '');\n} // -----\n\nconst Scope$1 = 'scope';\nconst View = 'view';\nfunction isSignal(_) {\n  return _ && _.signal;\n}\nfunction isExpr$1(_) {\n  return _ && _.expr;\n}\nfunction hasSignal(_) {\n  if (isSignal(_)) return true;\n  if (isObject(_)) for (const key in _) {\n    if (hasSignal(_[key])) return true;\n  }\n  return false;\n}\nfunction value(specValue, defaultValue) {\n  return specValue != null ? specValue : defaultValue;\n}\nfunction deref(v) {\n  return v && v.signal || v;\n}\n\nconst Timer = 'timer';\nfunction parseStream(stream, scope) {\n  const method = stream.merge ? mergeStream : stream.stream ? nestedStream : stream.type ? eventStream : error('Invalid stream specification: ' + stringValue(stream));\n  return method(stream, scope);\n}\n\nfunction eventSource(source) {\n  return source === Scope$1 ? View : source || View;\n}\n\nfunction mergeStream(stream, scope) {\n  const list = stream.merge.map(s => parseStream(s, scope)),\n        entry = streamParameters({\n    merge: list\n  }, stream, scope);\n  return scope.addStream(entry).id;\n}\n\nfunction nestedStream(stream, scope) {\n  const id = parseStream(stream.stream, scope),\n        entry = streamParameters({\n    stream: id\n  }, stream, scope);\n  return scope.addStream(entry).id;\n}\n\nfunction eventStream(stream, scope) {\n  let id;\n\n  if (stream.type === Timer) {\n    id = scope.event(Timer, stream.throttle);\n    stream = {\n      between: stream.between,\n      filter: stream.filter\n    };\n  } else {\n    id = scope.event(eventSource(stream.source), stream.type);\n  }\n\n  const entry = streamParameters({\n    stream: id\n  }, stream, scope);\n  return Object.keys(entry).length === 1 ? id : scope.addStream(entry).id;\n}\n\nfunction streamParameters(entry, stream, scope) {\n  let param = stream.between;\n\n  if (param) {\n    if (param.length !== 2) {\n      error('Stream \"between\" parameter must have 2 entries: ' + stringValue(stream));\n    }\n\n    entry.between = [parseStream(param[0], scope), parseStream(param[1], scope)];\n  }\n\n  param = stream.filter ? [].concat(stream.filter) : [];\n\n  if (stream.marktype || stream.markname || stream.markrole) {\n    // add filter for mark type, name and/or role\n    param.push(filterMark(stream.marktype, stream.markname, stream.markrole));\n  }\n\n  if (stream.source === Scope$1) {\n    // add filter to limit events from sub-scope only\n    param.push('inScope(event.item)');\n  }\n\n  if (param.length) {\n    entry.filter = parseExpression('(' + param.join(')&&(') + ')', scope).$expr;\n  }\n\n  if ((param = stream.throttle) != null) {\n    entry.throttle = +param;\n  }\n\n  if ((param = stream.debounce) != null) {\n    entry.debounce = +param;\n  }\n\n  if (stream.consume) {\n    entry.consume = true;\n  }\n\n  return entry;\n}\n\nfunction filterMark(type, name, role) {\n  const item = 'event.item';\n  return item + (type && type !== '*' ? '&&' + item + '.mark.marktype===\\'' + type + '\\'' : '') + (role ? '&&' + item + '.mark.role===\\'' + role + '\\'' : '') + (name ? '&&' + item + '.mark.name===\\'' + name + '\\'' : '');\n}\n\nconst OP_VALUE_EXPR = {\n  code: '_.$value',\n  ast: {\n    type: 'Identifier',\n    value: 'value'\n  }\n};\nfunction parseUpdate (spec, scope, target) {\n  const encode = spec.encode,\n        entry = {\n    target: target\n  };\n  let events = spec.events,\n      update = spec.update,\n      sources = [];\n\n  if (!events) {\n    error('Signal update missing events specification.');\n  } // interpret as an event selector string\n\n\n  if (isString(events)) {\n    events = parseSelector(events, scope.isSubscope() ? Scope$1 : View);\n  } // separate event streams from signal updates\n\n\n  events = array(events).filter(s => s.signal || s.scale ? (sources.push(s), 0) : 1); // merge internal operator listeners\n\n  if (sources.length > 1) {\n    sources = [mergeSources(sources)];\n  } // merge event streams, include as source\n\n\n  if (events.length) {\n    sources.push(events.length > 1 ? {\n      merge: events\n    } : events[0]);\n  }\n\n  if (encode != null) {\n    if (update) error('Signal encode and update are mutually exclusive.');\n    update = 'encode(item(),' + stringValue(encode) + ')';\n  } // resolve update value\n\n\n  entry.update = isString(update) ? parseExpression(update, scope) : update.expr != null ? parseExpression(update.expr, scope) : update.value != null ? update.value : update.signal != null ? {\n    $expr: OP_VALUE_EXPR,\n    $params: {\n      $value: scope.signalRef(update.signal)\n    }\n  } : error('Invalid signal update specification.');\n\n  if (spec.force) {\n    entry.options = {\n      force: true\n    };\n  }\n\n  sources.forEach(source => scope.addUpdate(extend(streamSource(source, scope), entry)));\n}\n\nfunction streamSource(stream, scope) {\n  return {\n    source: stream.signal ? scope.signalRef(stream.signal) : stream.scale ? scope.scaleRef(stream.scale) : parseStream(stream, scope)\n  };\n}\n\nfunction mergeSources(sources) {\n  return {\n    signal: '[' + sources.map(s => s.scale ? 'scale(\"' + s.scale + '\")' : s.signal) + ']'\n  };\n}\n\nfunction parseSignalUpdates (signal, scope) {\n  const op = scope.getSignal(signal.name);\n  let expr = signal.update;\n\n  if (signal.init) {\n    if (expr) {\n      error('Signals can not include both init and update expressions.');\n    } else {\n      expr = signal.init;\n      op.initonly = true;\n    }\n  }\n\n  if (expr) {\n    expr = parseExpression(expr, scope);\n    op.update = expr.$expr;\n    op.params = expr.$params;\n  }\n\n  if (signal.on) {\n    signal.on.forEach(_ => parseUpdate(_, scope, op.id));\n  }\n}\n\nconst transform = name => (params, value, parent) => entry(name, value, params || undefined, parent);\n\nconst Aggregate = transform('aggregate');\nconst AxisTicks = transform('axisticks');\nconst Bound = transform('bound');\nconst Collect = transform('collect');\nconst Compare = transform('compare');\nconst DataJoin = transform('datajoin');\nconst Encode = transform('encode');\nconst Expression = transform('expression');\nconst Facet = transform('facet');\nconst Field = transform('field');\nconst Key = transform('key');\nconst LegendEntries = transform('legendentries');\nconst Load = transform('load');\nconst Mark = transform('mark');\nconst MultiExtent = transform('multiextent');\nconst MultiValues = transform('multivalues');\nconst Overlap = transform('overlap');\nconst Params = transform('params');\nconst PreFacet = transform('prefacet');\nconst Projection = transform('projection');\nconst Proxy = transform('proxy');\nconst Relay = transform('relay');\nconst Render = transform('render');\nconst Scale = transform('scale');\nconst Sieve = transform('sieve');\nconst SortItems = transform('sortitems');\nconst ViewLayout = transform('viewlayout');\nconst Values = transform('values');\n\nlet FIELD_REF_ID = 0;\nconst MULTIDOMAIN_SORT_OPS = {\n  min: 'min',\n  max: 'max',\n  count: 'sum'\n};\nfunction initScale(spec, scope) {\n  const type = spec.type || 'linear';\n\n  if (!isValidScaleType(type)) {\n    error('Unrecognized scale type: ' + stringValue(type));\n  }\n\n  scope.addScale(spec.name, {\n    type,\n    domain: undefined\n  });\n}\nfunction parseScale(spec, scope) {\n  const params = scope.getScale(spec.name).params;\n  let key;\n  params.domain = parseScaleDomain(spec.domain, spec, scope);\n\n  if (spec.range != null) {\n    params.range = parseScaleRange(spec, scope, params);\n  }\n\n  if (spec.interpolate != null) {\n    parseScaleInterpolate(spec.interpolate, params);\n  }\n\n  if (spec.nice != null) {\n    params.nice = parseScaleNice(spec.nice);\n  }\n\n  if (spec.bins != null) {\n    params.bins = parseScaleBins(spec.bins, scope);\n  }\n\n  for (key in spec) {\n    if (hasOwnProperty(params, key) || key === 'name') continue;\n    params[key] = parseLiteral(spec[key], scope);\n  }\n}\n\nfunction parseLiteral(v, scope) {\n  return !isObject(v) ? v : v.signal ? scope.signalRef(v.signal) : error('Unsupported object: ' + stringValue(v));\n}\n\nfunction parseArray(v, scope) {\n  return v.signal ? scope.signalRef(v.signal) : v.map(v => parseLiteral(v, scope));\n}\n\nfunction dataLookupError(name) {\n  error('Can not find data set: ' + stringValue(name));\n} // -- SCALE DOMAIN ----\n\n\nfunction parseScaleDomain(domain, spec, scope) {\n  if (!domain) {\n    if (spec.domainMin != null || spec.domainMax != null) {\n      error('No scale domain defined for domainMin/domainMax to override.');\n    }\n\n    return; // default domain\n  }\n\n  return domain.signal ? scope.signalRef(domain.signal) : (isArray(domain) ? explicitDomain : domain.fields ? multipleDomain : singularDomain)(domain, spec, scope);\n}\n\nfunction explicitDomain(domain, spec, scope) {\n  return domain.map(v => parseLiteral(v, scope));\n}\n\nfunction singularDomain(domain, spec, scope) {\n  const data = scope.getData(domain.data);\n  if (!data) dataLookupError(domain.data);\n  return isDiscrete(spec.type) ? data.valuesRef(scope, domain.field, parseSort(domain.sort, false)) : isQuantile(spec.type) ? data.domainRef(scope, domain.field) : data.extentRef(scope, domain.field);\n}\n\nfunction multipleDomain(domain, spec, scope) {\n  const data = domain.data,\n        fields = domain.fields.reduce((dom, d) => {\n    d = isString(d) ? {\n      data: data,\n      field: d\n    } : isArray(d) || d.signal ? fieldRef(d, scope) : d;\n    dom.push(d);\n    return dom;\n  }, []);\n  return (isDiscrete(spec.type) ? ordinalMultipleDomain : isQuantile(spec.type) ? quantileMultipleDomain : numericMultipleDomain)(domain, scope, fields);\n}\n\nfunction fieldRef(data, scope) {\n  const name = '_:vega:_' + FIELD_REF_ID++,\n        coll = Collect({});\n\n  if (isArray(data)) {\n    coll.value = {\n      $ingest: data\n    };\n  } else if (data.signal) {\n    const code = 'setdata(' + stringValue(name) + ',' + data.signal + ')';\n    coll.params.input = scope.signalRef(code);\n  }\n\n  scope.addDataPipeline(name, [coll, Sieve({})]);\n  return {\n    data: name,\n    field: 'data'\n  };\n}\n\nfunction ordinalMultipleDomain(domain, scope, fields) {\n  const sort = parseSort(domain.sort, true);\n  let a, v; // get value counts for each domain field\n\n  const counts = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.countsRef(scope, f.field, sort);\n  }); // aggregate the results from each domain field\n\n  const p = {\n    groupby: keyFieldRef,\n    pulse: counts\n  };\n\n  if (sort) {\n    a = sort.op || 'count';\n    v = sort.field ? aggrField(a, sort.field) : 'count';\n    p.ops = [MULTIDOMAIN_SORT_OPS[a]];\n    p.fields = [scope.fieldRef(v)];\n    p.as = [v];\n  }\n\n  a = scope.add(Aggregate(p)); // collect aggregate output\n\n  const c = scope.add(Collect({\n    pulse: ref(a)\n  })); // extract values for combined domain\n\n  v = scope.add(Values({\n    field: keyFieldRef,\n    sort: scope.sortRef(sort),\n    pulse: ref(c)\n  }));\n  return ref(v);\n}\n\nfunction parseSort(sort, multidomain) {\n  if (sort) {\n    if (!sort.field && !sort.op) {\n      if (isObject(sort)) sort.field = 'key';else sort = {\n        field: 'key'\n      };\n    } else if (!sort.field && sort.op !== 'count') {\n      error('No field provided for sort aggregate op: ' + sort.op);\n    } else if (multidomain && sort.field) {\n      if (sort.op && !MULTIDOMAIN_SORT_OPS[sort.op]) {\n        error('Multiple domain scales can not be sorted using ' + sort.op);\n      }\n    }\n  }\n\n  return sort;\n}\n\nfunction quantileMultipleDomain(domain, scope, fields) {\n  // get value arrays for each domain field\n  const values = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.domainRef(scope, f.field);\n  }); // combine value arrays\n\n  return ref(scope.add(MultiValues({\n    values: values\n  })));\n}\n\nfunction numericMultipleDomain(domain, scope, fields) {\n  // get extents for each domain field\n  const extents = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.extentRef(scope, f.field);\n  }); // combine extents\n\n  return ref(scope.add(MultiExtent({\n    extents: extents\n  })));\n} // -- SCALE BINS -----\n\n\nfunction parseScaleBins(v, scope) {\n  return v.signal || isArray(v) ? parseArray(v, scope) : scope.objectProperty(v);\n} // -- SCALE NICE -----\n\n\nfunction parseScaleNice(nice) {\n  return isObject(nice) ? {\n    interval: parseLiteral(nice.interval),\n    step: parseLiteral(nice.step)\n  } : parseLiteral(nice);\n} // -- SCALE INTERPOLATION -----\n\n\nfunction parseScaleInterpolate(interpolate, params) {\n  params.interpolate = parseLiteral(interpolate.type || interpolate);\n\n  if (interpolate.gamma != null) {\n    params.interpolateGamma = parseLiteral(interpolate.gamma);\n  }\n} // -- SCALE RANGE -----\n\n\nfunction parseScaleRange(spec, scope, params) {\n  const config = scope.config.range;\n  let range = spec.range;\n\n  if (range.signal) {\n    return scope.signalRef(range.signal);\n  } else if (isString(range)) {\n    if (config && hasOwnProperty(config, range)) {\n      spec = extend({}, spec, {\n        range: config[range]\n      });\n      return parseScaleRange(spec, scope, params);\n    } else if (range === 'width') {\n      range = [0, {\n        signal: 'width'\n      }];\n    } else if (range === 'height') {\n      range = isDiscrete(spec.type) ? [0, {\n        signal: 'height'\n      }] : [{\n        signal: 'height'\n      }, 0];\n    } else {\n      error('Unrecognized scale range value: ' + stringValue(range));\n    }\n  } else if (range.scheme) {\n    params.scheme = isArray(range.scheme) ? parseArray(range.scheme, scope) : parseLiteral(range.scheme, scope);\n    if (range.extent) params.schemeExtent = parseArray(range.extent, scope);\n    if (range.count) params.schemeCount = parseLiteral(range.count, scope);\n    return;\n  } else if (range.step) {\n    params.rangeStep = parseLiteral(range.step, scope);\n    return;\n  } else if (isDiscrete(spec.type) && !isArray(range)) {\n    return parseScaleDomain(range, spec, scope);\n  } else if (!isArray(range)) {\n    error('Unsupported range type: ' + stringValue(range));\n  }\n\n  return range.map(v => (isArray(v) ? parseArray : parseLiteral)(v, scope));\n}\n\nfunction parseProjection (proj, scope) {\n  const config = scope.config.projection || {},\n        params = {};\n\n  for (const name in proj) {\n    if (name === 'name') continue;\n    params[name] = parseParameter$1(proj[name], name, scope);\n  } // apply projection defaults from config\n\n\n  for (const name in config) {\n    if (params[name] == null) {\n      params[name] = parseParameter$1(config[name], name, scope);\n    }\n  }\n\n  scope.addProjection(proj.name, params);\n}\n\nfunction parseParameter$1(_, name, scope) {\n  return isArray(_) ? _.map(_ => parseParameter$1(_, name, scope)) : !isObject(_) ? _ : _.signal ? scope.signalRef(_.signal) : name === 'fit' ? _ : error('Unsupported parameter object: ' + stringValue(_));\n}\n\nconst Top = 'top';\nconst Left = 'left';\nconst Right = 'right';\nconst Bottom = 'bottom';\nconst Center = 'center';\nconst Vertical = 'vertical';\nconst Start = 'start';\nconst Middle = 'middle';\nconst End = 'end';\nconst Index = 'index';\nconst Label = 'label';\nconst Offset = 'offset';\nconst Perc = 'perc';\nconst Perc2 = 'perc2';\nconst Value = 'value';\nconst GuideLabelStyle = 'guide-label';\nconst GuideTitleStyle = 'guide-title';\nconst GroupTitleStyle = 'group-title';\nconst GroupSubtitleStyle = 'group-subtitle';\nconst Symbols = 'symbol';\nconst Gradient = 'gradient';\nconst Discrete = 'discrete';\nconst Size = 'size';\nconst Shape = 'shape';\nconst Fill = 'fill';\nconst Stroke = 'stroke';\nconst StrokeWidth = 'strokeWidth';\nconst StrokeDash = 'strokeDash';\nconst Opacity = 'opacity'; // Encoding channels supported by legends\n// In priority order of 'canonical' scale\n\nconst LegendScales = [Size, Shape, Fill, Stroke, StrokeWidth, StrokeDash, Opacity];\nconst Skip = {\n  name: 1,\n  style: 1,\n  interactive: 1\n};\nconst zero = {\n  value: 0\n};\nconst one = {\n  value: 1\n};\n\nconst GroupMark = 'group';\nconst RectMark = 'rect';\nconst RuleMark = 'rule';\nconst SymbolMark = 'symbol';\nconst TextMark = 'text';\n\nfunction guideGroup (mark) {\n  mark.type = GroupMark;\n  mark.interactive = mark.interactive || false;\n  return mark;\n}\n\nfunction lookup(spec, config) {\n  const _ = (name, dflt) => value(spec[name], value(config[name], dflt));\n\n  _.isVertical = s => Vertical === value(spec.direction, config.direction || (s ? config.symbolDirection : config.gradientDirection));\n\n  _.gradientLength = () => value(spec.gradientLength, config.gradientLength || config.gradientWidth);\n\n  _.gradientThickness = () => value(spec.gradientThickness, config.gradientThickness || config.gradientHeight);\n\n  _.entryColumns = () => value(spec.columns, value(config.columns, +_.isVertical(true)));\n\n  return _;\n}\nfunction getEncoding(name, encode) {\n  const v = encode && (encode.update && encode.update[name] || encode.enter && encode.enter[name]);\n  return v && v.signal ? v : v ? v.value : null;\n}\nfunction getStyle(name, scope, style) {\n  const s = scope.config.style[style];\n  return s && s[name];\n}\nfunction anchorExpr(s, e, m) {\n  return `item.anchor === '${Start}' ? ${s} : item.anchor === '${End}' ? ${e} : ${m}`;\n}\nconst alignExpr$1 = anchorExpr(stringValue(Left), stringValue(Right), stringValue(Center));\nfunction tickBand(_) {\n  const v = _('tickBand');\n\n  let offset = _('tickOffset'),\n      band,\n      extra;\n\n  if (!v) {\n    // if no tick band entry, fall back on other properties\n    band = _('bandPosition');\n    extra = _('tickExtra');\n  } else if (v.signal) {\n    // if signal, augment code to interpret values\n    band = {\n      signal: `(${v.signal}) === 'extent' ? 1 : 0.5`\n    };\n    extra = {\n      signal: `(${v.signal}) === 'extent'`\n    };\n\n    if (!isObject(offset)) {\n      offset = {\n        signal: `(${v.signal}) === 'extent' ? 0 : ${offset}`\n      };\n    }\n  } else if (v === 'extent') {\n    // if constant, simply set values\n    band = 1;\n    extra = true;\n    offset = 0;\n  } else {\n    band = 0.5;\n    extra = false;\n  }\n\n  return {\n    extra,\n    band,\n    offset\n  };\n}\nfunction extendOffset(value, offset) {\n  return !offset ? value : !value ? offset : !isObject(value) ? {\n    value,\n    offset\n  } : Object.assign({}, value, {\n    offset: extendOffset(value.offset, offset)\n  });\n}\n\nfunction guideMark (mark, extras) {\n  if (extras) {\n    mark.name = extras.name;\n    mark.style = extras.style || mark.style;\n    mark.interactive = !!extras.interactive;\n    mark.encode = extendEncode(mark.encode, extras, Skip);\n  } else {\n    mark.interactive = false;\n  }\n\n  return mark;\n}\n\nfunction legendGradient (spec, scale, config, userEncode) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = _.gradientThickness(),\n        length = _.gradientLength();\n\n  let enter, start, stop, width, height;\n\n  if (vertical) {\n    start = [0, 1];\n    stop = [0, 0];\n    width = thickness;\n    height = length;\n  } else {\n    start = [0, 0];\n    stop = [1, 0];\n    width = length;\n    height = thickness;\n  }\n\n  const encode = {\n    enter: enter = {\n      opacity: zero,\n      x: zero,\n      y: zero,\n      width: encoder(width),\n      height: encoder(height)\n    },\n    update: extend({}, enter, {\n      opacity: one,\n      fill: {\n        gradient: scale,\n        start: start,\n        stop: stop\n      }\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, {\n    // update\n    opacity: _('gradientOpacity')\n  });\n  return guideMark({\n    type: RectMark,\n    role: LegendGradientRole,\n    encode\n  }, userEncode);\n}\n\nfunction legendGradientDiscrete (spec, scale, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = _.gradientThickness(),\n        length = _.gradientLength();\n\n  let u,\n      v,\n      uu,\n      vv,\n      adjust = '';\n  vertical ? (u = 'y', uu = 'y2', v = 'x', vv = 'width', adjust = '1-') : (u = 'x', uu = 'x2', v = 'y', vv = 'height');\n  const enter = {\n    opacity: zero,\n    fill: {\n      scale: scale,\n      field: Value\n    }\n  };\n  enter[u] = {\n    signal: adjust + 'datum.' + Perc,\n    mult: length\n  };\n  enter[v] = zero;\n  enter[uu] = {\n    signal: adjust + 'datum.' + Perc2,\n    mult: length\n  };\n  enter[vv] = encoder(thickness);\n  const encode = {\n    enter: enter,\n    update: extend({}, enter, {\n      opacity: one\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, {\n    // update\n    opacity: _('gradientOpacity')\n  });\n  return guideMark({\n    type: RectMark,\n    role: LegendBandRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nconst alignExpr = `datum.${Perc}<=0?\"${Left}\":datum.${Perc}>=1?\"${Right}\":\"${Center}\"`,\n      baselineExpr = `datum.${Perc}<=0?\"${Bottom}\":datum.${Perc}>=1?\"${Top}\":\"${Middle}\"`;\nfunction legendGradientLabels (spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = encoder(_.gradientThickness()),\n        length = _.gradientLength();\n\n  let overlap = _('labelOverlap'),\n      enter,\n      update,\n      u,\n      v,\n      adjust = '';\n\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontStyle: _('labelFontStyle'),\n    fontWeight: _('labelFontWeight'),\n    limit: value(spec.labelLimit, config.gradientLabelLimit)\n  });\n\n  if (vertical) {\n    enter.align = {\n      value: 'left'\n    };\n    enter.baseline = update.baseline = {\n      signal: baselineExpr\n    };\n    u = 'y';\n    v = 'x';\n    adjust = '1-';\n  } else {\n    enter.align = update.align = {\n      signal: alignExpr\n    };\n    enter.baseline = {\n      value: 'top'\n    };\n    u = 'x';\n    v = 'y';\n  }\n\n  enter[u] = update[u] = {\n    signal: adjust + 'datum.' + Perc,\n    mult: length\n  };\n  enter[v] = update[v] = thickness;\n  thickness.offset = value(spec.labelOffset, config.gradientLabelOffset) || 0;\n  overlap = overlap ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.' + Index\n  } : undefined; // type, role, style, key, dataRef, encode, extras\n\n  return guideMark({\n    type: TextMark,\n    role: LegendLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: dataRef,\n    encode,\n    overlap\n  }, userEncode);\n}\n\nfunction legendSymbolGroups (spec, config, userEncode, dataRef, columns) {\n  const _ = lookup(spec, config),\n        entries = userEncode.entries,\n        interactive = !!(entries && entries.interactive),\n        name = entries ? entries.name : undefined,\n        height = _('clipHeight'),\n        symbolOffset = _('symbolOffset'),\n        valueRef = {\n    data: 'value'\n  },\n        xSignal = `(${columns}) ? datum.${Offset} : datum.${Size}`,\n        yEncode = height ? encoder(height) : {\n    field: Size\n  },\n        index = `datum.${Index}`,\n        ncols = `max(1, ${columns})`;\n\n  let encode, enter, update, nrows, sort;\n  yEncode.mult = 0.5; // -- LEGEND SYMBOLS --\n\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: {\n        signal: xSignal,\n        mult: 0.5,\n        offset: symbolOffset\n      },\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  let baseFill = null,\n      baseStroke = null;\n\n  if (!spec.fill) {\n    baseFill = config.symbolBaseFillColor;\n    baseStroke = config.symbolBaseStrokeColor;\n  }\n\n  addEncoders(encode, {\n    fill: _('symbolFillColor', baseFill),\n    shape: _('symbolType'),\n    size: _('symbolSize'),\n    stroke: _('symbolStrokeColor', baseStroke),\n    strokeDash: _('symbolDash'),\n    strokeDashOffset: _('symbolDashOffset'),\n    strokeWidth: _('symbolStrokeWidth')\n  }, {\n    // update\n    opacity: _('symbolOpacity')\n  });\n  LegendScales.forEach(scale => {\n    if (spec[scale]) {\n      update[scale] = enter[scale] = {\n        scale: spec[scale],\n        field: Value\n      };\n    }\n  });\n  const symbols = guideMark({\n    type: SymbolMark,\n    role: LegendSymbolRole,\n    key: Value,\n    from: valueRef,\n    clip: height ? true : undefined,\n    encode\n  }, userEncode.symbols); // -- LEGEND LABELS --\n\n  const labelOffset = encoder(symbolOffset);\n  labelOffset.offset = _('labelOffset');\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: {\n        signal: xSignal,\n        offset: labelOffset\n      },\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      },\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    align: _('labelAlign'),\n    baseline: _('labelBaseline'),\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontStyle: _('labelFontStyle'),\n    fontWeight: _('labelFontWeight'),\n    limit: _('labelLimit')\n  });\n  const labels = guideMark({\n    type: TextMark,\n    role: LegendLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: valueRef,\n    encode\n  }, userEncode.labels); // -- LEGEND ENTRY GROUPS --\n\n  encode = {\n    enter: {\n      noBound: {\n        value: !height\n      },\n      // ignore width/height in bounds calc\n      width: zero,\n      height: height ? encoder(height) : zero,\n      opacity: zero\n    },\n    exit: {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one,\n      row: {\n        signal: null\n      },\n      column: {\n        signal: null\n      }\n    }\n  }; // annotate and sort groups to ensure correct ordering\n\n  if (_.isVertical(true)) {\n    nrows = `ceil(item.mark.items.length / ${ncols})`;\n    update.row.signal = `${index}%${nrows}`;\n    update.column.signal = `floor(${index} / ${nrows})`;\n    sort = {\n      field: ['row', index]\n    };\n  } else {\n    update.row.signal = `floor(${index} / ${ncols})`;\n    update.column.signal = `${index} % ${ncols}`;\n    sort = {\n      field: index\n    };\n  } // handle zero column case (implies infinite columns)\n\n\n  update.column.signal = `(${columns})?${update.column.signal}:${index}`; // facet legend entries into sub-groups\n\n  dataRef = {\n    facet: {\n      data: dataRef,\n      name: 'value',\n      groupby: Index\n    }\n  };\n  return guideGroup({\n    role: ScopeRole,\n    from: dataRef,\n    encode: extendEncode(encode, entries, Skip),\n    marks: [symbols, labels],\n    name,\n    interactive,\n    sort\n  });\n}\nfunction legendSymbolLayout(spec, config) {\n  const _ = lookup(spec, config); // layout parameters for legend entries\n\n\n  return {\n    align: _('gridAlign'),\n    columns: _.entryColumns(),\n    center: {\n      row: true,\n      column: false\n    },\n    padding: {\n      row: _('rowPadding'),\n      column: _('columnPadding')\n    }\n  };\n}\n\nconst isL = 'item.orient === \"left\"',\n      isR = 'item.orient === \"right\"',\n      isLR = `(${isL} || ${isR})`,\n      isVG = `datum.vgrad && ${isLR}`,\n      baseline = anchorExpr('\"top\"', '\"bottom\"', '\"middle\"'),\n      alignFlip = anchorExpr('\"right\"', '\"left\"', '\"center\"'),\n      exprAlign = `datum.vgrad && ${isR} ? (${alignFlip}) : (${isLR} && !(datum.vgrad && ${isL})) ? \"left\" : ${alignExpr$1}`,\n      exprAnchor = `item._anchor || (${isLR} ? \"middle\" : \"start\")`,\n      exprAngle = `${isVG} ? (${isL} ? -90 : 90) : 0`,\n      exprBaseline = `${isLR} ? (datum.vgrad ? (${isR} ? \"bottom\" : \"top\") : ${baseline}) : \"top\"`;\nfunction legendTitle (spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config);\n\n  const encode = {\n    enter: {\n      opacity: zero\n    },\n    update: {\n      opacity: one,\n      x: {\n        field: {\n          group: 'padding'\n        }\n      },\n      y: {\n        field: {\n          group: 'padding'\n        }\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    orient: _('titleOrient'),\n    _anchor: _('titleAnchor'),\n    anchor: {\n      signal: exprAnchor\n    },\n    angle: {\n      signal: exprAngle\n    },\n    align: {\n      signal: exprAlign\n    },\n    baseline: {\n      signal: exprBaseline\n    },\n    text: spec.title,\n    fill: _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font: _('titleFont'),\n    fontSize: _('titleFontSize'),\n    fontStyle: _('titleFontStyle'),\n    fontWeight: _('titleFontWeight'),\n    limit: _('titleLimit'),\n    lineHeight: _('titleLineHeight')\n  }, {\n    // require update\n    align: _('titleAlign'),\n    baseline: _('titleBaseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: LegendTitleRole,\n    style: GuideTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction clip (clip, scope) {\n  let expr;\n\n  if (isObject(clip)) {\n    if (clip.signal) {\n      expr = clip.signal;\n    } else if (clip.path) {\n      expr = 'pathShape(' + param(clip.path) + ')';\n    } else if (clip.sphere) {\n      expr = 'geoShape(' + param(clip.sphere) + ', {type: \"Sphere\"})';\n    }\n  }\n\n  return expr ? scope.signalRef(expr) : !!clip;\n}\n\nfunction param(value) {\n  return isObject(value) && value.signal ? value.signal : stringValue(value);\n}\n\nfunction getRole (spec) {\n  const role = spec.role || '';\n  return !role.indexOf('axis') || !role.indexOf('legend') || !role.indexOf('title') ? role : spec.type === GroupMark ? ScopeRole : role || MarkRole;\n}\n\nfunction definition (spec) {\n  return {\n    marktype: spec.type,\n    name: spec.name || undefined,\n    role: spec.role || getRole(spec),\n    zindex: +spec.zindex || undefined,\n    aria: spec.aria,\n    description: spec.description\n  };\n}\n\nfunction interactive (spec, scope) {\n  return spec && spec.signal ? scope.signalRef(spec.signal) : spec === false ? false : true;\n}\n\n/**\n * Parse a data transform specification.\n */\n\nfunction parseTransform (spec, scope) {\n  const def = definition$1(spec.type);\n  if (!def) error('Unrecognized transform type: ' + stringValue(spec.type));\n  const t = entry(def.type.toLowerCase(), null, parseParameters(def, spec, scope));\n  if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t));\n  t.metadata = def.metadata || {};\n  return t;\n}\n/**\n * Parse all parameters of a data transform.\n */\n\nfunction parseParameters(def, spec, scope) {\n  const params = {},\n        n = def.params.length;\n\n  for (let i = 0; i < n; ++i) {\n    const pdef = def.params[i];\n    params[pdef.name] = parseParameter(pdef, spec, scope);\n  }\n\n  return params;\n}\n/**\n * Parse a data transform parameter.\n */\n\n\nfunction parseParameter(def, spec, scope) {\n  const type = def.type,\n        value = spec[def.name];\n\n  if (type === 'index') {\n    return parseIndexParameter(def, spec, scope);\n  } else if (value === undefined) {\n    if (def.required) {\n      error('Missing required ' + stringValue(spec.type) + ' parameter: ' + stringValue(def.name));\n    }\n\n    return;\n  } else if (type === 'param') {\n    return parseSubParameters(def, spec, scope);\n  } else if (type === 'projection') {\n    return scope.projectionRef(spec[def.name]);\n  }\n\n  return def.array && !isSignal(value) ? value.map(v => parameterValue(def, v, scope)) : parameterValue(def, value, scope);\n}\n/**\n * Parse a single parameter value.\n */\n\n\nfunction parameterValue(def, value, scope) {\n  const type = def.type;\n\n  if (isSignal(value)) {\n    return isExpr(type) ? error('Expression references can not be signals.') : isField(type) ? scope.fieldRef(value) : isCompare(type) ? scope.compareRef(value) : scope.signalRef(value.signal);\n  } else {\n    const expr = def.expr || isField(type);\n    return expr && outerExpr(value) ? scope.exprRef(value.expr, value.as) : expr && outerField(value) ? fieldRef$1(value.field, value.as) : isExpr(type) ? parseExpression(value, scope) : isData(type) ? ref(scope.getData(value).values) : isField(type) ? fieldRef$1(value) : isCompare(type) ? scope.compareRef(value) : value;\n  }\n}\n/**\n * Parse parameter for accessing an index of another data set.\n */\n\n\nfunction parseIndexParameter(def, spec, scope) {\n  if (!isString(spec.from)) {\n    error('Lookup \"from\" parameter must be a string literal.');\n  }\n\n  return scope.getData(spec.from).lookupRef(scope, spec.key);\n}\n/**\n * Parse a parameter that contains one or more sub-parameter objects.\n */\n\n\nfunction parseSubParameters(def, spec, scope) {\n  const value = spec[def.name];\n\n  if (def.array) {\n    if (!isArray(value)) {\n      // signals not allowed!\n      error('Expected an array of sub-parameters. Instead: ' + stringValue(value));\n    }\n\n    return value.map(v => parseSubParameter(def, v, scope));\n  } else {\n    return parseSubParameter(def, value, scope);\n  }\n}\n/**\n * Parse a sub-parameter object.\n */\n\n\nfunction parseSubParameter(def, value, scope) {\n  const n = def.params.length;\n  let pdef; // loop over defs to find matching key\n\n  for (let i = 0; i < n; ++i) {\n    pdef = def.params[i];\n\n    for (const k in pdef.key) {\n      if (pdef.key[k] !== value[k]) {\n        pdef = null;\n        break;\n      }\n    }\n\n    if (pdef) break;\n  } // raise error if matching key not found\n\n\n  if (!pdef) error('Unsupported parameter: ' + stringValue(value)); // parse params, create Params transform, return ref\n\n  const params = extend(parseParameters(pdef, value, scope), pdef.key);\n  return ref(scope.add(Params(params)));\n} // -- Utilities -----\n\n\nconst outerExpr = _ => _ && _.expr;\nconst outerField = _ => _ && _.field;\nconst isData = _ => _ === 'data';\nconst isExpr = _ => _ === 'expr';\nconst isField = _ => _ === 'field';\nconst isCompare = _ => _ === 'compare';\n\nfunction parseData$1 (from, group, scope) {\n  let facet, key, op, dataRef, parent; // if no source data, generate singleton datum\n\n  if (!from) {\n    dataRef = ref(scope.add(Collect(null, [{}])));\n  } // if faceted, process facet specification\n  else if (facet = from.facet) {\n    if (!group) error('Only group marks can be faceted.'); // use pre-faceted source data, if available\n\n    if (facet.field != null) {\n      dataRef = parent = getDataRef(facet, scope);\n    } else {\n      // generate facet aggregates if no direct data specification\n      if (!from.data) {\n        op = parseTransform(extend({\n          type: 'aggregate',\n          groupby: array(facet.groupby)\n        }, facet.aggregate), scope);\n        op.params.key = scope.keyRef(facet.groupby);\n        op.params.pulse = getDataRef(facet, scope);\n        dataRef = parent = ref(scope.add(op));\n      } else {\n        parent = ref(scope.getData(from.data).aggregate);\n      }\n\n      key = scope.keyRef(facet.groupby, true);\n    }\n  } // if not yet defined, get source data reference\n\n\n  if (!dataRef) {\n    dataRef = getDataRef(from, scope);\n  }\n\n  return {\n    key: key,\n    pulse: dataRef,\n    parent: parent\n  };\n}\nfunction getDataRef(from, scope) {\n  return from.$ref ? from : from.data && from.data.$ref ? from.data : ref(scope.getData(from.data).output);\n}\n\nfunction DataScope(scope, input, output, values, aggr) {\n  this.scope = scope; // parent scope object\n\n  this.input = input; // first operator in pipeline (tuple input)\n\n  this.output = output; // last operator in pipeline (tuple output)\n\n  this.values = values; // operator for accessing tuples (but not tuple flow)\n  // last aggregate in transform pipeline\n\n  this.aggregate = aggr; // lookup table of field indices\n\n  this.index = {};\n}\n\nDataScope.fromEntries = function (scope, entries) {\n  const n = entries.length,\n        values = entries[n - 1],\n        output = entries[n - 2];\n  let input = entries[0],\n      aggr = null,\n      i = 1;\n\n  if (input && input.type === 'load') {\n    input = entries[1];\n  } // add operator entries to this scope, wire up pulse chain\n\n\n  scope.add(entries[0]);\n\n  for (; i < n; ++i) {\n    entries[i].params.pulse = ref(entries[i - 1]);\n    scope.add(entries[i]);\n    if (entries[i].type === 'aggregate') aggr = entries[i];\n  }\n\n  return new DataScope(scope, input, output, values, aggr);\n};\n\nfunction fieldKey(field) {\n  return isString(field) ? field : null;\n}\n\nfunction addSortField(scope, p, sort) {\n  const as = aggrField(sort.op, sort.field);\n  let s;\n\n  if (p.ops) {\n    for (let i = 0, n = p.as.length; i < n; ++i) {\n      if (p.as[i] === as) return;\n    }\n  } else {\n    p.ops = ['count'];\n    p.fields = [null];\n    p.as = ['count'];\n  }\n\n  if (sort.op) {\n    p.ops.push((s = sort.op.signal) ? scope.signalRef(s) : sort.op);\n    p.fields.push(scope.fieldRef(sort.field));\n    p.as.push(as);\n  }\n}\n\nfunction cache(scope, ds, name, optype, field, counts, index) {\n  const cache = ds[name] || (ds[name] = {}),\n        sort = sortKey(counts);\n  let k = fieldKey(field),\n      v,\n      op;\n\n  if (k != null) {\n    scope = ds.scope;\n    k = k + (sort ? '|' + sort : '');\n    v = cache[k];\n  }\n\n  if (!v) {\n    const params = counts ? {\n      field: keyFieldRef,\n      pulse: ds.countsRef(scope, field, counts)\n    } : {\n      field: scope.fieldRef(field),\n      pulse: ref(ds.output)\n    };\n    if (sort) params.sort = scope.sortRef(counts);\n    op = scope.add(entry(optype, undefined, params));\n    if (index) ds.index[field] = op;\n    v = ref(op);\n    if (k != null) cache[k] = v;\n  }\n\n  return v;\n}\n\nDataScope.prototype = {\n  countsRef(scope, field, sort) {\n    const ds = this,\n          cache = ds.counts || (ds.counts = {}),\n          k = fieldKey(field);\n    let v, a, p;\n\n    if (k != null) {\n      scope = ds.scope;\n      v = cache[k];\n    }\n\n    if (!v) {\n      p = {\n        groupby: scope.fieldRef(field, 'key'),\n        pulse: ref(ds.output)\n      };\n      if (sort && sort.field) addSortField(scope, p, sort);\n      a = scope.add(Aggregate(p));\n      v = scope.add(Collect({\n        pulse: ref(a)\n      }));\n      v = {\n        agg: a,\n        ref: ref(v)\n      };\n      if (k != null) cache[k] = v;\n    } else if (sort && sort.field) {\n      addSortField(scope, v.agg.params, sort);\n    }\n\n    return v.ref;\n  },\n\n  tuplesRef() {\n    return ref(this.values);\n  },\n\n  extentRef(scope, field) {\n    return cache(scope, this, 'extent', 'extent', field, false);\n  },\n\n  domainRef(scope, field) {\n    return cache(scope, this, 'domain', 'values', field, false);\n  },\n\n  valuesRef(scope, field, sort) {\n    return cache(scope, this, 'vals', 'values', field, sort || true);\n  },\n\n  lookupRef(scope, field) {\n    return cache(scope, this, 'lookup', 'tupleindex', field, false);\n  },\n\n  indataRef(scope, field) {\n    return cache(scope, this, 'indata', 'tupleindex', field, true, true);\n  }\n\n};\n\nfunction parseFacet (spec, scope, group) {\n  const facet = spec.from.facet,\n        name = facet.name,\n        data = getDataRef(facet, scope);\n  let op;\n\n  if (!facet.name) {\n    error('Facet must have a name: ' + stringValue(facet));\n  }\n\n  if (!facet.data) {\n    error('Facet must reference a data set: ' + stringValue(facet));\n  }\n\n  if (facet.field) {\n    op = scope.add(PreFacet({\n      field: scope.fieldRef(facet.field),\n      pulse: data\n    }));\n  } else if (facet.groupby) {\n    op = scope.add(Facet({\n      key: scope.keyRef(facet.groupby),\n      group: ref(scope.proxy(group.parent)),\n      pulse: data\n    }));\n  } else {\n    error('Facet must specify groupby or field: ' + stringValue(facet));\n  } // initialize facet subscope\n\n\n  const subscope = scope.fork(),\n        source = subscope.add(Collect()),\n        values = subscope.add(Sieve({\n    pulse: ref(source)\n  }));\n  subscope.addData(name, new DataScope(subscope, source, source, values));\n  subscope.addSignal('parent', null); // parse faceted subflow\n\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\n\nfunction parseSubflow (spec, scope, input) {\n  const op = scope.add(PreFacet({\n    pulse: input.pulse\n  })),\n        subscope = scope.fork();\n  subscope.add(Sieve());\n  subscope.addSignal('parent', null); // parse group mark subflow\n\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\n\nfunction parseTrigger (spec, scope, name) {\n  const remove = spec.remove,\n        insert = spec.insert,\n        toggle = spec.toggle,\n        modify = spec.modify,\n        values = spec.values,\n        op = scope.add(operator());\n  const update = 'if(' + spec.trigger + ',modify(\"' + name + '\",' + [insert, remove, toggle, modify, values].map(_ => _ == null ? 'null' : _).join(',') + '),0)';\n  const expr = parseExpression(update, scope);\n  op.update = expr.$expr;\n  op.params = expr.$params;\n}\n\nfunction parseMark (spec, scope) {\n  const role = getRole(spec),\n        group = spec.type === GroupMark,\n        facet = spec.from && spec.from.facet,\n        overlap = spec.overlap;\n  let layout = spec.layout || role === ScopeRole || role === FrameRole,\n      ops,\n      op,\n      store,\n      enc,\n      name,\n      layoutRef,\n      boundRef;\n  const nested = role === MarkRole || layout || facet; // resolve input data\n\n  const input = parseData$1(spec.from, group, scope); // data join to map tuples to visual items\n\n  op = scope.add(DataJoin({\n    key: input.key || (spec.key ? fieldRef$1(spec.key) : undefined),\n    pulse: input.pulse,\n    clean: !group\n  }));\n  const joinRef = ref(op); // collect visual items\n\n  op = store = scope.add(Collect({\n    pulse: joinRef\n  })); // connect visual items to scenegraph\n\n  op = scope.add(Mark({\n    markdef: definition(spec),\n    interactive: interactive(spec.interactive, scope),\n    clip: clip(spec.clip, scope),\n    context: {\n      $context: true\n    },\n    groups: scope.lookup(),\n    parent: scope.signals.parent ? scope.signalRef('parent') : null,\n    index: scope.markpath(),\n    pulse: ref(op)\n  }));\n  const markRef = ref(op); // add visual encoders\n\n  op = enc = scope.add(Encode(parseEncode(spec.encode, spec.type, role, spec.style, scope, {\n    mod: false,\n    pulse: markRef\n  }))); // monitor parent marks to propagate changes\n\n  op.params.parent = scope.encode(); // add post-encoding transforms, if defined\n\n  if (spec.transform) {\n    spec.transform.forEach(_ => {\n      const tx = parseTransform(_, scope),\n            md = tx.metadata;\n\n      if (md.generates || md.changes) {\n        error('Mark transforms should not generate new data.');\n      }\n\n      if (!md.nomod) enc.params.mod = true; // update encode mod handling\n\n      tx.params.pulse = ref(op);\n      scope.add(op = tx);\n    });\n  } // if item sort specified, perform post-encoding\n\n\n  if (spec.sort) {\n    op = scope.add(SortItems({\n      sort: scope.compareRef(spec.sort),\n      pulse: ref(op)\n    }));\n  }\n\n  const encodeRef = ref(op); // add view layout operator if needed\n\n  if (facet || layout) {\n    layout = scope.add(ViewLayout({\n      layout: scope.objectProperty(spec.layout),\n      legends: scope.legends,\n      mark: markRef,\n      pulse: encodeRef\n    }));\n    layoutRef = ref(layout);\n  } // compute bounding boxes\n\n\n  const bound = scope.add(Bound({\n    mark: markRef,\n    pulse: layoutRef || encodeRef\n  }));\n  boundRef = ref(bound); // if group mark, recurse to parse nested content\n\n  if (group) {\n    // juggle layout & bounds to ensure they run *after* any faceting transforms\n    if (nested) {\n      ops = scope.operators;\n      ops.pop();\n      if (layout) ops.pop();\n    }\n\n    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);\n    facet ? parseFacet(spec, scope, input) // explicit facet\n    : nested ? parseSubflow(spec, scope, input) // standard mark group\n    : scope.parse(spec); // guide group, we can avoid nested scopes\n\n    scope.popState();\n\n    if (nested) {\n      if (layout) ops.push(layout);\n      ops.push(bound);\n    }\n  } // if requested, add overlap removal transform\n\n\n  if (overlap) {\n    boundRef = parseOverlap(overlap, boundRef, scope);\n  } // render / sieve items\n\n\n  const render = scope.add(Render({\n    pulse: boundRef\n  })),\n        sieve = scope.add(Sieve({\n    pulse: ref(render)\n  }, undefined, scope.parent())); // if mark is named, make accessible as reactive geometry\n  // add trigger updates if defined\n\n  if (spec.name != null) {\n    name = spec.name;\n    scope.addData(name, new DataScope(scope, store, render, sieve));\n    if (spec.on) spec.on.forEach(on => {\n      if (on.insert || on.remove || on.toggle) {\n        error('Marks only support modify triggers.');\n      }\n\n      parseTrigger(on, scope, name);\n    });\n  }\n}\n\nfunction parseOverlap(overlap, source, scope) {\n  const method = overlap.method,\n        bound = overlap.bound,\n        sep = overlap.separation;\n  const params = {\n    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,\n    method: isSignal(method) ? scope.signalRef(method.signal) : method,\n    pulse: source\n  };\n\n  if (overlap.order) {\n    params.sort = scope.compareRef({\n      field: overlap.order\n    });\n  }\n\n  if (bound) {\n    const tol = bound.tolerance;\n    params.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;\n    params.boundScale = scope.scaleRef(bound.scale);\n    params.boundOrient = bound.orient;\n  }\n\n  return ref(scope.add(Overlap(params)));\n}\n\nfunction parseLegend (spec, scope) {\n  const config = scope.config.legend,\n        encode = spec.encode || {},\n        _ = lookup(spec, config),\n        legendEncode = encode.legend || {},\n        name = legendEncode.name || undefined,\n        interactive = legendEncode.interactive,\n        style = legendEncode.style,\n        scales = {};\n\n  let scale = 0,\n      entryLayout,\n      params,\n      children; // resolve scales and 'canonical' scale name\n\n  LegendScales.forEach(s => spec[s] ? (scales[s] = spec[s], scale = scale || spec[s]) : 0);\n  if (!scale) error('Missing valid scale for legend.'); // resolve legend type (symbol, gradient, or discrete gradient)\n\n  const type = legendType(spec, scope.scaleType(scale)); // single-element data source for legend group\n\n  const datum = {\n    title: spec.title != null,\n    scales: scales,\n    type: type,\n    vgrad: type !== 'symbol' && _.isVertical()\n  };\n  const dataRef = ref(scope.add(Collect(null, [datum]))); // encoding properties for legend entry sub-group\n\n  const entryEncode = {\n    enter: {\n      x: {\n        value: 0\n      },\n      y: {\n        value: 0\n      }\n    }\n  }; // data source for legend values\n\n  const entryRef = ref(scope.add(LegendEntries(params = {\n    type: type,\n    scale: scope.scaleRef(scale),\n    count: scope.objectProperty(_('tickCount')),\n    limit: scope.property(_('symbolLimit')),\n    values: scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  }))); // continuous gradient legend\n\n  if (type === Gradient) {\n    children = [legendGradient(spec, scale, config, encode.gradient), legendGradientLabels(spec, config, encode.labels, entryRef)]; // adjust default tick count based on the gradient length\n\n    params.count = params.count || scope.signalRef(`max(2,2*floor((${deref(_.gradientLength())})/100))`);\n  } // discrete gradient legend\n  else if (type === Discrete) {\n    children = [legendGradientDiscrete(spec, scale, config, encode.gradient, entryRef), legendGradientLabels(spec, config, encode.labels, entryRef)];\n  } // symbol legend\n  else {\n    // determine legend symbol group layout\n    entryLayout = legendSymbolLayout(spec, config);\n    children = [legendSymbolGroups(spec, config, encode, entryRef, deref(entryLayout.columns))]; // pass symbol size information to legend entry generator\n\n    params.size = sizeExpression(spec, scope, children[0].marks);\n  } // generate legend marks\n\n\n  children = [guideGroup({\n    role: LegendEntryRole,\n    from: dataRef,\n    encode: entryEncode,\n    marks: children,\n    layout: entryLayout,\n    interactive\n  })]; // include legend title if defined\n\n  if (datum.title) {\n    children.push(legendTitle(spec, config, encode.title, dataRef));\n  } // parse legend specification\n\n\n  return parseMark(guideGroup({\n    role: LegendRole,\n    from: dataRef,\n    encode: extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n}\n\nfunction legendType(spec, scaleType) {\n  let type = spec.type || Symbols;\n\n  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {\n    type = isContinuous(scaleType) ? Gradient : isDiscretizing(scaleType) ? Discrete : Symbols;\n  }\n\n  return type !== Gradient ? type : isDiscretizing(scaleType) ? Discrete : Gradient;\n}\n\nfunction scaleCount(spec) {\n  return LegendScales.reduce((count, type) => count + (spec[type] ? 1 : 0), 0);\n}\n\nfunction buildLegendEncode(_, spec, config) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    offset: _('offset'),\n    padding: _('padding'),\n    titlePadding: _('titlePadding'),\n    cornerRadius: _('cornerRadius'),\n    fill: _('fillColor'),\n    stroke: _('strokeColor'),\n    strokeWidth: config.strokeWidth,\n    strokeDash: config.strokeDash,\n    x: _('legendX'),\n    y: _('legendY'),\n    // accessibility support\n    format: spec.format,\n    formatType: spec.formatType\n  });\n  return encode;\n}\n\nfunction sizeExpression(spec, scope, marks) {\n  const size = deref(getChannel('size', spec, marks)),\n        strokeWidth = deref(getChannel('strokeWidth', spec, marks)),\n        fontSize = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));\n  return parseExpression(`max(ceil(sqrt(${size})+${strokeWidth}),${fontSize})`, scope);\n}\n\nfunction getChannel(name, spec, marks) {\n  return spec[name] ? `scale(\"${spec[name]}\",datum)` : getEncoding(name, marks[0].encode);\n}\n\nfunction getFontSize(encode, scope, style) {\n  return getEncoding('fontSize', encode) || getStyle('fontSize', scope, style);\n}\n\nconst angleExpr = `item.orient===\"${Left}\"?-90:item.orient===\"${Right}\"?90:0`;\nfunction parseTitle (spec, scope) {\n  spec = isString(spec) ? {\n    text: spec\n  } : spec;\n\n  const _ = lookup(spec, scope.config.title),\n        encode = spec.encode || {},\n        userEncode = encode.group || {},\n        name = userEncode.name || undefined,\n        interactive = userEncode.interactive,\n        style = userEncode.style,\n        children = []; // single-element data source for group title\n\n\n  const datum = {},\n        dataRef = ref(scope.add(Collect(null, [datum]))); // include title text\n\n  children.push(buildTitle(spec, _, titleEncode(spec), dataRef)); // include subtitle text\n\n  if (spec.subtitle) {\n    children.push(buildSubTitle(spec, _, encode.subtitle, dataRef));\n  } // parse title specification\n\n\n  return parseMark(guideGroup({\n    role: TitleRole,\n    from: dataRef,\n    encode: groupEncode(_, userEncode),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n} // provide backwards-compatibility for title custom encode;\n// the top-level encode block has been *deprecated*.\n\nfunction titleEncode(spec) {\n  const encode = spec.encode;\n  return encode && encode.title || extend({\n    name: spec.name,\n    interactive: spec.interactive,\n    style: spec.style\n  }, encode);\n}\n\nfunction groupEncode(_, userEncode) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    anchor: _('anchor'),\n    align: {\n      signal: alignExpr$1\n    },\n    angle: {\n      signal: angleExpr\n    },\n    limit: _('limit'),\n    frame: _('frame'),\n    offset: _('offset') || 0,\n    padding: _('subtitlePadding')\n  });\n  return extendEncode(encode, userEncode, Skip);\n}\n\nfunction buildTitle(spec, _, userEncode, dataRef) {\n  const zero = {\n    value: 0\n  },\n        text = spec.text,\n        encode = {\n    enter: {\n      opacity: zero\n    },\n    update: {\n      opacity: {\n        value: 1\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    text: text,\n    align: {\n      signal: 'item.mark.group.align'\n    },\n    angle: {\n      signal: 'item.mark.group.angle'\n    },\n    limit: {\n      signal: 'item.mark.group.limit'\n    },\n    baseline: 'top',\n    dx: _('dx'),\n    dy: _('dy'),\n    fill: _('color'),\n    font: _('font'),\n    fontSize: _('fontSize'),\n    fontStyle: _('fontStyle'),\n    fontWeight: _('fontWeight'),\n    lineHeight: _('lineHeight')\n  }, {\n    // update\n    align: _('align'),\n    angle: _('angle'),\n    baseline: _('baseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: TitleTextRole,\n    style: GroupTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction buildSubTitle(spec, _, userEncode, dataRef) {\n  const zero = {\n    value: 0\n  },\n        text = spec.subtitle,\n        encode = {\n    enter: {\n      opacity: zero\n    },\n    update: {\n      opacity: {\n        value: 1\n      }\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    text: text,\n    align: {\n      signal: 'item.mark.group.align'\n    },\n    angle: {\n      signal: 'item.mark.group.angle'\n    },\n    limit: {\n      signal: 'item.mark.group.limit'\n    },\n    baseline: 'top',\n    dx: _('dx'),\n    dy: _('dy'),\n    fill: _('subtitleColor'),\n    font: _('subtitleFont'),\n    fontSize: _('subtitleFontSize'),\n    fontStyle: _('subtitleFontStyle'),\n    fontWeight: _('subtitleFontWeight'),\n    lineHeight: _('subtitleLineHeight')\n  }, {\n    // update\n    align: _('align'),\n    angle: _('angle'),\n    baseline: _('baseline')\n  });\n  return guideMark({\n    type: TextMark,\n    role: TitleSubtitleRole,\n    style: GroupSubtitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction parseData(data, scope) {\n  const transforms = [];\n\n  if (data.transform) {\n    data.transform.forEach(tx => {\n      transforms.push(parseTransform(tx, scope));\n    });\n  }\n\n  if (data.on) {\n    data.on.forEach(on => {\n      parseTrigger(on, scope, data.name);\n    });\n  }\n\n  scope.addDataPipeline(data.name, analyze(data, scope, transforms));\n}\n/**\n * Analyze a data pipeline, add needed operators.\n */\n\nfunction analyze(data, scope, ops) {\n  const output = [];\n  let source = null,\n      modify = false,\n      generate = false,\n      upstream,\n      i,\n      n,\n      t,\n      m;\n\n  if (data.values) {\n    // hard-wired input data set\n    if (isSignal(data.values) || hasSignal(data.format)) {\n      // if either values is signal or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, ingest upon dataflow init\n      output.push(source = collect({\n        $ingest: data.values,\n        $format: data.format\n      }));\n    }\n  } else if (data.url) {\n    // load data from external source\n    if (hasSignal(data.url) || hasSignal(data.format)) {\n      // if either url or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, request load upon dataflow init\n      output.push(source = collect({\n        $request: data.url,\n        $format: data.format\n      }));\n    }\n  } else if (data.source) {\n    // derives from one or more other data sets\n    source = upstream = array(data.source).map(d => ref(scope.getData(d).output));\n    output.push(null); // populate later\n  } // scan data transforms, add collectors as needed\n\n\n  for (i = 0, n = ops.length; i < n; ++i) {\n    t = ops[i];\n    m = t.metadata;\n\n    if (!source && !m.source) {\n      output.push(source = collect());\n    }\n\n    output.push(t);\n    if (m.generates) generate = true;\n    if (m.modifies && !generate) modify = true;\n    if (m.source) source = t;else if (m.changes) source = null;\n  }\n\n  if (upstream) {\n    n = upstream.length - 1;\n    output[0] = Relay({\n      derive: modify,\n      pulse: n ? upstream : upstream[0]\n    });\n\n    if (modify || n) {\n      // collect derived and multi-pulse tuples\n      output.splice(1, 0, collect());\n    }\n  }\n\n  if (!source) output.push(collect());\n  output.push(Sieve({}));\n  return output;\n}\n\nfunction collect(values) {\n  const s = Collect({}, values);\n  s.metadata = {\n    source: true\n  };\n  return s;\n}\n\nfunction load(scope, data) {\n  return Load({\n    url: data.url ? scope.property(data.url) : undefined,\n    async: data.async ? scope.property(data.async) : undefined,\n    values: data.values ? scope.property(data.values) : undefined,\n    format: scope.objectProperty(data.format)\n  });\n}\n\nconst isX = orient => orient === Bottom || orient === Top; // get sign coefficient based on axis orient\n\n\nconst getSign = (orient, a, b) => isSignal(orient) ? ifLeftTopExpr(orient.signal, a, b) : orient === Left || orient === Top ? a : b; // condition on axis x-direction\n\nconst ifX = (orient, a, b) => isSignal(orient) ? ifXEnc(orient.signal, a, b) : isX(orient) ? a : b; // condition on axis y-direction\n\nconst ifY = (orient, a, b) => isSignal(orient) ? ifYEnc(orient.signal, a, b) : isX(orient) ? b : a;\nconst ifTop = (orient, a, b) => isSignal(orient) ? ifTopExpr(orient.signal, a, b) : orient === Top ? {\n  value: a\n} : {\n  value: b\n};\nconst ifRight = (orient, a, b) => isSignal(orient) ? ifRightExpr(orient.signal, a, b) : orient === Right ? {\n  value: a\n} : {\n  value: b\n};\n\nconst ifXEnc = ($orient, a, b) => ifEnc(`${$orient} === '${Top}' || ${$orient} === '${Bottom}'`, a, b);\n\nconst ifYEnc = ($orient, a, b) => ifEnc(`${$orient} !== '${Top}' && ${$orient} !== '${Bottom}'`, a, b);\n\nconst ifLeftTopExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Left}' || ${$orient} === '${Top}'`, a, b);\n\nconst ifTopExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Top}'`, a, b);\n\nconst ifRightExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Right}'`, a, b);\n\nconst ifEnc = (test, a, b) => {\n  // ensure inputs are encoder objects (or null)\n  a = a != null ? encoder(a) : a;\n  b = b != null ? encoder(b) : b;\n\n  if (isSimple(a) && isSimple(b)) {\n    // if possible generate simple signal expression\n    a = a ? a.signal || stringValue(a.value) : null;\n    b = b ? b.signal || stringValue(b.value) : null;\n    return {\n      signal: `${test} ? (${a}) : (${b})`\n    };\n  } else {\n    // otherwise generate rule set\n    return [extend({\n      test\n    }, a)].concat(b || []);\n  }\n};\n\nconst isSimple = enc => enc == null || Object.keys(enc).length === 1;\n\nconst ifExpr = (test, a, b) => ({\n  signal: `${test} ? (${toExpr(a)}) : (${toExpr(b)})`\n});\n\nconst ifOrient = ($orient, t, b, l, r) => ({\n  signal: (l != null ? `${$orient} === '${Left}' ? (${toExpr(l)}) : ` : '') + (b != null ? `${$orient} === '${Bottom}' ? (${toExpr(b)}) : ` : '') + (r != null ? `${$orient} === '${Right}' ? (${toExpr(r)}) : ` : '') + (t != null ? `${$orient} === '${Top}' ? (${toExpr(t)}) : ` : '') + '(null)'\n});\n\nconst toExpr = v => isSignal(v) ? v.signal : v == null ? null : stringValue(v);\n\nconst mult = (sign, value) => value === 0 ? 0 : isSignal(sign) ? {\n  signal: `(${sign.signal}) * ${value}`\n} : {\n  value: sign * value\n};\nconst patch = (value, base) => {\n  const s = value.signal;\n  return s && s.endsWith('(null)') ? {\n    signal: s.slice(0, -6) + base.signal\n  } : value;\n};\n\nfunction fallback(prop, config, axisConfig, style) {\n  let styleProp;\n\n  if (config && hasOwnProperty(config, prop)) {\n    return config[prop];\n  } else if (hasOwnProperty(axisConfig, prop)) {\n    return axisConfig[prop];\n  } else if (prop.startsWith('title')) {\n    switch (prop) {\n      case 'titleColor':\n        styleProp = 'fill';\n        break;\n\n      case 'titleFont':\n      case 'titleFontSize':\n      case 'titleFontWeight':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n\n    return style[GuideTitleStyle][styleProp];\n  } else if (prop.startsWith('label')) {\n    switch (prop) {\n      case 'labelColor':\n        styleProp = 'fill';\n        break;\n\n      case 'labelFont':\n      case 'labelFontSize':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n\n    return style[GuideLabelStyle][styleProp];\n  }\n\n  return null;\n}\n\nfunction keys(objects) {\n  const map = {};\n\n  for (const obj of objects) {\n    if (!obj) continue;\n\n    for (const key in obj) map[key] = 1;\n  }\n\n  return Object.keys(map);\n}\n\nfunction axisConfig (spec, scope) {\n  var config = scope.config,\n      style = config.style,\n      axis = config.axis,\n      band = scope.scaleType(spec.scale) === 'band' && config.axisBand,\n      orient = spec.orient,\n      xy,\n      or,\n      key;\n\n  if (isSignal(orient)) {\n    const xyKeys = keys([config.axisX, config.axisY]),\n          orientKeys = keys([config.axisTop, config.axisBottom, config.axisLeft, config.axisRight]);\n    xy = {};\n\n    for (key of xyKeys) {\n      xy[key] = ifX(orient, fallback(key, config.axisX, axis, style), fallback(key, config.axisY, axis, style));\n    }\n\n    or = {};\n\n    for (key of orientKeys) {\n      or[key] = ifOrient(orient.signal, fallback(key, config.axisTop, axis, style), fallback(key, config.axisBottom, axis, style), fallback(key, config.axisLeft, axis, style), fallback(key, config.axisRight, axis, style));\n    }\n  } else {\n    xy = orient === Top || orient === Bottom ? config.axisX : config.axisY;\n    or = config['axis' + orient[0].toUpperCase() + orient.slice(1)];\n  }\n\n  const result = xy || or || band ? extend({}, axis, xy, or, band) : axis;\n  return result;\n}\n\nfunction axisDomain (spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        orient = spec.orient;\n\n  let enter, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('domainColor'),\n    strokeCap: _('domainCap'),\n    strokeDash: _('domainDash'),\n    strokeDashOffset: _('domainDashOffset'),\n    strokeWidth: _('domainWidth'),\n    strokeOpacity: _('domainOpacity')\n  });\n  const pos0 = position(spec, 0);\n  const pos1 = position(spec, 1);\n  enter.x = update.x = ifX(orient, pos0, zero);\n  enter.x2 = update.x2 = ifX(orient, pos1);\n  enter.y = update.y = ifY(orient, pos0, zero);\n  enter.y2 = update.y2 = ifY(orient, pos1);\n  return guideMark({\n    type: RuleMark,\n    role: AxisDomainRole,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction position(spec, pos) {\n  return {\n    scale: spec.scale,\n    range: pos\n  };\n}\n\nfunction axisGrid (spec, config, userEncode, dataRef, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        vscale = spec.gridScale,\n        sign = getSign(orient, 1, -1),\n        offset = offsetValue(spec.offset, sign);\n\n  let enter, exit, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: exit = {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('gridColor'),\n    strokeCap: _('gridCap'),\n    strokeDash: _('gridDash'),\n    strokeDashOffset: _('gridDashOffset'),\n    strokeOpacity: _('gridOpacity'),\n    strokeWidth: _('gridWidth')\n  });\n  const tickPos = {\n    scale: spec.scale,\n    field: Value,\n    band: band.band,\n    extra: band.extra,\n    offset: band.offset,\n    round: _('tickRound')\n  };\n  const sz = ifX(orient, {\n    signal: 'height'\n  }, {\n    signal: 'width'\n  });\n  const gridStart = vscale ? {\n    scale: vscale,\n    range: 0,\n    mult: sign,\n    offset: offset\n  } : {\n    value: 0,\n    offset: offset\n  };\n  const gridEnd = vscale ? {\n    scale: vscale,\n    range: 1,\n    mult: sign,\n    offset: offset\n  } : extend(sz, {\n    mult: sign,\n    offset: offset\n  });\n  enter.x = update.x = ifX(orient, tickPos, gridStart);\n  enter.y = update.y = ifY(orient, tickPos, gridStart);\n  enter.x2 = update.x2 = ifY(orient, gridEnd);\n  enter.y2 = update.y2 = ifX(orient, gridEnd);\n  exit.x = ifX(orient, tickPos);\n  exit.y = ifY(orient, tickPos);\n  return guideMark({\n    type: RuleMark,\n    role: AxisGridRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction offsetValue(offset, sign) {\n  if (sign === 1) ; else if (!isObject(offset)) {\n    offset = isSignal(sign) ? {\n      signal: `(${sign.signal}) * (${offset || 0})`\n    } : sign * (offset || 0);\n  } else {\n    let entry = offset = extend({}, offset);\n\n    while (entry.mult != null) {\n      if (!isObject(entry.mult)) {\n        entry.mult = isSignal(sign) // no offset if sign === 1\n        ? {\n          signal: `(${entry.mult}) * (${sign.signal})`\n        } : entry.mult * sign;\n        return offset;\n      } else {\n        entry = entry.mult = extend({}, entry.mult);\n      }\n    }\n\n    entry.mult = sign;\n  }\n\n  return offset;\n}\n\nfunction axisTicks (spec, config, userEncode, dataRef, size, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        sign = getSign(orient, -1, 1);\n\n  let enter, exit, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one\n    },\n    exit: exit = {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    stroke: _('tickColor'),\n    strokeCap: _('tickCap'),\n    strokeDash: _('tickDash'),\n    strokeDashOffset: _('tickDashOffset'),\n    strokeOpacity: _('tickOpacity'),\n    strokeWidth: _('tickWidth')\n  });\n  const tickSize = encoder(size);\n  tickSize.mult = sign;\n  const tickPos = {\n    scale: spec.scale,\n    field: Value,\n    band: band.band,\n    extra: band.extra,\n    offset: band.offset,\n    round: _('tickRound')\n  };\n  update.y = enter.y = ifX(orient, zero, tickPos);\n  update.y2 = enter.y2 = ifX(orient, tickSize);\n  exit.x = ifX(orient, tickPos);\n  update.x = enter.x = ifY(orient, zero, tickPos);\n  update.x2 = enter.x2 = ifY(orient, tickSize);\n  exit.y = ifY(orient, tickPos);\n  return guideMark({\n    type: RuleMark,\n    role: AxisTickRole,\n    key: Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction flushExpr(scale, threshold, a, b, c) {\n  return {\n    signal: 'flush(range(\"' + scale + '\"), ' + 'scale(\"' + scale + '\", datum.value), ' + threshold + ',' + a + ',' + b + ',' + c + ')'\n  };\n}\n\nfunction axisLabels (spec, config, userEncode, dataRef, size, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        scale = spec.scale,\n        sign = getSign(orient, -1, 1),\n        flush = deref(_('labelFlush')),\n        flushOffset = deref(_('labelFlushOffset')),\n        labelAlign = _('labelAlign'),\n        labelBaseline = _('labelBaseline');\n\n  let flushOn = flush === 0 || !!flush,\n      update;\n  const tickSize = encoder(size);\n  tickSize.mult = sign;\n  tickSize.offset = encoder(_('labelPadding') || 0);\n  tickSize.offset.mult = sign;\n  const tickPos = {\n    scale: scale,\n    field: Value,\n    band: 0.5,\n    offset: extendOffset(band.offset, _('labelOffset'))\n  };\n  const align = ifX(orient, flushOn ? flushExpr(scale, flush, '\"left\"', '\"right\"', '\"center\"') : {\n    value: 'center'\n  }, ifRight(orient, 'left', 'right'));\n  const baseline = ifX(orient, ifTop(orient, 'bottom', 'top'), flushOn ? flushExpr(scale, flush, '\"top\"', '\"bottom\"', '\"middle\"') : {\n    value: 'middle'\n  });\n  const offsetExpr = flushExpr(scale, flush, `-(${flushOffset})`, flushOffset, 0);\n  flushOn = flushOn && flushOffset;\n  const enter = {\n    opacity: zero,\n    x: ifX(orient, tickPos, tickSize),\n    y: ifY(orient, tickPos, tickSize)\n  };\n  const encode = {\n    enter: enter,\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      },\n      x: enter.x,\n      y: enter.y,\n      align,\n      baseline\n    },\n    exit: {\n      opacity: zero,\n      x: enter.x,\n      y: enter.y\n    }\n  };\n  addEncoders(encode, {\n    dx: !labelAlign && flushOn ? ifX(orient, offsetExpr) : null,\n    dy: !labelBaseline && flushOn ? ifY(orient, offsetExpr) : null\n  });\n  addEncoders(encode, {\n    angle: _('labelAngle'),\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontWeight: _('labelFontWeight'),\n    fontStyle: _('labelFontStyle'),\n    limit: _('labelLimit'),\n    lineHeight: _('labelLineHeight')\n  }, {\n    align: labelAlign,\n    baseline: labelBaseline\n  });\n\n  const bound = _('labelBound');\n\n  let overlap = _('labelOverlap'); // if overlap method or bound defined, request label overlap removal\n\n\n  overlap = overlap || bound ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.index',\n    bound: bound ? {\n      scale,\n      orient,\n      tolerance: bound\n    } : null\n  } : undefined;\n\n  if (update.align !== align) {\n    update.align = patch(update.align, align);\n  }\n\n  if (update.baseline !== baseline) {\n    update.baseline = patch(update.baseline, baseline);\n  }\n\n  return guideMark({\n    type: TextMark,\n    role: AxisLabelRole,\n    style: GuideLabelStyle,\n    key: Value,\n    from: dataRef,\n    encode,\n    overlap\n  }, userEncode);\n}\n\nfunction axisTitle (spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        sign = getSign(orient, -1, 1);\n\n  let enter, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero,\n      anchor: encoder(_('titleAnchor', null)),\n      align: {\n        signal: alignExpr$1\n      }\n    },\n    update: update = extend({}, enter, {\n      opacity: one,\n      text: encoder(spec.title)\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  const titlePos = {\n    signal: `lerp(range(\"${spec.scale}\"), ${anchorExpr(0, 1, 0.5)})`\n  };\n  update.x = ifX(orient, titlePos);\n  update.y = ifY(orient, titlePos);\n  enter.angle = ifX(orient, zero, mult(sign, 90));\n  enter.baseline = ifX(orient, ifTop(orient, Bottom, Top), {\n    value: Bottom\n  });\n  update.angle = enter.angle;\n  update.baseline = enter.baseline;\n  addEncoders(encode, {\n    fill: _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font: _('titleFont'),\n    fontSize: _('titleFontSize'),\n    fontStyle: _('titleFontStyle'),\n    fontWeight: _('titleFontWeight'),\n    limit: _('titleLimit'),\n    lineHeight: _('titleLineHeight')\n  }, {\n    // require update\n    align: _('titleAlign'),\n    angle: _('titleAngle'),\n    baseline: _('titleBaseline')\n  });\n  autoLayout(_, orient, encode, userEncode);\n  encode.update.align = patch(encode.update.align, enter.align);\n  encode.update.angle = patch(encode.update.angle, enter.angle);\n  encode.update.baseline = patch(encode.update.baseline, enter.baseline);\n  return guideMark({\n    type: TextMark,\n    role: AxisTitleRole,\n    style: GuideTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction autoLayout(_, orient, encode, userEncode) {\n  const auto = (value, dim) => value != null ? (encode.update[dim] = patch(encoder(value), encode.update[dim]), false) : !has(dim, userEncode) ? true : false;\n\n  const autoY = auto(_('titleX'), 'x'),\n        autoX = auto(_('titleY'), 'y');\n  encode.enter.auto = autoX === autoY ? encoder(autoX) : ifX(orient, encoder(autoX), encoder(autoY));\n}\n\nfunction parseAxis (spec, scope) {\n  const config = axisConfig(spec, scope),\n        encode = spec.encode || {},\n        axisEncode = encode.axis || {},\n        name = axisEncode.name || undefined,\n        interactive = axisEncode.interactive,\n        style = axisEncode.style,\n        _ = lookup(spec, config),\n        band = tickBand(_); // single-element data source for axis group\n\n\n  const datum = {\n    scale: spec.scale,\n    ticks: !!_('ticks'),\n    labels: !!_('labels'),\n    grid: !!_('grid'),\n    domain: !!_('domain'),\n    title: spec.title != null\n  };\n  const dataRef = ref(scope.add(Collect({}, [datum]))); // data source for axis ticks\n\n  const ticksRef = ref(scope.add(AxisTicks({\n    scale: scope.scaleRef(spec.scale),\n    extra: scope.property(band.extra),\n    count: scope.objectProperty(spec.tickCount),\n    values: scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  }))); // generate axis marks\n\n  const children = [];\n  let size; // include axis gridlines if requested\n\n  if (datum.grid) {\n    children.push(axisGrid(spec, config, encode.grid, ticksRef, band));\n  } // include axis ticks if requested\n\n\n  if (datum.ticks) {\n    size = _('tickSize');\n    children.push(axisTicks(spec, config, encode.ticks, ticksRef, size, band));\n  } // include axis labels if requested\n\n\n  if (datum.labels) {\n    size = datum.ticks ? size : 0;\n    children.push(axisLabels(spec, config, encode.labels, ticksRef, size, band));\n  } // include axis domain path if requested\n\n\n  if (datum.domain) {\n    children.push(axisDomain(spec, config, encode.domain, dataRef));\n  } // include axis title if defined\n\n\n  if (datum.title) {\n    children.push(axisTitle(spec, config, encode.title, dataRef));\n  } // parse axis specification\n\n\n  return parseMark(guideGroup({\n    role: AxisRole,\n    from: dataRef,\n    encode: extendEncode(buildAxisEncode(_, spec), axisEncode, Skip),\n    marks: children,\n    aria: _('aria'),\n    description: _('description'),\n    zindex: _('zindex'),\n    name,\n    interactive,\n    style\n  }), scope);\n}\n\nfunction buildAxisEncode(_, spec) {\n  const encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    offset: _('offset') || 0,\n    position: value(spec.position, 0),\n    titlePadding: _('titlePadding'),\n    minExtent: _('minExtent'),\n    maxExtent: _('maxExtent'),\n    range: {\n      signal: `abs(span(range(\"${spec.scale}\")))`\n    },\n    translate: _('translate'),\n    // accessibility support\n    format: spec.format,\n    formatType: spec.formatType\n  });\n  return encode;\n}\n\nfunction parseScope (spec, scope, preprocessed) {\n  const signals = array(spec.signals),\n        scales = array(spec.scales); // parse signal definitions, if not already preprocessed\n\n  if (!preprocessed) signals.forEach(_ => parseSignal(_, scope)); // parse cartographic projection definitions\n\n  array(spec.projections).forEach(_ => parseProjection(_, scope)); // initialize scale references\n\n  scales.forEach(_ => initScale(_, scope)); // parse data sources\n\n  array(spec.data).forEach(_ => parseData(_, scope)); // parse scale definitions\n\n  scales.forEach(_ => parseScale(_, scope)); // parse signal updates\n\n  (preprocessed || signals).forEach(_ => parseSignalUpdates(_, scope)); // parse axis definitions\n\n  array(spec.axes).forEach(_ => parseAxis(_, scope)); // parse mark definitions\n\n  array(spec.marks).forEach(_ => parseMark(_, scope)); // parse legend definitions\n\n  array(spec.legends).forEach(_ => parseLegend(_, scope)); // parse title, if defined\n\n  if (spec.title) parseTitle(spec.title, scope); // parse collected lambda (anonymous) expressions\n\n  scope.parseLambdas();\n  return scope;\n}\n\nconst rootEncode = spec => extendEncode({\n  enter: {\n    x: {\n      value: 0\n    },\n    y: {\n      value: 0\n    }\n  },\n  update: {\n    width: {\n      signal: 'width'\n    },\n    height: {\n      signal: 'height'\n    }\n  }\n}, spec);\n\nfunction parseView(spec, scope) {\n  const config = scope.config; // add scenegraph root\n\n  const root = ref(scope.root = scope.add(operator())); // parse top-level signal definitions\n\n  const signals = collectSignals(spec, config);\n  signals.forEach(_ => parseSignal(_, scope)); // assign description, event, legend, and locale configuration\n\n  scope.description = spec.description || config.description;\n  scope.eventConfig = config.events;\n  scope.legends = scope.objectProperty(config.legend && config.legend.layout);\n  scope.locale = config.locale; // store root group item\n\n  const input = scope.add(Collect()); // encode root group item\n\n  const encode = scope.add(Encode(parseEncode(rootEncode(spec.encode), GroupMark, FrameRole, spec.style, scope, {\n    pulse: ref(input)\n  }))); // perform view layout\n\n  const parent = scope.add(ViewLayout({\n    layout: scope.objectProperty(spec.layout),\n    legends: scope.legends,\n    autosize: scope.signalRef('autosize'),\n    mark: root,\n    pulse: ref(encode)\n  }));\n  scope.operators.pop(); // parse remainder of specification\n\n  scope.pushState(ref(encode), ref(parent), null);\n  parseScope(spec, scope, signals);\n  scope.operators.push(parent); // bound / render / sieve root item\n\n  let op = scope.add(Bound({\n    mark: root,\n    pulse: ref(parent)\n  }));\n  op = scope.add(Render({\n    pulse: ref(op)\n  }));\n  op = scope.add(Sieve({\n    pulse: ref(op)\n  })); // track metadata for root item\n\n  scope.addData('root', new DataScope(scope, input, input, op));\n  return scope;\n}\n\nfunction signalObject(name, value) {\n  return value && value.signal ? {\n    name,\n    update: value.signal\n  } : {\n    name,\n    value\n  };\n}\n/**\n * Collect top-level signals, merging values as needed. Signals\n * defined in the config signals arrays are added only if that\n * signal is not explicitly defined in the specification.\n * Built-in signals (autosize, background, padding, width, height)\n * receive special treatment. They are initialized using the\n * top-level spec property, or, if undefined in the spec, using\n * the corresponding top-level config property. If this property\n * is a signal reference object, the signal expression maps to the\n * signal 'update' property. If the spec's top-level signal array\n * contains an entry that matches a built-in signal, that entry\n * will be merged with the built-in specification, potentially\n * overwriting existing 'value' or 'update' properties.\n */\n\n\nfunction collectSignals(spec, config) {\n  const _ = name => value(spec[name], config[name]),\n        signals = [signalObject('background', _('background')), signalObject('autosize', parseAutosize(_('autosize'))), signalObject('padding', parsePadding(_('padding'))), signalObject('width', _('width') || 0), signalObject('height', _('height') || 0)],\n        pre = signals.reduce((p, s) => (p[s.name] = s, p), {}),\n        map = {}; // add spec signal array\n\n\n  array(spec.signals).forEach(s => {\n    if (hasOwnProperty(pre, s.name)) {\n      // merge if built-in signal\n      s = extend(pre[s.name], s);\n    } else {\n      // otherwise add to signal list\n      signals.push(s);\n    }\n\n    map[s.name] = s;\n  }); // add config signal array\n\n  array(config.signals).forEach(s => {\n    if (!hasOwnProperty(map, s.name) && !hasOwnProperty(pre, s.name)) {\n      // add to signal list if not already defined\n      signals.push(s);\n    }\n  });\n  return signals;\n}\n\nfunction Scope(config, options) {\n  this.config = config || {};\n  this.options = options || {};\n  this.bindings = [];\n  this.field = {};\n  this.signals = {};\n  this.lambdas = {};\n  this.scales = {};\n  this.events = {};\n  this.data = {};\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this.eventConfig = null;\n  this.locale = null;\n  this._id = 0;\n  this._subid = 0;\n  this._nextsub = [0];\n  this._parent = [];\n  this._encode = [];\n  this._lookup = [];\n  this._markpath = [];\n}\n\nfunction Subscope(scope) {\n  this.config = scope.config;\n  this.options = scope.options;\n  this.legends = scope.legends;\n  this.field = Object.create(scope.field);\n  this.signals = Object.create(scope.signals);\n  this.lambdas = Object.create(scope.lambdas);\n  this.scales = Object.create(scope.scales);\n  this.events = Object.create(scope.events);\n  this.data = Object.create(scope.data);\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this._id = 0;\n  this._subid = ++scope._nextsub[0];\n  this._nextsub = scope._nextsub;\n  this._parent = scope._parent.slice();\n  this._encode = scope._encode.slice();\n  this._lookup = scope._lookup.slice();\n  this._markpath = scope._markpath;\n}\n\nScope.prototype = Subscope.prototype = {\n  parse(spec) {\n    return parseScope(spec, this);\n  },\n\n  fork() {\n    return new Subscope(this);\n  },\n\n  isSubscope() {\n    return this._subid > 0;\n  },\n\n  toRuntime() {\n    this.finish();\n    return {\n      description: this.description,\n      operators: this.operators,\n      streams: this.streams,\n      updates: this.updates,\n      bindings: this.bindings,\n      eventConfig: this.eventConfig,\n      locale: this.locale\n    };\n  },\n\n  id() {\n    return (this._subid ? this._subid + ':' : 0) + this._id++;\n  },\n\n  add(op) {\n    this.operators.push(op);\n    op.id = this.id(); // if pre-registration references exist, resolve them now\n\n    if (op.refs) {\n      op.refs.forEach(ref => {\n        ref.$ref = op.id;\n      });\n      op.refs = null;\n    }\n\n    return op;\n  },\n\n  proxy(op) {\n    const vref = op instanceof Entry ? ref(op) : op;\n    return this.add(Proxy({\n      value: vref\n    }));\n  },\n\n  addStream(stream) {\n    this.streams.push(stream);\n    stream.id = this.id();\n    return stream;\n  },\n\n  addUpdate(update) {\n    this.updates.push(update);\n    return update;\n  },\n\n  // Apply metadata\n  finish() {\n    let name, ds; // annotate root\n\n    if (this.root) this.root.root = true; // annotate signals\n\n    for (name in this.signals) {\n      this.signals[name].signal = name;\n    } // annotate scales\n\n\n    for (name in this.scales) {\n      this.scales[name].scale = name;\n    } // annotate data sets\n\n\n    function annotate(op, name, type) {\n      let data, list;\n\n      if (op) {\n        data = op.data || (op.data = {});\n        list = data[name] || (data[name] = []);\n        list.push(type);\n      }\n    }\n\n    for (name in this.data) {\n      ds = this.data[name];\n      annotate(ds.input, name, 'input');\n      annotate(ds.output, name, 'output');\n      annotate(ds.values, name, 'values');\n\n      for (const field in ds.index) {\n        annotate(ds.index[field], name, 'index:' + field);\n      }\n    }\n\n    return this;\n  },\n\n  // ----\n  pushState(encode, parent, lookup) {\n    this._encode.push(ref(this.add(Sieve({\n      pulse: encode\n    }))));\n\n    this._parent.push(parent);\n\n    this._lookup.push(lookup ? ref(this.proxy(lookup)) : null);\n\n    this._markpath.push(-1);\n  },\n\n  popState() {\n    this._encode.pop();\n\n    this._parent.pop();\n\n    this._lookup.pop();\n\n    this._markpath.pop();\n  },\n\n  parent() {\n    return peek(this._parent);\n  },\n\n  encode() {\n    return peek(this._encode);\n  },\n\n  lookup() {\n    return peek(this._lookup);\n  },\n\n  markpath() {\n    const p = this._markpath;\n    return ++p[p.length - 1];\n  },\n\n  // ----\n  fieldRef(field, name) {\n    if (isString(field)) return fieldRef$1(field, name);\n\n    if (!field.signal) {\n      error('Unsupported field reference: ' + stringValue(field));\n    }\n\n    const s = field.signal;\n    let f = this.field[s];\n\n    if (!f) {\n      const params = {\n        name: this.signalRef(s)\n      };\n      if (name) params.as = name;\n      this.field[s] = f = ref(this.add(Field(params)));\n    }\n\n    return f;\n  },\n\n  compareRef(cmp) {\n    let signal = false;\n\n    const check = _ => isSignal(_) ? (signal = true, this.signalRef(_.signal)) : isExpr$1(_) ? (signal = true, this.exprRef(_.expr)) : _;\n\n    const fields = array(cmp.field).map(check),\n          orders = array(cmp.order).map(check);\n    return signal ? ref(this.add(Compare({\n      fields: fields,\n      orders: orders\n    }))) : compareRef(fields, orders);\n  },\n\n  keyRef(fields, flat) {\n    let signal = false;\n\n    const check = _ => isSignal(_) ? (signal = true, ref(sig[_.signal])) : _;\n\n    const sig = this.signals;\n    fields = array(fields).map(check);\n    return signal ? ref(this.add(Key({\n      fields: fields,\n      flat: flat\n    }))) : keyRef(fields, flat);\n  },\n\n  sortRef(sort) {\n    if (!sort) return sort; // including id ensures stable sorting\n\n    const a = aggrField(sort.op, sort.field),\n          o = sort.order || Ascending;\n    return o.signal ? ref(this.add(Compare({\n      fields: a,\n      orders: this.signalRef(o.signal)\n    }))) : compareRef(a, o);\n  },\n\n  // ----\n  event(source, type) {\n    const key = source + ':' + type;\n\n    if (!this.events[key]) {\n      const id = this.id();\n      this.streams.push({\n        id: id,\n        source: source,\n        type: type\n      });\n      this.events[key] = id;\n    }\n\n    return this.events[key];\n  },\n\n  // ----\n  hasOwnSignal(name) {\n    return hasOwnProperty(this.signals, name);\n  },\n\n  addSignal(name, value) {\n    if (this.hasOwnSignal(name)) {\n      error('Duplicate signal name: ' + stringValue(name));\n    }\n\n    const op = value instanceof Entry ? value : this.add(operator(value));\n    return this.signals[name] = op;\n  },\n\n  getSignal(name) {\n    if (!this.signals[name]) {\n      error('Unrecognized signal name: ' + stringValue(name));\n    }\n\n    return this.signals[name];\n  },\n\n  signalRef(s) {\n    if (this.signals[s]) {\n      return ref(this.signals[s]);\n    } else if (!hasOwnProperty(this.lambdas, s)) {\n      this.lambdas[s] = this.add(operator(null));\n    }\n\n    return ref(this.lambdas[s]);\n  },\n\n  parseLambdas() {\n    const code = Object.keys(this.lambdas);\n\n    for (let i = 0, n = code.length; i < n; ++i) {\n      const s = code[i],\n            e = parseExpression(s, this),\n            op = this.lambdas[s];\n      op.params = e.$params;\n      op.update = e.$expr;\n    }\n  },\n\n  property(spec) {\n    return spec && spec.signal ? this.signalRef(spec.signal) : spec;\n  },\n\n  objectProperty(spec) {\n    return !spec || !isObject(spec) ? spec : this.signalRef(spec.signal || propertyLambda(spec));\n  },\n\n  exprRef(code, name) {\n    const params = {\n      expr: parseExpression(code, this)\n    };\n    if (name) params.expr.$name = name;\n    return ref(this.add(Expression(params)));\n  },\n\n  addBinding(name, bind) {\n    if (!this.bindings) {\n      error('Nested signals do not support binding: ' + stringValue(name));\n    }\n\n    this.bindings.push(extend({\n      signal: name\n    }, bind));\n  },\n\n  // ----\n  addScaleProj(name, transform) {\n    if (hasOwnProperty(this.scales, name)) {\n      error('Duplicate scale or projection name: ' + stringValue(name));\n    }\n\n    this.scales[name] = this.add(transform);\n  },\n\n  addScale(name, params) {\n    this.addScaleProj(name, Scale(params));\n  },\n\n  addProjection(name, params) {\n    this.addScaleProj(name, Projection(params));\n  },\n\n  getScale(name) {\n    if (!this.scales[name]) {\n      error('Unrecognized scale name: ' + stringValue(name));\n    }\n\n    return this.scales[name];\n  },\n\n  scaleRef(name) {\n    return ref(this.getScale(name));\n  },\n\n  scaleType(name) {\n    return this.getScale(name).params.type;\n  },\n\n  projectionRef(name) {\n    return this.scaleRef(name);\n  },\n\n  projectionType(name) {\n    return this.scaleType(name);\n  },\n\n  // ----\n  addData(name, dataScope) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n\n    return this.data[name] = dataScope;\n  },\n\n  getData(name) {\n    if (!this.data[name]) {\n      error('Undefined data set name: ' + stringValue(name));\n    }\n\n    return this.data[name];\n  },\n\n  addDataPipeline(name, entries) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n\n    return this.addData(name, DataScope.fromEntries(this, entries));\n  }\n\n};\n\nfunction propertyLambda(spec) {\n  return (isArray(spec) ? arrayLambda : objectLambda)(spec);\n}\n\nfunction arrayLambda(array) {\n  const n = array.length;\n  let code = '[';\n\n  for (let i = 0; i < n; ++i) {\n    const value = array[i];\n    code += (i > 0 ? ',' : '') + (isObject(value) ? value.signal || propertyLambda(value) : stringValue(value));\n  }\n\n  return code + ']';\n}\n\nfunction objectLambda(obj) {\n  let code = '{',\n      i = 0,\n      key,\n      value;\n\n  for (key in obj) {\n    value = obj[key];\n    code += (++i > 1 ? ',' : '') + stringValue(key) + ':' + (isObject(value) ? value.signal || propertyLambda(value) : stringValue(value));\n  }\n\n  return code + '}';\n}\n\n/**\n * Standard configuration defaults for Vega specification parsing.\n * Users can provide their own (sub-)set of these default values\n * by passing in a config object to the top-level parse method.\n */\nfunction defaults () {\n  const defaultFont = 'sans-serif',\n        defaultSymbolSize = 30,\n        defaultStrokeWidth = 2,\n        defaultColor = '#4c78a8',\n        black = '#000',\n        gray = '#888',\n        lightGray = '#ddd';\n  return {\n    // default visualization description\n    description: 'Vega visualization',\n    // default padding around visualization\n    padding: 0,\n    // default for automatic sizing; options: 'none', 'pad', 'fit'\n    // or provide an object (e.g., {'type': 'pad', 'resize': true})\n    autosize: 'pad',\n    // default view background color\n    // covers the entire view component\n    background: null,\n    // default event handling configuration\n    // preventDefault for view-sourced event types except 'wheel'\n    events: {\n      defaults: {\n        allow: ['wheel']\n      }\n    },\n    // defaults for top-level group marks\n    // accepts mark properties (fill, stroke, etc)\n    // covers the data rectangle within group width/height\n    group: null,\n    // defaults for basic mark types\n    // each subset accepts mark properties (fill, stroke, etc)\n    mark: null,\n    arc: {\n      fill: defaultColor\n    },\n    area: {\n      fill: defaultColor\n    },\n    image: null,\n    line: {\n      stroke: defaultColor,\n      strokeWidth: defaultStrokeWidth\n    },\n    path: {\n      stroke: defaultColor\n    },\n    rect: {\n      fill: defaultColor\n    },\n    rule: {\n      stroke: black\n    },\n    shape: {\n      stroke: defaultColor\n    },\n    symbol: {\n      fill: defaultColor,\n      size: 64\n    },\n    text: {\n      fill: black,\n      font: defaultFont,\n      fontSize: 11\n    },\n    trail: {\n      fill: defaultColor,\n      size: defaultStrokeWidth\n    },\n    // style definitions\n    style: {\n      // axis & legend labels\n      'guide-label': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 10\n      },\n      // axis & legend titles\n      'guide-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 11,\n        fontWeight: 'bold'\n      },\n      // headers, including chart title\n      'group-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 13,\n        fontWeight: 'bold'\n      },\n      // chart subtitle\n      'group-subtitle': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 12\n      },\n      // defaults for styled point marks in Vega-Lite\n      point: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'circle'\n      },\n      circle: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth\n      },\n      square: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'square'\n      },\n      // defaults for styled group marks in Vega-Lite\n      cell: {\n        fill: 'transparent',\n        stroke: lightGray\n      }\n    },\n    // defaults for title\n    title: {\n      orient: 'top',\n      anchor: 'middle',\n      offset: 4,\n      subtitlePadding: 3\n    },\n    // defaults for axes\n    axis: {\n      minExtent: 0,\n      maxExtent: 200,\n      bandPosition: 0.5,\n      domain: true,\n      domainWidth: 1,\n      domainColor: gray,\n      grid: false,\n      gridWidth: 1,\n      gridColor: lightGray,\n      labels: true,\n      labelAngle: 0,\n      labelLimit: 180,\n      labelOffset: 0,\n      labelPadding: 2,\n      ticks: true,\n      tickColor: gray,\n      tickOffset: 0,\n      tickRound: true,\n      tickSize: 5,\n      tickWidth: 1,\n      titlePadding: 4\n    },\n    // correction for centering bias\n    axisBand: {\n      tickOffset: -0.5\n    },\n    // defaults for cartographic projection\n    projection: {\n      type: 'mercator'\n    },\n    // defaults for legends\n    legend: {\n      orient: 'right',\n      padding: 0,\n      gridAlign: 'each',\n      columnPadding: 10,\n      rowPadding: 2,\n      symbolDirection: 'vertical',\n      gradientDirection: 'vertical',\n      gradientLength: 200,\n      gradientThickness: 16,\n      gradientStrokeColor: lightGray,\n      gradientStrokeWidth: 0,\n      gradientLabelOffset: 2,\n      labelAlign: 'left',\n      labelBaseline: 'middle',\n      labelLimit: 160,\n      labelOffset: 4,\n      labelOverlap: true,\n      symbolLimit: 30,\n      symbolType: 'circle',\n      symbolSize: 100,\n      symbolOffset: 0,\n      symbolStrokeWidth: 1.5,\n      symbolBaseFillColor: 'transparent',\n      symbolBaseStrokeColor: gray,\n      titleLimit: 180,\n      titleOrient: 'top',\n      titlePadding: 5,\n      layout: {\n        offset: 18,\n        direction: 'horizontal',\n        left: {\n          direction: 'vertical'\n        },\n        right: {\n          direction: 'vertical'\n        }\n      }\n    },\n    // defaults for scale ranges\n    range: {\n      category: {\n        scheme: 'tableau10'\n      },\n      ordinal: {\n        scheme: 'blues'\n      },\n      heatmap: {\n        scheme: 'yellowgreenblue'\n      },\n      ramp: {\n        scheme: 'blues'\n      },\n      diverging: {\n        scheme: 'blueorange',\n        extent: [1, 0]\n      },\n      symbol: ['circle', 'square', 'triangle-up', 'cross', 'diamond', 'triangle-right', 'triangle-down', 'triangle-left']\n    }\n  };\n}\n\nfunction parse (spec, config, options) {\n  if (!isObject(spec)) {\n    error('Input Vega specification must be an object.');\n  }\n\n  config = mergeConfig(defaults(), config, spec.config);\n  return parseView(spec, new Scope(config, options)).toRuntime();\n}\n\nexport { AxisDomainRole, AxisGridRole, AxisLabelRole, AxisRole, AxisTickRole, AxisTitleRole, DataScope, FrameRole, LegendEntryRole, LegendLabelRole, LegendRole, LegendSymbolRole, LegendTitleRole, MarkRole, Scope, ScopeRole, defaults as config, parse, parseSignal as signal, parseSignalUpdates as signalUpdates, parseStream as stream };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}