{"ast":null,"code":"import _classCallCheck from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { isScaleFieldDef, vgField } from '../../channeldef';\nimport { fieldFilterExpression } from '../../predicate';\nimport { isSortArray } from '../../sort';\nimport { duplicate, hash as _hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nimport { getDependentFields } from './expressions';\nexport var CalculateNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(CalculateNode, _DataFlowNode);\n  var _super = _createSuper(CalculateNode);\n  function CalculateNode(parent, transform) {\n    var _this;\n    _classCallCheck(this, CalculateNode);\n    _this = _super.call(this, parent);\n    _this.transform = transform;\n    _this._dependentFields = getDependentFields(_this.transform.calculate);\n    return _this;\n  }\n  _createClass(CalculateNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new CalculateNode(null, duplicate(this.transform));\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set([this.transform.as]);\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return this._dependentFields;\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      return {\n        type: 'formula',\n        expr: this.transform.calculate,\n        as: this.transform.as\n      };\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"Calculate \".concat(_hash(this.transform));\n    }\n  }], [{\n    key: \"parseAllForSortIndex\",\n    value: function parseAllForSortIndex(parent, model) {\n      // get all the encoding with sort fields from model\n      model.forEachFieldDef(function (fieldDef, channel) {\n        if (!isScaleFieldDef(fieldDef)) {\n          return;\n        }\n        if (isSortArray(fieldDef.sort)) {\n          var field = fieldDef.field,\n            timeUnit = fieldDef.timeUnit;\n          var sort = fieldDef.sort;\n          // generate `datum[\"a\"] === val0 ? 0 : datum[\"a\"] === val1 ? 1 : ... : n` via FieldEqualPredicate\n          var calculate = sort.map(function (sortValue, i) {\n            return \"\".concat(fieldFilterExpression({\n              field: field,\n              timeUnit: timeUnit,\n              equal: sortValue\n            }), \" ? \").concat(i, \" : \");\n          }).join('') + sort.length;\n          parent = new CalculateNode(parent, {\n            calculate: calculate,\n            as: sortArrayIndexField(fieldDef, channel, {\n              forAs: true\n            })\n          });\n        }\n      });\n      return parent;\n    }\n  }]);\n  return CalculateNode;\n}(DataFlowNode);\nexport function sortArrayIndexField(fieldDef, channel, opt) {\n  return vgField(fieldDef, Object.assign({\n    prefix: channel,\n    suffix: 'sort_index'\n  }, opt !== null && opt !== void 0 ? opt : {}));\n}","map":{"version":3,"sources":["../../../../src/compile/data/calculate.ts"],"names":[],"mappings":";;;;AAEA,SAAwB,eAAe,EAAiB,OAAO,QAAO,kBAAkB;AAExF,SAAQ,qBAAqB,QAAO,iBAAiB;AACrD,SAAQ,WAAW,QAAO,YAAY;AAEtC,SAAQ,SAAS,EAAE,IAAI,IAAJ,KAAI,QAAO,YAAY;AAE1C,SAAQ,YAAY,QAAO,YAAY;AACvC,SAAQ,kBAAkB,QAAO,eAAe;AAEhD,WAAa,aAAc;EAAA;EAAA;EAOzB,uBAAY,MAAoB,EAAmB,SAA6B,EAAA;IAAA;IAAA;IAC9E,0BAAM,MAAM;IADqC,MAAA,SAAS,GAAT,SAAS;IAG1D,MAAK,gBAAgB,GAAG,kBAAkB,CAAC,MAAK,SAAS,CAAC,SAAS,CAAC;IAAC;EACvE;EAAC;IAAA;IAAA,OARM,iBAAK;MACV,OAAO,IAAI,aAAa,CAAC,IAAI,EAAE,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;IAC3D;EAAC;IAAA;IAAA,OAkCM,0BAAc;MACnB,OAAO,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;IACrC;EAAC;IAAA;IAAA,OAEM,2BAAe;MACpB,OAAO,IAAI,CAAC,gBAAgB;IAC9B;EAAC;IAAA;IAAA,OAEM,oBAAQ;MACb,OAAO;QACL,IAAI,EAAE,SAAS;QACf,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,SAAS;QAC9B,EAAE,EAAE,IAAI,CAAC,SAAS,CAAC;OACpB;IACH;EAAC;IAAA;IAAA,OAEM,gBAAI;MACT,2BAAoB,KAAI,CAAC,IAAI,CAAC,SAAS,CAAC;IAC1C;EAAC;IAAA;IAAA,OA5CM,8BAA4B,MAAoB,EAAE,KAAqB,EAAA;MAC5E;MACA,KAAK,CAAC,eAAe,CAAC,UAAC,QAA+B,EAAE,OAAyB,EAAI;QACnF,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,EAAE;UAC9B;QACD;QACD,IAAI,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;UAC9B,IAAO,KAAK,GAAc,QAAQ,CAA3B,KAAK;YAAE,QAAQ,GAAI,QAAQ,CAApB,QAAQ;UACtB,IAAM,IAAI,GAA6C,QAAQ,CAAC,IAAI;UACpE;UACA,IAAM,SAAS,GACb,IAAI,CACD,GAAG,CAAC,UAAC,SAAS,EAAE,CAAC,EAAI;YACpB,iBAAU,qBAAqB,CAAC;cAAC,KAAK,EAAL,KAAK;cAAE,QAAQ,EAAR,QAAQ;cAAE,KAAK,EAAE;YAAS,CAAC,CAAC,gBAAM,CAAC;UAC7E,CAAC,CAAC,CACD,IAAI,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM;UAE3B,MAAM,GAAG,IAAI,aAAa,CAAC,MAAM,EAAE;YACjC,SAAS,EAAT,SAAS;YACT,EAAE,EAAE,mBAAmB,CAAC,QAAQ,EAAE,OAAO,EAAE;cAAC,KAAK,EAAE;YAAI,CAAC;WACzD,CAAC;QACH;MACH,CAAC,CAAC;MACF,OAAO,MAAM;IACf;EAAC;EAAA;AAAA,EArCgC,YAAY;AA4D/C,OAAM,SAAU,mBAAmB,CAAC,QAA+B,EAAE,OAAyB,EAAE,GAAoB,EAAA;EAClH,OAAO,OAAO,CAAC,QAAQ,EAAA,MAAA,CAAA,MAAA,CAAA;IAAG,MAAM,EAAE,OAAO;IAAE,MAAM,EAAE;EAAY,CAAA,EAAM,GAAG,KAAA,IAAA,IAAH,GAAG,KAAA,KAAA,CAAA,GAAH,GAAG,GAAI,CAAA,CAAE,CAAC,CAAE;AACnF","sourceRoot":"","sourcesContent":["import { isScaleFieldDef, vgField } from '../../channeldef';\nimport { fieldFilterExpression } from '../../predicate';\nimport { isSortArray } from '../../sort';\nimport { duplicate, hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nimport { getDependentFields } from './expressions';\nexport class CalculateNode extends DataFlowNode {\n    constructor(parent, transform) {\n        super(parent);\n        this.transform = transform;\n        this._dependentFields = getDependentFields(this.transform.calculate);\n    }\n    clone() {\n        return new CalculateNode(null, duplicate(this.transform));\n    }\n    static parseAllForSortIndex(parent, model) {\n        // get all the encoding with sort fields from model\n        model.forEachFieldDef((fieldDef, channel) => {\n            if (!isScaleFieldDef(fieldDef)) {\n                return;\n            }\n            if (isSortArray(fieldDef.sort)) {\n                const { field, timeUnit } = fieldDef;\n                const sort = fieldDef.sort;\n                // generate `datum[\"a\"] === val0 ? 0 : datum[\"a\"] === val1 ? 1 : ... : n` via FieldEqualPredicate\n                const calculate = sort\n                    .map((sortValue, i) => {\n                    return `${fieldFilterExpression({ field, timeUnit, equal: sortValue })} ? ${i} : `;\n                })\n                    .join('') + sort.length;\n                parent = new CalculateNode(parent, {\n                    calculate,\n                    as: sortArrayIndexField(fieldDef, channel, { forAs: true })\n                });\n            }\n        });\n        return parent;\n    }\n    producedFields() {\n        return new Set([this.transform.as]);\n    }\n    dependentFields() {\n        return this._dependentFields;\n    }\n    assemble() {\n        return {\n            type: 'formula',\n            expr: this.transform.calculate,\n            as: this.transform.as\n        };\n    }\n    hash() {\n        return `Calculate ${hash(this.transform)}`;\n    }\n}\nexport function sortArrayIndexField(fieldDef, channel, opt) {\n    return vgField(fieldDef, Object.assign({ prefix: channel, suffix: 'sort_index' }, (opt !== null && opt !== void 0 ? opt : {})));\n}\n//# sourceMappingURL=calculate.js.map"]},"metadata":{},"sourceType":"module"}