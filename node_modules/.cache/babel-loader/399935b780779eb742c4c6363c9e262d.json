{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\n// Using this you can \"await\" the file like a normal promise\n// https://blog.shovonhasan.com/using-promises-with-filereader/\nfunction readBlobAsArrayBuffer(blob) {\n  var fileReader = new FileReader();\n  return new Promise(function (resolve, reject) {\n    fileReader.onerror = function () {\n      fileReader.abort();\n      reject(new Error('problem reading blob'));\n    };\n    fileReader.onabort = function () {\n      reject(new Error('blob reading was aborted'));\n    };\n    fileReader.onload = function () {\n      if (fileReader.result && typeof fileReader.result !== 'string') {\n        resolve(fileReader.result);\n      } else {\n        reject(new Error('unknown error reading blob'));\n      }\n    };\n    fileReader.readAsArrayBuffer(blob);\n  });\n}\nfunction readBlobAsText(blob) {\n  var fileReader = new FileReader();\n  return new Promise(function (resolve, reject) {\n    fileReader.onerror = function () {\n      fileReader.abort();\n      reject(new Error('problem reading blob'));\n    };\n    fileReader.onabort = function () {\n      reject(new Error('blob reading was aborted'));\n    };\n    fileReader.onload = function () {\n      if (fileReader.result && typeof fileReader.result === 'string') {\n        resolve(fileReader.result);\n      } else {\n        reject(new Error('unknown error reading blob'));\n      }\n    };\n    fileReader.readAsText(blob);\n  });\n}\n/**\n * Blob of binary data fetched from a local file (with FileReader).\n *\n * Adapted by Robert Buels and Garrett Stevens from the BlobFetchable object in\n * the Dalliance Genome Explorer, which is copyright Thomas Down 2006-2011.\n */\n\nvar BlobFile = /*#__PURE__*/function () {\n  function BlobFile(blob) {\n    (0, _classCallCheck2.default)(this, BlobFile);\n    (0, _defineProperty2.default)(this, \"blob\", void 0);\n    (0, _defineProperty2.default)(this, \"size\", void 0);\n    this.blob = blob;\n    this.size = blob.size;\n  }\n  (0, _createClass2.default)(BlobFile, [{\n    key: \"read\",\n    value: function () {\n      var _read = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(buffer) {\n        var offset,\n          length,\n          position,\n          start,\n          end,\n          result,\n          resultBuffer,\n          bytesCopied,\n          _args = arguments;\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                offset = _args.length > 1 && _args[1] !== undefined ? _args[1] : 0;\n                length = _args.length > 2 ? _args[2] : undefined;\n                position = _args.length > 3 && _args[3] !== undefined ? _args[3] : 0;\n                if (length) {\n                  _context.next = 5;\n                  break;\n                }\n                return _context.abrupt(\"return\", {\n                  bytesRead: 0,\n                  buffer: buffer\n                });\n              case 5:\n                start = position;\n                end = start + length;\n                _context.next = 9;\n                return readBlobAsArrayBuffer(this.blob.slice(start, end));\n              case 9:\n                result = _context.sent;\n                resultBuffer = Buffer.from(result);\n                bytesCopied = resultBuffer.copy(buffer, offset);\n                return _context.abrupt(\"return\", {\n                  bytesRead: bytesCopied,\n                  buffer: resultBuffer\n                });\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function read(_x) {\n        return _read.apply(this, arguments);\n      }\n      return read;\n    }()\n  }, {\n    key: \"readFile\",\n    value: function () {\n      var _readFile = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(options) {\n        var encoding, result;\n        return _regenerator.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (typeof options === 'string') {\n                  encoding = options;\n                } else {\n                  encoding = options && options.encoding;\n                }\n                if (!(encoding === 'utf8')) {\n                  _context2.next = 3;\n                  break;\n                }\n                return _context2.abrupt(\"return\", readBlobAsText(this.blob));\n              case 3:\n                if (!encoding) {\n                  _context2.next = 5;\n                  break;\n                }\n                throw new Error(\"unsupported encoding: \".concat(encoding));\n              case 5:\n                _context2.next = 7;\n                return readBlobAsArrayBuffer(this.blob);\n              case 7:\n                result = _context2.sent;\n                return _context2.abrupt(\"return\", Buffer.from(result));\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function readFile(_x2) {\n        return _readFile.apply(this, arguments);\n      }\n      return readFile;\n    }()\n  }, {\n    key: \"stat\",\n    value: function () {\n      var _stat = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {\n        return _regenerator.default.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", {\n                  size: this.size\n                });\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function stat() {\n        return _stat.apply(this, arguments);\n      }\n      return stat;\n    }()\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {\n        return _regenerator.default.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt(\"return\");\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n      function close() {\n        return _close.apply(this, arguments);\n      }\n      return close;\n    }()\n  }]);\n  return BlobFile;\n}();\nexports.default = BlobFile;","map":{"version":3,"sources":["../src/blobFile.ts"],"names":["readBlobAsArrayBuffer","blob","fileReader","FileReader","Promise","resolve","reject","onerror","abort","Error","onabort","onload","result","readAsArrayBuffer","readBlobAsText","readAsText","BlobFile","size","buffer","offset","length","position","bytesRead","start","end","slice","resultBuffer","Buffer","from","bytesCopied","copy","options","encoding"],"mappings":"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","sourcesContent":["import { GenericFilehandle, FilehandleOptions, Stats } from './filehandle'\n\n// Using this you can \"await\" the file like a normal promise\n// https://blog.shovonhasan.com/using-promises-with-filereader/\nfunction readBlobAsArrayBuffer(blob: Blob): Promise<ArrayBuffer> {\n  const fileReader = new FileReader()\n\n  return new Promise((resolve, reject): void => {\n    fileReader.onerror = (): void => {\n      fileReader.abort()\n      reject(new Error('problem reading blob'))\n    }\n\n    fileReader.onabort = (): void => {\n      reject(new Error('blob reading was aborted'))\n    }\n\n    fileReader.onload = (): void => {\n      if (fileReader.result && typeof fileReader.result !== 'string') {\n        resolve(fileReader.result)\n      } else {\n        reject(new Error('unknown error reading blob'))\n      }\n    }\n    fileReader.readAsArrayBuffer(blob)\n  })\n}\n\nfunction readBlobAsText(blob: Blob): Promise<string> {\n  const fileReader = new FileReader()\n\n  return new Promise((resolve, reject): void => {\n    fileReader.onerror = (): void => {\n      fileReader.abort()\n      reject(new Error('problem reading blob'))\n    }\n\n    fileReader.onabort = (): void => {\n      reject(new Error('blob reading was aborted'))\n    }\n\n    fileReader.onload = (): void => {\n      if (fileReader.result && typeof fileReader.result === 'string') {\n        resolve(fileReader.result)\n      } else {\n        reject(new Error('unknown error reading blob'))\n      }\n    }\n    fileReader.readAsText(blob)\n  })\n}\n\n/**\n * Blob of binary data fetched from a local file (with FileReader).\n *\n * Adapted by Robert Buels and Garrett Stevens from the BlobFetchable object in\n * the Dalliance Genome Explorer, which is copyright Thomas Down 2006-2011.\n */\nexport default class BlobFile implements GenericFilehandle {\n  private blob: Blob\n  private size: number\n  public constructor(blob: Blob) {\n    this.blob = blob\n    this.size = blob.size\n  }\n\n  public async read(\n    buffer: Buffer,\n    offset = 0,\n    length: number,\n    position = 0,\n  ): Promise<{ bytesRead: number; buffer: Buffer }> {\n    // short-circuit a read of 0 bytes here, because browsers actually sometimes\n    // crash if you try to read 0 bytes from a local file!\n    if (!length) {\n      return { bytesRead: 0, buffer }\n    }\n\n    const start = position\n    const end = start + length\n\n    const result = await readBlobAsArrayBuffer(this.blob.slice(start, end))\n    const resultBuffer = Buffer.from(result)\n\n    const bytesCopied = resultBuffer.copy(buffer, offset)\n\n    return { bytesRead: bytesCopied, buffer: resultBuffer }\n  }\n\n  public async readFile(options?: FilehandleOptions | string): Promise<Buffer | string> {\n    let encoding\n    if (typeof options === 'string') {\n      encoding = options\n    } else {\n      encoding = options && options.encoding\n    }\n    if (encoding === 'utf8') {\n      return readBlobAsText(this.blob)\n    }\n    if (encoding) {\n      throw new Error(`unsupported encoding: ${encoding}`)\n    }\n    const result = await readBlobAsArrayBuffer(this.blob)\n    return Buffer.from(result)\n  }\n\n  public async stat(): Promise<Stats> {\n    return { size: this.size }\n  }\n\n  public async close(): Promise<void> {\n    return\n  }\n}\n"]},"metadata":{},"sourceType":"script"}