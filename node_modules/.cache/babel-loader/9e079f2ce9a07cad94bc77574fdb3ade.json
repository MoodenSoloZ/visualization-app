{"ast":null,"code":"import _defineProperty from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { array } from 'vega-util';\nimport { SCALE_CHANNELS } from '../../../channel';\nimport { isPathMark } from '../../../mark';\nimport { hasContinuousDomain } from '../../../scale';\nimport { keys } from '../../../util';\nimport { VG_MARK_CONFIGS } from '../../../vega.schema';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { aria } from './aria';\nimport { color } from './color';\nimport { nonPosition } from './nonposition';\nimport { text } from './text';\nimport { tooltip } from './tooltip';\nimport { fieldInvalidPredicate } from './valueref';\nimport { zindex } from './zindex';\nexport { color } from './color';\nexport { wrapCondition } from './conditional';\nexport { nonPosition } from './nonposition';\nexport { pointPosition } from './position-point';\nexport { pointOrRangePosition, rangePosition } from './position-range';\nexport { rectPosition } from './position-rect';\nexport { text } from './text';\nexport { tooltip } from './tooltip';\nvar ALWAYS_IGNORE = new Set(['aria', 'width', 'height']);\nexport function baseEncodeEntry(model, ignore) {\n  var _ref = ignore.color === 'include' ? color(model) : {},\n    _ref$fill = _ref.fill,\n    fill = _ref$fill === void 0 ? undefined : _ref$fill,\n    _ref$stroke = _ref.stroke,\n    stroke = _ref$stroke === void 0 ? undefined : _ref$stroke;\n  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, markDefProperties(model.markDef, ignore)), wrapAllFieldsInvalid(model, 'fill', fill)), wrapAllFieldsInvalid(model, 'stroke', stroke)), nonPosition('opacity', model)), nonPosition('fillOpacity', model)), nonPosition('strokeOpacity', model)), nonPosition('strokeWidth', model)), nonPosition('strokeDash', model)), zindex(model)), tooltip(model)), text(model, 'href')), aria(model));\n}\n// TODO: mark VgValueRef[] as readonly after https://github.com/vega/vega/pull/1987\nfunction wrapAllFieldsInvalid(model, channel, valueRef) {\n  var config = model.config,\n    mark = model.mark,\n    markDef = model.markDef;\n  var invalid = getMarkPropOrConfig('invalid', markDef, config);\n  if (invalid === 'hide' && valueRef && !isPathMark(mark)) {\n    // For non-path marks, we have to exclude invalid values (null and NaN) for scales with continuous domains.\n    // For path marks, we will use \"defined\" property and skip these values instead.\n    var test = allFieldsInvalidPredicate(model, {\n      invalid: true,\n      channels: SCALE_CHANNELS\n    });\n    if (test) {\n      return _defineProperty({}, channel, [\n      // prepend the invalid case\n      // TODO: support custom value\n      {\n        test: test,\n        value: null\n      }].concat(_toConsumableArray(array(valueRef))));\n    }\n  }\n  return valueRef ? _defineProperty({}, channel, valueRef) : {};\n}\nfunction markDefProperties(mark, ignore) {\n  return VG_MARK_CONFIGS.reduce(function (m, prop) {\n    if (!ALWAYS_IGNORE.has(prop) && mark[prop] !== undefined && ignore[prop] !== 'ignore') {\n      m[prop] = signalOrValueRef(mark[prop]);\n    }\n    return m;\n  }, {});\n}\nfunction allFieldsInvalidPredicate(model, _ref4) {\n  var _ref4$invalid = _ref4.invalid,\n    invalid = _ref4$invalid === void 0 ? false : _ref4$invalid,\n    channels = _ref4.channels;\n  var filterIndex = channels.reduce(function (aggregator, channel) {\n    var scaleComponent = model.getScaleComponent(channel);\n    if (scaleComponent) {\n      var scaleType = scaleComponent.get('type');\n      var field = model.vgField(channel, {\n        expr: 'datum'\n      });\n      // While discrete domain scales can handle invalid values, continuous scales can't.\n      if (field && hasContinuousDomain(scaleType)) {\n        aggregator[field] = true;\n      }\n    }\n    return aggregator;\n  }, {});\n  var fields = keys(filterIndex);\n  if (fields.length > 0) {\n    var op = invalid ? '||' : '&&';\n    return fields.map(function (field) {\n      return fieldInvalidPredicate(field, invalid);\n    }).join(\" \".concat(op, \" \"));\n  }\n  return undefined;\n}","map":{"version":3,"sources":["../../../../../src/compile/mark/encode/base.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { array } from 'vega-util';\nimport { SCALE_CHANNELS } from '../../../channel';\nimport { isPathMark } from '../../../mark';\nimport { hasContinuousDomain } from '../../../scale';\nimport { keys } from '../../../util';\nimport { VG_MARK_CONFIGS } from '../../../vega.schema';\nimport { getMarkPropOrConfig, signalOrValueRef } from '../../common';\nimport { aria } from './aria';\nimport { color } from './color';\nimport { nonPosition } from './nonposition';\nimport { text } from './text';\nimport { tooltip } from './tooltip';\nimport { fieldInvalidPredicate } from './valueref';\nimport { zindex } from './zindex';\nexport { color } from './color';\nexport { wrapCondition } from './conditional';\nexport { nonPosition } from './nonposition';\nexport { pointPosition } from './position-point';\nexport { pointOrRangePosition, rangePosition } from './position-range';\nexport { rectPosition } from './position-rect';\nexport { text } from './text';\nexport { tooltip } from './tooltip';\nconst ALWAYS_IGNORE = new Set(['aria', 'width', 'height']);\nexport function baseEncodeEntry(model, ignore) {\n    const { fill = undefined, stroke = undefined } = ignore.color === 'include' ? color(model) : {};\n    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, markDefProperties(model.markDef, ignore)), wrapAllFieldsInvalid(model, 'fill', fill)), wrapAllFieldsInvalid(model, 'stroke', stroke)), nonPosition('opacity', model)), nonPosition('fillOpacity', model)), nonPosition('strokeOpacity', model)), nonPosition('strokeWidth', model)), nonPosition('strokeDash', model)), zindex(model)), tooltip(model)), text(model, 'href')), aria(model));\n}\n// TODO: mark VgValueRef[] as readonly after https://github.com/vega/vega/pull/1987\nfunction wrapAllFieldsInvalid(model, channel, valueRef) {\n    const { config, mark, markDef } = model;\n    const invalid = getMarkPropOrConfig('invalid', markDef, config);\n    if (invalid === 'hide' && valueRef && !isPathMark(mark)) {\n        // For non-path marks, we have to exclude invalid values (null and NaN) for scales with continuous domains.\n        // For path marks, we will use \"defined\" property and skip these values instead.\n        const test = allFieldsInvalidPredicate(model, { invalid: true, channels: SCALE_CHANNELS });\n        if (test) {\n            return {\n                [channel]: [\n                    // prepend the invalid case\n                    // TODO: support custom value\n                    { test, value: null },\n                    ...array(valueRef)\n                ]\n            };\n        }\n    }\n    return valueRef ? { [channel]: valueRef } : {};\n}\nfunction markDefProperties(mark, ignore) {\n    return VG_MARK_CONFIGS.reduce((m, prop) => {\n        if (!ALWAYS_IGNORE.has(prop) && mark[prop] !== undefined && ignore[prop] !== 'ignore') {\n            m[prop] = signalOrValueRef(mark[prop]);\n        }\n        return m;\n    }, {});\n}\nfunction allFieldsInvalidPredicate(model, { invalid = false, channels }) {\n    const filterIndex = channels.reduce((aggregator, channel) => {\n        const scaleComponent = model.getScaleComponent(channel);\n        if (scaleComponent) {\n            const scaleType = scaleComponent.get('type');\n            const field = model.vgField(channel, { expr: 'datum' });\n            // While discrete domain scales can handle invalid values, continuous scales can't.\n            if (field && hasContinuousDomain(scaleType)) {\n                aggregator[field] = true;\n            }\n        }\n        return aggregator;\n    }, {});\n    const fields = keys(filterIndex);\n    if (fields.length > 0) {\n        const op = invalid ? '||' : '&&';\n        return fields.map(field => fieldInvalidPredicate(field, invalid)).join(` ${op} `);\n    }\n    return undefined;\n}\n//# sourceMappingURL=base.js.map"]},"metadata":{},"sourceType":"module"}