{"ast":null,"code":"import { isBinning } from '../../bin';\nimport { getSizeChannel, isColorChannel, isScaleChannel, isXorY, isXorYOffset, rangeType } from '../../channel';\nimport { isFieldDef, isPositionFieldOrDatumDef } from '../../channeldef';\nimport * as log from '../../log';\nimport { isRelativeBandSize } from '../../mark';\nimport { channelSupportScaleType, scaleTypeSupportDataType } from '../../scale';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport * as util from '../../util';\nimport { POLAR_POSITION_SCALE_CHANNEL_INDEX } from './../../channel';\n/**\n * Determine if there is a specified scale type and if it is appropriate,\n * or determine default type if type is unspecified or inappropriate.\n */\n// NOTE: CompassQL uses this method.\nexport function scaleType(specifiedScale, channel, fieldDef, mark) {\n  var hasNestedOffsetScale = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var defaultScaleType = defaultType(channel, fieldDef, mark, hasNestedOffsetScale);\n  var type = specifiedScale.type;\n  if (!isScaleChannel(channel)) {\n    // There is no scale for these channels\n    return null;\n  }\n  if (type !== undefined) {\n    // Check if explicitly specified scale type is supported by the channel\n    if (!channelSupportScaleType(channel, type)) {\n      log.warn(log.message.scaleTypeNotWorkWithChannel(channel, type, defaultScaleType));\n      return defaultScaleType;\n    }\n    // Check if explicitly specified scale type is supported by the data type\n    if (isFieldDef(fieldDef) && !scaleTypeSupportDataType(type, fieldDef.type)) {\n      log.warn(log.message.scaleTypeNotWorkWithFieldDef(type, defaultScaleType));\n      return defaultScaleType;\n    }\n    return type;\n  }\n  return defaultScaleType;\n}\n/**\n * Determine appropriate default scale type.\n */\n// NOTE: Voyager uses this method.\nfunction defaultType(channel, fieldDef, mark, hasNestedOffsetScale) {\n  var _a;\n  switch (fieldDef.type) {\n    case 'nominal':\n    case 'ordinal':\n      {\n        if (isColorChannel(channel) || rangeType(channel) === 'discrete') {\n          if (channel === 'shape' && fieldDef.type === 'ordinal') {\n            log.warn(log.message.discreteChannelCannotEncode(channel, 'ordinal'));\n          }\n          return 'ordinal';\n        }\n        if (isXorY(channel) || isXorYOffset(channel)) {\n          if (util.contains(['rect', 'bar', 'image', 'rule'], mark.type)) {\n            // The rect/bar mark should fit into a band.\n            // For rule, using band scale to make rule align with axis ticks better https://github.com/vega/vega-lite/issues/3429\n            return 'band';\n          }\n          if (hasNestedOffsetScale) {\n            // If there is a nested offset scale, then there is a \"band\" for the span of the nested scale.\n            return 'band';\n          }\n        } else if (mark.type === 'arc' && channel in POLAR_POSITION_SCALE_CHANNEL_INDEX) {\n          return 'band';\n        }\n        var dimensionSize = mark[getSizeChannel(channel)];\n        if (isRelativeBandSize(dimensionSize)) {\n          return 'band';\n        }\n        if (isPositionFieldOrDatumDef(fieldDef) && ((_a = fieldDef.axis) === null || _a === void 0 ? void 0 : _a.tickBand)) {\n          return 'band';\n        }\n        // Otherwise, use ordinal point scale so we can easily get center positions of the marks.\n        return 'point';\n      }\n    case 'temporal':\n      if (isColorChannel(channel)) {\n        return 'time';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'temporal'));\n        // TODO: consider using quantize (equivalent to binning) once we have it\n        return 'ordinal';\n      } else if (isFieldDef(fieldDef) && fieldDef.timeUnit && normalizeTimeUnit(fieldDef.timeUnit).utc) {\n        return 'utc';\n      }\n      return 'time';\n    case 'quantitative':\n      if (isColorChannel(channel)) {\n        if (isFieldDef(fieldDef) && isBinning(fieldDef.bin)) {\n          return 'bin-ordinal';\n        }\n        return 'linear';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'quantitative'));\n        // TODO: consider using quantize (equivalent to binning) once we have it\n        return 'ordinal';\n      }\n      return 'linear';\n    case 'geojson':\n      return undefined;\n  }\n  /* istanbul ignore next: should never reach this */\n  throw new Error(log.message.invalidFieldType(fieldDef.type));\n}","map":{"version":3,"sources":["../../../../src/compile/scale/type.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isBinning } from '../../bin';\nimport { getSizeChannel, isColorChannel, isScaleChannel, isXorY, isXorYOffset, rangeType } from '../../channel';\nimport { isFieldDef, isPositionFieldOrDatumDef } from '../../channeldef';\nimport * as log from '../../log';\nimport { isRelativeBandSize } from '../../mark';\nimport { channelSupportScaleType, scaleTypeSupportDataType } from '../../scale';\nimport { normalizeTimeUnit } from '../../timeunit';\nimport * as util from '../../util';\nimport { POLAR_POSITION_SCALE_CHANNEL_INDEX } from './../../channel';\n/**\n * Determine if there is a specified scale type and if it is appropriate,\n * or determine default type if type is unspecified or inappropriate.\n */\n// NOTE: CompassQL uses this method.\nexport function scaleType(specifiedScale, channel, fieldDef, mark, hasNestedOffsetScale = false) {\n    const defaultScaleType = defaultType(channel, fieldDef, mark, hasNestedOffsetScale);\n    const { type } = specifiedScale;\n    if (!isScaleChannel(channel)) {\n        // There is no scale for these channels\n        return null;\n    }\n    if (type !== undefined) {\n        // Check if explicitly specified scale type is supported by the channel\n        if (!channelSupportScaleType(channel, type)) {\n            log.warn(log.message.scaleTypeNotWorkWithChannel(channel, type, defaultScaleType));\n            return defaultScaleType;\n        }\n        // Check if explicitly specified scale type is supported by the data type\n        if (isFieldDef(fieldDef) && !scaleTypeSupportDataType(type, fieldDef.type)) {\n            log.warn(log.message.scaleTypeNotWorkWithFieldDef(type, defaultScaleType));\n            return defaultScaleType;\n        }\n        return type;\n    }\n    return defaultScaleType;\n}\n/**\n * Determine appropriate default scale type.\n */\n// NOTE: Voyager uses this method.\nfunction defaultType(channel, fieldDef, mark, hasNestedOffsetScale) {\n    var _a;\n    switch (fieldDef.type) {\n        case 'nominal':\n        case 'ordinal': {\n            if (isColorChannel(channel) || rangeType(channel) === 'discrete') {\n                if (channel === 'shape' && fieldDef.type === 'ordinal') {\n                    log.warn(log.message.discreteChannelCannotEncode(channel, 'ordinal'));\n                }\n                return 'ordinal';\n            }\n            if (isXorY(channel) || isXorYOffset(channel)) {\n                if (util.contains(['rect', 'bar', 'image', 'rule'], mark.type)) {\n                    // The rect/bar mark should fit into a band.\n                    // For rule, using band scale to make rule align with axis ticks better https://github.com/vega/vega-lite/issues/3429\n                    return 'band';\n                }\n                if (hasNestedOffsetScale) {\n                    // If there is a nested offset scale, then there is a \"band\" for the span of the nested scale.\n                    return 'band';\n                }\n            }\n            else if (mark.type === 'arc' && channel in POLAR_POSITION_SCALE_CHANNEL_INDEX) {\n                return 'band';\n            }\n            const dimensionSize = mark[getSizeChannel(channel)];\n            if (isRelativeBandSize(dimensionSize)) {\n                return 'band';\n            }\n            if (isPositionFieldOrDatumDef(fieldDef) && ((_a = fieldDef.axis) === null || _a === void 0 ? void 0 : _a.tickBand)) {\n                return 'band';\n            }\n            // Otherwise, use ordinal point scale so we can easily get center positions of the marks.\n            return 'point';\n        }\n        case 'temporal':\n            if (isColorChannel(channel)) {\n                return 'time';\n            }\n            else if (rangeType(channel) === 'discrete') {\n                log.warn(log.message.discreteChannelCannotEncode(channel, 'temporal'));\n                // TODO: consider using quantize (equivalent to binning) once we have it\n                return 'ordinal';\n            }\n            else if (isFieldDef(fieldDef) && fieldDef.timeUnit && normalizeTimeUnit(fieldDef.timeUnit).utc) {\n                return 'utc';\n            }\n            return 'time';\n        case 'quantitative':\n            if (isColorChannel(channel)) {\n                if (isFieldDef(fieldDef) && isBinning(fieldDef.bin)) {\n                    return 'bin-ordinal';\n                }\n                return 'linear';\n            }\n            else if (rangeType(channel) === 'discrete') {\n                log.warn(log.message.discreteChannelCannotEncode(channel, 'quantitative'));\n                // TODO: consider using quantize (equivalent to binning) once we have it\n                return 'ordinal';\n            }\n            return 'linear';\n        case 'geojson':\n            return undefined;\n    }\n    /* istanbul ignore next: should never reach this */\n    throw new Error(log.message.invalidFieldType(fieldDef.type));\n}\n//# sourceMappingURL=type.js.map"]},"metadata":{},"sourceType":"module"}