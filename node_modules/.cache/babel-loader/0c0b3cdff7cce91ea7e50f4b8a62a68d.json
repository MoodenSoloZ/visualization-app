{"ast":null,"code":"import { Transform, ingest, tupleid, stableCompare } from 'vega-dataflow';\nimport { tickCount, tickFormat, validTicks, tickValues, SymbolLegend, labelFormat, labelValues, GradientLegend, scaleFraction, labelFraction, scale, isContinuous, Sequential, Linear, Time, UTC, Pow, Sqrt, Ordinal, scaleImplicit, Log, Symlog, isLogarithmic, BinOrdinal, bandSpace, isInterpolating, interpolateRange, quantizeInterpolator, interpolateColors, interpolate, Band, Point, scheme, Threshold, Quantile, Quantize, Diverging } from 'vega-scale';\nimport { inherits, isArray, error, fastmap, falsy, isFunction, constant, peek, one, toSet, isString, zoomLog, zoomPow, zoomSymlog, zoomLinear, stringValue } from 'vega-util';\nimport { sum, range } from 'd3-array';\nimport { interpolateRound, interpolate as interpolate$1 } from 'd3-interpolate';\n\n/**\n * Generates axis ticks for visualizing a spatial scale.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Scale} params.scale - The scale to generate ticks for.\n * @param {*} [params.count=10] - The approximate number of ticks, or\n *   desired tick interval, to use.\n * @param {Array<*>} [params.values] - The exact tick values to use.\n *   These must be legal domain values for the provided scale.\n *   If provided, the count argument is ignored.\n * @param {function(*):string} [params.formatSpecifier] - A format specifier\n *   to use in conjunction with scale.tickFormat. Legal values are\n *   any valid d3 4.0 format specifier.\n * @param {function(*):string} [params.format] - The format function to use.\n *   If provided, the formatSpecifier argument is ignored.\n */\n\nfunction AxisTicks(params) {\n  Transform.call(this, null, params);\n}\ninherits(AxisTicks, Transform, {\n  transform: function transform(_, pulse) {\n    if (this.value && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n    var locale = pulse.dataflow.locale(),\n      out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      ticks = this.value,\n      scale = _.scale,\n      tally = _.count == null ? _.values ? _.values.length : 10 : _.count,\n      count = tickCount(scale, tally, _.minstep),\n      format = _.format || tickFormat(locale, scale, count, _.formatSpecifier, _.formatType, !!_.values),\n      values = _.values ? validTicks(scale, _.values, count) : tickValues(scale, count);\n    if (ticks) out.rem = ticks;\n    ticks = values.map(function (value, i) {\n      return ingest({\n        index: i / (values.length - 1 || 1),\n        value: value,\n        label: format(value)\n      });\n    });\n    if (_.extra && ticks.length) {\n      // add an extra tick pegged to the initial domain value\n      // this is used to generate axes with 'binned' domains\n      ticks.push(ingest({\n        index: -1,\n        extra: {\n          value: ticks[0].value\n        },\n        label: ''\n      }));\n    }\n    out.source = ticks;\n    out.add = ticks;\n    this.value = ticks;\n    return out;\n  }\n});\n\n/**\n * Joins a set of data elements against a set of visual items.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): object} [params.item] - An item generator function.\n * @param {function(object): *} [params.key] - The key field associating data and visual items.\n */\n\nfunction DataJoin(params) {\n  Transform.call(this, null, params);\n}\nfunction defaultItemCreate() {\n  return ingest({});\n}\nfunction newMap(key) {\n  var map = fastmap().test(function (t) {\n    return t.exit;\n  });\n  map.lookup = function (t) {\n    return map.get(key(t));\n  };\n  return map;\n}\ninherits(DataJoin, Transform, {\n  transform: function transform(_, pulse) {\n    var df = pulse.dataflow,\n      out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      item = _.item || defaultItemCreate,\n      key = _.key || tupleid,\n      map = this.value; // prevent transient (e.g., hover) requests from\n    // cascading across marks derived from marks\n\n    if (isArray(out.encode)) {\n      out.encode = null;\n    }\n    if (map && (_.modified('key') || pulse.modified(key))) {\n      error('DataJoin does not support modified key function or fields.');\n    }\n    if (!map) {\n      pulse = pulse.addAll();\n      this.value = map = newMap(key);\n    }\n    pulse.visit(pulse.ADD, function (t) {\n      var k = key(t);\n      var x = map.get(k);\n      if (x) {\n        if (x.exit) {\n          map.empty--;\n          out.add.push(x);\n        } else {\n          out.mod.push(x);\n        }\n      } else {\n        x = item(t);\n        map.set(k, x);\n        out.add.push(x);\n      }\n      x.datum = t;\n      x.exit = false;\n    });\n    pulse.visit(pulse.MOD, function (t) {\n      var k = key(t),\n        x = map.get(k);\n      if (x) {\n        x.datum = t;\n        out.mod.push(x);\n      }\n    });\n    pulse.visit(pulse.REM, function (t) {\n      var k = key(t),\n        x = map.get(k);\n      if (t === x.datum && !x.exit) {\n        out.rem.push(x);\n        x.exit = true;\n        ++map.empty;\n      }\n    });\n    if (pulse.changed(pulse.ADD_MOD)) out.modifies('datum');\n    if (pulse.clean() || _.clean && map.empty > df.cleanThreshold) {\n      df.runAfter(map.clean);\n    }\n    return out;\n  }\n});\n\n/**\n * Invokes encoding functions for visual items.\n * @constructor\n * @param {object} params - The parameters to the encoding functions. This\n *   parameter object will be passed through to all invoked encoding functions.\n * @param {object} [params.mod=false] - Flag indicating if tuples in the input\n *   mod set that are unmodified by encoders should be included in the output.\n * @param {object} param.encoders - The encoding functions\n * @param {function(object, object): boolean} [param.encoders.update] - Update encoding set\n * @param {function(object, object): boolean} [param.encoders.enter] - Enter encoding set\n * @param {function(object, object): boolean} [param.encoders.exit] - Exit encoding set\n */\n\nfunction Encode(params) {\n  Transform.call(this, null, params);\n}\ninherits(Encode, Transform, {\n  transform: function transform(_, pulse) {\n    var out = pulse.fork(pulse.ADD_REM),\n      fmod = _.mod || false,\n      encoders = _.encoders,\n      encode = pulse.encode; // if an array, the encode directive includes additional sets\n    // that must be defined in order for the primary set to be invoked\n    // e.g., only run the update set if the hover set is defined\n\n    if (isArray(encode)) {\n      if (out.changed() || encode.every(function (e) {\n        return encoders[e];\n      })) {\n        encode = encode[0];\n        out.encode = null; // consume targeted encode directive\n      } else {\n        return pulse.StopPropagation;\n      }\n    } // marshall encoder functions\n\n    var reenter = encode === 'enter',\n      update = encoders.update || falsy,\n      enter = encoders.enter || falsy,\n      exit = encoders.exit || falsy,\n      set = (encode && !reenter ? encoders[encode] : update) || falsy;\n    if (pulse.changed(pulse.ADD)) {\n      pulse.visit(pulse.ADD, function (t) {\n        enter(t, _);\n        update(t, _);\n      });\n      out.modifies(enter.output);\n      out.modifies(update.output);\n      if (set !== falsy && set !== update) {\n        pulse.visit(pulse.ADD, function (t) {\n          set(t, _);\n        });\n        out.modifies(set.output);\n      }\n    }\n    if (pulse.changed(pulse.REM) && exit !== falsy) {\n      pulse.visit(pulse.REM, function (t) {\n        exit(t, _);\n      });\n      out.modifies(exit.output);\n    }\n    if (reenter || set !== falsy) {\n      var flag = pulse.MOD | (_.modified() ? pulse.REFLOW : 0);\n      if (reenter) {\n        pulse.visit(flag, function (t) {\n          var mod = enter(t, _) || fmod;\n          if (set(t, _) || mod) out.mod.push(t);\n        });\n        if (out.mod.length) out.modifies(enter.output);\n      } else {\n        pulse.visit(flag, function (t) {\n          if (set(t, _) || fmod) out.mod.push(t);\n        });\n      }\n      if (out.mod.length) out.modifies(set.output);\n    }\n    return out.changed() ? out : pulse.StopPropagation;\n  }\n});\n\n/**\n * Generates legend entries for visualizing a scale.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Scale} params.scale - The scale to generate items for.\n * @param {*} [params.count=5] - The approximate number of items, or\n *   desired tick interval, to use.\n * @param {*} [params.limit] - The maximum number of entries to\n *   include in a symbol legend.\n * @param {Array<*>} [params.values] - The exact tick values to use.\n *   These must be legal domain values for the provided scale.\n *   If provided, the count argument is ignored.\n * @param {string} [params.formatSpecifier] - A format specifier\n *   to use in conjunction with scale.tickFormat. Legal values are\n *   any valid D3 format specifier string.\n * @param {function(*):string} [params.format] - The format function to use.\n *   If provided, the formatSpecifier argument is ignored.\n */\n\nfunction LegendEntries(params) {\n  Transform.call(this, [], params);\n}\ninherits(LegendEntries, Transform, {\n  transform: function transform(_, pulse) {\n    if (this.value != null && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n    var locale = pulse.dataflow.locale(),\n      out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      items = this.value,\n      type = _.type || SymbolLegend,\n      scale = _.scale,\n      limit = +_.limit,\n      count = tickCount(scale, _.count == null ? 5 : _.count, _.minstep),\n      lskip = !!_.values || type === SymbolLegend,\n      format = _.format || labelFormat(locale, scale, count, type, _.formatSpecifier, _.formatType, lskip),\n      values = _.values || labelValues(scale, count),\n      domain,\n      fraction,\n      size,\n      offset,\n      ellipsis;\n    if (items) out.rem = items;\n    if (type === SymbolLegend) {\n      if (limit && values.length > limit) {\n        pulse.dataflow.warn('Symbol legend count exceeds limit, filtering items.');\n        items = values.slice(0, limit - 1);\n        ellipsis = true;\n      } else {\n        items = values;\n      }\n      if (isFunction(size = _.size)) {\n        // if first value maps to size zero, remove from list (vega#717)\n        if (!_.values && scale(items[0]) === 0) {\n          items = items.slice(1);\n        } // compute size offset for legend entries\n\n        offset = items.reduce(function (max, value) {\n          return Math.max(max, size(value, _));\n        }, 0);\n      } else {\n        size = constant(offset = size || 8);\n      }\n      items = items.map(function (value, index) {\n        return ingest({\n          index: index,\n          label: format(value, index, items),\n          value: value,\n          offset: offset,\n          size: size(value, _)\n        });\n      });\n      if (ellipsis) {\n        ellipsis = values[items.length];\n        items.push(ingest({\n          index: items.length,\n          label: \"\\u2026\".concat(values.length - items.length, \" entries\"),\n          value: ellipsis,\n          offset: offset,\n          size: size(ellipsis, _)\n        }));\n      }\n    } else if (type === GradientLegend) {\n      domain = scale.domain(), fraction = scaleFraction(scale, domain[0], peek(domain)); // if automatic label generation produces 2 or fewer values,\n      // use the domain end points instead (fixes vega/vega#1364)\n\n      if (values.length < 3 && !_.values && domain[0] !== peek(domain)) {\n        values = [domain[0], peek(domain)];\n      }\n      items = values.map(function (value, index) {\n        return ingest({\n          index: index,\n          label: format(value, index, values),\n          value: value,\n          perc: fraction(value)\n        });\n      });\n    } else {\n      size = values.length - 1;\n      fraction = labelFraction(scale);\n      items = values.map(function (value, index) {\n        return ingest({\n          index: index,\n          label: format(value, index, values),\n          value: value,\n          perc: index ? fraction(value) : 0,\n          perc2: index === size ? 1 : fraction(values[index + 1])\n        });\n      });\n    }\n    out.source = items;\n    out.add = items;\n    this.value = items;\n    return out;\n  }\n});\nvar sourceX = function sourceX(t) {\n  return t.source.x;\n};\nvar sourceY = function sourceY(t) {\n  return t.source.y;\n};\nvar targetX = function targetX(t) {\n  return t.target.x;\n};\nvar targetY = function targetY(t) {\n  return t.target.y;\n};\n/**\n * Layout paths linking source and target elements.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction LinkPath(params) {\n  Transform.call(this, {}, params);\n}\nLinkPath.Definition = {\n  'type': 'LinkPath',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'sourceX',\n    'type': 'field',\n    'default': 'source.x'\n  }, {\n    'name': 'sourceY',\n    'type': 'field',\n    'default': 'source.y'\n  }, {\n    'name': 'targetX',\n    'type': 'field',\n    'default': 'target.x'\n  }, {\n    'name': 'targetY',\n    'type': 'field',\n    'default': 'target.y'\n  }, {\n    'name': 'orient',\n    'type': 'enum',\n    'default': 'vertical',\n    'values': ['horizontal', 'vertical', 'radial']\n  }, {\n    'name': 'shape',\n    'type': 'enum',\n    'default': 'line',\n    'values': ['line', 'arc', 'curve', 'diagonal', 'orthogonal']\n  }, {\n    'name': 'require',\n    'type': 'signal'\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'path'\n  }]\n};\ninherits(LinkPath, Transform, {\n  transform: function transform(_, pulse) {\n    var sx = _.sourceX || sourceX,\n      sy = _.sourceY || sourceY,\n      tx = _.targetX || targetX,\n      ty = _.targetY || targetY,\n      as = _.as || 'path',\n      orient = _.orient || 'vertical',\n      shape = _.shape || 'line',\n      path = Paths.get(shape + '-' + orient) || Paths.get(shape);\n    if (!path) {\n      error('LinkPath unsupported type: ' + _.shape + (_.orient ? '-' + _.orient : ''));\n    }\n    pulse.visit(pulse.SOURCE, function (t) {\n      t[as] = path(sx(t), sy(t), tx(t), ty(t));\n    });\n    return pulse.reflow(_.modified()).modifies(as);\n  }\n});\nvar line = function line(sx, sy, tx, ty) {\n  return 'M' + sx + ',' + sy + 'L' + tx + ',' + ty;\n};\nvar lineR = function lineR(sa, sr, ta, tr) {\n  return line(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));\n};\nvar arc = function arc(sx, sy, tx, ty) {\n  var dx = tx - sx,\n    dy = ty - sy,\n    rr = Math.sqrt(dx * dx + dy * dy) / 2,\n    ra = 180 * Math.atan2(dy, dx) / Math.PI;\n  return 'M' + sx + ',' + sy + 'A' + rr + ',' + rr + ' ' + ra + ' 0 1' + ' ' + tx + ',' + ty;\n};\nvar arcR = function arcR(sa, sr, ta, tr) {\n  return arc(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));\n};\nvar curve = function curve(sx, sy, tx, ty) {\n  var dx = tx - sx,\n    dy = ty - sy,\n    ix = 0.2 * (dx + dy),\n    iy = 0.2 * (dy - dx);\n  return 'M' + sx + ',' + sy + 'C' + (sx + ix) + ',' + (sy + iy) + ' ' + (tx + iy) + ',' + (ty - ix) + ' ' + tx + ',' + ty;\n};\nvar curveR = function curveR(sa, sr, ta, tr) {\n  return curve(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));\n};\nvar orthoX = function orthoX(sx, sy, tx, ty) {\n  return 'M' + sx + ',' + sy + 'V' + ty + 'H' + tx;\n};\nvar orthoY = function orthoY(sx, sy, tx, ty) {\n  return 'M' + sx + ',' + sy + 'H' + tx + 'V' + ty;\n};\nvar orthoR = function orthoR(sa, sr, ta, tr) {\n  var sc = Math.cos(sa),\n    ss = Math.sin(sa),\n    tc = Math.cos(ta),\n    ts = Math.sin(ta),\n    sf = Math.abs(ta - sa) > Math.PI ? ta <= sa : ta > sa;\n  return 'M' + sr * sc + ',' + sr * ss + 'A' + sr + ',' + sr + ' 0 0,' + (sf ? 1 : 0) + ' ' + sr * tc + ',' + sr * ts + 'L' + tr * tc + ',' + tr * ts;\n};\nvar diagonalX = function diagonalX(sx, sy, tx, ty) {\n  var m = (sx + tx) / 2;\n  return 'M' + sx + ',' + sy + 'C' + m + ',' + sy + ' ' + m + ',' + ty + ' ' + tx + ',' + ty;\n};\nvar diagonalY = function diagonalY(sx, sy, tx, ty) {\n  var m = (sy + ty) / 2;\n  return 'M' + sx + ',' + sy + 'C' + sx + ',' + m + ' ' + tx + ',' + m + ' ' + tx + ',' + ty;\n};\nvar diagonalR = function diagonalR(sa, sr, ta, tr) {\n  var sc = Math.cos(sa),\n    ss = Math.sin(sa),\n    tc = Math.cos(ta),\n    ts = Math.sin(ta),\n    mr = (sr + tr) / 2;\n  return 'M' + sr * sc + ',' + sr * ss + 'C' + mr * sc + ',' + mr * ss + ' ' + mr * tc + ',' + mr * ts + ' ' + tr * tc + ',' + tr * ts;\n};\nvar Paths = fastmap({\n  'line': line,\n  'line-radial': lineR,\n  'arc': arc,\n  'arc-radial': arcR,\n  'curve': curve,\n  'curve-radial': curveR,\n  'orthogonal-horizontal': orthoX,\n  'orthogonal-vertical': orthoY,\n  'orthogonal-radial': orthoR,\n  'diagonal-horizontal': diagonalX,\n  'diagonal-vertical': diagonalY,\n  'diagonal-radial': diagonalR\n});\n\n/**\n * Pie and donut chart layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size pie segments.\n * @param {number} [params.startAngle=0] - The start angle (in radians) of the layout.\n * @param {number} [params.endAngle=2π] - The end angle (in radians) of the layout.\n * @param {boolean} [params.sort] - Boolean flag for sorting sectors by value.\n */\n\nfunction Pie(params) {\n  Transform.call(this, null, params);\n}\nPie.Definition = {\n  'type': 'Pie',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'startAngle',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'endAngle',\n    'type': 'number',\n    'default': 6.283185307179586\n  }, {\n    'name': 'sort',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': ['startAngle', 'endAngle']\n  }]\n};\ninherits(Pie, Transform, {\n  transform: function transform(_, pulse) {\n    var as = _.as || ['startAngle', 'endAngle'],\n      startAngle = as[0],\n      endAngle = as[1],\n      field = _.field || one,\n      start = _.startAngle || 0,\n      stop = _.endAngle != null ? _.endAngle : 2 * Math.PI,\n      data = pulse.source,\n      values = data.map(field),\n      n = values.length,\n      a = start,\n      k = (stop - start) / sum(values),\n      index = range(n),\n      i,\n      t,\n      v;\n    if (_.sort) {\n      index.sort(function (a, b) {\n        return values[a] - values[b];\n      });\n    }\n    for (i = 0; i < n; ++i) {\n      v = values[index[i]];\n      t = data[index[i]];\n      t[startAngle] = a;\n      t[endAngle] = a += v * k;\n    }\n    this.value = values;\n    return pulse.reflow(_.modified()).modifies(as);\n  }\n});\nvar DEFAULT_COUNT = 5;\nfunction includeZero(scale) {\n  var type = scale.type;\n  return !scale.bins && (type === Linear || type === Pow || type === Sqrt);\n}\nfunction includePad(type) {\n  return isContinuous(type) && type !== Sequential;\n}\nvar SKIP = toSet(['set', 'modified', 'clear', 'type', 'scheme', 'schemeExtent', 'schemeCount', 'domain', 'domainMin', 'domainMid', 'domainMax', 'domainRaw', 'domainImplicit', 'nice', 'zero', 'bins', 'range', 'rangeStep', 'round', 'reverse', 'interpolate', 'interpolateGamma']);\n/**\n * Maintains a scale function mapping data values to visual channels.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction Scale(params) {\n  Transform.call(this, null, params);\n  this.modified(true); // always treat as modified\n}\n\ninherits(Scale, Transform, {\n  transform: function transform(_, pulse) {\n    var df = pulse.dataflow,\n      scale$1 = this.value,\n      key = scaleKey(_);\n    if (!scale$1 || key !== scale$1.type) {\n      this.value = scale$1 = scale(key)();\n    }\n    for (key in _) {\n      if (!SKIP[key]) {\n        // padding is a scale property for band/point but not others\n        if (key === 'padding' && includePad(scale$1.type)) continue; // invoke scale property setter, raise warning if not found\n\n        isFunction(scale$1[key]) ? scale$1[key](_[key]) : df.warn('Unsupported scale property: ' + key);\n      }\n    }\n    configureRange(scale$1, _, configureBins(scale$1, _, configureDomain(scale$1, _, df)));\n    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n  }\n});\nfunction scaleKey(_) {\n  var t = _.type,\n    d = '',\n    n; // backwards compatibility pre Vega 5.\n\n  if (t === Sequential) return Sequential + '-' + Linear;\n  if (isContinuousColor(_)) {\n    n = _.rawDomain ? _.rawDomain.length : _.domain ? _.domain.length + +(_.domainMid != null) : 0;\n    d = n === 2 ? Sequential + '-' : n === 3 ? Diverging + '-' : '';\n  }\n  return (d + t || Linear).toLowerCase();\n}\nfunction isContinuousColor(_) {\n  var t = _.type;\n  return isContinuous(t) && t !== Time && t !== UTC && (_.scheme || _.range && _.range.length && _.range.every(isString));\n}\nfunction configureDomain(scale, _, df) {\n  // check raw domain, if provided use that and exit early\n  var raw = rawDomain(scale, _.domainRaw, df);\n  if (raw > -1) return raw;\n  var domain = _.domain,\n    type = scale.type,\n    zero = _.zero || _.zero === undefined && includeZero(scale),\n    n,\n    mid;\n  if (!domain) return 0; // adjust continuous domain for minimum pixel padding\n\n  if (includePad(type) && _.padding && domain[0] !== peek(domain)) {\n    domain = padDomain(type, domain, _.range, _.padding, _.exponent, _.constant);\n  } // adjust domain based on zero, min, max settings\n\n  if (zero || _.domainMin != null || _.domainMax != null || _.domainMid != null) {\n    n = (domain = domain.slice()).length - 1 || 1;\n    if (zero) {\n      if (domain[0] > 0) domain[0] = 0;\n      if (domain[n] < 0) domain[n] = 0;\n    }\n    if (_.domainMin != null) domain[0] = _.domainMin;\n    if (_.domainMax != null) domain[n] = _.domainMax;\n    if (_.domainMid != null) {\n      mid = _.domainMid;\n      var i = mid > domain[n] ? n + 1 : mid < domain[0] ? 0 : n;\n      if (i !== n) df.warn('Scale domainMid exceeds domain min or max.', mid);\n      domain.splice(i, 0, mid);\n    }\n  } // set the scale domain\n\n  scale.domain(domainCheck(type, domain, df)); // if ordinal scale domain is defined, prevent implicit\n  // domain construction as side-effect of scale lookup\n\n  if (type === Ordinal) {\n    scale.unknown(_.domainImplicit ? scaleImplicit : undefined);\n  } // perform 'nice' adjustment as requested\n\n  if (_.nice && scale.nice) {\n    scale.nice(_.nice !== true && tickCount(scale, _.nice) || null);\n  } // return the cardinality of the domain\n\n  return domain.length;\n}\nfunction rawDomain(scale, raw, df) {\n  if (raw) {\n    scale.domain(domainCheck(scale.type, raw, df));\n    return raw.length;\n  } else {\n    return -1;\n  }\n}\nfunction padDomain(type, domain, range, pad, exponent, constant) {\n  var span = Math.abs(peek(range) - range[0]),\n    frac = span / (span - 2 * pad),\n    d = type === Log ? zoomLog(domain, null, frac) : type === Sqrt ? zoomPow(domain, null, frac, 0.5) : type === Pow ? zoomPow(domain, null, frac, exponent || 1) : type === Symlog ? zoomSymlog(domain, null, frac, constant || 1) : zoomLinear(domain, null, frac);\n  domain = domain.slice();\n  domain[0] = d[0];\n  domain[domain.length - 1] = d[1];\n  return domain;\n}\nfunction domainCheck(type, domain, df) {\n  if (isLogarithmic(type)) {\n    // sum signs of domain values\n    // if all pos or all neg, abs(sum) === domain.length\n    var s = Math.abs(domain.reduce(function (s, v) {\n      return s + (v < 0 ? -1 : v > 0 ? 1 : 0);\n    }, 0));\n    if (s !== domain.length) {\n      df.warn('Log scale domain includes zero: ' + stringValue(domain));\n    }\n  }\n  return domain;\n}\nfunction configureBins(scale, _, count) {\n  var bins = _.bins;\n  if (bins && !isArray(bins)) {\n    // generate bin boundary array\n    var domain = scale.domain(),\n      lo = domain[0],\n      hi = peek(domain),\n      step = bins.step;\n    var start = bins.start == null ? lo : bins.start,\n      stop = bins.stop == null ? hi : bins.stop;\n    if (!step) error('Scale bins parameter missing step property.');\n    if (start < lo) start = step * Math.ceil(lo / step);\n    if (stop > hi) stop = step * Math.floor(hi / step);\n    bins = range(start, stop + step / 2, step);\n  }\n  if (bins) {\n    // assign bin boundaries to scale instance\n    scale.bins = bins;\n  } else if (scale.bins) {\n    // no current bins, remove bins if previously set\n    delete scale.bins;\n  } // special handling for bin-ordinal scales\n\n  if (scale.type === BinOrdinal) {\n    if (!bins) {\n      // the domain specifies the bins\n      scale.bins = scale.domain();\n    } else if (!_.domain && !_.domainRaw) {\n      // the bins specify the domain\n      scale.domain(bins);\n      count = bins.length;\n    }\n  } // return domain cardinality\n\n  return count;\n}\nfunction configureRange(scale, _, count) {\n  var type = scale.type,\n    round = _.round || false,\n    range = _.range; // if range step specified, calculate full range extent\n\n  if (_.rangeStep != null) {\n    range = configureRangeStep(type, _, count);\n  } // else if a range scheme is defined, use that\n  else if (_.scheme) {\n    range = configureScheme(type, _, count);\n    if (isFunction(range)) {\n      if (scale.interpolator) {\n        return scale.interpolator(range);\n      } else {\n        error(\"Scale type \".concat(type, \" does not support interpolating color schemes.\"));\n      }\n    }\n  } // given a range array for an interpolating scale, convert to interpolator\n\n  if (range && isInterpolating(type)) {\n    return scale.interpolator(interpolateColors(flip(range, _.reverse), _.interpolate, _.interpolateGamma));\n  } // configure rounding / interpolation\n\n  if (range && _.interpolate && scale.interpolate) {\n    scale.interpolate(interpolate(_.interpolate, _.interpolateGamma));\n  } else if (isFunction(scale.round)) {\n    scale.round(round);\n  } else if (isFunction(scale.rangeRound)) {\n    scale.interpolate(round ? interpolateRound : interpolate$1);\n  }\n  if (range) scale.range(flip(range, _.reverse));\n}\nfunction configureRangeStep(type, _, count) {\n  if (type !== Band && type !== Point) {\n    error('Only band and point scales support rangeStep.');\n  } // calculate full range based on requested step size and padding\n\n  var outer = (_.paddingOuter != null ? _.paddingOuter : _.padding) || 0,\n    inner = type === Point ? 1 : (_.paddingInner != null ? _.paddingInner : _.padding) || 0;\n  return [0, _.rangeStep * bandSpace(count, inner, outer)];\n}\nfunction configureScheme(type, _, count) {\n  var extent = _.schemeExtent,\n    name,\n    scheme$1;\n  if (isArray(_.scheme)) {\n    scheme$1 = interpolateColors(_.scheme, _.interpolate, _.interpolateGamma);\n  } else {\n    name = _.scheme.toLowerCase();\n    scheme$1 = scheme(name);\n    if (!scheme$1) error(\"Unrecognized scheme name: \".concat(_.scheme));\n  } // determine size for potential discrete range\n\n  count = type === Threshold ? count + 1 : type === BinOrdinal ? count - 1 : type === Quantile || type === Quantize ? +_.schemeCount || DEFAULT_COUNT : count; // adjust and/or quantize scheme as appropriate\n\n  return isInterpolating(type) ? adjustScheme(scheme$1, extent, _.reverse) : isFunction(scheme$1) ? quantizeInterpolator(adjustScheme(scheme$1, extent), count) : type === Ordinal ? scheme$1 : scheme$1.slice(0, count);\n}\nfunction adjustScheme(scheme, extent, reverse) {\n  return isFunction(scheme) && (extent || reverse) ? interpolateRange(scheme, flip(extent || [0, 1], reverse)) : scheme;\n}\nfunction flip(array, reverse) {\n  return reverse ? array.slice().reverse() : array;\n}\n\n/**\n * Sorts scenegraph items in the pulse source array.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator\n *   function for sorting tuples.\n */\n\nfunction SortItems(params) {\n  Transform.call(this, null, params);\n}\ninherits(SortItems, Transform, {\n  transform: function transform(_, pulse) {\n    var mod = _.modified('sort') || pulse.changed(pulse.ADD) || pulse.modified(_.sort.fields) || pulse.modified('datum');\n    if (mod) pulse.source.sort(stableCompare(_.sort));\n    this.modified(mod);\n    return pulse;\n  }\n});\nvar Zero = 'zero',\n  Center = 'center',\n  Normalize = 'normalize',\n  DefOutput = ['y0', 'y1'];\n/**\n * Stack layout for visualization elements.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to stack.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {function(object,object): number} [params.sort] - A comparator for stack sorting.\n * @param {string} [offset='zero'] - Stack baseline offset. One of 'zero', 'center', 'normalize'.\n */\n\nfunction Stack(params) {\n  Transform.call(this, null, params);\n}\nStack.Definition = {\n  'type': 'Stack',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'offset',\n    'type': 'enum',\n    'default': Zero,\n    'values': [Zero, Center, Normalize]\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': DefOutput\n  }]\n};\ninherits(Stack, Transform, {\n  transform: function transform(_, pulse) {\n    var as = _.as || DefOutput,\n      y0 = as[0],\n      y1 = as[1],\n      sort = stableCompare(_.sort),\n      field = _.field || one,\n      stack = _.offset === Center ? stackCenter : _.offset === Normalize ? stackNormalize : stackZero,\n      groups,\n      i,\n      n,\n      max; // partition, sum, and sort the stack groups\n\n    groups = partition(pulse.source, _.groupby, sort, field); // compute stack layouts per group\n\n    for (i = 0, n = groups.length, max = groups.max; i < n; ++i) {\n      stack(groups[i], max, field, y0, y1);\n    }\n    return pulse.reflow(_.modified()).modifies(as);\n  }\n});\nfunction stackCenter(group, max, field, y0, y1) {\n  var last = (max - group.sum) / 2,\n    m = group.length,\n    j = 0,\n    t;\n  for (; j < m; ++j) {\n    t = group[j];\n    t[y0] = last;\n    t[y1] = last += Math.abs(field(t));\n  }\n}\nfunction stackNormalize(group, max, field, y0, y1) {\n  var scale = 1 / group.sum,\n    last = 0,\n    m = group.length,\n    j = 0,\n    v = 0,\n    t;\n  for (; j < m; ++j) {\n    t = group[j];\n    t[y0] = last;\n    t[y1] = last = scale * (v += Math.abs(field(t)));\n  }\n}\nfunction stackZero(group, max, field, y0, y1) {\n  var lastPos = 0,\n    lastNeg = 0,\n    m = group.length,\n    j = 0,\n    v,\n    t;\n  for (; j < m; ++j) {\n    t = group[j];\n    v = +field(t);\n    if (v < 0) {\n      t[y0] = lastNeg;\n      t[y1] = lastNeg += v;\n    } else {\n      t[y0] = lastPos;\n      t[y1] = lastPos += v;\n    }\n  }\n}\nfunction partition(data, groupby, sort, field) {\n  var groups = [],\n    get = function get(f) {\n      return f(t);\n    },\n    map,\n    i,\n    n,\n    m,\n    t,\n    k,\n    g,\n    s,\n    max; // partition data points into stack groups\n\n  if (groupby == null) {\n    groups.push(data.slice());\n  } else {\n    for (map = {}, i = 0, n = data.length; i < n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n      if (!g) {\n        map[k] = g = [];\n        groups.push(g);\n      }\n      g.push(t);\n    }\n  } // compute sums of groups, sort groups as needed\n\n  for (k = 0, max = 0, m = groups.length; k < m; ++k) {\n    g = groups[k];\n    for (i = 0, s = 0, n = g.length; i < n; ++i) {\n      s += Math.abs(field(g[i]));\n    }\n    g.sum = s;\n    if (s > max) max = s;\n    if (sort) g.sort(sort);\n  }\n  groups.max = max;\n  return groups;\n}\nexport { AxisTicks as axisticks, DataJoin as datajoin, Encode as encode, LegendEntries as legendentries, LinkPath as linkpath, Pie as pie, Scale as scale, SortItems as sortitems, Stack as stack };","map":{"version":3,"names":["Transform","ingest","tupleid","stableCompare","tickCount","tickFormat","validTicks","tickValues","SymbolLegend","labelFormat","labelValues","GradientLegend","scaleFraction","labelFraction","scale","isContinuous","Sequential","Linear","Time","UTC","Pow","Sqrt","Ordinal","scaleImplicit","Log","Symlog","isLogarithmic","BinOrdinal","bandSpace","isInterpolating","interpolateRange","quantizeInterpolator","interpolateColors","interpolate","Band","Point","scheme","Threshold","Quantile","Quantize","Diverging","inherits","isArray","error","fastmap","falsy","isFunction","constant","peek","one","toSet","isString","zoomLog","zoomPow","zoomSymlog","zoomLinear","stringValue","sum","range","interpolateRound","interpolate$1","AxisTicks","params","call","transform","_","pulse","value","modified","StopPropagation","locale","dataflow","out","fork","NO_SOURCE","NO_FIELDS","ticks","tally","count","values","length","minstep","format","formatSpecifier","formatType","rem","map","i","index","label","extra","push","source","add","DataJoin","defaultItemCreate","newMap","key","test","t","exit","lookup","get","df","item","encode","addAll","visit","ADD","k","x","empty","mod","set","datum","MOD","REM","changed","ADD_MOD","modifies","clean","cleanThreshold","runAfter","Encode","ADD_REM","fmod","encoders","every","e","reenter","update","enter","output","flag","REFLOW","LegendEntries","items","type","limit","lskip","domain","fraction","size","offset","ellipsis","warn","slice","reduce","max","Math","concat","perc","perc2","sourceX","sourceY","y","targetX","target","targetY","LinkPath","Definition","sx","sy","tx","ty","as","orient","shape","path","Paths","SOURCE","reflow","line","lineR","sa","sr","ta","tr","cos","sin","arc","dx","dy","rr","sqrt","ra","atan2","PI","arcR","curve","ix","iy","curveR","orthoX","orthoY","orthoR","sc","ss","tc","ts","sf","abs","diagonalX","m","diagonalY","diagonalR","mr","Pie","startAngle","endAngle","field","start","stop","data","n","a","v","sort","b","DEFAULT_COUNT","includeZero","bins","includePad","SKIP","Scale","scale$1","scaleKey","configureRange","configureBins","configureDomain","d","isContinuousColor","rawDomain","domainMid","toLowerCase","raw","domainRaw","zero","undefined","mid","padding","padDomain","exponent","domainMin","domainMax","splice","domainCheck","unknown","domainImplicit","nice","pad","span","frac","s","lo","hi","step","ceil","floor","round","rangeStep","configureRangeStep","configureScheme","interpolator","flip","reverse","interpolateGamma","rangeRound","outer","paddingOuter","inner","paddingInner","extent","schemeExtent","name","scheme$1","schemeCount","adjustScheme","array","SortItems","fields","Zero","Center","Normalize","DefOutput","Stack","y0","y1","stack","stackCenter","stackNormalize","stackZero","groups","partition","groupby","group","last","j","lastPos","lastNeg","f","g","axisticks","datajoin","legendentries","linkpath","pie","sortitems"],"sources":["/Users/weihangzhang/Documents/webpage/gosling-react/node_modules/vega-encode/build/vega-encode.module.js"],"sourcesContent":["import { Transform, ingest, tupleid, stableCompare } from 'vega-dataflow';\nimport { tickCount, tickFormat, validTicks, tickValues, SymbolLegend, labelFormat, labelValues, GradientLegend, scaleFraction, labelFraction, scale, isContinuous, Sequential, Linear, Time, UTC, Pow, Sqrt, Ordinal, scaleImplicit, Log, Symlog, isLogarithmic, BinOrdinal, bandSpace, isInterpolating, interpolateRange, quantizeInterpolator, interpolateColors, interpolate, Band, Point, scheme, Threshold, Quantile, Quantize, Diverging } from 'vega-scale';\nimport { inherits, isArray, error, fastmap, falsy, isFunction, constant, peek, one, toSet, isString, zoomLog, zoomPow, zoomSymlog, zoomLinear, stringValue } from 'vega-util';\nimport { sum, range } from 'd3-array';\nimport { interpolateRound, interpolate as interpolate$1 } from 'd3-interpolate';\n\n/**\n * Generates axis ticks for visualizing a spatial scale.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Scale} params.scale - The scale to generate ticks for.\n * @param {*} [params.count=10] - The approximate number of ticks, or\n *   desired tick interval, to use.\n * @param {Array<*>} [params.values] - The exact tick values to use.\n *   These must be legal domain values for the provided scale.\n *   If provided, the count argument is ignored.\n * @param {function(*):string} [params.formatSpecifier] - A format specifier\n *   to use in conjunction with scale.tickFormat. Legal values are\n *   any valid d3 4.0 format specifier.\n * @param {function(*):string} [params.format] - The format function to use.\n *   If provided, the formatSpecifier argument is ignored.\n */\n\nfunction AxisTicks(params) {\n  Transform.call(this, null, params);\n}\ninherits(AxisTicks, Transform, {\n  transform(_, pulse) {\n    if (this.value && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n\n    var locale = pulse.dataflow.locale(),\n        out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n        ticks = this.value,\n        scale = _.scale,\n        tally = _.count == null ? _.values ? _.values.length : 10 : _.count,\n        count = tickCount(scale, tally, _.minstep),\n        format = _.format || tickFormat(locale, scale, count, _.formatSpecifier, _.formatType, !!_.values),\n        values = _.values ? validTicks(scale, _.values, count) : tickValues(scale, count);\n    if (ticks) out.rem = ticks;\n    ticks = values.map((value, i) => ingest({\n      index: i / (values.length - 1 || 1),\n      value: value,\n      label: format(value)\n    }));\n\n    if (_.extra && ticks.length) {\n      // add an extra tick pegged to the initial domain value\n      // this is used to generate axes with 'binned' domains\n      ticks.push(ingest({\n        index: -1,\n        extra: {\n          value: ticks[0].value\n        },\n        label: ''\n      }));\n    }\n\n    out.source = ticks;\n    out.add = ticks;\n    this.value = ticks;\n    return out;\n  }\n\n});\n\n/**\n * Joins a set of data elements against a set of visual items.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): object} [params.item] - An item generator function.\n * @param {function(object): *} [params.key] - The key field associating data and visual items.\n */\n\nfunction DataJoin(params) {\n  Transform.call(this, null, params);\n}\n\nfunction defaultItemCreate() {\n  return ingest({});\n}\n\nfunction newMap(key) {\n  const map = fastmap().test(t => t.exit);\n\n  map.lookup = t => map.get(key(t));\n\n  return map;\n}\n\ninherits(DataJoin, Transform, {\n  transform(_, pulse) {\n    var df = pulse.dataflow,\n        out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n        item = _.item || defaultItemCreate,\n        key = _.key || tupleid,\n        map = this.value; // prevent transient (e.g., hover) requests from\n    // cascading across marks derived from marks\n\n    if (isArray(out.encode)) {\n      out.encode = null;\n    }\n\n    if (map && (_.modified('key') || pulse.modified(key))) {\n      error('DataJoin does not support modified key function or fields.');\n    }\n\n    if (!map) {\n      pulse = pulse.addAll();\n      this.value = map = newMap(key);\n    }\n\n    pulse.visit(pulse.ADD, t => {\n      const k = key(t);\n      let x = map.get(k);\n\n      if (x) {\n        if (x.exit) {\n          map.empty--;\n          out.add.push(x);\n        } else {\n          out.mod.push(x);\n        }\n      } else {\n        x = item(t);\n        map.set(k, x);\n        out.add.push(x);\n      }\n\n      x.datum = t;\n      x.exit = false;\n    });\n    pulse.visit(pulse.MOD, t => {\n      const k = key(t),\n            x = map.get(k);\n\n      if (x) {\n        x.datum = t;\n        out.mod.push(x);\n      }\n    });\n    pulse.visit(pulse.REM, t => {\n      const k = key(t),\n            x = map.get(k);\n\n      if (t === x.datum && !x.exit) {\n        out.rem.push(x);\n        x.exit = true;\n        ++map.empty;\n      }\n    });\n    if (pulse.changed(pulse.ADD_MOD)) out.modifies('datum');\n\n    if (pulse.clean() || _.clean && map.empty > df.cleanThreshold) {\n      df.runAfter(map.clean);\n    }\n\n    return out;\n  }\n\n});\n\n/**\n * Invokes encoding functions for visual items.\n * @constructor\n * @param {object} params - The parameters to the encoding functions. This\n *   parameter object will be passed through to all invoked encoding functions.\n * @param {object} [params.mod=false] - Flag indicating if tuples in the input\n *   mod set that are unmodified by encoders should be included in the output.\n * @param {object} param.encoders - The encoding functions\n * @param {function(object, object): boolean} [param.encoders.update] - Update encoding set\n * @param {function(object, object): boolean} [param.encoders.enter] - Enter encoding set\n * @param {function(object, object): boolean} [param.encoders.exit] - Exit encoding set\n */\n\nfunction Encode(params) {\n  Transform.call(this, null, params);\n}\ninherits(Encode, Transform, {\n  transform(_, pulse) {\n    var out = pulse.fork(pulse.ADD_REM),\n        fmod = _.mod || false,\n        encoders = _.encoders,\n        encode = pulse.encode; // if an array, the encode directive includes additional sets\n    // that must be defined in order for the primary set to be invoked\n    // e.g., only run the update set if the hover set is defined\n\n    if (isArray(encode)) {\n      if (out.changed() || encode.every(e => encoders[e])) {\n        encode = encode[0];\n        out.encode = null; // consume targeted encode directive\n      } else {\n        return pulse.StopPropagation;\n      }\n    } // marshall encoder functions\n\n\n    var reenter = encode === 'enter',\n        update = encoders.update || falsy,\n        enter = encoders.enter || falsy,\n        exit = encoders.exit || falsy,\n        set = (encode && !reenter ? encoders[encode] : update) || falsy;\n\n    if (pulse.changed(pulse.ADD)) {\n      pulse.visit(pulse.ADD, t => {\n        enter(t, _);\n        update(t, _);\n      });\n      out.modifies(enter.output);\n      out.modifies(update.output);\n\n      if (set !== falsy && set !== update) {\n        pulse.visit(pulse.ADD, t => {\n          set(t, _);\n        });\n        out.modifies(set.output);\n      }\n    }\n\n    if (pulse.changed(pulse.REM) && exit !== falsy) {\n      pulse.visit(pulse.REM, t => {\n        exit(t, _);\n      });\n      out.modifies(exit.output);\n    }\n\n    if (reenter || set !== falsy) {\n      const flag = pulse.MOD | (_.modified() ? pulse.REFLOW : 0);\n\n      if (reenter) {\n        pulse.visit(flag, t => {\n          const mod = enter(t, _) || fmod;\n          if (set(t, _) || mod) out.mod.push(t);\n        });\n        if (out.mod.length) out.modifies(enter.output);\n      } else {\n        pulse.visit(flag, t => {\n          if (set(t, _) || fmod) out.mod.push(t);\n        });\n      }\n\n      if (out.mod.length) out.modifies(set.output);\n    }\n\n    return out.changed() ? out : pulse.StopPropagation;\n  }\n\n});\n\n/**\n * Generates legend entries for visualizing a scale.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Scale} params.scale - The scale to generate items for.\n * @param {*} [params.count=5] - The approximate number of items, or\n *   desired tick interval, to use.\n * @param {*} [params.limit] - The maximum number of entries to\n *   include in a symbol legend.\n * @param {Array<*>} [params.values] - The exact tick values to use.\n *   These must be legal domain values for the provided scale.\n *   If provided, the count argument is ignored.\n * @param {string} [params.formatSpecifier] - A format specifier\n *   to use in conjunction with scale.tickFormat. Legal values are\n *   any valid D3 format specifier string.\n * @param {function(*):string} [params.format] - The format function to use.\n *   If provided, the formatSpecifier argument is ignored.\n */\n\nfunction LegendEntries(params) {\n  Transform.call(this, [], params);\n}\ninherits(LegendEntries, Transform, {\n  transform(_, pulse) {\n    if (this.value != null && !_.modified()) {\n      return pulse.StopPropagation;\n    }\n\n    var locale = pulse.dataflow.locale(),\n        out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n        items = this.value,\n        type = _.type || SymbolLegend,\n        scale = _.scale,\n        limit = +_.limit,\n        count = tickCount(scale, _.count == null ? 5 : _.count, _.minstep),\n        lskip = !!_.values || type === SymbolLegend,\n        format = _.format || labelFormat(locale, scale, count, type, _.formatSpecifier, _.formatType, lskip),\n        values = _.values || labelValues(scale, count),\n        domain,\n        fraction,\n        size,\n        offset,\n        ellipsis;\n    if (items) out.rem = items;\n\n    if (type === SymbolLegend) {\n      if (limit && values.length > limit) {\n        pulse.dataflow.warn('Symbol legend count exceeds limit, filtering items.');\n        items = values.slice(0, limit - 1);\n        ellipsis = true;\n      } else {\n        items = values;\n      }\n\n      if (isFunction(size = _.size)) {\n        // if first value maps to size zero, remove from list (vega#717)\n        if (!_.values && scale(items[0]) === 0) {\n          items = items.slice(1);\n        } // compute size offset for legend entries\n\n\n        offset = items.reduce((max, value) => Math.max(max, size(value, _)), 0);\n      } else {\n        size = constant(offset = size || 8);\n      }\n\n      items = items.map((value, index) => ingest({\n        index: index,\n        label: format(value, index, items),\n        value: value,\n        offset: offset,\n        size: size(value, _)\n      }));\n\n      if (ellipsis) {\n        ellipsis = values[items.length];\n        items.push(ingest({\n          index: items.length,\n          label: \"\\u2026\".concat(values.length - items.length, \" entries\"),\n          value: ellipsis,\n          offset: offset,\n          size: size(ellipsis, _)\n        }));\n      }\n    } else if (type === GradientLegend) {\n      domain = scale.domain(), fraction = scaleFraction(scale, domain[0], peek(domain)); // if automatic label generation produces 2 or fewer values,\n      // use the domain end points instead (fixes vega/vega#1364)\n\n      if (values.length < 3 && !_.values && domain[0] !== peek(domain)) {\n        values = [domain[0], peek(domain)];\n      }\n\n      items = values.map((value, index) => ingest({\n        index: index,\n        label: format(value, index, values),\n        value: value,\n        perc: fraction(value)\n      }));\n    } else {\n      size = values.length - 1;\n      fraction = labelFraction(scale);\n      items = values.map((value, index) => ingest({\n        index: index,\n        label: format(value, index, values),\n        value: value,\n        perc: index ? fraction(value) : 0,\n        perc2: index === size ? 1 : fraction(values[index + 1])\n      }));\n    }\n\n    out.source = items;\n    out.add = items;\n    this.value = items;\n    return out;\n  }\n\n});\n\nconst sourceX = t => t.source.x;\n\nconst sourceY = t => t.source.y;\n\nconst targetX = t => t.target.x;\n\nconst targetY = t => t.target.y;\n/**\n * Layout paths linking source and target elements.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\n\nfunction LinkPath(params) {\n  Transform.call(this, {}, params);\n}\nLinkPath.Definition = {\n  'type': 'LinkPath',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'sourceX',\n    'type': 'field',\n    'default': 'source.x'\n  }, {\n    'name': 'sourceY',\n    'type': 'field',\n    'default': 'source.y'\n  }, {\n    'name': 'targetX',\n    'type': 'field',\n    'default': 'target.x'\n  }, {\n    'name': 'targetY',\n    'type': 'field',\n    'default': 'target.y'\n  }, {\n    'name': 'orient',\n    'type': 'enum',\n    'default': 'vertical',\n    'values': ['horizontal', 'vertical', 'radial']\n  }, {\n    'name': 'shape',\n    'type': 'enum',\n    'default': 'line',\n    'values': ['line', 'arc', 'curve', 'diagonal', 'orthogonal']\n  }, {\n    'name': 'require',\n    'type': 'signal'\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'default': 'path'\n  }]\n};\ninherits(LinkPath, Transform, {\n  transform(_, pulse) {\n    var sx = _.sourceX || sourceX,\n        sy = _.sourceY || sourceY,\n        tx = _.targetX || targetX,\n        ty = _.targetY || targetY,\n        as = _.as || 'path',\n        orient = _.orient || 'vertical',\n        shape = _.shape || 'line',\n        path = Paths.get(shape + '-' + orient) || Paths.get(shape);\n\n    if (!path) {\n      error('LinkPath unsupported type: ' + _.shape + (_.orient ? '-' + _.orient : ''));\n    }\n\n    pulse.visit(pulse.SOURCE, t => {\n      t[as] = path(sx(t), sy(t), tx(t), ty(t));\n    });\n    return pulse.reflow(_.modified()).modifies(as);\n  }\n\n});\n\nconst line = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'L' + tx + ',' + ty;\n\nconst lineR = (sa, sr, ta, tr) => line(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));\n\nconst arc = (sx, sy, tx, ty) => {\n  var dx = tx - sx,\n      dy = ty - sy,\n      rr = Math.sqrt(dx * dx + dy * dy) / 2,\n      ra = 180 * Math.atan2(dy, dx) / Math.PI;\n  return 'M' + sx + ',' + sy + 'A' + rr + ',' + rr + ' ' + ra + ' 0 1' + ' ' + tx + ',' + ty;\n};\n\nconst arcR = (sa, sr, ta, tr) => arc(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));\n\nconst curve = (sx, sy, tx, ty) => {\n  const dx = tx - sx,\n        dy = ty - sy,\n        ix = 0.2 * (dx + dy),\n        iy = 0.2 * (dy - dx);\n  return 'M' + sx + ',' + sy + 'C' + (sx + ix) + ',' + (sy + iy) + ' ' + (tx + iy) + ',' + (ty - ix) + ' ' + tx + ',' + ty;\n};\n\nconst curveR = (sa, sr, ta, tr) => curve(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));\n\nconst orthoX = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'V' + ty + 'H' + tx;\n\nconst orthoY = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'H' + tx + 'V' + ty;\n\nconst orthoR = (sa, sr, ta, tr) => {\n  const sc = Math.cos(sa),\n        ss = Math.sin(sa),\n        tc = Math.cos(ta),\n        ts = Math.sin(ta),\n        sf = Math.abs(ta - sa) > Math.PI ? ta <= sa : ta > sa;\n  return 'M' + sr * sc + ',' + sr * ss + 'A' + sr + ',' + sr + ' 0 0,' + (sf ? 1 : 0) + ' ' + sr * tc + ',' + sr * ts + 'L' + tr * tc + ',' + tr * ts;\n};\n\nconst diagonalX = (sx, sy, tx, ty) => {\n  const m = (sx + tx) / 2;\n  return 'M' + sx + ',' + sy + 'C' + m + ',' + sy + ' ' + m + ',' + ty + ' ' + tx + ',' + ty;\n};\n\nconst diagonalY = (sx, sy, tx, ty) => {\n  const m = (sy + ty) / 2;\n  return 'M' + sx + ',' + sy + 'C' + sx + ',' + m + ' ' + tx + ',' + m + ' ' + tx + ',' + ty;\n};\n\nconst diagonalR = (sa, sr, ta, tr) => {\n  const sc = Math.cos(sa),\n        ss = Math.sin(sa),\n        tc = Math.cos(ta),\n        ts = Math.sin(ta),\n        mr = (sr + tr) / 2;\n  return 'M' + sr * sc + ',' + sr * ss + 'C' + mr * sc + ',' + mr * ss + ' ' + mr * tc + ',' + mr * ts + ' ' + tr * tc + ',' + tr * ts;\n};\n\nconst Paths = fastmap({\n  'line': line,\n  'line-radial': lineR,\n  'arc': arc,\n  'arc-radial': arcR,\n  'curve': curve,\n  'curve-radial': curveR,\n  'orthogonal-horizontal': orthoX,\n  'orthogonal-vertical': orthoY,\n  'orthogonal-radial': orthoR,\n  'diagonal-horizontal': diagonalX,\n  'diagonal-vertical': diagonalY,\n  'diagonal-radial': diagonalR\n});\n\n/**\n * Pie and donut chart layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size pie segments.\n * @param {number} [params.startAngle=0] - The start angle (in radians) of the layout.\n * @param {number} [params.endAngle=2π] - The end angle (in radians) of the layout.\n * @param {boolean} [params.sort] - Boolean flag for sorting sectors by value.\n */\n\nfunction Pie(params) {\n  Transform.call(this, null, params);\n}\nPie.Definition = {\n  'type': 'Pie',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'startAngle',\n    'type': 'number',\n    'default': 0\n  }, {\n    'name': 'endAngle',\n    'type': 'number',\n    'default': 6.283185307179586\n  }, {\n    'name': 'sort',\n    'type': 'boolean',\n    'default': false\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': ['startAngle', 'endAngle']\n  }]\n};\ninherits(Pie, Transform, {\n  transform(_, pulse) {\n    var as = _.as || ['startAngle', 'endAngle'],\n        startAngle = as[0],\n        endAngle = as[1],\n        field = _.field || one,\n        start = _.startAngle || 0,\n        stop = _.endAngle != null ? _.endAngle : 2 * Math.PI,\n        data = pulse.source,\n        values = data.map(field),\n        n = values.length,\n        a = start,\n        k = (stop - start) / sum(values),\n        index = range(n),\n        i,\n        t,\n        v;\n\n    if (_.sort) {\n      index.sort((a, b) => values[a] - values[b]);\n    }\n\n    for (i = 0; i < n; ++i) {\n      v = values[index[i]];\n      t = data[index[i]];\n      t[startAngle] = a;\n      t[endAngle] = a += v * k;\n    }\n\n    this.value = values;\n    return pulse.reflow(_.modified()).modifies(as);\n  }\n\n});\n\nconst DEFAULT_COUNT = 5;\n\nfunction includeZero(scale) {\n  const type = scale.type;\n  return !scale.bins && (type === Linear || type === Pow || type === Sqrt);\n}\n\nfunction includePad(type) {\n  return isContinuous(type) && type !== Sequential;\n}\n\nconst SKIP = toSet(['set', 'modified', 'clear', 'type', 'scheme', 'schemeExtent', 'schemeCount', 'domain', 'domainMin', 'domainMid', 'domainMax', 'domainRaw', 'domainImplicit', 'nice', 'zero', 'bins', 'range', 'rangeStep', 'round', 'reverse', 'interpolate', 'interpolateGamma']);\n/**\n * Maintains a scale function mapping data values to visual channels.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nfunction Scale(params) {\n  Transform.call(this, null, params);\n  this.modified(true); // always treat as modified\n}\ninherits(Scale, Transform, {\n  transform(_, pulse) {\n    var df = pulse.dataflow,\n        scale$1 = this.value,\n        key = scaleKey(_);\n\n    if (!scale$1 || key !== scale$1.type) {\n      this.value = scale$1 = scale(key)();\n    }\n\n    for (key in _) if (!SKIP[key]) {\n      // padding is a scale property for band/point but not others\n      if (key === 'padding' && includePad(scale$1.type)) continue; // invoke scale property setter, raise warning if not found\n\n      isFunction(scale$1[key]) ? scale$1[key](_[key]) : df.warn('Unsupported scale property: ' + key);\n    }\n\n    configureRange(scale$1, _, configureBins(scale$1, _, configureDomain(scale$1, _, df)));\n    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n  }\n\n});\n\nfunction scaleKey(_) {\n  var t = _.type,\n      d = '',\n      n; // backwards compatibility pre Vega 5.\n\n  if (t === Sequential) return Sequential + '-' + Linear;\n\n  if (isContinuousColor(_)) {\n    n = _.rawDomain ? _.rawDomain.length : _.domain ? _.domain.length + +(_.domainMid != null) : 0;\n    d = n === 2 ? Sequential + '-' : n === 3 ? Diverging + '-' : '';\n  }\n\n  return (d + t || Linear).toLowerCase();\n}\n\nfunction isContinuousColor(_) {\n  const t = _.type;\n  return isContinuous(t) && t !== Time && t !== UTC && (_.scheme || _.range && _.range.length && _.range.every(isString));\n}\n\nfunction configureDomain(scale, _, df) {\n  // check raw domain, if provided use that and exit early\n  const raw = rawDomain(scale, _.domainRaw, df);\n  if (raw > -1) return raw;\n  var domain = _.domain,\n      type = scale.type,\n      zero = _.zero || _.zero === undefined && includeZero(scale),\n      n,\n      mid;\n  if (!domain) return 0; // adjust continuous domain for minimum pixel padding\n\n  if (includePad(type) && _.padding && domain[0] !== peek(domain)) {\n    domain = padDomain(type, domain, _.range, _.padding, _.exponent, _.constant);\n  } // adjust domain based on zero, min, max settings\n\n\n  if (zero || _.domainMin != null || _.domainMax != null || _.domainMid != null) {\n    n = (domain = domain.slice()).length - 1 || 1;\n\n    if (zero) {\n      if (domain[0] > 0) domain[0] = 0;\n      if (domain[n] < 0) domain[n] = 0;\n    }\n\n    if (_.domainMin != null) domain[0] = _.domainMin;\n    if (_.domainMax != null) domain[n] = _.domainMax;\n\n    if (_.domainMid != null) {\n      mid = _.domainMid;\n      const i = mid > domain[n] ? n + 1 : mid < domain[0] ? 0 : n;\n      if (i !== n) df.warn('Scale domainMid exceeds domain min or max.', mid);\n      domain.splice(i, 0, mid);\n    }\n  } // set the scale domain\n\n\n  scale.domain(domainCheck(type, domain, df)); // if ordinal scale domain is defined, prevent implicit\n  // domain construction as side-effect of scale lookup\n\n  if (type === Ordinal) {\n    scale.unknown(_.domainImplicit ? scaleImplicit : undefined);\n  } // perform 'nice' adjustment as requested\n\n\n  if (_.nice && scale.nice) {\n    scale.nice(_.nice !== true && tickCount(scale, _.nice) || null);\n  } // return the cardinality of the domain\n\n\n  return domain.length;\n}\n\nfunction rawDomain(scale, raw, df) {\n  if (raw) {\n    scale.domain(domainCheck(scale.type, raw, df));\n    return raw.length;\n  } else {\n    return -1;\n  }\n}\n\nfunction padDomain(type, domain, range, pad, exponent, constant) {\n  var span = Math.abs(peek(range) - range[0]),\n      frac = span / (span - 2 * pad),\n      d = type === Log ? zoomLog(domain, null, frac) : type === Sqrt ? zoomPow(domain, null, frac, 0.5) : type === Pow ? zoomPow(domain, null, frac, exponent || 1) : type === Symlog ? zoomSymlog(domain, null, frac, constant || 1) : zoomLinear(domain, null, frac);\n  domain = domain.slice();\n  domain[0] = d[0];\n  domain[domain.length - 1] = d[1];\n  return domain;\n}\n\nfunction domainCheck(type, domain, df) {\n  if (isLogarithmic(type)) {\n    // sum signs of domain values\n    // if all pos or all neg, abs(sum) === domain.length\n    var s = Math.abs(domain.reduce((s, v) => s + (v < 0 ? -1 : v > 0 ? 1 : 0), 0));\n\n    if (s !== domain.length) {\n      df.warn('Log scale domain includes zero: ' + stringValue(domain));\n    }\n  }\n\n  return domain;\n}\n\nfunction configureBins(scale, _, count) {\n  let bins = _.bins;\n\n  if (bins && !isArray(bins)) {\n    // generate bin boundary array\n    const domain = scale.domain(),\n          lo = domain[0],\n          hi = peek(domain),\n          step = bins.step;\n    let start = bins.start == null ? lo : bins.start,\n        stop = bins.stop == null ? hi : bins.stop;\n    if (!step) error('Scale bins parameter missing step property.');\n    if (start < lo) start = step * Math.ceil(lo / step);\n    if (stop > hi) stop = step * Math.floor(hi / step);\n    bins = range(start, stop + step / 2, step);\n  }\n\n  if (bins) {\n    // assign bin boundaries to scale instance\n    scale.bins = bins;\n  } else if (scale.bins) {\n    // no current bins, remove bins if previously set\n    delete scale.bins;\n  } // special handling for bin-ordinal scales\n\n\n  if (scale.type === BinOrdinal) {\n    if (!bins) {\n      // the domain specifies the bins\n      scale.bins = scale.domain();\n    } else if (!_.domain && !_.domainRaw) {\n      // the bins specify the domain\n      scale.domain(bins);\n      count = bins.length;\n    }\n  } // return domain cardinality\n\n\n  return count;\n}\n\nfunction configureRange(scale, _, count) {\n  var type = scale.type,\n      round = _.round || false,\n      range = _.range; // if range step specified, calculate full range extent\n\n  if (_.rangeStep != null) {\n    range = configureRangeStep(type, _, count);\n  } // else if a range scheme is defined, use that\n  else if (_.scheme) {\n    range = configureScheme(type, _, count);\n\n    if (isFunction(range)) {\n      if (scale.interpolator) {\n        return scale.interpolator(range);\n      } else {\n        error(\"Scale type \".concat(type, \" does not support interpolating color schemes.\"));\n      }\n    }\n  } // given a range array for an interpolating scale, convert to interpolator\n\n\n  if (range && isInterpolating(type)) {\n    return scale.interpolator(interpolateColors(flip(range, _.reverse), _.interpolate, _.interpolateGamma));\n  } // configure rounding / interpolation\n\n\n  if (range && _.interpolate && scale.interpolate) {\n    scale.interpolate(interpolate(_.interpolate, _.interpolateGamma));\n  } else if (isFunction(scale.round)) {\n    scale.round(round);\n  } else if (isFunction(scale.rangeRound)) {\n    scale.interpolate(round ? interpolateRound : interpolate$1);\n  }\n\n  if (range) scale.range(flip(range, _.reverse));\n}\n\nfunction configureRangeStep(type, _, count) {\n  if (type !== Band && type !== Point) {\n    error('Only band and point scales support rangeStep.');\n  } // calculate full range based on requested step size and padding\n\n\n  var outer = (_.paddingOuter != null ? _.paddingOuter : _.padding) || 0,\n      inner = type === Point ? 1 : (_.paddingInner != null ? _.paddingInner : _.padding) || 0;\n  return [0, _.rangeStep * bandSpace(count, inner, outer)];\n}\n\nfunction configureScheme(type, _, count) {\n  var extent = _.schemeExtent,\n      name,\n      scheme$1;\n\n  if (isArray(_.scheme)) {\n    scheme$1 = interpolateColors(_.scheme, _.interpolate, _.interpolateGamma);\n  } else {\n    name = _.scheme.toLowerCase();\n    scheme$1 = scheme(name);\n    if (!scheme$1) error(\"Unrecognized scheme name: \".concat(_.scheme));\n  } // determine size for potential discrete range\n\n\n  count = type === Threshold ? count + 1 : type === BinOrdinal ? count - 1 : type === Quantile || type === Quantize ? +_.schemeCount || DEFAULT_COUNT : count; // adjust and/or quantize scheme as appropriate\n\n  return isInterpolating(type) ? adjustScheme(scheme$1, extent, _.reverse) : isFunction(scheme$1) ? quantizeInterpolator(adjustScheme(scheme$1, extent), count) : type === Ordinal ? scheme$1 : scheme$1.slice(0, count);\n}\n\nfunction adjustScheme(scheme, extent, reverse) {\n  return isFunction(scheme) && (extent || reverse) ? interpolateRange(scheme, flip(extent || [0, 1], reverse)) : scheme;\n}\n\nfunction flip(array, reverse) {\n  return reverse ? array.slice().reverse() : array;\n}\n\n/**\n * Sorts scenegraph items in the pulse source array.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator\n *   function for sorting tuples.\n */\n\nfunction SortItems(params) {\n  Transform.call(this, null, params);\n}\ninherits(SortItems, Transform, {\n  transform(_, pulse) {\n    const mod = _.modified('sort') || pulse.changed(pulse.ADD) || pulse.modified(_.sort.fields) || pulse.modified('datum');\n    if (mod) pulse.source.sort(stableCompare(_.sort));\n    this.modified(mod);\n    return pulse;\n  }\n\n});\n\nconst Zero = 'zero',\n      Center = 'center',\n      Normalize = 'normalize',\n      DefOutput = ['y0', 'y1'];\n/**\n * Stack layout for visualization elements.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to stack.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {function(object,object): number} [params.sort] - A comparator for stack sorting.\n * @param {string} [offset='zero'] - Stack baseline offset. One of 'zero', 'center', 'normalize'.\n */\n\nfunction Stack(params) {\n  Transform.call(this, null, params);\n}\nStack.Definition = {\n  'type': 'Stack',\n  'metadata': {\n    'modifies': true\n  },\n  'params': [{\n    'name': 'field',\n    'type': 'field'\n  }, {\n    'name': 'groupby',\n    'type': 'field',\n    'array': true\n  }, {\n    'name': 'sort',\n    'type': 'compare'\n  }, {\n    'name': 'offset',\n    'type': 'enum',\n    'default': Zero,\n    'values': [Zero, Center, Normalize]\n  }, {\n    'name': 'as',\n    'type': 'string',\n    'array': true,\n    'length': 2,\n    'default': DefOutput\n  }]\n};\ninherits(Stack, Transform, {\n  transform(_, pulse) {\n    var as = _.as || DefOutput,\n        y0 = as[0],\n        y1 = as[1],\n        sort = stableCompare(_.sort),\n        field = _.field || one,\n        stack = _.offset === Center ? stackCenter : _.offset === Normalize ? stackNormalize : stackZero,\n        groups,\n        i,\n        n,\n        max; // partition, sum, and sort the stack groups\n\n    groups = partition(pulse.source, _.groupby, sort, field); // compute stack layouts per group\n\n    for (i = 0, n = groups.length, max = groups.max; i < n; ++i) {\n      stack(groups[i], max, field, y0, y1);\n    }\n\n    return pulse.reflow(_.modified()).modifies(as);\n  }\n\n});\n\nfunction stackCenter(group, max, field, y0, y1) {\n  var last = (max - group.sum) / 2,\n      m = group.length,\n      j = 0,\n      t;\n\n  for (; j < m; ++j) {\n    t = group[j];\n    t[y0] = last;\n    t[y1] = last += Math.abs(field(t));\n  }\n}\n\nfunction stackNormalize(group, max, field, y0, y1) {\n  var scale = 1 / group.sum,\n      last = 0,\n      m = group.length,\n      j = 0,\n      v = 0,\n      t;\n\n  for (; j < m; ++j) {\n    t = group[j];\n    t[y0] = last;\n    t[y1] = last = scale * (v += Math.abs(field(t)));\n  }\n}\n\nfunction stackZero(group, max, field, y0, y1) {\n  var lastPos = 0,\n      lastNeg = 0,\n      m = group.length,\n      j = 0,\n      v,\n      t;\n\n  for (; j < m; ++j) {\n    t = group[j];\n    v = +field(t);\n\n    if (v < 0) {\n      t[y0] = lastNeg;\n      t[y1] = lastNeg += v;\n    } else {\n      t[y0] = lastPos;\n      t[y1] = lastPos += v;\n    }\n  }\n}\n\nfunction partition(data, groupby, sort, field) {\n  var groups = [],\n      get = f => f(t),\n      map,\n      i,\n      n,\n      m,\n      t,\n      k,\n      g,\n      s,\n      max; // partition data points into stack groups\n\n\n  if (groupby == null) {\n    groups.push(data.slice());\n  } else {\n    for (map = {}, i = 0, n = data.length; i < n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n\n      if (!g) {\n        map[k] = g = [];\n        groups.push(g);\n      }\n\n      g.push(t);\n    }\n  } // compute sums of groups, sort groups as needed\n\n\n  for (k = 0, max = 0, m = groups.length; k < m; ++k) {\n    g = groups[k];\n\n    for (i = 0, s = 0, n = g.length; i < n; ++i) {\n      s += Math.abs(field(g[i]));\n    }\n\n    g.sum = s;\n    if (s > max) max = s;\n    if (sort) g.sort(sort);\n  }\n\n  groups.max = max;\n  return groups;\n}\n\nexport { AxisTicks as axisticks, DataJoin as datajoin, Encode as encode, LegendEntries as legendentries, LinkPath as linkpath, Pie as pie, Scale as scale, SortItems as sortitems, Stack as stack };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}