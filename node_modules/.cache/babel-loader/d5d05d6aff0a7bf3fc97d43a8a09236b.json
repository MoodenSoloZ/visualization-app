{"ast":null,"code":"import _toConsumableArray from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _defineProperty from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nvar _ops;\nimport { bisector, union, intersection } from 'd3-array';\nimport { field, isDate, toNumber, isArray, inrange, extend, array, error, peek, hasOwnProperty } from 'vega-util';\nimport { Literal } from 'vega-expression';\nvar Intersect = 'intersect';\nvar Union = 'union';\nvar VlMulti = 'vlMulti';\nvar VlPoint = 'vlPoint';\nvar Or = 'or';\nvar And = 'and';\nvar SelectionId = '_vgsid_';\nvar $selectionId = field(SelectionId);\nvar TYPE_ENUM = 'E',\n  TYPE_RANGE_INC = 'R',\n  TYPE_RANGE_EXC = 'R-E',\n  TYPE_RANGE_LE = 'R-LE',\n  TYPE_RANGE_RE = 'R-RE',\n  UNIT_INDEX = 'index:unit'; // TODO: revisit date coercion?\n\nfunction testPoint(datum, entry) {\n  var fields = entry.fields,\n    values = entry.values,\n    n = fields.length,\n    i = 0,\n    dval,\n    f;\n  for (; i < n; ++i) {\n    f = fields[i];\n    f.getter = field.getter || field(f.field);\n    dval = f.getter(datum);\n    if (isDate(dval)) dval = toNumber(dval);\n    if (isDate(values[i])) values[i] = toNumber(values[i]);\n    if (isDate(values[i][0])) values[i] = values[i].map(toNumber);\n    if (f.type === TYPE_ENUM) {\n      // Enumerated fields can either specify individual values (single/multi selections)\n      // or an array of values (interval selections).\n      if (isArray(values[i]) ? values[i].indexOf(dval) < 0 : dval !== values[i]) {\n        return false;\n      }\n    } else {\n      if (f.type === TYPE_RANGE_INC) {\n        if (!inrange(dval, values[i])) return false;\n      } else if (f.type === TYPE_RANGE_RE) {\n        // Discrete selection of bins test within the range [bin_start, bin_end).\n        if (!inrange(dval, values[i], true, false)) return false;\n      } else if (f.type === TYPE_RANGE_EXC) {\n        // 'R-E'/'R-LE' included for completeness.\n        if (!inrange(dval, values[i], false, false)) return false;\n      } else if (f.type === TYPE_RANGE_LE) {\n        if (!inrange(dval, values[i], false, true)) return false;\n      }\n    }\n  }\n  return true;\n}\n/**\n * Tests if a tuple is contained within an interactive selection.\n * @param {string} name - The name of the data set representing the selection.\n *  Tuples in the dataset are of the form\n *  {unit: string, fields: array<fielddef>, values: array<*>}.\n *  Fielddef is of the form\n *  {field: string, channel: string, type: 'E' | 'R'} where\n *  'type' identifies whether tuples in the dataset enumerate\n *  values for the field, or specify a continuous range.\n * @param {object} datum - The tuple to test for inclusion.\n * @param {string} op - The set operation for combining selections.\n *   One of 'intersect' or 'union' (default).\n * @return {boolean} - True if the datum is in the selection, false otherwise.\n */\n\nfunction selectionTest(name, datum, op) {\n  var data = this.context.data[name],\n    entries = data ? data.values.value : [],\n    unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n    intersect = op === Intersect,\n    n = entries.length,\n    i = 0,\n    entry,\n    miss,\n    count,\n    unit,\n    b;\n  for (; i < n; ++i) {\n    entry = entries[i];\n    if (unitIdx && intersect) {\n      // multi selections union within the same unit and intersect across units.\n      miss = miss || {};\n      count = miss[unit = entry.unit] || 0; // if we've already matched this unit, skip.\n\n      if (count === -1) continue;\n      b = testPoint(datum, entry);\n      miss[unit] = b ? -1 : ++count; // if we match and there are no other units return true\n      // if we've missed against all tuples in this unit return false\n\n      if (b && unitIdx.size === 1) return true;\n      if (!b && count === unitIdx.get(unit).count) return false;\n    } else {\n      b = testPoint(datum, entry); // if we find a miss and we do require intersection return false\n      // if we find a match and we don't require intersection return true\n\n      if (intersect ^ b) return b;\n    }\n  } // if intersecting and we made it here, then we saw no misses\n  // if not intersecting, then we saw no matches\n  // if no active selections, return false\n\n  return n && intersect;\n}\nvar bisect = bisector($selectionId),\n  bisectLeft = bisect.left,\n  bisectRight = bisect.right;\nfunction selectionIdTest(name, datum, op) {\n  var data = this.context.data[name],\n    entries = data ? data.values.value : [],\n    unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n    intersect = op === Intersect,\n    value = $selectionId(datum),\n    index = bisectLeft(entries, value);\n  if (index === entries.length) return false;\n  if ($selectionId(entries[index]) !== value) return false;\n  if (unitIdx && intersect) {\n    if (unitIdx.size === 1) return true;\n    if (bisectRight(entries, value) - index < unitIdx.size) return false;\n  }\n  return true;\n}\n\n/**\n * Maps an array of scene graph items to an array of selection tuples.\n * @param {string} name  - The name of the dataset representing the selection.\n * @param {string} base  - The base object that generated tuples extend.\n *\n * @returns {array} An array of selection entries for the given unit.\n */\n\nfunction selectionTuples(array, base) {\n  return array.map(function (x) {\n    return extend(base.fields ? {\n      values: base.fields.map(function (f) {\n        return (f.getter || (f.getter = field(f.field)))(x.datum);\n      })\n    } : _defineProperty({}, SelectionId, $selectionId(x.datum)), base);\n  });\n}\n\n/**\n * Resolves selection for use as a scale domain or reads via the API.\n * @param {string} name - The name of the dataset representing the selection\n * @param {string} [op='union'] - The set operation for combining selections.\n *                 One of 'intersect' or 'union' (default).\n * @param {boolean} isMulti - Identifies a \"multi\" selection to perform more\n *                 expensive resolution computation.\n * @param {boolean} vl5 - With Vega-Lite v5, \"multi\" selections are now called \"point\"\n *                 selections, and thus the resolved tuple should reflect this name.\n *                 This parameter allows us to reflect this change without triggering\n *                 a major version bump for Vega.\n * @returns {object} An object of selected fields and values.\n */\n\nfunction selectionResolve(name, op, isMulti, vl5) {\n  var data = this.context.data[name],\n    entries = data ? data.values.value : [],\n    resolved = {},\n    multiRes = {},\n    types = {},\n    entry,\n    fields,\n    values,\n    unit,\n    field,\n    value,\n    res,\n    resUnit,\n    type,\n    union,\n    n = entries.length,\n    i = 0,\n    j,\n    m; // First union all entries within the same unit.\n\n  for (; i < n; ++i) {\n    entry = entries[i];\n    unit = entry.unit;\n    fields = entry.fields;\n    values = entry.values;\n    if (fields && values) {\n      // Intentional selection stores\n      for (j = 0, m = fields.length; j < m; ++j) {\n        field = fields[j];\n        res = resolved[field.field] || (resolved[field.field] = {});\n        resUnit = res[unit] || (res[unit] = []);\n        types[field.field] = type = field.type.charAt(0);\n        union = ops[\"\".concat(type, \"_union\")];\n        res[unit] = union(resUnit, array(values[j]));\n      } // If the same multi-selection is repeated over views and projected over\n      // an encoding, it may operate over different fields making it especially\n      // tricky to reliably resolve it. At best, we can de-dupe identical entries\n      // but doing so may be more computationally expensive than it is worth.\n      // Instead, for now, we simply transform our store representation into\n      // a more human-friendly one.\n\n      if (isMulti) {\n        resUnit = multiRes[unit] || (multiRes[unit] = []);\n        resUnit.push(array(values).reduce(function (obj, curr, j) {\n          return obj[fields[j].field] = curr, obj;\n        }, {}));\n      }\n    } else {\n      // Short circuit extensional selectionId stores which hold sorted IDs unique to each unit.\n      field = SelectionId;\n      value = $selectionId(entry);\n      res = resolved[field] || (resolved[field] = {});\n      resUnit = res[unit] || (res[unit] = []);\n      resUnit.push(value);\n      if (isMulti) {\n        resUnit = multiRes[unit] || (multiRes[unit] = []);\n        resUnit.push(_defineProperty({}, SelectionId, value));\n      }\n    }\n  } // Then resolve fields across units as per the op.\n\n  op = op || Union;\n  if (resolved[SelectionId]) {\n    resolved[SelectionId] = ops[\"\".concat(SelectionId, \"_\").concat(op)].apply(ops, _toConsumableArray(Object.values(resolved[SelectionId])));\n  } else {\n    Object.keys(resolved).forEach(function (field) {\n      resolved[field] = Object.keys(resolved[field]).map(function (unit) {\n        return resolved[field][unit];\n      }).reduce(function (acc, curr) {\n        return acc === undefined ? curr : ops[\"\".concat(types[field], \"_\").concat(op)](acc, curr);\n      });\n    });\n  }\n  entries = Object.keys(multiRes);\n  if (isMulti && entries.length) {\n    var key = vl5 ? VlPoint : VlMulti;\n    resolved[key] = op === Union ? _defineProperty({}, Or, entries.reduce(function (acc, k) {\n      return acc.push.apply(acc, _toConsumableArray(multiRes[k])), acc;\n    }, [])) : _defineProperty({}, And, entries.map(function (k) {\n      return _defineProperty({}, Or, multiRes[k]);\n    }));\n  }\n  return resolved;\n}\nvar ops = (_ops = {}, _defineProperty(_ops, \"\".concat(SelectionId, \"_union\"), union), _defineProperty(_ops, \"\".concat(SelectionId, \"_intersect\"), intersection), _defineProperty(_ops, \"E_union\", function E_union(base, value) {\n  if (!base.length) return value;\n  var i = 0,\n    n = value.length;\n  for (; i < n; ++i) {\n    if (base.indexOf(value[i]) < 0) base.push(value[i]);\n  }\n  return base;\n}), _defineProperty(_ops, \"E_intersect\", function E_intersect(base, value) {\n  return !base.length ? value : base.filter(function (v) {\n    return value.indexOf(v) >= 0;\n  });\n}), _defineProperty(_ops, \"R_union\", function R_union(base, value) {\n  var lo = toNumber(value[0]),\n    hi = toNumber(value[1]);\n  if (lo > hi) {\n    lo = value[1];\n    hi = value[0];\n  }\n  if (!base.length) return [lo, hi];\n  if (base[0] > lo) base[0] = lo;\n  if (base[1] < hi) base[1] = hi;\n  return base;\n}), _defineProperty(_ops, \"R_intersect\", function R_intersect(base, value) {\n  var lo = toNumber(value[0]),\n    hi = toNumber(value[1]);\n  if (lo > hi) {\n    lo = value[1];\n    hi = value[0];\n  }\n  if (!base.length) return [lo, hi];\n  if (hi < base[0] || base[1] < lo) {\n    return [];\n  } else {\n    if (base[0] < lo) base[0] = lo;\n    if (base[1] > hi) base[1] = hi;\n  }\n  return base;\n}), _ops);\nvar DataPrefix = ':',\n  IndexPrefix = '@';\nfunction selectionVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to selection functions must be a string literal.');\n  var data = args[0].value,\n    op = args.length >= 2 && peek(args).value,\n    field = 'unit',\n    indexName = IndexPrefix + field,\n    dataName = DataPrefix + data; // eslint-disable-next-line no-prototype-builtins\n\n  if (op === Intersect && !hasOwnProperty(params, indexName)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  } // eslint-disable-next-line no-prototype-builtins\n\n  if (!hasOwnProperty(params, dataName)) {\n    params[dataName] = scope.getData(data).tuplesRef();\n  }\n}\nexport { selectionIdTest, selectionResolve, selectionTest, selectionTuples, selectionVisitor };","map":{"version":3,"names":["bisector","union","intersection","field","isDate","toNumber","isArray","inrange","extend","array","error","peek","hasOwnProperty","Literal","Intersect","Union","VlMulti","VlPoint","Or","And","SelectionId","$selectionId","TYPE_ENUM","TYPE_RANGE_INC","TYPE_RANGE_EXC","TYPE_RANGE_LE","TYPE_RANGE_RE","UNIT_INDEX","testPoint","datum","entry","fields","values","n","length","i","dval","f","getter","map","type","indexOf","selectionTest","name","op","data","context","entries","value","unitIdx","undefined","intersect","miss","count","unit","b","size","get","bisect","bisectLeft","left","bisectRight","right","selectionIdTest","index","selectionTuples","base","x","selectionResolve","isMulti","vl5","resolved","multiRes","types","res","resUnit","j","m","charAt","ops","concat","push","reduce","obj","curr","Object","keys","forEach","acc","key","k","filter","v","lo","hi","DataPrefix","IndexPrefix","selectionVisitor","args","scope","params","indexName","dataName","getData","indataRef","tuplesRef"],"sources":["/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/vega-selections/build/vega-selection.module.js"],"sourcesContent":["import { bisector, union, intersection } from 'd3-array';\nimport { field, isDate, toNumber, isArray, inrange, extend, array, error, peek, hasOwnProperty } from 'vega-util';\nimport { Literal } from 'vega-expression';\n\nconst Intersect = 'intersect';\nconst Union = 'union';\nconst VlMulti = 'vlMulti';\nconst VlPoint = 'vlPoint';\nconst Or = 'or';\nconst And = 'and';\nconst SelectionId = '_vgsid_';\nconst $selectionId = field(SelectionId);\n\nconst TYPE_ENUM = 'E',\n      TYPE_RANGE_INC = 'R',\n      TYPE_RANGE_EXC = 'R-E',\n      TYPE_RANGE_LE = 'R-LE',\n      TYPE_RANGE_RE = 'R-RE',\n      UNIT_INDEX = 'index:unit'; // TODO: revisit date coercion?\n\nfunction testPoint(datum, entry) {\n  var fields = entry.fields,\n      values = entry.values,\n      n = fields.length,\n      i = 0,\n      dval,\n      f;\n\n  for (; i < n; ++i) {\n    f = fields[i];\n    f.getter = field.getter || field(f.field);\n    dval = f.getter(datum);\n    if (isDate(dval)) dval = toNumber(dval);\n    if (isDate(values[i])) values[i] = toNumber(values[i]);\n    if (isDate(values[i][0])) values[i] = values[i].map(toNumber);\n\n    if (f.type === TYPE_ENUM) {\n      // Enumerated fields can either specify individual values (single/multi selections)\n      // or an array of values (interval selections).\n      if (isArray(values[i]) ? values[i].indexOf(dval) < 0 : dval !== values[i]) {\n        return false;\n      }\n    } else {\n      if (f.type === TYPE_RANGE_INC) {\n        if (!inrange(dval, values[i])) return false;\n      } else if (f.type === TYPE_RANGE_RE) {\n        // Discrete selection of bins test within the range [bin_start, bin_end).\n        if (!inrange(dval, values[i], true, false)) return false;\n      } else if (f.type === TYPE_RANGE_EXC) {\n        // 'R-E'/'R-LE' included for completeness.\n        if (!inrange(dval, values[i], false, false)) return false;\n      } else if (f.type === TYPE_RANGE_LE) {\n        if (!inrange(dval, values[i], false, true)) return false;\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * Tests if a tuple is contained within an interactive selection.\n * @param {string} name - The name of the data set representing the selection.\n *  Tuples in the dataset are of the form\n *  {unit: string, fields: array<fielddef>, values: array<*>}.\n *  Fielddef is of the form\n *  {field: string, channel: string, type: 'E' | 'R'} where\n *  'type' identifies whether tuples in the dataset enumerate\n *  values for the field, or specify a continuous range.\n * @param {object} datum - The tuple to test for inclusion.\n * @param {string} op - The set operation for combining selections.\n *   One of 'intersect' or 'union' (default).\n * @return {boolean} - True if the datum is in the selection, false otherwise.\n */\n\n\nfunction selectionTest(name, datum, op) {\n  var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n      intersect = op === Intersect,\n      n = entries.length,\n      i = 0,\n      entry,\n      miss,\n      count,\n      unit,\n      b;\n\n  for (; i < n; ++i) {\n    entry = entries[i];\n\n    if (unitIdx && intersect) {\n      // multi selections union within the same unit and intersect across units.\n      miss = miss || {};\n      count = miss[unit = entry.unit] || 0; // if we've already matched this unit, skip.\n\n      if (count === -1) continue;\n      b = testPoint(datum, entry);\n      miss[unit] = b ? -1 : ++count; // if we match and there are no other units return true\n      // if we've missed against all tuples in this unit return false\n\n      if (b && unitIdx.size === 1) return true;\n      if (!b && count === unitIdx.get(unit).count) return false;\n    } else {\n      b = testPoint(datum, entry); // if we find a miss and we do require intersection return false\n      // if we find a match and we don't require intersection return true\n\n      if (intersect ^ b) return b;\n    }\n  } // if intersecting and we made it here, then we saw no misses\n  // if not intersecting, then we saw no matches\n  // if no active selections, return false\n\n\n  return n && intersect;\n}\nconst bisect = bisector($selectionId),\n      bisectLeft = bisect.left,\n      bisectRight = bisect.right;\nfunction selectionIdTest(name, datum, op) {\n  const data = this.context.data[name],\n        entries = data ? data.values.value : [],\n        unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n        intersect = op === Intersect,\n        value = $selectionId(datum),\n        index = bisectLeft(entries, value);\n  if (index === entries.length) return false;\n  if ($selectionId(entries[index]) !== value) return false;\n\n  if (unitIdx && intersect) {\n    if (unitIdx.size === 1) return true;\n    if (bisectRight(entries, value) - index < unitIdx.size) return false;\n  }\n\n  return true;\n}\n\n/**\n * Maps an array of scene graph items to an array of selection tuples.\n * @param {string} name  - The name of the dataset representing the selection.\n * @param {string} base  - The base object that generated tuples extend.\n *\n * @returns {array} An array of selection entries for the given unit.\n */\n\nfunction selectionTuples(array, base) {\n  return array.map(x => extend(base.fields ? {\n    values: base.fields.map(f => (f.getter || (f.getter = field(f.field)))(x.datum))\n  } : {\n    [SelectionId]: $selectionId(x.datum)\n  }, base));\n}\n\n/**\n * Resolves selection for use as a scale domain or reads via the API.\n * @param {string} name - The name of the dataset representing the selection\n * @param {string} [op='union'] - The set operation for combining selections.\n *                 One of 'intersect' or 'union' (default).\n * @param {boolean} isMulti - Identifies a \"multi\" selection to perform more\n *                 expensive resolution computation.\n * @param {boolean} vl5 - With Vega-Lite v5, \"multi\" selections are now called \"point\"\n *                 selections, and thus the resolved tuple should reflect this name.\n *                 This parameter allows us to reflect this change without triggering\n *                 a major version bump for Vega.\n * @returns {object} An object of selected fields and values.\n */\n\nfunction selectionResolve(name, op, isMulti, vl5) {\n  var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      resolved = {},\n      multiRes = {},\n      types = {},\n      entry,\n      fields,\n      values,\n      unit,\n      field,\n      value,\n      res,\n      resUnit,\n      type,\n      union,\n      n = entries.length,\n      i = 0,\n      j,\n      m; // First union all entries within the same unit.\n\n  for (; i < n; ++i) {\n    entry = entries[i];\n    unit = entry.unit;\n    fields = entry.fields;\n    values = entry.values;\n\n    if (fields && values) {\n      // Intentional selection stores\n      for (j = 0, m = fields.length; j < m; ++j) {\n        field = fields[j];\n        res = resolved[field.field] || (resolved[field.field] = {});\n        resUnit = res[unit] || (res[unit] = []);\n        types[field.field] = type = field.type.charAt(0);\n        union = ops[\"\".concat(type, \"_union\")];\n        res[unit] = union(resUnit, array(values[j]));\n      } // If the same multi-selection is repeated over views and projected over\n      // an encoding, it may operate over different fields making it especially\n      // tricky to reliably resolve it. At best, we can de-dupe identical entries\n      // but doing so may be more computationally expensive than it is worth.\n      // Instead, for now, we simply transform our store representation into\n      // a more human-friendly one.\n\n\n      if (isMulti) {\n        resUnit = multiRes[unit] || (multiRes[unit] = []);\n        resUnit.push(array(values).reduce((obj, curr, j) => (obj[fields[j].field] = curr, obj), {}));\n      }\n    } else {\n      // Short circuit extensional selectionId stores which hold sorted IDs unique to each unit.\n      field = SelectionId;\n      value = $selectionId(entry);\n      res = resolved[field] || (resolved[field] = {});\n      resUnit = res[unit] || (res[unit] = []);\n      resUnit.push(value);\n\n      if (isMulti) {\n        resUnit = multiRes[unit] || (multiRes[unit] = []);\n        resUnit.push({\n          [SelectionId]: value\n        });\n      }\n    }\n  } // Then resolve fields across units as per the op.\n\n\n  op = op || Union;\n\n  if (resolved[SelectionId]) {\n    resolved[SelectionId] = ops[\"\".concat(SelectionId, \"_\").concat(op)](...Object.values(resolved[SelectionId]));\n  } else {\n    Object.keys(resolved).forEach(field => {\n      resolved[field] = Object.keys(resolved[field]).map(unit => resolved[field][unit]).reduce((acc, curr) => acc === undefined ? curr : ops[\"\".concat(types[field], \"_\").concat(op)](acc, curr));\n    });\n  }\n\n  entries = Object.keys(multiRes);\n\n  if (isMulti && entries.length) {\n    const key = vl5 ? VlPoint : VlMulti;\n    resolved[key] = op === Union ? {\n      [Or]: entries.reduce((acc, k) => (acc.push(...multiRes[k]), acc), [])\n    } : {\n      [And]: entries.map(k => ({\n        [Or]: multiRes[k]\n      }))\n    };\n  }\n\n  return resolved;\n}\nvar ops = {\n  [\"\".concat(SelectionId, \"_union\")]: union,\n  [\"\".concat(SelectionId, \"_intersect\")]: intersection,\n  E_union: function (base, value) {\n    if (!base.length) return value;\n    var i = 0,\n        n = value.length;\n\n    for (; i < n; ++i) if (base.indexOf(value[i]) < 0) base.push(value[i]);\n\n    return base;\n  },\n  E_intersect: function (base, value) {\n    return !base.length ? value : base.filter(v => value.indexOf(v) >= 0);\n  },\n  R_union: function (base, value) {\n    var lo = toNumber(value[0]),\n        hi = toNumber(value[1]);\n\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n    if (base[0] > lo) base[0] = lo;\n    if (base[1] < hi) base[1] = hi;\n    return base;\n  },\n  R_intersect: function (base, value) {\n    var lo = toNumber(value[0]),\n        hi = toNumber(value[1]);\n\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n\n    if (hi < base[0] || base[1] < lo) {\n      return [];\n    } else {\n      if (base[0] < lo) base[0] = lo;\n      if (base[1] > hi) base[1] = hi;\n    }\n\n    return base;\n  }\n};\n\nconst DataPrefix = ':',\n      IndexPrefix = '@';\nfunction selectionVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to selection functions must be a string literal.');\n  const data = args[0].value,\n        op = args.length >= 2 && peek(args).value,\n        field = 'unit',\n        indexName = IndexPrefix + field,\n        dataName = DataPrefix + data; // eslint-disable-next-line no-prototype-builtins\n\n  if (op === Intersect && !hasOwnProperty(params, indexName)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  } // eslint-disable-next-line no-prototype-builtins\n\n\n  if (!hasOwnProperty(params, dataName)) {\n    params[dataName] = scope.getData(data).tuplesRef();\n  }\n}\n\nexport { selectionIdTest, selectionResolve, selectionTest, selectionTuples, selectionVisitor };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}