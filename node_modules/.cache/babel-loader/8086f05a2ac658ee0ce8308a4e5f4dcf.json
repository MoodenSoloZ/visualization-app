{"ast":null,"code":"import _classCallCheck from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _createForOfIteratorHelper from \"/Users/weihangzhang/Documents/webpage/visualization-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { isNumber, isString } from 'vega-util';\nimport { isMinMaxOp } from '../../aggregate';\nimport { getMainRangeChannel } from '../../channel';\nimport { isFieldDef, isFieldOrDatumDefForTimeFormat, isScaleFieldDef, isTypedFieldDef } from '../../channeldef';\nimport { isGenerator } from '../../data';\nimport { isDateTime } from '../../datetime';\nimport * as log from '../../log';\nimport { forEachLeaf } from '../../logical';\nimport { isPathMark } from '../../mark';\nimport { isFieldEqualPredicate, isFieldGTEPredicate, isFieldGTPredicate, isFieldLTEPredicate, isFieldLTPredicate, isFieldOneOfPredicate, isFieldPredicate, isFieldRangePredicate } from '../../predicate';\nimport { isSortField } from '../../sort';\nimport { accessPathDepth, accessPathWithDatum, duplicate, hash as _hash, keys, removePathFromField } from '../../util';\nimport { signalRefOrValue } from '../common';\nimport { isFacetModel, isUnitModel } from '../model';\nimport { Split } from '../split';\nimport { DataFlowNode } from './dataflow';\n/**\n * Remove quotes from a string.\n */\nfunction unquote(pattern) {\n  if (pattern.startsWith(\"'\") && pattern.endsWith(\"'\") || pattern.startsWith('\"') && pattern.endsWith('\"')) {\n    return pattern.slice(1, -1);\n  }\n  return pattern;\n}\n/**\n * @param field The field.\n * @param parse What to parse the field as.\n */\nfunction parseExpression(field, parse) {\n  var f = accessPathWithDatum(field);\n  if (parse === 'number') {\n    return \"toNumber(\".concat(f, \")\");\n  } else if (parse === 'boolean') {\n    return \"toBoolean(\".concat(f, \")\");\n  } else if (parse === 'string') {\n    return \"toString(\".concat(f, \")\");\n  } else if (parse === 'date') {\n    return \"toDate(\".concat(f, \")\");\n  } else if (parse === 'flatten') {\n    return f;\n  } else if (parse.startsWith('date:')) {\n    var specifier = unquote(parse.slice(5, parse.length));\n    return \"timeParse(\".concat(f, \",'\").concat(specifier, \"')\");\n  } else if (parse.startsWith('utc:')) {\n    var _specifier = unquote(parse.slice(4, parse.length));\n    return \"utcParse(\".concat(f, \",'\").concat(_specifier, \"')\");\n  } else {\n    log.warn(log.message.unrecognizedParse(parse));\n    return null;\n  }\n}\nexport function getImplicitFromFilterTransform(transform) {\n  var implicit = {};\n  forEachLeaf(transform.filter, function (filter) {\n    var _a;\n    if (isFieldPredicate(filter)) {\n      // Automatically add a parse node for filters with filter objects\n      var val = null;\n      // For EqualFilter, just use the equal property.\n      // For RangeFilter and OneOfFilter, all array members should have\n      // the same type, so we only use the first one.\n      if (isFieldEqualPredicate(filter)) {\n        val = signalRefOrValue(filter.equal);\n      } else if (isFieldLTEPredicate(filter)) {\n        val = signalRefOrValue(filter.lte);\n      } else if (isFieldLTPredicate(filter)) {\n        val = signalRefOrValue(filter.lt);\n      } else if (isFieldGTPredicate(filter)) {\n        val = signalRefOrValue(filter.gt);\n      } else if (isFieldGTEPredicate(filter)) {\n        val = signalRefOrValue(filter.gte);\n      } else if (isFieldRangePredicate(filter)) {\n        val = filter.range[0];\n      } else if (isFieldOneOfPredicate(filter)) {\n        val = ((_a = filter.oneOf) !== null && _a !== void 0 ? _a : filter['in'])[0];\n      } // else -- for filter expression, we can't infer anything\n      if (val) {\n        if (isDateTime(val)) {\n          implicit[filter.field] = 'date';\n        } else if (isNumber(val)) {\n          implicit[filter.field] = 'number';\n        } else if (isString(val)) {\n          implicit[filter.field] = 'string';\n        }\n      }\n      if (filter.timeUnit) {\n        implicit[filter.field] = 'date';\n      }\n    }\n  });\n  return implicit;\n}\n/**\n * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n */\nexport function getImplicitFromEncoding(model) {\n  var implicit = {};\n  function add(fieldDef) {\n    if (isFieldOrDatumDefForTimeFormat(fieldDef)) {\n      implicit[fieldDef.field] = 'date';\n    } else if (fieldDef.type === 'quantitative' && isMinMaxOp(fieldDef.aggregate) // we need to parse numbers to support correct min and max\n    ) {\n      implicit[fieldDef.field] = 'number';\n    } else if (accessPathDepth(fieldDef.field) > 1) {\n      // For non-date/non-number (strings and booleans), derive a flattened field for a referenced nested field.\n      // (Parsing numbers / dates already flattens numeric and temporal fields.)\n      if (!(fieldDef.field in implicit)) {\n        implicit[fieldDef.field] = 'flatten';\n      }\n    } else if (isScaleFieldDef(fieldDef) && isSortField(fieldDef.sort) && accessPathDepth(fieldDef.sort.field) > 1) {\n      // Flatten fields that we sort by but that are not otherwise flattened.\n      if (!(fieldDef.sort.field in implicit)) {\n        implicit[fieldDef.sort.field] = 'flatten';\n      }\n    }\n  }\n  if (isUnitModel(model) || isFacetModel(model)) {\n    // Parse encoded fields\n    model.forEachFieldDef(function (fieldDef, channel) {\n      if (isTypedFieldDef(fieldDef)) {\n        add(fieldDef);\n      } else {\n        var mainChannel = getMainRangeChannel(channel);\n        var mainFieldDef = model.fieldDef(mainChannel);\n        add(Object.assign(Object.assign({}, fieldDef), {\n          type: mainFieldDef.type\n        }));\n      }\n    });\n  }\n  // Parse quantitative dimension fields of path marks as numbers so that we sort them correctly.\n  if (isUnitModel(model)) {\n    var mark = model.mark,\n      markDef = model.markDef,\n      encoding = model.encoding;\n    if (isPathMark(mark) &&\n    // No need to sort by dimension if we have a connected scatterplot (order channel is present)\n    !model.encoding.order) {\n      var dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n      var dimensionChannelDef = encoding[dimensionChannel];\n      if (isFieldDef(dimensionChannelDef) && dimensionChannelDef.type === 'quantitative' && !(dimensionChannelDef.field in implicit)) {\n        implicit[dimensionChannelDef.field] = 'number';\n      }\n    }\n  }\n  return implicit;\n}\n/**\n * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n */\nexport function getImplicitFromSelection(model) {\n  var implicit = {};\n  if (isUnitModel(model) && model.component.selection) {\n    var _iterator = _createForOfIteratorHelper(keys(model.component.selection)),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var name = _step.value;\n        var selCmpt = model.component.selection[name];\n        var _iterator2 = _createForOfIteratorHelper(selCmpt.project.items),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var proj = _step2.value;\n            if (!proj.channel && accessPathDepth(proj.field) > 1) {\n              implicit[proj.field] = 'flatten';\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return implicit;\n}\nexport var ParseNode = /*#__PURE__*/function (_DataFlowNode) {\n  _inherits(ParseNode, _DataFlowNode);\n  var _super = _createSuper(ParseNode);\n  function ParseNode(parent, parse) {\n    var _this;\n    _classCallCheck(this, ParseNode);\n    _this = _super.call(this, parent);\n    _this._parse = parse;\n    return _this;\n  }\n  _createClass(ParseNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new ParseNode(null, duplicate(this._parse));\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"Parse \".concat(_hash(this._parse));\n    }\n    /**\n     * Creates a parse node from a data.format.parse and updates ancestorParse.\n     */\n  }, {\n    key: \"parse\",\n    get: function get() {\n      return this._parse;\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(other) {\n      this._parse = Object.assign(Object.assign({}, this._parse), other.parse);\n      other.remove();\n    }\n    /**\n     * Assemble an object for Vega's format.parse property.\n     */\n  }, {\n    key: \"assembleFormatParse\",\n    value: function assembleFormatParse() {\n      var formatParse = {};\n      var _iterator3 = _createForOfIteratorHelper(keys(this._parse)),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var field = _step3.value;\n          var p = this._parse[field];\n          if (accessPathDepth(field) === 1) {\n            formatParse[field] = p;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return formatParse;\n    }\n    // format parse depends and produces all fields in its parse\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set(keys(this._parse));\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return new Set(keys(this._parse));\n    }\n  }, {\n    key: \"assembleTransforms\",\n    value: function assembleTransforms() {\n      var _this2 = this;\n      var onlyNested = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return keys(this._parse).filter(function (field) {\n        return onlyNested ? accessPathDepth(field) > 1 : true;\n      }).map(function (field) {\n        var expr = parseExpression(field, _this2._parse[field]);\n        if (!expr) {\n          return null;\n        }\n        var formula = {\n          type: 'formula',\n          expr: expr,\n          as: removePathFromField(field) // Vega output is always flattened\n        };\n\n        return formula;\n      }).filter(function (t) {\n        return t !== null;\n      });\n    }\n  }], [{\n    key: \"makeExplicit\",\n    value: function makeExplicit(parent, model, ancestorParse) {\n      var _a;\n      // Custom parse\n      var explicit = {};\n      var data = model.data;\n      if (!isGenerator(data) && ((_a = data === null || data === void 0 ? void 0 : data.format) === null || _a === void 0 ? void 0 : _a.parse)) {\n        explicit = data.format.parse;\n      }\n      return this.makeWithAncestors(parent, explicit, {}, ancestorParse);\n    }\n    /**\n     * Creates a parse node from \"explicit\" parse and \"implicit\" parse and updates ancestorParse.\n     */\n  }, {\n    key: \"makeWithAncestors\",\n    value: function makeWithAncestors(parent, explicit, implicit, ancestorParse) {\n      // We should not parse what has already been parsed in a parent (explicitly or implicitly) or what has been derived (maked as \"derived\"). We also don't need to flatten a field that has already been parsed.\n      var _iterator4 = _createForOfIteratorHelper(keys(implicit)),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var field = _step4.value;\n          var parsedAs = ancestorParse.getWithExplicit(field);\n          if (parsedAs.value !== undefined) {\n            // We always ignore derived fields even if they are implicitly defined because we expect users to create the right types.\n            if (parsedAs.explicit || parsedAs.value === implicit[field] || parsedAs.value === 'derived' || implicit[field] === 'flatten') {\n              delete implicit[field];\n            } else {\n              log.warn(log.message.differentParse(field, implicit[field], parsedAs.value));\n            }\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      var _iterator5 = _createForOfIteratorHelper(keys(explicit)),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _field = _step5.value;\n          var _parsedAs = ancestorParse.get(_field);\n          if (_parsedAs !== undefined) {\n            // Don't parse a field again if it has been parsed with the same type already.\n            if (_parsedAs === explicit[_field]) {\n              delete explicit[_field];\n            } else {\n              log.warn(log.message.differentParse(_field, explicit[_field], _parsedAs));\n            }\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      var parse = new Split(explicit, implicit);\n      // add the format parse from this model so that children don't parse the same field again\n      ancestorParse.copyAll(parse);\n      // copy only non-null parses\n      var p = {};\n      var _iterator6 = _createForOfIteratorHelper(keys(parse.combine())),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var key = _step6.value;\n          var val = parse.get(key);\n          if (val !== null) {\n            p[key] = val;\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      if (keys(p).length === 0 || ancestorParse.parseNothing) {\n        return null;\n      }\n      return new ParseNode(parent, p);\n    }\n  }]);\n  return ParseNode;\n}(DataFlowNode);","map":{"version":3,"sources":["../../../../src/compile/data/formatparse.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isNumber, isString } from 'vega-util';\nimport { isMinMaxOp } from '../../aggregate';\nimport { getMainRangeChannel } from '../../channel';\nimport { isFieldDef, isFieldOrDatumDefForTimeFormat, isScaleFieldDef, isTypedFieldDef } from '../../channeldef';\nimport { isGenerator } from '../../data';\nimport { isDateTime } from '../../datetime';\nimport * as log from '../../log';\nimport { forEachLeaf } from '../../logical';\nimport { isPathMark } from '../../mark';\nimport { isFieldEqualPredicate, isFieldGTEPredicate, isFieldGTPredicate, isFieldLTEPredicate, isFieldLTPredicate, isFieldOneOfPredicate, isFieldPredicate, isFieldRangePredicate } from '../../predicate';\nimport { isSortField } from '../../sort';\nimport { accessPathDepth, accessPathWithDatum, duplicate, hash, keys, removePathFromField } from '../../util';\nimport { signalRefOrValue } from '../common';\nimport { isFacetModel, isUnitModel } from '../model';\nimport { Split } from '../split';\nimport { DataFlowNode } from './dataflow';\n/**\n * Remove quotes from a string.\n */\nfunction unquote(pattern) {\n    if ((pattern.startsWith(\"'\") && pattern.endsWith(\"'\")) || (pattern.startsWith('\"') && pattern.endsWith('\"'))) {\n        return pattern.slice(1, -1);\n    }\n    return pattern;\n}\n/**\n * @param field The field.\n * @param parse What to parse the field as.\n */\nfunction parseExpression(field, parse) {\n    const f = accessPathWithDatum(field);\n    if (parse === 'number') {\n        return `toNumber(${f})`;\n    }\n    else if (parse === 'boolean') {\n        return `toBoolean(${f})`;\n    }\n    else if (parse === 'string') {\n        return `toString(${f})`;\n    }\n    else if (parse === 'date') {\n        return `toDate(${f})`;\n    }\n    else if (parse === 'flatten') {\n        return f;\n    }\n    else if (parse.startsWith('date:')) {\n        const specifier = unquote(parse.slice(5, parse.length));\n        return `timeParse(${f},'${specifier}')`;\n    }\n    else if (parse.startsWith('utc:')) {\n        const specifier = unquote(parse.slice(4, parse.length));\n        return `utcParse(${f},'${specifier}')`;\n    }\n    else {\n        log.warn(log.message.unrecognizedParse(parse));\n        return null;\n    }\n}\nexport function getImplicitFromFilterTransform(transform) {\n    const implicit = {};\n    forEachLeaf(transform.filter, filter => {\n        var _a;\n        if (isFieldPredicate(filter)) {\n            // Automatically add a parse node for filters with filter objects\n            let val = null;\n            // For EqualFilter, just use the equal property.\n            // For RangeFilter and OneOfFilter, all array members should have\n            // the same type, so we only use the first one.\n            if (isFieldEqualPredicate(filter)) {\n                val = signalRefOrValue(filter.equal);\n            }\n            else if (isFieldLTEPredicate(filter)) {\n                val = signalRefOrValue(filter.lte);\n            }\n            else if (isFieldLTPredicate(filter)) {\n                val = signalRefOrValue(filter.lt);\n            }\n            else if (isFieldGTPredicate(filter)) {\n                val = signalRefOrValue(filter.gt);\n            }\n            else if (isFieldGTEPredicate(filter)) {\n                val = signalRefOrValue(filter.gte);\n            }\n            else if (isFieldRangePredicate(filter)) {\n                val = filter.range[0];\n            }\n            else if (isFieldOneOfPredicate(filter)) {\n                val = ((_a = filter.oneOf) !== null && _a !== void 0 ? _a : filter['in'])[0];\n            } // else -- for filter expression, we can't infer anything\n            if (val) {\n                if (isDateTime(val)) {\n                    implicit[filter.field] = 'date';\n                }\n                else if (isNumber(val)) {\n                    implicit[filter.field] = 'number';\n                }\n                else if (isString(val)) {\n                    implicit[filter.field] = 'string';\n                }\n            }\n            if (filter.timeUnit) {\n                implicit[filter.field] = 'date';\n            }\n        }\n    });\n    return implicit;\n}\n/**\n * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n */\nexport function getImplicitFromEncoding(model) {\n    const implicit = {};\n    function add(fieldDef) {\n        if (isFieldOrDatumDefForTimeFormat(fieldDef)) {\n            implicit[fieldDef.field] = 'date';\n        }\n        else if (fieldDef.type === 'quantitative' &&\n            isMinMaxOp(fieldDef.aggregate) // we need to parse numbers to support correct min and max\n        ) {\n            implicit[fieldDef.field] = 'number';\n        }\n        else if (accessPathDepth(fieldDef.field) > 1) {\n            // For non-date/non-number (strings and booleans), derive a flattened field for a referenced nested field.\n            // (Parsing numbers / dates already flattens numeric and temporal fields.)\n            if (!(fieldDef.field in implicit)) {\n                implicit[fieldDef.field] = 'flatten';\n            }\n        }\n        else if (isScaleFieldDef(fieldDef) && isSortField(fieldDef.sort) && accessPathDepth(fieldDef.sort.field) > 1) {\n            // Flatten fields that we sort by but that are not otherwise flattened.\n            if (!(fieldDef.sort.field in implicit)) {\n                implicit[fieldDef.sort.field] = 'flatten';\n            }\n        }\n    }\n    if (isUnitModel(model) || isFacetModel(model)) {\n        // Parse encoded fields\n        model.forEachFieldDef((fieldDef, channel) => {\n            if (isTypedFieldDef(fieldDef)) {\n                add(fieldDef);\n            }\n            else {\n                const mainChannel = getMainRangeChannel(channel);\n                const mainFieldDef = model.fieldDef(mainChannel);\n                add(Object.assign(Object.assign({}, fieldDef), { type: mainFieldDef.type }));\n            }\n        });\n    }\n    // Parse quantitative dimension fields of path marks as numbers so that we sort them correctly.\n    if (isUnitModel(model)) {\n        const { mark, markDef, encoding } = model;\n        if (isPathMark(mark) &&\n            // No need to sort by dimension if we have a connected scatterplot (order channel is present)\n            !model.encoding.order) {\n            const dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n            const dimensionChannelDef = encoding[dimensionChannel];\n            if (isFieldDef(dimensionChannelDef) &&\n                dimensionChannelDef.type === 'quantitative' &&\n                !(dimensionChannelDef.field in implicit)) {\n                implicit[dimensionChannelDef.field] = 'number';\n            }\n        }\n    }\n    return implicit;\n}\n/**\n * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n */\nexport function getImplicitFromSelection(model) {\n    const implicit = {};\n    if (isUnitModel(model) && model.component.selection) {\n        for (const name of keys(model.component.selection)) {\n            const selCmpt = model.component.selection[name];\n            for (const proj of selCmpt.project.items) {\n                if (!proj.channel && accessPathDepth(proj.field) > 1) {\n                    implicit[proj.field] = 'flatten';\n                }\n            }\n        }\n    }\n    return implicit;\n}\nexport class ParseNode extends DataFlowNode {\n    constructor(parent, parse) {\n        super(parent);\n        this._parse = parse;\n    }\n    clone() {\n        return new ParseNode(null, duplicate(this._parse));\n    }\n    hash() {\n        return `Parse ${hash(this._parse)}`;\n    }\n    /**\n     * Creates a parse node from a data.format.parse and updates ancestorParse.\n     */\n    static makeExplicit(parent, model, ancestorParse) {\n        var _a;\n        // Custom parse\n        let explicit = {};\n        const data = model.data;\n        if (!isGenerator(data) && ((_a = data === null || data === void 0 ? void 0 : data.format) === null || _a === void 0 ? void 0 : _a.parse)) {\n            explicit = data.format.parse;\n        }\n        return this.makeWithAncestors(parent, explicit, {}, ancestorParse);\n    }\n    /**\n     * Creates a parse node from \"explicit\" parse and \"implicit\" parse and updates ancestorParse.\n     */\n    static makeWithAncestors(parent, explicit, implicit, ancestorParse) {\n        // We should not parse what has already been parsed in a parent (explicitly or implicitly) or what has been derived (maked as \"derived\"). We also don't need to flatten a field that has already been parsed.\n        for (const field of keys(implicit)) {\n            const parsedAs = ancestorParse.getWithExplicit(field);\n            if (parsedAs.value !== undefined) {\n                // We always ignore derived fields even if they are implicitly defined because we expect users to create the right types.\n                if (parsedAs.explicit ||\n                    parsedAs.value === implicit[field] ||\n                    parsedAs.value === 'derived' ||\n                    implicit[field] === 'flatten') {\n                    delete implicit[field];\n                }\n                else {\n                    log.warn(log.message.differentParse(field, implicit[field], parsedAs.value));\n                }\n            }\n        }\n        for (const field of keys(explicit)) {\n            const parsedAs = ancestorParse.get(field);\n            if (parsedAs !== undefined) {\n                // Don't parse a field again if it has been parsed with the same type already.\n                if (parsedAs === explicit[field]) {\n                    delete explicit[field];\n                }\n                else {\n                    log.warn(log.message.differentParse(field, explicit[field], parsedAs));\n                }\n            }\n        }\n        const parse = new Split(explicit, implicit);\n        // add the format parse from this model so that children don't parse the same field again\n        ancestorParse.copyAll(parse);\n        // copy only non-null parses\n        const p = {};\n        for (const key of keys(parse.combine())) {\n            const val = parse.get(key);\n            if (val !== null) {\n                p[key] = val;\n            }\n        }\n        if (keys(p).length === 0 || ancestorParse.parseNothing) {\n            return null;\n        }\n        return new ParseNode(parent, p);\n    }\n    get parse() {\n        return this._parse;\n    }\n    merge(other) {\n        this._parse = Object.assign(Object.assign({}, this._parse), other.parse);\n        other.remove();\n    }\n    /**\n     * Assemble an object for Vega's format.parse property.\n     */\n    assembleFormatParse() {\n        const formatParse = {};\n        for (const field of keys(this._parse)) {\n            const p = this._parse[field];\n            if (accessPathDepth(field) === 1) {\n                formatParse[field] = p;\n            }\n        }\n        return formatParse;\n    }\n    // format parse depends and produces all fields in its parse\n    producedFields() {\n        return new Set(keys(this._parse));\n    }\n    dependentFields() {\n        return new Set(keys(this._parse));\n    }\n    assembleTransforms(onlyNested = false) {\n        return keys(this._parse)\n            .filter(field => (onlyNested ? accessPathDepth(field) > 1 : true))\n            .map(field => {\n            const expr = parseExpression(field, this._parse[field]);\n            if (!expr) {\n                return null;\n            }\n            const formula = {\n                type: 'formula',\n                expr,\n                as: removePathFromField(field) // Vega output is always flattened\n            };\n            return formula;\n        })\n            .filter(t => t !== null);\n    }\n}\n//# sourceMappingURL=formatparse.js.map"]},"metadata":{},"sourceType":"module"}